/* wsdlC.cpp
   Generated by gSOAP 2.8.50 for wsdl.h

gSOAP XML Web services tools
Copyright (C) 2000-2017, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "wsdlH.h"

SOAP_SOURCE_STAMP("@(#) wsdlC.cpp ver 2.8.50 2017-07-24 00:46:15 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->version && soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, ""))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->version && soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (soap->header == NULL)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (soap->fault == NULL)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap);
		if (soap->fault == NULL)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", "");
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
			return soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
		return NULL;
	}
	return soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)(void*)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Detail == NULL)
		{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap);
			soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Detail->__any;
	}
	if (soap->fault->detail == NULL)
	{	soap->fault->detail = soap_new_SOAP_ENV__Detail(soap);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
	}
	return (const char**)(void*)&soap->fault->detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Detail)
		return soap->fault->SOAP_ENV__Detail->__any;
	if (soap->fault->detail)
		return soap->fault->detail->__any;
	return NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if ((soap->error && soap->error != SOAP_TAG_MISMATCH) || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
#ifndef WITH_NOIDREF
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_sd__mutability:
		return soap_in_sd__mutability(soap, NULL, NULL, "sd:mutability");
	case SOAP_TYPE_soap__useChoice:
		return soap_in_soap__useChoice(soap, NULL, NULL, "soap:useChoice");
	case SOAP_TYPE_soap__styleChoice:
		return soap_in_soap__styleChoice(soap, NULL, NULL, "soap:styleChoice");
	case SOAP_TYPE_wadl__ParamStyle:
		return soap_in_wadl__ParamStyle(soap, NULL, NULL, "wadl:ParamStyle");
	case SOAP_TYPE_wadl__HTTPMethods:
		return soap_in_wadl__HTTPMethods(soap, NULL, NULL, "wadl:HTTPMethods");
	case SOAP_TYPE_xs__processContents:
		return soap_in_xs__processContents(soap, NULL, NULL, "xs:processContents");
	case SOAP_TYPE_xs__attribute_use:
		return soap_in_xs__attribute_use(soap, NULL, NULL, "xs:attribute-use");
	case SOAP_TYPE_xs__formChoice:
		return soap_in_xs__formChoice(soap, NULL, NULL, "xs:formChoice");
	case SOAP_TYPE_xsd__boolean:
		return soap_in_xsd__boolean(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_bool:
		return soap_in_bool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_wsdl__service:
		return soap_in_wsdl__service(soap, NULL, NULL, "wsdl:service");
	case SOAP_TYPE_wsdl__port:
		return soap_in_wsdl__port(soap, NULL, NULL, "wsdl:port");
	case SOAP_TYPE_wsdl__binding:
		return soap_in_wsdl__binding(soap, NULL, NULL, "wsdl:binding");
	case SOAP_TYPE_wsdl__ext_operation:
		return soap_in_wsdl__ext_operation(soap, NULL, NULL, "wsdl:ext-operation");
	case SOAP_TYPE_wsdl__ext_fault:
		return soap_in_wsdl__ext_fault(soap, NULL, NULL, "wsdl:ext-fault");
	case SOAP_TYPE_wsdl__ext_ioput:
		return soap_in_wsdl__ext_ioput(soap, NULL, NULL, "wsdl:ext-ioput");
	case SOAP_TYPE_wsdl__fault:
		return soap_in_wsdl__fault(soap, NULL, NULL, "wsdl:fault");
	case SOAP_TYPE_wsdl__ioput:
		return soap_in_wsdl__ioput(soap, NULL, NULL, "wsdl:ioput");
	case SOAP_TYPE_wsdl__types:
		return soap_in_wsdl__types(soap, NULL, NULL, "wsdl:types");
	case SOAP_TYPE_wsdl__import:
		return soap_in_wsdl__import(soap, NULL, NULL, "wsdl:import");
	case SOAP_TYPE_vprop__tPropertyAlias:
		return soap_in_vprop__tPropertyAlias(soap, NULL, NULL, "vprop:tPropertyAlias");
	case SOAP_TYPE_vprop__tProperty:
		return soap_in_vprop__tProperty(soap, NULL, NULL, "vprop:tProperty");
	case SOAP_TYPE_vprop__tQuery:
		return soap_in_vprop__tQuery(soap, NULL, NULL, "vprop:tQuery");
	case SOAP_TYPE_plnk__tRole:
		return soap_in_plnk__tRole(soap, NULL, NULL, "plnk:tRole");
	case SOAP_TYPE_plnk__tPartnerLinkType:
		return soap_in_plnk__tPartnerLinkType(soap, NULL, NULL, "plnk:tPartnerLinkType");
	case SOAP_TYPE_wsdl__portType:
		return soap_in_wsdl__portType(soap, NULL, NULL, "wsdl:portType");
	case SOAP_TYPE_wsp__PolicyAttachment:
		return soap_in_wsp__PolicyAttachment(soap, NULL, NULL, "wsp:PolicyAttachment");
	case SOAP_TYPE_wsp__AppliesTo:
		return soap_in_wsp__AppliesTo(soap, NULL, NULL, "wsp:AppliesTo");
	case SOAP_TYPE_wsp__Attachment:
		return soap_in_wsp__Attachment(soap, NULL, NULL, "wsp:Attachment");
	case SOAP_TYPE_wsrmp5__RMAssertion:
		return soap_in_wsrmp5__RMAssertion(soap, NULL, NULL, "wsrmp5:RMAssertion");
	case SOAP_TYPE_wsrmp5__Timeout:
		return soap_in_wsrmp5__Timeout(soap, NULL, NULL, "wsrmp5:Timeout");
	case SOAP_TYPE_wsrmp__RMAssertion:
		return soap_in_wsrmp__RMAssertion(soap, NULL, NULL, "wsrmp:RMAssertion");
	case SOAP_TYPE_wsrmp__Timeout:
		return soap_in_wsrmp__Timeout(soap, NULL, NULL, "wsrmp:Timeout");
	case SOAP_TYPE_sp__Token:
		return soap_in_sp__Token(soap, NULL, NULL, "sp:Token");
	case SOAP_TYPE_sp__Elements:
		return soap_in_sp__Elements(soap, NULL, NULL, "sp:Elements");
	case SOAP_TYPE_sp__Parts:
		return soap_in_sp__Parts(soap, NULL, NULL, "sp:Parts");
	case SOAP_TYPE_sp__Header:
		return soap_in_sp__Header(soap, NULL, NULL, "sp:Header");
	case SOAP_TYPE_wst__Claims:
		return soap_in_wst__Claims(soap, NULL, NULL, "wst:Claims");
	case SOAP_TYPE_wsp__Assertion:
		return soap_in_wsp__Assertion(soap, NULL, NULL, "wsp:Assertion");
	case SOAP_TYPE_wsp__PolicyReference:
		return soap_in_wsp__PolicyReference(soap, NULL, NULL, "wsp:PolicyReference");
	case SOAP_TYPE_wsp__Content:
		return soap_in_wsp__Content(soap, NULL, NULL, "wsp:Content");
	case SOAP_TYPE_wsp__Policy:
		return soap_in_wsp__Policy(soap, NULL, NULL, "wsp:Policy");
	case SOAP_TYPE_wsa__EndpointReferenceType:
		return soap_in_wsa__EndpointReferenceType(soap, NULL, NULL, "wsa:EndpointReferenceType");
	case SOAP_TYPE_gwsdl__portType:
		return soap_in_gwsdl__portType(soap, NULL, NULL, "gwsdl:portType");
	case SOAP_TYPE_sd__staticServiceDataValues:
		return soap_in_sd__staticServiceDataValues(soap, NULL, NULL, "sd:staticServiceDataValues");
	case SOAP_TYPE_sd__serviceData:
		return soap_in_sd__serviceData(soap, NULL, NULL, "sd:serviceData");
	case SOAP_TYPE_wsdl__operation:
		return soap_in_wsdl__operation(soap, NULL, NULL, "wsdl:operation");
	case SOAP_TYPE_whttp__header:
		return soap_in_whttp__header(soap, NULL, NULL, "whttp:header");
	case SOAP_TYPE_http__operation:
		return soap_in_http__operation(soap, NULL, NULL, "http:operation");
	case SOAP_TYPE_http__binding:
		return soap_in_http__binding(soap, NULL, NULL, "http:binding");
	case SOAP_TYPE_http__address:
		return soap_in_http__address(soap, NULL, NULL, "http:address");
	case SOAP_TYPE_dime__message:
		return soap_in_dime__message(soap, NULL, NULL, "dime:message");
	case SOAP_TYPE_mime__mimeXml:
		return soap_in_mime__mimeXml(soap, NULL, NULL, "mime:mimeXml");
	case SOAP_TYPE_mime__multipartRelated:
		return soap_in_mime__multipartRelated(soap, NULL, NULL, "mime:multipartRelated");
	case SOAP_TYPE_mime__part:
		return soap_in_mime__part(soap, NULL, NULL, "mime:part");
	case SOAP_TYPE_mime__content:
		return soap_in_mime__content(soap, NULL, NULL, "mime:content");
	case SOAP_TYPE_wsoap__header:
		return soap_in_wsoap__header(soap, NULL, NULL, "wsoap:header");
	case SOAP_TYPE_wsoap__module:
		return soap_in_wsoap__module(soap, NULL, NULL, "wsoap:module");
	case SOAP_TYPE_soap__address:
		return soap_in_soap__address(soap, NULL, NULL, "soap:address");
	case SOAP_TYPE_soap__header:
		return soap_in_soap__header(soap, NULL, NULL, "soap:header");
	case SOAP_TYPE_soap__headerfault:
		return soap_in_soap__headerfault(soap, NULL, NULL, "soap:headerfault");
	case SOAP_TYPE_soap__fault:
		return soap_in_soap__fault(soap, NULL, NULL, "soap:fault");
	case SOAP_TYPE_soap__body:
		return soap_in_soap__body(soap, NULL, NULL, "soap:body");
	case SOAP_TYPE_soap__operation:
		return soap_in_soap__operation(soap, NULL, NULL, "soap:operation");
	case SOAP_TYPE_soap__binding:
		return soap_in_soap__binding(soap, NULL, NULL, "soap:binding");
	case SOAP_TYPE_wsdl__part:
		return soap_in_wsdl__part(soap, NULL, NULL, "wsdl:part");
	case SOAP_TYPE_wsdl__message:
		return soap_in_wsdl__message(soap, NULL, NULL, "wsdl:message");
	case SOAP_TYPE_wadl__application:
		return soap_in_wadl__application(soap, NULL, NULL, "wadl:application");
	case SOAP_TYPE_wadl__resources:
		return soap_in_wadl__resources(soap, NULL, NULL, "wadl:resources");
	case SOAP_TYPE_wadl__method:
		return soap_in_wadl__method(soap, NULL, NULL, "wadl:method");
	case SOAP_TYPE_wadl__response:
		return soap_in_wadl__response(soap, NULL, NULL, "wadl:response");
	case SOAP_TYPE_wadl__request:
		return soap_in_wadl__request(soap, NULL, NULL, "wadl:request");
	case SOAP_TYPE_wadl__representation:
		return soap_in_wadl__representation(soap, NULL, NULL, "wadl:representation");
	case SOAP_TYPE_wadl__grammars:
		return soap_in_wadl__grammars(soap, NULL, NULL, "wadl:grammars");
	case SOAP_TYPE_wadl__include:
		return soap_in_wadl__include(soap, NULL, NULL, "wadl:include");
	case SOAP_TYPE_wadl__param:
		return soap_in_wadl__param(soap, NULL, NULL, "wadl:param");
	case SOAP_TYPE_wadl__link:
		return soap_in_wadl__link(soap, NULL, NULL, "wadl:link");
	case SOAP_TYPE_wadl__option:
		return soap_in_wadl__option(soap, NULL, NULL, "wadl:option");
	case SOAP_TYPE_wadl__doc:
		return soap_in_wadl__doc(soap, NULL, NULL, "wadl:doc");
	case SOAP_TYPE_wadl__resource_USCOREtype:
		return soap_in_wadl__resource_USCOREtype(soap, NULL, NULL, "wadl:resource_type");
	case SOAP_TYPE_wadl__resource:
		return soap_in_wadl__resource(soap, NULL, NULL, "wadl:resource");
	case SOAP_TYPE_xs__redefine:
		return soap_in_xs__redefine(soap, NULL, NULL, "xs:redefine");
	case SOAP_TYPE_xs__override:
		return soap_in_xs__override(soap, NULL, NULL, "xs:override");
	case SOAP_TYPE_xs__include:
		return soap_in_xs__include(soap, NULL, NULL, "xs:include");
	case SOAP_TYPE_xs__import:
		return soap_in_xs__import(soap, NULL, NULL, "xs:import");
	case SOAP_TYPE_xs__complexContent:
		return soap_in_xs__complexContent(soap, NULL, NULL, "xs:complexContent");
	case SOAP_TYPE_xs__whiteSpace:
		return soap_in_xs__whiteSpace(soap, NULL, NULL, "xs:whiteSpace");
	case SOAP_TYPE_xs__length:
		return soap_in_xs__length(soap, NULL, NULL, "xs:length");
	case SOAP_TYPE_xs__simpleContent:
		return soap_in_xs__simpleContent(soap, NULL, NULL, "xs:simpleContent");
	case SOAP_TYPE_xs__pattern:
		return soap_in_xs__pattern(soap, NULL, NULL, "xs:pattern");
	case SOAP_TYPE_xs__enumeration:
		return soap_in_xs__enumeration(soap, NULL, NULL, "xs:enumeration");
	case SOAP_TYPE_xs__attributeGroup:
		return soap_in_xs__attributeGroup(soap, NULL, NULL, "xs:attributeGroup");
	case SOAP_TYPE_xs__anyAttribute:
		return soap_in_xs__anyAttribute(soap, NULL, NULL, "xs:anyAttribute");
	case SOAP_TYPE_xs__contents:
		return soap_in_xs__contents(soap, NULL, NULL, "xs:contents");
	case SOAP_TYPE_xs__any:
		return soap_in_xs__any(soap, NULL, NULL, "xs:any");
	case SOAP_TYPE_xs__all:
		return soap_in_xs__all(soap, NULL, NULL, "xs:all");
	case SOAP_TYPE_xs__attribute:
		return soap_in_xs__attribute(soap, NULL, NULL, "xs:attribute");
	case SOAP_TYPE_xs__element:
		return soap_in_xs__element(soap, NULL, NULL, "xs:element");
	case SOAP_TYPE_xs__alternative:
		return soap_in_xs__alternative(soap, NULL, NULL, "xs:alternative");
	case SOAP_TYPE_xs__assert:
		return soap_in_xs__assert(soap, NULL, NULL, "xs:assert");
	case SOAP_TYPE_xs__annotation:
		return soap_in_xs__annotation(soap, NULL, NULL, "xs:annotation");
	case SOAP_TYPE_xs__union:
		return soap_in_xs__union(soap, NULL, NULL, "xs:union");
	case SOAP_TYPE_xs__list:
		return soap_in_xs__list(soap, NULL, NULL, "xs:list");
	case SOAP_TYPE_xs__group:
		return soap_in_xs__group(soap, NULL, NULL, "xs:group");
	case SOAP_TYPE_xs__seqchoice:
		return soap_in_xs__seqchoice(soap, NULL, NULL, "xs:seqchoice");
	case SOAP_TYPE_xs__restriction:
		return soap_in_xs__restriction(soap, NULL, NULL, "xs:restriction");
	case SOAP_TYPE_xs__extension:
		return soap_in_xs__extension(soap, NULL, NULL, "xs:extension");
	case SOAP_TYPE_xs__complexType:
		return soap_in_xs__complexType(soap, NULL, NULL, "xs:complexType");
	case SOAP_TYPE_xs__simpleType:
		return soap_in_xs__simpleType(soap, NULL, NULL, "xs:simpleType");
	case SOAP_TYPE_xs__schema:
		return soap_in_xs__schema(soap, NULL, NULL, "xs:schema");
	case SOAP_TYPE_wsdl__definitions:
		return soap_in_wsdl__definitions(soap, NULL, NULL, "wsdl:definitions");
	case SOAP_TYPE_PointerTowadl__application:
		return soap_in_PointerTowadl__application(soap, NULL, NULL, "wadl:application");
	case SOAP_TYPE_PointerTowsdl__types:
		return soap_in_PointerTowsdl__types(soap, NULL, NULL, "wsdl:types");
	case SOAP_TYPE_PointerTowsdl__binding:
		return soap_in_PointerTowsdl__binding(soap, NULL, NULL, "wsdl:binding");
	case SOAP_TYPE_PointerTohttp__address:
		return soap_in_PointerTohttp__address(soap, NULL, NULL, "http:address");
	case SOAP_TYPE_PointerTosoap__address:
		return soap_in_PointerTosoap__address(soap, NULL, NULL, "soap:address");
	case SOAP_TYPE_PointerToxsd__string:
		return soap_in_PointerToxsd__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerTohttp__binding:
		return soap_in_PointerTohttp__binding(soap, NULL, NULL, "http:binding");
	case SOAP_TYPE_PointerTosoap__binding:
		return soap_in_PointerTosoap__binding(soap, NULL, NULL, "soap:binding");
	case SOAP_TYPE_PointerTowsdl__ext_ioput:
		return soap_in_PointerTowsdl__ext_ioput(soap, NULL, NULL, "wsdl:ext-ioput");
	case SOAP_TYPE_PointerTohttp__operation:
		return soap_in_PointerTohttp__operation(soap, NULL, NULL, "http:operation");
	case SOAP_TYPE_PointerTosoap__operation:
		return soap_in_PointerTosoap__operation(soap, NULL, NULL, "soap:operation");
	case SOAP_TYPE_PointerTowsdl__fault:
		return soap_in_PointerTowsdl__fault(soap, NULL, NULL, "wsdl:fault");
	case SOAP_TYPE_PointerTosoap__fault:
		return soap_in_PointerTosoap__fault(soap, NULL, NULL, "soap:fault");
	case SOAP_TYPE_PointerTomime__mimeXml:
		return soap_in_PointerTomime__mimeXml(soap, NULL, NULL, "mime:mimeXml");
	case SOAP_TYPE_PointerTomime__content:
		return soap_in_PointerTomime__content(soap, NULL, NULL, "mime:content");
	case SOAP_TYPE_PointerTomime__multipartRelated:
		return soap_in_PointerTomime__multipartRelated(soap, NULL, NULL, "mime:multipartRelated");
	case SOAP_TYPE_PointerTodime__message:
		return soap_in_PointerTodime__message(soap, NULL, NULL, "dime:message");
	case SOAP_TYPE_PointerTowsdl__ioput:
		return soap_in_PointerTowsdl__ioput(soap, NULL, NULL, "wsdl:ioput");
	case SOAP_TYPE_PointerTowsdl__definitions:
		return soap_in_PointerTowsdl__definitions(soap, NULL, NULL, "wsdl:definitions");
	case SOAP_TYPE_PointerTovprop__tProperty:
		return soap_in_PointerTovprop__tProperty(soap, NULL, NULL, "vprop:tProperty");
	case SOAP_TYPE_PointerTovprop__tQuery:
		return soap_in_PointerTovprop__tQuery(soap, NULL, NULL, "vprop:tQuery");
	case SOAP_TYPE_PointerToplnk__tPartnerLinkType:
		return soap_in_PointerToplnk__tPartnerLinkType(soap, NULL, NULL, "plnk:tPartnerLinkType");
	case SOAP_TYPE_PointerTowsdl__portType:
		return soap_in_PointerTowsdl__portType(soap, NULL, NULL, "wsdl:portType");
	case SOAP_TYPE_PointerTowsp__AppliesTo:
		return soap_in_PointerTowsp__AppliesTo(soap, NULL, NULL, "wsp:AppliesTo");
	case SOAP_TYPE_PointerTowsrmp5__RMAssertion:
		return soap_in_PointerTowsrmp5__RMAssertion(soap, NULL, NULL, "wsrmp5:RMAssertion");
	case SOAP_TYPE_PointerTowsrmp__RMAssertion:
		return soap_in_PointerTowsrmp__RMAssertion(soap, NULL, NULL, "wsrmp:RMAssertion");
	case SOAP_TYPE_PointerTowsp__Assertion:
		return soap_in_PointerTowsp__Assertion(soap, NULL, NULL, "wsp:Assertion");
	case SOAP_TYPE_PointerTosp__Token:
		return soap_in_PointerTosp__Token(soap, NULL, NULL, "sp:Token");
	case SOAP_TYPE_PointerTosp__Elements:
		return soap_in_PointerTosp__Elements(soap, NULL, NULL, "sp:Elements");
	case SOAP_TYPE_PointerTowsp__PolicyReference:
		return soap_in_PointerTowsp__PolicyReference(soap, NULL, NULL, "wsp:PolicyReference");
	case SOAP_TYPE_PointerTowsrmp5__Timeout:
		return soap_in_PointerTowsrmp5__Timeout(soap, NULL, NULL, "wsrmp5:Timeout");
	case SOAP_TYPE_PointerTowsrmp__Timeout:
		return soap_in_PointerTowsrmp__Timeout(soap, NULL, NULL, "wsrmp:Timeout");
	case SOAP_TYPE_PointerTowst__Claims:
		return soap_in_PointerTowst__Claims(soap, NULL, NULL, "wst:Claims");
	case SOAP_TYPE_PointerTowsa__EndpointReferenceType:
		return soap_in_PointerTowsa__EndpointReferenceType(soap, NULL, NULL, "wsa:EndpointReferenceType");
	case SOAP_TYPE_PointerTowsp__Content:
		return soap_in_PointerTowsp__Content(soap, NULL, NULL, "wsp:Content");
	case SOAP_TYPE_PointerTowsp__Policy:
		return soap_in_PointerTowsp__Policy(soap, NULL, NULL, "wsp:Policy");
	case SOAP_TYPE_PointerTosd__staticServiceDataValues:
		return soap_in_PointerTosd__staticServiceDataValues(soap, NULL, NULL, "sd:staticServiceDataValues");
	case SOAP_TYPE_PointerTowsdl__operation:
		return soap_in_PointerTowsdl__operation(soap, NULL, NULL, "wsdl:operation");
	case SOAP_TYPE_PointerTosoap__body:
		return soap_in_PointerTosoap__body(soap, NULL, NULL, "soap:body");
	case SOAP_TYPE_PointerTowsdl__part:
		return soap_in_PointerTowsdl__part(soap, NULL, NULL, "wsdl:part");
	case SOAP_TYPE_PointerTowsdl__message:
		return soap_in_PointerTowsdl__message(soap, NULL, NULL, "wsdl:message");
	case SOAP_TYPE_PointerTosoap__styleChoice:
		return soap_in_PointerTosoap__styleChoice(soap, NULL, NULL, "soap:styleChoice");
	case SOAP_TYPE_PointerTowadl__grammars:
		return soap_in_PointerTowadl__grammars(soap, NULL, NULL, "wadl:grammars");
	case SOAP_TYPE_PointerTowadl__resource:
		return soap_in_PointerTowadl__resource(soap, NULL, NULL, "wadl:resource");
	case SOAP_TYPE_PointerTowadl__method:
		return soap_in_PointerTowadl__method(soap, NULL, NULL, "wadl:method");
	case SOAP_TYPE_PointerTowadl__request:
		return soap_in_PointerTowadl__request(soap, NULL, NULL, "wadl:request");
	case SOAP_TYPE_PointerTowadl__representation:
		return soap_in_PointerTowadl__representation(soap, NULL, NULL, "wadl:representation");
	case SOAP_TYPE_PointerTowadl__param:
		return soap_in_PointerTowadl__param(soap, NULL, NULL, "wadl:param");
	case SOAP_TYPE_PointerTowadl__link:
		return soap_in_PointerTowadl__link(soap, NULL, NULL, "wadl:link");
	case SOAP_TYPE_PointerTowadl__ParamStyle:
		return soap_in_PointerTowadl__ParamStyle(soap, NULL, NULL, "wadl:ParamStyle");
	case SOAP_TYPE_PointerTowadl__resource_USCOREtype:
		return soap_in_PointerTowadl__resource_USCOREtype(soap, NULL, NULL, "wadl:resource_type");
	case SOAP_TYPE_wadl__statusCodeList:
	{	char **s;
		s = soap_in_wadl__statusCodeList(soap, NULL, NULL, "wadl:statusCodeList");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_PointerToxs__complexContent:
		return soap_in_PointerToxs__complexContent(soap, NULL, NULL, "xs:complexContent");
	case SOAP_TYPE_PointerToxs__simpleContent:
		return soap_in_PointerToxs__simpleContent(soap, NULL, NULL, "xs:simpleContent");
	case SOAP_TYPE_PointerToxs__assert:
		return soap_in_PointerToxs__assert(soap, NULL, NULL, "xs:assert");
	case SOAP_TYPE_PointerToxs__length:
		return soap_in_PointerToxs__length(soap, NULL, NULL, "xs:length");
	case SOAP_TYPE_PointerToxs__whiteSpace:
		return soap_in_PointerToxs__whiteSpace(soap, NULL, NULL, "xs:whiteSpace");
	case SOAP_TYPE_PointerToxs__union:
		return soap_in_PointerToxs__union(soap, NULL, NULL, "xs:union");
	case SOAP_TYPE_PointerToxs__list:
		return soap_in_PointerToxs__list(soap, NULL, NULL, "xs:list");
	case SOAP_TYPE_PointerToxs__restriction:
		return soap_in_PointerToxs__restriction(soap, NULL, NULL, "xs:restriction");
	case SOAP_TYPE_PointerToxs__extension:
		return soap_in_PointerToxs__extension(soap, NULL, NULL, "xs:extension");
	case SOAP_TYPE_PointerToxs__attributeGroup:
		return soap_in_PointerToxs__attributeGroup(soap, NULL, NULL, "xs:attributeGroup");
	case SOAP_TYPE_PointerToxs__anyAttribute:
		return soap_in_PointerToxs__anyAttribute(soap, NULL, NULL, "xs:anyAttribute");
	case SOAP_TYPE_PointerToxs__all:
		return soap_in_PointerToxs__all(soap, NULL, NULL, "xs:all");
	case SOAP_TYPE_PointerToxs__any:
		return soap_in_PointerToxs__any(soap, NULL, NULL, "xs:any");
	case SOAP_TYPE_PointerToxs__seqchoice:
		return soap_in_PointerToxs__seqchoice(soap, NULL, NULL, "xs:seqchoice");
	case SOAP_TYPE_PointerToxs__group:
		return soap_in_PointerToxs__group(soap, NULL, NULL, "xs:group");
	case SOAP_TYPE_xs__namespaceList:
	{	char **s;
		s = soap_in_xs__namespaceList(soap, NULL, NULL, "xs:namespaceList");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_PointerToxs__attribute:
		return soap_in_PointerToxs__attribute(soap, NULL, NULL, "xs:attribute");
	case SOAP_TYPE_PointerToxs__element:
		return soap_in_PointerToxs__element(soap, NULL, NULL, "xs:element");
	case SOAP_TYPE_PointerToxs__schema:
		return soap_in_PointerToxs__schema(soap, NULL, NULL, "xs:schema");
	case SOAP_TYPE_PointerToxs__complexType:
		return soap_in_PointerToxs__complexType(soap, NULL, NULL, "xs:complexType");
	case SOAP_TYPE_PointerToxs__simpleType:
		return soap_in_PointerToxs__simpleType(soap, NULL, NULL, "xs:simpleType");
	case SOAP_TYPE_PointerToxs__formChoice:
		return soap_in_PointerToxs__formChoice(soap, NULL, NULL, "xs:formChoice");
	case SOAP_TYPE_PointerToxs__annotation:
		return soap_in_PointerToxs__annotation(soap, NULL, NULL, "xs:annotation");
	case SOAP_TYPE_xsd__string:
	{	char **s;
		s = soap_in_xsd__string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__token:
	{	char **s;
		s = soap_in_xsd__token(soap, NULL, NULL, "xsd:token");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__QName:
	{	char **s;
		s = soap_in_xsd__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__NMTOKENS:
	{	char **s;
		s = soap_in_xsd__NMTOKENS(soap, NULL, NULL, "xsd:NMTOKENS");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__NMTOKEN:
	{	char **s;
		s = soap_in_xsd__NMTOKEN(soap, NULL, NULL, "xsd:NMTOKEN");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__NCName:
	{	char **s;
		s = soap_in_xsd__NCName(soap, NULL, NULL, "xsd:NCName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__ID:
	{	char **s;
		s = soap_in_xsd__ID(soap, NULL, NULL, "xsd:ID");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__anyURI:
	{	char **s;
		s = soap_in_xsd__anyURI(soap, NULL, NULL, "xsd:anyURI");
		return s ? *s : NULL;
	}
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
#else
	*type = 0;
#endif
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "wsdl:service"))
		{	*type = SOAP_TYPE_wsdl__service;
			return soap_in_wsdl__service(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsdl:port"))
		{	*type = SOAP_TYPE_wsdl__port;
			return soap_in_wsdl__port(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsdl:binding"))
		{	*type = SOAP_TYPE_wsdl__binding;
			return soap_in_wsdl__binding(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsdl:ext-operation"))
		{	*type = SOAP_TYPE_wsdl__ext_operation;
			return soap_in_wsdl__ext_operation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsdl:ext-fault"))
		{	*type = SOAP_TYPE_wsdl__ext_fault;
			return soap_in_wsdl__ext_fault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsdl:ext-ioput"))
		{	*type = SOAP_TYPE_wsdl__ext_ioput;
			return soap_in_wsdl__ext_ioput(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsdl:fault"))
		{	*type = SOAP_TYPE_wsdl__fault;
			return soap_in_wsdl__fault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsdl:ioput"))
		{	*type = SOAP_TYPE_wsdl__ioput;
			return soap_in_wsdl__ioput(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsdl:types"))
		{	*type = SOAP_TYPE_wsdl__types;
			return soap_in_wsdl__types(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsdl:import"))
		{	*type = SOAP_TYPE_wsdl__import;
			return soap_in_wsdl__import(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "vprop:tPropertyAlias"))
		{	*type = SOAP_TYPE_vprop__tPropertyAlias;
			return soap_in_vprop__tPropertyAlias(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "vprop:tProperty"))
		{	*type = SOAP_TYPE_vprop__tProperty;
			return soap_in_vprop__tProperty(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "vprop:tQuery"))
		{	*type = SOAP_TYPE_vprop__tQuery;
			return soap_in_vprop__tQuery(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "plnk:tRole"))
		{	*type = SOAP_TYPE_plnk__tRole;
			return soap_in_plnk__tRole(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "plnk:tPartnerLinkType"))
		{	*type = SOAP_TYPE_plnk__tPartnerLinkType;
			return soap_in_plnk__tPartnerLinkType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsdl:portType"))
		{	*type = SOAP_TYPE_wsdl__portType;
			return soap_in_wsdl__portType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsp:PolicyAttachment"))
		{	*type = SOAP_TYPE_wsp__PolicyAttachment;
			return soap_in_wsp__PolicyAttachment(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsp:AppliesTo"))
		{	*type = SOAP_TYPE_wsp__AppliesTo;
			return soap_in_wsp__AppliesTo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsp:Attachment"))
		{	*type = SOAP_TYPE_wsp__Attachment;
			return soap_in_wsp__Attachment(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrmp5:RMAssertion"))
		{	*type = SOAP_TYPE_wsrmp5__RMAssertion;
			return soap_in_wsrmp5__RMAssertion(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrmp5:Timeout"))
		{	*type = SOAP_TYPE_wsrmp5__Timeout;
			return soap_in_wsrmp5__Timeout(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrmp:RMAssertion"))
		{	*type = SOAP_TYPE_wsrmp__RMAssertion;
			return soap_in_wsrmp__RMAssertion(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrmp:Timeout"))
		{	*type = SOAP_TYPE_wsrmp__Timeout;
			return soap_in_wsrmp__Timeout(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "sp:Token"))
		{	*type = SOAP_TYPE_sp__Token;
			return soap_in_sp__Token(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "sp:Elements"))
		{	*type = SOAP_TYPE_sp__Elements;
			return soap_in_sp__Elements(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "sp:Parts"))
		{	*type = SOAP_TYPE_sp__Parts;
			return soap_in_sp__Parts(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "sp:Header"))
		{	*type = SOAP_TYPE_sp__Header;
			return soap_in_sp__Header(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wst:Claims"))
		{	*type = SOAP_TYPE_wst__Claims;
			return soap_in_wst__Claims(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsp:Assertion"))
		{	*type = SOAP_TYPE_wsp__Assertion;
			return soap_in_wsp__Assertion(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsp:PolicyReference"))
		{	*type = SOAP_TYPE_wsp__PolicyReference;
			return soap_in_wsp__PolicyReference(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsp:Content"))
		{	*type = SOAP_TYPE_wsp__Content;
			return soap_in_wsp__Content(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsp:Policy"))
		{	*type = SOAP_TYPE_wsp__Policy;
			return soap_in_wsp__Policy(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa:EndpointReferenceType"))
		{	*type = SOAP_TYPE_wsa__EndpointReferenceType;
			return soap_in_wsa__EndpointReferenceType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "gwsdl:portType"))
		{	*type = SOAP_TYPE_gwsdl__portType;
			return soap_in_gwsdl__portType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "sd:staticServiceDataValues"))
		{	*type = SOAP_TYPE_sd__staticServiceDataValues;
			return soap_in_sd__staticServiceDataValues(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "sd:serviceData"))
		{	*type = SOAP_TYPE_sd__serviceData;
			return soap_in_sd__serviceData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsdl:operation"))
		{	*type = SOAP_TYPE_wsdl__operation;
			return soap_in_wsdl__operation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "whttp:header"))
		{	*type = SOAP_TYPE_whttp__header;
			return soap_in_whttp__header(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "http:operation"))
		{	*type = SOAP_TYPE_http__operation;
			return soap_in_http__operation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "http:binding"))
		{	*type = SOAP_TYPE_http__binding;
			return soap_in_http__binding(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "http:address"))
		{	*type = SOAP_TYPE_http__address;
			return soap_in_http__address(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dime:message"))
		{	*type = SOAP_TYPE_dime__message;
			return soap_in_dime__message(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "mime:mimeXml"))
		{	*type = SOAP_TYPE_mime__mimeXml;
			return soap_in_mime__mimeXml(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "mime:multipartRelated"))
		{	*type = SOAP_TYPE_mime__multipartRelated;
			return soap_in_mime__multipartRelated(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "mime:part"))
		{	*type = SOAP_TYPE_mime__part;
			return soap_in_mime__part(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "mime:content"))
		{	*type = SOAP_TYPE_mime__content;
			return soap_in_mime__content(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsoap:header"))
		{	*type = SOAP_TYPE_wsoap__header;
			return soap_in_wsoap__header(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsoap:module"))
		{	*type = SOAP_TYPE_wsoap__module;
			return soap_in_wsoap__module(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "soap:address"))
		{	*type = SOAP_TYPE_soap__address;
			return soap_in_soap__address(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "soap:header"))
		{	*type = SOAP_TYPE_soap__header;
			return soap_in_soap__header(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "soap:headerfault"))
		{	*type = SOAP_TYPE_soap__headerfault;
			return soap_in_soap__headerfault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "soap:fault"))
		{	*type = SOAP_TYPE_soap__fault;
			return soap_in_soap__fault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "soap:body"))
		{	*type = SOAP_TYPE_soap__body;
			return soap_in_soap__body(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "soap:operation"))
		{	*type = SOAP_TYPE_soap__operation;
			return soap_in_soap__operation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "soap:binding"))
		{	*type = SOAP_TYPE_soap__binding;
			return soap_in_soap__binding(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsdl:part"))
		{	*type = SOAP_TYPE_wsdl__part;
			return soap_in_wsdl__part(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsdl:message"))
		{	*type = SOAP_TYPE_wsdl__message;
			return soap_in_wsdl__message(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wadl:application"))
		{	*type = SOAP_TYPE_wadl__application;
			return soap_in_wadl__application(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wadl:resources"))
		{	*type = SOAP_TYPE_wadl__resources;
			return soap_in_wadl__resources(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wadl:method"))
		{	*type = SOAP_TYPE_wadl__method;
			return soap_in_wadl__method(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wadl:response"))
		{	*type = SOAP_TYPE_wadl__response;
			return soap_in_wadl__response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wadl:request"))
		{	*type = SOAP_TYPE_wadl__request;
			return soap_in_wadl__request(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wadl:representation"))
		{	*type = SOAP_TYPE_wadl__representation;
			return soap_in_wadl__representation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wadl:grammars"))
		{	*type = SOAP_TYPE_wadl__grammars;
			return soap_in_wadl__grammars(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wadl:include"))
		{	*type = SOAP_TYPE_wadl__include;
			return soap_in_wadl__include(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wadl:param"))
		{	*type = SOAP_TYPE_wadl__param;
			return soap_in_wadl__param(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wadl:link"))
		{	*type = SOAP_TYPE_wadl__link;
			return soap_in_wadl__link(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wadl:option"))
		{	*type = SOAP_TYPE_wadl__option;
			return soap_in_wadl__option(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wadl:doc"))
		{	*type = SOAP_TYPE_wadl__doc;
			return soap_in_wadl__doc(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wadl:resource_type"))
		{	*type = SOAP_TYPE_wadl__resource_USCOREtype;
			return soap_in_wadl__resource_USCOREtype(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wadl:resource"))
		{	*type = SOAP_TYPE_wadl__resource;
			return soap_in_wadl__resource(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xs:redefine"))
		{	*type = SOAP_TYPE_xs__redefine;
			return soap_in_xs__redefine(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xs:override"))
		{	*type = SOAP_TYPE_xs__override;
			return soap_in_xs__override(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xs:include"))
		{	*type = SOAP_TYPE_xs__include;
			return soap_in_xs__include(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xs:import"))
		{	*type = SOAP_TYPE_xs__import;
			return soap_in_xs__import(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xs:complexContent"))
		{	*type = SOAP_TYPE_xs__complexContent;
			return soap_in_xs__complexContent(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xs:whiteSpace"))
		{	*type = SOAP_TYPE_xs__whiteSpace;
			return soap_in_xs__whiteSpace(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xs:length"))
		{	*type = SOAP_TYPE_xs__length;
			return soap_in_xs__length(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xs:simpleContent"))
		{	*type = SOAP_TYPE_xs__simpleContent;
			return soap_in_xs__simpleContent(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xs:pattern"))
		{	*type = SOAP_TYPE_xs__pattern;
			return soap_in_xs__pattern(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xs:enumeration"))
		{	*type = SOAP_TYPE_xs__enumeration;
			return soap_in_xs__enumeration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xs:attributeGroup"))
		{	*type = SOAP_TYPE_xs__attributeGroup;
			return soap_in_xs__attributeGroup(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xs:anyAttribute"))
		{	*type = SOAP_TYPE_xs__anyAttribute;
			return soap_in_xs__anyAttribute(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xs:contents"))
		{	*type = SOAP_TYPE_xs__contents;
			return soap_in_xs__contents(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xs:any"))
		{	*type = SOAP_TYPE_xs__any;
			return soap_in_xs__any(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xs:all"))
		{	*type = SOAP_TYPE_xs__all;
			return soap_in_xs__all(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xs:attribute"))
		{	*type = SOAP_TYPE_xs__attribute;
			return soap_in_xs__attribute(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xs:element"))
		{	*type = SOAP_TYPE_xs__element;
			return soap_in_xs__element(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xs:alternative"))
		{	*type = SOAP_TYPE_xs__alternative;
			return soap_in_xs__alternative(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xs:assert"))
		{	*type = SOAP_TYPE_xs__assert;
			return soap_in_xs__assert(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xs:annotation"))
		{	*type = SOAP_TYPE_xs__annotation;
			return soap_in_xs__annotation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xs:union"))
		{	*type = SOAP_TYPE_xs__union;
			return soap_in_xs__union(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xs:list"))
		{	*type = SOAP_TYPE_xs__list;
			return soap_in_xs__list(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xs:group"))
		{	*type = SOAP_TYPE_xs__group;
			return soap_in_xs__group(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xs:seqchoice"))
		{	*type = SOAP_TYPE_xs__seqchoice;
			return soap_in_xs__seqchoice(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xs:restriction"))
		{	*type = SOAP_TYPE_xs__restriction;
			return soap_in_xs__restriction(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xs:extension"))
		{	*type = SOAP_TYPE_xs__extension;
			return soap_in_xs__extension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xs:complexType"))
		{	*type = SOAP_TYPE_xs__complexType;
			return soap_in_xs__complexType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xs:simpleType"))
		{	*type = SOAP_TYPE_xs__simpleType;
			return soap_in_xs__simpleType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xs:schema"))
		{	*type = SOAP_TYPE_xs__schema;
			return soap_in_xs__schema(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsdl:definitions"))
		{	*type = SOAP_TYPE_wsdl__definitions;
			return soap_in_wsdl__definitions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "sd:mutability"))
		{	*type = SOAP_TYPE_sd__mutability;
			return soap_in_sd__mutability(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "soap:useChoice"))
		{	*type = SOAP_TYPE_soap__useChoice;
			return soap_in_soap__useChoice(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "soap:styleChoice"))
		{	*type = SOAP_TYPE_soap__styleChoice;
			return soap_in_soap__styleChoice(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wadl:ParamStyle"))
		{	*type = SOAP_TYPE_wadl__ParamStyle;
			return soap_in_wadl__ParamStyle(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wadl:HTTPMethods"))
		{	*type = SOAP_TYPE_wadl__HTTPMethods;
			return soap_in_wadl__HTTPMethods(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xs:processContents"))
		{	*type = SOAP_TYPE_xs__processContents;
			return soap_in_xs__processContents(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xs:attribute-use"))
		{	*type = SOAP_TYPE_xs__attribute_use;
			return soap_in_xs__attribute_use(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xs:formChoice"))
		{	*type = SOAP_TYPE_xs__formChoice;
			return soap_in_xs__formChoice(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_xsd__boolean;
			return soap_in_xsd__boolean(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_bool;
			return soap_in_bool(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wadl:statusCodeList"))
		{	char **s;
			*type = SOAP_TYPE_wadl__statusCodeList;
			s = soap_in_wadl__statusCodeList(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xs:namespaceList"))
		{	char **s;
			*type = SOAP_TYPE_xs__namespaceList;
			s = soap_in_xs__namespaceList(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_xsd__string;
			s = soap_in_xsd__string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:token"))
		{	char **s;
			*type = SOAP_TYPE_xsd__token;
			s = soap_in_xsd__token(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE_xsd__QName;
			s = soap_in_xsd__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:NMTOKENS"))
		{	char **s;
			*type = SOAP_TYPE_xsd__NMTOKENS;
			s = soap_in_xsd__NMTOKENS(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:NMTOKEN"))
		{	char **s;
			*type = SOAP_TYPE_xsd__NMTOKEN;
			s = soap_in_xsd__NMTOKEN(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:NCName"))
		{	char **s;
			*type = SOAP_TYPE_xsd__NCName;
			s = soap_in_xsd__NCName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:ID"))
		{	char **s;
			*type = SOAP_TYPE_xsd__ID;
			s = soap_in_xsd__ID(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:anyURI"))
		{	char **s;
			*type = SOAP_TYPE_xsd__anyURI;
			s = soap_in_xsd__anyURI(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
#ifndef WITH_NOIDREF
	}
#endif
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level = %u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other && !soap->fignore)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				if (soap_ignore(soap) || soap_element_end_in(soap, NULL))
					return soap->error;
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, SOAP_MULTIREFTAG, pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_sd__mutability:
		return soap_out_sd__mutability(soap, tag, id, (const enum sd__mutability *)ptr, "sd:mutability");
	case SOAP_TYPE_soap__useChoice:
		return soap_out_soap__useChoice(soap, tag, id, (const enum soap__useChoice *)ptr, "soap:useChoice");
	case SOAP_TYPE_soap__styleChoice:
		return soap_out_soap__styleChoice(soap, tag, id, (const enum soap__styleChoice *)ptr, "soap:styleChoice");
	case SOAP_TYPE_wadl__ParamStyle:
		return soap_out_wadl__ParamStyle(soap, tag, id, (const enum wadl__ParamStyle *)ptr, "wadl:ParamStyle");
	case SOAP_TYPE_wadl__HTTPMethods:
		return soap_out_wadl__HTTPMethods(soap, tag, id, (const enum wadl__HTTPMethods *)ptr, "wadl:HTTPMethods");
	case SOAP_TYPE_xs__processContents:
		return soap_out_xs__processContents(soap, tag, id, (const enum xs__processContents *)ptr, "xs:processContents");
	case SOAP_TYPE_xs__attribute_use:
		return soap_out_xs__attribute_use(soap, tag, id, (const enum xs__attribute_use *)ptr, "xs:attribute-use");
	case SOAP_TYPE_xs__formChoice:
		return soap_out_xs__formChoice(soap, tag, id, (const enum xs__formChoice *)ptr, "xs:formChoice");
	case SOAP_TYPE_xsd__boolean:
		return soap_out_xsd__boolean(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE_wsdl__service:
		return ((wsdl__service *)ptr)->soap_out(soap, tag, id, "wsdl:service");
	case SOAP_TYPE_wsdl__port:
		return ((wsdl__port *)ptr)->soap_out(soap, tag, id, "wsdl:port");
	case SOAP_TYPE_wsdl__binding:
		return ((wsdl__binding *)ptr)->soap_out(soap, tag, id, "wsdl:binding");
	case SOAP_TYPE_wsdl__ext_operation:
		return ((wsdl__ext_operation *)ptr)->soap_out(soap, tag, id, "wsdl:ext-operation");
	case SOAP_TYPE_wsdl__ext_fault:
		return ((wsdl__ext_fault *)ptr)->soap_out(soap, tag, id, "wsdl:ext-fault");
	case SOAP_TYPE_wsdl__ext_ioput:
		return ((wsdl__ext_ioput *)ptr)->soap_out(soap, tag, id, "wsdl:ext-ioput");
	case SOAP_TYPE_wsdl__fault:
		return ((wsdl__fault *)ptr)->soap_out(soap, tag, id, "wsdl:fault");
	case SOAP_TYPE_wsdl__ioput:
		return ((wsdl__ioput *)ptr)->soap_out(soap, tag, id, "wsdl:ioput");
	case SOAP_TYPE_wsdl__types:
		return ((wsdl__types *)ptr)->soap_out(soap, tag, id, "wsdl:types");
	case SOAP_TYPE_wsdl__import:
		return ((wsdl__import *)ptr)->soap_out(soap, tag, id, "wsdl:import");
	case SOAP_TYPE_vprop__tPropertyAlias:
		return ((vprop__tPropertyAlias *)ptr)->soap_out(soap, tag, id, "vprop:tPropertyAlias");
	case SOAP_TYPE_vprop__tProperty:
		return ((vprop__tProperty *)ptr)->soap_out(soap, tag, id, "vprop:tProperty");
	case SOAP_TYPE_vprop__tQuery:
		return ((vprop__tQuery *)ptr)->soap_out(soap, tag, id, "vprop:tQuery");
	case SOAP_TYPE_plnk__tRole:
		return ((plnk__tRole *)ptr)->soap_out(soap, tag, id, "plnk:tRole");
	case SOAP_TYPE_plnk__tPartnerLinkType:
		return ((plnk__tPartnerLinkType *)ptr)->soap_out(soap, tag, id, "plnk:tPartnerLinkType");
	case SOAP_TYPE_wsdl__portType:
		return ((wsdl__portType *)ptr)->soap_out(soap, tag, id, "wsdl:portType");
	case SOAP_TYPE_wsp__PolicyAttachment:
		return ((wsp__PolicyAttachment *)ptr)->soap_out(soap, tag, id, "wsp:PolicyAttachment");
	case SOAP_TYPE_wsp__AppliesTo:
		return ((wsp__AppliesTo *)ptr)->soap_out(soap, tag, id, "wsp:AppliesTo");
	case SOAP_TYPE_wsp__Attachment:
		return ((wsp__Attachment *)ptr)->soap_out(soap, tag, id, "wsp:Attachment");
	case SOAP_TYPE_wsrmp5__RMAssertion:
		return ((wsrmp5__RMAssertion *)ptr)->soap_out(soap, tag, id, "wsrmp5:RMAssertion");
	case SOAP_TYPE_wsrmp5__Timeout:
		return ((wsrmp5__Timeout *)ptr)->soap_out(soap, tag, id, "wsrmp5:Timeout");
	case SOAP_TYPE_wsrmp__RMAssertion:
		return ((wsrmp__RMAssertion *)ptr)->soap_out(soap, tag, id, "wsrmp:RMAssertion");
	case SOAP_TYPE_wsrmp__Timeout:
		return ((wsrmp__Timeout *)ptr)->soap_out(soap, tag, id, "wsrmp:Timeout");
	case SOAP_TYPE_sp__Token:
		return ((sp__Token *)ptr)->soap_out(soap, tag, id, "sp:Token");
	case SOAP_TYPE_sp__Elements:
		return ((sp__Elements *)ptr)->soap_out(soap, tag, id, "sp:Elements");
	case SOAP_TYPE_sp__Parts:
		return ((sp__Parts *)ptr)->soap_out(soap, tag, id, "sp:Parts");
	case SOAP_TYPE_sp__Header:
		return ((sp__Header *)ptr)->soap_out(soap, tag, id, "sp:Header");
	case SOAP_TYPE_wst__Claims:
		return ((wst__Claims *)ptr)->soap_out(soap, tag, id, "wst:Claims");
	case SOAP_TYPE_wsp__Assertion:
		return ((wsp__Assertion *)ptr)->soap_out(soap, tag, id, "wsp:Assertion");
	case SOAP_TYPE_wsp__PolicyReference:
		return ((wsp__PolicyReference *)ptr)->soap_out(soap, tag, id, "wsp:PolicyReference");
	case SOAP_TYPE_wsp__Content:
		return ((wsp__Content *)ptr)->soap_out(soap, tag, id, "wsp:Content");
	case SOAP_TYPE_wsp__Policy:
		return ((wsp__Policy *)ptr)->soap_out(soap, tag, id, "wsp:Policy");
	case SOAP_TYPE_wsa__EndpointReferenceType:
		return ((wsa__EndpointReferenceType *)ptr)->soap_out(soap, tag, id, "wsa:EndpointReferenceType");
	case SOAP_TYPE_gwsdl__portType:
		return ((gwsdl__portType *)ptr)->soap_out(soap, tag, id, "gwsdl:portType");
	case SOAP_TYPE_sd__staticServiceDataValues:
		return ((sd__staticServiceDataValues *)ptr)->soap_out(soap, tag, id, "sd:staticServiceDataValues");
	case SOAP_TYPE_sd__serviceData:
		return ((sd__serviceData *)ptr)->soap_out(soap, tag, id, "sd:serviceData");
	case SOAP_TYPE_wsdl__operation:
		return ((wsdl__operation *)ptr)->soap_out(soap, tag, id, "wsdl:operation");
	case SOAP_TYPE_whttp__header:
		return ((whttp__header *)ptr)->soap_out(soap, tag, id, "whttp:header");
	case SOAP_TYPE_http__operation:
		return ((http__operation *)ptr)->soap_out(soap, tag, id, "http:operation");
	case SOAP_TYPE_http__binding:
		return ((http__binding *)ptr)->soap_out(soap, tag, id, "http:binding");
	case SOAP_TYPE_http__address:
		return ((http__address *)ptr)->soap_out(soap, tag, id, "http:address");
	case SOAP_TYPE_dime__message:
		return ((dime__message *)ptr)->soap_out(soap, tag, id, "dime:message");
	case SOAP_TYPE_mime__mimeXml:
		return ((mime__mimeXml *)ptr)->soap_out(soap, tag, id, "mime:mimeXml");
	case SOAP_TYPE_mime__multipartRelated:
		return ((mime__multipartRelated *)ptr)->soap_out(soap, tag, id, "mime:multipartRelated");
	case SOAP_TYPE_mime__part:
		return ((mime__part *)ptr)->soap_out(soap, tag, id, "mime:part");
	case SOAP_TYPE_mime__content:
		return ((mime__content *)ptr)->soap_out(soap, tag, id, "mime:content");
	case SOAP_TYPE_wsoap__header:
		return ((wsoap__header *)ptr)->soap_out(soap, tag, id, "wsoap:header");
	case SOAP_TYPE_wsoap__module:
		return ((wsoap__module *)ptr)->soap_out(soap, tag, id, "wsoap:module");
	case SOAP_TYPE_soap__address:
		return ((soap__address *)ptr)->soap_out(soap, tag, id, "soap:address");
	case SOAP_TYPE_soap__header:
		return ((soap__header *)ptr)->soap_out(soap, tag, id, "soap:header");
	case SOAP_TYPE_soap__headerfault:
		return ((soap__headerfault *)ptr)->soap_out(soap, tag, id, "soap:headerfault");
	case SOAP_TYPE_soap__fault:
		return ((soap__fault *)ptr)->soap_out(soap, tag, id, "soap:fault");
	case SOAP_TYPE_soap__body:
		return ((soap__body *)ptr)->soap_out(soap, tag, id, "soap:body");
	case SOAP_TYPE_soap__operation:
		return ((soap__operation *)ptr)->soap_out(soap, tag, id, "soap:operation");
	case SOAP_TYPE_soap__binding:
		return ((soap__binding *)ptr)->soap_out(soap, tag, id, "soap:binding");
	case SOAP_TYPE_wsdl__part:
		return ((wsdl__part *)ptr)->soap_out(soap, tag, id, "wsdl:part");
	case SOAP_TYPE_wsdl__message:
		return ((wsdl__message *)ptr)->soap_out(soap, tag, id, "wsdl:message");
	case SOAP_TYPE_wadl__application:
		return ((wadl__application *)ptr)->soap_out(soap, tag, id, "wadl:application");
	case SOAP_TYPE_wadl__resources:
		return ((wadl__resources *)ptr)->soap_out(soap, tag, id, "wadl:resources");
	case SOAP_TYPE_wadl__method:
		return ((wadl__method *)ptr)->soap_out(soap, tag, id, "wadl:method");
	case SOAP_TYPE_wadl__response:
		return ((wadl__response *)ptr)->soap_out(soap, tag, id, "wadl:response");
	case SOAP_TYPE_wadl__request:
		return ((wadl__request *)ptr)->soap_out(soap, tag, id, "wadl:request");
	case SOAP_TYPE_wadl__representation:
		return ((wadl__representation *)ptr)->soap_out(soap, tag, id, "wadl:representation");
	case SOAP_TYPE_wadl__grammars:
		return ((wadl__grammars *)ptr)->soap_out(soap, tag, id, "wadl:grammars");
	case SOAP_TYPE_wadl__include:
		return ((wadl__include *)ptr)->soap_out(soap, tag, id, "wadl:include");
	case SOAP_TYPE_wadl__param:
		return ((wadl__param *)ptr)->soap_out(soap, tag, id, "wadl:param");
	case SOAP_TYPE_wadl__link:
		return ((wadl__link *)ptr)->soap_out(soap, tag, id, "wadl:link");
	case SOAP_TYPE_wadl__option:
		return ((wadl__option *)ptr)->soap_out(soap, tag, id, "wadl:option");
	case SOAP_TYPE_wadl__doc:
		return ((wadl__doc *)ptr)->soap_out(soap, tag, id, "wadl:doc");
	case SOAP_TYPE_wadl__resource_USCOREtype:
		return ((wadl__resource_USCOREtype *)ptr)->soap_out(soap, tag, id, "wadl:resource_type");
	case SOAP_TYPE_wadl__resource:
		return ((wadl__resource *)ptr)->soap_out(soap, tag, id, "wadl:resource");
	case SOAP_TYPE_xs__redefine:
		return ((xs__redefine *)ptr)->soap_out(soap, tag, id, "xs:redefine");
	case SOAP_TYPE_xs__override:
		return ((xs__override *)ptr)->soap_out(soap, tag, id, "xs:override");
	case SOAP_TYPE_xs__include:
		return ((xs__include *)ptr)->soap_out(soap, tag, id, "xs:include");
	case SOAP_TYPE_xs__import:
		return ((xs__import *)ptr)->soap_out(soap, tag, id, "xs:import");
	case SOAP_TYPE_xs__complexContent:
		return ((xs__complexContent *)ptr)->soap_out(soap, tag, id, "xs:complexContent");
	case SOAP_TYPE_xs__whiteSpace:
		return ((xs__whiteSpace *)ptr)->soap_out(soap, tag, id, "xs:whiteSpace");
	case SOAP_TYPE_xs__length:
		return ((xs__length *)ptr)->soap_out(soap, tag, id, "xs:length");
	case SOAP_TYPE_xs__simpleContent:
		return ((xs__simpleContent *)ptr)->soap_out(soap, tag, id, "xs:simpleContent");
	case SOAP_TYPE_xs__pattern:
		return ((xs__pattern *)ptr)->soap_out(soap, tag, id, "xs:pattern");
	case SOAP_TYPE_xs__enumeration:
		return ((xs__enumeration *)ptr)->soap_out(soap, tag, id, "xs:enumeration");
	case SOAP_TYPE_xs__attributeGroup:
		return ((xs__attributeGroup *)ptr)->soap_out(soap, tag, id, "xs:attributeGroup");
	case SOAP_TYPE_xs__anyAttribute:
		return ((xs__anyAttribute *)ptr)->soap_out(soap, tag, id, "xs:anyAttribute");
	case SOAP_TYPE_xs__contents:
		return ((xs__contents *)ptr)->soap_out(soap, tag, id, "xs:contents");
	case SOAP_TYPE_xs__any:
		return ((xs__any *)ptr)->soap_out(soap, tag, id, "xs:any");
	case SOAP_TYPE_xs__all:
		return ((xs__all *)ptr)->soap_out(soap, tag, id, "xs:all");
	case SOAP_TYPE_xs__attribute:
		return ((xs__attribute *)ptr)->soap_out(soap, tag, id, "xs:attribute");
	case SOAP_TYPE_xs__element:
		return ((xs__element *)ptr)->soap_out(soap, tag, id, "xs:element");
	case SOAP_TYPE_xs__alternative:
		return ((xs__alternative *)ptr)->soap_out(soap, tag, id, "xs:alternative");
	case SOAP_TYPE_xs__assert:
		return ((xs__assert *)ptr)->soap_out(soap, tag, id, "xs:assert");
	case SOAP_TYPE_xs__annotation:
		return ((xs__annotation *)ptr)->soap_out(soap, tag, id, "xs:annotation");
	case SOAP_TYPE_xs__union:
		return ((xs__union *)ptr)->soap_out(soap, tag, id, "xs:union");
	case SOAP_TYPE_xs__list:
		return ((xs__list *)ptr)->soap_out(soap, tag, id, "xs:list");
	case SOAP_TYPE_xs__group:
		return ((xs__group *)ptr)->soap_out(soap, tag, id, "xs:group");
	case SOAP_TYPE_xs__seqchoice:
		return ((xs__seqchoice *)ptr)->soap_out(soap, tag, id, "xs:seqchoice");
	case SOAP_TYPE_xs__restriction:
		return ((xs__restriction *)ptr)->soap_out(soap, tag, id, "xs:restriction");
	case SOAP_TYPE_xs__extension:
		return ((xs__extension *)ptr)->soap_out(soap, tag, id, "xs:extension");
	case SOAP_TYPE_xs__complexType:
		return ((xs__complexType *)ptr)->soap_out(soap, tag, id, "xs:complexType");
	case SOAP_TYPE_xs__simpleType:
		return ((xs__simpleType *)ptr)->soap_out(soap, tag, id, "xs:simpleType");
	case SOAP_TYPE_xs__schema:
		return ((xs__schema *)ptr)->soap_out(soap, tag, id, "xs:schema");
	case SOAP_TYPE_wsdl__definitions:
		return ((wsdl__definitions *)ptr)->soap_out(soap, tag, id, "wsdl:definitions");
	case SOAP_TYPE_PointerTowadl__application:
		return soap_out_PointerTowadl__application(soap, tag, id, (wadl__application *const*)ptr, "wadl:application");
	case SOAP_TYPE_PointerTowsdl__types:
		return soap_out_PointerTowsdl__types(soap, tag, id, (wsdl__types *const*)ptr, "wsdl:types");
	case SOAP_TYPE_PointerTowsdl__binding:
		return soap_out_PointerTowsdl__binding(soap, tag, id, (wsdl__binding *const*)ptr, "wsdl:binding");
	case SOAP_TYPE_PointerTohttp__address:
		return soap_out_PointerTohttp__address(soap, tag, id, (http__address *const*)ptr, "http:address");
	case SOAP_TYPE_PointerTosoap__address:
		return soap_out_PointerTosoap__address(soap, tag, id, (soap__address *const*)ptr, "soap:address");
	case SOAP_TYPE_PointerToxsd__string:
		return soap_out_PointerToxsd__string(soap, tag, id, (char **const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerTohttp__binding:
		return soap_out_PointerTohttp__binding(soap, tag, id, (http__binding *const*)ptr, "http:binding");
	case SOAP_TYPE_PointerTosoap__binding:
		return soap_out_PointerTosoap__binding(soap, tag, id, (soap__binding *const*)ptr, "soap:binding");
	case SOAP_TYPE_PointerTowsdl__ext_ioput:
		return soap_out_PointerTowsdl__ext_ioput(soap, tag, id, (wsdl__ext_ioput *const*)ptr, "wsdl:ext-ioput");
	case SOAP_TYPE_PointerTohttp__operation:
		return soap_out_PointerTohttp__operation(soap, tag, id, (http__operation *const*)ptr, "http:operation");
	case SOAP_TYPE_PointerTosoap__operation:
		return soap_out_PointerTosoap__operation(soap, tag, id, (soap__operation *const*)ptr, "soap:operation");
	case SOAP_TYPE_PointerTowsdl__fault:
		return soap_out_PointerTowsdl__fault(soap, tag, id, (wsdl__fault *const*)ptr, "wsdl:fault");
	case SOAP_TYPE_PointerTosoap__fault:
		return soap_out_PointerTosoap__fault(soap, tag, id, (soap__fault *const*)ptr, "soap:fault");
	case SOAP_TYPE_PointerTomime__mimeXml:
		return soap_out_PointerTomime__mimeXml(soap, tag, id, (mime__mimeXml *const*)ptr, "mime:mimeXml");
	case SOAP_TYPE_PointerTomime__content:
		return soap_out_PointerTomime__content(soap, tag, id, (mime__content *const*)ptr, "mime:content");
	case SOAP_TYPE_PointerTomime__multipartRelated:
		return soap_out_PointerTomime__multipartRelated(soap, tag, id, (mime__multipartRelated *const*)ptr, "mime:multipartRelated");
	case SOAP_TYPE_PointerTodime__message:
		return soap_out_PointerTodime__message(soap, tag, id, (dime__message *const*)ptr, "dime:message");
	case SOAP_TYPE_PointerTowsdl__ioput:
		return soap_out_PointerTowsdl__ioput(soap, tag, id, (wsdl__ioput *const*)ptr, "wsdl:ioput");
	case SOAP_TYPE_PointerTowsdl__definitions:
		return soap_out_PointerTowsdl__definitions(soap, tag, id, (wsdl__definitions *const*)ptr, "wsdl:definitions");
	case SOAP_TYPE_PointerTovprop__tProperty:
		return soap_out_PointerTovprop__tProperty(soap, tag, id, (vprop__tProperty *const*)ptr, "vprop:tProperty");
	case SOAP_TYPE_PointerTovprop__tQuery:
		return soap_out_PointerTovprop__tQuery(soap, tag, id, (vprop__tQuery *const*)ptr, "vprop:tQuery");
	case SOAP_TYPE_PointerToplnk__tPartnerLinkType:
		return soap_out_PointerToplnk__tPartnerLinkType(soap, tag, id, (plnk__tPartnerLinkType *const*)ptr, "plnk:tPartnerLinkType");
	case SOAP_TYPE_PointerTowsdl__portType:
		return soap_out_PointerTowsdl__portType(soap, tag, id, (wsdl__portType *const*)ptr, "wsdl:portType");
	case SOAP_TYPE_PointerTowsp__AppliesTo:
		return soap_out_PointerTowsp__AppliesTo(soap, tag, id, (wsp__AppliesTo *const*)ptr, "wsp:AppliesTo");
	case SOAP_TYPE_PointerTowsrmp5__RMAssertion:
		return soap_out_PointerTowsrmp5__RMAssertion(soap, tag, id, (wsrmp5__RMAssertion *const*)ptr, "wsrmp5:RMAssertion");
	case SOAP_TYPE_PointerTowsrmp__RMAssertion:
		return soap_out_PointerTowsrmp__RMAssertion(soap, tag, id, (wsrmp__RMAssertion *const*)ptr, "wsrmp:RMAssertion");
	case SOAP_TYPE_PointerTowsp__Assertion:
		return soap_out_PointerTowsp__Assertion(soap, tag, id, (wsp__Assertion *const*)ptr, "wsp:Assertion");
	case SOAP_TYPE_PointerTosp__Token:
		return soap_out_PointerTosp__Token(soap, tag, id, (sp__Token *const*)ptr, "sp:Token");
	case SOAP_TYPE_PointerTosp__Elements:
		return soap_out_PointerTosp__Elements(soap, tag, id, (sp__Elements *const*)ptr, "sp:Elements");
	case SOAP_TYPE_PointerTowsp__PolicyReference:
		return soap_out_PointerTowsp__PolicyReference(soap, tag, id, (wsp__PolicyReference *const*)ptr, "wsp:PolicyReference");
	case SOAP_TYPE_PointerTowsrmp5__Timeout:
		return soap_out_PointerTowsrmp5__Timeout(soap, tag, id, (wsrmp5__Timeout *const*)ptr, "wsrmp5:Timeout");
	case SOAP_TYPE_PointerTowsrmp__Timeout:
		return soap_out_PointerTowsrmp__Timeout(soap, tag, id, (wsrmp__Timeout *const*)ptr, "wsrmp:Timeout");
	case SOAP_TYPE_PointerTowst__Claims:
		return soap_out_PointerTowst__Claims(soap, tag, id, (wst__Claims *const*)ptr, "wst:Claims");
	case SOAP_TYPE_PointerTowsa__EndpointReferenceType:
		return soap_out_PointerTowsa__EndpointReferenceType(soap, tag, id, (wsa__EndpointReferenceType *const*)ptr, "wsa:EndpointReferenceType");
	case SOAP_TYPE_PointerTowsp__Content:
		return soap_out_PointerTowsp__Content(soap, tag, id, (wsp__Content *const*)ptr, "wsp:Content");
	case SOAP_TYPE_PointerTowsp__Policy:
		return soap_out_PointerTowsp__Policy(soap, tag, id, (wsp__Policy *const*)ptr, "wsp:Policy");
	case SOAP_TYPE_PointerTosd__staticServiceDataValues:
		return soap_out_PointerTosd__staticServiceDataValues(soap, tag, id, (sd__staticServiceDataValues *const*)ptr, "sd:staticServiceDataValues");
	case SOAP_TYPE_PointerTowsdl__operation:
		return soap_out_PointerTowsdl__operation(soap, tag, id, (wsdl__operation *const*)ptr, "wsdl:operation");
	case SOAP_TYPE_PointerTosoap__body:
		return soap_out_PointerTosoap__body(soap, tag, id, (soap__body *const*)ptr, "soap:body");
	case SOAP_TYPE_PointerTowsdl__part:
		return soap_out_PointerTowsdl__part(soap, tag, id, (wsdl__part *const*)ptr, "wsdl:part");
	case SOAP_TYPE_PointerTowsdl__message:
		return soap_out_PointerTowsdl__message(soap, tag, id, (wsdl__message *const*)ptr, "wsdl:message");
	case SOAP_TYPE_PointerTosoap__styleChoice:
		return soap_out_PointerTosoap__styleChoice(soap, tag, id, (enum soap__styleChoice *const*)ptr, "soap:styleChoice");
	case SOAP_TYPE_PointerTowadl__grammars:
		return soap_out_PointerTowadl__grammars(soap, tag, id, (wadl__grammars *const*)ptr, "wadl:grammars");
	case SOAP_TYPE_PointerTowadl__resource:
		return soap_out_PointerTowadl__resource(soap, tag, id, (wadl__resource *const*)ptr, "wadl:resource");
	case SOAP_TYPE_PointerTowadl__method:
		return soap_out_PointerTowadl__method(soap, tag, id, (wadl__method *const*)ptr, "wadl:method");
	case SOAP_TYPE_PointerTowadl__request:
		return soap_out_PointerTowadl__request(soap, tag, id, (wadl__request *const*)ptr, "wadl:request");
	case SOAP_TYPE_PointerTowadl__representation:
		return soap_out_PointerTowadl__representation(soap, tag, id, (wadl__representation *const*)ptr, "wadl:representation");
	case SOAP_TYPE_PointerTowadl__param:
		return soap_out_PointerTowadl__param(soap, tag, id, (wadl__param *const*)ptr, "wadl:param");
	case SOAP_TYPE_PointerTowadl__link:
		return soap_out_PointerTowadl__link(soap, tag, id, (wadl__link *const*)ptr, "wadl:link");
	case SOAP_TYPE_PointerTowadl__ParamStyle:
		return soap_out_PointerTowadl__ParamStyle(soap, tag, id, (enum wadl__ParamStyle *const*)ptr, "wadl:ParamStyle");
	case SOAP_TYPE_PointerTowadl__resource_USCOREtype:
		return soap_out_PointerTowadl__resource_USCOREtype(soap, tag, id, (wadl__resource_USCOREtype *const*)ptr, "wadl:resource_type");
	case SOAP_TYPE_wadl__statusCodeList:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "wadl:statusCodeList");
	case SOAP_TYPE_PointerToxs__complexContent:
		return soap_out_PointerToxs__complexContent(soap, tag, id, (xs__complexContent *const*)ptr, "xs:complexContent");
	case SOAP_TYPE_PointerToxs__simpleContent:
		return soap_out_PointerToxs__simpleContent(soap, tag, id, (xs__simpleContent *const*)ptr, "xs:simpleContent");
	case SOAP_TYPE_PointerToxs__assert:
		return soap_out_PointerToxs__assert(soap, tag, id, (xs__assert *const*)ptr, "xs:assert");
	case SOAP_TYPE_PointerToxs__length:
		return soap_out_PointerToxs__length(soap, tag, id, (xs__length *const*)ptr, "xs:length");
	case SOAP_TYPE_PointerToxs__whiteSpace:
		return soap_out_PointerToxs__whiteSpace(soap, tag, id, (xs__whiteSpace *const*)ptr, "xs:whiteSpace");
	case SOAP_TYPE_PointerToxs__union:
		return soap_out_PointerToxs__union(soap, tag, id, (xs__union *const*)ptr, "xs:union");
	case SOAP_TYPE_PointerToxs__list:
		return soap_out_PointerToxs__list(soap, tag, id, (xs__list *const*)ptr, "xs:list");
	case SOAP_TYPE_PointerToxs__restriction:
		return soap_out_PointerToxs__restriction(soap, tag, id, (xs__restriction *const*)ptr, "xs:restriction");
	case SOAP_TYPE_PointerToxs__extension:
		return soap_out_PointerToxs__extension(soap, tag, id, (xs__extension *const*)ptr, "xs:extension");
	case SOAP_TYPE_PointerToxs__attributeGroup:
		return soap_out_PointerToxs__attributeGroup(soap, tag, id, (xs__attributeGroup *const*)ptr, "xs:attributeGroup");
	case SOAP_TYPE_PointerToxs__anyAttribute:
		return soap_out_PointerToxs__anyAttribute(soap, tag, id, (xs__anyAttribute *const*)ptr, "xs:anyAttribute");
	case SOAP_TYPE_PointerToxs__all:
		return soap_out_PointerToxs__all(soap, tag, id, (xs__all *const*)ptr, "xs:all");
	case SOAP_TYPE_PointerToxs__any:
		return soap_out_PointerToxs__any(soap, tag, id, (xs__any *const*)ptr, "xs:any");
	case SOAP_TYPE_PointerToxs__seqchoice:
		return soap_out_PointerToxs__seqchoice(soap, tag, id, (xs__seqchoice *const*)ptr, "xs:seqchoice");
	case SOAP_TYPE_PointerToxs__group:
		return soap_out_PointerToxs__group(soap, tag, id, (xs__group *const*)ptr, "xs:group");
	case SOAP_TYPE_xs__namespaceList:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xs:namespaceList");
	case SOAP_TYPE_PointerToxs__attribute:
		return soap_out_PointerToxs__attribute(soap, tag, id, (xs__attribute *const*)ptr, "xs:attribute");
	case SOAP_TYPE_PointerToxs__element:
		return soap_out_PointerToxs__element(soap, tag, id, (xs__element *const*)ptr, "xs:element");
	case SOAP_TYPE_PointerToxs__schema:
		return soap_out_PointerToxs__schema(soap, tag, id, (xs__schema *const*)ptr, "xs:schema");
	case SOAP_TYPE_PointerToxs__complexType:
		return soap_out_PointerToxs__complexType(soap, tag, id, (xs__complexType *const*)ptr, "xs:complexType");
	case SOAP_TYPE_PointerToxs__simpleType:
		return soap_out_PointerToxs__simpleType(soap, tag, id, (xs__simpleType *const*)ptr, "xs:simpleType");
	case SOAP_TYPE_PointerToxs__formChoice:
		return soap_out_PointerToxs__formChoice(soap, tag, id, (enum xs__formChoice *const*)ptr, "xs:formChoice");
	case SOAP_TYPE_PointerToxs__annotation:
		return soap_out_PointerToxs__annotation(soap, tag, id, (xs__annotation *const*)ptr, "xs:annotation");
	case SOAP_TYPE_xsd__string:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:string");
	case SOAP_TYPE_xsd__token:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:token");
	case SOAP_TYPE_xsd__QName:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:QName");
	case SOAP_TYPE_xsd__NMTOKENS:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:NMTOKENS");
	case SOAP_TYPE_xsd__NMTOKEN:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:NMTOKEN");
	case SOAP_TYPE_xsd__NCName:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:NCName");
	case SOAP_TYPE_xsd__ID:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:ID");
	case SOAP_TYPE_xsd__anyURI:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:anyURI");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}
#ifdef __cplusplus
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_wsdl__service:
		((wsdl__service *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsdl__port:
		((wsdl__port *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsdl__binding:
		((wsdl__binding *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsdl__ext_operation:
		((wsdl__ext_operation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsdl__ext_fault:
		((wsdl__ext_fault *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsdl__ext_ioput:
		((wsdl__ext_ioput *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsdl__fault:
		((wsdl__fault *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsdl__ioput:
		((wsdl__ioput *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsdl__types:
		((wsdl__types *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsdl__import:
		((wsdl__import *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_vprop__tPropertyAlias:
		((vprop__tPropertyAlias *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_vprop__tProperty:
		((vprop__tProperty *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_vprop__tQuery:
		((vprop__tQuery *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_plnk__tRole:
		((plnk__tRole *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_plnk__tPartnerLinkType:
		((plnk__tPartnerLinkType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsdl__portType:
		((wsdl__portType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsp__PolicyAttachment:
		((wsp__PolicyAttachment *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsp__AppliesTo:
		((wsp__AppliesTo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsp__Attachment:
		((wsp__Attachment *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsrmp5__RMAssertion:
		((wsrmp5__RMAssertion *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsrmp5__Timeout:
		((wsrmp5__Timeout *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsrmp__RMAssertion:
		((wsrmp__RMAssertion *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsrmp__Timeout:
		((wsrmp__Timeout *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_sp__Token:
		((sp__Token *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_sp__Elements:
		((sp__Elements *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_sp__Parts:
		((sp__Parts *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_sp__Header:
		((sp__Header *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wst__Claims:
		((wst__Claims *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsp__Assertion:
		((wsp__Assertion *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsp__PolicyReference:
		((wsp__PolicyReference *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsp__Content:
		((wsp__Content *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsp__Policy:
		((wsp__Policy *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsa__EndpointReferenceType:
		((wsa__EndpointReferenceType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_gwsdl__portType:
		((gwsdl__portType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_sd__staticServiceDataValues:
		((sd__staticServiceDataValues *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_sd__serviceData:
		((sd__serviceData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsdl__operation:
		((wsdl__operation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_whttp__header:
		((whttp__header *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_http__operation:
		((http__operation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_http__binding:
		((http__binding *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_http__address:
		((http__address *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_dime__message:
		((dime__message *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_mime__mimeXml:
		((mime__mimeXml *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_mime__multipartRelated:
		((mime__multipartRelated *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_mime__part:
		((mime__part *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_mime__content:
		((mime__content *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsoap__header:
		((wsoap__header *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsoap__module:
		((wsoap__module *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_soap__address:
		((soap__address *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_soap__header:
		((soap__header *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_soap__headerfault:
		((soap__headerfault *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_soap__fault:
		((soap__fault *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_soap__body:
		((soap__body *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_soap__operation:
		((soap__operation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_soap__binding:
		((soap__binding *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsdl__part:
		((wsdl__part *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsdl__message:
		((wsdl__message *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wadl__application:
		((wadl__application *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wadl__resources:
		((wadl__resources *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___wadl__method_resource_choice:
		((__wadl__method_resource_choice *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wadl__method:
		((wadl__method *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wadl__response:
		((wadl__response *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wadl__request:
		((wadl__request *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wadl__representation:
		((wadl__representation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wadl__grammars:
		((wadl__grammars *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wadl__include:
		((wadl__include *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wadl__param:
		((wadl__param *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wadl__link:
		((wadl__link *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wadl__option:
		((wadl__option *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wadl__doc:
		((wadl__doc *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wadl__resource_USCOREtype:
		((wadl__resource_USCOREtype *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wadl__resource:
		((wadl__resource *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xs__redefine:
		((xs__redefine *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xs__override:
		((xs__override *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xs__include:
		((xs__include *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xs__import:
		((xs__import *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xs__complexContent:
		((xs__complexContent *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xs__whiteSpace:
		((xs__whiteSpace *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xs__length:
		((xs__length *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xs__simpleContent:
		((xs__simpleContent *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xs__pattern:
		((xs__pattern *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xs__enumeration:
		((xs__enumeration *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xs__attributeGroup:
		((xs__attributeGroup *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xs__anyAttribute:
		((xs__anyAttribute *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xs__contents:
		((xs__contents *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xs__any:
		((xs__any *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xs__all:
		((xs__all *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xs__attribute:
		((xs__attribute *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xs__element:
		((xs__element *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xs__alternative:
		((xs__alternative *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xs__assert:
		((xs__assert *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xs__annotation:
		((xs__annotation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xs__union:
		((xs__union *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xs__list:
		((xs__list *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xs__group:
		((xs__group *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xs__seqchoice:
		((xs__seqchoice *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xs__restriction:
		((xs__restriction *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xs__extension:
		((xs__extension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xs__complexType:
		((xs__complexType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xs__simpleType:
		((xs__simpleType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xs__schema:
		((xs__schema *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsdl__definitions:
		((wsdl__definitions *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_PointerTowadl__application:
		soap_serialize_PointerTowadl__application(soap, (wadl__application *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsdl__types:
		soap_serialize_PointerTowsdl__types(soap, (wsdl__types *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsdl__binding:
		soap_serialize_PointerTowsdl__binding(soap, (wsdl__binding *const*)ptr);
		break;
	case SOAP_TYPE_PointerTohttp__address:
		soap_serialize_PointerTohttp__address(soap, (http__address *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosoap__address:
		soap_serialize_PointerTosoap__address(soap, (soap__address *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__string:
		soap_serialize_PointerToxsd__string(soap, (char **const*)ptr);
		break;
	case SOAP_TYPE_PointerTohttp__binding:
		soap_serialize_PointerTohttp__binding(soap, (http__binding *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosoap__binding:
		soap_serialize_PointerTosoap__binding(soap, (soap__binding *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsdl__ext_ioput:
		soap_serialize_PointerTowsdl__ext_ioput(soap, (wsdl__ext_ioput *const*)ptr);
		break;
	case SOAP_TYPE_PointerTohttp__operation:
		soap_serialize_PointerTohttp__operation(soap, (http__operation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosoap__operation:
		soap_serialize_PointerTosoap__operation(soap, (soap__operation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsdl__fault:
		soap_serialize_PointerTowsdl__fault(soap, (wsdl__fault *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosoap__fault:
		soap_serialize_PointerTosoap__fault(soap, (soap__fault *const*)ptr);
		break;
	case SOAP_TYPE_PointerTomime__mimeXml:
		soap_serialize_PointerTomime__mimeXml(soap, (mime__mimeXml *const*)ptr);
		break;
	case SOAP_TYPE_PointerTomime__content:
		soap_serialize_PointerTomime__content(soap, (mime__content *const*)ptr);
		break;
	case SOAP_TYPE_PointerTomime__multipartRelated:
		soap_serialize_PointerTomime__multipartRelated(soap, (mime__multipartRelated *const*)ptr);
		break;
	case SOAP_TYPE_PointerTodime__message:
		soap_serialize_PointerTodime__message(soap, (dime__message *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsdl__ioput:
		soap_serialize_PointerTowsdl__ioput(soap, (wsdl__ioput *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsdl__definitions:
		soap_serialize_PointerTowsdl__definitions(soap, (wsdl__definitions *const*)ptr);
		break;
	case SOAP_TYPE_PointerTovprop__tProperty:
		soap_serialize_PointerTovprop__tProperty(soap, (vprop__tProperty *const*)ptr);
		break;
	case SOAP_TYPE_PointerTovprop__tQuery:
		soap_serialize_PointerTovprop__tQuery(soap, (vprop__tQuery *const*)ptr);
		break;
	case SOAP_TYPE_PointerToplnk__tPartnerLinkType:
		soap_serialize_PointerToplnk__tPartnerLinkType(soap, (plnk__tPartnerLinkType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsdl__portType:
		soap_serialize_PointerTowsdl__portType(soap, (wsdl__portType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsp__AppliesTo:
		soap_serialize_PointerTowsp__AppliesTo(soap, (wsp__AppliesTo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsrmp5__RMAssertion:
		soap_serialize_PointerTowsrmp5__RMAssertion(soap, (wsrmp5__RMAssertion *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsrmp__RMAssertion:
		soap_serialize_PointerTowsrmp__RMAssertion(soap, (wsrmp__RMAssertion *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsp__Assertion:
		soap_serialize_PointerTowsp__Assertion(soap, (wsp__Assertion *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosp__Token:
		soap_serialize_PointerTosp__Token(soap, (sp__Token *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosp__Elements:
		soap_serialize_PointerTosp__Elements(soap, (sp__Elements *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsp__PolicyReference:
		soap_serialize_PointerTowsp__PolicyReference(soap, (wsp__PolicyReference *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsrmp5__Timeout:
		soap_serialize_PointerTowsrmp5__Timeout(soap, (wsrmp5__Timeout *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsrmp__Timeout:
		soap_serialize_PointerTowsrmp__Timeout(soap, (wsrmp__Timeout *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowst__Claims:
		soap_serialize_PointerTowst__Claims(soap, (wst__Claims *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsa__EndpointReferenceType:
		soap_serialize_PointerTowsa__EndpointReferenceType(soap, (wsa__EndpointReferenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsp__Content:
		soap_serialize_PointerTowsp__Content(soap, (wsp__Content *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsp__Policy:
		soap_serialize_PointerTowsp__Policy(soap, (wsp__Policy *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosd__staticServiceDataValues:
		soap_serialize_PointerTosd__staticServiceDataValues(soap, (sd__staticServiceDataValues *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsdl__operation:
		soap_serialize_PointerTowsdl__operation(soap, (wsdl__operation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosoap__body:
		soap_serialize_PointerTosoap__body(soap, (soap__body *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsdl__part:
		soap_serialize_PointerTowsdl__part(soap, (wsdl__part *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsdl__message:
		soap_serialize_PointerTowsdl__message(soap, (wsdl__message *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosoap__styleChoice:
		soap_serialize_PointerTosoap__styleChoice(soap, (enum soap__styleChoice *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowadl__grammars:
		soap_serialize_PointerTowadl__grammars(soap, (wadl__grammars *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowadl__resource:
		soap_serialize_PointerTowadl__resource(soap, (wadl__resource *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowadl__method:
		soap_serialize_PointerTowadl__method(soap, (wadl__method *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowadl__request:
		soap_serialize_PointerTowadl__request(soap, (wadl__request *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowadl__representation:
		soap_serialize_PointerTowadl__representation(soap, (wadl__representation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowadl__param:
		soap_serialize_PointerTowadl__param(soap, (wadl__param *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowadl__link:
		soap_serialize_PointerTowadl__link(soap, (wadl__link *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowadl__ParamStyle:
		soap_serialize_PointerTowadl__ParamStyle(soap, (enum wadl__ParamStyle *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowadl__resource_USCOREtype:
		soap_serialize_PointerTowadl__resource_USCOREtype(soap, (wadl__resource_USCOREtype *const*)ptr);
		break;
	case SOAP_TYPE_wadl__statusCodeList:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_PointerToxs__complexContent:
		soap_serialize_PointerToxs__complexContent(soap, (xs__complexContent *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxs__simpleContent:
		soap_serialize_PointerToxs__simpleContent(soap, (xs__simpleContent *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxs__assert:
		soap_serialize_PointerToxs__assert(soap, (xs__assert *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxs__length:
		soap_serialize_PointerToxs__length(soap, (xs__length *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxs__whiteSpace:
		soap_serialize_PointerToxs__whiteSpace(soap, (xs__whiteSpace *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxs__union:
		soap_serialize_PointerToxs__union(soap, (xs__union *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxs__list:
		soap_serialize_PointerToxs__list(soap, (xs__list *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxs__restriction:
		soap_serialize_PointerToxs__restriction(soap, (xs__restriction *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxs__extension:
		soap_serialize_PointerToxs__extension(soap, (xs__extension *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxs__attributeGroup:
		soap_serialize_PointerToxs__attributeGroup(soap, (xs__attributeGroup *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxs__anyAttribute:
		soap_serialize_PointerToxs__anyAttribute(soap, (xs__anyAttribute *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxs__all:
		soap_serialize_PointerToxs__all(soap, (xs__all *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxs__any:
		soap_serialize_PointerToxs__any(soap, (xs__any *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxs__seqchoice:
		soap_serialize_PointerToxs__seqchoice(soap, (xs__seqchoice *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxs__group:
		soap_serialize_PointerToxs__group(soap, (xs__group *const*)ptr);
		break;
	case SOAP_TYPE_xs__namespaceList:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_PointerToxs__attribute:
		soap_serialize_PointerToxs__attribute(soap, (xs__attribute *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxs__element:
		soap_serialize_PointerToxs__element(soap, (xs__element *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxs__schema:
		soap_serialize_PointerToxs__schema(soap, (xs__schema *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxs__complexType:
		soap_serialize_PointerToxs__complexType(soap, (xs__complexType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxs__simpleType:
		soap_serialize_PointerToxs__simpleType(soap, (xs__simpleType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxs__formChoice:
		soap_serialize_PointerToxs__formChoice(soap, (enum xs__formChoice *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxs__annotation:
		soap_serialize_PointerToxs__annotation(soap, (xs__annotation *const*)ptr);
		break;
	case SOAP_TYPE_xsd__string:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_xsd__token:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_xsd__QName:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_xsd__NMTOKENS:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_xsd__NMTOKEN:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_xsd__NCName:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_xsd__ID:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_xsd__anyURI:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	}
}
#ifdef __cplusplus
}
#endif
#endif

#ifdef __cplusplus
extern "C" {
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_dupelement(struct soap *soap, const void *ptr, int type)
{(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	return NULL;
}
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_delelement(const void *ptr, int type)
{(void)ptr; (void)type; /* appease -Wall -Werror */
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void * SOAP_FMAC4 wsdl_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{	(void)type;
	switch (t)
	{
	case SOAP_TYPE_xs__annotation:
		return (void*)wsdl_instantiate_xs__annotation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xs__assert:
		return (void*)wsdl_instantiate_xs__assert(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xs__alternative:
		return (void*)wsdl_instantiate_xs__alternative(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xs__element:
		return (void*)wsdl_instantiate_xs__element(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xs__attribute:
		return (void*)wsdl_instantiate_xs__attribute(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xs__all:
		return (void*)wsdl_instantiate_xs__all(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xs__any:
		return (void*)wsdl_instantiate_xs__any(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xs__contents:
		return (void*)wsdl_instantiate_xs__contents(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xs__seqchoice:
		return (void*)wsdl_instantiate_xs__seqchoice(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xs__group:
		return (void*)wsdl_instantiate_xs__group(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xs__anyAttribute:
		return (void*)wsdl_instantiate_xs__anyAttribute(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xs__attributeGroup:
		return (void*)wsdl_instantiate_xs__attributeGroup(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xs__enumeration:
		return (void*)wsdl_instantiate_xs__enumeration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xs__pattern:
		return (void*)wsdl_instantiate_xs__pattern(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xs__simpleContent:
		return (void*)wsdl_instantiate_xs__simpleContent(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xs__simpleType:
		return (void*)wsdl_instantiate_xs__simpleType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xs__extension:
		return (void*)wsdl_instantiate_xs__extension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xs__length:
		return (void*)wsdl_instantiate_xs__length(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xs__whiteSpace:
		return (void*)wsdl_instantiate_xs__whiteSpace(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xs__restriction:
		return (void*)wsdl_instantiate_xs__restriction(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xs__list:
		return (void*)wsdl_instantiate_xs__list(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xs__union:
		return (void*)wsdl_instantiate_xs__union(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xs__complexContent:
		return (void*)wsdl_instantiate_xs__complexContent(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xs__complexType:
		return (void*)wsdl_instantiate_xs__complexType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xs__import:
		return (void*)wsdl_instantiate_xs__import(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xs__include:
		return (void*)wsdl_instantiate_xs__include(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xs__override:
		return (void*)wsdl_instantiate_xs__override(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xs__redefine:
		return (void*)wsdl_instantiate_xs__redefine(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xs__schema:
		return (void*)wsdl_instantiate_xs__schema(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wadl__doc:
		return (void*)wsdl_instantiate_wadl__doc(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wadl__option:
		return (void*)wsdl_instantiate_wadl__option(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wadl__link:
		return (void*)wsdl_instantiate_wadl__link(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wadl__param:
		return (void*)wsdl_instantiate_wadl__param(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wadl__include:
		return (void*)wsdl_instantiate_wadl__include(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wadl__grammars:
		return (void*)wsdl_instantiate_wadl__grammars(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wadl__representation:
		return (void*)wsdl_instantiate_wadl__representation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wadl__request:
		return (void*)wsdl_instantiate_wadl__request(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wadl__response:
		return (void*)wsdl_instantiate_wadl__response(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wadl__method:
		return (void*)wsdl_instantiate_wadl__method(soap, -1, type, arrayType, n);
	case SOAP_TYPE___wadl__method_resource_choice:
		return (void*)wsdl_instantiate___wadl__method_resource_choice(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wadl__resource_USCOREtype:
		return (void*)wsdl_instantiate_wadl__resource_USCOREtype(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wadl__resource:
		return (void*)wsdl_instantiate_wadl__resource(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wadl__resources:
		return (void*)wsdl_instantiate_wadl__resources(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wadl__application:
		return (void*)wsdl_instantiate_wadl__application(soap, -1, type, arrayType, n);
	case SOAP_TYPE_soap__binding:
		return (void*)wsdl_instantiate_soap__binding(soap, -1, type, arrayType, n);
	case SOAP_TYPE_soap__operation:
		return (void*)wsdl_instantiate_soap__operation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_soap__body:
		return (void*)wsdl_instantiate_soap__body(soap, -1, type, arrayType, n);
	case SOAP_TYPE_soap__fault:
		return (void*)wsdl_instantiate_soap__fault(soap, -1, type, arrayType, n);
	case SOAP_TYPE_soap__headerfault:
		return (void*)wsdl_instantiate_soap__headerfault(soap, -1, type, arrayType, n);
	case SOAP_TYPE_soap__header:
		return (void*)wsdl_instantiate_soap__header(soap, -1, type, arrayType, n);
	case SOAP_TYPE_soap__address:
		return (void*)wsdl_instantiate_soap__address(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsoap__module:
		return (void*)wsdl_instantiate_wsoap__module(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsoap__header:
		return (void*)wsdl_instantiate_wsoap__header(soap, -1, type, arrayType, n);
	case SOAP_TYPE_mime__content:
		return (void*)wsdl_instantiate_mime__content(soap, -1, type, arrayType, n);
	case SOAP_TYPE_mime__part:
		return (void*)wsdl_instantiate_mime__part(soap, -1, type, arrayType, n);
	case SOAP_TYPE_mime__multipartRelated:
		return (void*)wsdl_instantiate_mime__multipartRelated(soap, -1, type, arrayType, n);
	case SOAP_TYPE_mime__mimeXml:
		return (void*)wsdl_instantiate_mime__mimeXml(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dime__message:
		return (void*)wsdl_instantiate_dime__message(soap, -1, type, arrayType, n);
	case SOAP_TYPE_http__address:
		return (void*)wsdl_instantiate_http__address(soap, -1, type, arrayType, n);
	case SOAP_TYPE_http__binding:
		return (void*)wsdl_instantiate_http__binding(soap, -1, type, arrayType, n);
	case SOAP_TYPE_http__operation:
		return (void*)wsdl_instantiate_http__operation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_whttp__header:
		return (void*)wsdl_instantiate_whttp__header(soap, -1, type, arrayType, n);
	case SOAP_TYPE_sd__serviceData:
		return (void*)wsdl_instantiate_sd__serviceData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_sd__staticServiceDataValues:
		return (void*)wsdl_instantiate_sd__staticServiceDataValues(soap, -1, type, arrayType, n);
	case SOAP_TYPE_gwsdl__portType:
		return (void*)wsdl_instantiate_gwsdl__portType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsa__EndpointReferenceType:
		return (void*)wsdl_instantiate_wsa__EndpointReferenceType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsp__PolicyReference:
		return (void*)wsdl_instantiate_wsp__PolicyReference(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsp__Assertion:
		return (void*)wsdl_instantiate_wsp__Assertion(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wst__Claims:
		return (void*)wsdl_instantiate_wst__Claims(soap, -1, type, arrayType, n);
	case SOAP_TYPE_sp__Header:
		return (void*)wsdl_instantiate_sp__Header(soap, -1, type, arrayType, n);
	case SOAP_TYPE_sp__Parts:
		return (void*)wsdl_instantiate_sp__Parts(soap, -1, type, arrayType, n);
	case SOAP_TYPE_sp__Elements:
		return (void*)wsdl_instantiate_sp__Elements(soap, -1, type, arrayType, n);
	case SOAP_TYPE_sp__Token:
		return (void*)wsdl_instantiate_sp__Token(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsrmp__Timeout:
		return (void*)wsdl_instantiate_wsrmp__Timeout(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsrmp__RMAssertion:
		return (void*)wsdl_instantiate_wsrmp__RMAssertion(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsrmp5__Timeout:
		return (void*)wsdl_instantiate_wsrmp5__Timeout(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsrmp5__RMAssertion:
		return (void*)wsdl_instantiate_wsrmp5__RMAssertion(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsp__Content:
		return (void*)wsdl_instantiate_wsp__Content(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsp__Policy:
		return (void*)wsdl_instantiate_wsp__Policy(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsp__Attachment:
		return (void*)wsdl_instantiate_wsp__Attachment(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsp__AppliesTo:
		return (void*)wsdl_instantiate_wsp__AppliesTo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsp__PolicyAttachment:
		return (void*)wsdl_instantiate_wsp__PolicyAttachment(soap, -1, type, arrayType, n);
	case SOAP_TYPE_plnk__tRole:
		return (void*)wsdl_instantiate_plnk__tRole(soap, -1, type, arrayType, n);
	case SOAP_TYPE_plnk__tPartnerLinkType:
		return (void*)wsdl_instantiate_plnk__tPartnerLinkType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vprop__tQuery:
		return (void*)wsdl_instantiate_vprop__tQuery(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vprop__tProperty:
		return (void*)wsdl_instantiate_vprop__tProperty(soap, -1, type, arrayType, n);
	case SOAP_TYPE_vprop__tPropertyAlias:
		return (void*)wsdl_instantiate_vprop__tPropertyAlias(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsdl__import:
		return (void*)wsdl_instantiate_wsdl__import(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsdl__types:
		return (void*)wsdl_instantiate_wsdl__types(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsdl__part:
		return (void*)wsdl_instantiate_wsdl__part(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsdl__message:
		return (void*)wsdl_instantiate_wsdl__message(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsdl__ioput:
		return (void*)wsdl_instantiate_wsdl__ioput(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsdl__fault:
		return (void*)wsdl_instantiate_wsdl__fault(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsdl__operation:
		return (void*)wsdl_instantiate_wsdl__operation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsdl__portType:
		return (void*)wsdl_instantiate_wsdl__portType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsdl__ext_ioput:
		return (void*)wsdl_instantiate_wsdl__ext_ioput(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsdl__ext_fault:
		return (void*)wsdl_instantiate_wsdl__ext_fault(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsdl__ext_operation:
		return (void*)wsdl_instantiate_wsdl__ext_operation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsdl__binding:
		return (void*)wsdl_instantiate_wsdl__binding(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsdl__port:
		return (void*)wsdl_instantiate_wsdl__port(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsdl__service:
		return (void*)wsdl_instantiate_wsdl__service(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsdl__definitions:
		return (void*)wsdl_instantiate_wsdl__definitions(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)wsdl_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)wsdl_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)wsdl_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)wsdl_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)wsdl_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_std__vectorTemplateOfgwsdl__portType:
		return (void*)wsdl_instantiate_std__vectorTemplateOfgwsdl__portType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfvprop__tPropertyAlias:
		return (void*)wsdl_instantiate_std__vectorTemplateOfvprop__tPropertyAlias(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfvprop__tProperty:
		return (void*)wsdl_instantiate_std__vectorTemplateOfvprop__tProperty(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfplnk__tPartnerLinkType:
		return (void*)wsdl_instantiate_std__vectorTemplateOfplnk__tPartnerLinkType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfwsdl__service:
		return (void*)wsdl_instantiate_std__vectorTemplateOfwsdl__service(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfwsdl__binding:
		return (void*)wsdl_instantiate_std__vectorTemplateOfwsdl__binding(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfwsdl__portType:
		return (void*)wsdl_instantiate_std__vectorTemplateOfwsdl__portType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfwsdl__message:
		return (void*)wsdl_instantiate_std__vectorTemplateOfwsdl__message(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfwsdl__import:
		return (void*)wsdl_instantiate_std__vectorTemplateOfwsdl__import(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfwsdl__port:
		return (void*)wsdl_instantiate_std__vectorTemplateOfwsdl__port(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfwsdl__ext_operation:
		return (void*)wsdl_instantiate_std__vectorTemplateOfwsdl__ext_operation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfwsdl__ext_fault:
		return (void*)wsdl_instantiate_std__vectorTemplateOfwsdl__ext_fault(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfwhttp__header:
		return (void*)wsdl_instantiate_std__vectorTemplateOfwhttp__header(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfwsoap__header:
		return (void*)wsdl_instantiate_std__vectorTemplateOfwsoap__header(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfwsoap__module:
		return (void*)wsdl_instantiate_std__vectorTemplateOfwsoap__module(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfwsdl__operation:
		return (void*)wsdl_instantiate_std__vectorTemplateOfwsdl__operation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfwsdl__fault:
		return (void*)wsdl_instantiate_std__vectorTemplateOfwsdl__fault(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfwsdl__part:
		return (void*)wsdl_instantiate_std__vectorTemplateOfwsdl__part(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfwsp__PolicyReference:
		return (void*)wsdl_instantiate_std__vectorTemplateOfwsp__PolicyReference(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfwsp__Policy:
		return (void*)wsdl_instantiate_std__vectorTemplateOfwsp__Policy(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerToxs__schema:
		return (void*)wsdl_instantiate_std__vectorTemplateOfPointerToxs__schema(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfplnk__tRole:
		return (void*)wsdl_instantiate_std__vectorTemplateOfplnk__tRole(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfwsp__Attachment:
		return (void*)wsdl_instantiate_std__vectorTemplateOfwsp__Attachment(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOf_XML:
		return (void*)wsdl_instantiate_std__vectorTemplateOf_XML(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfsp__Parts:
		return (void*)wsdl_instantiate_std__vectorTemplateOfsp__Parts(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTowsp__Content:
		return (void*)wsdl_instantiate_std__vectorTemplateOfPointerTowsp__Content(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfxsd__string:
		return (void*)wsdl_instantiate_std__vectorTemplateOfxsd__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfsp__Header:
		return (void*)wsdl_instantiate_std__vectorTemplateOfsp__Header(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfsd__serviceData:
		return (void*)wsdl_instantiate_std__vectorTemplateOfsd__serviceData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTowsdl__operation:
		return (void*)wsdl_instantiate_std__vectorTemplateOfPointerTowsdl__operation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfmime__part:
		return (void*)wsdl_instantiate_std__vectorTemplateOfmime__part(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfmime__content:
		return (void*)wsdl_instantiate_std__vectorTemplateOfmime__content(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfsoap__header:
		return (void*)wsdl_instantiate_std__vectorTemplateOfsoap__header(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfsoap__headerfault:
		return (void*)wsdl_instantiate_std__vectorTemplateOfsoap__headerfault(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfwadl__method:
		return (void*)wsdl_instantiate_std__vectorTemplateOfwadl__method(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfwadl__resource_USCOREtype:
		return (void*)wsdl_instantiate_std__vectorTemplateOfwadl__resource_USCOREtype(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfwadl__resources:
		return (void*)wsdl_instantiate_std__vectorTemplateOfwadl__resources(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfwadl__resource:
		return (void*)wsdl_instantiate_std__vectorTemplateOfwadl__resource(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTowadl__resource_USCOREtype:
		return (void*)wsdl_instantiate_std__vectorTemplateOfPointerTowadl__resource_USCOREtype(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOf__wadl__method_resource_choice:
		return (void*)wsdl_instantiate_std__vectorTemplateOf__wadl__method_resource_choice(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfwadl__response:
		return (void*)wsdl_instantiate_std__vectorTemplateOfwadl__response(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfwadl__representation:
		return (void*)wsdl_instantiate_std__vectorTemplateOfwadl__representation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfwadl__param:
		return (void*)wsdl_instantiate_std__vectorTemplateOfwadl__param(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfwadl__include:
		return (void*)wsdl_instantiate_std__vectorTemplateOfwadl__include(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfwadl__option:
		return (void*)wsdl_instantiate_std__vectorTemplateOfwadl__option(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfwadl__doc:
		return (void*)wsdl_instantiate_std__vectorTemplateOfwadl__doc(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfxs__import:
		return (void*)wsdl_instantiate_std__vectorTemplateOfxs__import(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfxs__redefine:
		return (void*)wsdl_instantiate_std__vectorTemplateOfxs__redefine(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfxs__override:
		return (void*)wsdl_instantiate_std__vectorTemplateOfxs__override(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfxs__include:
		return (void*)wsdl_instantiate_std__vectorTemplateOfxs__include(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfxs__complexType:
		return (void*)wsdl_instantiate_std__vectorTemplateOfxs__complexType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfxs__group:
		return (void*)wsdl_instantiate_std__vectorTemplateOfxs__group(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfxs__simpleType:
		return (void*)wsdl_instantiate_std__vectorTemplateOfxs__simpleType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfxs__pattern:
		return (void*)wsdl_instantiate_std__vectorTemplateOfxs__pattern(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfxs__enumeration:
		return (void*)wsdl_instantiate_std__vectorTemplateOfxs__enumeration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfxs__assert:
		return (void*)wsdl_instantiate_std__vectorTemplateOfxs__assert(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfxs__attributeGroup:
		return (void*)wsdl_instantiate_std__vectorTemplateOfxs__attributeGroup(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfxs__attribute:
		return (void*)wsdl_instantiate_std__vectorTemplateOfxs__attribute(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfxs__contents:
		return (void*)wsdl_instantiate_std__vectorTemplateOfxs__contents(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfxs__element:
		return (void*)wsdl_instantiate_std__vectorTemplateOfxs__element(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerToxs__element:
		return (void*)wsdl_instantiate_std__vectorTemplateOfPointerToxs__element(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfxs__alternative:
		return (void*)wsdl_instantiate_std__vectorTemplateOfxs__alternative(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfstring:
		return (void*)wsdl_instantiate_std__vectorTemplateOfstring(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 wsdl_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_xs__annotation:
		if (p->size < 0)
			SOAP_DELETE(static_cast<xs__annotation*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<xs__annotation*>(p->ptr));
		break;
	case SOAP_TYPE_xs__assert:
		if (p->size < 0)
			SOAP_DELETE(static_cast<xs__assert*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<xs__assert*>(p->ptr));
		break;
	case SOAP_TYPE_xs__alternative:
		if (p->size < 0)
			SOAP_DELETE(static_cast<xs__alternative*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<xs__alternative*>(p->ptr));
		break;
	case SOAP_TYPE_xs__element:
		if (p->size < 0)
			SOAP_DELETE(static_cast<xs__element*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<xs__element*>(p->ptr));
		break;
	case SOAP_TYPE_xs__attribute:
		if (p->size < 0)
			SOAP_DELETE(static_cast<xs__attribute*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<xs__attribute*>(p->ptr));
		break;
	case SOAP_TYPE_xs__all:
		if (p->size < 0)
			SOAP_DELETE(static_cast<xs__all*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<xs__all*>(p->ptr));
		break;
	case SOAP_TYPE_xs__any:
		if (p->size < 0)
			SOAP_DELETE(static_cast<xs__any*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<xs__any*>(p->ptr));
		break;
	case SOAP_TYPE_xs__contents:
		if (p->size < 0)
			SOAP_DELETE(static_cast<xs__contents*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<xs__contents*>(p->ptr));
		break;
	case SOAP_TYPE_xs__seqchoice:
		if (p->size < 0)
			SOAP_DELETE(static_cast<xs__seqchoice*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<xs__seqchoice*>(p->ptr));
		break;
	case SOAP_TYPE_xs__group:
		if (p->size < 0)
			SOAP_DELETE(static_cast<xs__group*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<xs__group*>(p->ptr));
		break;
	case SOAP_TYPE_xs__anyAttribute:
		if (p->size < 0)
			SOAP_DELETE(static_cast<xs__anyAttribute*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<xs__anyAttribute*>(p->ptr));
		break;
	case SOAP_TYPE_xs__attributeGroup:
		if (p->size < 0)
			SOAP_DELETE(static_cast<xs__attributeGroup*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<xs__attributeGroup*>(p->ptr));
		break;
	case SOAP_TYPE_xs__enumeration:
		if (p->size < 0)
			SOAP_DELETE(static_cast<xs__enumeration*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<xs__enumeration*>(p->ptr));
		break;
	case SOAP_TYPE_xs__pattern:
		if (p->size < 0)
			SOAP_DELETE(static_cast<xs__pattern*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<xs__pattern*>(p->ptr));
		break;
	case SOAP_TYPE_xs__simpleContent:
		if (p->size < 0)
			SOAP_DELETE(static_cast<xs__simpleContent*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<xs__simpleContent*>(p->ptr));
		break;
	case SOAP_TYPE_xs__simpleType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<xs__simpleType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<xs__simpleType*>(p->ptr));
		break;
	case SOAP_TYPE_xs__extension:
		if (p->size < 0)
			SOAP_DELETE(static_cast<xs__extension*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<xs__extension*>(p->ptr));
		break;
	case SOAP_TYPE_xs__length:
		if (p->size < 0)
			SOAP_DELETE(static_cast<xs__length*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<xs__length*>(p->ptr));
		break;
	case SOAP_TYPE_xs__whiteSpace:
		if (p->size < 0)
			SOAP_DELETE(static_cast<xs__whiteSpace*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<xs__whiteSpace*>(p->ptr));
		break;
	case SOAP_TYPE_xs__restriction:
		if (p->size < 0)
			SOAP_DELETE(static_cast<xs__restriction*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<xs__restriction*>(p->ptr));
		break;
	case SOAP_TYPE_xs__list:
		if (p->size < 0)
			SOAP_DELETE(static_cast<xs__list*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<xs__list*>(p->ptr));
		break;
	case SOAP_TYPE_xs__union:
		if (p->size < 0)
			SOAP_DELETE(static_cast<xs__union*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<xs__union*>(p->ptr));
		break;
	case SOAP_TYPE_xs__complexContent:
		if (p->size < 0)
			SOAP_DELETE(static_cast<xs__complexContent*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<xs__complexContent*>(p->ptr));
		break;
	case SOAP_TYPE_xs__complexType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<xs__complexType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<xs__complexType*>(p->ptr));
		break;
	case SOAP_TYPE_xs__import:
		if (p->size < 0)
			SOAP_DELETE(static_cast<xs__import*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<xs__import*>(p->ptr));
		break;
	case SOAP_TYPE_xs__include:
		if (p->size < 0)
			SOAP_DELETE(static_cast<xs__include*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<xs__include*>(p->ptr));
		break;
	case SOAP_TYPE_xs__override:
		if (p->size < 0)
			SOAP_DELETE(static_cast<xs__override*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<xs__override*>(p->ptr));
		break;
	case SOAP_TYPE_xs__redefine:
		if (p->size < 0)
			SOAP_DELETE(static_cast<xs__redefine*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<xs__redefine*>(p->ptr));
		break;
	case SOAP_TYPE_xs__schema:
		if (p->size < 0)
			SOAP_DELETE(static_cast<xs__schema*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<xs__schema*>(p->ptr));
		break;
	case SOAP_TYPE_wadl__doc:
		if (p->size < 0)
			SOAP_DELETE(static_cast<wadl__doc*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<wadl__doc*>(p->ptr));
		break;
	case SOAP_TYPE_wadl__option:
		if (p->size < 0)
			SOAP_DELETE(static_cast<wadl__option*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<wadl__option*>(p->ptr));
		break;
	case SOAP_TYPE_wadl__link:
		if (p->size < 0)
			SOAP_DELETE(static_cast<wadl__link*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<wadl__link*>(p->ptr));
		break;
	case SOAP_TYPE_wadl__param:
		if (p->size < 0)
			SOAP_DELETE(static_cast<wadl__param*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<wadl__param*>(p->ptr));
		break;
	case SOAP_TYPE_wadl__include:
		if (p->size < 0)
			SOAP_DELETE(static_cast<wadl__include*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<wadl__include*>(p->ptr));
		break;
	case SOAP_TYPE_wadl__grammars:
		if (p->size < 0)
			SOAP_DELETE(static_cast<wadl__grammars*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<wadl__grammars*>(p->ptr));
		break;
	case SOAP_TYPE_wadl__representation:
		if (p->size < 0)
			SOAP_DELETE(static_cast<wadl__representation*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<wadl__representation*>(p->ptr));
		break;
	case SOAP_TYPE_wadl__request:
		if (p->size < 0)
			SOAP_DELETE(static_cast<wadl__request*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<wadl__request*>(p->ptr));
		break;
	case SOAP_TYPE_wadl__response:
		if (p->size < 0)
			SOAP_DELETE(static_cast<wadl__response*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<wadl__response*>(p->ptr));
		break;
	case SOAP_TYPE_wadl__method:
		if (p->size < 0)
			SOAP_DELETE(static_cast<wadl__method*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<wadl__method*>(p->ptr));
		break;
	case SOAP_TYPE___wadl__method_resource_choice:
		if (p->size < 0)
			SOAP_DELETE(static_cast<__wadl__method_resource_choice*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<__wadl__method_resource_choice*>(p->ptr));
		break;
	case SOAP_TYPE_wadl__resource_USCOREtype:
		if (p->size < 0)
			SOAP_DELETE(static_cast<wadl__resource_USCOREtype*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<wadl__resource_USCOREtype*>(p->ptr));
		break;
	case SOAP_TYPE_wadl__resource:
		if (p->size < 0)
			SOAP_DELETE(static_cast<wadl__resource*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<wadl__resource*>(p->ptr));
		break;
	case SOAP_TYPE_wadl__resources:
		if (p->size < 0)
			SOAP_DELETE(static_cast<wadl__resources*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<wadl__resources*>(p->ptr));
		break;
	case SOAP_TYPE_wadl__application:
		if (p->size < 0)
			SOAP_DELETE(static_cast<wadl__application*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<wadl__application*>(p->ptr));
		break;
	case SOAP_TYPE_soap__binding:
		if (p->size < 0)
			SOAP_DELETE(static_cast<soap__binding*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<soap__binding*>(p->ptr));
		break;
	case SOAP_TYPE_soap__operation:
		if (p->size < 0)
			SOAP_DELETE(static_cast<soap__operation*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<soap__operation*>(p->ptr));
		break;
	case SOAP_TYPE_soap__body:
		if (p->size < 0)
			SOAP_DELETE(static_cast<soap__body*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<soap__body*>(p->ptr));
		break;
	case SOAP_TYPE_soap__fault:
		if (p->size < 0)
			SOAP_DELETE(static_cast<soap__fault*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<soap__fault*>(p->ptr));
		break;
	case SOAP_TYPE_soap__headerfault:
		if (p->size < 0)
			SOAP_DELETE(static_cast<soap__headerfault*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<soap__headerfault*>(p->ptr));
		break;
	case SOAP_TYPE_soap__header:
		if (p->size < 0)
			SOAP_DELETE(static_cast<soap__header*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<soap__header*>(p->ptr));
		break;
	case SOAP_TYPE_soap__address:
		if (p->size < 0)
			SOAP_DELETE(static_cast<soap__address*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<soap__address*>(p->ptr));
		break;
	case SOAP_TYPE_wsoap__module:
		if (p->size < 0)
			SOAP_DELETE(static_cast<wsoap__module*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<wsoap__module*>(p->ptr));
		break;
	case SOAP_TYPE_wsoap__header:
		if (p->size < 0)
			SOAP_DELETE(static_cast<wsoap__header*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<wsoap__header*>(p->ptr));
		break;
	case SOAP_TYPE_mime__content:
		if (p->size < 0)
			SOAP_DELETE(static_cast<mime__content*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<mime__content*>(p->ptr));
		break;
	case SOAP_TYPE_mime__part:
		if (p->size < 0)
			SOAP_DELETE(static_cast<mime__part*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<mime__part*>(p->ptr));
		break;
	case SOAP_TYPE_mime__multipartRelated:
		if (p->size < 0)
			SOAP_DELETE(static_cast<mime__multipartRelated*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<mime__multipartRelated*>(p->ptr));
		break;
	case SOAP_TYPE_mime__mimeXml:
		if (p->size < 0)
			SOAP_DELETE(static_cast<mime__mimeXml*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<mime__mimeXml*>(p->ptr));
		break;
	case SOAP_TYPE_dime__message:
		if (p->size < 0)
			SOAP_DELETE(static_cast<dime__message*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<dime__message*>(p->ptr));
		break;
	case SOAP_TYPE_http__address:
		if (p->size < 0)
			SOAP_DELETE(static_cast<http__address*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<http__address*>(p->ptr));
		break;
	case SOAP_TYPE_http__binding:
		if (p->size < 0)
			SOAP_DELETE(static_cast<http__binding*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<http__binding*>(p->ptr));
		break;
	case SOAP_TYPE_http__operation:
		if (p->size < 0)
			SOAP_DELETE(static_cast<http__operation*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<http__operation*>(p->ptr));
		break;
	case SOAP_TYPE_whttp__header:
		if (p->size < 0)
			SOAP_DELETE(static_cast<whttp__header*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<whttp__header*>(p->ptr));
		break;
	case SOAP_TYPE_sd__serviceData:
		if (p->size < 0)
			SOAP_DELETE(static_cast<sd__serviceData*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<sd__serviceData*>(p->ptr));
		break;
	case SOAP_TYPE_sd__staticServiceDataValues:
		if (p->size < 0)
			SOAP_DELETE(static_cast<sd__staticServiceDataValues*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<sd__staticServiceDataValues*>(p->ptr));
		break;
	case SOAP_TYPE_gwsdl__portType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<gwsdl__portType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<gwsdl__portType*>(p->ptr));
		break;
	case SOAP_TYPE_wsa__EndpointReferenceType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<wsa__EndpointReferenceType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<wsa__EndpointReferenceType*>(p->ptr));
		break;
	case SOAP_TYPE_wsp__PolicyReference:
		if (p->size < 0)
			SOAP_DELETE(static_cast<wsp__PolicyReference*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<wsp__PolicyReference*>(p->ptr));
		break;
	case SOAP_TYPE_wsp__Assertion:
		if (p->size < 0)
			SOAP_DELETE(static_cast<wsp__Assertion*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<wsp__Assertion*>(p->ptr));
		break;
	case SOAP_TYPE_wst__Claims:
		if (p->size < 0)
			SOAP_DELETE(static_cast<wst__Claims*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<wst__Claims*>(p->ptr));
		break;
	case SOAP_TYPE_sp__Header:
		if (p->size < 0)
			SOAP_DELETE(static_cast<sp__Header*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<sp__Header*>(p->ptr));
		break;
	case SOAP_TYPE_sp__Parts:
		if (p->size < 0)
			SOAP_DELETE(static_cast<sp__Parts*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<sp__Parts*>(p->ptr));
		break;
	case SOAP_TYPE_sp__Elements:
		if (p->size < 0)
			SOAP_DELETE(static_cast<sp__Elements*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<sp__Elements*>(p->ptr));
		break;
	case SOAP_TYPE_sp__Token:
		if (p->size < 0)
			SOAP_DELETE(static_cast<sp__Token*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<sp__Token*>(p->ptr));
		break;
	case SOAP_TYPE_wsrmp__Timeout:
		if (p->size < 0)
			SOAP_DELETE(static_cast<wsrmp__Timeout*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<wsrmp__Timeout*>(p->ptr));
		break;
	case SOAP_TYPE_wsrmp__RMAssertion:
		if (p->size < 0)
			SOAP_DELETE(static_cast<wsrmp__RMAssertion*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<wsrmp__RMAssertion*>(p->ptr));
		break;
	case SOAP_TYPE_wsrmp5__Timeout:
		if (p->size < 0)
			SOAP_DELETE(static_cast<wsrmp5__Timeout*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<wsrmp5__Timeout*>(p->ptr));
		break;
	case SOAP_TYPE_wsrmp5__RMAssertion:
		if (p->size < 0)
			SOAP_DELETE(static_cast<wsrmp5__RMAssertion*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<wsrmp5__RMAssertion*>(p->ptr));
		break;
	case SOAP_TYPE_wsp__Content:
		if (p->size < 0)
			SOAP_DELETE(static_cast<wsp__Content*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<wsp__Content*>(p->ptr));
		break;
	case SOAP_TYPE_wsp__Policy:
		if (p->size < 0)
			SOAP_DELETE(static_cast<wsp__Policy*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<wsp__Policy*>(p->ptr));
		break;
	case SOAP_TYPE_wsp__Attachment:
		if (p->size < 0)
			SOAP_DELETE(static_cast<wsp__Attachment*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<wsp__Attachment*>(p->ptr));
		break;
	case SOAP_TYPE_wsp__AppliesTo:
		if (p->size < 0)
			SOAP_DELETE(static_cast<wsp__AppliesTo*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<wsp__AppliesTo*>(p->ptr));
		break;
	case SOAP_TYPE_wsp__PolicyAttachment:
		if (p->size < 0)
			SOAP_DELETE(static_cast<wsp__PolicyAttachment*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<wsp__PolicyAttachment*>(p->ptr));
		break;
	case SOAP_TYPE_plnk__tRole:
		if (p->size < 0)
			SOAP_DELETE(static_cast<plnk__tRole*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<plnk__tRole*>(p->ptr));
		break;
	case SOAP_TYPE_plnk__tPartnerLinkType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<plnk__tPartnerLinkType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<plnk__tPartnerLinkType*>(p->ptr));
		break;
	case SOAP_TYPE_vprop__tQuery:
		if (p->size < 0)
			SOAP_DELETE(static_cast<vprop__tQuery*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<vprop__tQuery*>(p->ptr));
		break;
	case SOAP_TYPE_vprop__tProperty:
		if (p->size < 0)
			SOAP_DELETE(static_cast<vprop__tProperty*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<vprop__tProperty*>(p->ptr));
		break;
	case SOAP_TYPE_vprop__tPropertyAlias:
		if (p->size < 0)
			SOAP_DELETE(static_cast<vprop__tPropertyAlias*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<vprop__tPropertyAlias*>(p->ptr));
		break;
	case SOAP_TYPE_wsdl__import:
		if (p->size < 0)
			SOAP_DELETE(static_cast<wsdl__import*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<wsdl__import*>(p->ptr));
		break;
	case SOAP_TYPE_wsdl__types:
		if (p->size < 0)
			SOAP_DELETE(static_cast<wsdl__types*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<wsdl__types*>(p->ptr));
		break;
	case SOAP_TYPE_wsdl__part:
		if (p->size < 0)
			SOAP_DELETE(static_cast<wsdl__part*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<wsdl__part*>(p->ptr));
		break;
	case SOAP_TYPE_wsdl__message:
		if (p->size < 0)
			SOAP_DELETE(static_cast<wsdl__message*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<wsdl__message*>(p->ptr));
		break;
	case SOAP_TYPE_wsdl__ioput:
		if (p->size < 0)
			SOAP_DELETE(static_cast<wsdl__ioput*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<wsdl__ioput*>(p->ptr));
		break;
	case SOAP_TYPE_wsdl__fault:
		if (p->size < 0)
			SOAP_DELETE(static_cast<wsdl__fault*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<wsdl__fault*>(p->ptr));
		break;
	case SOAP_TYPE_wsdl__operation:
		if (p->size < 0)
			SOAP_DELETE(static_cast<wsdl__operation*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<wsdl__operation*>(p->ptr));
		break;
	case SOAP_TYPE_wsdl__portType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<wsdl__portType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<wsdl__portType*>(p->ptr));
		break;
	case SOAP_TYPE_wsdl__ext_ioput:
		if (p->size < 0)
			SOAP_DELETE(static_cast<wsdl__ext_ioput*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<wsdl__ext_ioput*>(p->ptr));
		break;
	case SOAP_TYPE_wsdl__ext_fault:
		if (p->size < 0)
			SOAP_DELETE(static_cast<wsdl__ext_fault*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<wsdl__ext_fault*>(p->ptr));
		break;
	case SOAP_TYPE_wsdl__ext_operation:
		if (p->size < 0)
			SOAP_DELETE(static_cast<wsdl__ext_operation*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<wsdl__ext_operation*>(p->ptr));
		break;
	case SOAP_TYPE_wsdl__binding:
		if (p->size < 0)
			SOAP_DELETE(static_cast<wsdl__binding*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<wsdl__binding*>(p->ptr));
		break;
	case SOAP_TYPE_wsdl__port:
		if (p->size < 0)
			SOAP_DELETE(static_cast<wsdl__port*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<wsdl__port*>(p->ptr));
		break;
	case SOAP_TYPE_wsdl__service:
		if (p->size < 0)
			SOAP_DELETE(static_cast<wsdl__service*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<wsdl__service*>(p->ptr));
		break;
	case SOAP_TYPE_wsdl__definitions:
		if (p->size < 0)
			SOAP_DELETE(static_cast<wsdl__definitions*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<wsdl__definitions*>(p->ptr));
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Header*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Header*>(p->ptr));
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Code*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Code*>(p->ptr));
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Detail*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Detail*>(p->ptr));
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Reason*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Reason*>(p->ptr));
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Fault*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Fault*>(p->ptr));
		break;
#endif
	case SOAP_TYPE_std__vectorTemplateOfgwsdl__portType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<gwsdl__portType> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<gwsdl__portType> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfvprop__tPropertyAlias:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<vprop__tPropertyAlias> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<vprop__tPropertyAlias> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfvprop__tProperty:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<vprop__tProperty> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<vprop__tProperty> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfplnk__tPartnerLinkType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<plnk__tPartnerLinkType> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<plnk__tPartnerLinkType> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfwsdl__service:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<wsdl__service> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<wsdl__service> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfwsdl__binding:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<wsdl__binding> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<wsdl__binding> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfwsdl__portType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<wsdl__portType> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<wsdl__portType> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfwsdl__message:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<wsdl__message> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<wsdl__message> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfwsdl__import:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<wsdl__import> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<wsdl__import> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfwsdl__port:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<wsdl__port> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<wsdl__port> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfwsdl__ext_operation:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<wsdl__ext_operation> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<wsdl__ext_operation> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfwsdl__ext_fault:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<wsdl__ext_fault> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<wsdl__ext_fault> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfwhttp__header:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<whttp__header> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<whttp__header> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfwsoap__header:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<wsoap__header> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<wsoap__header> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfwsoap__module:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<wsoap__module> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<wsoap__module> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfwsdl__operation:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<wsdl__operation> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<wsdl__operation> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfwsdl__fault:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<wsdl__fault> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<wsdl__fault> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfwsdl__part:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<wsdl__part> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<wsdl__part> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfwsp__PolicyReference:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<wsp__PolicyReference> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<wsp__PolicyReference> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfwsp__Policy:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<wsp__Policy> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<wsp__Policy> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToxs__schema:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<xs__schema *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<xs__schema *> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfplnk__tRole:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<plnk__tRole> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<plnk__tRole> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfwsp__Attachment:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<wsp__Attachment> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<wsp__Attachment> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOf_XML:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<char *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<char *> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfsp__Parts:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<sp__Parts> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<sp__Parts> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTowsp__Content:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<wsp__Content *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<wsp__Content *> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfxsd__string:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<char *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<char *> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfsp__Header:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<sp__Header> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<sp__Header> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfsd__serviceData:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<sd__serviceData> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<sd__serviceData> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTowsdl__operation:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<wsdl__operation *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<wsdl__operation *> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfmime__part:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<mime__part> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<mime__part> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfmime__content:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<mime__content> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<mime__content> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfsoap__header:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<soap__header> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<soap__header> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfsoap__headerfault:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<soap__headerfault> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<soap__headerfault> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfwadl__method:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<wadl__method> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<wadl__method> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfwadl__resource_USCOREtype:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<wadl__resource_USCOREtype> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<wadl__resource_USCOREtype> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfwadl__resources:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<wadl__resources> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<wadl__resources> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfwadl__resource:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<wadl__resource> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<wadl__resource> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTowadl__resource_USCOREtype:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<wadl__resource_USCOREtype *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<wadl__resource_USCOREtype *> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOf__wadl__method_resource_choice:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<__wadl__method_resource_choice> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<__wadl__method_resource_choice> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfwadl__response:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<wadl__response> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<wadl__response> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfwadl__representation:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<wadl__representation> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<wadl__representation> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfwadl__param:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<wadl__param> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<wadl__param> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfwadl__include:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<wadl__include> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<wadl__include> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfwadl__option:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<wadl__option> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<wadl__option> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfwadl__doc:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<wadl__doc> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<wadl__doc> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfxs__import:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<xs__import> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<xs__import> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfxs__redefine:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<xs__redefine> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<xs__redefine> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfxs__override:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<xs__override> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<xs__override> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfxs__include:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<xs__include> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<xs__include> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfxs__complexType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<xs__complexType> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<xs__complexType> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfxs__group:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<xs__group> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<xs__group> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfxs__simpleType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<xs__simpleType> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<xs__simpleType> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfxs__pattern:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<xs__pattern> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<xs__pattern> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfxs__enumeration:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<xs__enumeration> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<xs__enumeration> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfxs__assert:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<xs__assert> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<xs__assert> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfxs__attributeGroup:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<xs__attributeGroup> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<xs__attributeGroup> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfxs__attribute:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<xs__attribute> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<xs__attribute> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfxs__contents:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<xs__contents> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<xs__contents> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfxs__element:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<xs__element> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<xs__element> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToxs__element:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<xs__element *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<xs__element *> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfxs__alternative:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<xs__alternative> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<xs__alternative> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfstring:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<char *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<char *> *>(p->ptr));
		break;
	default:
		return SOAP_ERR;
	}
	return SOAP_OK;
}

#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 int SOAP_FMAC4 wsdl_fbase(int t, int b)
{
	do
	{	switch (t)
		{

		case SOAP_TYPE_wadl__response: t = SOAP_TYPE_wadl__request; break;
		case SOAP_TYPE_wadl__resource: t = SOAP_TYPE_wadl__resource_USCOREtype; break;
		case SOAP_TYPE_sp__Token: t = SOAP_TYPE_wsp__Assertion; break;
		case SOAP_TYPE_wsrmp__RMAssertion: t = SOAP_TYPE_wsp__Assertion; break;
		case SOAP_TYPE_wsrmp5__RMAssertion: t = SOAP_TYPE_wsp__Assertion; break;
		case SOAP_TYPE_wsp__Policy: t = SOAP_TYPE_wsp__Content; break;
		case SOAP_TYPE_wsdl__types: t = SOAP_TYPE_xs__schema; break;
		default: return 0;
		}
	}
	while (t != b);
	return 1;
}
#ifdef WIN32
#pragma warning(pop)
#endif

#ifndef WITH_NOIDREF
#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 void SOAP_FMAC4 wsdl_finsert(struct soap *soap, int t, int tt, void *p, size_t index, const void *q, void **x)
{
	(void)soap; (void)t; (void)p; (void)index; (void)q; (void)x; /* appease -Wall -Werror */
	switch (tt)
	{
	case SOAP_TYPE_std__vectorTemplateOfgwsdl__portType:
		if (t == SOAP_TYPE_gwsdl__portType)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<gwsdl__portType>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<gwsdl__portType> *)p)[index] = *(gwsdl__portType *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfvprop__tPropertyAlias:
		if (t == SOAP_TYPE_vprop__tPropertyAlias)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<vprop__tPropertyAlias>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<vprop__tPropertyAlias> *)p)[index] = *(vprop__tPropertyAlias *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfvprop__tProperty:
		if (t == SOAP_TYPE_vprop__tProperty)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<vprop__tProperty>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<vprop__tProperty> *)p)[index] = *(vprop__tProperty *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfplnk__tPartnerLinkType:
		if (t == SOAP_TYPE_plnk__tPartnerLinkType)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<plnk__tPartnerLinkType>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<plnk__tPartnerLinkType> *)p)[index] = *(plnk__tPartnerLinkType *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfwsdl__service:
		if (t == SOAP_TYPE_wsdl__service)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<wsdl__service>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<wsdl__service> *)p)[index] = *(wsdl__service *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfwsdl__binding:
		if (t == SOAP_TYPE_wsdl__binding)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<wsdl__binding>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<wsdl__binding> *)p)[index] = *(wsdl__binding *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfwsdl__portType:
		if (t == SOAP_TYPE_wsdl__portType)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<wsdl__portType>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<wsdl__portType> *)p)[index] = *(wsdl__portType *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfwsdl__message:
		if (t == SOAP_TYPE_wsdl__message)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<wsdl__message>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<wsdl__message> *)p)[index] = *(wsdl__message *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfwsdl__import:
		if (t == SOAP_TYPE_wsdl__import)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<wsdl__import>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<wsdl__import> *)p)[index] = *(wsdl__import *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfwsdl__port:
		if (t == SOAP_TYPE_wsdl__port)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<wsdl__port>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<wsdl__port> *)p)[index] = *(wsdl__port *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfwsdl__ext_operation:
		if (t == SOAP_TYPE_wsdl__ext_operation)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<wsdl__ext_operation>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<wsdl__ext_operation> *)p)[index] = *(wsdl__ext_operation *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfwsdl__ext_fault:
		if (t == SOAP_TYPE_wsdl__ext_fault)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<wsdl__ext_fault>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<wsdl__ext_fault> *)p)[index] = *(wsdl__ext_fault *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfwhttp__header:
		if (t == SOAP_TYPE_whttp__header)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<whttp__header>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<whttp__header> *)p)[index] = *(whttp__header *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfwsoap__header:
		if (t == SOAP_TYPE_wsoap__header)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<wsoap__header>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<wsoap__header> *)p)[index] = *(wsoap__header *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfwsoap__module:
		if (t == SOAP_TYPE_wsoap__module)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<wsoap__module>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<wsoap__module> *)p)[index] = *(wsoap__module *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfwsdl__operation:
		if (t == SOAP_TYPE_wsdl__operation)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<wsdl__operation>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<wsdl__operation> *)p)[index] = *(wsdl__operation *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfwsdl__fault:
		if (t == SOAP_TYPE_wsdl__fault)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<wsdl__fault>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<wsdl__fault> *)p)[index] = *(wsdl__fault *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfwsdl__part:
		if (t == SOAP_TYPE_wsdl__part)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<wsdl__part>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<wsdl__part> *)p)[index] = *(wsdl__part *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfwsp__PolicyReference:
		if (t == SOAP_TYPE_wsp__PolicyReference)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<wsp__PolicyReference>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<wsp__PolicyReference> *)p)[index] = *(wsp__PolicyReference *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfwsp__Policy:
		if (t == SOAP_TYPE_wsp__Policy)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<wsp__Policy>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<wsp__Policy> *)p)[index] = *(wsp__Policy *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToxs__schema:
		if (t == SOAP_TYPE_xs__schema || wsdl_fbase(t, SOAP_TYPE_xs__schema))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<xs__schema *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<xs__schema *> *)p)[index] = *(xs__schema **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfplnk__tRole:
		if (t == SOAP_TYPE_plnk__tRole)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<plnk__tRole>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<plnk__tRole> *)p)[index] = *(plnk__tRole *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfwsp__Attachment:
		if (t == SOAP_TYPE_wsp__Attachment)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<wsp__Attachment>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<wsp__Attachment> *)p)[index] = *(wsp__Attachment *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOf_XML:
		if (t == SOAP_TYPE__XML)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<char *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<char *> *)p)[index] = *(char **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfsp__Parts:
		if (t == SOAP_TYPE_sp__Parts)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<sp__Parts>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<sp__Parts> *)p)[index] = *(sp__Parts *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTowsp__Content:
		if (t == SOAP_TYPE_wsp__Content || wsdl_fbase(t, SOAP_TYPE_wsp__Content))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<wsp__Content *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<wsp__Content *> *)p)[index] = *(wsp__Content **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfxsd__string:
		if (t == SOAP_TYPE_xsd__string)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<char *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<char *> *)p)[index] = *(char **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfsp__Header:
		if (t == SOAP_TYPE_sp__Header)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<sp__Header>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<sp__Header> *)p)[index] = *(sp__Header *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfsd__serviceData:
		if (t == SOAP_TYPE_sd__serviceData)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<sd__serviceData>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<sd__serviceData> *)p)[index] = *(sd__serviceData *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTowsdl__operation:
		if (t == SOAP_TYPE_wsdl__operation || wsdl_fbase(t, SOAP_TYPE_wsdl__operation))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<wsdl__operation *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<wsdl__operation *> *)p)[index] = *(wsdl__operation **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfmime__part:
		if (t == SOAP_TYPE_mime__part)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<mime__part>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<mime__part> *)p)[index] = *(mime__part *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfmime__content:
		if (t == SOAP_TYPE_mime__content)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<mime__content>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<mime__content> *)p)[index] = *(mime__content *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfsoap__header:
		if (t == SOAP_TYPE_soap__header)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<soap__header>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<soap__header> *)p)[index] = *(soap__header *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfsoap__headerfault:
		if (t == SOAP_TYPE_soap__headerfault)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<soap__headerfault>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<soap__headerfault> *)p)[index] = *(soap__headerfault *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfwadl__method:
		if (t == SOAP_TYPE_wadl__method)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<wadl__method>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<wadl__method> *)p)[index] = *(wadl__method *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfwadl__resource_USCOREtype:
		if (t == SOAP_TYPE_wadl__resource_USCOREtype)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<wadl__resource_USCOREtype>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<wadl__resource_USCOREtype> *)p)[index] = *(wadl__resource_USCOREtype *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfwadl__resources:
		if (t == SOAP_TYPE_wadl__resources)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<wadl__resources>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<wadl__resources> *)p)[index] = *(wadl__resources *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfwadl__resource:
		if (t == SOAP_TYPE_wadl__resource)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<wadl__resource>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<wadl__resource> *)p)[index] = *(wadl__resource *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTowadl__resource_USCOREtype:
		if (t == SOAP_TYPE_wadl__resource_USCOREtype || wsdl_fbase(t, SOAP_TYPE_wadl__resource_USCOREtype))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<wadl__resource_USCOREtype *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<wadl__resource_USCOREtype *> *)p)[index] = *(wadl__resource_USCOREtype **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOf__wadl__method_resource_choice:
		if (t == SOAP_TYPE___wadl__method_resource_choice)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<__wadl__method_resource_choice>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<__wadl__method_resource_choice> *)p)[index] = *(__wadl__method_resource_choice *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfwadl__response:
		if (t == SOAP_TYPE_wadl__response)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<wadl__response>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<wadl__response> *)p)[index] = *(wadl__response *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfwadl__representation:
		if (t == SOAP_TYPE_wadl__representation)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<wadl__representation>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<wadl__representation> *)p)[index] = *(wadl__representation *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfwadl__param:
		if (t == SOAP_TYPE_wadl__param)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<wadl__param>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<wadl__param> *)p)[index] = *(wadl__param *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfwadl__include:
		if (t == SOAP_TYPE_wadl__include)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<wadl__include>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<wadl__include> *)p)[index] = *(wadl__include *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfwadl__option:
		if (t == SOAP_TYPE_wadl__option)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<wadl__option>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<wadl__option> *)p)[index] = *(wadl__option *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfwadl__doc:
		if (t == SOAP_TYPE_wadl__doc)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<wadl__doc>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<wadl__doc> *)p)[index] = *(wadl__doc *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfxs__import:
		if (t == SOAP_TYPE_xs__import)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<xs__import>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<xs__import> *)p)[index] = *(xs__import *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfxs__redefine:
		if (t == SOAP_TYPE_xs__redefine)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<xs__redefine>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<xs__redefine> *)p)[index] = *(xs__redefine *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfxs__override:
		if (t == SOAP_TYPE_xs__override)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<xs__override>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<xs__override> *)p)[index] = *(xs__override *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfxs__include:
		if (t == SOAP_TYPE_xs__include)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<xs__include>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<xs__include> *)p)[index] = *(xs__include *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfxs__complexType:
		if (t == SOAP_TYPE_xs__complexType)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<xs__complexType>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<xs__complexType> *)p)[index] = *(xs__complexType *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfxs__group:
		if (t == SOAP_TYPE_xs__group)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<xs__group>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<xs__group> *)p)[index] = *(xs__group *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfxs__simpleType:
		if (t == SOAP_TYPE_xs__simpleType)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<xs__simpleType>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<xs__simpleType> *)p)[index] = *(xs__simpleType *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfxs__pattern:
		if (t == SOAP_TYPE_xs__pattern)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<xs__pattern>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<xs__pattern> *)p)[index] = *(xs__pattern *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfxs__enumeration:
		if (t == SOAP_TYPE_xs__enumeration)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<xs__enumeration>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<xs__enumeration> *)p)[index] = *(xs__enumeration *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfxs__assert:
		if (t == SOAP_TYPE_xs__assert)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<xs__assert>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<xs__assert> *)p)[index] = *(xs__assert *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfxs__attributeGroup:
		if (t == SOAP_TYPE_xs__attributeGroup)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<xs__attributeGroup>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<xs__attributeGroup> *)p)[index] = *(xs__attributeGroup *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfxs__attribute:
		if (t == SOAP_TYPE_xs__attribute)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<xs__attribute>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<xs__attribute> *)p)[index] = *(xs__attribute *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfxs__contents:
		if (t == SOAP_TYPE_xs__contents)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<xs__contents>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<xs__contents> *)p)[index] = *(xs__contents *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfxs__element:
		if (t == SOAP_TYPE_xs__element)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<xs__element>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<xs__element> *)p)[index] = *(xs__element *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToxs__element:
		if (t == SOAP_TYPE_xs__element || wsdl_fbase(t, SOAP_TYPE_xs__element))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<xs__element *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<xs__element *> *)p)[index] = *(xs__element **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfxs__alternative:
		if (t == SOAP_TYPE_xs__alternative)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<xs__alternative>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<xs__alternative> *)p)[index] = *(xs__alternative *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfstring:
		if (t == SOAP_TYPE_string)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<char *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<char *> *)p)[index] = *(char **)q;
		}
		break;
	case SOAP_TYPE_xs__annotation:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xs__annotation type=%d location=%p object=%p\n", t, p, q));
		*(xs__annotation*)p = *(xs__annotation*)q;
		break;
	case SOAP_TYPE_xs__assert:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xs__assert type=%d location=%p object=%p\n", t, p, q));
		*(xs__assert*)p = *(xs__assert*)q;
		break;
	case SOAP_TYPE_xs__alternative:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xs__alternative type=%d location=%p object=%p\n", t, p, q));
		*(xs__alternative*)p = *(xs__alternative*)q;
		break;
	case SOAP_TYPE_xs__element:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xs__element type=%d location=%p object=%p\n", t, p, q));
		*(xs__element*)p = *(xs__element*)q;
		break;
	case SOAP_TYPE_xs__attribute:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xs__attribute type=%d location=%p object=%p\n", t, p, q));
		*(xs__attribute*)p = *(xs__attribute*)q;
		break;
	case SOAP_TYPE_xs__all:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xs__all type=%d location=%p object=%p\n", t, p, q));
		*(xs__all*)p = *(xs__all*)q;
		break;
	case SOAP_TYPE_xs__any:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xs__any type=%d location=%p object=%p\n", t, p, q));
		*(xs__any*)p = *(xs__any*)q;
		break;
	case SOAP_TYPE_xs__union_content:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy union xs__union_content type=%d location=%p object=%p\n", t, p, q));
		*(union xs__union_content*)p = *(union xs__union_content*)q;
		break;
	case SOAP_TYPE_xs__contents:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xs__contents type=%d location=%p object=%p\n", t, p, q));
		*(xs__contents*)p = *(xs__contents*)q;
		break;
	case SOAP_TYPE_xs__seqchoice:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xs__seqchoice type=%d location=%p object=%p\n", t, p, q));
		*(xs__seqchoice*)p = *(xs__seqchoice*)q;
		break;
	case SOAP_TYPE_xs__group:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xs__group type=%d location=%p object=%p\n", t, p, q));
		*(xs__group*)p = *(xs__group*)q;
		break;
	case SOAP_TYPE_xs__anyAttribute:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xs__anyAttribute type=%d location=%p object=%p\n", t, p, q));
		*(xs__anyAttribute*)p = *(xs__anyAttribute*)q;
		break;
	case SOAP_TYPE_xs__attributeGroup:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xs__attributeGroup type=%d location=%p object=%p\n", t, p, q));
		*(xs__attributeGroup*)p = *(xs__attributeGroup*)q;
		break;
	case SOAP_TYPE_xs__enumeration:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xs__enumeration type=%d location=%p object=%p\n", t, p, q));
		*(xs__enumeration*)p = *(xs__enumeration*)q;
		break;
	case SOAP_TYPE_xs__pattern:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xs__pattern type=%d location=%p object=%p\n", t, p, q));
		*(xs__pattern*)p = *(xs__pattern*)q;
		break;
	case SOAP_TYPE_xs__simpleContent:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xs__simpleContent type=%d location=%p object=%p\n", t, p, q));
		*(xs__simpleContent*)p = *(xs__simpleContent*)q;
		break;
	case SOAP_TYPE_xs__simpleType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xs__simpleType type=%d location=%p object=%p\n", t, p, q));
		*(xs__simpleType*)p = *(xs__simpleType*)q;
		break;
	case SOAP_TYPE_xs__extension:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xs__extension type=%d location=%p object=%p\n", t, p, q));
		*(xs__extension*)p = *(xs__extension*)q;
		break;
	case SOAP_TYPE_xs__length:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xs__length type=%d location=%p object=%p\n", t, p, q));
		*(xs__length*)p = *(xs__length*)q;
		break;
	case SOAP_TYPE_xs__whiteSpace:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xs__whiteSpace type=%d location=%p object=%p\n", t, p, q));
		*(xs__whiteSpace*)p = *(xs__whiteSpace*)q;
		break;
	case SOAP_TYPE_xs__restriction:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xs__restriction type=%d location=%p object=%p\n", t, p, q));
		*(xs__restriction*)p = *(xs__restriction*)q;
		break;
	case SOAP_TYPE_xs__list:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xs__list type=%d location=%p object=%p\n", t, p, q));
		*(xs__list*)p = *(xs__list*)q;
		break;
	case SOAP_TYPE_xs__union:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xs__union type=%d location=%p object=%p\n", t, p, q));
		*(xs__union*)p = *(xs__union*)q;
		break;
	case SOAP_TYPE_xs__complexContent:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xs__complexContent type=%d location=%p object=%p\n", t, p, q));
		*(xs__complexContent*)p = *(xs__complexContent*)q;
		break;
	case SOAP_TYPE_xs__complexType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xs__complexType type=%d location=%p object=%p\n", t, p, q));
		*(xs__complexType*)p = *(xs__complexType*)q;
		break;
	case SOAP_TYPE_xs__import:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xs__import type=%d location=%p object=%p\n", t, p, q));
		*(xs__import*)p = *(xs__import*)q;
		break;
	case SOAP_TYPE_xs__include:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xs__include type=%d location=%p object=%p\n", t, p, q));
		*(xs__include*)p = *(xs__include*)q;
		break;
	case SOAP_TYPE_xs__override:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xs__override type=%d location=%p object=%p\n", t, p, q));
		*(xs__override*)p = *(xs__override*)q;
		break;
	case SOAP_TYPE_xs__redefine:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xs__redefine type=%d location=%p object=%p\n", t, p, q));
		*(xs__redefine*)p = *(xs__redefine*)q;
		break;
	case SOAP_TYPE_xs__schema:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xs__schema type=%d location=%p object=%p\n", t, p, q));
		*(xs__schema*)p = *(xs__schema*)q;
		break;
	case SOAP_TYPE_wadl__doc:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wadl__doc type=%d location=%p object=%p\n", t, p, q));
		*(wadl__doc*)p = *(wadl__doc*)q;
		break;
	case SOAP_TYPE_wadl__option:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wadl__option type=%d location=%p object=%p\n", t, p, q));
		*(wadl__option*)p = *(wadl__option*)q;
		break;
	case SOAP_TYPE_wadl__link:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wadl__link type=%d location=%p object=%p\n", t, p, q));
		*(wadl__link*)p = *(wadl__link*)q;
		break;
	case SOAP_TYPE_wadl__param:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wadl__param type=%d location=%p object=%p\n", t, p, q));
		*(wadl__param*)p = *(wadl__param*)q;
		break;
	case SOAP_TYPE_wadl__include:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wadl__include type=%d location=%p object=%p\n", t, p, q));
		*(wadl__include*)p = *(wadl__include*)q;
		break;
	case SOAP_TYPE_wadl__grammars:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wadl__grammars type=%d location=%p object=%p\n", t, p, q));
		*(wadl__grammars*)p = *(wadl__grammars*)q;
		break;
	case SOAP_TYPE_wadl__representation:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wadl__representation type=%d location=%p object=%p\n", t, p, q));
		*(wadl__representation*)p = *(wadl__representation*)q;
		break;
	case SOAP_TYPE_wadl__request:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wadl__request type=%d location=%p object=%p\n", t, p, q));
		*(wadl__request*)p = *(wadl__request*)q;
		break;
	case SOAP_TYPE_wadl__response:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wadl__response type=%d location=%p object=%p\n", t, p, q));
		*(wadl__response*)p = *(wadl__response*)q;
		break;
	case SOAP_TYPE_wadl__method:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wadl__method type=%d location=%p object=%p\n", t, p, q));
		*(wadl__method*)p = *(wadl__method*)q;
		break;
	case SOAP_TYPE___wadl__method_resource_choice:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy __wadl__method_resource_choice type=%d location=%p object=%p\n", t, p, q));
		*(__wadl__method_resource_choice*)p = *(__wadl__method_resource_choice*)q;
		break;
	case SOAP_TYPE_wadl__resource_USCOREtype:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wadl__resource_USCOREtype type=%d location=%p object=%p\n", t, p, q));
		*(wadl__resource_USCOREtype*)p = *(wadl__resource_USCOREtype*)q;
		break;
	case SOAP_TYPE_wadl__resource:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wadl__resource type=%d location=%p object=%p\n", t, p, q));
		*(wadl__resource*)p = *(wadl__resource*)q;
		break;
	case SOAP_TYPE_wadl__resources:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wadl__resources type=%d location=%p object=%p\n", t, p, q));
		*(wadl__resources*)p = *(wadl__resources*)q;
		break;
	case SOAP_TYPE_wadl__application:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wadl__application type=%d location=%p object=%p\n", t, p, q));
		*(wadl__application*)p = *(wadl__application*)q;
		break;
	case SOAP_TYPE_soap__binding:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy soap__binding type=%d location=%p object=%p\n", t, p, q));
		*(soap__binding*)p = *(soap__binding*)q;
		break;
	case SOAP_TYPE_soap__operation:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy soap__operation type=%d location=%p object=%p\n", t, p, q));
		*(soap__operation*)p = *(soap__operation*)q;
		break;
	case SOAP_TYPE_soap__body:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy soap__body type=%d location=%p object=%p\n", t, p, q));
		*(soap__body*)p = *(soap__body*)q;
		break;
	case SOAP_TYPE_soap__fault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy soap__fault type=%d location=%p object=%p\n", t, p, q));
		*(soap__fault*)p = *(soap__fault*)q;
		break;
	case SOAP_TYPE_soap__headerfault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy soap__headerfault type=%d location=%p object=%p\n", t, p, q));
		*(soap__headerfault*)p = *(soap__headerfault*)q;
		break;
	case SOAP_TYPE_soap__header:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy soap__header type=%d location=%p object=%p\n", t, p, q));
		*(soap__header*)p = *(soap__header*)q;
		break;
	case SOAP_TYPE_soap__address:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy soap__address type=%d location=%p object=%p\n", t, p, q));
		*(soap__address*)p = *(soap__address*)q;
		break;
	case SOAP_TYPE_wsoap__module:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsoap__module type=%d location=%p object=%p\n", t, p, q));
		*(wsoap__module*)p = *(wsoap__module*)q;
		break;
	case SOAP_TYPE_wsoap__header:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsoap__header type=%d location=%p object=%p\n", t, p, q));
		*(wsoap__header*)p = *(wsoap__header*)q;
		break;
	case SOAP_TYPE_mime__content:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy mime__content type=%d location=%p object=%p\n", t, p, q));
		*(mime__content*)p = *(mime__content*)q;
		break;
	case SOAP_TYPE_mime__part:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy mime__part type=%d location=%p object=%p\n", t, p, q));
		*(mime__part*)p = *(mime__part*)q;
		break;
	case SOAP_TYPE_mime__multipartRelated:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy mime__multipartRelated type=%d location=%p object=%p\n", t, p, q));
		*(mime__multipartRelated*)p = *(mime__multipartRelated*)q;
		break;
	case SOAP_TYPE_mime__mimeXml:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy mime__mimeXml type=%d location=%p object=%p\n", t, p, q));
		*(mime__mimeXml*)p = *(mime__mimeXml*)q;
		break;
	case SOAP_TYPE_dime__message:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy dime__message type=%d location=%p object=%p\n", t, p, q));
		*(dime__message*)p = *(dime__message*)q;
		break;
	case SOAP_TYPE_http__address:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy http__address type=%d location=%p object=%p\n", t, p, q));
		*(http__address*)p = *(http__address*)q;
		break;
	case SOAP_TYPE_http__binding:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy http__binding type=%d location=%p object=%p\n", t, p, q));
		*(http__binding*)p = *(http__binding*)q;
		break;
	case SOAP_TYPE_http__operation:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy http__operation type=%d location=%p object=%p\n", t, p, q));
		*(http__operation*)p = *(http__operation*)q;
		break;
	case SOAP_TYPE_whttp__header:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy whttp__header type=%d location=%p object=%p\n", t, p, q));
		*(whttp__header*)p = *(whttp__header*)q;
		break;
	case SOAP_TYPE_sd__serviceData:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy sd__serviceData type=%d location=%p object=%p\n", t, p, q));
		*(sd__serviceData*)p = *(sd__serviceData*)q;
		break;
	case SOAP_TYPE_sd__staticServiceDataValues:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy sd__staticServiceDataValues type=%d location=%p object=%p\n", t, p, q));
		*(sd__staticServiceDataValues*)p = *(sd__staticServiceDataValues*)q;
		break;
	case SOAP_TYPE_gwsdl__portType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy gwsdl__portType type=%d location=%p object=%p\n", t, p, q));
		*(gwsdl__portType*)p = *(gwsdl__portType*)q;
		break;
	case SOAP_TYPE_wsa__EndpointReferenceType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsa__EndpointReferenceType type=%d location=%p object=%p\n", t, p, q));
		*(wsa__EndpointReferenceType*)p = *(wsa__EndpointReferenceType*)q;
		break;
	case SOAP_TYPE_wsp__PolicyReference:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsp__PolicyReference type=%d location=%p object=%p\n", t, p, q));
		*(wsp__PolicyReference*)p = *(wsp__PolicyReference*)q;
		break;
	case SOAP_TYPE_wsp__Assertion:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsp__Assertion type=%d location=%p object=%p\n", t, p, q));
		*(wsp__Assertion*)p = *(wsp__Assertion*)q;
		break;
	case SOAP_TYPE_wst__Claims:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wst__Claims type=%d location=%p object=%p\n", t, p, q));
		*(wst__Claims*)p = *(wst__Claims*)q;
		break;
	case SOAP_TYPE_sp__Header:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy sp__Header type=%d location=%p object=%p\n", t, p, q));
		*(sp__Header*)p = *(sp__Header*)q;
		break;
	case SOAP_TYPE_sp__Parts:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy sp__Parts type=%d location=%p object=%p\n", t, p, q));
		*(sp__Parts*)p = *(sp__Parts*)q;
		break;
	case SOAP_TYPE_sp__Elements:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy sp__Elements type=%d location=%p object=%p\n", t, p, q));
		*(sp__Elements*)p = *(sp__Elements*)q;
		break;
	case SOAP_TYPE_sp__Token:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy sp__Token type=%d location=%p object=%p\n", t, p, q));
		*(sp__Token*)p = *(sp__Token*)q;
		break;
	case SOAP_TYPE_wsrmp__Timeout:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsrmp__Timeout type=%d location=%p object=%p\n", t, p, q));
		*(wsrmp__Timeout*)p = *(wsrmp__Timeout*)q;
		break;
	case SOAP_TYPE_wsrmp__RMAssertion:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsrmp__RMAssertion type=%d location=%p object=%p\n", t, p, q));
		*(wsrmp__RMAssertion*)p = *(wsrmp__RMAssertion*)q;
		break;
	case SOAP_TYPE_wsrmp5__Timeout:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsrmp5__Timeout type=%d location=%p object=%p\n", t, p, q));
		*(wsrmp5__Timeout*)p = *(wsrmp5__Timeout*)q;
		break;
	case SOAP_TYPE_wsrmp5__RMAssertion:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsrmp5__RMAssertion type=%d location=%p object=%p\n", t, p, q));
		*(wsrmp5__RMAssertion*)p = *(wsrmp5__RMAssertion*)q;
		break;
	case SOAP_TYPE_wsp__Content:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsp__Content type=%d location=%p object=%p\n", t, p, q));
		*(wsp__Content*)p = *(wsp__Content*)q;
		break;
	case SOAP_TYPE_wsp__Policy:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsp__Policy type=%d location=%p object=%p\n", t, p, q));
		*(wsp__Policy*)p = *(wsp__Policy*)q;
		break;
	case SOAP_TYPE_wsp__Attachment:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsp__Attachment type=%d location=%p object=%p\n", t, p, q));
		*(wsp__Attachment*)p = *(wsp__Attachment*)q;
		break;
	case SOAP_TYPE_wsp__AppliesTo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsp__AppliesTo type=%d location=%p object=%p\n", t, p, q));
		*(wsp__AppliesTo*)p = *(wsp__AppliesTo*)q;
		break;
	case SOAP_TYPE_wsp__PolicyAttachment:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsp__PolicyAttachment type=%d location=%p object=%p\n", t, p, q));
		*(wsp__PolicyAttachment*)p = *(wsp__PolicyAttachment*)q;
		break;
	case SOAP_TYPE_plnk__tRole:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy plnk__tRole type=%d location=%p object=%p\n", t, p, q));
		*(plnk__tRole*)p = *(plnk__tRole*)q;
		break;
	case SOAP_TYPE_plnk__tPartnerLinkType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy plnk__tPartnerLinkType type=%d location=%p object=%p\n", t, p, q));
		*(plnk__tPartnerLinkType*)p = *(plnk__tPartnerLinkType*)q;
		break;
	case SOAP_TYPE_vprop__tQuery:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy vprop__tQuery type=%d location=%p object=%p\n", t, p, q));
		*(vprop__tQuery*)p = *(vprop__tQuery*)q;
		break;
	case SOAP_TYPE_vprop__tProperty:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy vprop__tProperty type=%d location=%p object=%p\n", t, p, q));
		*(vprop__tProperty*)p = *(vprop__tProperty*)q;
		break;
	case SOAP_TYPE_vprop__tPropertyAlias:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy vprop__tPropertyAlias type=%d location=%p object=%p\n", t, p, q));
		*(vprop__tPropertyAlias*)p = *(vprop__tPropertyAlias*)q;
		break;
	case SOAP_TYPE_wsdl__import:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsdl__import type=%d location=%p object=%p\n", t, p, q));
		*(wsdl__import*)p = *(wsdl__import*)q;
		break;
	case SOAP_TYPE_wsdl__types:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsdl__types type=%d location=%p object=%p\n", t, p, q));
		*(wsdl__types*)p = *(wsdl__types*)q;
		break;
	case SOAP_TYPE_wsdl__part:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsdl__part type=%d location=%p object=%p\n", t, p, q));
		*(wsdl__part*)p = *(wsdl__part*)q;
		break;
	case SOAP_TYPE_wsdl__message:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsdl__message type=%d location=%p object=%p\n", t, p, q));
		*(wsdl__message*)p = *(wsdl__message*)q;
		break;
	case SOAP_TYPE_wsdl__ioput:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsdl__ioput type=%d location=%p object=%p\n", t, p, q));
		*(wsdl__ioput*)p = *(wsdl__ioput*)q;
		break;
	case SOAP_TYPE_wsdl__fault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsdl__fault type=%d location=%p object=%p\n", t, p, q));
		*(wsdl__fault*)p = *(wsdl__fault*)q;
		break;
	case SOAP_TYPE_wsdl__union_ioput:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy union wsdl__union_ioput type=%d location=%p object=%p\n", t, p, q));
		*(union wsdl__union_ioput*)p = *(union wsdl__union_ioput*)q;
		break;
	case SOAP_TYPE_wsdl__operation:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsdl__operation type=%d location=%p object=%p\n", t, p, q));
		*(wsdl__operation*)p = *(wsdl__operation*)q;
		break;
	case SOAP_TYPE_wsdl__portType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsdl__portType type=%d location=%p object=%p\n", t, p, q));
		*(wsdl__portType*)p = *(wsdl__portType*)q;
		break;
	case SOAP_TYPE_wsdl__ext_ioput:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsdl__ext_ioput type=%d location=%p object=%p\n", t, p, q));
		*(wsdl__ext_ioput*)p = *(wsdl__ext_ioput*)q;
		break;
	case SOAP_TYPE_wsdl__ext_fault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsdl__ext_fault type=%d location=%p object=%p\n", t, p, q));
		*(wsdl__ext_fault*)p = *(wsdl__ext_fault*)q;
		break;
	case SOAP_TYPE_wsdl__ext_operation:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsdl__ext_operation type=%d location=%p object=%p\n", t, p, q));
		*(wsdl__ext_operation*)p = *(wsdl__ext_operation*)q;
		break;
	case SOAP_TYPE_wsdl__binding:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsdl__binding type=%d location=%p object=%p\n", t, p, q));
		*(wsdl__binding*)p = *(wsdl__binding*)q;
		break;
	case SOAP_TYPE_wsdl__port:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsdl__port type=%d location=%p object=%p\n", t, p, q));
		*(wsdl__port*)p = *(wsdl__port*)q;
		break;
	case SOAP_TYPE_wsdl__service:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsdl__service type=%d location=%p object=%p\n", t, p, q));
		*(wsdl__service*)p = *(wsdl__service*)q;
		break;
	case SOAP_TYPE_wsdl__definitions:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy wsdl__definitions type=%d location=%p object=%p\n", t, p, q));
		*(wsdl__definitions*)p = *(wsdl__definitions*)q;
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Header type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Code type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Detail type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Reason type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Fault type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
		break;
#endif
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type = %d in %d\n", t, tt));
	}
}
#ifdef WIN32
#pragma warning(pop)
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	a = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return a;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_new_byte(struct soap *soap, int n)
{
	char *a = static_cast<char *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(char)));
	for (char *p = a; p && n--; ++p)
		soap_default_byte(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	if (soap_out_byte(soap, tag ? tag : "byte", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	a = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return a;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_new_int(struct soap *soap, int n)
{
	int *a = static_cast<int *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(int)));
	for (int *p = a; p && n--; ++p)
		soap_default_int(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	if (soap_out_int(soap, tag ? tag : "int", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_sd__mutability[] =
{	{ (LONG64)static_, "static" },
	{ (LONG64)constant, "constant" },
	{ (LONG64)extendable, "extendable" },
	{ (LONG64)mutable_, "mutable" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_sd__mutability2s(struct soap *soap, enum sd__mutability n)
{	const char *s = soap_code_str(soap_codes_sd__mutability, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_sd__mutability(struct soap *soap, const char *tag, int id, const enum sd__mutability *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sd__mutability), type) || soap_send(soap, soap_sd__mutability2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2sd__mutability(struct soap *soap, const char *s, enum sd__mutability *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_sd__mutability, s);
	if (map)
		*a = (enum sd__mutability)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 3)
			return soap->error = SOAP_TYPE;
		*a = (enum sd__mutability)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum sd__mutability * SOAP_FMAC4 soap_in_sd__mutability(struct soap *soap, const char *tag, enum sd__mutability *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum sd__mutability *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sd__mutability, sizeof(enum sd__mutability), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2sd__mutability(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum sd__mutability *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_sd__mutability, SOAP_TYPE_sd__mutability, sizeof(enum sd__mutability), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum sd__mutability * SOAP_FMAC4 soap_new_sd__mutability(struct soap *soap, int n)
{
	enum sd__mutability *a = static_cast<enum sd__mutability *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum sd__mutability)));
	for (enum sd__mutability *p = a; p && n--; ++p)
		soap_default_sd__mutability(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_sd__mutability(struct soap *soap, const enum sd__mutability *a, const char *tag, const char *type)
{
	if (soap_out_sd__mutability(soap, tag ? tag : "sd:mutability", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum sd__mutability * SOAP_FMAC4 soap_get_sd__mutability(struct soap *soap, enum sd__mutability *p, const char *tag, const char *type)
{
	if ((p = soap_in_sd__mutability(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_soap__useChoice[] =
{	{ (LONG64)literal, "literal" },
	{ (LONG64)encoded, "encoded" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_soap__useChoice2s(struct soap *soap, enum soap__useChoice n)
{	const char *s = soap_code_str(soap_codes_soap__useChoice, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_soap__useChoice(struct soap *soap, const char *tag, int id, const enum soap__useChoice *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_soap__useChoice), type) || soap_send(soap, soap_soap__useChoice2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2soap__useChoice(struct soap *soap, const char *s, enum soap__useChoice *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_soap__useChoice, s);
	if (map)
		*a = (enum soap__useChoice)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum soap__useChoice)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum soap__useChoice * SOAP_FMAC4 soap_in_soap__useChoice(struct soap *soap, const char *tag, enum soap__useChoice *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum soap__useChoice *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_soap__useChoice, sizeof(enum soap__useChoice), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2soap__useChoice(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum soap__useChoice *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_soap__useChoice, SOAP_TYPE_soap__useChoice, sizeof(enum soap__useChoice), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum soap__useChoice * SOAP_FMAC4 soap_new_soap__useChoice(struct soap *soap, int n)
{
	enum soap__useChoice *a = static_cast<enum soap__useChoice *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum soap__useChoice)));
	for (enum soap__useChoice *p = a; p && n--; ++p)
		soap_default_soap__useChoice(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_soap__useChoice(struct soap *soap, const enum soap__useChoice *a, const char *tag, const char *type)
{
	if (soap_out_soap__useChoice(soap, tag ? tag : "soap:useChoice", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum soap__useChoice * SOAP_FMAC4 soap_get_soap__useChoice(struct soap *soap, enum soap__useChoice *p, const char *tag, const char *type)
{
	if ((p = soap_in_soap__useChoice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_soap__styleChoice[] =
{	{ (LONG64)rpc, "rpc" },
	{ (LONG64)document, "document" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_soap__styleChoice2s(struct soap *soap, enum soap__styleChoice n)
{	const char *s = soap_code_str(soap_codes_soap__styleChoice, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_soap__styleChoice(struct soap *soap, const char *tag, int id, const enum soap__styleChoice *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_soap__styleChoice), type) || soap_send(soap, soap_soap__styleChoice2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2soap__styleChoice(struct soap *soap, const char *s, enum soap__styleChoice *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_soap__styleChoice, s);
	if (map)
		*a = (enum soap__styleChoice)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum soap__styleChoice)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum soap__styleChoice * SOAP_FMAC4 soap_in_soap__styleChoice(struct soap *soap, const char *tag, enum soap__styleChoice *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum soap__styleChoice *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_soap__styleChoice, sizeof(enum soap__styleChoice), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2soap__styleChoice(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum soap__styleChoice *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_soap__styleChoice, SOAP_TYPE_soap__styleChoice, sizeof(enum soap__styleChoice), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum soap__styleChoice * SOAP_FMAC4 soap_new_soap__styleChoice(struct soap *soap, int n)
{
	enum soap__styleChoice *a = static_cast<enum soap__styleChoice *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum soap__styleChoice)));
	for (enum soap__styleChoice *p = a; p && n--; ++p)
		soap_default_soap__styleChoice(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_soap__styleChoice(struct soap *soap, const enum soap__styleChoice *a, const char *tag, const char *type)
{
	if (soap_out_soap__styleChoice(soap, tag ? tag : "soap:styleChoice", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum soap__styleChoice * SOAP_FMAC4 soap_get_soap__styleChoice(struct soap *soap, enum soap__styleChoice *p, const char *tag, const char *type)
{
	if ((p = soap_in_soap__styleChoice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_wadl__ParamStyle[] =
{	{ (LONG64)plain, "plain" },
	{ (LONG64)query, "query" },
	{ (LONG64)matrix, "matrix" },
	{ (LONG64)header, "header" },
	{ (LONG64)template_, "template" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wadl__ParamStyle2s(struct soap *soap, enum wadl__ParamStyle n)
{	const char *s = soap_code_str(soap_codes_wadl__ParamStyle, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wadl__ParamStyle(struct soap *soap, const char *tag, int id, const enum wadl__ParamStyle *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wadl__ParamStyle), type) || soap_send(soap, soap_wadl__ParamStyle2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wadl__ParamStyle(struct soap *soap, const char *s, enum wadl__ParamStyle *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_wadl__ParamStyle, s);
	if (map)
		*a = (enum wadl__ParamStyle)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 4)
			return soap->error = SOAP_TYPE;
		*a = (enum wadl__ParamStyle)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wadl__ParamStyle * SOAP_FMAC4 soap_in_wadl__ParamStyle(struct soap *soap, const char *tag, enum wadl__ParamStyle *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wadl__ParamStyle *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wadl__ParamStyle, sizeof(enum wadl__ParamStyle), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2wadl__ParamStyle(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum wadl__ParamStyle *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wadl__ParamStyle, SOAP_TYPE_wadl__ParamStyle, sizeof(enum wadl__ParamStyle), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum wadl__ParamStyle * SOAP_FMAC4 soap_new_wadl__ParamStyle(struct soap *soap, int n)
{
	enum wadl__ParamStyle *a = static_cast<enum wadl__ParamStyle *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum wadl__ParamStyle)));
	for (enum wadl__ParamStyle *p = a; p && n--; ++p)
		soap_default_wadl__ParamStyle(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wadl__ParamStyle(struct soap *soap, const enum wadl__ParamStyle *a, const char *tag, const char *type)
{
	if (soap_out_wadl__ParamStyle(soap, tag ? tag : "wadl:ParamStyle", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum wadl__ParamStyle * SOAP_FMAC4 soap_get_wadl__ParamStyle(struct soap *soap, enum wadl__ParamStyle *p, const char *tag, const char *type)
{
	if ((p = soap_in_wadl__ParamStyle(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_wadl__HTTPMethods[] =
{	{ (LONG64)GET, "GET" },
	{ (LONG64)POST, "POST" },
	{ (LONG64)PUT, "PUT" },
	{ (LONG64)HEAD, "HEAD" },
	{ (LONG64)DELETE_, "DELETE" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wadl__HTTPMethods2s(struct soap *soap, enum wadl__HTTPMethods n)
{	const char *s = soap_code_str(soap_codes_wadl__HTTPMethods, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wadl__HTTPMethods(struct soap *soap, const char *tag, int id, const enum wadl__HTTPMethods *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wadl__HTTPMethods), type) || soap_send(soap, soap_wadl__HTTPMethods2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wadl__HTTPMethods(struct soap *soap, const char *s, enum wadl__HTTPMethods *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_wadl__HTTPMethods, s);
	if (map)
		*a = (enum wadl__HTTPMethods)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 4)
			return soap->error = SOAP_TYPE;
		*a = (enum wadl__HTTPMethods)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wadl__HTTPMethods * SOAP_FMAC4 soap_in_wadl__HTTPMethods(struct soap *soap, const char *tag, enum wadl__HTTPMethods *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wadl__HTTPMethods *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wadl__HTTPMethods, sizeof(enum wadl__HTTPMethods), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2wadl__HTTPMethods(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum wadl__HTTPMethods *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wadl__HTTPMethods, SOAP_TYPE_wadl__HTTPMethods, sizeof(enum wadl__HTTPMethods), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum wadl__HTTPMethods * SOAP_FMAC4 soap_new_wadl__HTTPMethods(struct soap *soap, int n)
{
	enum wadl__HTTPMethods *a = static_cast<enum wadl__HTTPMethods *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum wadl__HTTPMethods)));
	for (enum wadl__HTTPMethods *p = a; p && n--; ++p)
		soap_default_wadl__HTTPMethods(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wadl__HTTPMethods(struct soap *soap, const enum wadl__HTTPMethods *a, const char *tag, const char *type)
{
	if (soap_out_wadl__HTTPMethods(soap, tag ? tag : "wadl:HTTPMethods", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum wadl__HTTPMethods * SOAP_FMAC4 soap_get_wadl__HTTPMethods(struct soap *soap, enum wadl__HTTPMethods *p, const char *tag, const char *type)
{
	if ((p = soap_in_wadl__HTTPMethods(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_xs__processContents[] =
{	{ (LONG64)strict, "strict" },
	{ (LONG64)skip, "skip" },
	{ (LONG64)lax, "lax" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_xs__processContents2s(struct soap *soap, enum xs__processContents n)
{	const char *s = soap_code_str(soap_codes_xs__processContents, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xs__processContents(struct soap *soap, const char *tag, int id, const enum xs__processContents *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xs__processContents), type) || soap_send(soap, soap_xs__processContents2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2xs__processContents(struct soap *soap, const char *s, enum xs__processContents *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_xs__processContents, s);
	if (map)
		*a = (enum xs__processContents)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum xs__processContents)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum xs__processContents * SOAP_FMAC4 soap_in_xs__processContents(struct soap *soap, const char *tag, enum xs__processContents *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum xs__processContents *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xs__processContents, sizeof(enum xs__processContents), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2xs__processContents(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum xs__processContents *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xs__processContents, SOAP_TYPE_xs__processContents, sizeof(enum xs__processContents), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum xs__processContents * SOAP_FMAC4 soap_new_xs__processContents(struct soap *soap, int n)
{
	enum xs__processContents *a = static_cast<enum xs__processContents *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum xs__processContents)));
	for (enum xs__processContents *p = a; p && n--; ++p)
		soap_default_xs__processContents(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xs__processContents(struct soap *soap, const enum xs__processContents *a, const char *tag, const char *type)
{
	if (soap_out_xs__processContents(soap, tag ? tag : "xs:processContents", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum xs__processContents * SOAP_FMAC4 soap_get_xs__processContents(struct soap *soap, enum xs__processContents *p, const char *tag, const char *type)
{
	if ((p = soap_in_xs__processContents(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_xs__attribute_use[] =
{	{ (LONG64)optional, "optional" },
	{ (LONG64)prohibited, "prohibited" },
	{ (LONG64)required, "required" },
	{ (LONG64)default_, "default" },
	{ (LONG64)fixed_, "fixed" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_xs__attribute_use2s(struct soap *soap, enum xs__attribute_use n)
{	const char *s = soap_code_str(soap_codes_xs__attribute_use, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xs__attribute_use(struct soap *soap, const char *tag, int id, const enum xs__attribute_use *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xs__attribute_use), type) || soap_send(soap, soap_xs__attribute_use2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2xs__attribute_use(struct soap *soap, const char *s, enum xs__attribute_use *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_xs__attribute_use, s);
	if (map)
		*a = (enum xs__attribute_use)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 4)
			return soap->error = SOAP_TYPE;
		*a = (enum xs__attribute_use)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum xs__attribute_use * SOAP_FMAC4 soap_in_xs__attribute_use(struct soap *soap, const char *tag, enum xs__attribute_use *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum xs__attribute_use *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xs__attribute_use, sizeof(enum xs__attribute_use), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2xs__attribute_use(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum xs__attribute_use *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xs__attribute_use, SOAP_TYPE_xs__attribute_use, sizeof(enum xs__attribute_use), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum xs__attribute_use * SOAP_FMAC4 soap_new_xs__attribute_use(struct soap *soap, int n)
{
	enum xs__attribute_use *a = static_cast<enum xs__attribute_use *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum xs__attribute_use)));
	for (enum xs__attribute_use *p = a; p && n--; ++p)
		soap_default_xs__attribute_use(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xs__attribute_use(struct soap *soap, const enum xs__attribute_use *a, const char *tag, const char *type)
{
	if (soap_out_xs__attribute_use(soap, tag ? tag : "xs:attribute-use", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum xs__attribute_use * SOAP_FMAC4 soap_get_xs__attribute_use(struct soap *soap, enum xs__attribute_use *p, const char *tag, const char *type)
{
	if ((p = soap_in_xs__attribute_use(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_xs__formChoice[] =
{	{ (LONG64)unqualified, "unqualified" },
	{ (LONG64)qualified, "qualified" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_xs__formChoice2s(struct soap *soap, enum xs__formChoice n)
{	const char *s = soap_code_str(soap_codes_xs__formChoice, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xs__formChoice(struct soap *soap, const char *tag, int id, const enum xs__formChoice *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xs__formChoice), type) || soap_send(soap, soap_xs__formChoice2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2xs__formChoice(struct soap *soap, const char *s, enum xs__formChoice *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_xs__formChoice, s);
	if (map)
		*a = (enum xs__formChoice)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum xs__formChoice)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum xs__formChoice * SOAP_FMAC4 soap_in_xs__formChoice(struct soap *soap, const char *tag, enum xs__formChoice *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum xs__formChoice *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xs__formChoice, sizeof(enum xs__formChoice), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2xs__formChoice(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum xs__formChoice *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xs__formChoice, SOAP_TYPE_xs__formChoice, sizeof(enum xs__formChoice), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum xs__formChoice * SOAP_FMAC4 soap_new_xs__formChoice(struct soap *soap, int n)
{
	enum xs__formChoice *a = static_cast<enum xs__formChoice *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum xs__formChoice)));
	for (enum xs__formChoice *p = a; p && n--; ++p)
		soap_default_xs__formChoice(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xs__formChoice(struct soap *soap, const enum xs__formChoice *a, const char *tag, const char *type)
{
	if (soap_out_xs__formChoice(soap, tag ? tag : "xs:formChoice", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum xs__formChoice * SOAP_FMAC4 soap_get_xs__formChoice(struct soap *soap, enum xs__formChoice *p, const char *tag, const char *type)
{
	if ((p = soap_in_xs__formChoice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__boolean(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xsd__boolean), type) || soap_send(soap, soap_xsd__boolean2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_xsd__boolean(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__boolean, sizeof(bool), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2xsd__boolean(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xsd__boolean, SOAP_TYPE_xsd__boolean, sizeof(bool), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__boolean(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	if (soap_out_xsd__boolean(soap, tag ? tag : "xsd:boolean", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_xsd__boolean(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__boolean(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (LONG64)false, "false" },
	{ (LONG64)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{
	(void)soap; /* appease -Wall -Werror */
	return soap_code_str(soap_codes_bool, n != 0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2bool(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bool, SOAP_TYPE_bool, sizeof(bool), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_new_bool(struct soap *soap, int n)
{
	bool *a = static_cast<bool *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(bool)));
	for (bool *p = a; p && n--; ++p)
		soap_default_bool(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	if (soap_out_bool(soap, tag ? tag : "boolean", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsdl__service::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__NMTOKEN(soap, &this->wsdl__service::name);
	soap_default_xsd__QName(soap, &this->wsdl__service::interface_);
	soap_default_xsd__string(soap, &this->wsdl__service::documentation);
	soap_default_std__vectorTemplateOfwsp__Policy(soap, &this->wsdl__service::wsp__Policy_);
	soap_default_std__vectorTemplateOfwsp__PolicyReference(soap, &this->wsdl__service::wsp__PolicyReference_);
	soap_default_std__vectorTemplateOfwsdl__port(soap, &this->wsdl__service::port);
	soap_default_std__vectorTemplateOfwsdl__port(soap, &this->wsdl__service::endpoint);
}

void wsdl__service::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__string(soap, (char*const*)&this->wsdl__service::documentation);
	soap_serialize_std__vectorTemplateOfwsp__Policy(soap, &this->wsdl__service::wsp__Policy_);
	soap_serialize_std__vectorTemplateOfwsp__PolicyReference(soap, &this->wsdl__service::wsp__PolicyReference_);
	soap_serialize_std__vectorTemplateOfwsdl__port(soap, &this->wsdl__service::port);
	soap_serialize_std__vectorTemplateOfwsdl__port(soap, &this->wsdl__service::endpoint);
#endif
}

int wsdl__service::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsdl__service(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdl__service(struct soap *soap, const char *tag, int id, const wsdl__service *a, const char *type)
{
	if (((wsdl__service*)a)->name)
		soap_set_attr(soap, "name", soap_xsd__NMTOKEN2s(soap, ((wsdl__service*)a)->name), 1);
	if (((wsdl__service*)a)->interface_)
		soap_set_attr(soap, "interface", soap_xsd__QName2s(soap, ((wsdl__service*)a)->interface_), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsdl__service), type))
		return soap->error;
	if (soap_out_xsd__string(soap, "wsdl:documentation", -1, (char*const*)&a->wsdl__service::documentation, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfwsp__Policy(soap, "wsp:Policy", -1, &a->wsdl__service::wsp__Policy_, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfwsp__PolicyReference(soap, "wsp:PolicyReference", -1, &a->wsdl__service::wsp__PolicyReference_, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfwsdl__port(soap, "wsdl:port", -1, &a->wsdl__service::port, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfwsdl__port(soap, "wsdl:endpoint", -1, &a->wsdl__service::endpoint, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsdl__service::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wsdl__service(soap, tag, this, type);
}

SOAP_FMAC3 wsdl__service * SOAP_FMAC4 soap_in_wsdl__service(struct soap *soap, const char *tag, wsdl__service *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsdl__service *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsdl__service, sizeof(wsdl__service), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsdl__service)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsdl__service *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__NMTOKEN(soap, soap_attr_value(soap, "name", 5, 0), &((wsdl__service*)a)->name))
		return NULL;
	if (soap_s2xsd__QName(soap, soap_attr_value(soap, "interface", 2, 0), &((wsdl__service*)a)->interface_))
		return NULL;
	size_t soap_flag_documentation1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_documentation1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "wsdl:documentation", (char**)&a->wsdl__service::documentation, "xsd:string"))
				{	soap_flag_documentation1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfwsp__Policy(soap, "wsp:Policy", &a->wsdl__service::wsp__Policy_, "wsp:Policy"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfwsp__PolicyReference(soap, "wsp:PolicyReference", &a->wsdl__service::wsp__PolicyReference_, "wsp:PolicyReference"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfwsdl__port(soap, "wsdl:port", &a->wsdl__service::port, "wsdl:port"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfwsdl__port(soap, "wsdl:endpoint", &a->wsdl__service::endpoint, "wsdl:port"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wsdl__service *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsdl__service, SOAP_TYPE_wsdl__service, sizeof(wsdl__service), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsdl__service * SOAP_FMAC2 wsdl_instantiate_wsdl__service(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_wsdl__service(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsdl__service *p;
	size_t k = sizeof(wsdl__service);
	if (n < 0)
	{	p = SOAP_NEW(wsdl__service);
	}
	else
	{	p = SOAP_NEW_ARRAY(wsdl__service, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsdl__service location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_wsdl__service, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int wsdl__service::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsdl__service(soap, tag ? tag : "wsdl:service", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsdl__service::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsdl__service(soap, this, tag, type);
}

SOAP_FMAC3 wsdl__service * SOAP_FMAC4 soap_get_wsdl__service(struct soap *soap, wsdl__service *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsdl__service(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsdl__port::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__NMTOKEN(soap, &this->wsdl__port::name);
	soap_default_xsd__QName(soap, &this->wsdl__port::binding);
	soap_default_xsd__anyURI(soap, &this->wsdl__port::address);
	soap_default_xsd__NMTOKEN(soap, &this->wsdl__port::whttp__authenticationScheme);
	soap_default_xsd__NMTOKEN(soap, &this->wsdl__port::whttp__authenticationRealm);
	soap_default_xsd__string(soap, &this->wsdl__port::documentation);
	this->wsdl__port::wsp__Policy_ = NULL;
	this->wsdl__port::wsp__PolicyReference_ = NULL;
	this->wsdl__port::wsa__EndpointReference = NULL;
	this->wsdl__port::wsaw__UsingAddressing = NULL;
	this->wsdl__port::soap__address_ = NULL;
	this->wsdl__port::http__address_ = NULL;
	this->wsdl__port::bindingRef = NULL;
}

void wsdl__port::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__string(soap, (char*const*)&this->wsdl__port::documentation);
	soap_serialize_PointerTowsp__Policy(soap, &this->wsdl__port::wsp__Policy_);
	soap_serialize_PointerTowsp__PolicyReference(soap, &this->wsdl__port::wsp__PolicyReference_);
	soap_serialize_PointerTowsa__EndpointReferenceType(soap, &this->wsdl__port::wsa__EndpointReference);
	soap_serialize_PointerToxsd__string(soap, &this->wsdl__port::wsaw__UsingAddressing);
	soap_serialize_PointerTosoap__address(soap, &this->wsdl__port::soap__address_);
	soap_serialize_PointerTohttp__address(soap, &this->wsdl__port::http__address_);
	/* non-serializable bindingRef skipped */
#endif
}

int wsdl__port::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsdl__port(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdl__port(struct soap *soap, const char *tag, int id, const wsdl__port *a, const char *type)
{
	if (((wsdl__port*)a)->name)
		soap_set_attr(soap, "name", soap_xsd__NMTOKEN2s(soap, ((wsdl__port*)a)->name), 1);
	if (((wsdl__port*)a)->binding)
		soap_set_attr(soap, "binding", soap_xsd__QName2s(soap, ((wsdl__port*)a)->binding), 1);
	if (((wsdl__port*)a)->address)
		soap_set_attr(soap, "address", soap_xsd__anyURI2s(soap, ((wsdl__port*)a)->address), 1);
	if (((wsdl__port*)a)->whttp__authenticationScheme)
		soap_set_attr(soap, "whttp:authenticationScheme", soap_xsd__NMTOKEN2s(soap, ((wsdl__port*)a)->whttp__authenticationScheme), 1);
	if (((wsdl__port*)a)->whttp__authenticationRealm)
		soap_set_attr(soap, "whttp:authenticationRealm", soap_xsd__NMTOKEN2s(soap, ((wsdl__port*)a)->whttp__authenticationRealm), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsdl__port), type))
		return soap->error;
	if (soap_out_xsd__string(soap, "wsdl:documentation", -1, (char*const*)&a->wsdl__port::documentation, ""))
		return soap->error;
	if (soap_out_PointerTowsp__Policy(soap, "wsp:Policy", -1, &a->wsdl__port::wsp__Policy_, ""))
		return soap->error;
	if (soap_out_PointerTowsp__PolicyReference(soap, "wsp:PolicyReference", -1, &a->wsdl__port::wsp__PolicyReference_, ""))
		return soap->error;
	if (soap_out_PointerTowsa__EndpointReferenceType(soap, "wsa:EndpointReference", -1, &a->wsdl__port::wsa__EndpointReference, ""))
		return soap->error;
	if (soap_out_PointerToxsd__string(soap, "wsaw:UsingAddressing", -1, &a->wsdl__port::wsaw__UsingAddressing, ""))
		return soap->error;
	if (soap_out_PointerTosoap__address(soap, "soap:address", -1, &a->wsdl__port::soap__address_, ""))
		return soap->error;
	if (soap_out_PointerTohttp__address(soap, "http:address", -1, &a->wsdl__port::http__address_, ""))
		return soap->error;
	/* non-serializable bindingRef skipped */
	return soap_element_end_out(soap, tag);
}

void *wsdl__port::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wsdl__port(soap, tag, this, type);
}

SOAP_FMAC3 wsdl__port * SOAP_FMAC4 soap_in_wsdl__port(struct soap *soap, const char *tag, wsdl__port *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsdl__port *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsdl__port, sizeof(wsdl__port), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsdl__port)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsdl__port *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__NMTOKEN(soap, soap_attr_value(soap, "name", 5, 0), &((wsdl__port*)a)->name))
		return NULL;
	if (soap_s2xsd__QName(soap, soap_attr_value(soap, "binding", 2, 0), &((wsdl__port*)a)->binding))
		return NULL;
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "address", 4, 0), &((wsdl__port*)a)->address))
		return NULL;
	if (soap_s2xsd__NMTOKEN(soap, soap_attr_value(soap, "whttp:authenticationScheme", 5, 0), &((wsdl__port*)a)->whttp__authenticationScheme))
		return NULL;
	if (soap_s2xsd__NMTOKEN(soap, soap_attr_value(soap, "whttp:authenticationRealm", 5, 0), &((wsdl__port*)a)->whttp__authenticationRealm))
		return NULL;
	size_t soap_flag_documentation1 = 1;
	size_t soap_flag_wsp__Policy_1 = 1;
	size_t soap_flag_wsp__PolicyReference_1 = 1;
	size_t soap_flag_wsa__EndpointReference1 = 1;
	size_t soap_flag_wsaw__UsingAddressing1 = 1;
	size_t soap_flag_soap__address_1 = 1;
	size_t soap_flag_http__address_1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_documentation1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "wsdl:documentation", (char**)&a->wsdl__port::documentation, "xsd:string"))
				{	soap_flag_documentation1--;
					continue;
				}
			}
			if (soap_flag_wsp__Policy_1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsp__Policy(soap, "wsp:Policy", &a->wsdl__port::wsp__Policy_, "wsp:Policy"))
				{	soap_flag_wsp__Policy_1--;
					continue;
				}
			}
			if (soap_flag_wsp__PolicyReference_1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsp__PolicyReference(soap, "wsp:PolicyReference", &a->wsdl__port::wsp__PolicyReference_, "wsp:PolicyReference"))
				{	soap_flag_wsp__PolicyReference_1--;
					continue;
				}
			}
			if (soap_flag_wsa__EndpointReference1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa__EndpointReferenceType(soap, "wsa:EndpointReference", &a->wsdl__port::wsa__EndpointReference, "wsa:EndpointReferenceType"))
				{	soap_flag_wsa__EndpointReference1--;
					continue;
				}
			}
			if (soap_flag_wsaw__UsingAddressing1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxsd__string(soap, "wsaw:UsingAddressing", &a->wsdl__port::wsaw__UsingAddressing, "xsd:string"))
				{	soap_flag_wsaw__UsingAddressing1--;
					continue;
				}
			}
			if (soap_flag_soap__address_1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosoap__address(soap, "soap:address", &a->wsdl__port::soap__address_, "soap:address"))
				{	soap_flag_soap__address_1--;
					continue;
				}
			}
			if (soap_flag_http__address_1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTohttp__address(soap, "http:address", &a->wsdl__port::http__address_, "http:address"))
				{	soap_flag_http__address_1--;
					continue;
				}
			}
			/* non-serializable bindingRef skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wsdl__port *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsdl__port, SOAP_TYPE_wsdl__port, sizeof(wsdl__port), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsdl__port * SOAP_FMAC2 wsdl_instantiate_wsdl__port(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_wsdl__port(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsdl__port *p;
	size_t k = sizeof(wsdl__port);
	if (n < 0)
	{	p = SOAP_NEW(wsdl__port);
	}
	else
	{	p = SOAP_NEW_ARRAY(wsdl__port, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsdl__port location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_wsdl__port, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int wsdl__port::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsdl__port(soap, tag ? tag : "wsdl:port", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsdl__port::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsdl__port(soap, this, tag, type);
}

SOAP_FMAC3 wsdl__port * SOAP_FMAC4 soap_get_wsdl__port(struct soap *soap, wsdl__port *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsdl__port(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsdl__binding::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__NMTOKEN(soap, &this->wsdl__binding::name);
	soap_default_xsd__QName(soap, &this->wsdl__binding::type);
	soap_default_xsd__anyURI(soap, &this->wsdl__binding::type_);
	soap_default_xsd__QName(soap, &this->wsdl__binding::interface_);
	this->wsdl__binding::whttp__cookies = (bool)0;
	soap_default_xsd__string(soap, &this->wsdl__binding::wsoap__version);
	soap_default_xsd__anyURI(soap, &this->wsdl__binding::wsoap__protocol);
	soap_default_xsd__anyURI(soap, &this->wsdl__binding::wsoap__mepDefault);
	soap_default_xsd__string(soap, &this->wsdl__binding::whttp__methodDefault);
	soap_default_xsd__string(soap, &this->wsdl__binding::documentation);
	soap_default_std__vectorTemplateOfwsp__Policy(soap, &this->wsdl__binding::wsp__Policy_);
	soap_default_std__vectorTemplateOfwsp__PolicyReference(soap, &this->wsdl__binding::wsp__PolicyReference_);
	this->wsdl__binding::soap__binding_ = NULL;
	this->wsdl__binding::http__binding_ = NULL;
	soap_default_std__vectorTemplateOfwsoap__module(soap, &this->wsdl__binding::wsoap__module_);
	soap_default_std__vectorTemplateOfwsdl__ext_fault(soap, &this->wsdl__binding::fault);
	soap_default_std__vectorTemplateOfwsdl__ext_operation(soap, &this->wsdl__binding::operation);
	this->wsdl__binding::portTypeRef = NULL;
}

void wsdl__binding::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__string(soap, (char*const*)&this->wsdl__binding::documentation);
	soap_serialize_std__vectorTemplateOfwsp__Policy(soap, &this->wsdl__binding::wsp__Policy_);
	soap_serialize_std__vectorTemplateOfwsp__PolicyReference(soap, &this->wsdl__binding::wsp__PolicyReference_);
	soap_serialize_PointerTosoap__binding(soap, &this->wsdl__binding::soap__binding_);
	soap_serialize_PointerTohttp__binding(soap, &this->wsdl__binding::http__binding_);
	soap_serialize_std__vectorTemplateOfwsoap__module(soap, &this->wsdl__binding::wsoap__module_);
	soap_serialize_std__vectorTemplateOfwsdl__ext_fault(soap, &this->wsdl__binding::fault);
	soap_serialize_std__vectorTemplateOfwsdl__ext_operation(soap, &this->wsdl__binding::operation);
	/* non-serializable portTypeRef skipped */
#endif
}

int wsdl__binding::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsdl__binding(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdl__binding(struct soap *soap, const char *tag, int id, const wsdl__binding *a, const char *type)
{
	if (((wsdl__binding*)a)->name)
		soap_set_attr(soap, "name", soap_xsd__NMTOKEN2s(soap, ((wsdl__binding*)a)->name), 1);
	if (((wsdl__binding*)a)->type)
		soap_set_attr(soap, "type", soap_xsd__QName2s(soap, ((wsdl__binding*)a)->type), 1);
	if (((wsdl__binding*)a)->type_)
		soap_set_attr(soap, "type", soap_xsd__anyURI2s(soap, ((wsdl__binding*)a)->type_), 1);
	if (((wsdl__binding*)a)->interface_)
		soap_set_attr(soap, "interface", soap_xsd__QName2s(soap, ((wsdl__binding*)a)->interface_), 1);
	soap_set_attr(soap, "whttp:cookies", soap_xsd__boolean2s(soap, ((wsdl__binding*)a)->whttp__cookies), 1);
	if (((wsdl__binding*)a)->wsoap__version)
		soap_set_attr(soap, "wsoap:version", soap_xsd__string2s(soap, ((wsdl__binding*)a)->wsoap__version), 1);
	if (((wsdl__binding*)a)->wsoap__protocol)
		soap_set_attr(soap, "wsoap:protocol", soap_xsd__anyURI2s(soap, ((wsdl__binding*)a)->wsoap__protocol), 1);
	if (((wsdl__binding*)a)->wsoap__mepDefault)
		soap_set_attr(soap, "wsoap:mepDefault", soap_xsd__anyURI2s(soap, ((wsdl__binding*)a)->wsoap__mepDefault), 1);
	if (((wsdl__binding*)a)->whttp__methodDefault)
		soap_set_attr(soap, "whttp:methodDefault", soap_xsd__string2s(soap, ((wsdl__binding*)a)->whttp__methodDefault), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsdl__binding), type))
		return soap->error;
	if (soap_out_xsd__string(soap, "wsdl:documentation", -1, (char*const*)&a->wsdl__binding::documentation, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfwsp__Policy(soap, "wsp:Policy", -1, &a->wsdl__binding::wsp__Policy_, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfwsp__PolicyReference(soap, "wsp:PolicyReference", -1, &a->wsdl__binding::wsp__PolicyReference_, ""))
		return soap->error;
	if (soap_out_PointerTosoap__binding(soap, "soap:binding", -1, &a->wsdl__binding::soap__binding_, ""))
		return soap->error;
	if (soap_out_PointerTohttp__binding(soap, "http:binding", -1, &a->wsdl__binding::http__binding_, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfwsoap__module(soap, "wsoap:module", -1, &a->wsdl__binding::wsoap__module_, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfwsdl__ext_fault(soap, "wsdl:fault", -1, &a->wsdl__binding::fault, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfwsdl__ext_operation(soap, "wsdl:operation", -1, &a->wsdl__binding::operation, ""))
		return soap->error;
	/* non-serializable portTypeRef skipped */
	return soap_element_end_out(soap, tag);
}

void *wsdl__binding::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wsdl__binding(soap, tag, this, type);
}

SOAP_FMAC3 wsdl__binding * SOAP_FMAC4 soap_in_wsdl__binding(struct soap *soap, const char *tag, wsdl__binding *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsdl__binding *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsdl__binding, sizeof(wsdl__binding), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsdl__binding)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsdl__binding *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__NMTOKEN(soap, soap_attr_value(soap, "name", 5, 0), &((wsdl__binding*)a)->name))
		return NULL;
	if (soap_s2xsd__QName(soap, soap_attr_value(soap, "type", 2, 0), &((wsdl__binding*)a)->type))
		return NULL;
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "type", 4, 0), &((wsdl__binding*)a)->type_))
		return NULL;
	if (soap_s2xsd__QName(soap, soap_attr_value(soap, "interface", 2, 0), &((wsdl__binding*)a)->interface_))
		return NULL;
	if (soap_s2xsd__boolean(soap, soap_attr_value(soap, "whttp:cookies", 5, 0), &((wsdl__binding*)a)->whttp__cookies))
		return NULL;
	if (soap_s2xsd__string(soap, soap_attr_value(soap, "wsoap:version", 1, 0), &((wsdl__binding*)a)->wsoap__version))
		return NULL;
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "wsoap:protocol", 4, 0), &((wsdl__binding*)a)->wsoap__protocol))
		return NULL;
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "wsoap:mepDefault", 4, 0), &((wsdl__binding*)a)->wsoap__mepDefault))
		return NULL;
	if (soap_s2xsd__string(soap, soap_attr_value(soap, "whttp:methodDefault", 1, 0), &((wsdl__binding*)a)->whttp__methodDefault))
		return NULL;
	size_t soap_flag_documentation1 = 1;
	size_t soap_flag_soap__binding_1 = 1;
	size_t soap_flag_http__binding_1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_documentation1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "wsdl:documentation", (char**)&a->wsdl__binding::documentation, "xsd:string"))
				{	soap_flag_documentation1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfwsp__Policy(soap, "wsp:Policy", &a->wsdl__binding::wsp__Policy_, "wsp:Policy"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfwsp__PolicyReference(soap, "wsp:PolicyReference", &a->wsdl__binding::wsp__PolicyReference_, "wsp:PolicyReference"))
					continue;
			}
			if (soap_flag_soap__binding_1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosoap__binding(soap, "soap:binding", &a->wsdl__binding::soap__binding_, "soap:binding"))
				{	soap_flag_soap__binding_1--;
					continue;
				}
			}
			if (soap_flag_http__binding_1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTohttp__binding(soap, "http:binding", &a->wsdl__binding::http__binding_, "http:binding"))
				{	soap_flag_http__binding_1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfwsoap__module(soap, "wsoap:module", &a->wsdl__binding::wsoap__module_, "wsoap:module"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfwsdl__ext_fault(soap, "wsdl:fault", &a->wsdl__binding::fault, "wsdl:ext-fault"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfwsdl__ext_operation(soap, "wsdl:operation", &a->wsdl__binding::operation, "wsdl:ext-operation"))
					continue;
			}
			/* non-serializable portTypeRef skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wsdl__binding *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsdl__binding, SOAP_TYPE_wsdl__binding, sizeof(wsdl__binding), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsdl__binding * SOAP_FMAC2 wsdl_instantiate_wsdl__binding(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_wsdl__binding(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsdl__binding *p;
	size_t k = sizeof(wsdl__binding);
	if (n < 0)
	{	p = SOAP_NEW(wsdl__binding);
	}
	else
	{	p = SOAP_NEW_ARRAY(wsdl__binding, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsdl__binding location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_wsdl__binding, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int wsdl__binding::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsdl__binding(soap, tag ? tag : "wsdl:binding", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsdl__binding::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsdl__binding(soap, this, tag, type);
}

SOAP_FMAC3 wsdl__binding * SOAP_FMAC4 soap_get_wsdl__binding(struct soap *soap, wsdl__binding *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsdl__binding(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsdl__ext_operation::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__NMTOKEN(soap, &this->wsdl__ext_operation::name);
	soap_default_xsd__QName(soap, &this->wsdl__ext_operation::ref);
	soap_default_xsd__anyURI(soap, &this->wsdl__ext_operation::wsoap__mep);
	soap_default_xsd__anyURI(soap, &this->wsdl__ext_operation::wsoap__action);
	soap_default_xsd__string(soap, &this->wsdl__ext_operation::whttp__method);
	soap_default_xsd__string(soap, &this->wsdl__ext_operation::whttp__location);
	soap_default_xsd__string(soap, &this->wsdl__ext_operation::documentation);
	this->wsdl__ext_operation::wsp__Policy_ = NULL;
	this->wsdl__ext_operation::wsp__PolicyReference_ = NULL;
	this->wsdl__ext_operation::soap__operation_ = NULL;
	this->wsdl__ext_operation::http__operation_ = NULL;
	this->wsdl__ext_operation::input = NULL;
	this->wsdl__ext_operation::output = NULL;
	soap_default_std__vectorTemplateOfwsdl__ext_fault(soap, &this->wsdl__ext_operation::fault);
	soap_default_std__vectorTemplateOfwsdl__ext_fault(soap, &this->wsdl__ext_operation::infault);
	soap_default_std__vectorTemplateOfwsdl__ext_fault(soap, &this->wsdl__ext_operation::outfault);
	this->wsdl__ext_operation::operationRef = NULL;
}

void wsdl__ext_operation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__string(soap, (char*const*)&this->wsdl__ext_operation::documentation);
	soap_serialize_PointerTowsp__Policy(soap, &this->wsdl__ext_operation::wsp__Policy_);
	soap_serialize_PointerTowsp__PolicyReference(soap, &this->wsdl__ext_operation::wsp__PolicyReference_);
	soap_serialize_PointerTosoap__operation(soap, &this->wsdl__ext_operation::soap__operation_);
	soap_serialize_PointerTohttp__operation(soap, &this->wsdl__ext_operation::http__operation_);
	soap_serialize_PointerTowsdl__ext_ioput(soap, &this->wsdl__ext_operation::input);
	soap_serialize_PointerTowsdl__ext_ioput(soap, &this->wsdl__ext_operation::output);
	soap_serialize_std__vectorTemplateOfwsdl__ext_fault(soap, &this->wsdl__ext_operation::fault);
	soap_serialize_std__vectorTemplateOfwsdl__ext_fault(soap, &this->wsdl__ext_operation::infault);
	soap_serialize_std__vectorTemplateOfwsdl__ext_fault(soap, &this->wsdl__ext_operation::outfault);
	/* non-serializable operationRef skipped */
#endif
}

int wsdl__ext_operation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsdl__ext_operation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdl__ext_operation(struct soap *soap, const char *tag, int id, const wsdl__ext_operation *a, const char *type)
{
	if (((wsdl__ext_operation*)a)->name)
		soap_set_attr(soap, "name", soap_xsd__NMTOKEN2s(soap, ((wsdl__ext_operation*)a)->name), 1);
	if (((wsdl__ext_operation*)a)->ref)
		soap_set_attr(soap, "ref", soap_xsd__QName2s(soap, ((wsdl__ext_operation*)a)->ref), 1);
	if (((wsdl__ext_operation*)a)->wsoap__mep)
		soap_set_attr(soap, "wsoap:mep", soap_xsd__anyURI2s(soap, ((wsdl__ext_operation*)a)->wsoap__mep), 1);
	if (((wsdl__ext_operation*)a)->wsoap__action)
		soap_set_attr(soap, "wsoap:action", soap_xsd__anyURI2s(soap, ((wsdl__ext_operation*)a)->wsoap__action), 1);
	if (((wsdl__ext_operation*)a)->whttp__method)
		soap_set_attr(soap, "whttp:method", soap_xsd__string2s(soap, ((wsdl__ext_operation*)a)->whttp__method), 1);
	if (((wsdl__ext_operation*)a)->whttp__location)
		soap_set_attr(soap, "whttp:location", soap_xsd__string2s(soap, ((wsdl__ext_operation*)a)->whttp__location), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsdl__ext_operation), type))
		return soap->error;
	if (soap_out_xsd__string(soap, "wsdl:documentation", -1, (char*const*)&a->wsdl__ext_operation::documentation, ""))
		return soap->error;
	if (soap_out_PointerTowsp__Policy(soap, "wsp:Policy", -1, &a->wsdl__ext_operation::wsp__Policy_, ""))
		return soap->error;
	if (soap_out_PointerTowsp__PolicyReference(soap, "wsp:PolicyReference", -1, &a->wsdl__ext_operation::wsp__PolicyReference_, ""))
		return soap->error;
	if (soap_out_PointerTosoap__operation(soap, "soap:operation", -1, &a->wsdl__ext_operation::soap__operation_, ""))
		return soap->error;
	if (soap_out_PointerTohttp__operation(soap, "http:operation", -1, &a->wsdl__ext_operation::http__operation_, ""))
		return soap->error;
	if (soap_out_PointerTowsdl__ext_ioput(soap, "wsdl:input", -1, &a->wsdl__ext_operation::input, ""))
		return soap->error;
	if (soap_out_PointerTowsdl__ext_ioput(soap, "wsdl:output", -1, &a->wsdl__ext_operation::output, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfwsdl__ext_fault(soap, "wsdl:fault", -1, &a->wsdl__ext_operation::fault, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfwsdl__ext_fault(soap, "wsdl:infault", -1, &a->wsdl__ext_operation::infault, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfwsdl__ext_fault(soap, "wsdl:outfault", -1, &a->wsdl__ext_operation::outfault, ""))
		return soap->error;
	/* non-serializable operationRef skipped */
	return soap_element_end_out(soap, tag);
}

void *wsdl__ext_operation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wsdl__ext_operation(soap, tag, this, type);
}

SOAP_FMAC3 wsdl__ext_operation * SOAP_FMAC4 soap_in_wsdl__ext_operation(struct soap *soap, const char *tag, wsdl__ext_operation *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsdl__ext_operation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsdl__ext_operation, sizeof(wsdl__ext_operation), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsdl__ext_operation)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsdl__ext_operation *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__NMTOKEN(soap, soap_attr_value(soap, "name", 5, 0), &((wsdl__ext_operation*)a)->name))
		return NULL;
	if (soap_s2xsd__QName(soap, soap_attr_value(soap, "ref", 2, 0), &((wsdl__ext_operation*)a)->ref))
		return NULL;
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "wsoap:mep", 4, 0), &((wsdl__ext_operation*)a)->wsoap__mep))
		return NULL;
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "wsoap:action", 4, 0), &((wsdl__ext_operation*)a)->wsoap__action))
		return NULL;
	if (soap_s2xsd__string(soap, soap_attr_value(soap, "whttp:method", 1, 0), &((wsdl__ext_operation*)a)->whttp__method))
		return NULL;
	if (soap_s2xsd__string(soap, soap_attr_value(soap, "whttp:location", 1, 0), &((wsdl__ext_operation*)a)->whttp__location))
		return NULL;
	size_t soap_flag_documentation1 = 1;
	size_t soap_flag_wsp__Policy_1 = 1;
	size_t soap_flag_wsp__PolicyReference_1 = 1;
	size_t soap_flag_soap__operation_1 = 1;
	size_t soap_flag_http__operation_1 = 1;
	size_t soap_flag_input1 = 1;
	size_t soap_flag_output1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_documentation1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "wsdl:documentation", (char**)&a->wsdl__ext_operation::documentation, "xsd:string"))
				{	soap_flag_documentation1--;
					continue;
				}
			}
			if (soap_flag_wsp__Policy_1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsp__Policy(soap, "wsp:Policy", &a->wsdl__ext_operation::wsp__Policy_, "wsp:Policy"))
				{	soap_flag_wsp__Policy_1--;
					continue;
				}
			}
			if (soap_flag_wsp__PolicyReference_1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsp__PolicyReference(soap, "wsp:PolicyReference", &a->wsdl__ext_operation::wsp__PolicyReference_, "wsp:PolicyReference"))
				{	soap_flag_wsp__PolicyReference_1--;
					continue;
				}
			}
			if (soap_flag_soap__operation_1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosoap__operation(soap, "soap:operation", &a->wsdl__ext_operation::soap__operation_, "soap:operation"))
				{	soap_flag_soap__operation_1--;
					continue;
				}
			}
			if (soap_flag_http__operation_1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTohttp__operation(soap, "http:operation", &a->wsdl__ext_operation::http__operation_, "http:operation"))
				{	soap_flag_http__operation_1--;
					continue;
				}
			}
			if (soap_flag_input1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsdl__ext_ioput(soap, "wsdl:input", &a->wsdl__ext_operation::input, "wsdl:ext-ioput"))
				{	soap_flag_input1--;
					continue;
				}
			}
			if (soap_flag_output1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsdl__ext_ioput(soap, "wsdl:output", &a->wsdl__ext_operation::output, "wsdl:ext-ioput"))
				{	soap_flag_output1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfwsdl__ext_fault(soap, "wsdl:fault", &a->wsdl__ext_operation::fault, "wsdl:ext-fault"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfwsdl__ext_fault(soap, "wsdl:infault", &a->wsdl__ext_operation::infault, "wsdl:ext-fault"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfwsdl__ext_fault(soap, "wsdl:outfault", &a->wsdl__ext_operation::outfault, "wsdl:ext-fault"))
					continue;
			}
			/* non-serializable operationRef skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wsdl__ext_operation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsdl__ext_operation, SOAP_TYPE_wsdl__ext_operation, sizeof(wsdl__ext_operation), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsdl__ext_operation * SOAP_FMAC2 wsdl_instantiate_wsdl__ext_operation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_wsdl__ext_operation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsdl__ext_operation *p;
	size_t k = sizeof(wsdl__ext_operation);
	if (n < 0)
	{	p = SOAP_NEW(wsdl__ext_operation);
	}
	else
	{	p = SOAP_NEW_ARRAY(wsdl__ext_operation, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsdl__ext_operation location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_wsdl__ext_operation, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int wsdl__ext_operation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsdl__ext_operation(soap, tag ? tag : "wsdl:ext-operation", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsdl__ext_operation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsdl__ext_operation(soap, this, tag, type);
}

SOAP_FMAC3 wsdl__ext_operation * SOAP_FMAC4 soap_get_wsdl__ext_operation(struct soap *soap, wsdl__ext_operation *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsdl__ext_operation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsdl__ext_fault::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__NMTOKEN(soap, &this->wsdl__ext_fault::name);
	soap_default_xsd__QName(soap, &this->wsdl__ext_fault::ref);
	soap_default_xsd__NMTOKEN(soap, &this->wsdl__ext_fault::messageLabel);
	soap_default_xsd__QName(soap, &this->wsdl__ext_fault::wsoap__code);
	soap_default_xsd__QName(soap, &this->wsdl__ext_fault::wsoap__subcodes);
	soap_default_xsd__string(soap, &this->wsdl__ext_fault::documentation);
	this->wsdl__ext_fault::wsp__Policy_ = NULL;
	this->wsdl__ext_fault::wsp__PolicyReference_ = NULL;
	this->wsdl__ext_fault::soap__fault_ = NULL;
	soap_default_std__vectorTemplateOfwsoap__module(soap, &this->wsdl__ext_fault::wsoap__module_);
	this->wsdl__ext_fault::faultRef = NULL;
}

void wsdl__ext_fault::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__string(soap, (char*const*)&this->wsdl__ext_fault::documentation);
	soap_serialize_PointerTowsp__Policy(soap, &this->wsdl__ext_fault::wsp__Policy_);
	soap_serialize_PointerTowsp__PolicyReference(soap, &this->wsdl__ext_fault::wsp__PolicyReference_);
	soap_serialize_PointerTosoap__fault(soap, &this->wsdl__ext_fault::soap__fault_);
	soap_serialize_std__vectorTemplateOfwsoap__module(soap, &this->wsdl__ext_fault::wsoap__module_);
	/* non-serializable faultRef skipped */
#endif
}

int wsdl__ext_fault::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsdl__ext_fault(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdl__ext_fault(struct soap *soap, const char *tag, int id, const wsdl__ext_fault *a, const char *type)
{
	if (((wsdl__ext_fault*)a)->name)
		soap_set_attr(soap, "name", soap_xsd__NMTOKEN2s(soap, ((wsdl__ext_fault*)a)->name), 1);
	if (((wsdl__ext_fault*)a)->ref)
		soap_set_attr(soap, "ref", soap_xsd__QName2s(soap, ((wsdl__ext_fault*)a)->ref), 1);
	if (((wsdl__ext_fault*)a)->messageLabel)
		soap_set_attr(soap, "messageLabel", soap_xsd__NMTOKEN2s(soap, ((wsdl__ext_fault*)a)->messageLabel), 1);
	if (((wsdl__ext_fault*)a)->wsoap__code)
		soap_set_attr(soap, "wsoap:code", soap_xsd__QName2s(soap, ((wsdl__ext_fault*)a)->wsoap__code), 1);
	if (((wsdl__ext_fault*)a)->wsoap__subcodes)
		soap_set_attr(soap, "wsoap:subcodes", soap_xsd__QName2s(soap, ((wsdl__ext_fault*)a)->wsoap__subcodes), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsdl__ext_fault), type))
		return soap->error;
	if (soap_out_xsd__string(soap, "wsdl:documentation", -1, (char*const*)&a->wsdl__ext_fault::documentation, ""))
		return soap->error;
	if (soap_out_PointerTowsp__Policy(soap, "wsp:Policy", -1, &a->wsdl__ext_fault::wsp__Policy_, ""))
		return soap->error;
	if (soap_out_PointerTowsp__PolicyReference(soap, "wsp:PolicyReference", -1, &a->wsdl__ext_fault::wsp__PolicyReference_, ""))
		return soap->error;
	if (soap_out_PointerTosoap__fault(soap, "soap:fault", -1, &a->wsdl__ext_fault::soap__fault_, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfwsoap__module(soap, "wsoap:module", -1, &a->wsdl__ext_fault::wsoap__module_, ""))
		return soap->error;
	/* non-serializable faultRef skipped */
	return soap_element_end_out(soap, tag);
}

void *wsdl__ext_fault::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wsdl__ext_fault(soap, tag, this, type);
}

SOAP_FMAC3 wsdl__ext_fault * SOAP_FMAC4 soap_in_wsdl__ext_fault(struct soap *soap, const char *tag, wsdl__ext_fault *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsdl__ext_fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsdl__ext_fault, sizeof(wsdl__ext_fault), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsdl__ext_fault)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsdl__ext_fault *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__NMTOKEN(soap, soap_attr_value(soap, "name", 5, 0), &((wsdl__ext_fault*)a)->name))
		return NULL;
	if (soap_s2xsd__QName(soap, soap_attr_value(soap, "ref", 2, 0), &((wsdl__ext_fault*)a)->ref))
		return NULL;
	if (soap_s2xsd__NMTOKEN(soap, soap_attr_value(soap, "messageLabel", 5, 0), &((wsdl__ext_fault*)a)->messageLabel))
		return NULL;
	if (soap_s2xsd__QName(soap, soap_attr_value(soap, "wsoap:code", 2, 0), &((wsdl__ext_fault*)a)->wsoap__code))
		return NULL;
	if (soap_s2xsd__QName(soap, soap_attr_value(soap, "wsoap:subcodes", 2, 0), &((wsdl__ext_fault*)a)->wsoap__subcodes))
		return NULL;
	size_t soap_flag_documentation1 = 1;
	size_t soap_flag_wsp__Policy_1 = 1;
	size_t soap_flag_wsp__PolicyReference_1 = 1;
	size_t soap_flag_soap__fault_1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_documentation1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "wsdl:documentation", (char**)&a->wsdl__ext_fault::documentation, "xsd:string"))
				{	soap_flag_documentation1--;
					continue;
				}
			}
			if (soap_flag_wsp__Policy_1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsp__Policy(soap, "wsp:Policy", &a->wsdl__ext_fault::wsp__Policy_, "wsp:Policy"))
				{	soap_flag_wsp__Policy_1--;
					continue;
				}
			}
			if (soap_flag_wsp__PolicyReference_1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsp__PolicyReference(soap, "wsp:PolicyReference", &a->wsdl__ext_fault::wsp__PolicyReference_, "wsp:PolicyReference"))
				{	soap_flag_wsp__PolicyReference_1--;
					continue;
				}
			}
			if (soap_flag_soap__fault_1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosoap__fault(soap, "soap:fault", &a->wsdl__ext_fault::soap__fault_, "soap:fault"))
				{	soap_flag_soap__fault_1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfwsoap__module(soap, "wsoap:module", &a->wsdl__ext_fault::wsoap__module_, "wsoap:module"))
					continue;
			}
			/* non-serializable faultRef skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wsdl__ext_fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsdl__ext_fault, SOAP_TYPE_wsdl__ext_fault, sizeof(wsdl__ext_fault), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsdl__ext_fault * SOAP_FMAC2 wsdl_instantiate_wsdl__ext_fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_wsdl__ext_fault(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsdl__ext_fault *p;
	size_t k = sizeof(wsdl__ext_fault);
	if (n < 0)
	{	p = SOAP_NEW(wsdl__ext_fault);
	}
	else
	{	p = SOAP_NEW_ARRAY(wsdl__ext_fault, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsdl__ext_fault location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_wsdl__ext_fault, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int wsdl__ext_fault::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsdl__ext_fault(soap, tag ? tag : "wsdl:ext-fault", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsdl__ext_fault::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsdl__ext_fault(soap, this, tag, type);
}

SOAP_FMAC3 wsdl__ext_fault * SOAP_FMAC4 soap_get_wsdl__ext_fault(struct soap *soap, wsdl__ext_fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsdl__ext_fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsdl__ext_ioput::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__NMTOKEN(soap, &this->wsdl__ext_ioput::name);
	soap_default_xsd__NMTOKEN(soap, &this->wsdl__ext_ioput::messageLabel);
	soap_default_xsd__string(soap, &this->wsdl__ext_ioput::documentation);
	this->wsdl__ext_ioput::wsp__Policy_ = NULL;
	this->wsdl__ext_ioput::wsp__PolicyReference_ = NULL;
	this->wsdl__ext_ioput::dime__message_ = NULL;
	this->wsdl__ext_ioput::soap__body_ = NULL;
	soap_default_xsd__string(soap, &this->wsdl__ext_ioput::http__urlEncoded);
	this->wsdl__ext_ioput::mime__multipartRelated_ = NULL;
	this->wsdl__ext_ioput::mime__content_ = NULL;
	this->wsdl__ext_ioput::mime__mimeXml_ = NULL;
	soap_default_std__vectorTemplateOfsoap__header(soap, &this->wsdl__ext_ioput::soap__header_);
	soap_default_std__vectorTemplateOfwsoap__module(soap, &this->wsdl__ext_ioput::wsoap__module_);
	soap_default_std__vectorTemplateOfwsoap__header(soap, &this->wsdl__ext_ioput::wsoap__header_);
	soap_default_std__vectorTemplateOfwhttp__header(soap, &this->wsdl__ext_ioput::whttp__header_);
}

void wsdl__ext_ioput::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__string(soap, (char*const*)&this->wsdl__ext_ioput::documentation);
	soap_serialize_PointerTowsp__Policy(soap, &this->wsdl__ext_ioput::wsp__Policy_);
	soap_serialize_PointerTowsp__PolicyReference(soap, &this->wsdl__ext_ioput::wsp__PolicyReference_);
	soap_serialize_PointerTodime__message(soap, &this->wsdl__ext_ioput::dime__message_);
	soap_serialize_PointerTosoap__body(soap, &this->wsdl__ext_ioput::soap__body_);
	soap_serialize_xsd__string(soap, (char*const*)&this->wsdl__ext_ioput::http__urlEncoded);
	soap_serialize_PointerTomime__multipartRelated(soap, &this->wsdl__ext_ioput::mime__multipartRelated_);
	soap_serialize_PointerTomime__content(soap, &this->wsdl__ext_ioput::mime__content_);
	soap_serialize_PointerTomime__mimeXml(soap, &this->wsdl__ext_ioput::mime__mimeXml_);
	soap_serialize_std__vectorTemplateOfsoap__header(soap, &this->wsdl__ext_ioput::soap__header_);
	soap_serialize_std__vectorTemplateOfwsoap__module(soap, &this->wsdl__ext_ioput::wsoap__module_);
	soap_serialize_std__vectorTemplateOfwsoap__header(soap, &this->wsdl__ext_ioput::wsoap__header_);
	soap_serialize_std__vectorTemplateOfwhttp__header(soap, &this->wsdl__ext_ioput::whttp__header_);
#endif
}

int wsdl__ext_ioput::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsdl__ext_ioput(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdl__ext_ioput(struct soap *soap, const char *tag, int id, const wsdl__ext_ioput *a, const char *type)
{
	if (((wsdl__ext_ioput*)a)->name)
		soap_set_attr(soap, "name", soap_xsd__NMTOKEN2s(soap, ((wsdl__ext_ioput*)a)->name), 1);
	if (((wsdl__ext_ioput*)a)->messageLabel)
		soap_set_attr(soap, "messageLabel", soap_xsd__NMTOKEN2s(soap, ((wsdl__ext_ioput*)a)->messageLabel), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsdl__ext_ioput), type))
		return soap->error;
	if (soap_out_xsd__string(soap, "wsdl:documentation", -1, (char*const*)&a->wsdl__ext_ioput::documentation, ""))
		return soap->error;
	if (soap_out_PointerTowsp__Policy(soap, "wsp:Policy", -1, &a->wsdl__ext_ioput::wsp__Policy_, ""))
		return soap->error;
	if (soap_out_PointerTowsp__PolicyReference(soap, "wsp:PolicyReference", -1, &a->wsdl__ext_ioput::wsp__PolicyReference_, ""))
		return soap->error;
	if (soap_out_PointerTodime__message(soap, "dime:message", -1, &a->wsdl__ext_ioput::dime__message_, ""))
		return soap->error;
	if (soap_out_PointerTosoap__body(soap, "soap:body", -1, &a->wsdl__ext_ioput::soap__body_, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "http:urlEncoded", -1, (char*const*)&a->wsdl__ext_ioput::http__urlEncoded, ""))
		return soap->error;
	if (soap_out_PointerTomime__multipartRelated(soap, "mime:multipartRelated", -1, &a->wsdl__ext_ioput::mime__multipartRelated_, ""))
		return soap->error;
	if (soap_out_PointerTomime__content(soap, "mime:content", -1, &a->wsdl__ext_ioput::mime__content_, ""))
		return soap->error;
	if (soap_out_PointerTomime__mimeXml(soap, "mime:mimeXml", -1, &a->wsdl__ext_ioput::mime__mimeXml_, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfsoap__header(soap, "soap:header", -1, &a->wsdl__ext_ioput::soap__header_, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfwsoap__module(soap, "wsoap:module", -1, &a->wsdl__ext_ioput::wsoap__module_, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfwsoap__header(soap, "wsoap:header", -1, &a->wsdl__ext_ioput::wsoap__header_, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfwhttp__header(soap, "whttp:header", -1, &a->wsdl__ext_ioput::whttp__header_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsdl__ext_ioput::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wsdl__ext_ioput(soap, tag, this, type);
}

SOAP_FMAC3 wsdl__ext_ioput * SOAP_FMAC4 soap_in_wsdl__ext_ioput(struct soap *soap, const char *tag, wsdl__ext_ioput *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsdl__ext_ioput *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsdl__ext_ioput, sizeof(wsdl__ext_ioput), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsdl__ext_ioput)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsdl__ext_ioput *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__NMTOKEN(soap, soap_attr_value(soap, "name", 5, 0), &((wsdl__ext_ioput*)a)->name))
		return NULL;
	if (soap_s2xsd__NMTOKEN(soap, soap_attr_value(soap, "messageLabel", 5, 0), &((wsdl__ext_ioput*)a)->messageLabel))
		return NULL;
	size_t soap_flag_documentation1 = 1;
	size_t soap_flag_wsp__Policy_1 = 1;
	size_t soap_flag_wsp__PolicyReference_1 = 1;
	size_t soap_flag_dime__message_1 = 1;
	size_t soap_flag_soap__body_1 = 1;
	size_t soap_flag_http__urlEncoded1 = 1;
	size_t soap_flag_mime__multipartRelated_1 = 1;
	size_t soap_flag_mime__content_1 = 1;
	size_t soap_flag_mime__mimeXml_1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_documentation1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "wsdl:documentation", (char**)&a->wsdl__ext_ioput::documentation, "xsd:string"))
				{	soap_flag_documentation1--;
					continue;
				}
			}
			if (soap_flag_wsp__Policy_1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsp__Policy(soap, "wsp:Policy", &a->wsdl__ext_ioput::wsp__Policy_, "wsp:Policy"))
				{	soap_flag_wsp__Policy_1--;
					continue;
				}
			}
			if (soap_flag_wsp__PolicyReference_1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsp__PolicyReference(soap, "wsp:PolicyReference", &a->wsdl__ext_ioput::wsp__PolicyReference_, "wsp:PolicyReference"))
				{	soap_flag_wsp__PolicyReference_1--;
					continue;
				}
			}
			if (soap_flag_dime__message_1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodime__message(soap, "dime:message", &a->wsdl__ext_ioput::dime__message_, "dime:message"))
				{	soap_flag_dime__message_1--;
					continue;
				}
			}
			if (soap_flag_soap__body_1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosoap__body(soap, "soap:body", &a->wsdl__ext_ioput::soap__body_, "soap:body"))
				{	soap_flag_soap__body_1--;
					continue;
				}
			}
			if (soap_flag_http__urlEncoded1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "http:urlEncoded", (char**)&a->wsdl__ext_ioput::http__urlEncoded, "xsd:string"))
				{	soap_flag_http__urlEncoded1--;
					continue;
				}
			}
			if (soap_flag_mime__multipartRelated_1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTomime__multipartRelated(soap, "mime:multipartRelated", &a->wsdl__ext_ioput::mime__multipartRelated_, "mime:multipartRelated"))
				{	soap_flag_mime__multipartRelated_1--;
					continue;
				}
			}
			if (soap_flag_mime__content_1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTomime__content(soap, "mime:content", &a->wsdl__ext_ioput::mime__content_, "mime:content"))
				{	soap_flag_mime__content_1--;
					continue;
				}
			}
			if (soap_flag_mime__mimeXml_1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTomime__mimeXml(soap, "mime:mimeXml", &a->wsdl__ext_ioput::mime__mimeXml_, "mime:mimeXml"))
				{	soap_flag_mime__mimeXml_1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfsoap__header(soap, "soap:header", &a->wsdl__ext_ioput::soap__header_, "soap:header"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfwsoap__module(soap, "wsoap:module", &a->wsdl__ext_ioput::wsoap__module_, "wsoap:module"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfwsoap__header(soap, "wsoap:header", &a->wsdl__ext_ioput::wsoap__header_, "wsoap:header"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfwhttp__header(soap, "whttp:header", &a->wsdl__ext_ioput::whttp__header_, "whttp:header"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wsdl__ext_ioput *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsdl__ext_ioput, SOAP_TYPE_wsdl__ext_ioput, sizeof(wsdl__ext_ioput), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsdl__ext_ioput * SOAP_FMAC2 wsdl_instantiate_wsdl__ext_ioput(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_wsdl__ext_ioput(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsdl__ext_ioput *p;
	size_t k = sizeof(wsdl__ext_ioput);
	if (n < 0)
	{	p = SOAP_NEW(wsdl__ext_ioput);
	}
	else
	{	p = SOAP_NEW_ARRAY(wsdl__ext_ioput, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsdl__ext_ioput location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_wsdl__ext_ioput, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int wsdl__ext_ioput::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsdl__ext_ioput(soap, tag ? tag : "wsdl:ext-ioput", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsdl__ext_ioput::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsdl__ext_ioput(soap, this, tag, type);
}

SOAP_FMAC3 wsdl__ext_ioput * SOAP_FMAC4 soap_get_wsdl__ext_ioput(struct soap *soap, wsdl__ext_ioput *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsdl__ext_ioput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsdl__fault::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__NMTOKEN(soap, &this->wsdl__fault::name);
	soap_default_xsd__QName(soap, &this->wsdl__fault::message);
	soap_default_xsd__QName(soap, &this->wsdl__fault::ref);
	soap_default_xsd__NMTOKEN(soap, &this->wsdl__fault::messageLabel);
	soap_default_xsd__QName(soap, &this->wsdl__fault::element);
	soap_default_xsd__anyURI(soap, &this->wsdl__fault::wsa__Action);
	soap_default_xsd__anyURI(soap, &this->wsdl__fault::wsam__Action);
	soap_default_xsd__string(soap, &this->wsdl__fault::documentation);
	this->wsdl__fault::wsp__Policy_ = NULL;
	this->wsdl__fault::wsp__PolicyReference_ = NULL;
	this->wsdl__fault::messageRef = NULL;
	this->wsdl__fault::elementRef = NULL;
}

void wsdl__fault::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__string(soap, (char*const*)&this->wsdl__fault::documentation);
	soap_serialize_PointerTowsp__Policy(soap, &this->wsdl__fault::wsp__Policy_);
	soap_serialize_PointerTowsp__PolicyReference(soap, &this->wsdl__fault::wsp__PolicyReference_);
	/* non-serializable messageRef skipped */
	/* non-serializable elementRef skipped */
#endif
}

int wsdl__fault::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsdl__fault(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdl__fault(struct soap *soap, const char *tag, int id, const wsdl__fault *a, const char *type)
{
	if (((wsdl__fault*)a)->name)
		soap_set_attr(soap, "name", soap_xsd__NMTOKEN2s(soap, ((wsdl__fault*)a)->name), 1);
	if (((wsdl__fault*)a)->message)
		soap_set_attr(soap, "message", soap_xsd__QName2s(soap, ((wsdl__fault*)a)->message), 1);
	if (((wsdl__fault*)a)->ref)
		soap_set_attr(soap, "ref", soap_xsd__QName2s(soap, ((wsdl__fault*)a)->ref), 1);
	if (((wsdl__fault*)a)->messageLabel)
		soap_set_attr(soap, "messageLabel", soap_xsd__NMTOKEN2s(soap, ((wsdl__fault*)a)->messageLabel), 1);
	if (((wsdl__fault*)a)->element)
		soap_set_attr(soap, "element", soap_xsd__QName2s(soap, ((wsdl__fault*)a)->element), 1);
	if (((wsdl__fault*)a)->wsa__Action)
		soap_set_attr(soap, "wsa:Action", soap_xsd__anyURI2s(soap, ((wsdl__fault*)a)->wsa__Action), 1);
	if (((wsdl__fault*)a)->wsam__Action)
		soap_set_attr(soap, "wsam:Action", soap_xsd__anyURI2s(soap, ((wsdl__fault*)a)->wsam__Action), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsdl__fault), type))
		return soap->error;
	if (soap_out_xsd__string(soap, "wsdl:documentation", -1, (char*const*)&a->wsdl__fault::documentation, ""))
		return soap->error;
	if (soap_out_PointerTowsp__Policy(soap, "wsp:Policy", -1, &a->wsdl__fault::wsp__Policy_, ""))
		return soap->error;
	if (soap_out_PointerTowsp__PolicyReference(soap, "wsp:PolicyReference", -1, &a->wsdl__fault::wsp__PolicyReference_, ""))
		return soap->error;
	/* non-serializable messageRef skipped */
	/* non-serializable elementRef skipped */
	return soap_element_end_out(soap, tag);
}

void *wsdl__fault::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wsdl__fault(soap, tag, this, type);
}

SOAP_FMAC3 wsdl__fault * SOAP_FMAC4 soap_in_wsdl__fault(struct soap *soap, const char *tag, wsdl__fault *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsdl__fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsdl__fault, sizeof(wsdl__fault), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsdl__fault)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsdl__fault *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__NMTOKEN(soap, soap_attr_value(soap, "name", 5, 0), &((wsdl__fault*)a)->name))
		return NULL;
	if (soap_s2xsd__QName(soap, soap_attr_value(soap, "message", 2, 0), &((wsdl__fault*)a)->message))
		return NULL;
	if (soap_s2xsd__QName(soap, soap_attr_value(soap, "ref", 2, 0), &((wsdl__fault*)a)->ref))
		return NULL;
	if (soap_s2xsd__NMTOKEN(soap, soap_attr_value(soap, "messageLabel", 5, 0), &((wsdl__fault*)a)->messageLabel))
		return NULL;
	if (soap_s2xsd__QName(soap, soap_attr_value(soap, "element", 2, 0), &((wsdl__fault*)a)->element))
		return NULL;
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "wsa:Action", 4, 0), &((wsdl__fault*)a)->wsa__Action))
		return NULL;
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "wsam:Action", 4, 0), &((wsdl__fault*)a)->wsam__Action))
		return NULL;
	size_t soap_flag_documentation1 = 1;
	size_t soap_flag_wsp__Policy_1 = 1;
	size_t soap_flag_wsp__PolicyReference_1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_documentation1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "wsdl:documentation", (char**)&a->wsdl__fault::documentation, "xsd:string"))
				{	soap_flag_documentation1--;
					continue;
				}
			}
			if (soap_flag_wsp__Policy_1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsp__Policy(soap, "wsp:Policy", &a->wsdl__fault::wsp__Policy_, "wsp:Policy"))
				{	soap_flag_wsp__Policy_1--;
					continue;
				}
			}
			if (soap_flag_wsp__PolicyReference_1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsp__PolicyReference(soap, "wsp:PolicyReference", &a->wsdl__fault::wsp__PolicyReference_, "wsp:PolicyReference"))
				{	soap_flag_wsp__PolicyReference_1--;
					continue;
				}
			}
			/* non-serializable messageRef skipped */
			/* non-serializable elementRef skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wsdl__fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsdl__fault, SOAP_TYPE_wsdl__fault, sizeof(wsdl__fault), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsdl__fault * SOAP_FMAC2 wsdl_instantiate_wsdl__fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_wsdl__fault(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsdl__fault *p;
	size_t k = sizeof(wsdl__fault);
	if (n < 0)
	{	p = SOAP_NEW(wsdl__fault);
	}
	else
	{	p = SOAP_NEW_ARRAY(wsdl__fault, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsdl__fault location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_wsdl__fault, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int wsdl__fault::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsdl__fault(soap, tag ? tag : "wsdl:fault", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsdl__fault::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsdl__fault(soap, this, tag, type);
}

SOAP_FMAC3 wsdl__fault * SOAP_FMAC4 soap_get_wsdl__fault(struct soap *soap, wsdl__fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsdl__fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsdl__ioput::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__NMTOKEN(soap, &this->wsdl__ioput::name);
	soap_default_xsd__QName(soap, &this->wsdl__ioput::message);
	soap_default_xsd__NMTOKEN(soap, &this->wsdl__ioput::messageLabel);
	soap_default_xsd__QName(soap, &this->wsdl__ioput::element);
	soap_default_xsd__anyURI(soap, &this->wsdl__ioput::wsa__Action);
	soap_default_xsd__anyURI(soap, &this->wsdl__ioput::wsam__Action);
	soap_default_xsd__string(soap, &this->wsdl__ioput::documentation);
	this->wsdl__ioput::wsp__Policy_ = NULL;
	this->wsdl__ioput::wsp__PolicyReference_ = NULL;
	this->wsdl__ioput::messageRef = NULL;
	this->wsdl__ioput::elementRef = NULL;
}

void wsdl__ioput::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__string(soap, (char*const*)&this->wsdl__ioput::documentation);
	soap_serialize_PointerTowsp__Policy(soap, &this->wsdl__ioput::wsp__Policy_);
	soap_serialize_PointerTowsp__PolicyReference(soap, &this->wsdl__ioput::wsp__PolicyReference_);
	/* non-serializable messageRef skipped */
	/* non-serializable elementRef skipped */
#endif
}

int wsdl__ioput::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsdl__ioput(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdl__ioput(struct soap *soap, const char *tag, int id, const wsdl__ioput *a, const char *type)
{
	if (((wsdl__ioput*)a)->name)
		soap_set_attr(soap, "name", soap_xsd__NMTOKEN2s(soap, ((wsdl__ioput*)a)->name), 1);
	if (((wsdl__ioput*)a)->message)
		soap_set_attr(soap, "message", soap_xsd__QName2s(soap, ((wsdl__ioput*)a)->message), 1);
	if (((wsdl__ioput*)a)->messageLabel)
		soap_set_attr(soap, "messageLabel", soap_xsd__NMTOKEN2s(soap, ((wsdl__ioput*)a)->messageLabel), 1);
	if (((wsdl__ioput*)a)->element)
		soap_set_attr(soap, "element", soap_xsd__QName2s(soap, ((wsdl__ioput*)a)->element), 1);
	if (((wsdl__ioput*)a)->wsa__Action)
		soap_set_attr(soap, "wsa:Action", soap_xsd__anyURI2s(soap, ((wsdl__ioput*)a)->wsa__Action), 1);
	if (((wsdl__ioput*)a)->wsam__Action)
		soap_set_attr(soap, "wsam:Action", soap_xsd__anyURI2s(soap, ((wsdl__ioput*)a)->wsam__Action), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsdl__ioput), type))
		return soap->error;
	if (soap_out_xsd__string(soap, "wsdl:documentation", -1, (char*const*)&a->wsdl__ioput::documentation, ""))
		return soap->error;
	if (soap_out_PointerTowsp__Policy(soap, "wsp:Policy", -1, &a->wsdl__ioput::wsp__Policy_, ""))
		return soap->error;
	if (soap_out_PointerTowsp__PolicyReference(soap, "wsp:PolicyReference", -1, &a->wsdl__ioput::wsp__PolicyReference_, ""))
		return soap->error;
	/* non-serializable messageRef skipped */
	/* non-serializable elementRef skipped */
	return soap_element_end_out(soap, tag);
}

void *wsdl__ioput::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wsdl__ioput(soap, tag, this, type);
}

SOAP_FMAC3 wsdl__ioput * SOAP_FMAC4 soap_in_wsdl__ioput(struct soap *soap, const char *tag, wsdl__ioput *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsdl__ioput *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsdl__ioput, sizeof(wsdl__ioput), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsdl__ioput)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsdl__ioput *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__NMTOKEN(soap, soap_attr_value(soap, "name", 5, 0), &((wsdl__ioput*)a)->name))
		return NULL;
	if (soap_s2xsd__QName(soap, soap_attr_value(soap, "message", 2, 0), &((wsdl__ioput*)a)->message))
		return NULL;
	if (soap_s2xsd__NMTOKEN(soap, soap_attr_value(soap, "messageLabel", 5, 0), &((wsdl__ioput*)a)->messageLabel))
		return NULL;
	if (soap_s2xsd__QName(soap, soap_attr_value(soap, "element", 2, 0), &((wsdl__ioput*)a)->element))
		return NULL;
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "wsa:Action", 4, 0), &((wsdl__ioput*)a)->wsa__Action))
		return NULL;
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "wsam:Action", 4, 0), &((wsdl__ioput*)a)->wsam__Action))
		return NULL;
	size_t soap_flag_documentation1 = 1;
	size_t soap_flag_wsp__Policy_1 = 1;
	size_t soap_flag_wsp__PolicyReference_1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_documentation1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "wsdl:documentation", (char**)&a->wsdl__ioput::documentation, "xsd:string"))
				{	soap_flag_documentation1--;
					continue;
				}
			}
			if (soap_flag_wsp__Policy_1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsp__Policy(soap, "wsp:Policy", &a->wsdl__ioput::wsp__Policy_, "wsp:Policy"))
				{	soap_flag_wsp__Policy_1--;
					continue;
				}
			}
			if (soap_flag_wsp__PolicyReference_1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsp__PolicyReference(soap, "wsp:PolicyReference", &a->wsdl__ioput::wsp__PolicyReference_, "wsp:PolicyReference"))
				{	soap_flag_wsp__PolicyReference_1--;
					continue;
				}
			}
			/* non-serializable messageRef skipped */
			/* non-serializable elementRef skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wsdl__ioput *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsdl__ioput, SOAP_TYPE_wsdl__ioput, sizeof(wsdl__ioput), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsdl__ioput * SOAP_FMAC2 wsdl_instantiate_wsdl__ioput(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_wsdl__ioput(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsdl__ioput *p;
	size_t k = sizeof(wsdl__ioput);
	if (n < 0)
	{	p = SOAP_NEW(wsdl__ioput);
	}
	else
	{	p = SOAP_NEW_ARRAY(wsdl__ioput, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsdl__ioput location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_wsdl__ioput, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int wsdl__ioput::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsdl__ioput(soap, tag ? tag : "wsdl:ioput", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsdl__ioput::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsdl__ioput(soap, this, tag, type);
}

SOAP_FMAC3 wsdl__ioput * SOAP_FMAC4 soap_get_wsdl__ioput(struct soap *soap, wsdl__ioput *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsdl__ioput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsdl__types::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xs__schema::soap_default(soap);
	soap_default_xsd__string(soap, &this->wsdl__types::documentation);
	soap_default_std__vectorTemplateOfPointerToxs__schema(soap, &this->wsdl__types::xs__schema_);
}

void wsdl__types::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__string(soap, (char*const*)&this->wsdl__types::documentation);
	soap_serialize_std__vectorTemplateOfPointerToxs__schema(soap, &this->wsdl__types::xs__schema_);
	this->xs__schema::soap_serialize(soap);
#endif
}

int wsdl__types::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsdl__types(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdl__types(struct soap *soap, const char *tag, int id, const wsdl__types *a, const char *type)
{
	if (((xs__schema*)a)->targetNamespace)
		soap_set_attr(soap, "targetNamespace", soap_xsd__anyURI2s(soap, ((xs__schema*)a)->targetNamespace), 1);
	if (((xs__schema*)a)->version)
		soap_set_attr(soap, "version", soap_xsd__string2s(soap, ((xs__schema*)a)->version), 1);
	if (((xs__schema*)a)->defaultAttributes)
		soap_set_attr(soap, "defaultAttributes", soap_xsd__NCName2s(soap, ((xs__schema*)a)->defaultAttributes), 1);
	soap_set_attr(soap, "attributeFormDefault", soap_xs__formChoice2s(soap, ((xs__schema*)a)->attributeFormDefault), 1);
	soap_set_attr(soap, "elementFormDefault", soap_xs__formChoice2s(soap, ((xs__schema*)a)->elementFormDefault), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsdl__types), type ? type : "wsdl:types"))
		return soap->error;
	if (soap_out_PointerToxs__annotation(soap, "xs:annotation", -1, &a->xs__schema::annotation, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxs__include(soap, "xs:include", -1, &a->xs__schema::include, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxs__override(soap, "xs:override", -1, &a->xs__schema::override_, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxs__redefine(soap, "xs:redefine", -1, &a->xs__schema::redefine, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxs__import(soap, "xs:import", -1, &a->xs__schema::import, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxs__attribute(soap, "xs:attribute", -1, &a->xs__schema::attribute, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxs__element(soap, "xs:element", -1, &a->xs__schema::element, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxs__group(soap, "xs:group", -1, &a->xs__schema::group, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxs__attributeGroup(soap, "xs:attributeGroup", -1, &a->xs__schema::attributeGroup, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxs__simpleType(soap, "xs:simpleType", -1, &a->xs__schema::simpleType, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxs__complexType(soap, "xs:complexType", -1, &a->xs__schema::complexType, ""))
		return soap->error;
	/* non-serializable attributeGroupRef skipped */
	/* non-serializable updated skipped */
	/* non-serializable location skipped */
	/* non-serializable redirs skipped */
	/* non-serializable builtinTypeSet skipped */
	/* non-serializable builtinElementSet skipped */
	/* non-serializable builtinAttributeSet skipped */
	if (soap_out_xsd__string(soap, "wsdl:documentation", -1, (char*const*)&a->wsdl__types::documentation, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerToxs__schema(soap, "xs:schema", -1, &a->wsdl__types::xs__schema_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsdl__types::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wsdl__types(soap, tag, this, type);
}

SOAP_FMAC3 wsdl__types * SOAP_FMAC4 soap_in_wsdl__types(struct soap *soap, const char *tag, wsdl__types *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsdl__types *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsdl__types, sizeof(wsdl__types), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsdl__types)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsdl__types *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "targetNamespace", 4, 0), &((xs__schema*)a)->targetNamespace))
		return NULL;
	if (soap_s2xsd__string(soap, soap_attr_value(soap, "version", 1, 0), &((xs__schema*)a)->version))
		return NULL;
	if (soap_s2xsd__NCName(soap, soap_attr_value(soap, "defaultAttributes", 5, 0), &((xs__schema*)a)->defaultAttributes))
		return NULL;
	if (soap_s2xs__formChoice(soap, soap_attr_value(soap, "attributeFormDefault", 5, 0), &((xs__schema*)a)->attributeFormDefault))
		return NULL;
	if (soap_s2xs__formChoice(soap, soap_attr_value(soap, "elementFormDefault", 5, 0), &((xs__schema*)a)->elementFormDefault))
		return NULL;
	size_t soap_flag_annotation2 = 1;
	size_t soap_flag_documentation1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_annotation2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxs__annotation(soap, "xs:annotation", &a->xs__schema::annotation, "xs:annotation"))
				{	soap_flag_annotation2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxs__include(soap, "xs:include", &a->xs__schema::include, "xs:include"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxs__override(soap, "xs:override", &a->xs__schema::override_, "xs:override"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxs__redefine(soap, "xs:redefine", &a->xs__schema::redefine, "xs:redefine"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxs__import(soap, "xs:import", &a->xs__schema::import, "xs:import"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxs__attribute(soap, "xs:attribute", &a->xs__schema::attribute, "xs:attribute"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxs__element(soap, "xs:element", &a->xs__schema::element, "xs:element"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxs__group(soap, "xs:group", &a->xs__schema::group, "xs:group"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxs__attributeGroup(soap, "xs:attributeGroup", &a->xs__schema::attributeGroup, "xs:attributeGroup"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxs__simpleType(soap, "xs:simpleType", &a->xs__schema::simpleType, "xs:simpleType"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxs__complexType(soap, "xs:complexType", &a->xs__schema::complexType, "xs:complexType"))
					continue;
			}
			/* non-serializable attributeGroupRef skipped */
			/* non-serializable updated skipped */
			/* non-serializable location skipped */
			/* non-serializable redirs skipped */
			/* non-serializable builtinTypeSet skipped */
			/* non-serializable builtinElementSet skipped */
			/* non-serializable builtinAttributeSet skipped */
			if (soap_flag_documentation1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "wsdl:documentation", (char**)&a->wsdl__types::documentation, "xsd:string"))
				{	soap_flag_documentation1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerToxs__schema(soap, "xs:schema", &a->wsdl__types::xs__schema_, "xs:schema"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if (a->get(soap))
			return NULL;
	}
	else
	{	a = (wsdl__types *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsdl__types, SOAP_TYPE_wsdl__types, sizeof(wsdl__types), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsdl__types * SOAP_FMAC2 wsdl_instantiate_wsdl__types(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_wsdl__types(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsdl__types *p;
	size_t k = sizeof(wsdl__types);
	if (n < 0)
	{	p = SOAP_NEW(wsdl__types);
		if (p)
			((wsdl__types*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(wsdl__types, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((wsdl__types*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsdl__types location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_wsdl__types, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int wsdl__types::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsdl__types(soap, tag ? tag : "wsdl:types", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsdl__types::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsdl__types(soap, this, tag, type);
}

SOAP_FMAC3 wsdl__types * SOAP_FMAC4 soap_get_wsdl__types(struct soap *soap, wsdl__types *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsdl__types(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsdl__import::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &this->wsdl__import::namespace_);
	soap_default_xsd__anyURI(soap, &this->wsdl__import::location);
	this->wsdl__import::definitionsRef = NULL;
}

void wsdl__import::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	/* non-serializable definitionsRef skipped */
#endif
}

int wsdl__import::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsdl__import(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdl__import(struct soap *soap, const char *tag, int id, const wsdl__import *a, const char *type)
{
	if (((wsdl__import*)a)->namespace_)
		soap_set_attr(soap, "namespace", soap_xsd__anyURI2s(soap, ((wsdl__import*)a)->namespace_), 1);
	if (((wsdl__import*)a)->location)
		soap_set_attr(soap, "location", soap_xsd__anyURI2s(soap, ((wsdl__import*)a)->location), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsdl__import), type))
		return soap->error;
	/* non-serializable definitionsRef skipped */
	return soap_element_end_out(soap, tag);
}

void *wsdl__import::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wsdl__import(soap, tag, this, type);
}

SOAP_FMAC3 wsdl__import * SOAP_FMAC4 soap_in_wsdl__import(struct soap *soap, const char *tag, wsdl__import *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsdl__import *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsdl__import, sizeof(wsdl__import), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsdl__import)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsdl__import *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "namespace", 4, 0), &((wsdl__import*)a)->namespace_))
		return NULL;
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "location", 4, 0), &((wsdl__import*)a)->location))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* non-serializable definitionsRef skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wsdl__import *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsdl__import, SOAP_TYPE_wsdl__import, sizeof(wsdl__import), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsdl__import * SOAP_FMAC2 wsdl_instantiate_wsdl__import(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_wsdl__import(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsdl__import *p;
	size_t k = sizeof(wsdl__import);
	if (n < 0)
	{	p = SOAP_NEW(wsdl__import);
	}
	else
	{	p = SOAP_NEW_ARRAY(wsdl__import, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsdl__import location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_wsdl__import, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int wsdl__import::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsdl__import(soap, tag ? tag : "wsdl:import", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsdl__import::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsdl__import(soap, this, tag, type);
}

SOAP_FMAC3 wsdl__import * SOAP_FMAC4 soap_get_wsdl__import(struct soap *soap, wsdl__import *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsdl__import(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void vprop__tPropertyAlias::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->vprop__tPropertyAlias::query = NULL;
	soap_default_xsd__QName(soap, &this->vprop__tPropertyAlias::propertyName);
	soap_default_xsd__QName(soap, &this->vprop__tPropertyAlias::messageType);
	soap_default_xsd__NCName(soap, &this->vprop__tPropertyAlias::part);
	soap_default_xsd__QName(soap, &this->vprop__tPropertyAlias::type);
	soap_default_xsd__QName(soap, &this->vprop__tPropertyAlias::element);
	soap_default_xsd__string(soap, &this->vprop__tPropertyAlias::documentation);
	this->vprop__tPropertyAlias::vpropRef = NULL;
}

void vprop__tPropertyAlias::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTovprop__tQuery(soap, &this->vprop__tPropertyAlias::query);
	soap_serialize_xsd__string(soap, (char*const*)&this->vprop__tPropertyAlias::documentation);
	/* non-serializable vpropRef skipped */
#endif
}

int vprop__tPropertyAlias::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vprop__tPropertyAlias(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_vprop__tPropertyAlias(struct soap *soap, const char *tag, int id, const vprop__tPropertyAlias *a, const char *type)
{
	if (((vprop__tPropertyAlias*)a)->propertyName)
		soap_set_attr(soap, "propertyName", soap_xsd__QName2s(soap, ((vprop__tPropertyAlias*)a)->propertyName), 1);
	if (((vprop__tPropertyAlias*)a)->messageType)
		soap_set_attr(soap, "messageType", soap_xsd__QName2s(soap, ((vprop__tPropertyAlias*)a)->messageType), 1);
	if (((vprop__tPropertyAlias*)a)->part)
		soap_set_attr(soap, "part", soap_xsd__NCName2s(soap, ((vprop__tPropertyAlias*)a)->part), 1);
	if (((vprop__tPropertyAlias*)a)->type)
		soap_set_attr(soap, "type", soap_xsd__QName2s(soap, ((vprop__tPropertyAlias*)a)->type), 1);
	if (((vprop__tPropertyAlias*)a)->element)
		soap_set_attr(soap, "element", soap_xsd__QName2s(soap, ((vprop__tPropertyAlias*)a)->element), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vprop__tPropertyAlias), type))
		return soap->error;
	if (soap_out_PointerTovprop__tQuery(soap, "vprop:query", -1, &a->vprop__tPropertyAlias::query, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "vprop:documentation", -1, (char*const*)&a->vprop__tPropertyAlias::documentation, ""))
		return soap->error;
	/* non-serializable vpropRef skipped */
	return soap_element_end_out(soap, tag);
}

void *vprop__tPropertyAlias::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_vprop__tPropertyAlias(soap, tag, this, type);
}

SOAP_FMAC3 vprop__tPropertyAlias * SOAP_FMAC4 soap_in_vprop__tPropertyAlias(struct soap *soap, const char *tag, vprop__tPropertyAlias *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vprop__tPropertyAlias *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_vprop__tPropertyAlias, sizeof(vprop__tPropertyAlias), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_vprop__tPropertyAlias)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (vprop__tPropertyAlias *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__QName(soap, soap_attr_value(soap, "propertyName", 2, 0), &((vprop__tPropertyAlias*)a)->propertyName))
		return NULL;
	if (soap_s2xsd__QName(soap, soap_attr_value(soap, "messageType", 2, 0), &((vprop__tPropertyAlias*)a)->messageType))
		return NULL;
	if (soap_s2xsd__NCName(soap, soap_attr_value(soap, "part", 5, 0), &((vprop__tPropertyAlias*)a)->part))
		return NULL;
	if (soap_s2xsd__QName(soap, soap_attr_value(soap, "type", 2, 0), &((vprop__tPropertyAlias*)a)->type))
		return NULL;
	if (soap_s2xsd__QName(soap, soap_attr_value(soap, "element", 2, 0), &((vprop__tPropertyAlias*)a)->element))
		return NULL;
	size_t soap_flag_query1 = 1;
	size_t soap_flag_documentation1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_query1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTovprop__tQuery(soap, "vprop:query", &a->vprop__tPropertyAlias::query, "vprop:tQuery"))
				{	soap_flag_query1--;
					continue;
				}
			}
			if (soap_flag_documentation1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "vprop:documentation", (char**)&a->vprop__tPropertyAlias::documentation, "xsd:string"))
				{	soap_flag_documentation1--;
					continue;
				}
			}
			/* non-serializable vpropRef skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (vprop__tPropertyAlias *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vprop__tPropertyAlias, SOAP_TYPE_vprop__tPropertyAlias, sizeof(vprop__tPropertyAlias), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 vprop__tPropertyAlias * SOAP_FMAC2 wsdl_instantiate_vprop__tPropertyAlias(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_vprop__tPropertyAlias(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	vprop__tPropertyAlias *p;
	size_t k = sizeof(vprop__tPropertyAlias);
	if (n < 0)
	{	p = SOAP_NEW(vprop__tPropertyAlias);
	}
	else
	{	p = SOAP_NEW_ARRAY(vprop__tPropertyAlias, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated vprop__tPropertyAlias location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_vprop__tPropertyAlias, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int vprop__tPropertyAlias::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_vprop__tPropertyAlias(soap, tag ? tag : "vprop:tPropertyAlias", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *vprop__tPropertyAlias::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vprop__tPropertyAlias(soap, this, tag, type);
}

SOAP_FMAC3 vprop__tPropertyAlias * SOAP_FMAC4 soap_get_vprop__tPropertyAlias(struct soap *soap, vprop__tPropertyAlias *p, const char *tag, const char *type)
{
	if ((p = soap_in_vprop__tPropertyAlias(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void vprop__tProperty::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__NCName(soap, &this->vprop__tProperty::name);
	soap_default_xsd__QName(soap, &this->vprop__tProperty::type);
	soap_default_xsd__QName(soap, &this->vprop__tProperty::element);
	soap_default_xsd__string(soap, &this->vprop__tProperty::documentation);
}

void vprop__tProperty::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__string(soap, (char*const*)&this->vprop__tProperty::documentation);
#endif
}

int vprop__tProperty::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vprop__tProperty(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_vprop__tProperty(struct soap *soap, const char *tag, int id, const vprop__tProperty *a, const char *type)
{
	if (((vprop__tProperty*)a)->name)
		soap_set_attr(soap, "name", soap_xsd__NCName2s(soap, ((vprop__tProperty*)a)->name), 1);
	if (((vprop__tProperty*)a)->type)
		soap_set_attr(soap, "type", soap_xsd__QName2s(soap, ((vprop__tProperty*)a)->type), 1);
	if (((vprop__tProperty*)a)->element)
		soap_set_attr(soap, "element", soap_xsd__QName2s(soap, ((vprop__tProperty*)a)->element), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vprop__tProperty), type))
		return soap->error;
	if (soap_out_xsd__string(soap, "vprop:documentation", -1, (char*const*)&a->vprop__tProperty::documentation, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *vprop__tProperty::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_vprop__tProperty(soap, tag, this, type);
}

SOAP_FMAC3 vprop__tProperty * SOAP_FMAC4 soap_in_vprop__tProperty(struct soap *soap, const char *tag, vprop__tProperty *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vprop__tProperty *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_vprop__tProperty, sizeof(vprop__tProperty), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_vprop__tProperty)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (vprop__tProperty *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__NCName(soap, soap_attr_value(soap, "name", 5, 0), &((vprop__tProperty*)a)->name))
		return NULL;
	if (soap_s2xsd__QName(soap, soap_attr_value(soap, "type", 2, 0), &((vprop__tProperty*)a)->type))
		return NULL;
	if (soap_s2xsd__QName(soap, soap_attr_value(soap, "element", 2, 0), &((vprop__tProperty*)a)->element))
		return NULL;
	size_t soap_flag_documentation1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_documentation1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "vprop:documentation", (char**)&a->vprop__tProperty::documentation, "xsd:string"))
				{	soap_flag_documentation1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (vprop__tProperty *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vprop__tProperty, SOAP_TYPE_vprop__tProperty, sizeof(vprop__tProperty), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 vprop__tProperty * SOAP_FMAC2 wsdl_instantiate_vprop__tProperty(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_vprop__tProperty(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	vprop__tProperty *p;
	size_t k = sizeof(vprop__tProperty);
	if (n < 0)
	{	p = SOAP_NEW(vprop__tProperty);
	}
	else
	{	p = SOAP_NEW_ARRAY(vprop__tProperty, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated vprop__tProperty location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_vprop__tProperty, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int vprop__tProperty::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_vprop__tProperty(soap, tag ? tag : "vprop:tProperty", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *vprop__tProperty::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vprop__tProperty(soap, this, tag, type);
}

SOAP_FMAC3 vprop__tProperty * SOAP_FMAC4 soap_get_vprop__tProperty(struct soap *soap, vprop__tProperty *p, const char *tag, const char *type)
{
	if ((p = soap_in_vprop__tProperty(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void vprop__tQuery::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->vprop__tQuery::queryLanguage = (char*)"urn:oasis:names:tc:wsbpel:2.0:sublang:xpath1.0";
	soap_default_xsd__QName(soap, &this->vprop__tQuery::__mixed);
}

void vprop__tQuery::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__QName(soap, (char*const*)&this->vprop__tQuery::__mixed);
#endif
}

int vprop__tQuery::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_vprop__tQuery(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_vprop__tQuery(struct soap *soap, const char *tag, int id, const vprop__tQuery *a, const char *type)
{
	if (((vprop__tQuery*)a)->queryLanguage)
		soap_set_attr(soap, "queryLanguage", soap_xsd__anyURI2s(soap, ((vprop__tQuery*)a)->queryLanguage), 1);
	const char *soap_tmp___mixed = soap_QName2s(soap, a->__mixed);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vprop__tQuery), type))
		return soap->error;
	if (soap_out_xsd__QName(soap, "-mixed", -1, (char*const*)(void*)&soap_tmp___mixed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *vprop__tQuery::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_vprop__tQuery(soap, tag, this, type);
}

SOAP_FMAC3 vprop__tQuery * SOAP_FMAC4 soap_in_vprop__tQuery(struct soap *soap, const char *tag, vprop__tQuery *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (vprop__tQuery *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_vprop__tQuery, sizeof(vprop__tQuery), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_vprop__tQuery)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (vprop__tQuery *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "queryLanguage", 4, 0), &((vprop__tQuery*)a)->queryLanguage))
		return NULL;
	size_t soap_flag___mixed1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__QName(soap, "-mixed", (char**)&a->vprop__tQuery::__mixed, "xsd:QName"))
				{	soap_flag___mixed1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (vprop__tQuery *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vprop__tQuery, SOAP_TYPE_vprop__tQuery, sizeof(vprop__tQuery), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 vprop__tQuery * SOAP_FMAC2 wsdl_instantiate_vprop__tQuery(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_vprop__tQuery(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	vprop__tQuery *p;
	size_t k = sizeof(vprop__tQuery);
	if (n < 0)
	{	p = SOAP_NEW(vprop__tQuery);
	}
	else
	{	p = SOAP_NEW_ARRAY(vprop__tQuery, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated vprop__tQuery location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_vprop__tQuery, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int vprop__tQuery::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_vprop__tQuery(soap, tag ? tag : "vprop:tQuery", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *vprop__tQuery::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_vprop__tQuery(soap, this, tag, type);
}

SOAP_FMAC3 vprop__tQuery * SOAP_FMAC4 soap_get_vprop__tQuery(struct soap *soap, vprop__tQuery *p, const char *tag, const char *type)
{
	if ((p = soap_in_vprop__tQuery(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void plnk__tRole::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__NCName(soap, &this->plnk__tRole::name);
	soap_default_xsd__QName(soap, &this->plnk__tRole::portType);
	soap_default_xsd__string(soap, &this->plnk__tRole::documentation);
	this->plnk__tRole::portTypeRef = NULL;
	this->plnk__tRole::plnkRef = NULL;
}

void plnk__tRole::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__string(soap, (char*const*)&this->plnk__tRole::documentation);
	/* non-serializable portTypeRef skipped */
	/* non-serializable plnkRef skipped */
#endif
}

int plnk__tRole::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_plnk__tRole(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_plnk__tRole(struct soap *soap, const char *tag, int id, const plnk__tRole *a, const char *type)
{
	if (((plnk__tRole*)a)->name)
		soap_set_attr(soap, "name", soap_xsd__NCName2s(soap, ((plnk__tRole*)a)->name), 1);
	if (((plnk__tRole*)a)->portType)
		soap_set_attr(soap, "portType", soap_xsd__QName2s(soap, ((plnk__tRole*)a)->portType), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_plnk__tRole), type))
		return soap->error;
	if (soap_out_xsd__string(soap, "plnk:documentation", -1, (char*const*)&a->plnk__tRole::documentation, ""))
		return soap->error;
	/* non-serializable portTypeRef skipped */
	/* non-serializable plnkRef skipped */
	return soap_element_end_out(soap, tag);
}

void *plnk__tRole::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_plnk__tRole(soap, tag, this, type);
}

SOAP_FMAC3 plnk__tRole * SOAP_FMAC4 soap_in_plnk__tRole(struct soap *soap, const char *tag, plnk__tRole *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (plnk__tRole *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_plnk__tRole, sizeof(plnk__tRole), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_plnk__tRole)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (plnk__tRole *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__NCName(soap, soap_attr_value(soap, "name", 5, 0), &((plnk__tRole*)a)->name))
		return NULL;
	if (soap_s2xsd__QName(soap, soap_attr_value(soap, "portType", 2, 0), &((plnk__tRole*)a)->portType))
		return NULL;
	size_t soap_flag_documentation1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_documentation1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "plnk:documentation", (char**)&a->plnk__tRole::documentation, "xsd:string"))
				{	soap_flag_documentation1--;
					continue;
				}
			}
			/* non-serializable portTypeRef skipped */
			/* non-serializable plnkRef skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (plnk__tRole *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_plnk__tRole, SOAP_TYPE_plnk__tRole, sizeof(plnk__tRole), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 plnk__tRole * SOAP_FMAC2 wsdl_instantiate_plnk__tRole(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_plnk__tRole(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	plnk__tRole *p;
	size_t k = sizeof(plnk__tRole);
	if (n < 0)
	{	p = SOAP_NEW(plnk__tRole);
	}
	else
	{	p = SOAP_NEW_ARRAY(plnk__tRole, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated plnk__tRole location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_plnk__tRole, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int plnk__tRole::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_plnk__tRole(soap, tag ? tag : "plnk:tRole", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *plnk__tRole::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_plnk__tRole(soap, this, tag, type);
}

SOAP_FMAC3 plnk__tRole * SOAP_FMAC4 soap_get_plnk__tRole(struct soap *soap, plnk__tRole *p, const char *tag, const char *type)
{
	if ((p = soap_in_plnk__tRole(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void plnk__tPartnerLinkType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__NCName(soap, &this->plnk__tPartnerLinkType::name);
	soap_default_std__vectorTemplateOfplnk__tRole(soap, &this->plnk__tPartnerLinkType::role);
	soap_default_xsd__string(soap, &this->plnk__tPartnerLinkType::documentation);
}

void plnk__tPartnerLinkType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfplnk__tRole(soap, &this->plnk__tPartnerLinkType::role);
	soap_serialize_xsd__string(soap, (char*const*)&this->plnk__tPartnerLinkType::documentation);
#endif
}

int plnk__tPartnerLinkType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_plnk__tPartnerLinkType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_plnk__tPartnerLinkType(struct soap *soap, const char *tag, int id, const plnk__tPartnerLinkType *a, const char *type)
{
	if (((plnk__tPartnerLinkType*)a)->name)
		soap_set_attr(soap, "name", soap_xsd__NCName2s(soap, ((plnk__tPartnerLinkType*)a)->name), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_plnk__tPartnerLinkType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfplnk__tRole(soap, "plnk:role", -1, &a->plnk__tPartnerLinkType::role, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "plnk:documentation", -1, (char*const*)&a->plnk__tPartnerLinkType::documentation, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *plnk__tPartnerLinkType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_plnk__tPartnerLinkType(soap, tag, this, type);
}

SOAP_FMAC3 plnk__tPartnerLinkType * SOAP_FMAC4 soap_in_plnk__tPartnerLinkType(struct soap *soap, const char *tag, plnk__tPartnerLinkType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (plnk__tPartnerLinkType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_plnk__tPartnerLinkType, sizeof(plnk__tPartnerLinkType), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_plnk__tPartnerLinkType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (plnk__tPartnerLinkType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__NCName(soap, soap_attr_value(soap, "name", 5, 0), &((plnk__tPartnerLinkType*)a)->name))
		return NULL;
	size_t soap_flag_documentation1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfplnk__tRole(soap, "plnk:role", &a->plnk__tPartnerLinkType::role, "plnk:tRole"))
					continue;
			}
			if (soap_flag_documentation1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "plnk:documentation", (char**)&a->plnk__tPartnerLinkType::documentation, "xsd:string"))
				{	soap_flag_documentation1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (plnk__tPartnerLinkType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_plnk__tPartnerLinkType, SOAP_TYPE_plnk__tPartnerLinkType, sizeof(plnk__tPartnerLinkType), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 plnk__tPartnerLinkType * SOAP_FMAC2 wsdl_instantiate_plnk__tPartnerLinkType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_plnk__tPartnerLinkType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	plnk__tPartnerLinkType *p;
	size_t k = sizeof(plnk__tPartnerLinkType);
	if (n < 0)
	{	p = SOAP_NEW(plnk__tPartnerLinkType);
	}
	else
	{	p = SOAP_NEW_ARRAY(plnk__tPartnerLinkType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated plnk__tPartnerLinkType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_plnk__tPartnerLinkType, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int plnk__tPartnerLinkType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_plnk__tPartnerLinkType(soap, tag ? tag : "plnk:tPartnerLinkType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *plnk__tPartnerLinkType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_plnk__tPartnerLinkType(soap, this, tag, type);
}

SOAP_FMAC3 plnk__tPartnerLinkType * SOAP_FMAC4 soap_get_plnk__tPartnerLinkType(struct soap *soap, plnk__tPartnerLinkType *p, const char *tag, const char *type)
{
	if ((p = soap_in_plnk__tPartnerLinkType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsdl__portType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__NMTOKEN(soap, &this->wsdl__portType::name);
	soap_default_xsd__QName(soap, &this->wsdl__portType::extends);
	soap_default_xsd__anyURI(soap, &this->wsdl__portType::styleDefault);
	soap_default_xsd__string(soap, &this->wsdl__portType::documentation);
	this->wsdl__portType::wsp__Policy_ = NULL;
	this->wsdl__portType::wsp__PolicyReference_ = NULL;
	soap_default_std__vectorTemplateOfwsdl__fault(soap, &this->wsdl__portType::fault);
	soap_default_std__vectorTemplateOfwsdl__operation(soap, &this->wsdl__portType::operation);
	this->wsdl__portType::definitionsRef = NULL;
}

void wsdl__portType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__string(soap, (char*const*)&this->wsdl__portType::documentation);
	soap_serialize_PointerTowsp__Policy(soap, &this->wsdl__portType::wsp__Policy_);
	soap_serialize_PointerTowsp__PolicyReference(soap, &this->wsdl__portType::wsp__PolicyReference_);
	soap_serialize_std__vectorTemplateOfwsdl__fault(soap, &this->wsdl__portType::fault);
	soap_serialize_std__vectorTemplateOfwsdl__operation(soap, &this->wsdl__portType::operation);
	/* non-serializable definitionsRef skipped */
#endif
}

int wsdl__portType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsdl__portType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdl__portType(struct soap *soap, const char *tag, int id, const wsdl__portType *a, const char *type)
{
	if (((wsdl__portType*)a)->name)
		soap_set_attr(soap, "name", soap_xsd__NMTOKEN2s(soap, ((wsdl__portType*)a)->name), 1);
	if (((wsdl__portType*)a)->extends)
		soap_set_attr(soap, "extends", soap_xsd__QName2s(soap, ((wsdl__portType*)a)->extends), 1);
	if (((wsdl__portType*)a)->styleDefault)
		soap_set_attr(soap, "styleDefault", soap_xsd__anyURI2s(soap, ((wsdl__portType*)a)->styleDefault), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsdl__portType), type))
		return soap->error;
	if (soap_out_xsd__string(soap, "wsdl:documentation", -1, (char*const*)&a->wsdl__portType::documentation, ""))
		return soap->error;
	if (soap_out_PointerTowsp__Policy(soap, "wsp:Policy", -1, &a->wsdl__portType::wsp__Policy_, ""))
		return soap->error;
	if (soap_out_PointerTowsp__PolicyReference(soap, "wsp:PolicyReference", -1, &a->wsdl__portType::wsp__PolicyReference_, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfwsdl__fault(soap, "wsdl:fault", -1, &a->wsdl__portType::fault, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfwsdl__operation(soap, "wsdl:operation", -1, &a->wsdl__portType::operation, ""))
		return soap->error;
	/* non-serializable definitionsRef skipped */
	return soap_element_end_out(soap, tag);
}

void *wsdl__portType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wsdl__portType(soap, tag, this, type);
}

SOAP_FMAC3 wsdl__portType * SOAP_FMAC4 soap_in_wsdl__portType(struct soap *soap, const char *tag, wsdl__portType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsdl__portType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsdl__portType, sizeof(wsdl__portType), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsdl__portType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsdl__portType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__NMTOKEN(soap, soap_attr_value(soap, "name", 5, 0), &((wsdl__portType*)a)->name))
		return NULL;
	if (soap_s2xsd__QName(soap, soap_attr_value(soap, "extends", 2, 0), &((wsdl__portType*)a)->extends))
		return NULL;
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "styleDefault", 4, 0), &((wsdl__portType*)a)->styleDefault))
		return NULL;
	size_t soap_flag_documentation1 = 1;
	size_t soap_flag_wsp__Policy_1 = 1;
	size_t soap_flag_wsp__PolicyReference_1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_documentation1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "wsdl:documentation", (char**)&a->wsdl__portType::documentation, "xsd:string"))
				{	soap_flag_documentation1--;
					continue;
				}
			}
			if (soap_flag_wsp__Policy_1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsp__Policy(soap, "wsp:Policy", &a->wsdl__portType::wsp__Policy_, "wsp:Policy"))
				{	soap_flag_wsp__Policy_1--;
					continue;
				}
			}
			if (soap_flag_wsp__PolicyReference_1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsp__PolicyReference(soap, "wsp:PolicyReference", &a->wsdl__portType::wsp__PolicyReference_, "wsp:PolicyReference"))
				{	soap_flag_wsp__PolicyReference_1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfwsdl__fault(soap, "wsdl:fault", &a->wsdl__portType::fault, "wsdl:fault"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfwsdl__operation(soap, "wsdl:operation", &a->wsdl__portType::operation, "wsdl:operation"))
					continue;
			}
			/* non-serializable definitionsRef skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wsdl__portType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsdl__portType, SOAP_TYPE_wsdl__portType, sizeof(wsdl__portType), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsdl__portType * SOAP_FMAC2 wsdl_instantiate_wsdl__portType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_wsdl__portType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsdl__portType *p;
	size_t k = sizeof(wsdl__portType);
	if (n < 0)
	{	p = SOAP_NEW(wsdl__portType);
	}
	else
	{	p = SOAP_NEW_ARRAY(wsdl__portType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsdl__portType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_wsdl__portType, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int wsdl__portType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsdl__portType(soap, tag ? tag : "wsdl:portType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsdl__portType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsdl__portType(soap, this, tag, type);
}

SOAP_FMAC3 wsdl__portType * SOAP_FMAC4 soap_get_wsdl__portType(struct soap *soap, wsdl__portType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsdl__portType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsp__PolicyAttachment::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->wsp__PolicyAttachment::AppliesTo = NULL;
	soap_default_std__vectorTemplateOfwsp__Attachment(soap, &this->wsp__PolicyAttachment::Attachment);
}

void wsp__PolicyAttachment::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowsp__AppliesTo(soap, &this->wsp__PolicyAttachment::AppliesTo);
	soap_serialize_std__vectorTemplateOfwsp__Attachment(soap, &this->wsp__PolicyAttachment::Attachment);
#endif
}

int wsp__PolicyAttachment::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsp__PolicyAttachment(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsp__PolicyAttachment(struct soap *soap, const char *tag, int id, const wsp__PolicyAttachment *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsp__PolicyAttachment), type))
		return soap->error;
	if (soap_out_PointerTowsp__AppliesTo(soap, "wsp:AppliesTo", -1, &a->wsp__PolicyAttachment::AppliesTo, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfwsp__Attachment(soap, "wsp:Attachment", -1, &a->wsp__PolicyAttachment::Attachment, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsp__PolicyAttachment::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wsp__PolicyAttachment(soap, tag, this, type);
}

SOAP_FMAC3 wsp__PolicyAttachment * SOAP_FMAC4 soap_in_wsp__PolicyAttachment(struct soap *soap, const char *tag, wsp__PolicyAttachment *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsp__PolicyAttachment *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsp__PolicyAttachment, sizeof(wsp__PolicyAttachment), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsp__PolicyAttachment)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsp__PolicyAttachment *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_AppliesTo1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AppliesTo1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsp__AppliesTo(soap, "wsp:AppliesTo", &a->wsp__PolicyAttachment::AppliesTo, "wsp:AppliesTo"))
				{	soap_flag_AppliesTo1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfwsp__Attachment(soap, "wsp:Attachment", &a->wsp__PolicyAttachment::Attachment, "wsp:Attachment"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wsp__PolicyAttachment *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsp__PolicyAttachment, SOAP_TYPE_wsp__PolicyAttachment, sizeof(wsp__PolicyAttachment), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsp__PolicyAttachment * SOAP_FMAC2 wsdl_instantiate_wsp__PolicyAttachment(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_wsp__PolicyAttachment(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsp__PolicyAttachment *p;
	size_t k = sizeof(wsp__PolicyAttachment);
	if (n < 0)
	{	p = SOAP_NEW(wsp__PolicyAttachment);
	}
	else
	{	p = SOAP_NEW_ARRAY(wsp__PolicyAttachment, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsp__PolicyAttachment location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_wsp__PolicyAttachment, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int wsp__PolicyAttachment::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsp__PolicyAttachment(soap, tag ? tag : "wsp:PolicyAttachment", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsp__PolicyAttachment::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsp__PolicyAttachment(soap, this, tag, type);
}

SOAP_FMAC3 wsp__PolicyAttachment * SOAP_FMAC4 soap_get_wsp__PolicyAttachment(struct soap *soap, wsp__PolicyAttachment *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsp__PolicyAttachment(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsp__AppliesTo::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->wsp__AppliesTo::__any = NULL;
}

void wsp__AppliesTo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int wsp__AppliesTo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsp__AppliesTo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsp__AppliesTo(struct soap *soap, const char *tag, int id, const wsp__AppliesTo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsp__AppliesTo), type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->wsp__AppliesTo::__any, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsp__AppliesTo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wsp__AppliesTo(soap, tag, this, type);
}

SOAP_FMAC3 wsp__AppliesTo * SOAP_FMAC4 soap_in_wsp__AppliesTo(struct soap *soap, const char *tag, wsp__AppliesTo *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsp__AppliesTo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsp__AppliesTo, sizeof(wsp__AppliesTo), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsp__AppliesTo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsp__AppliesTo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___any1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->wsp__AppliesTo::__any))
				{	soap_flag___any1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wsp__AppliesTo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsp__AppliesTo, SOAP_TYPE_wsp__AppliesTo, sizeof(wsp__AppliesTo), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsp__AppliesTo * SOAP_FMAC2 wsdl_instantiate_wsp__AppliesTo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_wsp__AppliesTo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsp__AppliesTo *p;
	size_t k = sizeof(wsp__AppliesTo);
	if (n < 0)
	{	p = SOAP_NEW(wsp__AppliesTo);
	}
	else
	{	p = SOAP_NEW_ARRAY(wsp__AppliesTo, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsp__AppliesTo location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_wsp__AppliesTo, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int wsp__AppliesTo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsp__AppliesTo(soap, tag ? tag : "wsp:AppliesTo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsp__AppliesTo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsp__AppliesTo(soap, this, tag, type);
}

SOAP_FMAC3 wsp__AppliesTo * SOAP_FMAC4 soap_get_wsp__AppliesTo(struct soap *soap, wsp__AppliesTo *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsp__AppliesTo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsp__Attachment::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->wsp__Attachment::Policy = NULL;
	this->wsp__Attachment::PolicyReference = NULL;
}

void wsp__Attachment::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowsp__Policy(soap, &this->wsp__Attachment::Policy);
	soap_serialize_PointerTowsp__PolicyReference(soap, &this->wsp__Attachment::PolicyReference);
#endif
}

int wsp__Attachment::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsp__Attachment(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsp__Attachment(struct soap *soap, const char *tag, int id, const wsp__Attachment *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsp__Attachment), type))
		return soap->error;
	if (soap_out_PointerTowsp__Policy(soap, "wsp:Policy", -1, &a->wsp__Attachment::Policy, ""))
		return soap->error;
	if (soap_out_PointerTowsp__PolicyReference(soap, "wsp:PolicyReference", -1, &a->wsp__Attachment::PolicyReference, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsp__Attachment::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wsp__Attachment(soap, tag, this, type);
}

SOAP_FMAC3 wsp__Attachment * SOAP_FMAC4 soap_in_wsp__Attachment(struct soap *soap, const char *tag, wsp__Attachment *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsp__Attachment *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsp__Attachment, sizeof(wsp__Attachment), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsp__Attachment)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsp__Attachment *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Policy1 = 1;
	size_t soap_flag_PolicyReference1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Policy1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsp__Policy(soap, "wsp:Policy", &a->wsp__Attachment::Policy, "wsp:Policy"))
				{	soap_flag_Policy1--;
					continue;
				}
			}
			if (soap_flag_PolicyReference1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsp__PolicyReference(soap, "wsp:PolicyReference", &a->wsp__Attachment::PolicyReference, "wsp:PolicyReference"))
				{	soap_flag_PolicyReference1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wsp__Attachment *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsp__Attachment, SOAP_TYPE_wsp__Attachment, sizeof(wsp__Attachment), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsp__Attachment * SOAP_FMAC2 wsdl_instantiate_wsp__Attachment(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_wsp__Attachment(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsp__Attachment *p;
	size_t k = sizeof(wsp__Attachment);
	if (n < 0)
	{	p = SOAP_NEW(wsp__Attachment);
	}
	else
	{	p = SOAP_NEW_ARRAY(wsp__Attachment, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsp__Attachment location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_wsp__Attachment, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int wsp__Attachment::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsp__Attachment(soap, tag ? tag : "wsp:Attachment", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsp__Attachment::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsp__Attachment(soap, this, tag, type);
}

SOAP_FMAC3 wsp__Attachment * SOAP_FMAC4 soap_get_wsp__Attachment(struct soap *soap, wsp__Attachment *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsp__Attachment(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsrmp5__RMAssertion::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->wsp__Assertion::soap_default(soap);
	this->wsrmp5__RMAssertion::InactivityTimeout = NULL;
	this->wsrmp5__RMAssertion::BaseRetransmissionInterval = NULL;
	this->wsrmp5__RMAssertion::AcknowledgementInterval = NULL;
	soap_default_string(soap, &this->wsrmp5__RMAssertion::ExponentialBackoff);
}

void wsrmp5__RMAssertion::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowsrmp5__Timeout(soap, &this->wsrmp5__RMAssertion::InactivityTimeout);
	soap_serialize_PointerTowsrmp5__Timeout(soap, &this->wsrmp5__RMAssertion::BaseRetransmissionInterval);
	soap_serialize_PointerTowsrmp5__Timeout(soap, &this->wsrmp5__RMAssertion::AcknowledgementInterval);
	soap_serialize_string(soap, (char*const*)&this->wsrmp5__RMAssertion::ExponentialBackoff);
	this->wsp__Assertion::soap_serialize(soap);
#endif
}

int wsrmp5__RMAssertion::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsrmp5__RMAssertion(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsrmp5__RMAssertion(struct soap *soap, const char *tag, int id, const wsrmp5__RMAssertion *a, const char *type)
{
	soap_set_attr(soap, "Optional", soap_bool2s(soap, ((wsp__Assertion*)a)->Optional), 1);
	soap_set_attr(soap, "Ignorable", soap_bool2s(soap, ((wsp__Assertion*)a)->Ignorable), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsrmp5__RMAssertion), type ? type : "wsrmp5:RMAssertion"))
		return soap->error;
	if (soap_out_PointerTowsp__Content(soap, "wsp:Policy", -1, &a->wsp__Assertion::Policy, ""))
		return soap->error;
	if (soap_out_PointerTowsrmp5__Timeout(soap, "wsrmp5:InactivityTimeout", -1, &a->wsrmp5__RMAssertion::InactivityTimeout, ""))
		return soap->error;
	if (soap_out_PointerTowsrmp5__Timeout(soap, "wsrmp5:BaseRetransmissionInterval", -1, &a->wsrmp5__RMAssertion::BaseRetransmissionInterval, ""))
		return soap->error;
	if (soap_out_PointerTowsrmp5__Timeout(soap, "wsrmp5:AcknowledgementInterval", -1, &a->wsrmp5__RMAssertion::AcknowledgementInterval, ""))
		return soap->error;
	if (soap_out_string(soap, "wsrmp5:ExponentialBackoff", -1, (char*const*)&a->wsrmp5__RMAssertion::ExponentialBackoff, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsrmp5__RMAssertion::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wsrmp5__RMAssertion(soap, tag, this, type);
}

SOAP_FMAC3 wsrmp5__RMAssertion * SOAP_FMAC4 soap_in_wsrmp5__RMAssertion(struct soap *soap, const char *tag, wsrmp5__RMAssertion *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsrmp5__RMAssertion *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsrmp5__RMAssertion, sizeof(wsrmp5__RMAssertion), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsrmp5__RMAssertion)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsrmp5__RMAssertion *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2bool(soap, soap_attr_value(soap, "Optional", 5, 0), &((wsp__Assertion*)a)->Optional))
		return NULL;
	if (soap_s2bool(soap, soap_attr_value(soap, "Ignorable", 5, 0), &((wsp__Assertion*)a)->Ignorable))
		return NULL;
	size_t soap_flag_Policy2 = 1;
	size_t soap_flag_InactivityTimeout1 = 1;
	size_t soap_flag_BaseRetransmissionInterval1 = 1;
	size_t soap_flag_AcknowledgementInterval1 = 1;
	size_t soap_flag_ExponentialBackoff1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Policy2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsp__Content(soap, "wsp:Policy", &a->wsp__Assertion::Policy, "wsp:Content"))
				{	soap_flag_Policy2--;
					continue;
				}
			}
			if (soap_flag_InactivityTimeout1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsrmp5__Timeout(soap, "wsrmp5:InactivityTimeout", &a->wsrmp5__RMAssertion::InactivityTimeout, "wsrmp5:Timeout"))
				{	soap_flag_InactivityTimeout1--;
					continue;
				}
			}
			if (soap_flag_BaseRetransmissionInterval1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsrmp5__Timeout(soap, "wsrmp5:BaseRetransmissionInterval", &a->wsrmp5__RMAssertion::BaseRetransmissionInterval, "wsrmp5:Timeout"))
				{	soap_flag_BaseRetransmissionInterval1--;
					continue;
				}
			}
			if (soap_flag_AcknowledgementInterval1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsrmp5__Timeout(soap, "wsrmp5:AcknowledgementInterval", &a->wsrmp5__RMAssertion::AcknowledgementInterval, "wsrmp5:Timeout"))
				{	soap_flag_AcknowledgementInterval1--;
					continue;
				}
			}
			if (soap_flag_ExponentialBackoff1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "wsrmp5:ExponentialBackoff", (char**)&a->wsrmp5__RMAssertion::ExponentialBackoff, "xsd:string"))
				{	soap_flag_ExponentialBackoff1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wsrmp5__RMAssertion *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsrmp5__RMAssertion, SOAP_TYPE_wsrmp5__RMAssertion, sizeof(wsrmp5__RMAssertion), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsrmp5__RMAssertion * SOAP_FMAC2 wsdl_instantiate_wsrmp5__RMAssertion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_wsrmp5__RMAssertion(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsrmp5__RMAssertion *p;
	size_t k = sizeof(wsrmp5__RMAssertion);
	if (n < 0)
	{	p = SOAP_NEW(wsrmp5__RMAssertion);
	}
	else
	{	p = SOAP_NEW_ARRAY(wsrmp5__RMAssertion, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsrmp5__RMAssertion location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_wsrmp5__RMAssertion, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int wsrmp5__RMAssertion::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsrmp5__RMAssertion(soap, tag ? tag : "wsrmp5:RMAssertion", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsrmp5__RMAssertion::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsrmp5__RMAssertion(soap, this, tag, type);
}

SOAP_FMAC3 wsrmp5__RMAssertion * SOAP_FMAC4 soap_get_wsrmp5__RMAssertion(struct soap *soap, wsrmp5__RMAssertion *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsrmp5__RMAssertion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsrmp5__Timeout::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_string(soap, &this->wsrmp5__Timeout::Milliseconds);
}

void wsrmp5__Timeout::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int wsrmp5__Timeout::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsrmp5__Timeout(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsrmp5__Timeout(struct soap *soap, const char *tag, int id, const wsrmp5__Timeout *a, const char *type)
{
	if (((wsrmp5__Timeout*)a)->Milliseconds)
		soap_set_attr(soap, "Milliseconds", soap_string2s(soap, ((wsrmp5__Timeout*)a)->Milliseconds), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsrmp5__Timeout), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsrmp5__Timeout::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wsrmp5__Timeout(soap, tag, this, type);
}

SOAP_FMAC3 wsrmp5__Timeout * SOAP_FMAC4 soap_in_wsrmp5__Timeout(struct soap *soap, const char *tag, wsrmp5__Timeout *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsrmp5__Timeout *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsrmp5__Timeout, sizeof(wsrmp5__Timeout), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsrmp5__Timeout)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsrmp5__Timeout *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2string(soap, soap_attr_value(soap, "Milliseconds", 1, 0), &((wsrmp5__Timeout*)a)->Milliseconds))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wsrmp5__Timeout *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsrmp5__Timeout, SOAP_TYPE_wsrmp5__Timeout, sizeof(wsrmp5__Timeout), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsrmp5__Timeout * SOAP_FMAC2 wsdl_instantiate_wsrmp5__Timeout(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_wsrmp5__Timeout(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsrmp5__Timeout *p;
	size_t k = sizeof(wsrmp5__Timeout);
	if (n < 0)
	{	p = SOAP_NEW(wsrmp5__Timeout);
	}
	else
	{	p = SOAP_NEW_ARRAY(wsrmp5__Timeout, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsrmp5__Timeout location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_wsrmp5__Timeout, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int wsrmp5__Timeout::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsrmp5__Timeout(soap, tag ? tag : "wsrmp5:Timeout", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsrmp5__Timeout::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsrmp5__Timeout(soap, this, tag, type);
}

SOAP_FMAC3 wsrmp5__Timeout * SOAP_FMAC4 soap_get_wsrmp5__Timeout(struct soap *soap, wsrmp5__Timeout *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsrmp5__Timeout(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsrmp__RMAssertion::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->wsp__Assertion::soap_default(soap);
	this->wsrmp__RMAssertion::InactivityTimeout = NULL;
	this->wsrmp__RMAssertion::BaseRetransmissionInterval = NULL;
	this->wsrmp__RMAssertion::AcknowledgementInterval = NULL;
	soap_default_string(soap, &this->wsrmp__RMAssertion::ExponentialBackoff);
}

void wsrmp__RMAssertion::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowsrmp__Timeout(soap, &this->wsrmp__RMAssertion::InactivityTimeout);
	soap_serialize_PointerTowsrmp__Timeout(soap, &this->wsrmp__RMAssertion::BaseRetransmissionInterval);
	soap_serialize_PointerTowsrmp__Timeout(soap, &this->wsrmp__RMAssertion::AcknowledgementInterval);
	soap_serialize_string(soap, (char*const*)&this->wsrmp__RMAssertion::ExponentialBackoff);
	this->wsp__Assertion::soap_serialize(soap);
#endif
}

int wsrmp__RMAssertion::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsrmp__RMAssertion(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsrmp__RMAssertion(struct soap *soap, const char *tag, int id, const wsrmp__RMAssertion *a, const char *type)
{
	soap_set_attr(soap, "Optional", soap_bool2s(soap, ((wsp__Assertion*)a)->Optional), 1);
	soap_set_attr(soap, "Ignorable", soap_bool2s(soap, ((wsp__Assertion*)a)->Ignorable), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsrmp__RMAssertion), type ? type : "wsrmp:RMAssertion"))
		return soap->error;
	if (soap_out_PointerTowsp__Content(soap, "wsp:Policy", -1, &a->wsp__Assertion::Policy, ""))
		return soap->error;
	if (soap_out_PointerTowsrmp__Timeout(soap, "wsrmp:InactivityTimeout", -1, &a->wsrmp__RMAssertion::InactivityTimeout, ""))
		return soap->error;
	if (soap_out_PointerTowsrmp__Timeout(soap, "wsrmp:BaseRetransmissionInterval", -1, &a->wsrmp__RMAssertion::BaseRetransmissionInterval, ""))
		return soap->error;
	if (soap_out_PointerTowsrmp__Timeout(soap, "wsrmp:AcknowledgementInterval", -1, &a->wsrmp__RMAssertion::AcknowledgementInterval, ""))
		return soap->error;
	if (soap_out_string(soap, "wsrmp:ExponentialBackoff", -1, (char*const*)&a->wsrmp__RMAssertion::ExponentialBackoff, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsrmp__RMAssertion::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wsrmp__RMAssertion(soap, tag, this, type);
}

SOAP_FMAC3 wsrmp__RMAssertion * SOAP_FMAC4 soap_in_wsrmp__RMAssertion(struct soap *soap, const char *tag, wsrmp__RMAssertion *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsrmp__RMAssertion *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsrmp__RMAssertion, sizeof(wsrmp__RMAssertion), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsrmp__RMAssertion)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsrmp__RMAssertion *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2bool(soap, soap_attr_value(soap, "Optional", 5, 0), &((wsp__Assertion*)a)->Optional))
		return NULL;
	if (soap_s2bool(soap, soap_attr_value(soap, "Ignorable", 5, 0), &((wsp__Assertion*)a)->Ignorable))
		return NULL;
	size_t soap_flag_Policy2 = 1;
	size_t soap_flag_InactivityTimeout1 = 1;
	size_t soap_flag_BaseRetransmissionInterval1 = 1;
	size_t soap_flag_AcknowledgementInterval1 = 1;
	size_t soap_flag_ExponentialBackoff1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Policy2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsp__Content(soap, "wsp:Policy", &a->wsp__Assertion::Policy, "wsp:Content"))
				{	soap_flag_Policy2--;
					continue;
				}
			}
			if (soap_flag_InactivityTimeout1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsrmp__Timeout(soap, "wsrmp:InactivityTimeout", &a->wsrmp__RMAssertion::InactivityTimeout, "wsrmp:Timeout"))
				{	soap_flag_InactivityTimeout1--;
					continue;
				}
			}
			if (soap_flag_BaseRetransmissionInterval1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsrmp__Timeout(soap, "wsrmp:BaseRetransmissionInterval", &a->wsrmp__RMAssertion::BaseRetransmissionInterval, "wsrmp:Timeout"))
				{	soap_flag_BaseRetransmissionInterval1--;
					continue;
				}
			}
			if (soap_flag_AcknowledgementInterval1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsrmp__Timeout(soap, "wsrmp:AcknowledgementInterval", &a->wsrmp__RMAssertion::AcknowledgementInterval, "wsrmp:Timeout"))
				{	soap_flag_AcknowledgementInterval1--;
					continue;
				}
			}
			if (soap_flag_ExponentialBackoff1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "wsrmp:ExponentialBackoff", (char**)&a->wsrmp__RMAssertion::ExponentialBackoff, "xsd:string"))
				{	soap_flag_ExponentialBackoff1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wsrmp__RMAssertion *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsrmp__RMAssertion, SOAP_TYPE_wsrmp__RMAssertion, sizeof(wsrmp__RMAssertion), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsrmp__RMAssertion * SOAP_FMAC2 wsdl_instantiate_wsrmp__RMAssertion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_wsrmp__RMAssertion(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsrmp__RMAssertion *p;
	size_t k = sizeof(wsrmp__RMAssertion);
	if (n < 0)
	{	p = SOAP_NEW(wsrmp__RMAssertion);
	}
	else
	{	p = SOAP_NEW_ARRAY(wsrmp__RMAssertion, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsrmp__RMAssertion location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_wsrmp__RMAssertion, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int wsrmp__RMAssertion::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsrmp__RMAssertion(soap, tag ? tag : "wsrmp:RMAssertion", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsrmp__RMAssertion::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsrmp__RMAssertion(soap, this, tag, type);
}

SOAP_FMAC3 wsrmp__RMAssertion * SOAP_FMAC4 soap_get_wsrmp__RMAssertion(struct soap *soap, wsrmp__RMAssertion *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsrmp__RMAssertion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsrmp__Timeout::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_string(soap, &this->wsrmp__Timeout::Milliseconds);
}

void wsrmp__Timeout::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int wsrmp__Timeout::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsrmp__Timeout(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsrmp__Timeout(struct soap *soap, const char *tag, int id, const wsrmp__Timeout *a, const char *type)
{
	if (((wsrmp__Timeout*)a)->Milliseconds)
		soap_set_attr(soap, "Milliseconds", soap_string2s(soap, ((wsrmp__Timeout*)a)->Milliseconds), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsrmp__Timeout), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsrmp__Timeout::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wsrmp__Timeout(soap, tag, this, type);
}

SOAP_FMAC3 wsrmp__Timeout * SOAP_FMAC4 soap_in_wsrmp__Timeout(struct soap *soap, const char *tag, wsrmp__Timeout *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsrmp__Timeout *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsrmp__Timeout, sizeof(wsrmp__Timeout), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsrmp__Timeout)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsrmp__Timeout *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2string(soap, soap_attr_value(soap, "Milliseconds", 1, 0), &((wsrmp__Timeout*)a)->Milliseconds))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wsrmp__Timeout *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsrmp__Timeout, SOAP_TYPE_wsrmp__Timeout, sizeof(wsrmp__Timeout), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsrmp__Timeout * SOAP_FMAC2 wsdl_instantiate_wsrmp__Timeout(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_wsrmp__Timeout(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsrmp__Timeout *p;
	size_t k = sizeof(wsrmp__Timeout);
	if (n < 0)
	{	p = SOAP_NEW(wsrmp__Timeout);
	}
	else
	{	p = SOAP_NEW_ARRAY(wsrmp__Timeout, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsrmp__Timeout location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_wsrmp__Timeout, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int wsrmp__Timeout::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsrmp__Timeout(soap, tag ? tag : "wsrmp:Timeout", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsrmp__Timeout::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsrmp__Timeout(soap, this, tag, type);
}

SOAP_FMAC3 wsrmp__Timeout * SOAP_FMAC4 soap_get_wsrmp__Timeout(struct soap *soap, wsrmp__Timeout *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsrmp__Timeout(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void sp__Token::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->wsp__Assertion::soap_default(soap);
	soap_default_xsd__anyURI(soap, &this->sp__Token::IncludeToken);
	this->sp__Token::Issuer = NULL;
	soap_default_xsd__anyURI(soap, &this->sp__Token::IssuerName);
	this->sp__Token::wst__Claims_ = NULL;
}

void sp__Token::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowsa__EndpointReferenceType(soap, &this->sp__Token::Issuer);
	soap_serialize_xsd__anyURI(soap, (char*const*)&this->sp__Token::IssuerName);
	soap_serialize_PointerTowst__Claims(soap, &this->sp__Token::wst__Claims_);
	this->wsp__Assertion::soap_serialize(soap);
#endif
}

int sp__Token::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_sp__Token(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_sp__Token(struct soap *soap, const char *tag, int id, const sp__Token *a, const char *type)
{
	if (((sp__Token*)a)->IncludeToken)
		soap_set_attr(soap, "IncludeToken", soap_xsd__anyURI2s(soap, ((sp__Token*)a)->IncludeToken), 1);
	soap_set_attr(soap, "Optional", soap_bool2s(soap, ((wsp__Assertion*)a)->Optional), 1);
	soap_set_attr(soap, "Ignorable", soap_bool2s(soap, ((wsp__Assertion*)a)->Ignorable), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sp__Token), type ? type : "sp:Token"))
		return soap->error;
	if (soap_out_PointerTowsp__Content(soap, "wsp:Policy", -1, &a->wsp__Assertion::Policy, ""))
		return soap->error;
	if (soap_out_PointerTowsa__EndpointReferenceType(soap, "sp:Issuer", -1, &a->sp__Token::Issuer, ""))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "sp:IssuerName", -1, (char*const*)&a->sp__Token::IssuerName, ""))
		return soap->error;
	if (soap_out_PointerTowst__Claims(soap, "wst:Claims", -1, &a->sp__Token::wst__Claims_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *sp__Token::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_sp__Token(soap, tag, this, type);
}

SOAP_FMAC3 sp__Token * SOAP_FMAC4 soap_in_sp__Token(struct soap *soap, const char *tag, sp__Token *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (sp__Token *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sp__Token, sizeof(sp__Token), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_sp__Token)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (sp__Token *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "IncludeToken", 4, 0), &((sp__Token*)a)->IncludeToken))
		return NULL;
	if (soap_s2bool(soap, soap_attr_value(soap, "Optional", 5, 0), &((wsp__Assertion*)a)->Optional))
		return NULL;
	if (soap_s2bool(soap, soap_attr_value(soap, "Ignorable", 5, 0), &((wsp__Assertion*)a)->Ignorable))
		return NULL;
	size_t soap_flag_Policy2 = 1;
	size_t soap_flag_Issuer1 = 1;
	size_t soap_flag_IssuerName1 = 1;
	size_t soap_flag_wst__Claims_1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Policy2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsp__Content(soap, "wsp:Policy", &a->wsp__Assertion::Policy, "wsp:Content"))
				{	soap_flag_Policy2--;
					continue;
				}
			}
			if (soap_flag_Issuer1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa__EndpointReferenceType(soap, "sp:Issuer", &a->sp__Token::Issuer, "wsa:EndpointReferenceType"))
				{	soap_flag_Issuer1--;
					continue;
				}
			}
			if (soap_flag_IssuerName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "sp:IssuerName", (char**)&a->sp__Token::IssuerName, "xsd:anyURI"))
				{	soap_flag_IssuerName1--;
					continue;
				}
			}
			if (soap_flag_wst__Claims_1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowst__Claims(soap, "wst:Claims", &a->sp__Token::wst__Claims_, "wst:Claims"))
				{	soap_flag_wst__Claims_1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (sp__Token *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_sp__Token, SOAP_TYPE_sp__Token, sizeof(sp__Token), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 sp__Token * SOAP_FMAC2 wsdl_instantiate_sp__Token(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_sp__Token(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	sp__Token *p;
	size_t k = sizeof(sp__Token);
	if (n < 0)
	{	p = SOAP_NEW(sp__Token);
	}
	else
	{	p = SOAP_NEW_ARRAY(sp__Token, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated sp__Token location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_sp__Token, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int sp__Token::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_sp__Token(soap, tag ? tag : "sp:Token", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *sp__Token::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_sp__Token(soap, this, tag, type);
}

SOAP_FMAC3 sp__Token * SOAP_FMAC4 soap_get_sp__Token(struct soap *soap, sp__Token *p, const char *tag, const char *type)
{
	if ((p = soap_in_sp__Token(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void sp__Elements::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &this->sp__Elements::XPathVersion);
	soap_default_std__vectorTemplateOfxsd__string(soap, &this->sp__Elements::XPath);
}

void sp__Elements::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__string(soap, &this->sp__Elements::XPath);
#endif
}

int sp__Elements::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_sp__Elements(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_sp__Elements(struct soap *soap, const char *tag, int id, const sp__Elements *a, const char *type)
{
	if (((sp__Elements*)a)->XPathVersion)
		soap_set_attr(soap, "XPathVersion", soap_xsd__anyURI2s(soap, ((sp__Elements*)a)->XPathVersion), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sp__Elements), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__string(soap, "sp:XPath", -1, &a->sp__Elements::XPath, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *sp__Elements::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_sp__Elements(soap, tag, this, type);
}

SOAP_FMAC3 sp__Elements * SOAP_FMAC4 soap_in_sp__Elements(struct soap *soap, const char *tag, sp__Elements *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (sp__Elements *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sp__Elements, sizeof(sp__Elements), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_sp__Elements)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (sp__Elements *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "XPathVersion", 4, 0), &((sp__Elements*)a)->XPathVersion))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__string(soap, "sp:XPath", &a->sp__Elements::XPath, "xsd:string"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (sp__Elements *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_sp__Elements, SOAP_TYPE_sp__Elements, sizeof(sp__Elements), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 sp__Elements * SOAP_FMAC2 wsdl_instantiate_sp__Elements(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_sp__Elements(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	sp__Elements *p;
	size_t k = sizeof(sp__Elements);
	if (n < 0)
	{	p = SOAP_NEW(sp__Elements);
	}
	else
	{	p = SOAP_NEW_ARRAY(sp__Elements, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated sp__Elements location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_sp__Elements, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int sp__Elements::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_sp__Elements(soap, tag ? tag : "sp:Elements", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *sp__Elements::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_sp__Elements(soap, this, tag, type);
}

SOAP_FMAC3 sp__Elements * SOAP_FMAC4 soap_get_sp__Elements(struct soap *soap, sp__Elements *p, const char *tag, const char *type)
{
	if ((p = soap_in_sp__Elements(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void sp__Parts::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &this->sp__Parts::Body);
	soap_default_std__vectorTemplateOfsp__Header(soap, &this->sp__Parts::Header);
	soap_default_xsd__string(soap, &this->sp__Parts::Attachments);
}

void sp__Parts::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__string(soap, (char*const*)&this->sp__Parts::Body);
	soap_serialize_std__vectorTemplateOfsp__Header(soap, &this->sp__Parts::Header);
	soap_serialize_xsd__string(soap, (char*const*)&this->sp__Parts::Attachments);
#endif
}

int sp__Parts::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_sp__Parts(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_sp__Parts(struct soap *soap, const char *tag, int id, const sp__Parts *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sp__Parts), type))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:Body", -1, (char*const*)&a->sp__Parts::Body, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfsp__Header(soap, "sp:Header", -1, &a->sp__Parts::Header, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:Attachments", -1, (char*const*)&a->sp__Parts::Attachments, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *sp__Parts::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_sp__Parts(soap, tag, this, type);
}

SOAP_FMAC3 sp__Parts * SOAP_FMAC4 soap_in_sp__Parts(struct soap *soap, const char *tag, sp__Parts *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (sp__Parts *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sp__Parts, sizeof(sp__Parts), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_sp__Parts)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (sp__Parts *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Body1 = 1;
	size_t soap_flag_Attachments1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Body1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:Body", (char**)&a->sp__Parts::Body, "xsd:string"))
				{	soap_flag_Body1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfsp__Header(soap, "sp:Header", &a->sp__Parts::Header, "sp:Header"))
					continue;
			}
			if (soap_flag_Attachments1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:Attachments", (char**)&a->sp__Parts::Attachments, "xsd:string"))
				{	soap_flag_Attachments1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (sp__Parts *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_sp__Parts, SOAP_TYPE_sp__Parts, sizeof(sp__Parts), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 sp__Parts * SOAP_FMAC2 wsdl_instantiate_sp__Parts(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_sp__Parts(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	sp__Parts *p;
	size_t k = sizeof(sp__Parts);
	if (n < 0)
	{	p = SOAP_NEW(sp__Parts);
	}
	else
	{	p = SOAP_NEW_ARRAY(sp__Parts, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated sp__Parts location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_sp__Parts, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int sp__Parts::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_sp__Parts(soap, tag ? tag : "sp:Parts", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *sp__Parts::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_sp__Parts(soap, this, tag, type);
}

SOAP_FMAC3 sp__Parts * SOAP_FMAC4 soap_get_sp__Parts(struct soap *soap, sp__Parts *p, const char *tag, const char *type)
{
	if ((p = soap_in_sp__Parts(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void sp__Header::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__NCName(soap, &this->sp__Header::Name);
	soap_default_xsd__anyURI(soap, &this->sp__Header::Namespace);
}

void sp__Header::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int sp__Header::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_sp__Header(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_sp__Header(struct soap *soap, const char *tag, int id, const sp__Header *a, const char *type)
{
	if (((sp__Header*)a)->Name)
		soap_set_attr(soap, "Name", soap_xsd__NCName2s(soap, ((sp__Header*)a)->Name), 1);
	if (((sp__Header*)a)->Namespace)
		soap_set_attr(soap, "Namespace", soap_xsd__anyURI2s(soap, ((sp__Header*)a)->Namespace), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sp__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *sp__Header::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_sp__Header(soap, tag, this, type);
}

SOAP_FMAC3 sp__Header * SOAP_FMAC4 soap_in_sp__Header(struct soap *soap, const char *tag, sp__Header *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (sp__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sp__Header, sizeof(sp__Header), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_sp__Header)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (sp__Header *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__NCName(soap, soap_attr_value(soap, "Name", 5, 0), &((sp__Header*)a)->Name))
		return NULL;
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "Namespace", 4, 0), &((sp__Header*)a)->Namespace))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (sp__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_sp__Header, SOAP_TYPE_sp__Header, sizeof(sp__Header), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 sp__Header * SOAP_FMAC2 wsdl_instantiate_sp__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_sp__Header(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	sp__Header *p;
	size_t k = sizeof(sp__Header);
	if (n < 0)
	{	p = SOAP_NEW(sp__Header);
	}
	else
	{	p = SOAP_NEW_ARRAY(sp__Header, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated sp__Header location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_sp__Header, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int sp__Header::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_sp__Header(soap, tag ? tag : "sp:Header", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *sp__Header::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_sp__Header(soap, this, tag, type);
}

SOAP_FMAC3 sp__Header * SOAP_FMAC4 soap_get_sp__Header(struct soap *soap, sp__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_sp__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wst__Claims::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &this->wst__Claims::Dialect);
	soap_default_xsd__string(soap, &this->wst__Claims::__item);
}

void wst__Claims::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__string(soap, (char*const*)&this->wst__Claims::__item);
#endif
}

int wst__Claims::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wst__Claims(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wst__Claims(struct soap *soap, const char *tag, int id, const wst__Claims *a, const char *type)
{
	if (((wst__Claims*)a)->Dialect)
		soap_set_attr(soap, "Dialect", soap_xsd__string2s(soap, ((wst__Claims*)a)->Dialect), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_xsd__string(soap, tag, id, (char*const*)&a->wst__Claims::__item, "");
}

void *wst__Claims::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wst__Claims(soap, tag, this, type);
}

SOAP_FMAC3 wst__Claims * SOAP_FMAC4 soap_in_wst__Claims(struct soap *soap, const char *tag, wst__Claims *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (wst__Claims *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wst__Claims, sizeof(wst__Claims), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_wst__Claims)
		return (wst__Claims *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__string(soap, soap_attr_value(soap, "Dialect", 1, 0), &((wst__Claims*)a)->Dialect))
		return NULL;
	if (!soap_in_xsd__string(soap, tag, (char**)&a->wst__Claims::__item, "wst:Claims"))
		return NULL;
	return a;
}

SOAP_FMAC1 wst__Claims * SOAP_FMAC2 wsdl_instantiate_wst__Claims(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_wst__Claims(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wst__Claims *p;
	size_t k = sizeof(wst__Claims);
	if (n < 0)
	{	p = SOAP_NEW(wst__Claims);
	}
	else
	{	p = SOAP_NEW_ARRAY(wst__Claims, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wst__Claims location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_wst__Claims, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int wst__Claims::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wst__Claims(soap, tag ? tag : "wst:Claims", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wst__Claims::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wst__Claims(soap, this, tag, type);
}

SOAP_FMAC3 wst__Claims * SOAP_FMAC4 soap_get_wst__Claims(struct soap *soap, wst__Claims *p, const char *tag, const char *type)
{
	if ((p = soap_in_wst__Claims(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsp__Assertion::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->wsp__Assertion::Optional = (bool)0;
	this->wsp__Assertion::Ignorable = (bool)0;
	this->wsp__Assertion::Policy = NULL;
}

void wsp__Assertion::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowsp__Content(soap, &this->wsp__Assertion::Policy);
#endif
}

int wsp__Assertion::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsp__Assertion(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsp__Assertion(struct soap *soap, const char *tag, int id, const wsp__Assertion *a, const char *type)
{
	soap_set_attr(soap, "Optional", soap_bool2s(soap, ((wsp__Assertion*)a)->Optional), 1);
	soap_set_attr(soap, "Ignorable", soap_bool2s(soap, ((wsp__Assertion*)a)->Ignorable), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsp__Assertion), type))
		return soap->error;
	if (soap_out_PointerTowsp__Content(soap, "wsp:Policy", -1, &a->wsp__Assertion::Policy, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsp__Assertion::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wsp__Assertion(soap, tag, this, type);
}

SOAP_FMAC3 wsp__Assertion * SOAP_FMAC4 soap_in_wsp__Assertion(struct soap *soap, const char *tag, wsp__Assertion *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsp__Assertion *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsp__Assertion, sizeof(wsp__Assertion), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsp__Assertion)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsp__Assertion *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2bool(soap, soap_attr_value(soap, "Optional", 5, 0), &((wsp__Assertion*)a)->Optional))
		return NULL;
	if (soap_s2bool(soap, soap_attr_value(soap, "Ignorable", 5, 0), &((wsp__Assertion*)a)->Ignorable))
		return NULL;
	size_t soap_flag_Policy1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Policy1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsp__Content(soap, "wsp:Policy", &a->wsp__Assertion::Policy, "wsp:Content"))
				{	soap_flag_Policy1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wsp__Assertion *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsp__Assertion, SOAP_TYPE_wsp__Assertion, sizeof(wsp__Assertion), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsp__Assertion * SOAP_FMAC2 wsdl_instantiate_wsp__Assertion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_wsp__Assertion(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (soap && type && !soap_match_tag(soap, type, "sp:Token"))
		return wsdl_instantiate_sp__Token(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsrmp:RMAssertion"))
		return wsdl_instantiate_wsrmp__RMAssertion(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsrmp5:RMAssertion"))
		return wsdl_instantiate_wsrmp5__RMAssertion(soap, n, NULL, NULL, size);
	wsp__Assertion *p;
	size_t k = sizeof(wsp__Assertion);
	if (n < 0)
	{	p = SOAP_NEW(wsp__Assertion);
	}
	else
	{	p = SOAP_NEW_ARRAY(wsp__Assertion, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsp__Assertion location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_wsp__Assertion, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int wsp__Assertion::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsp__Assertion(soap, tag ? tag : "wsp:Assertion", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsp__Assertion::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsp__Assertion(soap, this, tag, type);
}

SOAP_FMAC3 wsp__Assertion * SOAP_FMAC4 soap_get_wsp__Assertion(struct soap *soap, wsp__Assertion *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsp__Assertion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsp__PolicyReference::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &this->wsp__PolicyReference::URI);
	soap_default_xsd__string(soap, &this->wsp__PolicyReference::Digest);
	soap_default_xsd__anyURI(soap, &this->wsp__PolicyReference::DigestAlgorithm);
	this->wsp__PolicyReference::policyRef = NULL;
}

void wsp__PolicyReference::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	/* non-serializable policyRef skipped */
#endif
}

int wsp__PolicyReference::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsp__PolicyReference(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsp__PolicyReference(struct soap *soap, const char *tag, int id, const wsp__PolicyReference *a, const char *type)
{
	if (((wsp__PolicyReference*)a)->URI)
		soap_set_attr(soap, "URI", soap_xsd__anyURI2s(soap, ((wsp__PolicyReference*)a)->URI), 1);
	if (((wsp__PolicyReference*)a)->Digest)
		soap_set_attr(soap, "Digest", soap_xsd__string2s(soap, ((wsp__PolicyReference*)a)->Digest), 1);
	if (((wsp__PolicyReference*)a)->DigestAlgorithm)
		soap_set_attr(soap, "DigestAlgorithm", soap_xsd__anyURI2s(soap, ((wsp__PolicyReference*)a)->DigestAlgorithm), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsp__PolicyReference), type))
		return soap->error;
	/* non-serializable policyRef skipped */
	return soap_element_end_out(soap, tag);
}

void *wsp__PolicyReference::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wsp__PolicyReference(soap, tag, this, type);
}

SOAP_FMAC3 wsp__PolicyReference * SOAP_FMAC4 soap_in_wsp__PolicyReference(struct soap *soap, const char *tag, wsp__PolicyReference *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsp__PolicyReference *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsp__PolicyReference, sizeof(wsp__PolicyReference), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsp__PolicyReference)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsp__PolicyReference *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "URI", 4, 0), &((wsp__PolicyReference*)a)->URI))
		return NULL;
	if (soap_s2xsd__string(soap, soap_attr_value(soap, "Digest", 1, 0), &((wsp__PolicyReference*)a)->Digest))
		return NULL;
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "DigestAlgorithm", 4, 0), &((wsp__PolicyReference*)a)->DigestAlgorithm))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* non-serializable policyRef skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wsp__PolicyReference *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsp__PolicyReference, SOAP_TYPE_wsp__PolicyReference, sizeof(wsp__PolicyReference), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsp__PolicyReference * SOAP_FMAC2 wsdl_instantiate_wsp__PolicyReference(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_wsp__PolicyReference(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsp__PolicyReference *p;
	size_t k = sizeof(wsp__PolicyReference);
	if (n < 0)
	{	p = SOAP_NEW(wsp__PolicyReference);
	}
	else
	{	p = SOAP_NEW_ARRAY(wsp__PolicyReference, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsp__PolicyReference location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_wsp__PolicyReference, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int wsp__PolicyReference::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsp__PolicyReference(soap, tag ? tag : "wsp:PolicyReference", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsp__PolicyReference::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsp__PolicyReference(soap, this, tag, type);
}

SOAP_FMAC3 wsp__PolicyReference * SOAP_FMAC4 soap_get_wsp__PolicyReference(struct soap *soap, wsp__PolicyReference *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsp__PolicyReference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsp__Content::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->wsp__Content::Policy = NULL;
	this->wsp__Content::PolicyReference = NULL;
	soap_default_std__vectorTemplateOfPointerTowsp__Content(soap, &this->wsp__Content::All);
	soap_default_std__vectorTemplateOfPointerTowsp__Content(soap, &this->wsp__Content::ExactlyOne);
	soap_default_std__vectorTemplateOfsp__Parts(soap, &this->wsp__Content::sp__SignedParts);
	soap_default_std__vectorTemplateOfsp__Parts(soap, &this->wsp__Content::sp__EncryptedParts);
	soap_default_std__vectorTemplateOfsp__Parts(soap, &this->wsp__Content::sp__RequiredParts);
	this->wsp__Content::sp__SignedElements = NULL;
	this->wsp__Content::sp__EncryptedElements = NULL;
	this->wsp__Content::sp__ContentEncryptedElements = NULL;
	this->wsp__Content::sp__RequiredElements = NULL;
	this->wsp__Content::sp__UsernameToken = NULL;
	this->wsp__Content::sp__IssuedToken = NULL;
	this->wsp__Content::sp__X509Token = NULL;
	this->wsp__Content::sp__KerberosToken = NULL;
	this->wsp__Content::sp__SpnegoContextToken = NULL;
	this->wsp__Content::sp__SecurityContextToken = NULL;
	this->wsp__Content::sp__SecureConversationToken = NULL;
	this->wsp__Content::sp__SamlToken = NULL;
	this->wsp__Content::sp__RelToken = NULL;
	this->wsp__Content::sp__HttpsToken = NULL;
	this->wsp__Content::sp__KeyValueToken = NULL;
	this->wsp__Content::sp__TransportBinding = NULL;
	this->wsp__Content::sp__TransportToken = NULL;
	this->wsp__Content::sp__AlgorithmSuite = NULL;
	this->wsp__Content::sp__Layout = NULL;
	this->wsp__Content::sp__SymmetricBinding = NULL;
	this->wsp__Content::sp__AsymmetricBinding = NULL;
	this->wsp__Content::sp__ProtectionToken = NULL;
	this->wsp__Content::sp__InitiatorToken = NULL;
	this->wsp__Content::sp__InitiatorSignatureToken = NULL;
	this->wsp__Content::sp__InitiatorEncryptionToken = NULL;
	this->wsp__Content::sp__RecipientToken = NULL;
	this->wsp__Content::sp__SupportingTokens = NULL;
	this->wsp__Content::sp__SignedSupportingTokens = NULL;
	this->wsp__Content::sp__EndorsingSupportingTokens = NULL;
	this->wsp__Content::sp__SignedEndorsingSupportingTokens = NULL;
	this->wsp__Content::sp__SignedEncryptedSupportingTokens = NULL;
	this->wsp__Content::sp__EncryptedSupportingTokens = NULL;
	this->wsp__Content::sp__EndorsingEncryptedSupportingTokens = NULL;
	this->wsp__Content::sp__SignedEndorsingEncryptedSupportingTokens = NULL;
	this->wsp__Content::sp__Wss10 = NULL;
	this->wsp__Content::sp__Wss11 = NULL;
	this->wsp__Content::sp__Trust10 = NULL;
	this->wsp__Content::sp__Trust13 = NULL;
	this->wsp__Content::sp__BootstrapPolicy = NULL;
	soap_default_xsd__string(soap, &this->wsp__Content::wsaw__UsingAddressing);
	this->wsp__Content::wsam__Addressing = NULL;
	this->wsp__Content::wsrmp__RMAssertion_ = NULL;
	this->wsp__Content::wsrmp__DeliveryAssurance = NULL;
	soap_default_xsd__string(soap, &this->wsp__Content::wsrmp__AtLeastOnce);
	soap_default_xsd__string(soap, &this->wsp__Content::wsrmp__AtMostOnce);
	soap_default_xsd__string(soap, &this->wsp__Content::wsrmp__ExactlyOnce);
	soap_default_xsd__string(soap, &this->wsp__Content::wsrmp__InOrder);
	this->wsp__Content::wsrmp5__RMAssertion_ = NULL;
	this->wsp__Content::wsrmp5__DeliveryAssurance = NULL;
	soap_default_xsd__string(soap, &this->wsp__Content::wsrmp5__AtLeastOnce);
	soap_default_xsd__string(soap, &this->wsp__Content::wsrmp5__AtMostOnce);
	soap_default_xsd__string(soap, &this->wsp__Content::wsrmp5__ExactlyOnce);
	soap_default_xsd__string(soap, &this->wsp__Content::wsrmp5__InOrder);
	this->wsp__Content::sp__NoPassword = NULL;
	this->wsp__Content::sp__HashPassword = NULL;
	this->wsp__Content::sp__IncludeTimestamp = NULL;
	this->wsp__Content::sp__EncryptBeforeSigning = NULL;
	this->wsp__Content::sp__EncryptSignature = NULL;
	this->wsp__Content::sp__ProtectTokens = NULL;
	this->wsp__Content::sp__OnlySignEntireHeadersAndBody = NULL;
	soap_default_xsd__string(soap, &this->wsp__Content::sp__RequireDerivedKeys);
	soap_default_xsd__string(soap, &this->wsp__Content::sp__RequireImpliedDerivedKeys);
	soap_default_xsd__string(soap, &this->wsp__Content::sp__RequireExplicitDerivedKeys);
	soap_default_xsd__string(soap, &this->wsp__Content::sp__WssUsernameToken10);
	soap_default_xsd__string(soap, &this->wsp__Content::sp__WssUsernameToken11);
	soap_default_xsd__string(soap, &this->wsp__Content::sp__RequireExternalReference);
	soap_default_xsd__string(soap, &this->wsp__Content::sp__RequireInternalReference);
	soap_default_xsd__string(soap, &this->wsp__Content::sp__RequireKeyIdentifierReference);
	soap_default_xsd__string(soap, &this->wsp__Content::sp__RequireIssuerSerialReference);
	soap_default_xsd__string(soap, &this->wsp__Content::sp__RequireEmbeddedTokenReference);
	soap_default_xsd__string(soap, &this->wsp__Content::sp__RequireThumbprintReference);
	soap_default_xsd__string(soap, &this->wsp__Content::sp__WssX509V3Token10);
	soap_default_xsd__string(soap, &this->wsp__Content::sp__WssX509Pkcs7Token10);
	soap_default_xsd__string(soap, &this->wsp__Content::sp__WssX509PkiPathV1Token10);
	soap_default_xsd__string(soap, &this->wsp__Content::sp__WssX509V1Token11);
	soap_default_xsd__string(soap, &this->wsp__Content::sp__WssX509V3Token11);
	soap_default_xsd__string(soap, &this->wsp__Content::sp__WssX509Pkcs7Token11);
	soap_default_xsd__string(soap, &this->wsp__Content::sp__WssX509PkiPathV1Token11);
	soap_default_xsd__string(soap, &this->wsp__Content::sp__WssKerberosV5ApReqToken11);
	soap_default_xsd__string(soap, &this->wsp__Content::sp__WssGssKerberosV5ApReqToken11);
	soap_default_xsd__string(soap, &this->wsp__Content::sp__WssRelV10Token10);
	soap_default_xsd__string(soap, &this->wsp__Content::sp__WssRelV20Token10);
	soap_default_xsd__string(soap, &this->wsp__Content::sp__WssRelV10Token11);
	soap_default_xsd__string(soap, &this->wsp__Content::sp__WssRelV20Token11);
	soap_default_xsd__string(soap, &this->wsp__Content::sp__MustNotSendCancel);
	soap_default_xsd__string(soap, &this->wsp__Content::sp__MustNotSendAmend);
	soap_default_xsd__string(soap, &this->wsp__Content::sp__MustNotSendRenew);
	soap_default_xsd__string(soap, &this->wsp__Content::sp__MustSupportRefKeyIdentifier);
	soap_default_xsd__string(soap, &this->wsp__Content::sp__MustSupportRefIssuerSerial);
	soap_default_xsd__string(soap, &this->wsp__Content::sp__MustSupportRefExternalURI);
	soap_default_xsd__string(soap, &this->wsp__Content::sp__MustSupportRefEmbeddedToken);
	soap_default_xsd__string(soap, &this->wsp__Content::sp__MustSupportRefThumbprint);
	soap_default_xsd__string(soap, &this->wsp__Content::sp__MustSupportRefEncryptedKey);
	soap_default_xsd__string(soap, &this->wsp__Content::sp__RequireSignatureConfirmation);
	soap_default_xsd__string(soap, &this->wsp__Content::sp__MustSupportClientChallenge);
	soap_default_xsd__string(soap, &this->wsp__Content::sp__MustSupportServerChallenge);
	soap_default_xsd__string(soap, &this->wsp__Content::sp__RequireClientEntropy);
	soap_default_xsd__string(soap, &this->wsp__Content::sp__RequireServerEntropy);
	soap_default_xsd__string(soap, &this->wsp__Content::sp__MustSupportIssuedTokens);
	soap_default_xsd__string(soap, &this->wsp__Content::sp__RequireRequestSecurityTokenCollection);
	soap_default_xsd__string(soap, &this->wsp__Content::sp__RequireAppliesTo);
	soap_default_xsd__string(soap, &this->wsp__Content::sp__RequireExternalUriReference);
	soap_default_xsd__string(soap, &this->wsp__Content::sp__SC13SecurityContextToken);
	soap_default_xsd__string(soap, &this->wsp__Content::sp__Strict);
	soap_default_xsd__string(soap, &this->wsp__Content::sp__Lax);
	soap_default_xsd__string(soap, &this->wsp__Content::sp__LaxTsFirst);
	soap_default_xsd__string(soap, &this->wsp__Content::sp__LaxTsLast);
	soap_default_xsd__string(soap, &this->wsp__Content::sp__HttpBasicAuthentication);
	soap_default_xsd__string(soap, &this->wsp__Content::sp__HttpDigestAuthentication);
	soap_default_xsd__string(soap, &this->wsp__Content::sp__RequireClientCertificate);
	soap_default_xsd__string(soap, &this->wsp__Content::sp__Basic256);
	soap_default_xsd__string(soap, &this->wsp__Content::sp__Basic192);
	soap_default_xsd__string(soap, &this->wsp__Content::sp__Basic128);
	soap_default_xsd__string(soap, &this->wsp__Content::sp__TripleDes);
	soap_default_xsd__string(soap, &this->wsp__Content::sp__Basic256Rsa15);
	soap_default_xsd__string(soap, &this->wsp__Content::sp__Basic192Rsa15);
	soap_default_xsd__string(soap, &this->wsp__Content::sp__Basic128Rsa15);
	soap_default_xsd__string(soap, &this->wsp__Content::sp__TripleDesRsa15);
	soap_default_xsd__string(soap, &this->wsp__Content::sp__Basic256Sha256);
	soap_default_xsd__string(soap, &this->wsp__Content::sp__Basic192Sha256);
	soap_default_xsd__string(soap, &this->wsp__Content::sp__Basic128Sha256);
	soap_default_xsd__string(soap, &this->wsp__Content::sp__TripleDesSha256);
	soap_default_xsd__string(soap, &this->wsp__Content::sp__Basic256Sha256Rsa15);
	soap_default_xsd__string(soap, &this->wsp__Content::sp__Basic192Sha256Rsa15);
	soap_default_xsd__string(soap, &this->wsp__Content::sp__Basic128Sha256Rsa15);
	soap_default_xsd__string(soap, &this->wsp__Content::sp__TripleDesSha256Rsa15);
	soap_default_xsd__string(soap, &this->wsp__Content::sp__InclusiveC14N);
	soap_default_xsd__string(soap, &this->wsp__Content::sp__SOAPNormalization10);
	soap_default_xsd__string(soap, &this->wsp__Content::sp__STRTransform10);
	soap_default_xsd__string(soap, &this->wsp__Content::sp__Path10);
	soap_default_xsd__string(soap, &this->wsp__Content::sp__XPathFilter20);
	soap_default_xsd__string(soap, &this->wsp__Content::sp__AbsXPath);
	soap_default_xsd__string(soap, &this->wsp__Content::wsam__AnonymousResponses);
	soap_default_xsd__string(soap, &this->wsp__Content::wsam__NonAnonymousResponses);
	soap_default_std__vectorTemplateOf_XML(soap, &this->wsp__Content::__any);
}

void wsp__Content::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowsp__Policy(soap, &this->wsp__Content::Policy);
	soap_serialize_PointerTowsp__PolicyReference(soap, &this->wsp__Content::PolicyReference);
	soap_serialize_std__vectorTemplateOfPointerTowsp__Content(soap, &this->wsp__Content::All);
	soap_serialize_std__vectorTemplateOfPointerTowsp__Content(soap, &this->wsp__Content::ExactlyOne);
	soap_serialize_std__vectorTemplateOfsp__Parts(soap, &this->wsp__Content::sp__SignedParts);
	soap_serialize_std__vectorTemplateOfsp__Parts(soap, &this->wsp__Content::sp__EncryptedParts);
	soap_serialize_std__vectorTemplateOfsp__Parts(soap, &this->wsp__Content::sp__RequiredParts);
	soap_serialize_PointerTosp__Elements(soap, &this->wsp__Content::sp__SignedElements);
	soap_serialize_PointerTosp__Elements(soap, &this->wsp__Content::sp__EncryptedElements);
	soap_serialize_PointerTosp__Elements(soap, &this->wsp__Content::sp__ContentEncryptedElements);
	soap_serialize_PointerTosp__Elements(soap, &this->wsp__Content::sp__RequiredElements);
	soap_serialize_PointerTosp__Token(soap, &this->wsp__Content::sp__UsernameToken);
	soap_serialize_PointerTosp__Token(soap, &this->wsp__Content::sp__IssuedToken);
	soap_serialize_PointerTosp__Token(soap, &this->wsp__Content::sp__X509Token);
	soap_serialize_PointerTosp__Token(soap, &this->wsp__Content::sp__KerberosToken);
	soap_serialize_PointerTosp__Token(soap, &this->wsp__Content::sp__SpnegoContextToken);
	soap_serialize_PointerTosp__Token(soap, &this->wsp__Content::sp__SecurityContextToken);
	soap_serialize_PointerTosp__Token(soap, &this->wsp__Content::sp__SecureConversationToken);
	soap_serialize_PointerTosp__Token(soap, &this->wsp__Content::sp__SamlToken);
	soap_serialize_PointerTosp__Token(soap, &this->wsp__Content::sp__RelToken);
	soap_serialize_PointerTosp__Token(soap, &this->wsp__Content::sp__HttpsToken);
	soap_serialize_PointerTosp__Token(soap, &this->wsp__Content::sp__KeyValueToken);
	soap_serialize_PointerTowsp__Assertion(soap, &this->wsp__Content::sp__TransportBinding);
	soap_serialize_PointerTowsp__Assertion(soap, &this->wsp__Content::sp__TransportToken);
	soap_serialize_PointerTowsp__Assertion(soap, &this->wsp__Content::sp__AlgorithmSuite);
	soap_serialize_PointerTowsp__Assertion(soap, &this->wsp__Content::sp__Layout);
	soap_serialize_PointerTowsp__Assertion(soap, &this->wsp__Content::sp__SymmetricBinding);
	soap_serialize_PointerTowsp__Assertion(soap, &this->wsp__Content::sp__AsymmetricBinding);
	soap_serialize_PointerTowsp__Assertion(soap, &this->wsp__Content::sp__ProtectionToken);
	soap_serialize_PointerTowsp__Assertion(soap, &this->wsp__Content::sp__InitiatorToken);
	soap_serialize_PointerTowsp__Assertion(soap, &this->wsp__Content::sp__InitiatorSignatureToken);
	soap_serialize_PointerTowsp__Assertion(soap, &this->wsp__Content::sp__InitiatorEncryptionToken);
	soap_serialize_PointerTowsp__Assertion(soap, &this->wsp__Content::sp__RecipientToken);
	soap_serialize_PointerTowsp__Assertion(soap, &this->wsp__Content::sp__SupportingTokens);
	soap_serialize_PointerTowsp__Assertion(soap, &this->wsp__Content::sp__SignedSupportingTokens);
	soap_serialize_PointerTowsp__Assertion(soap, &this->wsp__Content::sp__EndorsingSupportingTokens);
	soap_serialize_PointerTowsp__Assertion(soap, &this->wsp__Content::sp__SignedEndorsingSupportingTokens);
	soap_serialize_PointerTowsp__Assertion(soap, &this->wsp__Content::sp__SignedEncryptedSupportingTokens);
	soap_serialize_PointerTowsp__Assertion(soap, &this->wsp__Content::sp__EncryptedSupportingTokens);
	soap_serialize_PointerTowsp__Assertion(soap, &this->wsp__Content::sp__EndorsingEncryptedSupportingTokens);
	soap_serialize_PointerTowsp__Assertion(soap, &this->wsp__Content::sp__SignedEndorsingEncryptedSupportingTokens);
	soap_serialize_PointerTowsp__Assertion(soap, &this->wsp__Content::sp__Wss10);
	soap_serialize_PointerTowsp__Assertion(soap, &this->wsp__Content::sp__Wss11);
	soap_serialize_PointerTowsp__Assertion(soap, &this->wsp__Content::sp__Trust10);
	soap_serialize_PointerTowsp__Assertion(soap, &this->wsp__Content::sp__Trust13);
	soap_serialize_PointerTowsp__Content(soap, &this->wsp__Content::sp__BootstrapPolicy);
	soap_serialize_xsd__string(soap, (char*const*)&this->wsp__Content::wsaw__UsingAddressing);
	soap_serialize_PointerTowsp__Assertion(soap, &this->wsp__Content::wsam__Addressing);
	soap_serialize_PointerTowsrmp__RMAssertion(soap, &this->wsp__Content::wsrmp__RMAssertion_);
	soap_serialize_PointerTowsrmp__RMAssertion(soap, &this->wsp__Content::wsrmp__DeliveryAssurance);
	soap_serialize_xsd__string(soap, (char*const*)&this->wsp__Content::wsrmp__AtLeastOnce);
	soap_serialize_xsd__string(soap, (char*const*)&this->wsp__Content::wsrmp__AtMostOnce);
	soap_serialize_xsd__string(soap, (char*const*)&this->wsp__Content::wsrmp__ExactlyOnce);
	soap_serialize_xsd__string(soap, (char*const*)&this->wsp__Content::wsrmp__InOrder);
	soap_serialize_PointerTowsrmp5__RMAssertion(soap, &this->wsp__Content::wsrmp5__RMAssertion_);
	soap_serialize_PointerTowsrmp5__RMAssertion(soap, &this->wsp__Content::wsrmp5__DeliveryAssurance);
	soap_serialize_xsd__string(soap, (char*const*)&this->wsp__Content::wsrmp5__AtLeastOnce);
	soap_serialize_xsd__string(soap, (char*const*)&this->wsp__Content::wsrmp5__AtMostOnce);
	soap_serialize_xsd__string(soap, (char*const*)&this->wsp__Content::wsrmp5__ExactlyOnce);
	soap_serialize_xsd__string(soap, (char*const*)&this->wsp__Content::wsrmp5__InOrder);
	soap_serialize_PointerTowsp__Assertion(soap, &this->wsp__Content::sp__NoPassword);
	soap_serialize_PointerTowsp__Assertion(soap, &this->wsp__Content::sp__HashPassword);
	soap_serialize_PointerTowsp__Assertion(soap, &this->wsp__Content::sp__IncludeTimestamp);
	soap_serialize_PointerTowsp__Assertion(soap, &this->wsp__Content::sp__EncryptBeforeSigning);
	soap_serialize_PointerTowsp__Assertion(soap, &this->wsp__Content::sp__EncryptSignature);
	soap_serialize_PointerTowsp__Assertion(soap, &this->wsp__Content::sp__ProtectTokens);
	soap_serialize_PointerTowsp__Assertion(soap, &this->wsp__Content::sp__OnlySignEntireHeadersAndBody);
	soap_serialize_xsd__string(soap, (char*const*)&this->wsp__Content::sp__RequireDerivedKeys);
	soap_serialize_xsd__string(soap, (char*const*)&this->wsp__Content::sp__RequireImpliedDerivedKeys);
	soap_serialize_xsd__string(soap, (char*const*)&this->wsp__Content::sp__RequireExplicitDerivedKeys);
	soap_serialize_xsd__string(soap, (char*const*)&this->wsp__Content::sp__WssUsernameToken10);
	soap_serialize_xsd__string(soap, (char*const*)&this->wsp__Content::sp__WssUsernameToken11);
	soap_serialize_xsd__string(soap, (char*const*)&this->wsp__Content::sp__RequireExternalReference);
	soap_serialize_xsd__string(soap, (char*const*)&this->wsp__Content::sp__RequireInternalReference);
	soap_serialize_xsd__string(soap, (char*const*)&this->wsp__Content::sp__RequireKeyIdentifierReference);
	soap_serialize_xsd__string(soap, (char*const*)&this->wsp__Content::sp__RequireIssuerSerialReference);
	soap_serialize_xsd__string(soap, (char*const*)&this->wsp__Content::sp__RequireEmbeddedTokenReference);
	soap_serialize_xsd__string(soap, (char*const*)&this->wsp__Content::sp__RequireThumbprintReference);
	soap_serialize_xsd__string(soap, (char*const*)&this->wsp__Content::sp__WssX509V3Token10);
	soap_serialize_xsd__string(soap, (char*const*)&this->wsp__Content::sp__WssX509Pkcs7Token10);
	soap_serialize_xsd__string(soap, (char*const*)&this->wsp__Content::sp__WssX509PkiPathV1Token10);
	soap_serialize_xsd__string(soap, (char*const*)&this->wsp__Content::sp__WssX509V1Token11);
	soap_serialize_xsd__string(soap, (char*const*)&this->wsp__Content::sp__WssX509V3Token11);
	soap_serialize_xsd__string(soap, (char*const*)&this->wsp__Content::sp__WssX509Pkcs7Token11);
	soap_serialize_xsd__string(soap, (char*const*)&this->wsp__Content::sp__WssX509PkiPathV1Token11);
	soap_serialize_xsd__string(soap, (char*const*)&this->wsp__Content::sp__WssKerberosV5ApReqToken11);
	soap_serialize_xsd__string(soap, (char*const*)&this->wsp__Content::sp__WssGssKerberosV5ApReqToken11);
	soap_serialize_xsd__string(soap, (char*const*)&this->wsp__Content::sp__WssRelV10Token10);
	soap_serialize_xsd__string(soap, (char*const*)&this->wsp__Content::sp__WssRelV20Token10);
	soap_serialize_xsd__string(soap, (char*const*)&this->wsp__Content::sp__WssRelV10Token11);
	soap_serialize_xsd__string(soap, (char*const*)&this->wsp__Content::sp__WssRelV20Token11);
	soap_serialize_xsd__string(soap, (char*const*)&this->wsp__Content::sp__MustNotSendCancel);
	soap_serialize_xsd__string(soap, (char*const*)&this->wsp__Content::sp__MustNotSendAmend);
	soap_serialize_xsd__string(soap, (char*const*)&this->wsp__Content::sp__MustNotSendRenew);
	soap_serialize_xsd__string(soap, (char*const*)&this->wsp__Content::sp__MustSupportRefKeyIdentifier);
	soap_serialize_xsd__string(soap, (char*const*)&this->wsp__Content::sp__MustSupportRefIssuerSerial);
	soap_serialize_xsd__string(soap, (char*const*)&this->wsp__Content::sp__MustSupportRefExternalURI);
	soap_serialize_xsd__string(soap, (char*const*)&this->wsp__Content::sp__MustSupportRefEmbeddedToken);
	soap_serialize_xsd__string(soap, (char*const*)&this->wsp__Content::sp__MustSupportRefThumbprint);
	soap_serialize_xsd__string(soap, (char*const*)&this->wsp__Content::sp__MustSupportRefEncryptedKey);
	soap_serialize_xsd__string(soap, (char*const*)&this->wsp__Content::sp__RequireSignatureConfirmation);
	soap_serialize_xsd__string(soap, (char*const*)&this->wsp__Content::sp__MustSupportClientChallenge);
	soap_serialize_xsd__string(soap, (char*const*)&this->wsp__Content::sp__MustSupportServerChallenge);
	soap_serialize_xsd__string(soap, (char*const*)&this->wsp__Content::sp__RequireClientEntropy);
	soap_serialize_xsd__string(soap, (char*const*)&this->wsp__Content::sp__RequireServerEntropy);
	soap_serialize_xsd__string(soap, (char*const*)&this->wsp__Content::sp__MustSupportIssuedTokens);
	soap_serialize_xsd__string(soap, (char*const*)&this->wsp__Content::sp__RequireRequestSecurityTokenCollection);
	soap_serialize_xsd__string(soap, (char*const*)&this->wsp__Content::sp__RequireAppliesTo);
	soap_serialize_xsd__string(soap, (char*const*)&this->wsp__Content::sp__RequireExternalUriReference);
	soap_serialize_xsd__string(soap, (char*const*)&this->wsp__Content::sp__SC13SecurityContextToken);
	soap_serialize_xsd__string(soap, (char*const*)&this->wsp__Content::sp__Strict);
	soap_serialize_xsd__string(soap, (char*const*)&this->wsp__Content::sp__Lax);
	soap_serialize_xsd__string(soap, (char*const*)&this->wsp__Content::sp__LaxTsFirst);
	soap_serialize_xsd__string(soap, (char*const*)&this->wsp__Content::sp__LaxTsLast);
	soap_serialize_xsd__string(soap, (char*const*)&this->wsp__Content::sp__HttpBasicAuthentication);
	soap_serialize_xsd__string(soap, (char*const*)&this->wsp__Content::sp__HttpDigestAuthentication);
	soap_serialize_xsd__string(soap, (char*const*)&this->wsp__Content::sp__RequireClientCertificate);
	soap_serialize_xsd__string(soap, (char*const*)&this->wsp__Content::sp__Basic256);
	soap_serialize_xsd__string(soap, (char*const*)&this->wsp__Content::sp__Basic192);
	soap_serialize_xsd__string(soap, (char*const*)&this->wsp__Content::sp__Basic128);
	soap_serialize_xsd__string(soap, (char*const*)&this->wsp__Content::sp__TripleDes);
	soap_serialize_xsd__string(soap, (char*const*)&this->wsp__Content::sp__Basic256Rsa15);
	soap_serialize_xsd__string(soap, (char*const*)&this->wsp__Content::sp__Basic192Rsa15);
	soap_serialize_xsd__string(soap, (char*const*)&this->wsp__Content::sp__Basic128Rsa15);
	soap_serialize_xsd__string(soap, (char*const*)&this->wsp__Content::sp__TripleDesRsa15);
	soap_serialize_xsd__string(soap, (char*const*)&this->wsp__Content::sp__Basic256Sha256);
	soap_serialize_xsd__string(soap, (char*const*)&this->wsp__Content::sp__Basic192Sha256);
	soap_serialize_xsd__string(soap, (char*const*)&this->wsp__Content::sp__Basic128Sha256);
	soap_serialize_xsd__string(soap, (char*const*)&this->wsp__Content::sp__TripleDesSha256);
	soap_serialize_xsd__string(soap, (char*const*)&this->wsp__Content::sp__Basic256Sha256Rsa15);
	soap_serialize_xsd__string(soap, (char*const*)&this->wsp__Content::sp__Basic192Sha256Rsa15);
	soap_serialize_xsd__string(soap, (char*const*)&this->wsp__Content::sp__Basic128Sha256Rsa15);
	soap_serialize_xsd__string(soap, (char*const*)&this->wsp__Content::sp__TripleDesSha256Rsa15);
	soap_serialize_xsd__string(soap, (char*const*)&this->wsp__Content::sp__InclusiveC14N);
	soap_serialize_xsd__string(soap, (char*const*)&this->wsp__Content::sp__SOAPNormalization10);
	soap_serialize_xsd__string(soap, (char*const*)&this->wsp__Content::sp__STRTransform10);
	soap_serialize_xsd__string(soap, (char*const*)&this->wsp__Content::sp__Path10);
	soap_serialize_xsd__string(soap, (char*const*)&this->wsp__Content::sp__XPathFilter20);
	soap_serialize_xsd__string(soap, (char*const*)&this->wsp__Content::sp__AbsXPath);
	soap_serialize_xsd__string(soap, (char*const*)&this->wsp__Content::wsam__AnonymousResponses);
	soap_serialize_xsd__string(soap, (char*const*)&this->wsp__Content::wsam__NonAnonymousResponses);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->wsp__Content::__any);
#endif
}

int wsp__Content::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsp__Content(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsp__Content(struct soap *soap, const char *tag, int id, const wsp__Content *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsp__Content), type))
		return soap->error;
	if (soap_out_PointerTowsp__Policy(soap, "wsp:Policy", -1, &a->wsp__Content::Policy, ""))
		return soap->error;
	if (soap_out_PointerTowsp__PolicyReference(soap, "wsp:PolicyReference", -1, &a->wsp__Content::PolicyReference, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTowsp__Content(soap, "wsp:All", -1, &a->wsp__Content::All, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTowsp__Content(soap, "wsp:ExactlyOne", -1, &a->wsp__Content::ExactlyOne, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfsp__Parts(soap, "sp:SignedParts", -1, &a->wsp__Content::sp__SignedParts, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfsp__Parts(soap, "sp:EncryptedParts", -1, &a->wsp__Content::sp__EncryptedParts, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfsp__Parts(soap, "sp:RequiredParts", -1, &a->wsp__Content::sp__RequiredParts, ""))
		return soap->error;
	if (soap_out_PointerTosp__Elements(soap, "sp:SignedElements", -1, &a->wsp__Content::sp__SignedElements, ""))
		return soap->error;
	if (soap_out_PointerTosp__Elements(soap, "sp:EncryptedElements", -1, &a->wsp__Content::sp__EncryptedElements, ""))
		return soap->error;
	if (soap_out_PointerTosp__Elements(soap, "sp:ContentEncryptedElements", -1, &a->wsp__Content::sp__ContentEncryptedElements, ""))
		return soap->error;
	if (soap_out_PointerTosp__Elements(soap, "sp:RequiredElements", -1, &a->wsp__Content::sp__RequiredElements, ""))
		return soap->error;
	if (soap_out_PointerTosp__Token(soap, "sp:UsernameToken", -1, &a->wsp__Content::sp__UsernameToken, ""))
		return soap->error;
	if (soap_out_PointerTosp__Token(soap, "sp:IssuedToken", -1, &a->wsp__Content::sp__IssuedToken, ""))
		return soap->error;
	if (soap_out_PointerTosp__Token(soap, "sp:X509Token", -1, &a->wsp__Content::sp__X509Token, ""))
		return soap->error;
	if (soap_out_PointerTosp__Token(soap, "sp:KerberosToken", -1, &a->wsp__Content::sp__KerberosToken, ""))
		return soap->error;
	if (soap_out_PointerTosp__Token(soap, "sp:SpnegoContextToken", -1, &a->wsp__Content::sp__SpnegoContextToken, ""))
		return soap->error;
	if (soap_out_PointerTosp__Token(soap, "sp:SecurityContextToken", -1, &a->wsp__Content::sp__SecurityContextToken, ""))
		return soap->error;
	if (soap_out_PointerTosp__Token(soap, "sp:SecureConversationToken", -1, &a->wsp__Content::sp__SecureConversationToken, ""))
		return soap->error;
	if (soap_out_PointerTosp__Token(soap, "sp:SamlToken", -1, &a->wsp__Content::sp__SamlToken, ""))
		return soap->error;
	if (soap_out_PointerTosp__Token(soap, "sp:RelToken", -1, &a->wsp__Content::sp__RelToken, ""))
		return soap->error;
	if (soap_out_PointerTosp__Token(soap, "sp:HttpsToken", -1, &a->wsp__Content::sp__HttpsToken, ""))
		return soap->error;
	if (soap_out_PointerTosp__Token(soap, "sp:KeyValueToken", -1, &a->wsp__Content::sp__KeyValueToken, ""))
		return soap->error;
	if (soap_out_PointerTowsp__Assertion(soap, "sp:TransportBinding", -1, &a->wsp__Content::sp__TransportBinding, ""))
		return soap->error;
	if (soap_out_PointerTowsp__Assertion(soap, "sp:TransportToken", -1, &a->wsp__Content::sp__TransportToken, ""))
		return soap->error;
	if (soap_out_PointerTowsp__Assertion(soap, "sp:AlgorithmSuite", -1, &a->wsp__Content::sp__AlgorithmSuite, ""))
		return soap->error;
	if (soap_out_PointerTowsp__Assertion(soap, "sp:Layout", -1, &a->wsp__Content::sp__Layout, ""))
		return soap->error;
	if (soap_out_PointerTowsp__Assertion(soap, "sp:SymmetricBinding", -1, &a->wsp__Content::sp__SymmetricBinding, ""))
		return soap->error;
	if (soap_out_PointerTowsp__Assertion(soap, "sp:AsymmetricBinding", -1, &a->wsp__Content::sp__AsymmetricBinding, ""))
		return soap->error;
	if (soap_out_PointerTowsp__Assertion(soap, "sp:ProtectionToken", -1, &a->wsp__Content::sp__ProtectionToken, ""))
		return soap->error;
	if (soap_out_PointerTowsp__Assertion(soap, "sp:InitiatorToken", -1, &a->wsp__Content::sp__InitiatorToken, ""))
		return soap->error;
	if (soap_out_PointerTowsp__Assertion(soap, "sp:InitiatorSignatureToken", -1, &a->wsp__Content::sp__InitiatorSignatureToken, ""))
		return soap->error;
	if (soap_out_PointerTowsp__Assertion(soap, "sp:InitiatorEncryptionToken", -1, &a->wsp__Content::sp__InitiatorEncryptionToken, ""))
		return soap->error;
	if (soap_out_PointerTowsp__Assertion(soap, "sp:RecipientToken", -1, &a->wsp__Content::sp__RecipientToken, ""))
		return soap->error;
	if (soap_out_PointerTowsp__Assertion(soap, "sp:SupportingTokens", -1, &a->wsp__Content::sp__SupportingTokens, ""))
		return soap->error;
	if (soap_out_PointerTowsp__Assertion(soap, "sp:SignedSupportingTokens", -1, &a->wsp__Content::sp__SignedSupportingTokens, ""))
		return soap->error;
	if (soap_out_PointerTowsp__Assertion(soap, "sp:EndorsingSupportingTokens", -1, &a->wsp__Content::sp__EndorsingSupportingTokens, ""))
		return soap->error;
	if (soap_out_PointerTowsp__Assertion(soap, "sp:SignedEndorsingSupportingTokens", -1, &a->wsp__Content::sp__SignedEndorsingSupportingTokens, ""))
		return soap->error;
	if (soap_out_PointerTowsp__Assertion(soap, "sp:SignedEncryptedSupportingTokens", -1, &a->wsp__Content::sp__SignedEncryptedSupportingTokens, ""))
		return soap->error;
	if (soap_out_PointerTowsp__Assertion(soap, "sp:EncryptedSupportingTokens", -1, &a->wsp__Content::sp__EncryptedSupportingTokens, ""))
		return soap->error;
	if (soap_out_PointerTowsp__Assertion(soap, "sp:EndorsingEncryptedSupportingTokens", -1, &a->wsp__Content::sp__EndorsingEncryptedSupportingTokens, ""))
		return soap->error;
	if (soap_out_PointerTowsp__Assertion(soap, "sp:SignedEndorsingEncryptedSupportingTokens", -1, &a->wsp__Content::sp__SignedEndorsingEncryptedSupportingTokens, ""))
		return soap->error;
	if (soap_out_PointerTowsp__Assertion(soap, "sp:Wss10", -1, &a->wsp__Content::sp__Wss10, ""))
		return soap->error;
	if (soap_out_PointerTowsp__Assertion(soap, "sp:Wss11", -1, &a->wsp__Content::sp__Wss11, ""))
		return soap->error;
	if (soap_out_PointerTowsp__Assertion(soap, "sp:Trust10", -1, &a->wsp__Content::sp__Trust10, ""))
		return soap->error;
	if (soap_out_PointerTowsp__Assertion(soap, "sp:Trust13", -1, &a->wsp__Content::sp__Trust13, ""))
		return soap->error;
	if (soap_out_PointerTowsp__Content(soap, "sp:BootstrapPolicy", -1, &a->wsp__Content::sp__BootstrapPolicy, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "wsaw:UsingAddressing", -1, (char*const*)&a->wsp__Content::wsaw__UsingAddressing, ""))
		return soap->error;
	if (soap_out_PointerTowsp__Assertion(soap, "wsam:Addressing", -1, &a->wsp__Content::wsam__Addressing, ""))
		return soap->error;
	if (soap_out_PointerTowsrmp__RMAssertion(soap, "wsrmp:RMAssertion", -1, &a->wsp__Content::wsrmp__RMAssertion_, ""))
		return soap->error;
	if (soap_out_PointerTowsrmp__RMAssertion(soap, "wsrmp:DeliveryAssurance", -1, &a->wsp__Content::wsrmp__DeliveryAssurance, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "wsrmp:AtLeastOnce", -1, (char*const*)&a->wsp__Content::wsrmp__AtLeastOnce, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "wsrmp:AtMostOnce", -1, (char*const*)&a->wsp__Content::wsrmp__AtMostOnce, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "wsrmp:ExactlyOnce", -1, (char*const*)&a->wsp__Content::wsrmp__ExactlyOnce, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "wsrmp:InOrder", -1, (char*const*)&a->wsp__Content::wsrmp__InOrder, ""))
		return soap->error;
	if (soap_out_PointerTowsrmp5__RMAssertion(soap, "wsrmp5:RMAssertion", -1, &a->wsp__Content::wsrmp5__RMAssertion_, ""))
		return soap->error;
	if (soap_out_PointerTowsrmp5__RMAssertion(soap, "wsrmp5:DeliveryAssurance", -1, &a->wsp__Content::wsrmp5__DeliveryAssurance, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "wsrmp5:AtLeastOnce", -1, (char*const*)&a->wsp__Content::wsrmp5__AtLeastOnce, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "wsrmp5:AtMostOnce", -1, (char*const*)&a->wsp__Content::wsrmp5__AtMostOnce, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "wsrmp5:ExactlyOnce", -1, (char*const*)&a->wsp__Content::wsrmp5__ExactlyOnce, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "wsrmp5:InOrder", -1, (char*const*)&a->wsp__Content::wsrmp5__InOrder, ""))
		return soap->error;
	if (soap_out_PointerTowsp__Assertion(soap, "sp:NoPassword", -1, &a->wsp__Content::sp__NoPassword, ""))
		return soap->error;
	if (soap_out_PointerTowsp__Assertion(soap, "sp:HashPassword", -1, &a->wsp__Content::sp__HashPassword, ""))
		return soap->error;
	if (soap_out_PointerTowsp__Assertion(soap, "sp:IncludeTimestamp", -1, &a->wsp__Content::sp__IncludeTimestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsp__Assertion(soap, "sp:EncryptBeforeSigning", -1, &a->wsp__Content::sp__EncryptBeforeSigning, ""))
		return soap->error;
	if (soap_out_PointerTowsp__Assertion(soap, "sp:EncryptSignature", -1, &a->wsp__Content::sp__EncryptSignature, ""))
		return soap->error;
	if (soap_out_PointerTowsp__Assertion(soap, "sp:ProtectTokens", -1, &a->wsp__Content::sp__ProtectTokens, ""))
		return soap->error;
	if (soap_out_PointerTowsp__Assertion(soap, "sp:OnlySignEntireHeadersAndBody", -1, &a->wsp__Content::sp__OnlySignEntireHeadersAndBody, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:RequireDerivedKeys", -1, (char*const*)&a->wsp__Content::sp__RequireDerivedKeys, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:RequireImpliedDerivedKeys", -1, (char*const*)&a->wsp__Content::sp__RequireImpliedDerivedKeys, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:RequireExplicitDerivedKeys", -1, (char*const*)&a->wsp__Content::sp__RequireExplicitDerivedKeys, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:WssUsernameToken10", -1, (char*const*)&a->wsp__Content::sp__WssUsernameToken10, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:WssUsernameToken11", -1, (char*const*)&a->wsp__Content::sp__WssUsernameToken11, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:RequireExternalReference", -1, (char*const*)&a->wsp__Content::sp__RequireExternalReference, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:RequireInternalReference", -1, (char*const*)&a->wsp__Content::sp__RequireInternalReference, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:RequireKeyIdentifierReference", -1, (char*const*)&a->wsp__Content::sp__RequireKeyIdentifierReference, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:RequireIssuerSerialReference", -1, (char*const*)&a->wsp__Content::sp__RequireIssuerSerialReference, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:RequireEmbeddedTokenReference", -1, (char*const*)&a->wsp__Content::sp__RequireEmbeddedTokenReference, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:RequireThumbprintReference", -1, (char*const*)&a->wsp__Content::sp__RequireThumbprintReference, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:WssX509V3Token10", -1, (char*const*)&a->wsp__Content::sp__WssX509V3Token10, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:WssX509Pkcs7Token10", -1, (char*const*)&a->wsp__Content::sp__WssX509Pkcs7Token10, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:WssX509PkiPathV1Token10", -1, (char*const*)&a->wsp__Content::sp__WssX509PkiPathV1Token10, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:WssX509V1Token11", -1, (char*const*)&a->wsp__Content::sp__WssX509V1Token11, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:WssX509V3Token11", -1, (char*const*)&a->wsp__Content::sp__WssX509V3Token11, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:WssX509Pkcs7Token11", -1, (char*const*)&a->wsp__Content::sp__WssX509Pkcs7Token11, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:WssX509PkiPathV1Token11", -1, (char*const*)&a->wsp__Content::sp__WssX509PkiPathV1Token11, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:WssKerberosV5ApReqToken11", -1, (char*const*)&a->wsp__Content::sp__WssKerberosV5ApReqToken11, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:WssGssKerberosV5ApReqToken11", -1, (char*const*)&a->wsp__Content::sp__WssGssKerberosV5ApReqToken11, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:WssRelV10Token10", -1, (char*const*)&a->wsp__Content::sp__WssRelV10Token10, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:WssRelV20Token10", -1, (char*const*)&a->wsp__Content::sp__WssRelV20Token10, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:WssRelV10Token11", -1, (char*const*)&a->wsp__Content::sp__WssRelV10Token11, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:WssRelV20Token11", -1, (char*const*)&a->wsp__Content::sp__WssRelV20Token11, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:MustNotSendCancel", -1, (char*const*)&a->wsp__Content::sp__MustNotSendCancel, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:MustNotSendAmend", -1, (char*const*)&a->wsp__Content::sp__MustNotSendAmend, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:MustNotSendRenew", -1, (char*const*)&a->wsp__Content::sp__MustNotSendRenew, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:MustSupportRefKeyIdentifier", -1, (char*const*)&a->wsp__Content::sp__MustSupportRefKeyIdentifier, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:MustSupportRefIssuerSerial", -1, (char*const*)&a->wsp__Content::sp__MustSupportRefIssuerSerial, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:MustSupportRefExternalURI", -1, (char*const*)&a->wsp__Content::sp__MustSupportRefExternalURI, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:MustSupportRefEmbeddedToken", -1, (char*const*)&a->wsp__Content::sp__MustSupportRefEmbeddedToken, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:MustSupportRefThumbprint", -1, (char*const*)&a->wsp__Content::sp__MustSupportRefThumbprint, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:MustSupportRefEncryptedKey", -1, (char*const*)&a->wsp__Content::sp__MustSupportRefEncryptedKey, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:RequireSignatureConfirmation", -1, (char*const*)&a->wsp__Content::sp__RequireSignatureConfirmation, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:MustSupportClientChallenge", -1, (char*const*)&a->wsp__Content::sp__MustSupportClientChallenge, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:MustSupportServerChallenge", -1, (char*const*)&a->wsp__Content::sp__MustSupportServerChallenge, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:RequireClientEntropy", -1, (char*const*)&a->wsp__Content::sp__RequireClientEntropy, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:RequireServerEntropy", -1, (char*const*)&a->wsp__Content::sp__RequireServerEntropy, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:MustSupportIssuedTokens", -1, (char*const*)&a->wsp__Content::sp__MustSupportIssuedTokens, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:RequireRequestSecurityTokenCollection", -1, (char*const*)&a->wsp__Content::sp__RequireRequestSecurityTokenCollection, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:RequireAppliesTo", -1, (char*const*)&a->wsp__Content::sp__RequireAppliesTo, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:RequireExternalUriReference", -1, (char*const*)&a->wsp__Content::sp__RequireExternalUriReference, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:SC13SecurityContextToken", -1, (char*const*)&a->wsp__Content::sp__SC13SecurityContextToken, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:Strict", -1, (char*const*)&a->wsp__Content::sp__Strict, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:Lax", -1, (char*const*)&a->wsp__Content::sp__Lax, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:LaxTsFirst", -1, (char*const*)&a->wsp__Content::sp__LaxTsFirst, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:LaxTsLast", -1, (char*const*)&a->wsp__Content::sp__LaxTsLast, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:HttpBasicAuthentication", -1, (char*const*)&a->wsp__Content::sp__HttpBasicAuthentication, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:HttpDigestAuthentication", -1, (char*const*)&a->wsp__Content::sp__HttpDigestAuthentication, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:RequireClientCertificate", -1, (char*const*)&a->wsp__Content::sp__RequireClientCertificate, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:Basic256", -1, (char*const*)&a->wsp__Content::sp__Basic256, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:Basic192", -1, (char*const*)&a->wsp__Content::sp__Basic192, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:Basic128", -1, (char*const*)&a->wsp__Content::sp__Basic128, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:TripleDes", -1, (char*const*)&a->wsp__Content::sp__TripleDes, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:Basic256Rsa15", -1, (char*const*)&a->wsp__Content::sp__Basic256Rsa15, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:Basic192Rsa15", -1, (char*const*)&a->wsp__Content::sp__Basic192Rsa15, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:Basic128Rsa15", -1, (char*const*)&a->wsp__Content::sp__Basic128Rsa15, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:TripleDesRsa15", -1, (char*const*)&a->wsp__Content::sp__TripleDesRsa15, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:Basic256Sha256", -1, (char*const*)&a->wsp__Content::sp__Basic256Sha256, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:Basic192Sha256", -1, (char*const*)&a->wsp__Content::sp__Basic192Sha256, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:Basic128Sha256", -1, (char*const*)&a->wsp__Content::sp__Basic128Sha256, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:TripleDesSha256", -1, (char*const*)&a->wsp__Content::sp__TripleDesSha256, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:Basic256Sha256Rsa15", -1, (char*const*)&a->wsp__Content::sp__Basic256Sha256Rsa15, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:Basic192Sha256Rsa15", -1, (char*const*)&a->wsp__Content::sp__Basic192Sha256Rsa15, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:Basic128Sha256Rsa15", -1, (char*const*)&a->wsp__Content::sp__Basic128Sha256Rsa15, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:TripleDesSha256Rsa15", -1, (char*const*)&a->wsp__Content::sp__TripleDesSha256Rsa15, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:InclusiveC14N", -1, (char*const*)&a->wsp__Content::sp__InclusiveC14N, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:SOAPNormalization10", -1, (char*const*)&a->wsp__Content::sp__SOAPNormalization10, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:STRTransform10", -1, (char*const*)&a->wsp__Content::sp__STRTransform10, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:Path10", -1, (char*const*)&a->wsp__Content::sp__Path10, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:XPathFilter20", -1, (char*const*)&a->wsp__Content::sp__XPathFilter20, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:AbsXPath", -1, (char*const*)&a->wsp__Content::sp__AbsXPath, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "wsam:AnonymousResponses", -1, (char*const*)&a->wsp__Content::wsam__AnonymousResponses, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "wsam:NonAnonymousResponses", -1, (char*const*)&a->wsp__Content::wsam__NonAnonymousResponses, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->wsp__Content::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsp__Content::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wsp__Content(soap, tag, this, type);
}

SOAP_FMAC3 wsp__Content * SOAP_FMAC4 soap_in_wsp__Content(struct soap *soap, const char *tag, wsp__Content *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsp__Content *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsp__Content, sizeof(wsp__Content), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsp__Content)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsp__Content *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Policy1 = 1;
	size_t soap_flag_PolicyReference1 = 1;
	size_t soap_flag_sp__SignedElements1 = 1;
	size_t soap_flag_sp__EncryptedElements1 = 1;
	size_t soap_flag_sp__ContentEncryptedElements1 = 1;
	size_t soap_flag_sp__RequiredElements1 = 1;
	size_t soap_flag_sp__UsernameToken1 = 1;
	size_t soap_flag_sp__IssuedToken1 = 1;
	size_t soap_flag_sp__X509Token1 = 1;
	size_t soap_flag_sp__KerberosToken1 = 1;
	size_t soap_flag_sp__SpnegoContextToken1 = 1;
	size_t soap_flag_sp__SecurityContextToken1 = 1;
	size_t soap_flag_sp__SecureConversationToken1 = 1;
	size_t soap_flag_sp__SamlToken1 = 1;
	size_t soap_flag_sp__RelToken1 = 1;
	size_t soap_flag_sp__HttpsToken1 = 1;
	size_t soap_flag_sp__KeyValueToken1 = 1;
	size_t soap_flag_sp__TransportBinding1 = 1;
	size_t soap_flag_sp__TransportToken1 = 1;
	size_t soap_flag_sp__AlgorithmSuite1 = 1;
	size_t soap_flag_sp__Layout1 = 1;
	size_t soap_flag_sp__SymmetricBinding1 = 1;
	size_t soap_flag_sp__AsymmetricBinding1 = 1;
	size_t soap_flag_sp__ProtectionToken1 = 1;
	size_t soap_flag_sp__InitiatorToken1 = 1;
	size_t soap_flag_sp__InitiatorSignatureToken1 = 1;
	size_t soap_flag_sp__InitiatorEncryptionToken1 = 1;
	size_t soap_flag_sp__RecipientToken1 = 1;
	size_t soap_flag_sp__SupportingTokens1 = 1;
	size_t soap_flag_sp__SignedSupportingTokens1 = 1;
	size_t soap_flag_sp__EndorsingSupportingTokens1 = 1;
	size_t soap_flag_sp__SignedEndorsingSupportingTokens1 = 1;
	size_t soap_flag_sp__SignedEncryptedSupportingTokens1 = 1;
	size_t soap_flag_sp__EncryptedSupportingTokens1 = 1;
	size_t soap_flag_sp__EndorsingEncryptedSupportingTokens1 = 1;
	size_t soap_flag_sp__SignedEndorsingEncryptedSupportingTokens1 = 1;
	size_t soap_flag_sp__Wss101 = 1;
	size_t soap_flag_sp__Wss111 = 1;
	size_t soap_flag_sp__Trust101 = 1;
	size_t soap_flag_sp__Trust131 = 1;
	size_t soap_flag_sp__BootstrapPolicy1 = 1;
	size_t soap_flag_wsaw__UsingAddressing1 = 1;
	size_t soap_flag_wsam__Addressing1 = 1;
	size_t soap_flag_wsrmp__RMAssertion_1 = 1;
	size_t soap_flag_wsrmp__DeliveryAssurance1 = 1;
	size_t soap_flag_wsrmp__AtLeastOnce1 = 1;
	size_t soap_flag_wsrmp__AtMostOnce1 = 1;
	size_t soap_flag_wsrmp__ExactlyOnce1 = 1;
	size_t soap_flag_wsrmp__InOrder1 = 1;
	size_t soap_flag_wsrmp5__RMAssertion_1 = 1;
	size_t soap_flag_wsrmp5__DeliveryAssurance1 = 1;
	size_t soap_flag_wsrmp5__AtLeastOnce1 = 1;
	size_t soap_flag_wsrmp5__AtMostOnce1 = 1;
	size_t soap_flag_wsrmp5__ExactlyOnce1 = 1;
	size_t soap_flag_wsrmp5__InOrder1 = 1;
	size_t soap_flag_sp__NoPassword1 = 1;
	size_t soap_flag_sp__HashPassword1 = 1;
	size_t soap_flag_sp__IncludeTimestamp1 = 1;
	size_t soap_flag_sp__EncryptBeforeSigning1 = 1;
	size_t soap_flag_sp__EncryptSignature1 = 1;
	size_t soap_flag_sp__ProtectTokens1 = 1;
	size_t soap_flag_sp__OnlySignEntireHeadersAndBody1 = 1;
	size_t soap_flag_sp__RequireDerivedKeys1 = 1;
	size_t soap_flag_sp__RequireImpliedDerivedKeys1 = 1;
	size_t soap_flag_sp__RequireExplicitDerivedKeys1 = 1;
	size_t soap_flag_sp__WssUsernameToken101 = 1;
	size_t soap_flag_sp__WssUsernameToken111 = 1;
	size_t soap_flag_sp__RequireExternalReference1 = 1;
	size_t soap_flag_sp__RequireInternalReference1 = 1;
	size_t soap_flag_sp__RequireKeyIdentifierReference1 = 1;
	size_t soap_flag_sp__RequireIssuerSerialReference1 = 1;
	size_t soap_flag_sp__RequireEmbeddedTokenReference1 = 1;
	size_t soap_flag_sp__RequireThumbprintReference1 = 1;
	size_t soap_flag_sp__WssX509V3Token101 = 1;
	size_t soap_flag_sp__WssX509Pkcs7Token101 = 1;
	size_t soap_flag_sp__WssX509PkiPathV1Token101 = 1;
	size_t soap_flag_sp__WssX509V1Token111 = 1;
	size_t soap_flag_sp__WssX509V3Token111 = 1;
	size_t soap_flag_sp__WssX509Pkcs7Token111 = 1;
	size_t soap_flag_sp__WssX509PkiPathV1Token111 = 1;
	size_t soap_flag_sp__WssKerberosV5ApReqToken111 = 1;
	size_t soap_flag_sp__WssGssKerberosV5ApReqToken111 = 1;
	size_t soap_flag_sp__WssRelV10Token101 = 1;
	size_t soap_flag_sp__WssRelV20Token101 = 1;
	size_t soap_flag_sp__WssRelV10Token111 = 1;
	size_t soap_flag_sp__WssRelV20Token111 = 1;
	size_t soap_flag_sp__MustNotSendCancel1 = 1;
	size_t soap_flag_sp__MustNotSendAmend1 = 1;
	size_t soap_flag_sp__MustNotSendRenew1 = 1;
	size_t soap_flag_sp__MustSupportRefKeyIdentifier1 = 1;
	size_t soap_flag_sp__MustSupportRefIssuerSerial1 = 1;
	size_t soap_flag_sp__MustSupportRefExternalURI1 = 1;
	size_t soap_flag_sp__MustSupportRefEmbeddedToken1 = 1;
	size_t soap_flag_sp__MustSupportRefThumbprint1 = 1;
	size_t soap_flag_sp__MustSupportRefEncryptedKey1 = 1;
	size_t soap_flag_sp__RequireSignatureConfirmation1 = 1;
	size_t soap_flag_sp__MustSupportClientChallenge1 = 1;
	size_t soap_flag_sp__MustSupportServerChallenge1 = 1;
	size_t soap_flag_sp__RequireClientEntropy1 = 1;
	size_t soap_flag_sp__RequireServerEntropy1 = 1;
	size_t soap_flag_sp__MustSupportIssuedTokens1 = 1;
	size_t soap_flag_sp__RequireRequestSecurityTokenCollection1 = 1;
	size_t soap_flag_sp__RequireAppliesTo1 = 1;
	size_t soap_flag_sp__RequireExternalUriReference1 = 1;
	size_t soap_flag_sp__SC13SecurityContextToken1 = 1;
	size_t soap_flag_sp__Strict1 = 1;
	size_t soap_flag_sp__Lax1 = 1;
	size_t soap_flag_sp__LaxTsFirst1 = 1;
	size_t soap_flag_sp__LaxTsLast1 = 1;
	size_t soap_flag_sp__HttpBasicAuthentication1 = 1;
	size_t soap_flag_sp__HttpDigestAuthentication1 = 1;
	size_t soap_flag_sp__RequireClientCertificate1 = 1;
	size_t soap_flag_sp__Basic2561 = 1;
	size_t soap_flag_sp__Basic1921 = 1;
	size_t soap_flag_sp__Basic1281 = 1;
	size_t soap_flag_sp__TripleDes1 = 1;
	size_t soap_flag_sp__Basic256Rsa151 = 1;
	size_t soap_flag_sp__Basic192Rsa151 = 1;
	size_t soap_flag_sp__Basic128Rsa151 = 1;
	size_t soap_flag_sp__TripleDesRsa151 = 1;
	size_t soap_flag_sp__Basic256Sha2561 = 1;
	size_t soap_flag_sp__Basic192Sha2561 = 1;
	size_t soap_flag_sp__Basic128Sha2561 = 1;
	size_t soap_flag_sp__TripleDesSha2561 = 1;
	size_t soap_flag_sp__Basic256Sha256Rsa151 = 1;
	size_t soap_flag_sp__Basic192Sha256Rsa151 = 1;
	size_t soap_flag_sp__Basic128Sha256Rsa151 = 1;
	size_t soap_flag_sp__TripleDesSha256Rsa151 = 1;
	size_t soap_flag_sp__InclusiveC14N1 = 1;
	size_t soap_flag_sp__SOAPNormalization101 = 1;
	size_t soap_flag_sp__STRTransform101 = 1;
	size_t soap_flag_sp__Path101 = 1;
	size_t soap_flag_sp__XPathFilter201 = 1;
	size_t soap_flag_sp__AbsXPath1 = 1;
	size_t soap_flag_wsam__AnonymousResponses1 = 1;
	size_t soap_flag_wsam__NonAnonymousResponses1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Policy1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsp__Policy(soap, "wsp:Policy", &a->wsp__Content::Policy, "wsp:Policy"))
				{	soap_flag_Policy1--;
					continue;
				}
			}
			if (soap_flag_PolicyReference1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsp__PolicyReference(soap, "wsp:PolicyReference", &a->wsp__Content::PolicyReference, "wsp:PolicyReference"))
				{	soap_flag_PolicyReference1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTowsp__Content(soap, "wsp:All", &a->wsp__Content::All, "wsp:Content"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTowsp__Content(soap, "wsp:ExactlyOne", &a->wsp__Content::ExactlyOne, "wsp:Content"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfsp__Parts(soap, "sp:SignedParts", &a->wsp__Content::sp__SignedParts, "sp:Parts"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfsp__Parts(soap, "sp:EncryptedParts", &a->wsp__Content::sp__EncryptedParts, "sp:Parts"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfsp__Parts(soap, "sp:RequiredParts", &a->wsp__Content::sp__RequiredParts, "sp:Parts"))
					continue;
			}
			if (soap_flag_sp__SignedElements1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosp__Elements(soap, "sp:SignedElements", &a->wsp__Content::sp__SignedElements, "sp:Elements"))
				{	soap_flag_sp__SignedElements1--;
					continue;
				}
			}
			if (soap_flag_sp__EncryptedElements1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosp__Elements(soap, "sp:EncryptedElements", &a->wsp__Content::sp__EncryptedElements, "sp:Elements"))
				{	soap_flag_sp__EncryptedElements1--;
					continue;
				}
			}
			if (soap_flag_sp__ContentEncryptedElements1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosp__Elements(soap, "sp:ContentEncryptedElements", &a->wsp__Content::sp__ContentEncryptedElements, "sp:Elements"))
				{	soap_flag_sp__ContentEncryptedElements1--;
					continue;
				}
			}
			if (soap_flag_sp__RequiredElements1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosp__Elements(soap, "sp:RequiredElements", &a->wsp__Content::sp__RequiredElements, "sp:Elements"))
				{	soap_flag_sp__RequiredElements1--;
					continue;
				}
			}
			if (soap_flag_sp__UsernameToken1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosp__Token(soap, "sp:UsernameToken", &a->wsp__Content::sp__UsernameToken, "sp:Token"))
				{	soap_flag_sp__UsernameToken1--;
					continue;
				}
			}
			if (soap_flag_sp__IssuedToken1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosp__Token(soap, "sp:IssuedToken", &a->wsp__Content::sp__IssuedToken, "sp:Token"))
				{	soap_flag_sp__IssuedToken1--;
					continue;
				}
			}
			if (soap_flag_sp__X509Token1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosp__Token(soap, "sp:X509Token", &a->wsp__Content::sp__X509Token, "sp:Token"))
				{	soap_flag_sp__X509Token1--;
					continue;
				}
			}
			if (soap_flag_sp__KerberosToken1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosp__Token(soap, "sp:KerberosToken", &a->wsp__Content::sp__KerberosToken, "sp:Token"))
				{	soap_flag_sp__KerberosToken1--;
					continue;
				}
			}
			if (soap_flag_sp__SpnegoContextToken1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosp__Token(soap, "sp:SpnegoContextToken", &a->wsp__Content::sp__SpnegoContextToken, "sp:Token"))
				{	soap_flag_sp__SpnegoContextToken1--;
					continue;
				}
			}
			if (soap_flag_sp__SecurityContextToken1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosp__Token(soap, "sp:SecurityContextToken", &a->wsp__Content::sp__SecurityContextToken, "sp:Token"))
				{	soap_flag_sp__SecurityContextToken1--;
					continue;
				}
			}
			if (soap_flag_sp__SecureConversationToken1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosp__Token(soap, "sp:SecureConversationToken", &a->wsp__Content::sp__SecureConversationToken, "sp:Token"))
				{	soap_flag_sp__SecureConversationToken1--;
					continue;
				}
			}
			if (soap_flag_sp__SamlToken1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosp__Token(soap, "sp:SamlToken", &a->wsp__Content::sp__SamlToken, "sp:Token"))
				{	soap_flag_sp__SamlToken1--;
					continue;
				}
			}
			if (soap_flag_sp__RelToken1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosp__Token(soap, "sp:RelToken", &a->wsp__Content::sp__RelToken, "sp:Token"))
				{	soap_flag_sp__RelToken1--;
					continue;
				}
			}
			if (soap_flag_sp__HttpsToken1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosp__Token(soap, "sp:HttpsToken", &a->wsp__Content::sp__HttpsToken, "sp:Token"))
				{	soap_flag_sp__HttpsToken1--;
					continue;
				}
			}
			if (soap_flag_sp__KeyValueToken1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosp__Token(soap, "sp:KeyValueToken", &a->wsp__Content::sp__KeyValueToken, "sp:Token"))
				{	soap_flag_sp__KeyValueToken1--;
					continue;
				}
			}
			if (soap_flag_sp__TransportBinding1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsp__Assertion(soap, "sp:TransportBinding", &a->wsp__Content::sp__TransportBinding, "wsp:Assertion"))
				{	soap_flag_sp__TransportBinding1--;
					continue;
				}
			}
			if (soap_flag_sp__TransportToken1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsp__Assertion(soap, "sp:TransportToken", &a->wsp__Content::sp__TransportToken, "wsp:Assertion"))
				{	soap_flag_sp__TransportToken1--;
					continue;
				}
			}
			if (soap_flag_sp__AlgorithmSuite1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsp__Assertion(soap, "sp:AlgorithmSuite", &a->wsp__Content::sp__AlgorithmSuite, "wsp:Assertion"))
				{	soap_flag_sp__AlgorithmSuite1--;
					continue;
				}
			}
			if (soap_flag_sp__Layout1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsp__Assertion(soap, "sp:Layout", &a->wsp__Content::sp__Layout, "wsp:Assertion"))
				{	soap_flag_sp__Layout1--;
					continue;
				}
			}
			if (soap_flag_sp__SymmetricBinding1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsp__Assertion(soap, "sp:SymmetricBinding", &a->wsp__Content::sp__SymmetricBinding, "wsp:Assertion"))
				{	soap_flag_sp__SymmetricBinding1--;
					continue;
				}
			}
			if (soap_flag_sp__AsymmetricBinding1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsp__Assertion(soap, "sp:AsymmetricBinding", &a->wsp__Content::sp__AsymmetricBinding, "wsp:Assertion"))
				{	soap_flag_sp__AsymmetricBinding1--;
					continue;
				}
			}
			if (soap_flag_sp__ProtectionToken1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsp__Assertion(soap, "sp:ProtectionToken", &a->wsp__Content::sp__ProtectionToken, "wsp:Assertion"))
				{	soap_flag_sp__ProtectionToken1--;
					continue;
				}
			}
			if (soap_flag_sp__InitiatorToken1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsp__Assertion(soap, "sp:InitiatorToken", &a->wsp__Content::sp__InitiatorToken, "wsp:Assertion"))
				{	soap_flag_sp__InitiatorToken1--;
					continue;
				}
			}
			if (soap_flag_sp__InitiatorSignatureToken1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsp__Assertion(soap, "sp:InitiatorSignatureToken", &a->wsp__Content::sp__InitiatorSignatureToken, "wsp:Assertion"))
				{	soap_flag_sp__InitiatorSignatureToken1--;
					continue;
				}
			}
			if (soap_flag_sp__InitiatorEncryptionToken1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsp__Assertion(soap, "sp:InitiatorEncryptionToken", &a->wsp__Content::sp__InitiatorEncryptionToken, "wsp:Assertion"))
				{	soap_flag_sp__InitiatorEncryptionToken1--;
					continue;
				}
			}
			if (soap_flag_sp__RecipientToken1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsp__Assertion(soap, "sp:RecipientToken", &a->wsp__Content::sp__RecipientToken, "wsp:Assertion"))
				{	soap_flag_sp__RecipientToken1--;
					continue;
				}
			}
			if (soap_flag_sp__SupportingTokens1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsp__Assertion(soap, "sp:SupportingTokens", &a->wsp__Content::sp__SupportingTokens, "wsp:Assertion"))
				{	soap_flag_sp__SupportingTokens1--;
					continue;
				}
			}
			if (soap_flag_sp__SignedSupportingTokens1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsp__Assertion(soap, "sp:SignedSupportingTokens", &a->wsp__Content::sp__SignedSupportingTokens, "wsp:Assertion"))
				{	soap_flag_sp__SignedSupportingTokens1--;
					continue;
				}
			}
			if (soap_flag_sp__EndorsingSupportingTokens1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsp__Assertion(soap, "sp:EndorsingSupportingTokens", &a->wsp__Content::sp__EndorsingSupportingTokens, "wsp:Assertion"))
				{	soap_flag_sp__EndorsingSupportingTokens1--;
					continue;
				}
			}
			if (soap_flag_sp__SignedEndorsingSupportingTokens1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsp__Assertion(soap, "sp:SignedEndorsingSupportingTokens", &a->wsp__Content::sp__SignedEndorsingSupportingTokens, "wsp:Assertion"))
				{	soap_flag_sp__SignedEndorsingSupportingTokens1--;
					continue;
				}
			}
			if (soap_flag_sp__SignedEncryptedSupportingTokens1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsp__Assertion(soap, "sp:SignedEncryptedSupportingTokens", &a->wsp__Content::sp__SignedEncryptedSupportingTokens, "wsp:Assertion"))
				{	soap_flag_sp__SignedEncryptedSupportingTokens1--;
					continue;
				}
			}
			if (soap_flag_sp__EncryptedSupportingTokens1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsp__Assertion(soap, "sp:EncryptedSupportingTokens", &a->wsp__Content::sp__EncryptedSupportingTokens, "wsp:Assertion"))
				{	soap_flag_sp__EncryptedSupportingTokens1--;
					continue;
				}
			}
			if (soap_flag_sp__EndorsingEncryptedSupportingTokens1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsp__Assertion(soap, "sp:EndorsingEncryptedSupportingTokens", &a->wsp__Content::sp__EndorsingEncryptedSupportingTokens, "wsp:Assertion"))
				{	soap_flag_sp__EndorsingEncryptedSupportingTokens1--;
					continue;
				}
			}
			if (soap_flag_sp__SignedEndorsingEncryptedSupportingTokens1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsp__Assertion(soap, "sp:SignedEndorsingEncryptedSupportingTokens", &a->wsp__Content::sp__SignedEndorsingEncryptedSupportingTokens, "wsp:Assertion"))
				{	soap_flag_sp__SignedEndorsingEncryptedSupportingTokens1--;
					continue;
				}
			}
			if (soap_flag_sp__Wss101 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsp__Assertion(soap, "sp:Wss10", &a->wsp__Content::sp__Wss10, "wsp:Assertion"))
				{	soap_flag_sp__Wss101--;
					continue;
				}
			}
			if (soap_flag_sp__Wss111 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsp__Assertion(soap, "sp:Wss11", &a->wsp__Content::sp__Wss11, "wsp:Assertion"))
				{	soap_flag_sp__Wss111--;
					continue;
				}
			}
			if (soap_flag_sp__Trust101 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsp__Assertion(soap, "sp:Trust10", &a->wsp__Content::sp__Trust10, "wsp:Assertion"))
				{	soap_flag_sp__Trust101--;
					continue;
				}
			}
			if (soap_flag_sp__Trust131 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsp__Assertion(soap, "sp:Trust13", &a->wsp__Content::sp__Trust13, "wsp:Assertion"))
				{	soap_flag_sp__Trust131--;
					continue;
				}
			}
			if (soap_flag_sp__BootstrapPolicy1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsp__Content(soap, "sp:BootstrapPolicy", &a->wsp__Content::sp__BootstrapPolicy, "wsp:Content"))
				{	soap_flag_sp__BootstrapPolicy1--;
					continue;
				}
			}
			if (soap_flag_wsaw__UsingAddressing1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "wsaw:UsingAddressing", (char**)&a->wsp__Content::wsaw__UsingAddressing, "xsd:string"))
				{	soap_flag_wsaw__UsingAddressing1--;
					continue;
				}
			}
			if (soap_flag_wsam__Addressing1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsp__Assertion(soap, "wsam:Addressing", &a->wsp__Content::wsam__Addressing, "wsp:Assertion"))
				{	soap_flag_wsam__Addressing1--;
					continue;
				}
			}
			if (soap_flag_wsrmp__RMAssertion_1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsrmp__RMAssertion(soap, "wsrmp:RMAssertion", &a->wsp__Content::wsrmp__RMAssertion_, "wsrmp:RMAssertion"))
				{	soap_flag_wsrmp__RMAssertion_1--;
					continue;
				}
			}
			if (soap_flag_wsrmp__DeliveryAssurance1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsrmp__RMAssertion(soap, "wsrmp:DeliveryAssurance", &a->wsp__Content::wsrmp__DeliveryAssurance, "wsrmp:RMAssertion"))
				{	soap_flag_wsrmp__DeliveryAssurance1--;
					continue;
				}
			}
			if (soap_flag_wsrmp__AtLeastOnce1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "wsrmp:AtLeastOnce", (char**)&a->wsp__Content::wsrmp__AtLeastOnce, "xsd:string"))
				{	soap_flag_wsrmp__AtLeastOnce1--;
					continue;
				}
			}
			if (soap_flag_wsrmp__AtMostOnce1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "wsrmp:AtMostOnce", (char**)&a->wsp__Content::wsrmp__AtMostOnce, "xsd:string"))
				{	soap_flag_wsrmp__AtMostOnce1--;
					continue;
				}
			}
			if (soap_flag_wsrmp__ExactlyOnce1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "wsrmp:ExactlyOnce", (char**)&a->wsp__Content::wsrmp__ExactlyOnce, "xsd:string"))
				{	soap_flag_wsrmp__ExactlyOnce1--;
					continue;
				}
			}
			if (soap_flag_wsrmp__InOrder1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "wsrmp:InOrder", (char**)&a->wsp__Content::wsrmp__InOrder, "xsd:string"))
				{	soap_flag_wsrmp__InOrder1--;
					continue;
				}
			}
			if (soap_flag_wsrmp5__RMAssertion_1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsrmp5__RMAssertion(soap, "wsrmp5:RMAssertion", &a->wsp__Content::wsrmp5__RMAssertion_, "wsrmp5:RMAssertion"))
				{	soap_flag_wsrmp5__RMAssertion_1--;
					continue;
				}
			}
			if (soap_flag_wsrmp5__DeliveryAssurance1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsrmp5__RMAssertion(soap, "wsrmp5:DeliveryAssurance", &a->wsp__Content::wsrmp5__DeliveryAssurance, "wsrmp5:RMAssertion"))
				{	soap_flag_wsrmp5__DeliveryAssurance1--;
					continue;
				}
			}
			if (soap_flag_wsrmp5__AtLeastOnce1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "wsrmp5:AtLeastOnce", (char**)&a->wsp__Content::wsrmp5__AtLeastOnce, "xsd:string"))
				{	soap_flag_wsrmp5__AtLeastOnce1--;
					continue;
				}
			}
			if (soap_flag_wsrmp5__AtMostOnce1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "wsrmp5:AtMostOnce", (char**)&a->wsp__Content::wsrmp5__AtMostOnce, "xsd:string"))
				{	soap_flag_wsrmp5__AtMostOnce1--;
					continue;
				}
			}
			if (soap_flag_wsrmp5__ExactlyOnce1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "wsrmp5:ExactlyOnce", (char**)&a->wsp__Content::wsrmp5__ExactlyOnce, "xsd:string"))
				{	soap_flag_wsrmp5__ExactlyOnce1--;
					continue;
				}
			}
			if (soap_flag_wsrmp5__InOrder1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "wsrmp5:InOrder", (char**)&a->wsp__Content::wsrmp5__InOrder, "xsd:string"))
				{	soap_flag_wsrmp5__InOrder1--;
					continue;
				}
			}
			if (soap_flag_sp__NoPassword1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsp__Assertion(soap, "sp:NoPassword", &a->wsp__Content::sp__NoPassword, "wsp:Assertion"))
				{	soap_flag_sp__NoPassword1--;
					continue;
				}
			}
			if (soap_flag_sp__HashPassword1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsp__Assertion(soap, "sp:HashPassword", &a->wsp__Content::sp__HashPassword, "wsp:Assertion"))
				{	soap_flag_sp__HashPassword1--;
					continue;
				}
			}
			if (soap_flag_sp__IncludeTimestamp1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsp__Assertion(soap, "sp:IncludeTimestamp", &a->wsp__Content::sp__IncludeTimestamp, "wsp:Assertion"))
				{	soap_flag_sp__IncludeTimestamp1--;
					continue;
				}
			}
			if (soap_flag_sp__EncryptBeforeSigning1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsp__Assertion(soap, "sp:EncryptBeforeSigning", &a->wsp__Content::sp__EncryptBeforeSigning, "wsp:Assertion"))
				{	soap_flag_sp__EncryptBeforeSigning1--;
					continue;
				}
			}
			if (soap_flag_sp__EncryptSignature1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsp__Assertion(soap, "sp:EncryptSignature", &a->wsp__Content::sp__EncryptSignature, "wsp:Assertion"))
				{	soap_flag_sp__EncryptSignature1--;
					continue;
				}
			}
			if (soap_flag_sp__ProtectTokens1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsp__Assertion(soap, "sp:ProtectTokens", &a->wsp__Content::sp__ProtectTokens, "wsp:Assertion"))
				{	soap_flag_sp__ProtectTokens1--;
					continue;
				}
			}
			if (soap_flag_sp__OnlySignEntireHeadersAndBody1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsp__Assertion(soap, "sp:OnlySignEntireHeadersAndBody", &a->wsp__Content::sp__OnlySignEntireHeadersAndBody, "wsp:Assertion"))
				{	soap_flag_sp__OnlySignEntireHeadersAndBody1--;
					continue;
				}
			}
			if (soap_flag_sp__RequireDerivedKeys1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:RequireDerivedKeys", (char**)&a->wsp__Content::sp__RequireDerivedKeys, "xsd:string"))
				{	soap_flag_sp__RequireDerivedKeys1--;
					continue;
				}
			}
			if (soap_flag_sp__RequireImpliedDerivedKeys1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:RequireImpliedDerivedKeys", (char**)&a->wsp__Content::sp__RequireImpliedDerivedKeys, "xsd:string"))
				{	soap_flag_sp__RequireImpliedDerivedKeys1--;
					continue;
				}
			}
			if (soap_flag_sp__RequireExplicitDerivedKeys1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:RequireExplicitDerivedKeys", (char**)&a->wsp__Content::sp__RequireExplicitDerivedKeys, "xsd:string"))
				{	soap_flag_sp__RequireExplicitDerivedKeys1--;
					continue;
				}
			}
			if (soap_flag_sp__WssUsernameToken101 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:WssUsernameToken10", (char**)&a->wsp__Content::sp__WssUsernameToken10, "xsd:string"))
				{	soap_flag_sp__WssUsernameToken101--;
					continue;
				}
			}
			if (soap_flag_sp__WssUsernameToken111 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:WssUsernameToken11", (char**)&a->wsp__Content::sp__WssUsernameToken11, "xsd:string"))
				{	soap_flag_sp__WssUsernameToken111--;
					continue;
				}
			}
			if (soap_flag_sp__RequireExternalReference1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:RequireExternalReference", (char**)&a->wsp__Content::sp__RequireExternalReference, "xsd:string"))
				{	soap_flag_sp__RequireExternalReference1--;
					continue;
				}
			}
			if (soap_flag_sp__RequireInternalReference1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:RequireInternalReference", (char**)&a->wsp__Content::sp__RequireInternalReference, "xsd:string"))
				{	soap_flag_sp__RequireInternalReference1--;
					continue;
				}
			}
			if (soap_flag_sp__RequireKeyIdentifierReference1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:RequireKeyIdentifierReference", (char**)&a->wsp__Content::sp__RequireKeyIdentifierReference, "xsd:string"))
				{	soap_flag_sp__RequireKeyIdentifierReference1--;
					continue;
				}
			}
			if (soap_flag_sp__RequireIssuerSerialReference1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:RequireIssuerSerialReference", (char**)&a->wsp__Content::sp__RequireIssuerSerialReference, "xsd:string"))
				{	soap_flag_sp__RequireIssuerSerialReference1--;
					continue;
				}
			}
			if (soap_flag_sp__RequireEmbeddedTokenReference1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:RequireEmbeddedTokenReference", (char**)&a->wsp__Content::sp__RequireEmbeddedTokenReference, "xsd:string"))
				{	soap_flag_sp__RequireEmbeddedTokenReference1--;
					continue;
				}
			}
			if (soap_flag_sp__RequireThumbprintReference1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:RequireThumbprintReference", (char**)&a->wsp__Content::sp__RequireThumbprintReference, "xsd:string"))
				{	soap_flag_sp__RequireThumbprintReference1--;
					continue;
				}
			}
			if (soap_flag_sp__WssX509V3Token101 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:WssX509V3Token10", (char**)&a->wsp__Content::sp__WssX509V3Token10, "xsd:string"))
				{	soap_flag_sp__WssX509V3Token101--;
					continue;
				}
			}
			if (soap_flag_sp__WssX509Pkcs7Token101 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:WssX509Pkcs7Token10", (char**)&a->wsp__Content::sp__WssX509Pkcs7Token10, "xsd:string"))
				{	soap_flag_sp__WssX509Pkcs7Token101--;
					continue;
				}
			}
			if (soap_flag_sp__WssX509PkiPathV1Token101 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:WssX509PkiPathV1Token10", (char**)&a->wsp__Content::sp__WssX509PkiPathV1Token10, "xsd:string"))
				{	soap_flag_sp__WssX509PkiPathV1Token101--;
					continue;
				}
			}
			if (soap_flag_sp__WssX509V1Token111 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:WssX509V1Token11", (char**)&a->wsp__Content::sp__WssX509V1Token11, "xsd:string"))
				{	soap_flag_sp__WssX509V1Token111--;
					continue;
				}
			}
			if (soap_flag_sp__WssX509V3Token111 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:WssX509V3Token11", (char**)&a->wsp__Content::sp__WssX509V3Token11, "xsd:string"))
				{	soap_flag_sp__WssX509V3Token111--;
					continue;
				}
			}
			if (soap_flag_sp__WssX509Pkcs7Token111 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:WssX509Pkcs7Token11", (char**)&a->wsp__Content::sp__WssX509Pkcs7Token11, "xsd:string"))
				{	soap_flag_sp__WssX509Pkcs7Token111--;
					continue;
				}
			}
			if (soap_flag_sp__WssX509PkiPathV1Token111 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:WssX509PkiPathV1Token11", (char**)&a->wsp__Content::sp__WssX509PkiPathV1Token11, "xsd:string"))
				{	soap_flag_sp__WssX509PkiPathV1Token111--;
					continue;
				}
			}
			if (soap_flag_sp__WssKerberosV5ApReqToken111 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:WssKerberosV5ApReqToken11", (char**)&a->wsp__Content::sp__WssKerberosV5ApReqToken11, "xsd:string"))
				{	soap_flag_sp__WssKerberosV5ApReqToken111--;
					continue;
				}
			}
			if (soap_flag_sp__WssGssKerberosV5ApReqToken111 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:WssGssKerberosV5ApReqToken11", (char**)&a->wsp__Content::sp__WssGssKerberosV5ApReqToken11, "xsd:string"))
				{	soap_flag_sp__WssGssKerberosV5ApReqToken111--;
					continue;
				}
			}
			if (soap_flag_sp__WssRelV10Token101 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:WssRelV10Token10", (char**)&a->wsp__Content::sp__WssRelV10Token10, "xsd:string"))
				{	soap_flag_sp__WssRelV10Token101--;
					continue;
				}
			}
			if (soap_flag_sp__WssRelV20Token101 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:WssRelV20Token10", (char**)&a->wsp__Content::sp__WssRelV20Token10, "xsd:string"))
				{	soap_flag_sp__WssRelV20Token101--;
					continue;
				}
			}
			if (soap_flag_sp__WssRelV10Token111 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:WssRelV10Token11", (char**)&a->wsp__Content::sp__WssRelV10Token11, "xsd:string"))
				{	soap_flag_sp__WssRelV10Token111--;
					continue;
				}
			}
			if (soap_flag_sp__WssRelV20Token111 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:WssRelV20Token11", (char**)&a->wsp__Content::sp__WssRelV20Token11, "xsd:string"))
				{	soap_flag_sp__WssRelV20Token111--;
					continue;
				}
			}
			if (soap_flag_sp__MustNotSendCancel1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:MustNotSendCancel", (char**)&a->wsp__Content::sp__MustNotSendCancel, "xsd:string"))
				{	soap_flag_sp__MustNotSendCancel1--;
					continue;
				}
			}
			if (soap_flag_sp__MustNotSendAmend1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:MustNotSendAmend", (char**)&a->wsp__Content::sp__MustNotSendAmend, "xsd:string"))
				{	soap_flag_sp__MustNotSendAmend1--;
					continue;
				}
			}
			if (soap_flag_sp__MustNotSendRenew1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:MustNotSendRenew", (char**)&a->wsp__Content::sp__MustNotSendRenew, "xsd:string"))
				{	soap_flag_sp__MustNotSendRenew1--;
					continue;
				}
			}
			if (soap_flag_sp__MustSupportRefKeyIdentifier1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:MustSupportRefKeyIdentifier", (char**)&a->wsp__Content::sp__MustSupportRefKeyIdentifier, "xsd:string"))
				{	soap_flag_sp__MustSupportRefKeyIdentifier1--;
					continue;
				}
			}
			if (soap_flag_sp__MustSupportRefIssuerSerial1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:MustSupportRefIssuerSerial", (char**)&a->wsp__Content::sp__MustSupportRefIssuerSerial, "xsd:string"))
				{	soap_flag_sp__MustSupportRefIssuerSerial1--;
					continue;
				}
			}
			if (soap_flag_sp__MustSupportRefExternalURI1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:MustSupportRefExternalURI", (char**)&a->wsp__Content::sp__MustSupportRefExternalURI, "xsd:string"))
				{	soap_flag_sp__MustSupportRefExternalURI1--;
					continue;
				}
			}
			if (soap_flag_sp__MustSupportRefEmbeddedToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:MustSupportRefEmbeddedToken", (char**)&a->wsp__Content::sp__MustSupportRefEmbeddedToken, "xsd:string"))
				{	soap_flag_sp__MustSupportRefEmbeddedToken1--;
					continue;
				}
			}
			if (soap_flag_sp__MustSupportRefThumbprint1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:MustSupportRefThumbprint", (char**)&a->wsp__Content::sp__MustSupportRefThumbprint, "xsd:string"))
				{	soap_flag_sp__MustSupportRefThumbprint1--;
					continue;
				}
			}
			if (soap_flag_sp__MustSupportRefEncryptedKey1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:MustSupportRefEncryptedKey", (char**)&a->wsp__Content::sp__MustSupportRefEncryptedKey, "xsd:string"))
				{	soap_flag_sp__MustSupportRefEncryptedKey1--;
					continue;
				}
			}
			if (soap_flag_sp__RequireSignatureConfirmation1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:RequireSignatureConfirmation", (char**)&a->wsp__Content::sp__RequireSignatureConfirmation, "xsd:string"))
				{	soap_flag_sp__RequireSignatureConfirmation1--;
					continue;
				}
			}
			if (soap_flag_sp__MustSupportClientChallenge1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:MustSupportClientChallenge", (char**)&a->wsp__Content::sp__MustSupportClientChallenge, "xsd:string"))
				{	soap_flag_sp__MustSupportClientChallenge1--;
					continue;
				}
			}
			if (soap_flag_sp__MustSupportServerChallenge1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:MustSupportServerChallenge", (char**)&a->wsp__Content::sp__MustSupportServerChallenge, "xsd:string"))
				{	soap_flag_sp__MustSupportServerChallenge1--;
					continue;
				}
			}
			if (soap_flag_sp__RequireClientEntropy1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:RequireClientEntropy", (char**)&a->wsp__Content::sp__RequireClientEntropy, "xsd:string"))
				{	soap_flag_sp__RequireClientEntropy1--;
					continue;
				}
			}
			if (soap_flag_sp__RequireServerEntropy1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:RequireServerEntropy", (char**)&a->wsp__Content::sp__RequireServerEntropy, "xsd:string"))
				{	soap_flag_sp__RequireServerEntropy1--;
					continue;
				}
			}
			if (soap_flag_sp__MustSupportIssuedTokens1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:MustSupportIssuedTokens", (char**)&a->wsp__Content::sp__MustSupportIssuedTokens, "xsd:string"))
				{	soap_flag_sp__MustSupportIssuedTokens1--;
					continue;
				}
			}
			if (soap_flag_sp__RequireRequestSecurityTokenCollection1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:RequireRequestSecurityTokenCollection", (char**)&a->wsp__Content::sp__RequireRequestSecurityTokenCollection, "xsd:string"))
				{	soap_flag_sp__RequireRequestSecurityTokenCollection1--;
					continue;
				}
			}
			if (soap_flag_sp__RequireAppliesTo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:RequireAppliesTo", (char**)&a->wsp__Content::sp__RequireAppliesTo, "xsd:string"))
				{	soap_flag_sp__RequireAppliesTo1--;
					continue;
				}
			}
			if (soap_flag_sp__RequireExternalUriReference1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:RequireExternalUriReference", (char**)&a->wsp__Content::sp__RequireExternalUriReference, "xsd:string"))
				{	soap_flag_sp__RequireExternalUriReference1--;
					continue;
				}
			}
			if (soap_flag_sp__SC13SecurityContextToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:SC13SecurityContextToken", (char**)&a->wsp__Content::sp__SC13SecurityContextToken, "xsd:string"))
				{	soap_flag_sp__SC13SecurityContextToken1--;
					continue;
				}
			}
			if (soap_flag_sp__Strict1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:Strict", (char**)&a->wsp__Content::sp__Strict, "xsd:string"))
				{	soap_flag_sp__Strict1--;
					continue;
				}
			}
			if (soap_flag_sp__Lax1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:Lax", (char**)&a->wsp__Content::sp__Lax, "xsd:string"))
				{	soap_flag_sp__Lax1--;
					continue;
				}
			}
			if (soap_flag_sp__LaxTsFirst1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:LaxTsFirst", (char**)&a->wsp__Content::sp__LaxTsFirst, "xsd:string"))
				{	soap_flag_sp__LaxTsFirst1--;
					continue;
				}
			}
			if (soap_flag_sp__LaxTsLast1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:LaxTsLast", (char**)&a->wsp__Content::sp__LaxTsLast, "xsd:string"))
				{	soap_flag_sp__LaxTsLast1--;
					continue;
				}
			}
			if (soap_flag_sp__HttpBasicAuthentication1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:HttpBasicAuthentication", (char**)&a->wsp__Content::sp__HttpBasicAuthentication, "xsd:string"))
				{	soap_flag_sp__HttpBasicAuthentication1--;
					continue;
				}
			}
			if (soap_flag_sp__HttpDigestAuthentication1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:HttpDigestAuthentication", (char**)&a->wsp__Content::sp__HttpDigestAuthentication, "xsd:string"))
				{	soap_flag_sp__HttpDigestAuthentication1--;
					continue;
				}
			}
			if (soap_flag_sp__RequireClientCertificate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:RequireClientCertificate", (char**)&a->wsp__Content::sp__RequireClientCertificate, "xsd:string"))
				{	soap_flag_sp__RequireClientCertificate1--;
					continue;
				}
			}
			if (soap_flag_sp__Basic2561 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:Basic256", (char**)&a->wsp__Content::sp__Basic256, "xsd:string"))
				{	soap_flag_sp__Basic2561--;
					continue;
				}
			}
			if (soap_flag_sp__Basic1921 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:Basic192", (char**)&a->wsp__Content::sp__Basic192, "xsd:string"))
				{	soap_flag_sp__Basic1921--;
					continue;
				}
			}
			if (soap_flag_sp__Basic1281 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:Basic128", (char**)&a->wsp__Content::sp__Basic128, "xsd:string"))
				{	soap_flag_sp__Basic1281--;
					continue;
				}
			}
			if (soap_flag_sp__TripleDes1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:TripleDes", (char**)&a->wsp__Content::sp__TripleDes, "xsd:string"))
				{	soap_flag_sp__TripleDes1--;
					continue;
				}
			}
			if (soap_flag_sp__Basic256Rsa151 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:Basic256Rsa15", (char**)&a->wsp__Content::sp__Basic256Rsa15, "xsd:string"))
				{	soap_flag_sp__Basic256Rsa151--;
					continue;
				}
			}
			if (soap_flag_sp__Basic192Rsa151 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:Basic192Rsa15", (char**)&a->wsp__Content::sp__Basic192Rsa15, "xsd:string"))
				{	soap_flag_sp__Basic192Rsa151--;
					continue;
				}
			}
			if (soap_flag_sp__Basic128Rsa151 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:Basic128Rsa15", (char**)&a->wsp__Content::sp__Basic128Rsa15, "xsd:string"))
				{	soap_flag_sp__Basic128Rsa151--;
					continue;
				}
			}
			if (soap_flag_sp__TripleDesRsa151 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:TripleDesRsa15", (char**)&a->wsp__Content::sp__TripleDesRsa15, "xsd:string"))
				{	soap_flag_sp__TripleDesRsa151--;
					continue;
				}
			}
			if (soap_flag_sp__Basic256Sha2561 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:Basic256Sha256", (char**)&a->wsp__Content::sp__Basic256Sha256, "xsd:string"))
				{	soap_flag_sp__Basic256Sha2561--;
					continue;
				}
			}
			if (soap_flag_sp__Basic192Sha2561 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:Basic192Sha256", (char**)&a->wsp__Content::sp__Basic192Sha256, "xsd:string"))
				{	soap_flag_sp__Basic192Sha2561--;
					continue;
				}
			}
			if (soap_flag_sp__Basic128Sha2561 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:Basic128Sha256", (char**)&a->wsp__Content::sp__Basic128Sha256, "xsd:string"))
				{	soap_flag_sp__Basic128Sha2561--;
					continue;
				}
			}
			if (soap_flag_sp__TripleDesSha2561 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:TripleDesSha256", (char**)&a->wsp__Content::sp__TripleDesSha256, "xsd:string"))
				{	soap_flag_sp__TripleDesSha2561--;
					continue;
				}
			}
			if (soap_flag_sp__Basic256Sha256Rsa151 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:Basic256Sha256Rsa15", (char**)&a->wsp__Content::sp__Basic256Sha256Rsa15, "xsd:string"))
				{	soap_flag_sp__Basic256Sha256Rsa151--;
					continue;
				}
			}
			if (soap_flag_sp__Basic192Sha256Rsa151 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:Basic192Sha256Rsa15", (char**)&a->wsp__Content::sp__Basic192Sha256Rsa15, "xsd:string"))
				{	soap_flag_sp__Basic192Sha256Rsa151--;
					continue;
				}
			}
			if (soap_flag_sp__Basic128Sha256Rsa151 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:Basic128Sha256Rsa15", (char**)&a->wsp__Content::sp__Basic128Sha256Rsa15, "xsd:string"))
				{	soap_flag_sp__Basic128Sha256Rsa151--;
					continue;
				}
			}
			if (soap_flag_sp__TripleDesSha256Rsa151 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:TripleDesSha256Rsa15", (char**)&a->wsp__Content::sp__TripleDesSha256Rsa15, "xsd:string"))
				{	soap_flag_sp__TripleDesSha256Rsa151--;
					continue;
				}
			}
			if (soap_flag_sp__InclusiveC14N1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:InclusiveC14N", (char**)&a->wsp__Content::sp__InclusiveC14N, "xsd:string"))
				{	soap_flag_sp__InclusiveC14N1--;
					continue;
				}
			}
			if (soap_flag_sp__SOAPNormalization101 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:SOAPNormalization10", (char**)&a->wsp__Content::sp__SOAPNormalization10, "xsd:string"))
				{	soap_flag_sp__SOAPNormalization101--;
					continue;
				}
			}
			if (soap_flag_sp__STRTransform101 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:STRTransform10", (char**)&a->wsp__Content::sp__STRTransform10, "xsd:string"))
				{	soap_flag_sp__STRTransform101--;
					continue;
				}
			}
			if (soap_flag_sp__Path101 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:Path10", (char**)&a->wsp__Content::sp__Path10, "xsd:string"))
				{	soap_flag_sp__Path101--;
					continue;
				}
			}
			if (soap_flag_sp__XPathFilter201 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:XPathFilter20", (char**)&a->wsp__Content::sp__XPathFilter20, "xsd:string"))
				{	soap_flag_sp__XPathFilter201--;
					continue;
				}
			}
			if (soap_flag_sp__AbsXPath1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:AbsXPath", (char**)&a->wsp__Content::sp__AbsXPath, "xsd:string"))
				{	soap_flag_sp__AbsXPath1--;
					continue;
				}
			}
			if (soap_flag_wsam__AnonymousResponses1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "wsam:AnonymousResponses", (char**)&a->wsp__Content::wsam__AnonymousResponses, "xsd:string"))
				{	soap_flag_wsam__AnonymousResponses1--;
					continue;
				}
			}
			if (soap_flag_wsam__NonAnonymousResponses1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "wsam:NonAnonymousResponses", (char**)&a->wsp__Content::wsam__NonAnonymousResponses, "xsd:string"))
				{	soap_flag_wsam__NonAnonymousResponses1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->wsp__Content::__any, ""))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wsp__Content *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsp__Content, SOAP_TYPE_wsp__Content, sizeof(wsp__Content), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsp__Content * SOAP_FMAC2 wsdl_instantiate_wsp__Content(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_wsp__Content(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (soap && type && !soap_match_tag(soap, type, "wsp:Policy"))
		return wsdl_instantiate_wsp__Policy(soap, n, NULL, NULL, size);
	wsp__Content *p;
	size_t k = sizeof(wsp__Content);
	if (n < 0)
	{	p = SOAP_NEW(wsp__Content);
	}
	else
	{	p = SOAP_NEW_ARRAY(wsp__Content, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsp__Content location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_wsp__Content, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int wsp__Content::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsp__Content(soap, tag ? tag : "wsp:Content", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsp__Content::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsp__Content(soap, this, tag, type);
}

SOAP_FMAC3 wsp__Content * SOAP_FMAC4 soap_get_wsp__Content(struct soap *soap, wsp__Content *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsp__Content(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsp__Policy::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->wsp__Content::soap_default(soap);
	soap_default_xsd__anyURI(soap, &this->wsp__Policy::xml__base);
	soap_default_xsd__string(soap, &this->wsp__Policy::wsu__Id);
	soap_default_xsd__anyURI(soap, &this->wsp__Policy::TargetNamespace);
}

void wsp__Policy::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->wsp__Content::soap_serialize(soap);
#endif
}

int wsp__Policy::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsp__Policy(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsp__Policy(struct soap *soap, const char *tag, int id, const wsp__Policy *a, const char *type)
{
	if (((wsp__Policy*)a)->xml__base)
		soap_set_attr(soap, "xml:base", soap_xsd__anyURI2s(soap, ((wsp__Policy*)a)->xml__base), 1);
	if (((wsp__Policy*)a)->wsu__Id)
		soap_set_attr(soap, "wsu:Id", soap_xsd__string2s(soap, ((wsp__Policy*)a)->wsu__Id), 1);
	if (((wsp__Policy*)a)->TargetNamespace)
		soap_set_attr(soap, "TargetNamespace", soap_xsd__anyURI2s(soap, ((wsp__Policy*)a)->TargetNamespace), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsp__Policy), type ? type : "wsp:Policy"))
		return soap->error;
	if (soap_out_PointerTowsp__Policy(soap, "wsp:Policy", -1, &a->wsp__Content::Policy, ""))
		return soap->error;
	if (soap_out_PointerTowsp__PolicyReference(soap, "wsp:PolicyReference", -1, &a->wsp__Content::PolicyReference, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTowsp__Content(soap, "wsp:All", -1, &a->wsp__Content::All, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTowsp__Content(soap, "wsp:ExactlyOne", -1, &a->wsp__Content::ExactlyOne, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfsp__Parts(soap, "sp:SignedParts", -1, &a->wsp__Content::sp__SignedParts, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfsp__Parts(soap, "sp:EncryptedParts", -1, &a->wsp__Content::sp__EncryptedParts, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfsp__Parts(soap, "sp:RequiredParts", -1, &a->wsp__Content::sp__RequiredParts, ""))
		return soap->error;
	if (soap_out_PointerTosp__Elements(soap, "sp:SignedElements", -1, &a->wsp__Content::sp__SignedElements, ""))
		return soap->error;
	if (soap_out_PointerTosp__Elements(soap, "sp:EncryptedElements", -1, &a->wsp__Content::sp__EncryptedElements, ""))
		return soap->error;
	if (soap_out_PointerTosp__Elements(soap, "sp:ContentEncryptedElements", -1, &a->wsp__Content::sp__ContentEncryptedElements, ""))
		return soap->error;
	if (soap_out_PointerTosp__Elements(soap, "sp:RequiredElements", -1, &a->wsp__Content::sp__RequiredElements, ""))
		return soap->error;
	if (soap_out_PointerTosp__Token(soap, "sp:UsernameToken", -1, &a->wsp__Content::sp__UsernameToken, ""))
		return soap->error;
	if (soap_out_PointerTosp__Token(soap, "sp:IssuedToken", -1, &a->wsp__Content::sp__IssuedToken, ""))
		return soap->error;
	if (soap_out_PointerTosp__Token(soap, "sp:X509Token", -1, &a->wsp__Content::sp__X509Token, ""))
		return soap->error;
	if (soap_out_PointerTosp__Token(soap, "sp:KerberosToken", -1, &a->wsp__Content::sp__KerberosToken, ""))
		return soap->error;
	if (soap_out_PointerTosp__Token(soap, "sp:SpnegoContextToken", -1, &a->wsp__Content::sp__SpnegoContextToken, ""))
		return soap->error;
	if (soap_out_PointerTosp__Token(soap, "sp:SecurityContextToken", -1, &a->wsp__Content::sp__SecurityContextToken, ""))
		return soap->error;
	if (soap_out_PointerTosp__Token(soap, "sp:SecureConversationToken", -1, &a->wsp__Content::sp__SecureConversationToken, ""))
		return soap->error;
	if (soap_out_PointerTosp__Token(soap, "sp:SamlToken", -1, &a->wsp__Content::sp__SamlToken, ""))
		return soap->error;
	if (soap_out_PointerTosp__Token(soap, "sp:RelToken", -1, &a->wsp__Content::sp__RelToken, ""))
		return soap->error;
	if (soap_out_PointerTosp__Token(soap, "sp:HttpsToken", -1, &a->wsp__Content::sp__HttpsToken, ""))
		return soap->error;
	if (soap_out_PointerTosp__Token(soap, "sp:KeyValueToken", -1, &a->wsp__Content::sp__KeyValueToken, ""))
		return soap->error;
	if (soap_out_PointerTowsp__Assertion(soap, "sp:TransportBinding", -1, &a->wsp__Content::sp__TransportBinding, ""))
		return soap->error;
	if (soap_out_PointerTowsp__Assertion(soap, "sp:TransportToken", -1, &a->wsp__Content::sp__TransportToken, ""))
		return soap->error;
	if (soap_out_PointerTowsp__Assertion(soap, "sp:AlgorithmSuite", -1, &a->wsp__Content::sp__AlgorithmSuite, ""))
		return soap->error;
	if (soap_out_PointerTowsp__Assertion(soap, "sp:Layout", -1, &a->wsp__Content::sp__Layout, ""))
		return soap->error;
	if (soap_out_PointerTowsp__Assertion(soap, "sp:SymmetricBinding", -1, &a->wsp__Content::sp__SymmetricBinding, ""))
		return soap->error;
	if (soap_out_PointerTowsp__Assertion(soap, "sp:AsymmetricBinding", -1, &a->wsp__Content::sp__AsymmetricBinding, ""))
		return soap->error;
	if (soap_out_PointerTowsp__Assertion(soap, "sp:ProtectionToken", -1, &a->wsp__Content::sp__ProtectionToken, ""))
		return soap->error;
	if (soap_out_PointerTowsp__Assertion(soap, "sp:InitiatorToken", -1, &a->wsp__Content::sp__InitiatorToken, ""))
		return soap->error;
	if (soap_out_PointerTowsp__Assertion(soap, "sp:InitiatorSignatureToken", -1, &a->wsp__Content::sp__InitiatorSignatureToken, ""))
		return soap->error;
	if (soap_out_PointerTowsp__Assertion(soap, "sp:InitiatorEncryptionToken", -1, &a->wsp__Content::sp__InitiatorEncryptionToken, ""))
		return soap->error;
	if (soap_out_PointerTowsp__Assertion(soap, "sp:RecipientToken", -1, &a->wsp__Content::sp__RecipientToken, ""))
		return soap->error;
	if (soap_out_PointerTowsp__Assertion(soap, "sp:SupportingTokens", -1, &a->wsp__Content::sp__SupportingTokens, ""))
		return soap->error;
	if (soap_out_PointerTowsp__Assertion(soap, "sp:SignedSupportingTokens", -1, &a->wsp__Content::sp__SignedSupportingTokens, ""))
		return soap->error;
	if (soap_out_PointerTowsp__Assertion(soap, "sp:EndorsingSupportingTokens", -1, &a->wsp__Content::sp__EndorsingSupportingTokens, ""))
		return soap->error;
	if (soap_out_PointerTowsp__Assertion(soap, "sp:SignedEndorsingSupportingTokens", -1, &a->wsp__Content::sp__SignedEndorsingSupportingTokens, ""))
		return soap->error;
	if (soap_out_PointerTowsp__Assertion(soap, "sp:SignedEncryptedSupportingTokens", -1, &a->wsp__Content::sp__SignedEncryptedSupportingTokens, ""))
		return soap->error;
	if (soap_out_PointerTowsp__Assertion(soap, "sp:EncryptedSupportingTokens", -1, &a->wsp__Content::sp__EncryptedSupportingTokens, ""))
		return soap->error;
	if (soap_out_PointerTowsp__Assertion(soap, "sp:EndorsingEncryptedSupportingTokens", -1, &a->wsp__Content::sp__EndorsingEncryptedSupportingTokens, ""))
		return soap->error;
	if (soap_out_PointerTowsp__Assertion(soap, "sp:SignedEndorsingEncryptedSupportingTokens", -1, &a->wsp__Content::sp__SignedEndorsingEncryptedSupportingTokens, ""))
		return soap->error;
	if (soap_out_PointerTowsp__Assertion(soap, "sp:Wss10", -1, &a->wsp__Content::sp__Wss10, ""))
		return soap->error;
	if (soap_out_PointerTowsp__Assertion(soap, "sp:Wss11", -1, &a->wsp__Content::sp__Wss11, ""))
		return soap->error;
	if (soap_out_PointerTowsp__Assertion(soap, "sp:Trust10", -1, &a->wsp__Content::sp__Trust10, ""))
		return soap->error;
	if (soap_out_PointerTowsp__Assertion(soap, "sp:Trust13", -1, &a->wsp__Content::sp__Trust13, ""))
		return soap->error;
	if (soap_out_PointerTowsp__Content(soap, "sp:BootstrapPolicy", -1, &a->wsp__Content::sp__BootstrapPolicy, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "wsaw:UsingAddressing", -1, (char*const*)&a->wsp__Content::wsaw__UsingAddressing, ""))
		return soap->error;
	if (soap_out_PointerTowsp__Assertion(soap, "wsam:Addressing", -1, &a->wsp__Content::wsam__Addressing, ""))
		return soap->error;
	if (soap_out_PointerTowsrmp__RMAssertion(soap, "wsrmp:RMAssertion", -1, &a->wsp__Content::wsrmp__RMAssertion_, ""))
		return soap->error;
	if (soap_out_PointerTowsrmp__RMAssertion(soap, "wsrmp:DeliveryAssurance", -1, &a->wsp__Content::wsrmp__DeliveryAssurance, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "wsrmp:AtLeastOnce", -1, (char*const*)&a->wsp__Content::wsrmp__AtLeastOnce, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "wsrmp:AtMostOnce", -1, (char*const*)&a->wsp__Content::wsrmp__AtMostOnce, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "wsrmp:ExactlyOnce", -1, (char*const*)&a->wsp__Content::wsrmp__ExactlyOnce, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "wsrmp:InOrder", -1, (char*const*)&a->wsp__Content::wsrmp__InOrder, ""))
		return soap->error;
	if (soap_out_PointerTowsrmp5__RMAssertion(soap, "wsrmp5:RMAssertion", -1, &a->wsp__Content::wsrmp5__RMAssertion_, ""))
		return soap->error;
	if (soap_out_PointerTowsrmp5__RMAssertion(soap, "wsrmp5:DeliveryAssurance", -1, &a->wsp__Content::wsrmp5__DeliveryAssurance, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "wsrmp5:AtLeastOnce", -1, (char*const*)&a->wsp__Content::wsrmp5__AtLeastOnce, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "wsrmp5:AtMostOnce", -1, (char*const*)&a->wsp__Content::wsrmp5__AtMostOnce, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "wsrmp5:ExactlyOnce", -1, (char*const*)&a->wsp__Content::wsrmp5__ExactlyOnce, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "wsrmp5:InOrder", -1, (char*const*)&a->wsp__Content::wsrmp5__InOrder, ""))
		return soap->error;
	if (soap_out_PointerTowsp__Assertion(soap, "sp:NoPassword", -1, &a->wsp__Content::sp__NoPassword, ""))
		return soap->error;
	if (soap_out_PointerTowsp__Assertion(soap, "sp:HashPassword", -1, &a->wsp__Content::sp__HashPassword, ""))
		return soap->error;
	if (soap_out_PointerTowsp__Assertion(soap, "sp:IncludeTimestamp", -1, &a->wsp__Content::sp__IncludeTimestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsp__Assertion(soap, "sp:EncryptBeforeSigning", -1, &a->wsp__Content::sp__EncryptBeforeSigning, ""))
		return soap->error;
	if (soap_out_PointerTowsp__Assertion(soap, "sp:EncryptSignature", -1, &a->wsp__Content::sp__EncryptSignature, ""))
		return soap->error;
	if (soap_out_PointerTowsp__Assertion(soap, "sp:ProtectTokens", -1, &a->wsp__Content::sp__ProtectTokens, ""))
		return soap->error;
	if (soap_out_PointerTowsp__Assertion(soap, "sp:OnlySignEntireHeadersAndBody", -1, &a->wsp__Content::sp__OnlySignEntireHeadersAndBody, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:RequireDerivedKeys", -1, (char*const*)&a->wsp__Content::sp__RequireDerivedKeys, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:RequireImpliedDerivedKeys", -1, (char*const*)&a->wsp__Content::sp__RequireImpliedDerivedKeys, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:RequireExplicitDerivedKeys", -1, (char*const*)&a->wsp__Content::sp__RequireExplicitDerivedKeys, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:WssUsernameToken10", -1, (char*const*)&a->wsp__Content::sp__WssUsernameToken10, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:WssUsernameToken11", -1, (char*const*)&a->wsp__Content::sp__WssUsernameToken11, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:RequireExternalReference", -1, (char*const*)&a->wsp__Content::sp__RequireExternalReference, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:RequireInternalReference", -1, (char*const*)&a->wsp__Content::sp__RequireInternalReference, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:RequireKeyIdentifierReference", -1, (char*const*)&a->wsp__Content::sp__RequireKeyIdentifierReference, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:RequireIssuerSerialReference", -1, (char*const*)&a->wsp__Content::sp__RequireIssuerSerialReference, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:RequireEmbeddedTokenReference", -1, (char*const*)&a->wsp__Content::sp__RequireEmbeddedTokenReference, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:RequireThumbprintReference", -1, (char*const*)&a->wsp__Content::sp__RequireThumbprintReference, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:WssX509V3Token10", -1, (char*const*)&a->wsp__Content::sp__WssX509V3Token10, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:WssX509Pkcs7Token10", -1, (char*const*)&a->wsp__Content::sp__WssX509Pkcs7Token10, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:WssX509PkiPathV1Token10", -1, (char*const*)&a->wsp__Content::sp__WssX509PkiPathV1Token10, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:WssX509V1Token11", -1, (char*const*)&a->wsp__Content::sp__WssX509V1Token11, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:WssX509V3Token11", -1, (char*const*)&a->wsp__Content::sp__WssX509V3Token11, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:WssX509Pkcs7Token11", -1, (char*const*)&a->wsp__Content::sp__WssX509Pkcs7Token11, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:WssX509PkiPathV1Token11", -1, (char*const*)&a->wsp__Content::sp__WssX509PkiPathV1Token11, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:WssKerberosV5ApReqToken11", -1, (char*const*)&a->wsp__Content::sp__WssKerberosV5ApReqToken11, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:WssGssKerberosV5ApReqToken11", -1, (char*const*)&a->wsp__Content::sp__WssGssKerberosV5ApReqToken11, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:WssRelV10Token10", -1, (char*const*)&a->wsp__Content::sp__WssRelV10Token10, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:WssRelV20Token10", -1, (char*const*)&a->wsp__Content::sp__WssRelV20Token10, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:WssRelV10Token11", -1, (char*const*)&a->wsp__Content::sp__WssRelV10Token11, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:WssRelV20Token11", -1, (char*const*)&a->wsp__Content::sp__WssRelV20Token11, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:MustNotSendCancel", -1, (char*const*)&a->wsp__Content::sp__MustNotSendCancel, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:MustNotSendAmend", -1, (char*const*)&a->wsp__Content::sp__MustNotSendAmend, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:MustNotSendRenew", -1, (char*const*)&a->wsp__Content::sp__MustNotSendRenew, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:MustSupportRefKeyIdentifier", -1, (char*const*)&a->wsp__Content::sp__MustSupportRefKeyIdentifier, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:MustSupportRefIssuerSerial", -1, (char*const*)&a->wsp__Content::sp__MustSupportRefIssuerSerial, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:MustSupportRefExternalURI", -1, (char*const*)&a->wsp__Content::sp__MustSupportRefExternalURI, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:MustSupportRefEmbeddedToken", -1, (char*const*)&a->wsp__Content::sp__MustSupportRefEmbeddedToken, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:MustSupportRefThumbprint", -1, (char*const*)&a->wsp__Content::sp__MustSupportRefThumbprint, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:MustSupportRefEncryptedKey", -1, (char*const*)&a->wsp__Content::sp__MustSupportRefEncryptedKey, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:RequireSignatureConfirmation", -1, (char*const*)&a->wsp__Content::sp__RequireSignatureConfirmation, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:MustSupportClientChallenge", -1, (char*const*)&a->wsp__Content::sp__MustSupportClientChallenge, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:MustSupportServerChallenge", -1, (char*const*)&a->wsp__Content::sp__MustSupportServerChallenge, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:RequireClientEntropy", -1, (char*const*)&a->wsp__Content::sp__RequireClientEntropy, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:RequireServerEntropy", -1, (char*const*)&a->wsp__Content::sp__RequireServerEntropy, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:MustSupportIssuedTokens", -1, (char*const*)&a->wsp__Content::sp__MustSupportIssuedTokens, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:RequireRequestSecurityTokenCollection", -1, (char*const*)&a->wsp__Content::sp__RequireRequestSecurityTokenCollection, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:RequireAppliesTo", -1, (char*const*)&a->wsp__Content::sp__RequireAppliesTo, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:RequireExternalUriReference", -1, (char*const*)&a->wsp__Content::sp__RequireExternalUriReference, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:SC13SecurityContextToken", -1, (char*const*)&a->wsp__Content::sp__SC13SecurityContextToken, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:Strict", -1, (char*const*)&a->wsp__Content::sp__Strict, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:Lax", -1, (char*const*)&a->wsp__Content::sp__Lax, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:LaxTsFirst", -1, (char*const*)&a->wsp__Content::sp__LaxTsFirst, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:LaxTsLast", -1, (char*const*)&a->wsp__Content::sp__LaxTsLast, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:HttpBasicAuthentication", -1, (char*const*)&a->wsp__Content::sp__HttpBasicAuthentication, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:HttpDigestAuthentication", -1, (char*const*)&a->wsp__Content::sp__HttpDigestAuthentication, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:RequireClientCertificate", -1, (char*const*)&a->wsp__Content::sp__RequireClientCertificate, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:Basic256", -1, (char*const*)&a->wsp__Content::sp__Basic256, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:Basic192", -1, (char*const*)&a->wsp__Content::sp__Basic192, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:Basic128", -1, (char*const*)&a->wsp__Content::sp__Basic128, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:TripleDes", -1, (char*const*)&a->wsp__Content::sp__TripleDes, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:Basic256Rsa15", -1, (char*const*)&a->wsp__Content::sp__Basic256Rsa15, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:Basic192Rsa15", -1, (char*const*)&a->wsp__Content::sp__Basic192Rsa15, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:Basic128Rsa15", -1, (char*const*)&a->wsp__Content::sp__Basic128Rsa15, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:TripleDesRsa15", -1, (char*const*)&a->wsp__Content::sp__TripleDesRsa15, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:Basic256Sha256", -1, (char*const*)&a->wsp__Content::sp__Basic256Sha256, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:Basic192Sha256", -1, (char*const*)&a->wsp__Content::sp__Basic192Sha256, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:Basic128Sha256", -1, (char*const*)&a->wsp__Content::sp__Basic128Sha256, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:TripleDesSha256", -1, (char*const*)&a->wsp__Content::sp__TripleDesSha256, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:Basic256Sha256Rsa15", -1, (char*const*)&a->wsp__Content::sp__Basic256Sha256Rsa15, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:Basic192Sha256Rsa15", -1, (char*const*)&a->wsp__Content::sp__Basic192Sha256Rsa15, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:Basic128Sha256Rsa15", -1, (char*const*)&a->wsp__Content::sp__Basic128Sha256Rsa15, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:TripleDesSha256Rsa15", -1, (char*const*)&a->wsp__Content::sp__TripleDesSha256Rsa15, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:InclusiveC14N", -1, (char*const*)&a->wsp__Content::sp__InclusiveC14N, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:SOAPNormalization10", -1, (char*const*)&a->wsp__Content::sp__SOAPNormalization10, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:STRTransform10", -1, (char*const*)&a->wsp__Content::sp__STRTransform10, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:Path10", -1, (char*const*)&a->wsp__Content::sp__Path10, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:XPathFilter20", -1, (char*const*)&a->wsp__Content::sp__XPathFilter20, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sp:AbsXPath", -1, (char*const*)&a->wsp__Content::sp__AbsXPath, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "wsam:AnonymousResponses", -1, (char*const*)&a->wsp__Content::wsam__AnonymousResponses, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "wsam:NonAnonymousResponses", -1, (char*const*)&a->wsp__Content::wsam__NonAnonymousResponses, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->wsp__Content::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsp__Policy::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wsp__Policy(soap, tag, this, type);
}

SOAP_FMAC3 wsp__Policy * SOAP_FMAC4 soap_in_wsp__Policy(struct soap *soap, const char *tag, wsp__Policy *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsp__Policy *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsp__Policy, sizeof(wsp__Policy), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsp__Policy)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsp__Policy *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "xml:base", 4, 0), &((wsp__Policy*)a)->xml__base))
		return NULL;
	if (soap_s2xsd__string(soap, soap_attr_value(soap, "wsu:Id", 1, 0), &((wsp__Policy*)a)->wsu__Id))
		return NULL;
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "TargetNamespace", 4, 0), &((wsp__Policy*)a)->TargetNamespace))
		return NULL;
	size_t soap_flag_Policy2 = 1;
	size_t soap_flag_PolicyReference2 = 1;
	size_t soap_flag_sp__SignedElements2 = 1;
	size_t soap_flag_sp__EncryptedElements2 = 1;
	size_t soap_flag_sp__ContentEncryptedElements2 = 1;
	size_t soap_flag_sp__RequiredElements2 = 1;
	size_t soap_flag_sp__UsernameToken2 = 1;
	size_t soap_flag_sp__IssuedToken2 = 1;
	size_t soap_flag_sp__X509Token2 = 1;
	size_t soap_flag_sp__KerberosToken2 = 1;
	size_t soap_flag_sp__SpnegoContextToken2 = 1;
	size_t soap_flag_sp__SecurityContextToken2 = 1;
	size_t soap_flag_sp__SecureConversationToken2 = 1;
	size_t soap_flag_sp__SamlToken2 = 1;
	size_t soap_flag_sp__RelToken2 = 1;
	size_t soap_flag_sp__HttpsToken2 = 1;
	size_t soap_flag_sp__KeyValueToken2 = 1;
	size_t soap_flag_sp__TransportBinding2 = 1;
	size_t soap_flag_sp__TransportToken2 = 1;
	size_t soap_flag_sp__AlgorithmSuite2 = 1;
	size_t soap_flag_sp__Layout2 = 1;
	size_t soap_flag_sp__SymmetricBinding2 = 1;
	size_t soap_flag_sp__AsymmetricBinding2 = 1;
	size_t soap_flag_sp__ProtectionToken2 = 1;
	size_t soap_flag_sp__InitiatorToken2 = 1;
	size_t soap_flag_sp__InitiatorSignatureToken2 = 1;
	size_t soap_flag_sp__InitiatorEncryptionToken2 = 1;
	size_t soap_flag_sp__RecipientToken2 = 1;
	size_t soap_flag_sp__SupportingTokens2 = 1;
	size_t soap_flag_sp__SignedSupportingTokens2 = 1;
	size_t soap_flag_sp__EndorsingSupportingTokens2 = 1;
	size_t soap_flag_sp__SignedEndorsingSupportingTokens2 = 1;
	size_t soap_flag_sp__SignedEncryptedSupportingTokens2 = 1;
	size_t soap_flag_sp__EncryptedSupportingTokens2 = 1;
	size_t soap_flag_sp__EndorsingEncryptedSupportingTokens2 = 1;
	size_t soap_flag_sp__SignedEndorsingEncryptedSupportingTokens2 = 1;
	size_t soap_flag_sp__Wss102 = 1;
	size_t soap_flag_sp__Wss112 = 1;
	size_t soap_flag_sp__Trust102 = 1;
	size_t soap_flag_sp__Trust132 = 1;
	size_t soap_flag_sp__BootstrapPolicy2 = 1;
	size_t soap_flag_wsaw__UsingAddressing2 = 1;
	size_t soap_flag_wsam__Addressing2 = 1;
	size_t soap_flag_wsrmp__RMAssertion_2 = 1;
	size_t soap_flag_wsrmp__DeliveryAssurance2 = 1;
	size_t soap_flag_wsrmp__AtLeastOnce2 = 1;
	size_t soap_flag_wsrmp__AtMostOnce2 = 1;
	size_t soap_flag_wsrmp__ExactlyOnce2 = 1;
	size_t soap_flag_wsrmp__InOrder2 = 1;
	size_t soap_flag_wsrmp5__RMAssertion_2 = 1;
	size_t soap_flag_wsrmp5__DeliveryAssurance2 = 1;
	size_t soap_flag_wsrmp5__AtLeastOnce2 = 1;
	size_t soap_flag_wsrmp5__AtMostOnce2 = 1;
	size_t soap_flag_wsrmp5__ExactlyOnce2 = 1;
	size_t soap_flag_wsrmp5__InOrder2 = 1;
	size_t soap_flag_sp__NoPassword2 = 1;
	size_t soap_flag_sp__HashPassword2 = 1;
	size_t soap_flag_sp__IncludeTimestamp2 = 1;
	size_t soap_flag_sp__EncryptBeforeSigning2 = 1;
	size_t soap_flag_sp__EncryptSignature2 = 1;
	size_t soap_flag_sp__ProtectTokens2 = 1;
	size_t soap_flag_sp__OnlySignEntireHeadersAndBody2 = 1;
	size_t soap_flag_sp__RequireDerivedKeys2 = 1;
	size_t soap_flag_sp__RequireImpliedDerivedKeys2 = 1;
	size_t soap_flag_sp__RequireExplicitDerivedKeys2 = 1;
	size_t soap_flag_sp__WssUsernameToken102 = 1;
	size_t soap_flag_sp__WssUsernameToken112 = 1;
	size_t soap_flag_sp__RequireExternalReference2 = 1;
	size_t soap_flag_sp__RequireInternalReference2 = 1;
	size_t soap_flag_sp__RequireKeyIdentifierReference2 = 1;
	size_t soap_flag_sp__RequireIssuerSerialReference2 = 1;
	size_t soap_flag_sp__RequireEmbeddedTokenReference2 = 1;
	size_t soap_flag_sp__RequireThumbprintReference2 = 1;
	size_t soap_flag_sp__WssX509V3Token102 = 1;
	size_t soap_flag_sp__WssX509Pkcs7Token102 = 1;
	size_t soap_flag_sp__WssX509PkiPathV1Token102 = 1;
	size_t soap_flag_sp__WssX509V1Token112 = 1;
	size_t soap_flag_sp__WssX509V3Token112 = 1;
	size_t soap_flag_sp__WssX509Pkcs7Token112 = 1;
	size_t soap_flag_sp__WssX509PkiPathV1Token112 = 1;
	size_t soap_flag_sp__WssKerberosV5ApReqToken112 = 1;
	size_t soap_flag_sp__WssGssKerberosV5ApReqToken112 = 1;
	size_t soap_flag_sp__WssRelV10Token102 = 1;
	size_t soap_flag_sp__WssRelV20Token102 = 1;
	size_t soap_flag_sp__WssRelV10Token112 = 1;
	size_t soap_flag_sp__WssRelV20Token112 = 1;
	size_t soap_flag_sp__MustNotSendCancel2 = 1;
	size_t soap_flag_sp__MustNotSendAmend2 = 1;
	size_t soap_flag_sp__MustNotSendRenew2 = 1;
	size_t soap_flag_sp__MustSupportRefKeyIdentifier2 = 1;
	size_t soap_flag_sp__MustSupportRefIssuerSerial2 = 1;
	size_t soap_flag_sp__MustSupportRefExternalURI2 = 1;
	size_t soap_flag_sp__MustSupportRefEmbeddedToken2 = 1;
	size_t soap_flag_sp__MustSupportRefThumbprint2 = 1;
	size_t soap_flag_sp__MustSupportRefEncryptedKey2 = 1;
	size_t soap_flag_sp__RequireSignatureConfirmation2 = 1;
	size_t soap_flag_sp__MustSupportClientChallenge2 = 1;
	size_t soap_flag_sp__MustSupportServerChallenge2 = 1;
	size_t soap_flag_sp__RequireClientEntropy2 = 1;
	size_t soap_flag_sp__RequireServerEntropy2 = 1;
	size_t soap_flag_sp__MustSupportIssuedTokens2 = 1;
	size_t soap_flag_sp__RequireRequestSecurityTokenCollection2 = 1;
	size_t soap_flag_sp__RequireAppliesTo2 = 1;
	size_t soap_flag_sp__RequireExternalUriReference2 = 1;
	size_t soap_flag_sp__SC13SecurityContextToken2 = 1;
	size_t soap_flag_sp__Strict2 = 1;
	size_t soap_flag_sp__Lax2 = 1;
	size_t soap_flag_sp__LaxTsFirst2 = 1;
	size_t soap_flag_sp__LaxTsLast2 = 1;
	size_t soap_flag_sp__HttpBasicAuthentication2 = 1;
	size_t soap_flag_sp__HttpDigestAuthentication2 = 1;
	size_t soap_flag_sp__RequireClientCertificate2 = 1;
	size_t soap_flag_sp__Basic2562 = 1;
	size_t soap_flag_sp__Basic1922 = 1;
	size_t soap_flag_sp__Basic1282 = 1;
	size_t soap_flag_sp__TripleDes2 = 1;
	size_t soap_flag_sp__Basic256Rsa152 = 1;
	size_t soap_flag_sp__Basic192Rsa152 = 1;
	size_t soap_flag_sp__Basic128Rsa152 = 1;
	size_t soap_flag_sp__TripleDesRsa152 = 1;
	size_t soap_flag_sp__Basic256Sha2562 = 1;
	size_t soap_flag_sp__Basic192Sha2562 = 1;
	size_t soap_flag_sp__Basic128Sha2562 = 1;
	size_t soap_flag_sp__TripleDesSha2562 = 1;
	size_t soap_flag_sp__Basic256Sha256Rsa152 = 1;
	size_t soap_flag_sp__Basic192Sha256Rsa152 = 1;
	size_t soap_flag_sp__Basic128Sha256Rsa152 = 1;
	size_t soap_flag_sp__TripleDesSha256Rsa152 = 1;
	size_t soap_flag_sp__InclusiveC14N2 = 1;
	size_t soap_flag_sp__SOAPNormalization102 = 1;
	size_t soap_flag_sp__STRTransform102 = 1;
	size_t soap_flag_sp__Path102 = 1;
	size_t soap_flag_sp__XPathFilter202 = 1;
	size_t soap_flag_sp__AbsXPath2 = 1;
	size_t soap_flag_wsam__AnonymousResponses2 = 1;
	size_t soap_flag_wsam__NonAnonymousResponses2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Policy2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsp__Policy(soap, "wsp:Policy", &a->wsp__Content::Policy, "wsp:Policy"))
				{	soap_flag_Policy2--;
					continue;
				}
			}
			if (soap_flag_PolicyReference2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsp__PolicyReference(soap, "wsp:PolicyReference", &a->wsp__Content::PolicyReference, "wsp:PolicyReference"))
				{	soap_flag_PolicyReference2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTowsp__Content(soap, "wsp:All", &a->wsp__Content::All, "wsp:Content"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTowsp__Content(soap, "wsp:ExactlyOne", &a->wsp__Content::ExactlyOne, "wsp:Content"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfsp__Parts(soap, "sp:SignedParts", &a->wsp__Content::sp__SignedParts, "sp:Parts"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfsp__Parts(soap, "sp:EncryptedParts", &a->wsp__Content::sp__EncryptedParts, "sp:Parts"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfsp__Parts(soap, "sp:RequiredParts", &a->wsp__Content::sp__RequiredParts, "sp:Parts"))
					continue;
			}
			if (soap_flag_sp__SignedElements2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosp__Elements(soap, "sp:SignedElements", &a->wsp__Content::sp__SignedElements, "sp:Elements"))
				{	soap_flag_sp__SignedElements2--;
					continue;
				}
			}
			if (soap_flag_sp__EncryptedElements2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosp__Elements(soap, "sp:EncryptedElements", &a->wsp__Content::sp__EncryptedElements, "sp:Elements"))
				{	soap_flag_sp__EncryptedElements2--;
					continue;
				}
			}
			if (soap_flag_sp__ContentEncryptedElements2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosp__Elements(soap, "sp:ContentEncryptedElements", &a->wsp__Content::sp__ContentEncryptedElements, "sp:Elements"))
				{	soap_flag_sp__ContentEncryptedElements2--;
					continue;
				}
			}
			if (soap_flag_sp__RequiredElements2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosp__Elements(soap, "sp:RequiredElements", &a->wsp__Content::sp__RequiredElements, "sp:Elements"))
				{	soap_flag_sp__RequiredElements2--;
					continue;
				}
			}
			if (soap_flag_sp__UsernameToken2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosp__Token(soap, "sp:UsernameToken", &a->wsp__Content::sp__UsernameToken, "sp:Token"))
				{	soap_flag_sp__UsernameToken2--;
					continue;
				}
			}
			if (soap_flag_sp__IssuedToken2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosp__Token(soap, "sp:IssuedToken", &a->wsp__Content::sp__IssuedToken, "sp:Token"))
				{	soap_flag_sp__IssuedToken2--;
					continue;
				}
			}
			if (soap_flag_sp__X509Token2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosp__Token(soap, "sp:X509Token", &a->wsp__Content::sp__X509Token, "sp:Token"))
				{	soap_flag_sp__X509Token2--;
					continue;
				}
			}
			if (soap_flag_sp__KerberosToken2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosp__Token(soap, "sp:KerberosToken", &a->wsp__Content::sp__KerberosToken, "sp:Token"))
				{	soap_flag_sp__KerberosToken2--;
					continue;
				}
			}
			if (soap_flag_sp__SpnegoContextToken2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosp__Token(soap, "sp:SpnegoContextToken", &a->wsp__Content::sp__SpnegoContextToken, "sp:Token"))
				{	soap_flag_sp__SpnegoContextToken2--;
					continue;
				}
			}
			if (soap_flag_sp__SecurityContextToken2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosp__Token(soap, "sp:SecurityContextToken", &a->wsp__Content::sp__SecurityContextToken, "sp:Token"))
				{	soap_flag_sp__SecurityContextToken2--;
					continue;
				}
			}
			if (soap_flag_sp__SecureConversationToken2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosp__Token(soap, "sp:SecureConversationToken", &a->wsp__Content::sp__SecureConversationToken, "sp:Token"))
				{	soap_flag_sp__SecureConversationToken2--;
					continue;
				}
			}
			if (soap_flag_sp__SamlToken2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosp__Token(soap, "sp:SamlToken", &a->wsp__Content::sp__SamlToken, "sp:Token"))
				{	soap_flag_sp__SamlToken2--;
					continue;
				}
			}
			if (soap_flag_sp__RelToken2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosp__Token(soap, "sp:RelToken", &a->wsp__Content::sp__RelToken, "sp:Token"))
				{	soap_flag_sp__RelToken2--;
					continue;
				}
			}
			if (soap_flag_sp__HttpsToken2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosp__Token(soap, "sp:HttpsToken", &a->wsp__Content::sp__HttpsToken, "sp:Token"))
				{	soap_flag_sp__HttpsToken2--;
					continue;
				}
			}
			if (soap_flag_sp__KeyValueToken2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosp__Token(soap, "sp:KeyValueToken", &a->wsp__Content::sp__KeyValueToken, "sp:Token"))
				{	soap_flag_sp__KeyValueToken2--;
					continue;
				}
			}
			if (soap_flag_sp__TransportBinding2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsp__Assertion(soap, "sp:TransportBinding", &a->wsp__Content::sp__TransportBinding, "wsp:Assertion"))
				{	soap_flag_sp__TransportBinding2--;
					continue;
				}
			}
			if (soap_flag_sp__TransportToken2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsp__Assertion(soap, "sp:TransportToken", &a->wsp__Content::sp__TransportToken, "wsp:Assertion"))
				{	soap_flag_sp__TransportToken2--;
					continue;
				}
			}
			if (soap_flag_sp__AlgorithmSuite2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsp__Assertion(soap, "sp:AlgorithmSuite", &a->wsp__Content::sp__AlgorithmSuite, "wsp:Assertion"))
				{	soap_flag_sp__AlgorithmSuite2--;
					continue;
				}
			}
			if (soap_flag_sp__Layout2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsp__Assertion(soap, "sp:Layout", &a->wsp__Content::sp__Layout, "wsp:Assertion"))
				{	soap_flag_sp__Layout2--;
					continue;
				}
			}
			if (soap_flag_sp__SymmetricBinding2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsp__Assertion(soap, "sp:SymmetricBinding", &a->wsp__Content::sp__SymmetricBinding, "wsp:Assertion"))
				{	soap_flag_sp__SymmetricBinding2--;
					continue;
				}
			}
			if (soap_flag_sp__AsymmetricBinding2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsp__Assertion(soap, "sp:AsymmetricBinding", &a->wsp__Content::sp__AsymmetricBinding, "wsp:Assertion"))
				{	soap_flag_sp__AsymmetricBinding2--;
					continue;
				}
			}
			if (soap_flag_sp__ProtectionToken2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsp__Assertion(soap, "sp:ProtectionToken", &a->wsp__Content::sp__ProtectionToken, "wsp:Assertion"))
				{	soap_flag_sp__ProtectionToken2--;
					continue;
				}
			}
			if (soap_flag_sp__InitiatorToken2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsp__Assertion(soap, "sp:InitiatorToken", &a->wsp__Content::sp__InitiatorToken, "wsp:Assertion"))
				{	soap_flag_sp__InitiatorToken2--;
					continue;
				}
			}
			if (soap_flag_sp__InitiatorSignatureToken2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsp__Assertion(soap, "sp:InitiatorSignatureToken", &a->wsp__Content::sp__InitiatorSignatureToken, "wsp:Assertion"))
				{	soap_flag_sp__InitiatorSignatureToken2--;
					continue;
				}
			}
			if (soap_flag_sp__InitiatorEncryptionToken2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsp__Assertion(soap, "sp:InitiatorEncryptionToken", &a->wsp__Content::sp__InitiatorEncryptionToken, "wsp:Assertion"))
				{	soap_flag_sp__InitiatorEncryptionToken2--;
					continue;
				}
			}
			if (soap_flag_sp__RecipientToken2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsp__Assertion(soap, "sp:RecipientToken", &a->wsp__Content::sp__RecipientToken, "wsp:Assertion"))
				{	soap_flag_sp__RecipientToken2--;
					continue;
				}
			}
			if (soap_flag_sp__SupportingTokens2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsp__Assertion(soap, "sp:SupportingTokens", &a->wsp__Content::sp__SupportingTokens, "wsp:Assertion"))
				{	soap_flag_sp__SupportingTokens2--;
					continue;
				}
			}
			if (soap_flag_sp__SignedSupportingTokens2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsp__Assertion(soap, "sp:SignedSupportingTokens", &a->wsp__Content::sp__SignedSupportingTokens, "wsp:Assertion"))
				{	soap_flag_sp__SignedSupportingTokens2--;
					continue;
				}
			}
			if (soap_flag_sp__EndorsingSupportingTokens2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsp__Assertion(soap, "sp:EndorsingSupportingTokens", &a->wsp__Content::sp__EndorsingSupportingTokens, "wsp:Assertion"))
				{	soap_flag_sp__EndorsingSupportingTokens2--;
					continue;
				}
			}
			if (soap_flag_sp__SignedEndorsingSupportingTokens2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsp__Assertion(soap, "sp:SignedEndorsingSupportingTokens", &a->wsp__Content::sp__SignedEndorsingSupportingTokens, "wsp:Assertion"))
				{	soap_flag_sp__SignedEndorsingSupportingTokens2--;
					continue;
				}
			}
			if (soap_flag_sp__SignedEncryptedSupportingTokens2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsp__Assertion(soap, "sp:SignedEncryptedSupportingTokens", &a->wsp__Content::sp__SignedEncryptedSupportingTokens, "wsp:Assertion"))
				{	soap_flag_sp__SignedEncryptedSupportingTokens2--;
					continue;
				}
			}
			if (soap_flag_sp__EncryptedSupportingTokens2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsp__Assertion(soap, "sp:EncryptedSupportingTokens", &a->wsp__Content::sp__EncryptedSupportingTokens, "wsp:Assertion"))
				{	soap_flag_sp__EncryptedSupportingTokens2--;
					continue;
				}
			}
			if (soap_flag_sp__EndorsingEncryptedSupportingTokens2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsp__Assertion(soap, "sp:EndorsingEncryptedSupportingTokens", &a->wsp__Content::sp__EndorsingEncryptedSupportingTokens, "wsp:Assertion"))
				{	soap_flag_sp__EndorsingEncryptedSupportingTokens2--;
					continue;
				}
			}
			if (soap_flag_sp__SignedEndorsingEncryptedSupportingTokens2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsp__Assertion(soap, "sp:SignedEndorsingEncryptedSupportingTokens", &a->wsp__Content::sp__SignedEndorsingEncryptedSupportingTokens, "wsp:Assertion"))
				{	soap_flag_sp__SignedEndorsingEncryptedSupportingTokens2--;
					continue;
				}
			}
			if (soap_flag_sp__Wss102 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsp__Assertion(soap, "sp:Wss10", &a->wsp__Content::sp__Wss10, "wsp:Assertion"))
				{	soap_flag_sp__Wss102--;
					continue;
				}
			}
			if (soap_flag_sp__Wss112 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsp__Assertion(soap, "sp:Wss11", &a->wsp__Content::sp__Wss11, "wsp:Assertion"))
				{	soap_flag_sp__Wss112--;
					continue;
				}
			}
			if (soap_flag_sp__Trust102 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsp__Assertion(soap, "sp:Trust10", &a->wsp__Content::sp__Trust10, "wsp:Assertion"))
				{	soap_flag_sp__Trust102--;
					continue;
				}
			}
			if (soap_flag_sp__Trust132 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsp__Assertion(soap, "sp:Trust13", &a->wsp__Content::sp__Trust13, "wsp:Assertion"))
				{	soap_flag_sp__Trust132--;
					continue;
				}
			}
			if (soap_flag_sp__BootstrapPolicy2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsp__Content(soap, "sp:BootstrapPolicy", &a->wsp__Content::sp__BootstrapPolicy, "wsp:Content"))
				{	soap_flag_sp__BootstrapPolicy2--;
					continue;
				}
			}
			if (soap_flag_wsaw__UsingAddressing2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "wsaw:UsingAddressing", (char**)&a->wsp__Content::wsaw__UsingAddressing, "xsd:string"))
				{	soap_flag_wsaw__UsingAddressing2--;
					continue;
				}
			}
			if (soap_flag_wsam__Addressing2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsp__Assertion(soap, "wsam:Addressing", &a->wsp__Content::wsam__Addressing, "wsp:Assertion"))
				{	soap_flag_wsam__Addressing2--;
					continue;
				}
			}
			if (soap_flag_wsrmp__RMAssertion_2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsrmp__RMAssertion(soap, "wsrmp:RMAssertion", &a->wsp__Content::wsrmp__RMAssertion_, "wsrmp:RMAssertion"))
				{	soap_flag_wsrmp__RMAssertion_2--;
					continue;
				}
			}
			if (soap_flag_wsrmp__DeliveryAssurance2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsrmp__RMAssertion(soap, "wsrmp:DeliveryAssurance", &a->wsp__Content::wsrmp__DeliveryAssurance, "wsrmp:RMAssertion"))
				{	soap_flag_wsrmp__DeliveryAssurance2--;
					continue;
				}
			}
			if (soap_flag_wsrmp__AtLeastOnce2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "wsrmp:AtLeastOnce", (char**)&a->wsp__Content::wsrmp__AtLeastOnce, "xsd:string"))
				{	soap_flag_wsrmp__AtLeastOnce2--;
					continue;
				}
			}
			if (soap_flag_wsrmp__AtMostOnce2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "wsrmp:AtMostOnce", (char**)&a->wsp__Content::wsrmp__AtMostOnce, "xsd:string"))
				{	soap_flag_wsrmp__AtMostOnce2--;
					continue;
				}
			}
			if (soap_flag_wsrmp__ExactlyOnce2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "wsrmp:ExactlyOnce", (char**)&a->wsp__Content::wsrmp__ExactlyOnce, "xsd:string"))
				{	soap_flag_wsrmp__ExactlyOnce2--;
					continue;
				}
			}
			if (soap_flag_wsrmp__InOrder2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "wsrmp:InOrder", (char**)&a->wsp__Content::wsrmp__InOrder, "xsd:string"))
				{	soap_flag_wsrmp__InOrder2--;
					continue;
				}
			}
			if (soap_flag_wsrmp5__RMAssertion_2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsrmp5__RMAssertion(soap, "wsrmp5:RMAssertion", &a->wsp__Content::wsrmp5__RMAssertion_, "wsrmp5:RMAssertion"))
				{	soap_flag_wsrmp5__RMAssertion_2--;
					continue;
				}
			}
			if (soap_flag_wsrmp5__DeliveryAssurance2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsrmp5__RMAssertion(soap, "wsrmp5:DeliveryAssurance", &a->wsp__Content::wsrmp5__DeliveryAssurance, "wsrmp5:RMAssertion"))
				{	soap_flag_wsrmp5__DeliveryAssurance2--;
					continue;
				}
			}
			if (soap_flag_wsrmp5__AtLeastOnce2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "wsrmp5:AtLeastOnce", (char**)&a->wsp__Content::wsrmp5__AtLeastOnce, "xsd:string"))
				{	soap_flag_wsrmp5__AtLeastOnce2--;
					continue;
				}
			}
			if (soap_flag_wsrmp5__AtMostOnce2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "wsrmp5:AtMostOnce", (char**)&a->wsp__Content::wsrmp5__AtMostOnce, "xsd:string"))
				{	soap_flag_wsrmp5__AtMostOnce2--;
					continue;
				}
			}
			if (soap_flag_wsrmp5__ExactlyOnce2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "wsrmp5:ExactlyOnce", (char**)&a->wsp__Content::wsrmp5__ExactlyOnce, "xsd:string"))
				{	soap_flag_wsrmp5__ExactlyOnce2--;
					continue;
				}
			}
			if (soap_flag_wsrmp5__InOrder2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "wsrmp5:InOrder", (char**)&a->wsp__Content::wsrmp5__InOrder, "xsd:string"))
				{	soap_flag_wsrmp5__InOrder2--;
					continue;
				}
			}
			if (soap_flag_sp__NoPassword2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsp__Assertion(soap, "sp:NoPassword", &a->wsp__Content::sp__NoPassword, "wsp:Assertion"))
				{	soap_flag_sp__NoPassword2--;
					continue;
				}
			}
			if (soap_flag_sp__HashPassword2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsp__Assertion(soap, "sp:HashPassword", &a->wsp__Content::sp__HashPassword, "wsp:Assertion"))
				{	soap_flag_sp__HashPassword2--;
					continue;
				}
			}
			if (soap_flag_sp__IncludeTimestamp2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsp__Assertion(soap, "sp:IncludeTimestamp", &a->wsp__Content::sp__IncludeTimestamp, "wsp:Assertion"))
				{	soap_flag_sp__IncludeTimestamp2--;
					continue;
				}
			}
			if (soap_flag_sp__EncryptBeforeSigning2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsp__Assertion(soap, "sp:EncryptBeforeSigning", &a->wsp__Content::sp__EncryptBeforeSigning, "wsp:Assertion"))
				{	soap_flag_sp__EncryptBeforeSigning2--;
					continue;
				}
			}
			if (soap_flag_sp__EncryptSignature2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsp__Assertion(soap, "sp:EncryptSignature", &a->wsp__Content::sp__EncryptSignature, "wsp:Assertion"))
				{	soap_flag_sp__EncryptSignature2--;
					continue;
				}
			}
			if (soap_flag_sp__ProtectTokens2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsp__Assertion(soap, "sp:ProtectTokens", &a->wsp__Content::sp__ProtectTokens, "wsp:Assertion"))
				{	soap_flag_sp__ProtectTokens2--;
					continue;
				}
			}
			if (soap_flag_sp__OnlySignEntireHeadersAndBody2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsp__Assertion(soap, "sp:OnlySignEntireHeadersAndBody", &a->wsp__Content::sp__OnlySignEntireHeadersAndBody, "wsp:Assertion"))
				{	soap_flag_sp__OnlySignEntireHeadersAndBody2--;
					continue;
				}
			}
			if (soap_flag_sp__RequireDerivedKeys2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:RequireDerivedKeys", (char**)&a->wsp__Content::sp__RequireDerivedKeys, "xsd:string"))
				{	soap_flag_sp__RequireDerivedKeys2--;
					continue;
				}
			}
			if (soap_flag_sp__RequireImpliedDerivedKeys2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:RequireImpliedDerivedKeys", (char**)&a->wsp__Content::sp__RequireImpliedDerivedKeys, "xsd:string"))
				{	soap_flag_sp__RequireImpliedDerivedKeys2--;
					continue;
				}
			}
			if (soap_flag_sp__RequireExplicitDerivedKeys2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:RequireExplicitDerivedKeys", (char**)&a->wsp__Content::sp__RequireExplicitDerivedKeys, "xsd:string"))
				{	soap_flag_sp__RequireExplicitDerivedKeys2--;
					continue;
				}
			}
			if (soap_flag_sp__WssUsernameToken102 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:WssUsernameToken10", (char**)&a->wsp__Content::sp__WssUsernameToken10, "xsd:string"))
				{	soap_flag_sp__WssUsernameToken102--;
					continue;
				}
			}
			if (soap_flag_sp__WssUsernameToken112 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:WssUsernameToken11", (char**)&a->wsp__Content::sp__WssUsernameToken11, "xsd:string"))
				{	soap_flag_sp__WssUsernameToken112--;
					continue;
				}
			}
			if (soap_flag_sp__RequireExternalReference2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:RequireExternalReference", (char**)&a->wsp__Content::sp__RequireExternalReference, "xsd:string"))
				{	soap_flag_sp__RequireExternalReference2--;
					continue;
				}
			}
			if (soap_flag_sp__RequireInternalReference2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:RequireInternalReference", (char**)&a->wsp__Content::sp__RequireInternalReference, "xsd:string"))
				{	soap_flag_sp__RequireInternalReference2--;
					continue;
				}
			}
			if (soap_flag_sp__RequireKeyIdentifierReference2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:RequireKeyIdentifierReference", (char**)&a->wsp__Content::sp__RequireKeyIdentifierReference, "xsd:string"))
				{	soap_flag_sp__RequireKeyIdentifierReference2--;
					continue;
				}
			}
			if (soap_flag_sp__RequireIssuerSerialReference2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:RequireIssuerSerialReference", (char**)&a->wsp__Content::sp__RequireIssuerSerialReference, "xsd:string"))
				{	soap_flag_sp__RequireIssuerSerialReference2--;
					continue;
				}
			}
			if (soap_flag_sp__RequireEmbeddedTokenReference2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:RequireEmbeddedTokenReference", (char**)&a->wsp__Content::sp__RequireEmbeddedTokenReference, "xsd:string"))
				{	soap_flag_sp__RequireEmbeddedTokenReference2--;
					continue;
				}
			}
			if (soap_flag_sp__RequireThumbprintReference2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:RequireThumbprintReference", (char**)&a->wsp__Content::sp__RequireThumbprintReference, "xsd:string"))
				{	soap_flag_sp__RequireThumbprintReference2--;
					continue;
				}
			}
			if (soap_flag_sp__WssX509V3Token102 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:WssX509V3Token10", (char**)&a->wsp__Content::sp__WssX509V3Token10, "xsd:string"))
				{	soap_flag_sp__WssX509V3Token102--;
					continue;
				}
			}
			if (soap_flag_sp__WssX509Pkcs7Token102 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:WssX509Pkcs7Token10", (char**)&a->wsp__Content::sp__WssX509Pkcs7Token10, "xsd:string"))
				{	soap_flag_sp__WssX509Pkcs7Token102--;
					continue;
				}
			}
			if (soap_flag_sp__WssX509PkiPathV1Token102 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:WssX509PkiPathV1Token10", (char**)&a->wsp__Content::sp__WssX509PkiPathV1Token10, "xsd:string"))
				{	soap_flag_sp__WssX509PkiPathV1Token102--;
					continue;
				}
			}
			if (soap_flag_sp__WssX509V1Token112 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:WssX509V1Token11", (char**)&a->wsp__Content::sp__WssX509V1Token11, "xsd:string"))
				{	soap_flag_sp__WssX509V1Token112--;
					continue;
				}
			}
			if (soap_flag_sp__WssX509V3Token112 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:WssX509V3Token11", (char**)&a->wsp__Content::sp__WssX509V3Token11, "xsd:string"))
				{	soap_flag_sp__WssX509V3Token112--;
					continue;
				}
			}
			if (soap_flag_sp__WssX509Pkcs7Token112 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:WssX509Pkcs7Token11", (char**)&a->wsp__Content::sp__WssX509Pkcs7Token11, "xsd:string"))
				{	soap_flag_sp__WssX509Pkcs7Token112--;
					continue;
				}
			}
			if (soap_flag_sp__WssX509PkiPathV1Token112 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:WssX509PkiPathV1Token11", (char**)&a->wsp__Content::sp__WssX509PkiPathV1Token11, "xsd:string"))
				{	soap_flag_sp__WssX509PkiPathV1Token112--;
					continue;
				}
			}
			if (soap_flag_sp__WssKerberosV5ApReqToken112 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:WssKerberosV5ApReqToken11", (char**)&a->wsp__Content::sp__WssKerberosV5ApReqToken11, "xsd:string"))
				{	soap_flag_sp__WssKerberosV5ApReqToken112--;
					continue;
				}
			}
			if (soap_flag_sp__WssGssKerberosV5ApReqToken112 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:WssGssKerberosV5ApReqToken11", (char**)&a->wsp__Content::sp__WssGssKerberosV5ApReqToken11, "xsd:string"))
				{	soap_flag_sp__WssGssKerberosV5ApReqToken112--;
					continue;
				}
			}
			if (soap_flag_sp__WssRelV10Token102 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:WssRelV10Token10", (char**)&a->wsp__Content::sp__WssRelV10Token10, "xsd:string"))
				{	soap_flag_sp__WssRelV10Token102--;
					continue;
				}
			}
			if (soap_flag_sp__WssRelV20Token102 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:WssRelV20Token10", (char**)&a->wsp__Content::sp__WssRelV20Token10, "xsd:string"))
				{	soap_flag_sp__WssRelV20Token102--;
					continue;
				}
			}
			if (soap_flag_sp__WssRelV10Token112 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:WssRelV10Token11", (char**)&a->wsp__Content::sp__WssRelV10Token11, "xsd:string"))
				{	soap_flag_sp__WssRelV10Token112--;
					continue;
				}
			}
			if (soap_flag_sp__WssRelV20Token112 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:WssRelV20Token11", (char**)&a->wsp__Content::sp__WssRelV20Token11, "xsd:string"))
				{	soap_flag_sp__WssRelV20Token112--;
					continue;
				}
			}
			if (soap_flag_sp__MustNotSendCancel2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:MustNotSendCancel", (char**)&a->wsp__Content::sp__MustNotSendCancel, "xsd:string"))
				{	soap_flag_sp__MustNotSendCancel2--;
					continue;
				}
			}
			if (soap_flag_sp__MustNotSendAmend2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:MustNotSendAmend", (char**)&a->wsp__Content::sp__MustNotSendAmend, "xsd:string"))
				{	soap_flag_sp__MustNotSendAmend2--;
					continue;
				}
			}
			if (soap_flag_sp__MustNotSendRenew2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:MustNotSendRenew", (char**)&a->wsp__Content::sp__MustNotSendRenew, "xsd:string"))
				{	soap_flag_sp__MustNotSendRenew2--;
					continue;
				}
			}
			if (soap_flag_sp__MustSupportRefKeyIdentifier2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:MustSupportRefKeyIdentifier", (char**)&a->wsp__Content::sp__MustSupportRefKeyIdentifier, "xsd:string"))
				{	soap_flag_sp__MustSupportRefKeyIdentifier2--;
					continue;
				}
			}
			if (soap_flag_sp__MustSupportRefIssuerSerial2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:MustSupportRefIssuerSerial", (char**)&a->wsp__Content::sp__MustSupportRefIssuerSerial, "xsd:string"))
				{	soap_flag_sp__MustSupportRefIssuerSerial2--;
					continue;
				}
			}
			if (soap_flag_sp__MustSupportRefExternalURI2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:MustSupportRefExternalURI", (char**)&a->wsp__Content::sp__MustSupportRefExternalURI, "xsd:string"))
				{	soap_flag_sp__MustSupportRefExternalURI2--;
					continue;
				}
			}
			if (soap_flag_sp__MustSupportRefEmbeddedToken2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:MustSupportRefEmbeddedToken", (char**)&a->wsp__Content::sp__MustSupportRefEmbeddedToken, "xsd:string"))
				{	soap_flag_sp__MustSupportRefEmbeddedToken2--;
					continue;
				}
			}
			if (soap_flag_sp__MustSupportRefThumbprint2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:MustSupportRefThumbprint", (char**)&a->wsp__Content::sp__MustSupportRefThumbprint, "xsd:string"))
				{	soap_flag_sp__MustSupportRefThumbprint2--;
					continue;
				}
			}
			if (soap_flag_sp__MustSupportRefEncryptedKey2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:MustSupportRefEncryptedKey", (char**)&a->wsp__Content::sp__MustSupportRefEncryptedKey, "xsd:string"))
				{	soap_flag_sp__MustSupportRefEncryptedKey2--;
					continue;
				}
			}
			if (soap_flag_sp__RequireSignatureConfirmation2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:RequireSignatureConfirmation", (char**)&a->wsp__Content::sp__RequireSignatureConfirmation, "xsd:string"))
				{	soap_flag_sp__RequireSignatureConfirmation2--;
					continue;
				}
			}
			if (soap_flag_sp__MustSupportClientChallenge2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:MustSupportClientChallenge", (char**)&a->wsp__Content::sp__MustSupportClientChallenge, "xsd:string"))
				{	soap_flag_sp__MustSupportClientChallenge2--;
					continue;
				}
			}
			if (soap_flag_sp__MustSupportServerChallenge2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:MustSupportServerChallenge", (char**)&a->wsp__Content::sp__MustSupportServerChallenge, "xsd:string"))
				{	soap_flag_sp__MustSupportServerChallenge2--;
					continue;
				}
			}
			if (soap_flag_sp__RequireClientEntropy2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:RequireClientEntropy", (char**)&a->wsp__Content::sp__RequireClientEntropy, "xsd:string"))
				{	soap_flag_sp__RequireClientEntropy2--;
					continue;
				}
			}
			if (soap_flag_sp__RequireServerEntropy2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:RequireServerEntropy", (char**)&a->wsp__Content::sp__RequireServerEntropy, "xsd:string"))
				{	soap_flag_sp__RequireServerEntropy2--;
					continue;
				}
			}
			if (soap_flag_sp__MustSupportIssuedTokens2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:MustSupportIssuedTokens", (char**)&a->wsp__Content::sp__MustSupportIssuedTokens, "xsd:string"))
				{	soap_flag_sp__MustSupportIssuedTokens2--;
					continue;
				}
			}
			if (soap_flag_sp__RequireRequestSecurityTokenCollection2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:RequireRequestSecurityTokenCollection", (char**)&a->wsp__Content::sp__RequireRequestSecurityTokenCollection, "xsd:string"))
				{	soap_flag_sp__RequireRequestSecurityTokenCollection2--;
					continue;
				}
			}
			if (soap_flag_sp__RequireAppliesTo2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:RequireAppliesTo", (char**)&a->wsp__Content::sp__RequireAppliesTo, "xsd:string"))
				{	soap_flag_sp__RequireAppliesTo2--;
					continue;
				}
			}
			if (soap_flag_sp__RequireExternalUriReference2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:RequireExternalUriReference", (char**)&a->wsp__Content::sp__RequireExternalUriReference, "xsd:string"))
				{	soap_flag_sp__RequireExternalUriReference2--;
					continue;
				}
			}
			if (soap_flag_sp__SC13SecurityContextToken2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:SC13SecurityContextToken", (char**)&a->wsp__Content::sp__SC13SecurityContextToken, "xsd:string"))
				{	soap_flag_sp__SC13SecurityContextToken2--;
					continue;
				}
			}
			if (soap_flag_sp__Strict2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:Strict", (char**)&a->wsp__Content::sp__Strict, "xsd:string"))
				{	soap_flag_sp__Strict2--;
					continue;
				}
			}
			if (soap_flag_sp__Lax2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:Lax", (char**)&a->wsp__Content::sp__Lax, "xsd:string"))
				{	soap_flag_sp__Lax2--;
					continue;
				}
			}
			if (soap_flag_sp__LaxTsFirst2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:LaxTsFirst", (char**)&a->wsp__Content::sp__LaxTsFirst, "xsd:string"))
				{	soap_flag_sp__LaxTsFirst2--;
					continue;
				}
			}
			if (soap_flag_sp__LaxTsLast2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:LaxTsLast", (char**)&a->wsp__Content::sp__LaxTsLast, "xsd:string"))
				{	soap_flag_sp__LaxTsLast2--;
					continue;
				}
			}
			if (soap_flag_sp__HttpBasicAuthentication2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:HttpBasicAuthentication", (char**)&a->wsp__Content::sp__HttpBasicAuthentication, "xsd:string"))
				{	soap_flag_sp__HttpBasicAuthentication2--;
					continue;
				}
			}
			if (soap_flag_sp__HttpDigestAuthentication2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:HttpDigestAuthentication", (char**)&a->wsp__Content::sp__HttpDigestAuthentication, "xsd:string"))
				{	soap_flag_sp__HttpDigestAuthentication2--;
					continue;
				}
			}
			if (soap_flag_sp__RequireClientCertificate2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:RequireClientCertificate", (char**)&a->wsp__Content::sp__RequireClientCertificate, "xsd:string"))
				{	soap_flag_sp__RequireClientCertificate2--;
					continue;
				}
			}
			if (soap_flag_sp__Basic2562 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:Basic256", (char**)&a->wsp__Content::sp__Basic256, "xsd:string"))
				{	soap_flag_sp__Basic2562--;
					continue;
				}
			}
			if (soap_flag_sp__Basic1922 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:Basic192", (char**)&a->wsp__Content::sp__Basic192, "xsd:string"))
				{	soap_flag_sp__Basic1922--;
					continue;
				}
			}
			if (soap_flag_sp__Basic1282 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:Basic128", (char**)&a->wsp__Content::sp__Basic128, "xsd:string"))
				{	soap_flag_sp__Basic1282--;
					continue;
				}
			}
			if (soap_flag_sp__TripleDes2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:TripleDes", (char**)&a->wsp__Content::sp__TripleDes, "xsd:string"))
				{	soap_flag_sp__TripleDes2--;
					continue;
				}
			}
			if (soap_flag_sp__Basic256Rsa152 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:Basic256Rsa15", (char**)&a->wsp__Content::sp__Basic256Rsa15, "xsd:string"))
				{	soap_flag_sp__Basic256Rsa152--;
					continue;
				}
			}
			if (soap_flag_sp__Basic192Rsa152 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:Basic192Rsa15", (char**)&a->wsp__Content::sp__Basic192Rsa15, "xsd:string"))
				{	soap_flag_sp__Basic192Rsa152--;
					continue;
				}
			}
			if (soap_flag_sp__Basic128Rsa152 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:Basic128Rsa15", (char**)&a->wsp__Content::sp__Basic128Rsa15, "xsd:string"))
				{	soap_flag_sp__Basic128Rsa152--;
					continue;
				}
			}
			if (soap_flag_sp__TripleDesRsa152 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:TripleDesRsa15", (char**)&a->wsp__Content::sp__TripleDesRsa15, "xsd:string"))
				{	soap_flag_sp__TripleDesRsa152--;
					continue;
				}
			}
			if (soap_flag_sp__Basic256Sha2562 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:Basic256Sha256", (char**)&a->wsp__Content::sp__Basic256Sha256, "xsd:string"))
				{	soap_flag_sp__Basic256Sha2562--;
					continue;
				}
			}
			if (soap_flag_sp__Basic192Sha2562 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:Basic192Sha256", (char**)&a->wsp__Content::sp__Basic192Sha256, "xsd:string"))
				{	soap_flag_sp__Basic192Sha2562--;
					continue;
				}
			}
			if (soap_flag_sp__Basic128Sha2562 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:Basic128Sha256", (char**)&a->wsp__Content::sp__Basic128Sha256, "xsd:string"))
				{	soap_flag_sp__Basic128Sha2562--;
					continue;
				}
			}
			if (soap_flag_sp__TripleDesSha2562 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:TripleDesSha256", (char**)&a->wsp__Content::sp__TripleDesSha256, "xsd:string"))
				{	soap_flag_sp__TripleDesSha2562--;
					continue;
				}
			}
			if (soap_flag_sp__Basic256Sha256Rsa152 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:Basic256Sha256Rsa15", (char**)&a->wsp__Content::sp__Basic256Sha256Rsa15, "xsd:string"))
				{	soap_flag_sp__Basic256Sha256Rsa152--;
					continue;
				}
			}
			if (soap_flag_sp__Basic192Sha256Rsa152 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:Basic192Sha256Rsa15", (char**)&a->wsp__Content::sp__Basic192Sha256Rsa15, "xsd:string"))
				{	soap_flag_sp__Basic192Sha256Rsa152--;
					continue;
				}
			}
			if (soap_flag_sp__Basic128Sha256Rsa152 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:Basic128Sha256Rsa15", (char**)&a->wsp__Content::sp__Basic128Sha256Rsa15, "xsd:string"))
				{	soap_flag_sp__Basic128Sha256Rsa152--;
					continue;
				}
			}
			if (soap_flag_sp__TripleDesSha256Rsa152 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:TripleDesSha256Rsa15", (char**)&a->wsp__Content::sp__TripleDesSha256Rsa15, "xsd:string"))
				{	soap_flag_sp__TripleDesSha256Rsa152--;
					continue;
				}
			}
			if (soap_flag_sp__InclusiveC14N2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:InclusiveC14N", (char**)&a->wsp__Content::sp__InclusiveC14N, "xsd:string"))
				{	soap_flag_sp__InclusiveC14N2--;
					continue;
				}
			}
			if (soap_flag_sp__SOAPNormalization102 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:SOAPNormalization10", (char**)&a->wsp__Content::sp__SOAPNormalization10, "xsd:string"))
				{	soap_flag_sp__SOAPNormalization102--;
					continue;
				}
			}
			if (soap_flag_sp__STRTransform102 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:STRTransform10", (char**)&a->wsp__Content::sp__STRTransform10, "xsd:string"))
				{	soap_flag_sp__STRTransform102--;
					continue;
				}
			}
			if (soap_flag_sp__Path102 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:Path10", (char**)&a->wsp__Content::sp__Path10, "xsd:string"))
				{	soap_flag_sp__Path102--;
					continue;
				}
			}
			if (soap_flag_sp__XPathFilter202 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:XPathFilter20", (char**)&a->wsp__Content::sp__XPathFilter20, "xsd:string"))
				{	soap_flag_sp__XPathFilter202--;
					continue;
				}
			}
			if (soap_flag_sp__AbsXPath2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sp:AbsXPath", (char**)&a->wsp__Content::sp__AbsXPath, "xsd:string"))
				{	soap_flag_sp__AbsXPath2--;
					continue;
				}
			}
			if (soap_flag_wsam__AnonymousResponses2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "wsam:AnonymousResponses", (char**)&a->wsp__Content::wsam__AnonymousResponses, "xsd:string"))
				{	soap_flag_wsam__AnonymousResponses2--;
					continue;
				}
			}
			if (soap_flag_wsam__NonAnonymousResponses2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "wsam:NonAnonymousResponses", (char**)&a->wsp__Content::wsam__NonAnonymousResponses, "xsd:string"))
				{	soap_flag_wsam__NonAnonymousResponses2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->wsp__Content::__any, ""))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wsp__Policy *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsp__Policy, SOAP_TYPE_wsp__Policy, sizeof(wsp__Policy), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsp__Policy * SOAP_FMAC2 wsdl_instantiate_wsp__Policy(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_wsp__Policy(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsp__Policy *p;
	size_t k = sizeof(wsp__Policy);
	if (n < 0)
	{	p = SOAP_NEW(wsp__Policy);
	}
	else
	{	p = SOAP_NEW_ARRAY(wsp__Policy, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsp__Policy location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_wsp__Policy, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int wsp__Policy::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsp__Policy(soap, tag ? tag : "wsp:Policy", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsp__Policy::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsp__Policy(soap, this, tag, type);
}

SOAP_FMAC3 wsp__Policy * SOAP_FMAC4 soap_get_wsp__Policy(struct soap *soap, wsp__Policy *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsp__Policy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsa__EndpointReferenceType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &this->wsa__EndpointReferenceType::Address);
	this->wsa__EndpointReferenceType::__any = NULL;
}

void wsa__EndpointReferenceType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__anyURI(soap, (char*const*)&this->wsa__EndpointReferenceType::Address);
#endif
}

int wsa__EndpointReferenceType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsa__EndpointReferenceType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa__EndpointReferenceType(struct soap *soap, const char *tag, int id, const wsa__EndpointReferenceType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa__EndpointReferenceType), type))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "wsa:Address", -1, (char*const*)&a->wsa__EndpointReferenceType::Address, ""))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->wsa__EndpointReferenceType::__any, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsa__EndpointReferenceType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wsa__EndpointReferenceType(soap, tag, this, type);
}

SOAP_FMAC3 wsa__EndpointReferenceType * SOAP_FMAC4 soap_in_wsa__EndpointReferenceType(struct soap *soap, const char *tag, wsa__EndpointReferenceType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsa__EndpointReferenceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__EndpointReferenceType, sizeof(wsa__EndpointReferenceType), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsa__EndpointReferenceType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsa__EndpointReferenceType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Address1 = 1;
	size_t soap_flag___any1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Address1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "wsa:Address", (char**)&a->wsa__EndpointReferenceType::Address, "xsd:anyURI"))
				{	soap_flag_Address1--;
					continue;
				}
			}
			if (soap_flag___any1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->wsa__EndpointReferenceType::__any))
				{	soap_flag___any1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wsa__EndpointReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa__EndpointReferenceType, SOAP_TYPE_wsa__EndpointReferenceType, sizeof(wsa__EndpointReferenceType), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsa__EndpointReferenceType * SOAP_FMAC2 wsdl_instantiate_wsa__EndpointReferenceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_wsa__EndpointReferenceType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsa__EndpointReferenceType *p;
	size_t k = sizeof(wsa__EndpointReferenceType);
	if (n < 0)
	{	p = SOAP_NEW(wsa__EndpointReferenceType);
	}
	else
	{	p = SOAP_NEW_ARRAY(wsa__EndpointReferenceType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsa__EndpointReferenceType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_wsa__EndpointReferenceType, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int wsa__EndpointReferenceType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsa__EndpointReferenceType(soap, tag ? tag : "wsa:EndpointReferenceType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsa__EndpointReferenceType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsa__EndpointReferenceType(soap, this, tag, type);
}

SOAP_FMAC3 wsa__EndpointReferenceType * SOAP_FMAC4 soap_get_wsa__EndpointReferenceType(struct soap *soap, wsa__EndpointReferenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__EndpointReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void gwsdl__portType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__NMTOKEN(soap, &this->gwsdl__portType::name);
	soap_default_xsd__QName(soap, &this->gwsdl__portType::extends);
	soap_default_xsd__string(soap, &this->gwsdl__portType::documentation);
	soap_default_std__vectorTemplateOfPointerTowsdl__operation(soap, &this->gwsdl__portType::operation);
	soap_default_std__vectorTemplateOfsd__serviceData(soap, &this->gwsdl__portType::sd__serviceData_);
	this->gwsdl__portType::sd__staticServiceDataValues_ = NULL;
}

void gwsdl__portType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__string(soap, (char*const*)&this->gwsdl__portType::documentation);
	soap_serialize_std__vectorTemplateOfPointerTowsdl__operation(soap, &this->gwsdl__portType::operation);
	soap_serialize_std__vectorTemplateOfsd__serviceData(soap, &this->gwsdl__portType::sd__serviceData_);
	soap_serialize_PointerTosd__staticServiceDataValues(soap, &this->gwsdl__portType::sd__staticServiceDataValues_);
#endif
}

int gwsdl__portType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_gwsdl__portType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_gwsdl__portType(struct soap *soap, const char *tag, int id, const gwsdl__portType *a, const char *type)
{
	if (((gwsdl__portType*)a)->name)
		soap_set_attr(soap, "name", soap_xsd__NMTOKEN2s(soap, ((gwsdl__portType*)a)->name), 1);
	if (((gwsdl__portType*)a)->extends)
		soap_set_attr(soap, "extends", soap_xsd__QName2s(soap, ((gwsdl__portType*)a)->extends), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_gwsdl__portType), type))
		return soap->error;
	if (soap_out_xsd__string(soap, "documentation", -1, (char*const*)&a->gwsdl__portType::documentation, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTowsdl__operation(soap, "operation", -1, &a->gwsdl__portType::operation, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfsd__serviceData(soap, "sd:serviceData", -1, &a->gwsdl__portType::sd__serviceData_, ""))
		return soap->error;
	if (soap_out_PointerTosd__staticServiceDataValues(soap, "sd:staticServiceDataValues", -1, &a->gwsdl__portType::sd__staticServiceDataValues_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *gwsdl__portType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_gwsdl__portType(soap, tag, this, type);
}

SOAP_FMAC3 gwsdl__portType * SOAP_FMAC4 soap_in_gwsdl__portType(struct soap *soap, const char *tag, gwsdl__portType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (gwsdl__portType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_gwsdl__portType, sizeof(gwsdl__portType), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_gwsdl__portType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (gwsdl__portType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__NMTOKEN(soap, soap_attr_value(soap, "name", 5, 0), &((gwsdl__portType*)a)->name))
		return NULL;
	if (soap_s2xsd__QName(soap, soap_attr_value(soap, "extends", 2, 0), &((gwsdl__portType*)a)->extends))
		return NULL;
	size_t soap_flag_documentation1 = 1;
	size_t soap_flag_sd__staticServiceDataValues_1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_documentation1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "documentation", (char**)&a->gwsdl__portType::documentation, "xsd:string"))
				{	soap_flag_documentation1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTowsdl__operation(soap, "operation", &a->gwsdl__portType::operation, "wsdl:operation"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfsd__serviceData(soap, "sd:serviceData", &a->gwsdl__portType::sd__serviceData_, "sd:serviceData"))
					continue;
			}
			if (soap_flag_sd__staticServiceDataValues_1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosd__staticServiceDataValues(soap, "sd:staticServiceDataValues", &a->gwsdl__portType::sd__staticServiceDataValues_, "sd:staticServiceDataValues"))
				{	soap_flag_sd__staticServiceDataValues_1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (gwsdl__portType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_gwsdl__portType, SOAP_TYPE_gwsdl__portType, sizeof(gwsdl__portType), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 gwsdl__portType * SOAP_FMAC2 wsdl_instantiate_gwsdl__portType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_gwsdl__portType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	gwsdl__portType *p;
	size_t k = sizeof(gwsdl__portType);
	if (n < 0)
	{	p = SOAP_NEW(gwsdl__portType);
	}
	else
	{	p = SOAP_NEW_ARRAY(gwsdl__portType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated gwsdl__portType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_gwsdl__portType, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int gwsdl__portType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_gwsdl__portType(soap, tag ? tag : "gwsdl:portType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *gwsdl__portType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_gwsdl__portType(soap, this, tag, type);
}

SOAP_FMAC3 gwsdl__portType * SOAP_FMAC4 soap_get_gwsdl__portType(struct soap *soap, gwsdl__portType *p, const char *tag, const char *type)
{
	if ((p = soap_in_gwsdl__portType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void sd__staticServiceDataValues::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->sd__staticServiceDataValues::__type = 0;
	this->sd__staticServiceDataValues::_any = NULL;
}

void sd__staticServiceDataValues::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_markelement(soap, this->_any, this->__type);
#endif
}

int sd__staticServiceDataValues::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_sd__staticServiceDataValues(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_sd__staticServiceDataValues(struct soap *soap, const char *tag, int id, const sd__staticServiceDataValues *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sd__staticServiceDataValues), type))
		return soap->error;
	if (soap_putelement(soap, a->sd__staticServiceDataValues::_any, "-type", -1, a->sd__staticServiceDataValues::__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *sd__staticServiceDataValues::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_sd__staticServiceDataValues(soap, tag, this, type);
}

SOAP_FMAC3 sd__staticServiceDataValues * SOAP_FMAC4 soap_in_sd__staticServiceDataValues(struct soap *soap, const char *tag, sd__staticServiceDataValues *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (sd__staticServiceDataValues *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sd__staticServiceDataValues, sizeof(sd__staticServiceDataValues), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_sd__staticServiceDataValues)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (sd__staticServiceDataValues *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag__any1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__any1 && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->sd__staticServiceDataValues::_any = soap_getelement(soap, &a->sd__staticServiceDataValues::__type)))
				{	soap_flag__any1 = 0;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (sd__staticServiceDataValues *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_sd__staticServiceDataValues, SOAP_TYPE_sd__staticServiceDataValues, sizeof(sd__staticServiceDataValues), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 sd__staticServiceDataValues * SOAP_FMAC2 wsdl_instantiate_sd__staticServiceDataValues(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_sd__staticServiceDataValues(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	sd__staticServiceDataValues *p;
	size_t k = sizeof(sd__staticServiceDataValues);
	if (n < 0)
	{	p = SOAP_NEW(sd__staticServiceDataValues);
	}
	else
	{	p = SOAP_NEW_ARRAY(sd__staticServiceDataValues, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated sd__staticServiceDataValues location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_sd__staticServiceDataValues, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int sd__staticServiceDataValues::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_sd__staticServiceDataValues(soap, tag ? tag : "sd:staticServiceDataValues", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *sd__staticServiceDataValues::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_sd__staticServiceDataValues(soap, this, tag, type);
}

SOAP_FMAC3 sd__staticServiceDataValues * SOAP_FMAC4 soap_get_sd__staticServiceDataValues(struct soap *soap, sd__staticServiceDataValues *p, const char *tag, const char *type)
{
	if ((p = soap_in_sd__staticServiceDataValues(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void sd__serviceData::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__NMTOKEN(soap, &this->sd__serviceData::name);
	soap_default_xsd__QName(soap, &this->sd__serviceData::type);
	this->sd__serviceData::nillable = (bool)0;
	soap_default_xsd__string(soap, &this->sd__serviceData::minOccurs);
	soap_default_xsd__string(soap, &this->sd__serviceData::maxOccurs);
	this->sd__serviceData::mutability = (enum sd__mutability)2;
	this->sd__serviceData::modifiable = (bool)0;
}

void sd__serviceData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int sd__serviceData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_sd__serviceData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_sd__serviceData(struct soap *soap, const char *tag, int id, const sd__serviceData *a, const char *type)
{
	if (((sd__serviceData*)a)->name)
		soap_set_attr(soap, "name", soap_xsd__NMTOKEN2s(soap, ((sd__serviceData*)a)->name), 1);
	if (((sd__serviceData*)a)->type)
		soap_set_attr(soap, "type", soap_xsd__QName2s(soap, ((sd__serviceData*)a)->type), 1);
	soap_set_attr(soap, "nillable", soap_xsd__boolean2s(soap, ((sd__serviceData*)a)->nillable), 1);
	if (((sd__serviceData*)a)->minOccurs)
		soap_set_attr(soap, "minOccurs", soap_xsd__string2s(soap, ((sd__serviceData*)a)->minOccurs), 1);
	if (((sd__serviceData*)a)->maxOccurs)
		soap_set_attr(soap, "maxOccurs", soap_xsd__string2s(soap, ((sd__serviceData*)a)->maxOccurs), 1);
	soap_set_attr(soap, "mutability", soap_sd__mutability2s(soap, ((sd__serviceData*)a)->mutability), 1);
	soap_set_attr(soap, "modifiable", soap_xsd__boolean2s(soap, ((sd__serviceData*)a)->modifiable), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sd__serviceData), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *sd__serviceData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_sd__serviceData(soap, tag, this, type);
}

SOAP_FMAC3 sd__serviceData * SOAP_FMAC4 soap_in_sd__serviceData(struct soap *soap, const char *tag, sd__serviceData *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (sd__serviceData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sd__serviceData, sizeof(sd__serviceData), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_sd__serviceData)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (sd__serviceData *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__NMTOKEN(soap, soap_attr_value(soap, "name", 5, 0), &((sd__serviceData*)a)->name))
		return NULL;
	if (soap_s2xsd__QName(soap, soap_attr_value(soap, "type", 2, 0), &((sd__serviceData*)a)->type))
		return NULL;
	if (soap_s2xsd__boolean(soap, soap_attr_value(soap, "nillable", 5, 0), &((sd__serviceData*)a)->nillable))
		return NULL;
	if (soap_s2xsd__string(soap, soap_attr_value(soap, "minOccurs", 1, 0), &((sd__serviceData*)a)->minOccurs))
		return NULL;
	if (soap_s2xsd__string(soap, soap_attr_value(soap, "maxOccurs", 1, 0), &((sd__serviceData*)a)->maxOccurs))
		return NULL;
	if (soap_s2sd__mutability(soap, soap_attr_value(soap, "mutability", 5, 0), &((sd__serviceData*)a)->mutability))
		return NULL;
	if (soap_s2xsd__boolean(soap, soap_attr_value(soap, "modifiable", 5, 0), &((sd__serviceData*)a)->modifiable))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (sd__serviceData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_sd__serviceData, SOAP_TYPE_sd__serviceData, sizeof(sd__serviceData), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 sd__serviceData * SOAP_FMAC2 wsdl_instantiate_sd__serviceData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_sd__serviceData(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	sd__serviceData *p;
	size_t k = sizeof(sd__serviceData);
	if (n < 0)
	{	p = SOAP_NEW(sd__serviceData);
	}
	else
	{	p = SOAP_NEW_ARRAY(sd__serviceData, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated sd__serviceData location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_sd__serviceData, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int sd__serviceData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_sd__serviceData(soap, tag ? tag : "sd:serviceData", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *sd__serviceData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_sd__serviceData(soap, this, tag, type);
}

SOAP_FMAC3 sd__serviceData * SOAP_FMAC4 soap_get_sd__serviceData(struct soap *soap, sd__serviceData *p, const char *tag, const char *type)
{
	if ((p = soap_in_sd__serviceData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsdl__operation::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__NMTOKEN(soap, &this->wsdl__operation::name);
	soap_default_xsd__anyURI(soap, &this->wsdl__operation::pattern);
	soap_default_xsd__anyURI(soap, &this->wsdl__operation::style);
	soap_default_xsd__string(soap, &this->wsdl__operation::wrpc__signature);
	soap_default_xsd__string(soap, &this->wsdl__operation::parameterOrder);
	soap_default_xsd__string(soap, &this->wsdl__operation::documentation);
	this->wsdl__operation::wsp__Policy_ = NULL;
	this->wsdl__operation::wsp__PolicyReference_ = NULL;
	this->wsdl__operation::__union1 = 0;
	this->wsdl__operation::__union2 = 0;
	soap_default_std__vectorTemplateOfwsdl__fault(soap, &this->wsdl__operation::fault);
	soap_default_std__vectorTemplateOfwsdl__fault(soap, &this->wsdl__operation::infault);
	soap_default_std__vectorTemplateOfwsdl__fault(soap, &this->wsdl__operation::outfault);
}

void wsdl__operation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__string(soap, (char*const*)&this->wsdl__operation::documentation);
	soap_serialize_PointerTowsp__Policy(soap, &this->wsdl__operation::wsp__Policy_);
	soap_serialize_PointerTowsp__PolicyReference(soap, &this->wsdl__operation::wsp__PolicyReference_);
	soap_serialize_wsdl__union_ioput(soap, this->wsdl__operation::__union1, &this->wsdl__operation::__ioput1);
	soap_serialize_wsdl__union_ioput(soap, this->wsdl__operation::__union2, &this->wsdl__operation::__ioput2);
	soap_serialize_std__vectorTemplateOfwsdl__fault(soap, &this->wsdl__operation::fault);
	soap_serialize_std__vectorTemplateOfwsdl__fault(soap, &this->wsdl__operation::infault);
	soap_serialize_std__vectorTemplateOfwsdl__fault(soap, &this->wsdl__operation::outfault);
#endif
}

int wsdl__operation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsdl__operation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdl__operation(struct soap *soap, const char *tag, int id, const wsdl__operation *a, const char *type)
{
	if (((wsdl__operation*)a)->name)
		soap_set_attr(soap, "name", soap_xsd__NMTOKEN2s(soap, ((wsdl__operation*)a)->name), 1);
	if (((wsdl__operation*)a)->pattern)
		soap_set_attr(soap, "pattern", soap_xsd__anyURI2s(soap, ((wsdl__operation*)a)->pattern), 1);
	if (((wsdl__operation*)a)->style)
		soap_set_attr(soap, "style", soap_xsd__anyURI2s(soap, ((wsdl__operation*)a)->style), 1);
	if (((wsdl__operation*)a)->wrpc__signature)
		soap_set_attr(soap, "wrpc:signature", soap_xsd__string2s(soap, ((wsdl__operation*)a)->wrpc__signature), 1);
	if (((wsdl__operation*)a)->parameterOrder)
		soap_set_attr(soap, "parameterOrder", soap_xsd__string2s(soap, ((wsdl__operation*)a)->parameterOrder), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsdl__operation), type))
		return soap->error;
	if (soap_out_xsd__string(soap, "wsdl:documentation", -1, (char*const*)&a->wsdl__operation::documentation, ""))
		return soap->error;
	if (soap_out_PointerTowsp__Policy(soap, "wsp:Policy", -1, &a->wsdl__operation::wsp__Policy_, ""))
		return soap->error;
	if (soap_out_PointerTowsp__PolicyReference(soap, "wsp:PolicyReference", -1, &a->wsdl__operation::wsp__PolicyReference_, ""))
		return soap->error;
	if (soap_out_wsdl__union_ioput(soap, a->wsdl__operation::__union1, &a->wsdl__operation::__ioput1))
		return soap->error;
	if (soap_out_wsdl__union_ioput(soap, a->wsdl__operation::__union2, &a->wsdl__operation::__ioput2))
		return soap->error;
	if (soap_out_std__vectorTemplateOfwsdl__fault(soap, "wsdl:fault", -1, &a->wsdl__operation::fault, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfwsdl__fault(soap, "wsdl:infault", -1, &a->wsdl__operation::infault, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfwsdl__fault(soap, "wsdl:outfault", -1, &a->wsdl__operation::outfault, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsdl__operation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wsdl__operation(soap, tag, this, type);
}

SOAP_FMAC3 wsdl__operation * SOAP_FMAC4 soap_in_wsdl__operation(struct soap *soap, const char *tag, wsdl__operation *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsdl__operation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsdl__operation, sizeof(wsdl__operation), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsdl__operation)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsdl__operation *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__NMTOKEN(soap, soap_attr_value(soap, "name", 5, 0), &((wsdl__operation*)a)->name))
		return NULL;
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "pattern", 4, 0), &((wsdl__operation*)a)->pattern))
		return NULL;
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "style", 4, 0), &((wsdl__operation*)a)->style))
		return NULL;
	if (soap_s2xsd__string(soap, soap_attr_value(soap, "wrpc:signature", 1, 0), &((wsdl__operation*)a)->wrpc__signature))
		return NULL;
	if (soap_s2xsd__string(soap, soap_attr_value(soap, "parameterOrder", 1, 0), &((wsdl__operation*)a)->parameterOrder))
		return NULL;
	size_t soap_flag_documentation1 = 1;
	size_t soap_flag_wsp__Policy_1 = 1;
	size_t soap_flag_wsp__PolicyReference_1 = 1;
	size_t soap_flag___ioput11 = 1;
	size_t soap_flag___ioput21 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_documentation1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "wsdl:documentation", (char**)&a->wsdl__operation::documentation, "xsd:string"))
				{	soap_flag_documentation1--;
					continue;
				}
			}
			if (soap_flag_wsp__Policy_1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsp__Policy(soap, "wsp:Policy", &a->wsdl__operation::wsp__Policy_, "wsp:Policy"))
				{	soap_flag_wsp__Policy_1--;
					continue;
				}
			}
			if (soap_flag_wsp__PolicyReference_1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsp__PolicyReference(soap, "wsp:PolicyReference", &a->wsdl__operation::wsp__PolicyReference_, "wsp:PolicyReference"))
				{	soap_flag_wsp__PolicyReference_1--;
					continue;
				}
			}
			if (soap_flag___ioput11 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_wsdl__union_ioput(soap, &a->wsdl__operation::__union1, &a->wsdl__operation::__ioput1))
				{	soap_flag___ioput11 = 0;
					continue;
				}
		}
			if (soap_flag___ioput21 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_wsdl__union_ioput(soap, &a->wsdl__operation::__union2, &a->wsdl__operation::__ioput2))
				{	soap_flag___ioput21 = 0;
					continue;
				}
		}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfwsdl__fault(soap, "wsdl:fault", &a->wsdl__operation::fault, "wsdl:fault"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfwsdl__fault(soap, "wsdl:infault", &a->wsdl__operation::infault, "wsdl:fault"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfwsdl__fault(soap, "wsdl:outfault", &a->wsdl__operation::outfault, "wsdl:fault"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wsdl__operation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsdl__operation, SOAP_TYPE_wsdl__operation, sizeof(wsdl__operation), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsdl__operation * SOAP_FMAC2 wsdl_instantiate_wsdl__operation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_wsdl__operation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsdl__operation *p;
	size_t k = sizeof(wsdl__operation);
	if (n < 0)
	{	p = SOAP_NEW(wsdl__operation);
	}
	else
	{	p = SOAP_NEW_ARRAY(wsdl__operation, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsdl__operation location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_wsdl__operation, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int wsdl__operation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsdl__operation(soap, tag ? tag : "wsdl:operation", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsdl__operation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsdl__operation(soap, this, tag, type);
}

SOAP_FMAC3 wsdl__operation * SOAP_FMAC4 soap_get_wsdl__operation(struct soap *soap, wsdl__operation *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsdl__operation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void whttp__header::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &this->whttp__header::name);
	soap_default_xsd__QName(soap, &this->whttp__header::type);
	this->whttp__header::required = (bool)0;
}

void whttp__header::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int whttp__header::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_whttp__header(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_whttp__header(struct soap *soap, const char *tag, int id, const whttp__header *a, const char *type)
{
	if (((whttp__header*)a)->name)
		soap_set_attr(soap, "name", soap_xsd__string2s(soap, ((whttp__header*)a)->name), 1);
	if (((whttp__header*)a)->type)
		soap_set_attr(soap, "type", soap_xsd__QName2s(soap, ((whttp__header*)a)->type), 1);
	soap_set_attr(soap, "required", soap_xsd__boolean2s(soap, ((whttp__header*)a)->required), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_whttp__header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *whttp__header::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_whttp__header(soap, tag, this, type);
}

SOAP_FMAC3 whttp__header * SOAP_FMAC4 soap_in_whttp__header(struct soap *soap, const char *tag, whttp__header *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (whttp__header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_whttp__header, sizeof(whttp__header), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_whttp__header)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (whttp__header *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__string(soap, soap_attr_value(soap, "name", 1, 0), &((whttp__header*)a)->name))
		return NULL;
	if (soap_s2xsd__QName(soap, soap_attr_value(soap, "type", 2, 0), &((whttp__header*)a)->type))
		return NULL;
	if (soap_s2xsd__boolean(soap, soap_attr_value(soap, "required", 5, 0), &((whttp__header*)a)->required))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (whttp__header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_whttp__header, SOAP_TYPE_whttp__header, sizeof(whttp__header), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 whttp__header * SOAP_FMAC2 wsdl_instantiate_whttp__header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_whttp__header(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	whttp__header *p;
	size_t k = sizeof(whttp__header);
	if (n < 0)
	{	p = SOAP_NEW(whttp__header);
	}
	else
	{	p = SOAP_NEW_ARRAY(whttp__header, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated whttp__header location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_whttp__header, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int whttp__header::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_whttp__header(soap, tag ? tag : "whttp:header", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *whttp__header::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_whttp__header(soap, this, tag, type);
}

SOAP_FMAC3 whttp__header * SOAP_FMAC4 soap_get_whttp__header(struct soap *soap, whttp__header *p, const char *tag, const char *type)
{
	if ((p = soap_in_whttp__header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void http__operation::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &this->http__operation::location);
}

void http__operation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int http__operation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_http__operation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_http__operation(struct soap *soap, const char *tag, int id, const http__operation *a, const char *type)
{
	if (((http__operation*)a)->location)
		soap_set_attr(soap, "location", soap_xsd__anyURI2s(soap, ((http__operation*)a)->location), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_http__operation), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *http__operation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_http__operation(soap, tag, this, type);
}

SOAP_FMAC3 http__operation * SOAP_FMAC4 soap_in_http__operation(struct soap *soap, const char *tag, http__operation *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (http__operation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_http__operation, sizeof(http__operation), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_http__operation)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (http__operation *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "location", 4, 0), &((http__operation*)a)->location))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (http__operation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_http__operation, SOAP_TYPE_http__operation, sizeof(http__operation), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 http__operation * SOAP_FMAC2 wsdl_instantiate_http__operation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_http__operation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	http__operation *p;
	size_t k = sizeof(http__operation);
	if (n < 0)
	{	p = SOAP_NEW(http__operation);
	}
	else
	{	p = SOAP_NEW_ARRAY(http__operation, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated http__operation location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_http__operation, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int http__operation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_http__operation(soap, tag ? tag : "http:operation", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *http__operation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_http__operation(soap, this, tag, type);
}

SOAP_FMAC3 http__operation * SOAP_FMAC4 soap_get_http__operation(struct soap *soap, http__operation *p, const char *tag, const char *type)
{
	if ((p = soap_in_http__operation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void http__binding::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__NMTOKEN(soap, &this->http__binding::verb);
}

void http__binding::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int http__binding::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_http__binding(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_http__binding(struct soap *soap, const char *tag, int id, const http__binding *a, const char *type)
{
	if (((http__binding*)a)->verb)
		soap_set_attr(soap, "verb", soap_xsd__NMTOKEN2s(soap, ((http__binding*)a)->verb), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_http__binding), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *http__binding::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_http__binding(soap, tag, this, type);
}

SOAP_FMAC3 http__binding * SOAP_FMAC4 soap_in_http__binding(struct soap *soap, const char *tag, http__binding *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (http__binding *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_http__binding, sizeof(http__binding), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_http__binding)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (http__binding *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__NMTOKEN(soap, soap_attr_value(soap, "verb", 5, 0), &((http__binding*)a)->verb))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (http__binding *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_http__binding, SOAP_TYPE_http__binding, sizeof(http__binding), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 http__binding * SOAP_FMAC2 wsdl_instantiate_http__binding(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_http__binding(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	http__binding *p;
	size_t k = sizeof(http__binding);
	if (n < 0)
	{	p = SOAP_NEW(http__binding);
	}
	else
	{	p = SOAP_NEW_ARRAY(http__binding, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated http__binding location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_http__binding, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int http__binding::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_http__binding(soap, tag ? tag : "http:binding", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *http__binding::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_http__binding(soap, this, tag, type);
}

SOAP_FMAC3 http__binding * SOAP_FMAC4 soap_get_http__binding(struct soap *soap, http__binding *p, const char *tag, const char *type)
{
	if ((p = soap_in_http__binding(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void http__address::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &this->http__address::location);
}

void http__address::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int http__address::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_http__address(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_http__address(struct soap *soap, const char *tag, int id, const http__address *a, const char *type)
{
	if (((http__address*)a)->location)
		soap_set_attr(soap, "location", soap_xsd__anyURI2s(soap, ((http__address*)a)->location), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_http__address), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *http__address::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_http__address(soap, tag, this, type);
}

SOAP_FMAC3 http__address * SOAP_FMAC4 soap_in_http__address(struct soap *soap, const char *tag, http__address *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (http__address *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_http__address, sizeof(http__address), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_http__address)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (http__address *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "location", 4, 0), &((http__address*)a)->location))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (http__address *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_http__address, SOAP_TYPE_http__address, sizeof(http__address), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 http__address * SOAP_FMAC2 wsdl_instantiate_http__address(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_http__address(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	http__address *p;
	size_t k = sizeof(http__address);
	if (n < 0)
	{	p = SOAP_NEW(http__address);
	}
	else
	{	p = SOAP_NEW_ARRAY(http__address, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated http__address location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_http__address, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int http__address::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_http__address(soap, tag ? tag : "http:address", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *http__address::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_http__address(soap, this, tag, type);
}

SOAP_FMAC3 http__address * SOAP_FMAC4 soap_get_http__address(struct soap *soap, http__address *p, const char *tag, const char *type)
{
	if ((p = soap_in_http__address(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void dime__message::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &this->dime__message::layout);
}

void dime__message::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int dime__message::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_dime__message(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dime__message(struct soap *soap, const char *tag, int id, const dime__message *a, const char *type)
{
	if (((dime__message*)a)->layout)
		soap_set_attr(soap, "layout", soap_xsd__anyURI2s(soap, ((dime__message*)a)->layout), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dime__message), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *dime__message::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_dime__message(soap, tag, this, type);
}

SOAP_FMAC3 dime__message * SOAP_FMAC4 soap_in_dime__message(struct soap *soap, const char *tag, dime__message *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (dime__message *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dime__message, sizeof(dime__message), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_dime__message)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (dime__message *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "layout", 4, 0), &((dime__message*)a)->layout))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (dime__message *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dime__message, SOAP_TYPE_dime__message, sizeof(dime__message), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 dime__message * SOAP_FMAC2 wsdl_instantiate_dime__message(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_dime__message(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	dime__message *p;
	size_t k = sizeof(dime__message);
	if (n < 0)
	{	p = SOAP_NEW(dime__message);
	}
	else
	{	p = SOAP_NEW_ARRAY(dime__message, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated dime__message location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_dime__message, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int dime__message::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_dime__message(soap, tag ? tag : "dime:message", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *dime__message::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_dime__message(soap, this, tag, type);
}

SOAP_FMAC3 dime__message * SOAP_FMAC4 soap_get_dime__message(struct soap *soap, dime__message *p, const char *tag, const char *type)
{
	if ((p = soap_in_dime__message(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void mime__mimeXml::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__NMTOKEN(soap, &this->mime__mimeXml::part);
}

void mime__mimeXml::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int mime__mimeXml::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_mime__mimeXml(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_mime__mimeXml(struct soap *soap, const char *tag, int id, const mime__mimeXml *a, const char *type)
{
	if (((mime__mimeXml*)a)->part)
		soap_set_attr(soap, "part", soap_xsd__NMTOKEN2s(soap, ((mime__mimeXml*)a)->part), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_mime__mimeXml), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *mime__mimeXml::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_mime__mimeXml(soap, tag, this, type);
}

SOAP_FMAC3 mime__mimeXml * SOAP_FMAC4 soap_in_mime__mimeXml(struct soap *soap, const char *tag, mime__mimeXml *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (mime__mimeXml *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_mime__mimeXml, sizeof(mime__mimeXml), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_mime__mimeXml)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (mime__mimeXml *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__NMTOKEN(soap, soap_attr_value(soap, "part", 5, 0), &((mime__mimeXml*)a)->part))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (mime__mimeXml *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_mime__mimeXml, SOAP_TYPE_mime__mimeXml, sizeof(mime__mimeXml), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 mime__mimeXml * SOAP_FMAC2 wsdl_instantiate_mime__mimeXml(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_mime__mimeXml(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	mime__mimeXml *p;
	size_t k = sizeof(mime__mimeXml);
	if (n < 0)
	{	p = SOAP_NEW(mime__mimeXml);
	}
	else
	{	p = SOAP_NEW_ARRAY(mime__mimeXml, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated mime__mimeXml location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_mime__mimeXml, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int mime__mimeXml::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_mime__mimeXml(soap, tag ? tag : "mime:mimeXml", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *mime__mimeXml::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_mime__mimeXml(soap, this, tag, type);
}

SOAP_FMAC3 mime__mimeXml * SOAP_FMAC4 soap_get_mime__mimeXml(struct soap *soap, mime__mimeXml *p, const char *tag, const char *type)
{
	if ((p = soap_in_mime__mimeXml(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void mime__multipartRelated::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfmime__part(soap, &this->mime__multipartRelated::part);
}

void mime__multipartRelated::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfmime__part(soap, &this->mime__multipartRelated::part);
#endif
}

int mime__multipartRelated::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_mime__multipartRelated(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_mime__multipartRelated(struct soap *soap, const char *tag, int id, const mime__multipartRelated *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_mime__multipartRelated), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfmime__part(soap, "mime:part", -1, &a->mime__multipartRelated::part, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *mime__multipartRelated::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_mime__multipartRelated(soap, tag, this, type);
}

SOAP_FMAC3 mime__multipartRelated * SOAP_FMAC4 soap_in_mime__multipartRelated(struct soap *soap, const char *tag, mime__multipartRelated *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (mime__multipartRelated *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_mime__multipartRelated, sizeof(mime__multipartRelated), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_mime__multipartRelated)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (mime__multipartRelated *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfmime__part(soap, "mime:part", &a->mime__multipartRelated::part, "mime:part"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (mime__multipartRelated *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_mime__multipartRelated, SOAP_TYPE_mime__multipartRelated, sizeof(mime__multipartRelated), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 mime__multipartRelated * SOAP_FMAC2 wsdl_instantiate_mime__multipartRelated(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_mime__multipartRelated(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	mime__multipartRelated *p;
	size_t k = sizeof(mime__multipartRelated);
	if (n < 0)
	{	p = SOAP_NEW(mime__multipartRelated);
	}
	else
	{	p = SOAP_NEW_ARRAY(mime__multipartRelated, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated mime__multipartRelated location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_mime__multipartRelated, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int mime__multipartRelated::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_mime__multipartRelated(soap, tag ? tag : "mime:multipartRelated", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *mime__multipartRelated::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_mime__multipartRelated(soap, this, tag, type);
}

SOAP_FMAC3 mime__multipartRelated * SOAP_FMAC4 soap_get_mime__multipartRelated(struct soap *soap, mime__multipartRelated *p, const char *tag, const char *type)
{
	if ((p = soap_in_mime__multipartRelated(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void mime__part::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->mime__part::soap__body_ = NULL;
	soap_default_std__vectorTemplateOfsoap__header(soap, &this->mime__part::soap__header_);
	soap_default_std__vectorTemplateOfmime__content(soap, &this->mime__part::content);
}

void mime__part::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTosoap__body(soap, &this->mime__part::soap__body_);
	soap_serialize_std__vectorTemplateOfsoap__header(soap, &this->mime__part::soap__header_);
	soap_serialize_std__vectorTemplateOfmime__content(soap, &this->mime__part::content);
#endif
}

int mime__part::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_mime__part(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_mime__part(struct soap *soap, const char *tag, int id, const mime__part *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_mime__part), type))
		return soap->error;
	if (soap_out_PointerTosoap__body(soap, "soap:body", -1, &a->mime__part::soap__body_, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfsoap__header(soap, "soap:header", -1, &a->mime__part::soap__header_, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfmime__content(soap, "mime:content", -1, &a->mime__part::content, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *mime__part::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_mime__part(soap, tag, this, type);
}

SOAP_FMAC3 mime__part * SOAP_FMAC4 soap_in_mime__part(struct soap *soap, const char *tag, mime__part *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (mime__part *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_mime__part, sizeof(mime__part), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_mime__part)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (mime__part *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soap__body_1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_soap__body_1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosoap__body(soap, "soap:body", &a->mime__part::soap__body_, "soap:body"))
				{	soap_flag_soap__body_1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfsoap__header(soap, "soap:header", &a->mime__part::soap__header_, "soap:header"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfmime__content(soap, "mime:content", &a->mime__part::content, "mime:content"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (mime__part *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_mime__part, SOAP_TYPE_mime__part, sizeof(mime__part), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 mime__part * SOAP_FMAC2 wsdl_instantiate_mime__part(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_mime__part(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	mime__part *p;
	size_t k = sizeof(mime__part);
	if (n < 0)
	{	p = SOAP_NEW(mime__part);
	}
	else
	{	p = SOAP_NEW_ARRAY(mime__part, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated mime__part location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_mime__part, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int mime__part::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_mime__part(soap, tag ? tag : "mime:part", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *mime__part::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_mime__part(soap, this, tag, type);
}

SOAP_FMAC3 mime__part * SOAP_FMAC4 soap_get_mime__part(struct soap *soap, mime__part *p, const char *tag, const char *type)
{
	if ((p = soap_in_mime__part(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void mime__content::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__NMTOKEN(soap, &this->mime__content::part);
	soap_default_xsd__string(soap, &this->mime__content::type);
}

void mime__content::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int mime__content::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_mime__content(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_mime__content(struct soap *soap, const char *tag, int id, const mime__content *a, const char *type)
{
	if (((mime__content*)a)->part)
		soap_set_attr(soap, "part", soap_xsd__NMTOKEN2s(soap, ((mime__content*)a)->part), 1);
	if (((mime__content*)a)->type)
		soap_set_attr(soap, "type", soap_xsd__string2s(soap, ((mime__content*)a)->type), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_mime__content), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *mime__content::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_mime__content(soap, tag, this, type);
}

SOAP_FMAC3 mime__content * SOAP_FMAC4 soap_in_mime__content(struct soap *soap, const char *tag, mime__content *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (mime__content *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_mime__content, sizeof(mime__content), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_mime__content)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (mime__content *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__NMTOKEN(soap, soap_attr_value(soap, "part", 5, 0), &((mime__content*)a)->part))
		return NULL;
	if (soap_s2xsd__string(soap, soap_attr_value(soap, "type", 1, 0), &((mime__content*)a)->type))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (mime__content *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_mime__content, SOAP_TYPE_mime__content, sizeof(mime__content), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 mime__content * SOAP_FMAC2 wsdl_instantiate_mime__content(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_mime__content(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	mime__content *p;
	size_t k = sizeof(mime__content);
	if (n < 0)
	{	p = SOAP_NEW(mime__content);
	}
	else
	{	p = SOAP_NEW_ARRAY(mime__content, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated mime__content location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_mime__content, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int mime__content::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_mime__content(soap, tag ? tag : "mime:content", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *mime__content::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_mime__content(soap, this, tag, type);
}

SOAP_FMAC3 mime__content * SOAP_FMAC4 soap_get_mime__content(struct soap *soap, mime__content *p, const char *tag, const char *type)
{
	if ((p = soap_in_mime__content(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsoap__header::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__QName(soap, &this->wsoap__header::element);
	this->wsoap__header::mustUnderstand_ = (bool)0;
	this->wsoap__header::required = (bool)0;
	this->wsoap__header::elementRef = NULL;
}

void wsoap__header::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	/* non-serializable elementRef skipped */
#endif
}

int wsoap__header::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsoap__header(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsoap__header(struct soap *soap, const char *tag, int id, const wsoap__header *a, const char *type)
{
	if (((wsoap__header*)a)->element)
		soap_set_attr(soap, "element", soap_xsd__QName2s(soap, ((wsoap__header*)a)->element), 1);
	soap_set_attr(soap, "mustUnderstand", soap_xsd__boolean2s(soap, ((wsoap__header*)a)->mustUnderstand_), 1);
	soap_set_attr(soap, "required", soap_xsd__boolean2s(soap, ((wsoap__header*)a)->required), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsoap__header), type))
		return soap->error;
	/* non-serializable elementRef skipped */
	return soap_element_end_out(soap, tag);
}

void *wsoap__header::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wsoap__header(soap, tag, this, type);
}

SOAP_FMAC3 wsoap__header * SOAP_FMAC4 soap_in_wsoap__header(struct soap *soap, const char *tag, wsoap__header *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsoap__header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsoap__header, sizeof(wsoap__header), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsoap__header)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsoap__header *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__QName(soap, soap_attr_value(soap, "element", 2, 0), &((wsoap__header*)a)->element))
		return NULL;
	if (soap_s2xsd__boolean(soap, soap_attr_value(soap, "mustUnderstand", 5, 0), &((wsoap__header*)a)->mustUnderstand_))
		return NULL;
	if (soap_s2xsd__boolean(soap, soap_attr_value(soap, "required", 5, 0), &((wsoap__header*)a)->required))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* non-serializable elementRef skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wsoap__header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsoap__header, SOAP_TYPE_wsoap__header, sizeof(wsoap__header), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsoap__header * SOAP_FMAC2 wsdl_instantiate_wsoap__header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_wsoap__header(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsoap__header *p;
	size_t k = sizeof(wsoap__header);
	if (n < 0)
	{	p = SOAP_NEW(wsoap__header);
	}
	else
	{	p = SOAP_NEW_ARRAY(wsoap__header, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsoap__header location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_wsoap__header, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int wsoap__header::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsoap__header(soap, tag ? tag : "wsoap:header", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsoap__header::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsoap__header(soap, this, tag, type);
}

SOAP_FMAC3 wsoap__header * SOAP_FMAC4 soap_get_wsoap__header(struct soap *soap, wsoap__header *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsoap__header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsoap__module::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &this->wsoap__module::ref);
	this->wsoap__module::required = (bool)0;
}

void wsoap__module::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int wsoap__module::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsoap__module(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsoap__module(struct soap *soap, const char *tag, int id, const wsoap__module *a, const char *type)
{
	if (((wsoap__module*)a)->ref)
		soap_set_attr(soap, "ref", soap_xsd__anyURI2s(soap, ((wsoap__module*)a)->ref), 1);
	soap_set_attr(soap, "required", soap_xsd__boolean2s(soap, ((wsoap__module*)a)->required), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsoap__module), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsoap__module::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wsoap__module(soap, tag, this, type);
}

SOAP_FMAC3 wsoap__module * SOAP_FMAC4 soap_in_wsoap__module(struct soap *soap, const char *tag, wsoap__module *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsoap__module *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsoap__module, sizeof(wsoap__module), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsoap__module)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsoap__module *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "ref", 4, 0), &((wsoap__module*)a)->ref))
		return NULL;
	if (soap_s2xsd__boolean(soap, soap_attr_value(soap, "required", 5, 0), &((wsoap__module*)a)->required))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wsoap__module *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsoap__module, SOAP_TYPE_wsoap__module, sizeof(wsoap__module), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsoap__module * SOAP_FMAC2 wsdl_instantiate_wsoap__module(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_wsoap__module(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsoap__module *p;
	size_t k = sizeof(wsoap__module);
	if (n < 0)
	{	p = SOAP_NEW(wsoap__module);
	}
	else
	{	p = SOAP_NEW_ARRAY(wsoap__module, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsoap__module location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_wsoap__module, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int wsoap__module::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsoap__module(soap, tag ? tag : "wsoap:module", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsoap__module::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsoap__module(soap, this, tag, type);
}

SOAP_FMAC3 wsoap__module * SOAP_FMAC4 soap_get_wsoap__module(struct soap *soap, wsoap__module *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsoap__module(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void soap__address::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &this->soap__address::location);
}

void soap__address::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int soap__address::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_soap__address(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_soap__address(struct soap *soap, const char *tag, int id, const soap__address *a, const char *type)
{
	if (((soap__address*)a)->location)
		soap_set_attr(soap, "location", soap_xsd__anyURI2s(soap, ((soap__address*)a)->location), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_soap__address), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *soap__address::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_soap__address(soap, tag, this, type);
}

SOAP_FMAC3 soap__address * SOAP_FMAC4 soap_in_soap__address(struct soap *soap, const char *tag, soap__address *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (soap__address *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_soap__address, sizeof(soap__address), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_soap__address)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (soap__address *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "location", 4, 0), &((soap__address*)a)->location))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (soap__address *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_soap__address, SOAP_TYPE_soap__address, sizeof(soap__address), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 soap__address * SOAP_FMAC2 wsdl_instantiate_soap__address(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_soap__address(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	soap__address *p;
	size_t k = sizeof(soap__address);
	if (n < 0)
	{	p = SOAP_NEW(soap__address);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap__address, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated soap__address location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_soap__address, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int soap__address::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_soap__address(soap, tag ? tag : "soap:address", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *soap__address::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_soap__address(soap, this, tag, type);
}

SOAP_FMAC3 soap__address * SOAP_FMAC4 soap_get_soap__address(struct soap *soap, soap__address *p, const char *tag, const char *type)
{
	if ((p = soap_in_soap__address(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void soap__header::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__QName(soap, &this->soap__header::message);
	soap_default_xsd__NMTOKEN(soap, &this->soap__header::part);
	soap_default_soap__useChoice(soap, &this->soap__header::use);
	soap_default_xsd__anyURI(soap, &this->soap__header::encodingStyle);
	soap_default_xsd__anyURI(soap, &this->soap__header::namespace_);
	soap_default_std__vectorTemplateOfsoap__headerfault(soap, &this->soap__header::headerfault);
	this->soap__header::messageRef = NULL;
	this->soap__header::partRef = NULL;
}

void soap__header::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfsoap__headerfault(soap, &this->soap__header::headerfault);
	/* non-serializable messageRef skipped */
	/* non-serializable partRef skipped */
#endif
}

int soap__header::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_soap__header(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_soap__header(struct soap *soap, const char *tag, int id, const soap__header *a, const char *type)
{
	if (((soap__header*)a)->message)
		soap_set_attr(soap, "message", soap_xsd__QName2s(soap, ((soap__header*)a)->message), 1);
	if (((soap__header*)a)->part)
		soap_set_attr(soap, "part", soap_xsd__NMTOKEN2s(soap, ((soap__header*)a)->part), 1);
	soap_set_attr(soap, "use", soap_soap__useChoice2s(soap, ((soap__header*)a)->use), 1);
	if (((soap__header*)a)->encodingStyle)
		soap_set_attr(soap, "encodingStyle", soap_xsd__anyURI2s(soap, ((soap__header*)a)->encodingStyle), 1);
	if (((soap__header*)a)->namespace_)
		soap_set_attr(soap, "namespace", soap_xsd__anyURI2s(soap, ((soap__header*)a)->namespace_), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_soap__header), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfsoap__headerfault(soap, "soap:headerfault", -1, &a->soap__header::headerfault, ""))
		return soap->error;
	/* non-serializable messageRef skipped */
	/* non-serializable partRef skipped */
	return soap_element_end_out(soap, tag);
}

void *soap__header::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_soap__header(soap, tag, this, type);
}

SOAP_FMAC3 soap__header * SOAP_FMAC4 soap_in_soap__header(struct soap *soap, const char *tag, soap__header *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (soap__header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_soap__header, sizeof(soap__header), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_soap__header)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (soap__header *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__QName(soap, soap_attr_value(soap, "message", 2, 0), &((soap__header*)a)->message))
		return NULL;
	if (soap_s2xsd__NMTOKEN(soap, soap_attr_value(soap, "part", 5, 0), &((soap__header*)a)->part))
		return NULL;
	if (soap_s2soap__useChoice(soap, soap_attr_value(soap, "use", 5, 0), &((soap__header*)a)->use))
		return NULL;
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "encodingStyle", 4, 0), &((soap__header*)a)->encodingStyle))
		return NULL;
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "namespace", 4, 0), &((soap__header*)a)->namespace_))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfsoap__headerfault(soap, "soap:headerfault", &a->soap__header::headerfault, "soap:headerfault"))
					continue;
			}
			/* non-serializable messageRef skipped */
			/* non-serializable partRef skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (soap__header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_soap__header, SOAP_TYPE_soap__header, sizeof(soap__header), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 soap__header * SOAP_FMAC2 wsdl_instantiate_soap__header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_soap__header(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	soap__header *p;
	size_t k = sizeof(soap__header);
	if (n < 0)
	{	p = SOAP_NEW(soap__header);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap__header, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated soap__header location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_soap__header, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int soap__header::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_soap__header(soap, tag ? tag : "soap:header", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *soap__header::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_soap__header(soap, this, tag, type);
}

SOAP_FMAC3 soap__header * SOAP_FMAC4 soap_get_soap__header(struct soap *soap, soap__header *p, const char *tag, const char *type)
{
	if ((p = soap_in_soap__header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void soap__headerfault::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__QName(soap, &this->soap__headerfault::message);
	soap_default_xsd__NMTOKEN(soap, &this->soap__headerfault::part);
	soap_default_soap__useChoice(soap, &this->soap__headerfault::use);
	soap_default_xsd__anyURI(soap, &this->soap__headerfault::encodingStyle);
	soap_default_xsd__anyURI(soap, &this->soap__headerfault::namespace_);
	this->soap__headerfault::messageRef = NULL;
	this->soap__headerfault::partRef = NULL;
}

void soap__headerfault::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	/* non-serializable messageRef skipped */
	/* non-serializable partRef skipped */
#endif
}

int soap__headerfault::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_soap__headerfault(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_soap__headerfault(struct soap *soap, const char *tag, int id, const soap__headerfault *a, const char *type)
{
	if (((soap__headerfault*)a)->message)
		soap_set_attr(soap, "message", soap_xsd__QName2s(soap, ((soap__headerfault*)a)->message), 1);
	if (((soap__headerfault*)a)->part)
		soap_set_attr(soap, "part", soap_xsd__NMTOKEN2s(soap, ((soap__headerfault*)a)->part), 1);
	soap_set_attr(soap, "use", soap_soap__useChoice2s(soap, ((soap__headerfault*)a)->use), 1);
	if (((soap__headerfault*)a)->encodingStyle)
		soap_set_attr(soap, "encodingStyle", soap_xsd__anyURI2s(soap, ((soap__headerfault*)a)->encodingStyle), 1);
	if (((soap__headerfault*)a)->namespace_)
		soap_set_attr(soap, "namespace", soap_xsd__anyURI2s(soap, ((soap__headerfault*)a)->namespace_), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_soap__headerfault), type))
		return soap->error;
	/* non-serializable messageRef skipped */
	/* non-serializable partRef skipped */
	return soap_element_end_out(soap, tag);
}

void *soap__headerfault::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_soap__headerfault(soap, tag, this, type);
}

SOAP_FMAC3 soap__headerfault * SOAP_FMAC4 soap_in_soap__headerfault(struct soap *soap, const char *tag, soap__headerfault *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (soap__headerfault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_soap__headerfault, sizeof(soap__headerfault), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_soap__headerfault)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (soap__headerfault *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__QName(soap, soap_attr_value(soap, "message", 2, 0), &((soap__headerfault*)a)->message))
		return NULL;
	if (soap_s2xsd__NMTOKEN(soap, soap_attr_value(soap, "part", 5, 0), &((soap__headerfault*)a)->part))
		return NULL;
	if (soap_s2soap__useChoice(soap, soap_attr_value(soap, "use", 5, 0), &((soap__headerfault*)a)->use))
		return NULL;
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "encodingStyle", 4, 0), &((soap__headerfault*)a)->encodingStyle))
		return NULL;
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "namespace", 4, 0), &((soap__headerfault*)a)->namespace_))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* non-serializable messageRef skipped */
			/* non-serializable partRef skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (soap__headerfault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_soap__headerfault, SOAP_TYPE_soap__headerfault, sizeof(soap__headerfault), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 soap__headerfault * SOAP_FMAC2 wsdl_instantiate_soap__headerfault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_soap__headerfault(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	soap__headerfault *p;
	size_t k = sizeof(soap__headerfault);
	if (n < 0)
	{	p = SOAP_NEW(soap__headerfault);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap__headerfault, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated soap__headerfault location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_soap__headerfault, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int soap__headerfault::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_soap__headerfault(soap, tag ? tag : "soap:headerfault", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *soap__headerfault::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_soap__headerfault(soap, this, tag, type);
}

SOAP_FMAC3 soap__headerfault * SOAP_FMAC4 soap_get_soap__headerfault(struct soap *soap, soap__headerfault *p, const char *tag, const char *type)
{
	if ((p = soap_in_soap__headerfault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void soap__fault::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__NMTOKEN(soap, &this->soap__fault::name);
	soap_default_xsd__anyURI(soap, &this->soap__fault::encodingStyle);
	soap_default_soap__useChoice(soap, &this->soap__fault::use);
	soap_default_xsd__anyURI(soap, &this->soap__fault::namespace_);
}

void soap__fault::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int soap__fault::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_soap__fault(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_soap__fault(struct soap *soap, const char *tag, int id, const soap__fault *a, const char *type)
{
	if (((soap__fault*)a)->name)
		soap_set_attr(soap, "name", soap_xsd__NMTOKEN2s(soap, ((soap__fault*)a)->name), 1);
	if (((soap__fault*)a)->encodingStyle)
		soap_set_attr(soap, "encodingStyle", soap_xsd__anyURI2s(soap, ((soap__fault*)a)->encodingStyle), 1);
	soap_set_attr(soap, "use", soap_soap__useChoice2s(soap, ((soap__fault*)a)->use), 1);
	if (((soap__fault*)a)->namespace_)
		soap_set_attr(soap, "namespace", soap_xsd__anyURI2s(soap, ((soap__fault*)a)->namespace_), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_soap__fault), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *soap__fault::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_soap__fault(soap, tag, this, type);
}

SOAP_FMAC3 soap__fault * SOAP_FMAC4 soap_in_soap__fault(struct soap *soap, const char *tag, soap__fault *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (soap__fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_soap__fault, sizeof(soap__fault), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_soap__fault)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (soap__fault *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__NMTOKEN(soap, soap_attr_value(soap, "name", 5, 0), &((soap__fault*)a)->name))
		return NULL;
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "encodingStyle", 4, 0), &((soap__fault*)a)->encodingStyle))
		return NULL;
	if (soap_s2soap__useChoice(soap, soap_attr_value(soap, "use", 5, 0), &((soap__fault*)a)->use))
		return NULL;
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "namespace", 4, 0), &((soap__fault*)a)->namespace_))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (soap__fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_soap__fault, SOAP_TYPE_soap__fault, sizeof(soap__fault), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 soap__fault * SOAP_FMAC2 wsdl_instantiate_soap__fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_soap__fault(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	soap__fault *p;
	size_t k = sizeof(soap__fault);
	if (n < 0)
	{	p = SOAP_NEW(soap__fault);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap__fault, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated soap__fault location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_soap__fault, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int soap__fault::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_soap__fault(soap, tag ? tag : "soap:fault", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *soap__fault::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_soap__fault(soap, this, tag, type);
}

SOAP_FMAC3 soap__fault * SOAP_FMAC4 soap_get_soap__fault(struct soap *soap, soap__fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_soap__fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void soap__body::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &this->soap__body::encodingStyle);
	soap_default_xsd__NMTOKENS(soap, &this->soap__body::parts);
	soap_default_soap__useChoice(soap, &this->soap__body::use);
	soap_default_xsd__anyURI(soap, &this->soap__body::namespace_);
}

void soap__body::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int soap__body::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_soap__body(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_soap__body(struct soap *soap, const char *tag, int id, const soap__body *a, const char *type)
{
	if (((soap__body*)a)->encodingStyle)
		soap_set_attr(soap, "encodingStyle", soap_xsd__anyURI2s(soap, ((soap__body*)a)->encodingStyle), 1);
	if (((soap__body*)a)->parts)
		soap_set_attr(soap, "parts", soap_xsd__NMTOKENS2s(soap, ((soap__body*)a)->parts), 1);
	soap_set_attr(soap, "use", soap_soap__useChoice2s(soap, ((soap__body*)a)->use), 1);
	if (((soap__body*)a)->namespace_)
		soap_set_attr(soap, "namespace", soap_xsd__anyURI2s(soap, ((soap__body*)a)->namespace_), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_soap__body), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *soap__body::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_soap__body(soap, tag, this, type);
}

SOAP_FMAC3 soap__body * SOAP_FMAC4 soap_in_soap__body(struct soap *soap, const char *tag, soap__body *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (soap__body *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_soap__body, sizeof(soap__body), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_soap__body)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (soap__body *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "encodingStyle", 4, 0), &((soap__body*)a)->encodingStyle))
		return NULL;
	if (soap_s2xsd__NMTOKENS(soap, soap_attr_value(soap, "parts", 5, 0), &((soap__body*)a)->parts))
		return NULL;
	if (soap_s2soap__useChoice(soap, soap_attr_value(soap, "use", 5, 0), &((soap__body*)a)->use))
		return NULL;
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "namespace", 4, 0), &((soap__body*)a)->namespace_))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (soap__body *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_soap__body, SOAP_TYPE_soap__body, sizeof(soap__body), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 soap__body * SOAP_FMAC2 wsdl_instantiate_soap__body(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_soap__body(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	soap__body *p;
	size_t k = sizeof(soap__body);
	if (n < 0)
	{	p = SOAP_NEW(soap__body);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap__body, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated soap__body location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_soap__body, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int soap__body::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_soap__body(soap, tag ? tag : "soap:body", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *soap__body::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_soap__body(soap, this, tag, type);
}

SOAP_FMAC3 soap__body * SOAP_FMAC4 soap_get_soap__body(struct soap *soap, soap__body *p, const char *tag, const char *type)
{
	if ((p = soap_in_soap__body(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void soap__operation::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &this->soap__operation::soapAction);
	this->soap__operation::soapActionRequired = (bool)1;
	this->soap__operation::style = NULL;
}

void soap__operation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int soap__operation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_soap__operation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_soap__operation(struct soap *soap, const char *tag, int id, const soap__operation *a, const char *type)
{
	if (((soap__operation*)a)->soapAction)
		soap_set_attr(soap, "soapAction", soap_xsd__anyURI2s(soap, ((soap__operation*)a)->soapAction), 1);
	soap_set_attr(soap, "soapActionRequired", soap_xsd__boolean2s(soap, ((soap__operation*)a)->soapActionRequired), 1);
	if (((soap__operation*)a)->style)
	{	soap_set_attr(soap, "style", soap_soap__styleChoice2s(soap, *((soap__operation*)a)->style), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_soap__operation), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *soap__operation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_soap__operation(soap, tag, this, type);
}

SOAP_FMAC3 soap__operation * SOAP_FMAC4 soap_in_soap__operation(struct soap *soap, const char *tag, soap__operation *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (soap__operation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_soap__operation, sizeof(soap__operation), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_soap__operation)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (soap__operation *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "soapAction", 4, 0), &((soap__operation*)a)->soapAction))
		return NULL;
	if (soap_s2xsd__boolean(soap, soap_attr_value(soap, "soapActionRequired", 5, 0), &((soap__operation*)a)->soapActionRequired))
		return NULL;
	{
		const char *t = soap_attr_value(soap, "style", 5, 0);
		if (t)
		{
			if (!(((soap__operation*)a)->style = (enum soap__styleChoice *)soap_malloc(soap, sizeof(enum soap__styleChoice))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2soap__styleChoice(soap, t, ((soap__operation*)a)->style))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (soap__operation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_soap__operation, SOAP_TYPE_soap__operation, sizeof(soap__operation), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 soap__operation * SOAP_FMAC2 wsdl_instantiate_soap__operation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_soap__operation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	soap__operation *p;
	size_t k = sizeof(soap__operation);
	if (n < 0)
	{	p = SOAP_NEW(soap__operation);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap__operation, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated soap__operation location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_soap__operation, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int soap__operation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_soap__operation(soap, tag ? tag : "soap:operation", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *soap__operation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_soap__operation(soap, this, tag, type);
}

SOAP_FMAC3 soap__operation * SOAP_FMAC4 soap_get_soap__operation(struct soap *soap, soap__operation *p, const char *tag, const char *type)
{
	if ((p = soap_in_soap__operation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void soap__binding::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &this->soap__binding::transport);
	this->soap__binding::style = NULL;
}

void soap__binding::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int soap__binding::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_soap__binding(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_soap__binding(struct soap *soap, const char *tag, int id, const soap__binding *a, const char *type)
{
	if (((soap__binding*)a)->transport)
		soap_set_attr(soap, "transport", soap_xsd__anyURI2s(soap, ((soap__binding*)a)->transport), 1);
	if (((soap__binding*)a)->style)
	{	soap_set_attr(soap, "style", soap_soap__styleChoice2s(soap, *((soap__binding*)a)->style), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_soap__binding), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *soap__binding::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_soap__binding(soap, tag, this, type);
}

SOAP_FMAC3 soap__binding * SOAP_FMAC4 soap_in_soap__binding(struct soap *soap, const char *tag, soap__binding *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (soap__binding *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_soap__binding, sizeof(soap__binding), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_soap__binding)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (soap__binding *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "transport", 4, 0), &((soap__binding*)a)->transport))
		return NULL;
	{
		const char *t = soap_attr_value(soap, "style", 5, 0);
		if (t)
		{
			if (!(((soap__binding*)a)->style = (enum soap__styleChoice *)soap_malloc(soap, sizeof(enum soap__styleChoice))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2soap__styleChoice(soap, t, ((soap__binding*)a)->style))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (soap__binding *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_soap__binding, SOAP_TYPE_soap__binding, sizeof(soap__binding), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 soap__binding * SOAP_FMAC2 wsdl_instantiate_soap__binding(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_soap__binding(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	soap__binding *p;
	size_t k = sizeof(soap__binding);
	if (n < 0)
	{	p = SOAP_NEW(soap__binding);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap__binding, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated soap__binding location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_soap__binding, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int soap__binding::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_soap__binding(soap, tag ? tag : "soap:binding", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *soap__binding::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_soap__binding(soap, this, tag, type);
}

SOAP_FMAC3 soap__binding * SOAP_FMAC4 soap_get_soap__binding(struct soap *soap, soap__binding *p, const char *tag, const char *type)
{
	if ((p = soap_in_soap__binding(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsdl__part::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__NMTOKEN(soap, &this->wsdl__part::name);
	soap_default_xsd__QName(soap, &this->wsdl__part::element);
	soap_default_xsd__QName(soap, &this->wsdl__part::type);
	soap_default_xsd__string(soap, &this->wsdl__part::documentation);
	soap_default_bool(soap, &this->wsdl__part::optional);
	soap_default_bool(soap, &this->wsdl__part::repeating);
	soap_default_bool(soap, &this->wsdl__part::fixed);
	soap_default_xsd__string(soap, &this->wsdl__part::default_);
	soap_default_std__vectorTemplateOfstring(soap, &this->wsdl__part::option);
	this->wsdl__part::elementRef = NULL;
	this->wsdl__part::simpleTypeRef = NULL;
	this->wsdl__part::complexTypeRef = NULL;
}

void wsdl__part::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__string(soap, (char*const*)&this->wsdl__part::documentation);
	/* non-serializable optional skipped */
	/* non-serializable repeating skipped */
	/* non-serializable fixed skipped */
	/* non-serializable default_ skipped */
	/* non-serializable option skipped */
	/* non-serializable elementRef skipped */
	/* non-serializable simpleTypeRef skipped */
	/* non-serializable complexTypeRef skipped */
#endif
}

int wsdl__part::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsdl__part(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdl__part(struct soap *soap, const char *tag, int id, const wsdl__part *a, const char *type)
{
	if (((wsdl__part*)a)->name)
		soap_set_attr(soap, "name", soap_xsd__NMTOKEN2s(soap, ((wsdl__part*)a)->name), 1);
	if (((wsdl__part*)a)->element)
		soap_set_attr(soap, "element", soap_xsd__QName2s(soap, ((wsdl__part*)a)->element), 1);
	if (((wsdl__part*)a)->type)
		soap_set_attr(soap, "type", soap_xsd__QName2s(soap, ((wsdl__part*)a)->type), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsdl__part), type))
		return soap->error;
	if (soap_out_xsd__string(soap, "wsdl:documentation", -1, (char*const*)&a->wsdl__part::documentation, ""))
		return soap->error;
	/* non-serializable optional skipped */
	/* non-serializable repeating skipped */
	/* non-serializable fixed skipped */
	/* non-serializable default_ skipped */
	/* non-serializable option skipped */
	/* non-serializable elementRef skipped */
	/* non-serializable simpleTypeRef skipped */
	/* non-serializable complexTypeRef skipped */
	return soap_element_end_out(soap, tag);
}

void *wsdl__part::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wsdl__part(soap, tag, this, type);
}

SOAP_FMAC3 wsdl__part * SOAP_FMAC4 soap_in_wsdl__part(struct soap *soap, const char *tag, wsdl__part *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsdl__part *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsdl__part, sizeof(wsdl__part), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsdl__part)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsdl__part *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__NMTOKEN(soap, soap_attr_value(soap, "name", 5, 0), &((wsdl__part*)a)->name))
		return NULL;
	if (soap_s2xsd__QName(soap, soap_attr_value(soap, "element", 2, 0), &((wsdl__part*)a)->element))
		return NULL;
	if (soap_s2xsd__QName(soap, soap_attr_value(soap, "type", 2, 0), &((wsdl__part*)a)->type))
		return NULL;
	size_t soap_flag_documentation1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_documentation1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "wsdl:documentation", (char**)&a->wsdl__part::documentation, "xsd:string"))
				{	soap_flag_documentation1--;
					continue;
				}
			}
			/* non-serializable optional skipped */
			/* non-serializable repeating skipped */
			/* non-serializable fixed skipped */
			/* non-serializable default_ skipped */
			/* non-serializable option skipped */
			/* non-serializable elementRef skipped */
			/* non-serializable simpleTypeRef skipped */
			/* non-serializable complexTypeRef skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wsdl__part *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsdl__part, SOAP_TYPE_wsdl__part, sizeof(wsdl__part), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsdl__part * SOAP_FMAC2 wsdl_instantiate_wsdl__part(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_wsdl__part(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsdl__part *p;
	size_t k = sizeof(wsdl__part);
	if (n < 0)
	{	p = SOAP_NEW(wsdl__part);
	}
	else
	{	p = SOAP_NEW_ARRAY(wsdl__part, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsdl__part location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_wsdl__part, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int wsdl__part::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsdl__part(soap, tag ? tag : "wsdl:part", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsdl__part::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsdl__part(soap, this, tag, type);
}

SOAP_FMAC3 wsdl__part * SOAP_FMAC4 soap_get_wsdl__part(struct soap *soap, wsdl__part *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsdl__part(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsdl__message::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__NMTOKEN(soap, &this->wsdl__message::name);
	soap_default_xsd__string(soap, &this->wsdl__message::documentation);
	soap_default_std__vectorTemplateOfwsp__Policy(soap, &this->wsdl__message::wsp__Policy_);
	soap_default_std__vectorTemplateOfwsp__PolicyReference(soap, &this->wsdl__message::wsp__PolicyReference_);
	soap_default_std__vectorTemplateOfwsdl__part(soap, &this->wsdl__message::part);
}

void wsdl__message::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__string(soap, (char*const*)&this->wsdl__message::documentation);
	soap_serialize_std__vectorTemplateOfwsp__Policy(soap, &this->wsdl__message::wsp__Policy_);
	soap_serialize_std__vectorTemplateOfwsp__PolicyReference(soap, &this->wsdl__message::wsp__PolicyReference_);
	soap_serialize_std__vectorTemplateOfwsdl__part(soap, &this->wsdl__message::part);
#endif
}

int wsdl__message::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsdl__message(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdl__message(struct soap *soap, const char *tag, int id, const wsdl__message *a, const char *type)
{
	if (((wsdl__message*)a)->name)
		soap_set_attr(soap, "name", soap_xsd__NMTOKEN2s(soap, ((wsdl__message*)a)->name), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsdl__message), type))
		return soap->error;
	if (soap_out_xsd__string(soap, "wsdl:documentation", -1, (char*const*)&a->wsdl__message::documentation, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfwsp__Policy(soap, "wsp:Policy", -1, &a->wsdl__message::wsp__Policy_, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfwsp__PolicyReference(soap, "wsp:PolicyReference", -1, &a->wsdl__message::wsp__PolicyReference_, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfwsdl__part(soap, "wsdl:part", -1, &a->wsdl__message::part, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsdl__message::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wsdl__message(soap, tag, this, type);
}

SOAP_FMAC3 wsdl__message * SOAP_FMAC4 soap_in_wsdl__message(struct soap *soap, const char *tag, wsdl__message *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsdl__message *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsdl__message, sizeof(wsdl__message), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsdl__message)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsdl__message *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__NMTOKEN(soap, soap_attr_value(soap, "name", 5, 0), &((wsdl__message*)a)->name))
		return NULL;
	size_t soap_flag_documentation1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_documentation1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "wsdl:documentation", (char**)&a->wsdl__message::documentation, "xsd:string"))
				{	soap_flag_documentation1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfwsp__Policy(soap, "wsp:Policy", &a->wsdl__message::wsp__Policy_, "wsp:Policy"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfwsp__PolicyReference(soap, "wsp:PolicyReference", &a->wsdl__message::wsp__PolicyReference_, "wsp:PolicyReference"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfwsdl__part(soap, "wsdl:part", &a->wsdl__message::part, "wsdl:part"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wsdl__message *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsdl__message, SOAP_TYPE_wsdl__message, sizeof(wsdl__message), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsdl__message * SOAP_FMAC2 wsdl_instantiate_wsdl__message(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_wsdl__message(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsdl__message *p;
	size_t k = sizeof(wsdl__message);
	if (n < 0)
	{	p = SOAP_NEW(wsdl__message);
	}
	else
	{	p = SOAP_NEW_ARRAY(wsdl__message, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsdl__message location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_wsdl__message, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int wsdl__message::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsdl__message(soap, tag ? tag : "wsdl:message", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsdl__message::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsdl__message(soap, this, tag, type);
}

SOAP_FMAC3 wsdl__message * SOAP_FMAC4 soap_get_wsdl__message(struct soap *soap, wsdl__message *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsdl__message(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wadl__application::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfwadl__doc(soap, &this->wadl__application::doc);
	this->wadl__application::grammars = NULL;
	soap_default_std__vectorTemplateOfwadl__resources(soap, &this->wadl__application::resources);
	soap_default_std__vectorTemplateOfwadl__resource_USCOREtype(soap, &this->wadl__application::resource_USCOREtype);
	soap_default_std__vectorTemplateOfwadl__method(soap, &this->wadl__application::method);
	soap_default_std__vectorTemplateOfwadl__representation(soap, &this->wadl__application::representation);
	soap_default_std__vectorTemplateOfwadl__param(soap, &this->wadl__application::param);
	/* transient soap skipped */
}

void wadl__application::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfwadl__doc(soap, &this->wadl__application::doc);
	soap_serialize_PointerTowadl__grammars(soap, &this->wadl__application::grammars);
	soap_serialize_std__vectorTemplateOfwadl__resources(soap, &this->wadl__application::resources);
	soap_serialize_std__vectorTemplateOfwadl__resource_USCOREtype(soap, &this->wadl__application::resource_USCOREtype);
	soap_serialize_std__vectorTemplateOfwadl__method(soap, &this->wadl__application::method);
	soap_serialize_std__vectorTemplateOfwadl__representation(soap, &this->wadl__application::representation);
	soap_serialize_std__vectorTemplateOfwadl__param(soap, &this->wadl__application::param);
#endif
}

int wadl__application::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wadl__application(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wadl__application(struct soap *soap, const char *tag, int id, const wadl__application *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wadl__application), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfwadl__doc(soap, "wadl:doc", -1, &a->wadl__application::doc, ""))
		return soap->error;
	if (soap_out_PointerTowadl__grammars(soap, "wadl:grammars", -1, &a->wadl__application::grammars, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfwadl__resources(soap, "wadl:resources", -1, &a->wadl__application::resources, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfwadl__resource_USCOREtype(soap, "wadl:resource_type", -1, &a->wadl__application::resource_USCOREtype, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfwadl__method(soap, "wadl:method", -1, &a->wadl__application::method, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfwadl__representation(soap, "wadl:representation", -1, &a->wadl__application::representation, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfwadl__param(soap, "wadl:param", -1, &a->wadl__application::param, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wadl__application::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wadl__application(soap, tag, this, type);
}

SOAP_FMAC3 wadl__application * SOAP_FMAC4 soap_in_wadl__application(struct soap *soap, const char *tag, wadl__application *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wadl__application *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wadl__application, sizeof(wadl__application), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wadl__application)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wadl__application *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_grammars1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfwadl__doc(soap, "wadl:doc", &a->wadl__application::doc, "wadl:doc"))
					continue;
			}
			if (soap_flag_grammars1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowadl__grammars(soap, "wadl:grammars", &a->wadl__application::grammars, "wadl:grammars"))
				{	soap_flag_grammars1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfwadl__resources(soap, "wadl:resources", &a->wadl__application::resources, "wadl:resources"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfwadl__resource_USCOREtype(soap, "wadl:resource_type", &a->wadl__application::resource_USCOREtype, "wadl:resource_type"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfwadl__method(soap, "wadl:method", &a->wadl__application::method, "wadl:method"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfwadl__representation(soap, "wadl:representation", &a->wadl__application::representation, "wadl:representation"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfwadl__param(soap, "wadl:param", &a->wadl__application::param, "wadl:param"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wadl__application *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wadl__application, SOAP_TYPE_wadl__application, sizeof(wadl__application), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wadl__application * SOAP_FMAC2 wsdl_instantiate_wadl__application(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_wadl__application(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wadl__application *p;
	size_t k = sizeof(wadl__application);
	if (n < 0)
	{	p = SOAP_NEW(wadl__application);
		if (p)
			((wadl__application*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(wadl__application, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((wadl__application*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wadl__application location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_wadl__application, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int wadl__application::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wadl__application(soap, tag ? tag : "wadl:application", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wadl__application::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wadl__application(soap, this, tag, type);
}

SOAP_FMAC3 wadl__application * SOAP_FMAC4 soap_get_wadl__application(struct soap *soap, wadl__application *p, const char *tag, const char *type)
{
	if ((p = soap_in_wadl__application(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wadl__resources::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &this->wadl__resources::base);
	soap_default_std__vectorTemplateOfwadl__doc(soap, &this->wadl__resources::doc);
	soap_default_std__vectorTemplateOfwadl__resource(soap, &this->wadl__resources::resource);
}

void wadl__resources::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfwadl__doc(soap, &this->wadl__resources::doc);
	soap_serialize_std__vectorTemplateOfwadl__resource(soap, &this->wadl__resources::resource);
#endif
}

int wadl__resources::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wadl__resources(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wadl__resources(struct soap *soap, const char *tag, int id, const wadl__resources *a, const char *type)
{
	if (((wadl__resources*)a)->base)
		soap_set_attr(soap, "base", soap_xsd__anyURI2s(soap, ((wadl__resources*)a)->base), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wadl__resources), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfwadl__doc(soap, "wadl:doc", -1, &a->wadl__resources::doc, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfwadl__resource(soap, "wadl:resource", -1, &a->wadl__resources::resource, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wadl__resources::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wadl__resources(soap, tag, this, type);
}

SOAP_FMAC3 wadl__resources * SOAP_FMAC4 soap_in_wadl__resources(struct soap *soap, const char *tag, wadl__resources *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wadl__resources *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wadl__resources, sizeof(wadl__resources), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wadl__resources)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wadl__resources *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "base", 4, 0), &((wadl__resources*)a)->base))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfwadl__doc(soap, "wadl:doc", &a->wadl__resources::doc, "wadl:doc"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfwadl__resource(soap, "wadl:resource", &a->wadl__resources::resource, "wadl:resource"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wadl__resources *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wadl__resources, SOAP_TYPE_wadl__resources, sizeof(wadl__resources), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wadl__resources * SOAP_FMAC2 wsdl_instantiate_wadl__resources(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_wadl__resources(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wadl__resources *p;
	size_t k = sizeof(wadl__resources);
	if (n < 0)
	{	p = SOAP_NEW(wadl__resources);
	}
	else
	{	p = SOAP_NEW_ARRAY(wadl__resources, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wadl__resources location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_wadl__resources, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int wadl__resources::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wadl__resources(soap, tag ? tag : "wadl:resources", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wadl__resources::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wadl__resources(soap, this, tag, type);
}

SOAP_FMAC3 wadl__resources * SOAP_FMAC4 soap_get_wadl__resources(struct soap *soap, wadl__resources *p, const char *tag, const char *type)
{
	if ((p = soap_in_wadl__resources(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void __wadl__method_resource_choice::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->__wadl__method_resource_choice::method = NULL;
	this->__wadl__method_resource_choice::resource = NULL;
}

void __wadl__method_resource_choice::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowadl__method(soap, &this->__wadl__method_resource_choice::method);
	soap_serialize_PointerTowadl__resource(soap, &this->__wadl__method_resource_choice::resource);
#endif
}

int __wadl__method_resource_choice::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out___wadl__method_resource_choice(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___wadl__method_resource_choice(struct soap *soap, const char *tag, int id, const __wadl__method_resource_choice *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTowadl__method(soap, "wadl:method", -1, &a->__wadl__method_resource_choice::method, ""))
		return soap->error;
	if (soap_out_PointerTowadl__resource(soap, "wadl:resource", -1, &a->__wadl__method_resource_choice::resource, ""))
		return soap->error;
	return SOAP_OK;
}

void *__wadl__method_resource_choice::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in___wadl__method_resource_choice(soap, tag, this, type);
}

SOAP_FMAC3 __wadl__method_resource_choice * SOAP_FMAC4 soap_in___wadl__method_resource_choice(struct soap *soap, const char *tag, __wadl__method_resource_choice *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (__wadl__method_resource_choice *)soap_id_enter(soap, "", a, SOAP_TYPE___wadl__method_resource_choice, sizeof(__wadl__method_resource_choice), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_method1 = 1;
	size_t soap_flag_resource1 = 1;
		for (short soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_method1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowadl__method(soap, "wadl:method", &a->__wadl__method_resource_choice::method, "wadl:method"))
				{	soap_flag_method1--;
					continue;
				}
			}
			if (soap_flag_resource1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowadl__resource(soap, "wadl:resource", &a->__wadl__method_resource_choice::resource, "wadl:resource"))
				{	soap_flag_resource1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{
				soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 __wadl__method_resource_choice * SOAP_FMAC2 wsdl_instantiate___wadl__method_resource_choice(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate___wadl__method_resource_choice(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	__wadl__method_resource_choice *p;
	size_t k = sizeof(__wadl__method_resource_choice);
	if (n < 0)
	{	p = SOAP_NEW(__wadl__method_resource_choice);
	}
	else
	{	p = SOAP_NEW_ARRAY(__wadl__method_resource_choice, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated __wadl__method_resource_choice location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___wadl__method_resource_choice, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int __wadl__method_resource_choice::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out___wadl__method_resource_choice(soap, tag ? tag : "-wadl:method-resource-choice", -2, this, type))
		return soap->error;
	return SOAP_OK;
}

void *__wadl__method_resource_choice::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get___wadl__method_resource_choice(soap, this, tag, type);
}

SOAP_FMAC3 __wadl__method_resource_choice * SOAP_FMAC4 soap_get___wadl__method_resource_choice(struct soap *soap, __wadl__method_resource_choice *p, const char *tag, const char *type)
{
	if ((p = soap_in___wadl__method_resource_choice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wadl__method::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__ID(soap, &this->wadl__method::id);
	soap_default_wadl__HTTPMethods(soap, &this->wadl__method::name);
	soap_default_xsd__anyURI(soap, &this->wadl__method::href);
	soap_default_std__vectorTemplateOfwadl__doc(soap, &this->wadl__method::doc);
	this->wadl__method::request = NULL;
	soap_default_std__vectorTemplateOfwadl__response(soap, &this->wadl__method::response);
	this->wadl__method::methodRef = NULL;
}

void wadl__method::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfwadl__doc(soap, &this->wadl__method::doc);
	soap_serialize_PointerTowadl__request(soap, &this->wadl__method::request);
	soap_serialize_std__vectorTemplateOfwadl__response(soap, &this->wadl__method::response);
	/* non-serializable methodRef skipped */
#endif
}

int wadl__method::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wadl__method(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wadl__method(struct soap *soap, const char *tag, int id, const wadl__method *a, const char *type)
{
	if (((wadl__method*)a)->id)
		soap_set_attr(soap, "id", soap_xsd__ID2s(soap, ((wadl__method*)a)->id), 1);
	soap_set_attr(soap, "name", soap_wadl__HTTPMethods2s(soap, ((wadl__method*)a)->name), 1);
	if (((wadl__method*)a)->href)
		soap_set_attr(soap, "href", soap_xsd__anyURI2s(soap, ((wadl__method*)a)->href), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wadl__method), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfwadl__doc(soap, "wadl:doc", -1, &a->wadl__method::doc, ""))
		return soap->error;
	if (soap_out_PointerTowadl__request(soap, "wadl:request", -1, &a->wadl__method::request, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfwadl__response(soap, "wadl:response", -1, &a->wadl__method::response, ""))
		return soap->error;
	/* non-serializable methodRef skipped */
	return soap_element_end_out(soap, tag);
}

void *wadl__method::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wadl__method(soap, tag, this, type);
}

SOAP_FMAC3 wadl__method * SOAP_FMAC4 soap_in_wadl__method(struct soap *soap, const char *tag, wadl__method *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wadl__method *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wadl__method, sizeof(wadl__method), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wadl__method)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wadl__method *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__ID(soap, soap_attr_value(soap, "id", 5, 0), &((wadl__method*)a)->id))
		return NULL;
	if (soap_s2wadl__HTTPMethods(soap, soap_attr_value(soap, "name", 5, 0), &((wadl__method*)a)->name))
		return NULL;
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "href", 4, 0), &((wadl__method*)a)->href))
		return NULL;
	size_t soap_flag_request1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfwadl__doc(soap, "wadl:doc", &a->wadl__method::doc, "wadl:doc"))
					continue;
			}
			if (soap_flag_request1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowadl__request(soap, "wadl:request", &a->wadl__method::request, "wadl:request"))
				{	soap_flag_request1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfwadl__response(soap, "wadl:response", &a->wadl__method::response, "wadl:response"))
					continue;
			}
			/* non-serializable methodRef skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wadl__method *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wadl__method, SOAP_TYPE_wadl__method, sizeof(wadl__method), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wadl__method * SOAP_FMAC2 wsdl_instantiate_wadl__method(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_wadl__method(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wadl__method *p;
	size_t k = sizeof(wadl__method);
	if (n < 0)
	{	p = SOAP_NEW(wadl__method);
	}
	else
	{	p = SOAP_NEW_ARRAY(wadl__method, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wadl__method location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_wadl__method, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int wadl__method::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wadl__method(soap, tag ? tag : "wadl:method", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wadl__method::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wadl__method(soap, this, tag, type);
}

SOAP_FMAC3 wadl__method * SOAP_FMAC4 soap_get_wadl__method(struct soap *soap, wadl__method *p, const char *tag, const char *type)
{
	if ((p = soap_in_wadl__method(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wadl__response::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->wadl__request::soap_default(soap);
	soap_default_wadl__statusCodeList(soap, &this->wadl__response::status);
}

void wadl__response::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->wadl__request::soap_serialize(soap);
#endif
}

int wadl__response::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wadl__response(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wadl__response(struct soap *soap, const char *tag, int id, const wadl__response *a, const char *type)
{
	if (((wadl__response*)a)->status)
		soap_set_attr(soap, "status", soap_wadl__statusCodeList2s(soap, ((wadl__response*)a)->status), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wadl__response), type ? type : "wadl:response"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfwadl__doc(soap, "wadl:doc", -1, &a->wadl__request::doc, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfwadl__param(soap, "wadl:param", -1, &a->wadl__request::param, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfwadl__representation(soap, "wadl:representation", -1, &a->wadl__request::representation, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wadl__response::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wadl__response(soap, tag, this, type);
}

SOAP_FMAC3 wadl__response * SOAP_FMAC4 soap_in_wadl__response(struct soap *soap, const char *tag, wadl__response *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wadl__response *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wadl__response, sizeof(wadl__response), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wadl__response)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wadl__response *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2wadl__statusCodeList(soap, soap_attr_value(soap, "status", 1, 0), &((wadl__response*)a)->status))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfwadl__doc(soap, "wadl:doc", &a->wadl__request::doc, "wadl:doc"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfwadl__param(soap, "wadl:param", &a->wadl__request::param, "wadl:param"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfwadl__representation(soap, "wadl:representation", &a->wadl__request::representation, "wadl:representation"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wadl__response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wadl__response, SOAP_TYPE_wadl__response, sizeof(wadl__response), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wadl__response * SOAP_FMAC2 wsdl_instantiate_wadl__response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_wadl__response(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wadl__response *p;
	size_t k = sizeof(wadl__response);
	if (n < 0)
	{	p = SOAP_NEW(wadl__response);
	}
	else
	{	p = SOAP_NEW_ARRAY(wadl__response, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wadl__response location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_wadl__response, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int wadl__response::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wadl__response(soap, tag ? tag : "wadl:response", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wadl__response::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wadl__response(soap, this, tag, type);
}

SOAP_FMAC3 wadl__response * SOAP_FMAC4 soap_get_wadl__response(struct soap *soap, wadl__response *p, const char *tag, const char *type)
{
	if ((p = soap_in_wadl__response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wadl__request::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfwadl__doc(soap, &this->wadl__request::doc);
	soap_default_std__vectorTemplateOfwadl__param(soap, &this->wadl__request::param);
	soap_default_std__vectorTemplateOfwadl__representation(soap, &this->wadl__request::representation);
}

void wadl__request::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfwadl__doc(soap, &this->wadl__request::doc);
	soap_serialize_std__vectorTemplateOfwadl__param(soap, &this->wadl__request::param);
	soap_serialize_std__vectorTemplateOfwadl__representation(soap, &this->wadl__request::representation);
#endif
}

int wadl__request::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wadl__request(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wadl__request(struct soap *soap, const char *tag, int id, const wadl__request *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wadl__request), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfwadl__doc(soap, "wadl:doc", -1, &a->wadl__request::doc, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfwadl__param(soap, "wadl:param", -1, &a->wadl__request::param, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfwadl__representation(soap, "wadl:representation", -1, &a->wadl__request::representation, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wadl__request::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wadl__request(soap, tag, this, type);
}

SOAP_FMAC3 wadl__request * SOAP_FMAC4 soap_in_wadl__request(struct soap *soap, const char *tag, wadl__request *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wadl__request *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wadl__request, sizeof(wadl__request), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wadl__request)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wadl__request *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfwadl__doc(soap, "wadl:doc", &a->wadl__request::doc, "wadl:doc"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfwadl__param(soap, "wadl:param", &a->wadl__request::param, "wadl:param"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfwadl__representation(soap, "wadl:representation", &a->wadl__request::representation, "wadl:representation"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wadl__request *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wadl__request, SOAP_TYPE_wadl__request, sizeof(wadl__request), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wadl__request * SOAP_FMAC2 wsdl_instantiate_wadl__request(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_wadl__request(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (soap && type && !soap_match_tag(soap, type, "wadl:response"))
		return wsdl_instantiate_wadl__response(soap, n, NULL, NULL, size);
	wadl__request *p;
	size_t k = sizeof(wadl__request);
	if (n < 0)
	{	p = SOAP_NEW(wadl__request);
	}
	else
	{	p = SOAP_NEW_ARRAY(wadl__request, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wadl__request location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_wadl__request, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int wadl__request::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wadl__request(soap, tag ? tag : "wadl:request", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wadl__request::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wadl__request(soap, this, tag, type);
}

SOAP_FMAC3 wadl__request * SOAP_FMAC4 soap_get_wadl__request(struct soap *soap, wadl__request *p, const char *tag, const char *type)
{
	if ((p = soap_in_wadl__request(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wadl__representation::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__ID(soap, &this->wadl__representation::id);
	soap_default_xsd__QName(soap, &this->wadl__representation::element);
	soap_default_xsd__string(soap, &this->wadl__representation::mediaType);
	soap_default_xsd__anyURI(soap, &this->wadl__representation::href);
	soap_default_xsd__anyURI(soap, &this->wadl__representation::profile);
	soap_default_std__vectorTemplateOfwadl__doc(soap, &this->wadl__representation::doc);
	soap_default_std__vectorTemplateOfwadl__param(soap, &this->wadl__representation::param);
	this->wadl__representation::representationRef = NULL;
	this->wadl__representation::elementRef = NULL;
}

void wadl__representation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfwadl__doc(soap, &this->wadl__representation::doc);
	soap_serialize_std__vectorTemplateOfwadl__param(soap, &this->wadl__representation::param);
	/* non-serializable representationRef skipped */
	/* non-serializable elementRef skipped */
#endif
}

int wadl__representation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wadl__representation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wadl__representation(struct soap *soap, const char *tag, int id, const wadl__representation *a, const char *type)
{
	if (((wadl__representation*)a)->id)
		soap_set_attr(soap, "id", soap_xsd__ID2s(soap, ((wadl__representation*)a)->id), 1);
	if (((wadl__representation*)a)->element)
		soap_set_attr(soap, "element", soap_xsd__QName2s(soap, ((wadl__representation*)a)->element), 1);
	if (((wadl__representation*)a)->mediaType)
		soap_set_attr(soap, "mediaType", soap_xsd__string2s(soap, ((wadl__representation*)a)->mediaType), 1);
	if (((wadl__representation*)a)->href)
		soap_set_attr(soap, "href", soap_xsd__anyURI2s(soap, ((wadl__representation*)a)->href), 1);
	if (((wadl__representation*)a)->profile)
		soap_set_attr(soap, "profile", soap_xsd__anyURI2s(soap, ((wadl__representation*)a)->profile), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wadl__representation), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfwadl__doc(soap, "wadl:doc", -1, &a->wadl__representation::doc, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfwadl__param(soap, "wadl:param", -1, &a->wadl__representation::param, ""))
		return soap->error;
	/* non-serializable representationRef skipped */
	/* non-serializable elementRef skipped */
	return soap_element_end_out(soap, tag);
}

void *wadl__representation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wadl__representation(soap, tag, this, type);
}

SOAP_FMAC3 wadl__representation * SOAP_FMAC4 soap_in_wadl__representation(struct soap *soap, const char *tag, wadl__representation *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wadl__representation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wadl__representation, sizeof(wadl__representation), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wadl__representation)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wadl__representation *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__ID(soap, soap_attr_value(soap, "id", 5, 0), &((wadl__representation*)a)->id))
		return NULL;
	if (soap_s2xsd__QName(soap, soap_attr_value(soap, "element", 2, 0), &((wadl__representation*)a)->element))
		return NULL;
	if (soap_s2xsd__string(soap, soap_attr_value(soap, "mediaType", 1, 0), &((wadl__representation*)a)->mediaType))
		return NULL;
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "href", 4, 0), &((wadl__representation*)a)->href))
		return NULL;
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "profile", 4, 0), &((wadl__representation*)a)->profile))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfwadl__doc(soap, "wadl:doc", &a->wadl__representation::doc, "wadl:doc"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfwadl__param(soap, "wadl:param", &a->wadl__representation::param, "wadl:param"))
					continue;
			}
			/* non-serializable representationRef skipped */
			/* non-serializable elementRef skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wadl__representation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wadl__representation, SOAP_TYPE_wadl__representation, sizeof(wadl__representation), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wadl__representation * SOAP_FMAC2 wsdl_instantiate_wadl__representation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_wadl__representation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wadl__representation *p;
	size_t k = sizeof(wadl__representation);
	if (n < 0)
	{	p = SOAP_NEW(wadl__representation);
	}
	else
	{	p = SOAP_NEW_ARRAY(wadl__representation, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wadl__representation location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_wadl__representation, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int wadl__representation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wadl__representation(soap, tag ? tag : "wadl:representation", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wadl__representation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wadl__representation(soap, this, tag, type);
}

SOAP_FMAC3 wadl__representation * SOAP_FMAC4 soap_get_wadl__representation(struct soap *soap, wadl__representation *p, const char *tag, const char *type)
{
	if ((p = soap_in_wadl__representation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wadl__grammars::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfwadl__doc(soap, &this->wadl__grammars::doc);
	soap_default_std__vectorTemplateOfwadl__include(soap, &this->wadl__grammars::include);
}

void wadl__grammars::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfwadl__doc(soap, &this->wadl__grammars::doc);
	soap_serialize_std__vectorTemplateOfwadl__include(soap, &this->wadl__grammars::include);
#endif
}

int wadl__grammars::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wadl__grammars(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wadl__grammars(struct soap *soap, const char *tag, int id, const wadl__grammars *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wadl__grammars), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfwadl__doc(soap, "wadl:doc", -1, &a->wadl__grammars::doc, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfwadl__include(soap, "wadl:include", -1, &a->wadl__grammars::include, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wadl__grammars::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wadl__grammars(soap, tag, this, type);
}

SOAP_FMAC3 wadl__grammars * SOAP_FMAC4 soap_in_wadl__grammars(struct soap *soap, const char *tag, wadl__grammars *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wadl__grammars *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wadl__grammars, sizeof(wadl__grammars), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wadl__grammars)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wadl__grammars *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfwadl__doc(soap, "wadl:doc", &a->wadl__grammars::doc, "wadl:doc"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfwadl__include(soap, "wadl:include", &a->wadl__grammars::include, "wadl:include"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wadl__grammars *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wadl__grammars, SOAP_TYPE_wadl__grammars, sizeof(wadl__grammars), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wadl__grammars * SOAP_FMAC2 wsdl_instantiate_wadl__grammars(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_wadl__grammars(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wadl__grammars *p;
	size_t k = sizeof(wadl__grammars);
	if (n < 0)
	{	p = SOAP_NEW(wadl__grammars);
	}
	else
	{	p = SOAP_NEW_ARRAY(wadl__grammars, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wadl__grammars location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_wadl__grammars, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int wadl__grammars::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wadl__grammars(soap, tag ? tag : "wadl:grammars", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wadl__grammars::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wadl__grammars(soap, this, tag, type);
}

SOAP_FMAC3 wadl__grammars * SOAP_FMAC4 soap_get_wadl__grammars(struct soap *soap, wadl__grammars *p, const char *tag, const char *type)
{
	if ((p = soap_in_wadl__grammars(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wadl__include::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &this->wadl__include::href);
	soap_default_std__vectorTemplateOfwadl__doc(soap, &this->wadl__include::doc);
}

void wadl__include::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfwadl__doc(soap, &this->wadl__include::doc);
#endif
}

int wadl__include::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wadl__include(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wadl__include(struct soap *soap, const char *tag, int id, const wadl__include *a, const char *type)
{
	if (((wadl__include*)a)->href)
		soap_set_attr(soap, "href", soap_xsd__anyURI2s(soap, ((wadl__include*)a)->href), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wadl__include), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfwadl__doc(soap, "wadl:doc", -1, &a->wadl__include::doc, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wadl__include::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wadl__include(soap, tag, this, type);
}

SOAP_FMAC3 wadl__include * SOAP_FMAC4 soap_in_wadl__include(struct soap *soap, const char *tag, wadl__include *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wadl__include *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wadl__include, sizeof(wadl__include), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wadl__include)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wadl__include *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "href", 4, 0), &((wadl__include*)a)->href))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfwadl__doc(soap, "wadl:doc", &a->wadl__include::doc, "wadl:doc"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wadl__include *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wadl__include, SOAP_TYPE_wadl__include, sizeof(wadl__include), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wadl__include * SOAP_FMAC2 wsdl_instantiate_wadl__include(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_wadl__include(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wadl__include *p;
	size_t k = sizeof(wadl__include);
	if (n < 0)
	{	p = SOAP_NEW(wadl__include);
	}
	else
	{	p = SOAP_NEW_ARRAY(wadl__include, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wadl__include location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_wadl__include, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int wadl__include::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wadl__include(soap, tag ? tag : "wadl:include", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wadl__include::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wadl__include(soap, this, tag, type);
}

SOAP_FMAC3 wadl__include * SOAP_FMAC4 soap_get_wadl__include(struct soap *soap, wadl__include *p, const char *tag, const char *type)
{
	if ((p = soap_in_wadl__include(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wadl__param::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &this->wadl__param::href);
	soap_default_xsd__NMTOKEN(soap, &this->wadl__param::name);
	this->wadl__param::style = NULL;
	soap_default_xsd__ID(soap, &this->wadl__param::id);
	soap_default_xsd__QName(soap, &this->wadl__param::type);
	soap_default_xsd__string(soap, &this->wadl__param::default_);
	this->wadl__param::required = (bool)0;
	this->wadl__param::repeating = (bool)0;
	soap_default_xsd__string(soap, &this->wadl__param::fixed);
	soap_default_xsd__string(soap, &this->wadl__param::path);
	soap_default_std__vectorTemplateOfwadl__doc(soap, &this->wadl__param::doc);
	soap_default_std__vectorTemplateOfwadl__option(soap, &this->wadl__param::option);
	this->wadl__param::link = NULL;
	this->wadl__param::paramRef = NULL;
	this->wadl__param::simpleTypeRef = NULL;
	this->wadl__param::complexTypeRef = NULL;
}

void wadl__param::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfwadl__doc(soap, &this->wadl__param::doc);
	soap_serialize_std__vectorTemplateOfwadl__option(soap, &this->wadl__param::option);
	soap_serialize_PointerTowadl__link(soap, &this->wadl__param::link);
	/* non-serializable paramRef skipped */
	/* non-serializable simpleTypeRef skipped */
	/* non-serializable complexTypeRef skipped */
#endif
}

int wadl__param::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wadl__param(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wadl__param(struct soap *soap, const char *tag, int id, const wadl__param *a, const char *type)
{
	if (((wadl__param*)a)->href)
		soap_set_attr(soap, "href", soap_xsd__anyURI2s(soap, ((wadl__param*)a)->href), 1);
	if (((wadl__param*)a)->name)
		soap_set_attr(soap, "name", soap_xsd__NMTOKEN2s(soap, ((wadl__param*)a)->name), 1);
	if (((wadl__param*)a)->style)
	{	soap_set_attr(soap, "style", soap_wadl__ParamStyle2s(soap, *((wadl__param*)a)->style), 1);
	}
	if (((wadl__param*)a)->id)
		soap_set_attr(soap, "id", soap_xsd__ID2s(soap, ((wadl__param*)a)->id), 1);
	if (((wadl__param*)a)->type)
		soap_set_attr(soap, "type", soap_xsd__QName2s(soap, ((wadl__param*)a)->type), 1);
	if (((wadl__param*)a)->default_)
		soap_set_attr(soap, "default", soap_xsd__string2s(soap, ((wadl__param*)a)->default_), 1);
	soap_set_attr(soap, "required", soap_bool2s(soap, ((wadl__param*)a)->required), 1);
	soap_set_attr(soap, "repeating", soap_bool2s(soap, ((wadl__param*)a)->repeating), 1);
	if (((wadl__param*)a)->fixed)
		soap_set_attr(soap, "fixed", soap_xsd__string2s(soap, ((wadl__param*)a)->fixed), 1);
	if (((wadl__param*)a)->path)
		soap_set_attr(soap, "path", soap_xsd__string2s(soap, ((wadl__param*)a)->path), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wadl__param), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfwadl__doc(soap, "wadl:doc", -1, &a->wadl__param::doc, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfwadl__option(soap, "wadl:option", -1, &a->wadl__param::option, ""))
		return soap->error;
	if (soap_out_PointerTowadl__link(soap, "wadl:link", -1, &a->wadl__param::link, ""))
		return soap->error;
	/* non-serializable paramRef skipped */
	/* non-serializable simpleTypeRef skipped */
	/* non-serializable complexTypeRef skipped */
	return soap_element_end_out(soap, tag);
}

void *wadl__param::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wadl__param(soap, tag, this, type);
}

SOAP_FMAC3 wadl__param * SOAP_FMAC4 soap_in_wadl__param(struct soap *soap, const char *tag, wadl__param *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wadl__param *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wadl__param, sizeof(wadl__param), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wadl__param)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wadl__param *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "href", 4, 0), &((wadl__param*)a)->href))
		return NULL;
	if (soap_s2xsd__NMTOKEN(soap, soap_attr_value(soap, "name", 5, 0), &((wadl__param*)a)->name))
		return NULL;
	{
		const char *t = soap_attr_value(soap, "style", 5, 0);
		if (t)
		{
			if (!(((wadl__param*)a)->style = (enum wadl__ParamStyle *)soap_malloc(soap, sizeof(enum wadl__ParamStyle))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2wadl__ParamStyle(soap, t, ((wadl__param*)a)->style))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2xsd__ID(soap, soap_attr_value(soap, "id", 5, 0), &((wadl__param*)a)->id))
		return NULL;
	if (soap_s2xsd__QName(soap, soap_attr_value(soap, "type", 2, 0), &((wadl__param*)a)->type))
		return NULL;
	if (soap_s2xsd__string(soap, soap_attr_value(soap, "default", 1, 0), &((wadl__param*)a)->default_))
		return NULL;
	if (soap_s2bool(soap, soap_attr_value(soap, "required", 5, 0), &((wadl__param*)a)->required))
		return NULL;
	if (soap_s2bool(soap, soap_attr_value(soap, "repeating", 5, 0), &((wadl__param*)a)->repeating))
		return NULL;
	if (soap_s2xsd__string(soap, soap_attr_value(soap, "fixed", 1, 0), &((wadl__param*)a)->fixed))
		return NULL;
	if (soap_s2xsd__string(soap, soap_attr_value(soap, "path", 1, 0), &((wadl__param*)a)->path))
		return NULL;
	size_t soap_flag_link1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfwadl__doc(soap, "wadl:doc", &a->wadl__param::doc, "wadl:doc"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfwadl__option(soap, "wadl:option", &a->wadl__param::option, "wadl:option"))
					continue;
			}
			if (soap_flag_link1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowadl__link(soap, "wadl:link", &a->wadl__param::link, "wadl:link"))
				{	soap_flag_link1--;
					continue;
				}
			}
			/* non-serializable paramRef skipped */
			/* non-serializable simpleTypeRef skipped */
			/* non-serializable complexTypeRef skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wadl__param *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wadl__param, SOAP_TYPE_wadl__param, sizeof(wadl__param), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wadl__param * SOAP_FMAC2 wsdl_instantiate_wadl__param(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_wadl__param(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wadl__param *p;
	size_t k = sizeof(wadl__param);
	if (n < 0)
	{	p = SOAP_NEW(wadl__param);
	}
	else
	{	p = SOAP_NEW_ARRAY(wadl__param, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wadl__param location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_wadl__param, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int wadl__param::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wadl__param(soap, tag ? tag : "wadl:param", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wadl__param::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wadl__param(soap, this, tag, type);
}

SOAP_FMAC3 wadl__param * SOAP_FMAC4 soap_get_wadl__param(struct soap *soap, wadl__param *p, const char *tag, const char *type)
{
	if ((p = soap_in_wadl__param(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wadl__link::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &this->wadl__link::resource_USCOREtype);
	soap_default_xsd__token(soap, &this->wadl__link::rel);
	soap_default_xsd__token(soap, &this->wadl__link::rev);
	soap_default_std__vectorTemplateOfwadl__doc(soap, &this->wadl__link::doc);
	this->wadl__link::linkRef = NULL;
}

void wadl__link::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfwadl__doc(soap, &this->wadl__link::doc);
	/* non-serializable linkRef skipped */
#endif
}

int wadl__link::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wadl__link(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wadl__link(struct soap *soap, const char *tag, int id, const wadl__link *a, const char *type)
{
	if (((wadl__link*)a)->resource_USCOREtype)
		soap_set_attr(soap, "resource_type", soap_xsd__anyURI2s(soap, ((wadl__link*)a)->resource_USCOREtype), 1);
	if (((wadl__link*)a)->rel)
		soap_set_attr(soap, "rel", soap_xsd__token2s(soap, ((wadl__link*)a)->rel), 1);
	if (((wadl__link*)a)->rev)
		soap_set_attr(soap, "rev", soap_xsd__token2s(soap, ((wadl__link*)a)->rev), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wadl__link), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfwadl__doc(soap, "wadl:doc", -1, &a->wadl__link::doc, ""))
		return soap->error;
	/* non-serializable linkRef skipped */
	return soap_element_end_out(soap, tag);
}

void *wadl__link::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wadl__link(soap, tag, this, type);
}

SOAP_FMAC3 wadl__link * SOAP_FMAC4 soap_in_wadl__link(struct soap *soap, const char *tag, wadl__link *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wadl__link *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wadl__link, sizeof(wadl__link), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wadl__link)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wadl__link *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "resource_type", 4, 0), &((wadl__link*)a)->resource_USCOREtype))
		return NULL;
	if (soap_s2xsd__token(soap, soap_attr_value(soap, "rel", 5, 0), &((wadl__link*)a)->rel))
		return NULL;
	if (soap_s2xsd__token(soap, soap_attr_value(soap, "rev", 5, 0), &((wadl__link*)a)->rev))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfwadl__doc(soap, "wadl:doc", &a->wadl__link::doc, "wadl:doc"))
					continue;
			}
			/* non-serializable linkRef skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wadl__link *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wadl__link, SOAP_TYPE_wadl__link, sizeof(wadl__link), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wadl__link * SOAP_FMAC2 wsdl_instantiate_wadl__link(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_wadl__link(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wadl__link *p;
	size_t k = sizeof(wadl__link);
	if (n < 0)
	{	p = SOAP_NEW(wadl__link);
	}
	else
	{	p = SOAP_NEW_ARRAY(wadl__link, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wadl__link location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_wadl__link, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int wadl__link::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wadl__link(soap, tag ? tag : "wadl:link", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wadl__link::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wadl__link(soap, this, tag, type);
}

SOAP_FMAC3 wadl__link * SOAP_FMAC4 soap_get_wadl__link(struct soap *soap, wadl__link *p, const char *tag, const char *type)
{
	if ((p = soap_in_wadl__link(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wadl__option::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &this->wadl__option::value);
	soap_default_xsd__string(soap, &this->wadl__option::mediaType);
	soap_default_std__vectorTemplateOfwadl__doc(soap, &this->wadl__option::doc);
}

void wadl__option::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfwadl__doc(soap, &this->wadl__option::doc);
#endif
}

int wadl__option::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wadl__option(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wadl__option(struct soap *soap, const char *tag, int id, const wadl__option *a, const char *type)
{
	if (((wadl__option*)a)->value)
		soap_set_attr(soap, "value", soap_xsd__string2s(soap, ((wadl__option*)a)->value), 1);
	if (((wadl__option*)a)->mediaType)
		soap_set_attr(soap, "mediaType", soap_xsd__string2s(soap, ((wadl__option*)a)->mediaType), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wadl__option), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfwadl__doc(soap, "wadl:doc", -1, &a->wadl__option::doc, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wadl__option::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wadl__option(soap, tag, this, type);
}

SOAP_FMAC3 wadl__option * SOAP_FMAC4 soap_in_wadl__option(struct soap *soap, const char *tag, wadl__option *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wadl__option *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wadl__option, sizeof(wadl__option), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wadl__option)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wadl__option *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__string(soap, soap_attr_value(soap, "value", 1, 0), &((wadl__option*)a)->value))
		return NULL;
	if (soap_s2xsd__string(soap, soap_attr_value(soap, "mediaType", 1, 0), &((wadl__option*)a)->mediaType))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfwadl__doc(soap, "wadl:doc", &a->wadl__option::doc, "wadl:doc"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wadl__option *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wadl__option, SOAP_TYPE_wadl__option, sizeof(wadl__option), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wadl__option * SOAP_FMAC2 wsdl_instantiate_wadl__option(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_wadl__option(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wadl__option *p;
	size_t k = sizeof(wadl__option);
	if (n < 0)
	{	p = SOAP_NEW(wadl__option);
	}
	else
	{	p = SOAP_NEW_ARRAY(wadl__option, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wadl__option location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_wadl__option, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int wadl__option::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wadl__option(soap, tag ? tag : "wadl:option", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wadl__option::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wadl__option(soap, this, tag, type);
}

SOAP_FMAC3 wadl__option * SOAP_FMAC4 soap_get_wadl__option(struct soap *soap, wadl__option *p, const char *tag, const char *type)
{
	if ((p = soap_in_wadl__option(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wadl__doc::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &this->wadl__doc::title);
	soap_default_xsd__string(soap, &this->wadl__doc::xml__lang);
	this->wadl__doc::__mixed = NULL;
}

void wadl__doc::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int wadl__doc::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wadl__doc(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wadl__doc(struct soap *soap, const char *tag, int id, const wadl__doc *a, const char *type)
{
	if (((wadl__doc*)a)->title)
		soap_set_attr(soap, "title", soap_xsd__string2s(soap, ((wadl__doc*)a)->title), 1);
	if (((wadl__doc*)a)->xml__lang)
		soap_set_attr(soap, "xml:lang", soap_xsd__string2s(soap, ((wadl__doc*)a)->xml__lang), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wadl__doc), type))
		return soap->error;
	if (soap_outliteral(soap, "-mixed", (char*const*)&a->wadl__doc::__mixed, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wadl__doc::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wadl__doc(soap, tag, this, type);
}

SOAP_FMAC3 wadl__doc * SOAP_FMAC4 soap_in_wadl__doc(struct soap *soap, const char *tag, wadl__doc *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wadl__doc *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wadl__doc, sizeof(wadl__doc), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wadl__doc)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wadl__doc *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__string(soap, soap_attr_value(soap, "title", 1, 0), &((wadl__doc*)a)->title))
		return NULL;
	if (soap_s2xsd__string(soap, soap_attr_value(soap, "xml:lang", 1, 0), &((wadl__doc*)a)->xml__lang))
		return NULL;
	size_t soap_flag___mixed1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-mixed", (char**)&a->wadl__doc::__mixed))
				{	soap_flag___mixed1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wadl__doc *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wadl__doc, SOAP_TYPE_wadl__doc, sizeof(wadl__doc), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wadl__doc * SOAP_FMAC2 wsdl_instantiate_wadl__doc(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_wadl__doc(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wadl__doc *p;
	size_t k = sizeof(wadl__doc);
	if (n < 0)
	{	p = SOAP_NEW(wadl__doc);
	}
	else
	{	p = SOAP_NEW_ARRAY(wadl__doc, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wadl__doc location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_wadl__doc, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int wadl__doc::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wadl__doc(soap, tag ? tag : "wadl:doc", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wadl__doc::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wadl__doc(soap, this, tag, type);
}

SOAP_FMAC3 wadl__doc * SOAP_FMAC4 soap_get_wadl__doc(struct soap *soap, wadl__doc *p, const char *tag, const char *type)
{
	if ((p = soap_in_wadl__doc(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wadl__resource_USCOREtype::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__ID(soap, &this->wadl__resource_USCOREtype::id);
	soap_default_std__vectorTemplateOfwadl__doc(soap, &this->wadl__resource_USCOREtype::doc);
	soap_default_std__vectorTemplateOfwadl__param(soap, &this->wadl__resource_USCOREtype::param);
	soap_default_std__vectorTemplateOf__wadl__method_resource_choice(soap, &this->wadl__resource_USCOREtype::__choice);
}

void wadl__resource_USCOREtype::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfwadl__doc(soap, &this->wadl__resource_USCOREtype::doc);
	soap_serialize_std__vectorTemplateOfwadl__param(soap, &this->wadl__resource_USCOREtype::param);
	soap_serialize_std__vectorTemplateOf__wadl__method_resource_choice(soap, &this->wadl__resource_USCOREtype::__choice);
#endif
}

int wadl__resource_USCOREtype::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wadl__resource_USCOREtype(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wadl__resource_USCOREtype(struct soap *soap, const char *tag, int id, const wadl__resource_USCOREtype *a, const char *type)
{
	if (((wadl__resource_USCOREtype*)a)->id)
		soap_set_attr(soap, "id", soap_xsd__ID2s(soap, ((wadl__resource_USCOREtype*)a)->id), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wadl__resource_USCOREtype), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfwadl__doc(soap, "wadl:doc", -1, &a->wadl__resource_USCOREtype::doc, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfwadl__param(soap, "wadl:param", -1, &a->wadl__resource_USCOREtype::param, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf__wadl__method_resource_choice(soap, "-choice", -1, &a->wadl__resource_USCOREtype::__choice, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wadl__resource_USCOREtype::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wadl__resource_USCOREtype(soap, tag, this, type);
}

SOAP_FMAC3 wadl__resource_USCOREtype * SOAP_FMAC4 soap_in_wadl__resource_USCOREtype(struct soap *soap, const char *tag, wadl__resource_USCOREtype *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wadl__resource_USCOREtype *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wadl__resource_USCOREtype, sizeof(wadl__resource_USCOREtype), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wadl__resource_USCOREtype)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wadl__resource_USCOREtype *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__ID(soap, soap_attr_value(soap, "id", 5, 0), &((wadl__resource_USCOREtype*)a)->id))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfwadl__doc(soap, "wadl:doc", &a->wadl__resource_USCOREtype::doc, "wadl:doc"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfwadl__param(soap, "wadl:param", &a->wadl__resource_USCOREtype::param, "wadl:param"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf__wadl__method_resource_choice(soap, "-choice", &a->wadl__resource_USCOREtype::__choice, "-wadl:method-resource-choice"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wadl__resource_USCOREtype *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wadl__resource_USCOREtype, SOAP_TYPE_wadl__resource_USCOREtype, sizeof(wadl__resource_USCOREtype), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wadl__resource_USCOREtype * SOAP_FMAC2 wsdl_instantiate_wadl__resource_USCOREtype(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_wadl__resource_USCOREtype(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (soap && type && !soap_match_tag(soap, type, "wadl:resource"))
		return wsdl_instantiate_wadl__resource(soap, n, NULL, NULL, size);
	wadl__resource_USCOREtype *p;
	size_t k = sizeof(wadl__resource_USCOREtype);
	if (n < 0)
	{	p = SOAP_NEW(wadl__resource_USCOREtype);
	}
	else
	{	p = SOAP_NEW_ARRAY(wadl__resource_USCOREtype, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wadl__resource_USCOREtype location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_wadl__resource_USCOREtype, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int wadl__resource_USCOREtype::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wadl__resource_USCOREtype(soap, tag ? tag : "wadl:resource_type", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wadl__resource_USCOREtype::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wadl__resource_USCOREtype(soap, this, tag, type);
}

SOAP_FMAC3 wadl__resource_USCOREtype * SOAP_FMAC4 soap_get_wadl__resource_USCOREtype(struct soap *soap, wadl__resource_USCOREtype *p, const char *tag, const char *type)
{
	if ((p = soap_in_wadl__resource_USCOREtype(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wadl__resource::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->wadl__resource_USCOREtype::soap_default(soap);
	soap_default_xsd__anyURI(soap, &this->wadl__resource::type);
	this->wadl__resource::queryType = (char*)"application/x-www-form-urlencoded";
	soap_default_xsd__string(soap, &this->wadl__resource::path);
	soap_default_std__vectorTemplateOfPointerTowadl__resource_USCOREtype(soap, &this->wadl__resource::typeRefs);
}

void wadl__resource::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	/* non-serializable typeRefs skipped */
	this->wadl__resource_USCOREtype::soap_serialize(soap);
#endif
}

int wadl__resource::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wadl__resource(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wadl__resource(struct soap *soap, const char *tag, int id, const wadl__resource *a, const char *type)
{
	if (((wadl__resource*)a)->type)
		soap_set_attr(soap, "type", soap_xsd__anyURI2s(soap, ((wadl__resource*)a)->type), 1);
	if (((wadl__resource*)a)->queryType)
		soap_set_attr(soap, "queryType", soap_xsd__string2s(soap, ((wadl__resource*)a)->queryType), 1);
	if (((wadl__resource*)a)->path)
		soap_set_attr(soap, "path", soap_xsd__string2s(soap, ((wadl__resource*)a)->path), 1);
	if (((wadl__resource_USCOREtype*)a)->id)
		soap_set_attr(soap, "id", soap_xsd__ID2s(soap, ((wadl__resource_USCOREtype*)a)->id), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wadl__resource), type ? type : "wadl:resource"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfwadl__doc(soap, "wadl:doc", -1, &a->wadl__resource_USCOREtype::doc, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfwadl__param(soap, "wadl:param", -1, &a->wadl__resource_USCOREtype::param, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf__wadl__method_resource_choice(soap, "-choice", -1, &a->wadl__resource_USCOREtype::__choice, ""))
		return soap->error;
	/* non-serializable typeRefs skipped */
	return soap_element_end_out(soap, tag);
}

void *wadl__resource::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wadl__resource(soap, tag, this, type);
}

SOAP_FMAC3 wadl__resource * SOAP_FMAC4 soap_in_wadl__resource(struct soap *soap, const char *tag, wadl__resource *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wadl__resource *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wadl__resource, sizeof(wadl__resource), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wadl__resource)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wadl__resource *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "type", 4, 0), &((wadl__resource*)a)->type))
		return NULL;
	if (soap_s2xsd__string(soap, soap_attr_value(soap, "queryType", 1, 0), &((wadl__resource*)a)->queryType))
		return NULL;
	if (soap_s2xsd__string(soap, soap_attr_value(soap, "path", 1, 0), &((wadl__resource*)a)->path))
		return NULL;
	if (soap_s2xsd__ID(soap, soap_attr_value(soap, "id", 5, 0), &((wadl__resource_USCOREtype*)a)->id))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfwadl__doc(soap, "wadl:doc", &a->wadl__resource_USCOREtype::doc, "wadl:doc"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfwadl__param(soap, "wadl:param", &a->wadl__resource_USCOREtype::param, "wadl:param"))
					continue;
			}
			/* non-serializable typeRefs skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf__wadl__method_resource_choice(soap, "-choice", &a->wadl__resource_USCOREtype::__choice, "-wadl:method-resource-choice"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wadl__resource *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wadl__resource, SOAP_TYPE_wadl__resource, sizeof(wadl__resource), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wadl__resource * SOAP_FMAC2 wsdl_instantiate_wadl__resource(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_wadl__resource(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wadl__resource *p;
	size_t k = sizeof(wadl__resource);
	if (n < 0)
	{	p = SOAP_NEW(wadl__resource);
	}
	else
	{	p = SOAP_NEW_ARRAY(wadl__resource, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wadl__resource location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_wadl__resource, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int wadl__resource::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wadl__resource(soap, tag ? tag : "wadl:resource", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wadl__resource::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wadl__resource(soap, this, tag, type);
}

SOAP_FMAC3 wadl__resource * SOAP_FMAC4 soap_get_wadl__resource(struct soap *soap, wadl__resource *p, const char *tag, const char *type)
{
	if ((p = soap_in_wadl__resource(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xs__redefine::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &this->xs__redefine::schemaLocation);
	soap_default_std__vectorTemplateOfxs__group(soap, &this->xs__redefine::group);
	soap_default_std__vectorTemplateOfxs__attributeGroup(soap, &this->xs__redefine::attributeGroup);
	soap_default_std__vectorTemplateOfxs__simpleType(soap, &this->xs__redefine::simpleType);
	soap_default_std__vectorTemplateOfxs__complexType(soap, &this->xs__redefine::complexType);
	this->xs__redefine::schemaRef = NULL;
}

void xs__redefine::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxs__group(soap, &this->xs__redefine::group);
	soap_serialize_std__vectorTemplateOfxs__attributeGroup(soap, &this->xs__redefine::attributeGroup);
	soap_serialize_std__vectorTemplateOfxs__simpleType(soap, &this->xs__redefine::simpleType);
	soap_serialize_std__vectorTemplateOfxs__complexType(soap, &this->xs__redefine::complexType);
	/* non-serializable schemaRef skipped */
#endif
}

int xs__redefine::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xs__redefine(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xs__redefine(struct soap *soap, const char *tag, int id, const xs__redefine *a, const char *type)
{
	if (((xs__redefine*)a)->schemaLocation)
		soap_set_attr(soap, "schemaLocation", soap_xsd__anyURI2s(soap, ((xs__redefine*)a)->schemaLocation), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xs__redefine), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxs__group(soap, "xs:group", -1, &a->xs__redefine::group, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxs__attributeGroup(soap, "xs:attributeGroup", -1, &a->xs__redefine::attributeGroup, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxs__simpleType(soap, "xs:simpleType", -1, &a->xs__redefine::simpleType, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxs__complexType(soap, "xs:complexType", -1, &a->xs__redefine::complexType, ""))
		return soap->error;
	/* non-serializable schemaRef skipped */
	return soap_element_end_out(soap, tag);
}

void *xs__redefine::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xs__redefine(soap, tag, this, type);
}

SOAP_FMAC3 xs__redefine * SOAP_FMAC4 soap_in_xs__redefine(struct soap *soap, const char *tag, xs__redefine *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (xs__redefine *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xs__redefine, sizeof(xs__redefine), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_xs__redefine)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (xs__redefine *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "schemaLocation", 4, 0), &((xs__redefine*)a)->schemaLocation))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxs__group(soap, "xs:group", &a->xs__redefine::group, "xs:group"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxs__attributeGroup(soap, "xs:attributeGroup", &a->xs__redefine::attributeGroup, "xs:attributeGroup"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxs__simpleType(soap, "xs:simpleType", &a->xs__redefine::simpleType, "xs:simpleType"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxs__complexType(soap, "xs:complexType", &a->xs__redefine::complexType, "xs:complexType"))
					continue;
			}
			/* non-serializable schemaRef skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (xs__redefine *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xs__redefine, SOAP_TYPE_xs__redefine, sizeof(xs__redefine), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 xs__redefine * SOAP_FMAC2 wsdl_instantiate_xs__redefine(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_xs__redefine(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xs__redefine *p;
	size_t k = sizeof(xs__redefine);
	if (n < 0)
	{	p = SOAP_NEW(xs__redefine);
	}
	else
	{	p = SOAP_NEW_ARRAY(xs__redefine, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xs__redefine location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_xs__redefine, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int xs__redefine::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xs__redefine(soap, tag ? tag : "xs:redefine", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xs__redefine::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xs__redefine(soap, this, tag, type);
}

SOAP_FMAC3 xs__redefine * SOAP_FMAC4 soap_get_xs__redefine(struct soap *soap, xs__redefine *p, const char *tag, const char *type)
{
	if ((p = soap_in_xs__redefine(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xs__override::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &this->xs__override::schemaLocation);
	soap_default_std__vectorTemplateOfxs__attribute(soap, &this->xs__override::attribute);
	soap_default_std__vectorTemplateOfxs__element(soap, &this->xs__override::element);
	soap_default_std__vectorTemplateOfxs__group(soap, &this->xs__override::group);
	soap_default_std__vectorTemplateOfxs__attributeGroup(soap, &this->xs__override::attributeGroup);
	soap_default_std__vectorTemplateOfxs__simpleType(soap, &this->xs__override::simpleType);
	soap_default_std__vectorTemplateOfxs__complexType(soap, &this->xs__override::complexType);
	this->xs__override::schemaRef = NULL;
}

void xs__override::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxs__attribute(soap, &this->xs__override::attribute);
	soap_serialize_std__vectorTemplateOfxs__element(soap, &this->xs__override::element);
	soap_serialize_std__vectorTemplateOfxs__group(soap, &this->xs__override::group);
	soap_serialize_std__vectorTemplateOfxs__attributeGroup(soap, &this->xs__override::attributeGroup);
	soap_serialize_std__vectorTemplateOfxs__simpleType(soap, &this->xs__override::simpleType);
	soap_serialize_std__vectorTemplateOfxs__complexType(soap, &this->xs__override::complexType);
	/* non-serializable schemaRef skipped */
#endif
}

int xs__override::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xs__override(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xs__override(struct soap *soap, const char *tag, int id, const xs__override *a, const char *type)
{
	if (((xs__override*)a)->schemaLocation)
		soap_set_attr(soap, "schemaLocation", soap_xsd__anyURI2s(soap, ((xs__override*)a)->schemaLocation), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xs__override), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxs__attribute(soap, "xs:attribute", -1, &a->xs__override::attribute, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxs__element(soap, "xs:element", -1, &a->xs__override::element, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxs__group(soap, "xs:group", -1, &a->xs__override::group, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxs__attributeGroup(soap, "xs:attributeGroup", -1, &a->xs__override::attributeGroup, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxs__simpleType(soap, "xs:simpleType", -1, &a->xs__override::simpleType, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxs__complexType(soap, "xs:complexType", -1, &a->xs__override::complexType, ""))
		return soap->error;
	/* non-serializable schemaRef skipped */
	return soap_element_end_out(soap, tag);
}

void *xs__override::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xs__override(soap, tag, this, type);
}

SOAP_FMAC3 xs__override * SOAP_FMAC4 soap_in_xs__override(struct soap *soap, const char *tag, xs__override *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (xs__override *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xs__override, sizeof(xs__override), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_xs__override)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (xs__override *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "schemaLocation", 4, 0), &((xs__override*)a)->schemaLocation))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxs__attribute(soap, "xs:attribute", &a->xs__override::attribute, "xs:attribute"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxs__element(soap, "xs:element", &a->xs__override::element, "xs:element"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxs__group(soap, "xs:group", &a->xs__override::group, "xs:group"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxs__attributeGroup(soap, "xs:attributeGroup", &a->xs__override::attributeGroup, "xs:attributeGroup"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxs__simpleType(soap, "xs:simpleType", &a->xs__override::simpleType, "xs:simpleType"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxs__complexType(soap, "xs:complexType", &a->xs__override::complexType, "xs:complexType"))
					continue;
			}
			/* non-serializable schemaRef skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (xs__override *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xs__override, SOAP_TYPE_xs__override, sizeof(xs__override), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 xs__override * SOAP_FMAC2 wsdl_instantiate_xs__override(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_xs__override(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xs__override *p;
	size_t k = sizeof(xs__override);
	if (n < 0)
	{	p = SOAP_NEW(xs__override);
	}
	else
	{	p = SOAP_NEW_ARRAY(xs__override, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xs__override location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_xs__override, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int xs__override::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xs__override(soap, tag ? tag : "xs:override", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xs__override::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xs__override(soap, this, tag, type);
}

SOAP_FMAC3 xs__override * SOAP_FMAC4 soap_get_xs__override(struct soap *soap, xs__override *p, const char *tag, const char *type)
{
	if ((p = soap_in_xs__override(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xs__include::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &this->xs__include::schemaLocation);
	this->xs__include::schemaRef = NULL;
}

void xs__include::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	/* non-serializable schemaRef skipped */
#endif
}

int xs__include::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xs__include(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xs__include(struct soap *soap, const char *tag, int id, const xs__include *a, const char *type)
{
	if (((xs__include*)a)->schemaLocation)
		soap_set_attr(soap, "schemaLocation", soap_xsd__anyURI2s(soap, ((xs__include*)a)->schemaLocation), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xs__include), type))
		return soap->error;
	/* non-serializable schemaRef skipped */
	return soap_element_end_out(soap, tag);
}

void *xs__include::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xs__include(soap, tag, this, type);
}

SOAP_FMAC3 xs__include * SOAP_FMAC4 soap_in_xs__include(struct soap *soap, const char *tag, xs__include *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (xs__include *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xs__include, sizeof(xs__include), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_xs__include)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (xs__include *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "schemaLocation", 4, 0), &((xs__include*)a)->schemaLocation))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* non-serializable schemaRef skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (xs__include *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xs__include, SOAP_TYPE_xs__include, sizeof(xs__include), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 xs__include * SOAP_FMAC2 wsdl_instantiate_xs__include(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_xs__include(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xs__include *p;
	size_t k = sizeof(xs__include);
	if (n < 0)
	{	p = SOAP_NEW(xs__include);
	}
	else
	{	p = SOAP_NEW_ARRAY(xs__include, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xs__include location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_xs__include, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int xs__include::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xs__include(soap, tag ? tag : "xs:include", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xs__include::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xs__include(soap, this, tag, type);
}

SOAP_FMAC3 xs__include * SOAP_FMAC4 soap_get_xs__include(struct soap *soap, xs__include *p, const char *tag, const char *type)
{
	if ((p = soap_in_xs__include(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xs__import::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &this->xs__import::namespace_);
	soap_default_xsd__anyURI(soap, &this->xs__import::schemaLocation);
	soap_default_xsd__anyURI(soap, &this->xs__import::location);
	this->xs__import::schemaRef = NULL;
}

void xs__import::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	/* non-serializable schemaRef skipped */
#endif
}

int xs__import::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xs__import(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xs__import(struct soap *soap, const char *tag, int id, const xs__import *a, const char *type)
{
	if (((xs__import*)a)->namespace_)
		soap_set_attr(soap, "namespace", soap_xsd__anyURI2s(soap, ((xs__import*)a)->namespace_), 1);
	if (((xs__import*)a)->schemaLocation)
		soap_set_attr(soap, "schemaLocation", soap_xsd__anyURI2s(soap, ((xs__import*)a)->schemaLocation), 1);
	if (((xs__import*)a)->location)
		soap_set_attr(soap, "location", soap_xsd__anyURI2s(soap, ((xs__import*)a)->location), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xs__import), type))
		return soap->error;
	/* non-serializable schemaRef skipped */
	return soap_element_end_out(soap, tag);
}

void *xs__import::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xs__import(soap, tag, this, type);
}

SOAP_FMAC3 xs__import * SOAP_FMAC4 soap_in_xs__import(struct soap *soap, const char *tag, xs__import *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (xs__import *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xs__import, sizeof(xs__import), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_xs__import)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (xs__import *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "namespace", 4, 0), &((xs__import*)a)->namespace_))
		return NULL;
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "schemaLocation", 4, 0), &((xs__import*)a)->schemaLocation))
		return NULL;
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "location", 4, 0), &((xs__import*)a)->location))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* non-serializable schemaRef skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (xs__import *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xs__import, SOAP_TYPE_xs__import, sizeof(xs__import), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 xs__import * SOAP_FMAC2 wsdl_instantiate_xs__import(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_xs__import(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xs__import *p;
	size_t k = sizeof(xs__import);
	if (n < 0)
	{	p = SOAP_NEW(xs__import);
	}
	else
	{	p = SOAP_NEW_ARRAY(xs__import, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xs__import location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_xs__import, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int xs__import::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xs__import(soap, tag ? tag : "xs:import", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xs__import::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xs__import(soap, this, tag, type);
}

SOAP_FMAC3 xs__import * SOAP_FMAC4 soap_get_xs__import(struct soap *soap, xs__import *p, const char *tag, const char *type)
{
	if ((p = soap_in_xs__import(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xs__complexContent::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->xs__complexContent::mixed = (bool)0;
	this->xs__complexContent::extension = NULL;
	this->xs__complexContent::restriction = NULL;
	this->xs__complexContent::annotation = NULL;
}

void xs__complexContent::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToxs__extension(soap, &this->xs__complexContent::extension);
	soap_serialize_PointerToxs__restriction(soap, &this->xs__complexContent::restriction);
	soap_serialize_PointerToxs__annotation(soap, &this->xs__complexContent::annotation);
#endif
}

int xs__complexContent::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xs__complexContent(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xs__complexContent(struct soap *soap, const char *tag, int id, const xs__complexContent *a, const char *type)
{
	soap_set_attr(soap, "mixed", soap_xsd__boolean2s(soap, ((xs__complexContent*)a)->mixed), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xs__complexContent), type))
		return soap->error;
	if (soap_out_PointerToxs__extension(soap, "xs:extension", -1, &a->xs__complexContent::extension, ""))
		return soap->error;
	if (soap_out_PointerToxs__restriction(soap, "xs:restriction", -1, &a->xs__complexContent::restriction, ""))
		return soap->error;
	if (soap_out_PointerToxs__annotation(soap, "xs:annotation", -1, &a->xs__complexContent::annotation, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *xs__complexContent::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xs__complexContent(soap, tag, this, type);
}

SOAP_FMAC3 xs__complexContent * SOAP_FMAC4 soap_in_xs__complexContent(struct soap *soap, const char *tag, xs__complexContent *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (xs__complexContent *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xs__complexContent, sizeof(xs__complexContent), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_xs__complexContent)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (xs__complexContent *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__boolean(soap, soap_attr_value(soap, "mixed", 5, 0), &((xs__complexContent*)a)->mixed))
		return NULL;
	size_t soap_flag_extension1 = 1;
	size_t soap_flag_restriction1 = 1;
	size_t soap_flag_annotation1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxs__extension(soap, "xs:extension", &a->xs__complexContent::extension, "xs:extension"))
				{	soap_flag_extension1--;
					continue;
				}
			}
			if (soap_flag_restriction1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxs__restriction(soap, "xs:restriction", &a->xs__complexContent::restriction, "xs:restriction"))
				{	soap_flag_restriction1--;
					continue;
				}
			}
			if (soap_flag_annotation1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxs__annotation(soap, "xs:annotation", &a->xs__complexContent::annotation, "xs:annotation"))
				{	soap_flag_annotation1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (xs__complexContent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xs__complexContent, SOAP_TYPE_xs__complexContent, sizeof(xs__complexContent), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 xs__complexContent * SOAP_FMAC2 wsdl_instantiate_xs__complexContent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_xs__complexContent(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xs__complexContent *p;
	size_t k = sizeof(xs__complexContent);
	if (n < 0)
	{	p = SOAP_NEW(xs__complexContent);
	}
	else
	{	p = SOAP_NEW_ARRAY(xs__complexContent, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xs__complexContent location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_xs__complexContent, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int xs__complexContent::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xs__complexContent(soap, tag ? tag : "xs:complexContent", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xs__complexContent::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xs__complexContent(soap, this, tag, type);
}

SOAP_FMAC3 xs__complexContent * SOAP_FMAC4 soap_get_xs__complexContent(struct soap *soap, xs__complexContent *p, const char *tag, const char *type)
{
	if ((p = soap_in_xs__complexContent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xs__whiteSpace::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &this->xs__whiteSpace::value);
}

void xs__whiteSpace::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int xs__whiteSpace::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xs__whiteSpace(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xs__whiteSpace(struct soap *soap, const char *tag, int id, const xs__whiteSpace *a, const char *type)
{
	if (((xs__whiteSpace*)a)->value)
		soap_set_attr(soap, "value", soap_xsd__string2s(soap, ((xs__whiteSpace*)a)->value), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xs__whiteSpace), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *xs__whiteSpace::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xs__whiteSpace(soap, tag, this, type);
}

SOAP_FMAC3 xs__whiteSpace * SOAP_FMAC4 soap_in_xs__whiteSpace(struct soap *soap, const char *tag, xs__whiteSpace *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (xs__whiteSpace *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xs__whiteSpace, sizeof(xs__whiteSpace), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_xs__whiteSpace)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (xs__whiteSpace *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__string(soap, soap_attr_value(soap, "value", 1, 0), &((xs__whiteSpace*)a)->value))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (xs__whiteSpace *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xs__whiteSpace, SOAP_TYPE_xs__whiteSpace, sizeof(xs__whiteSpace), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 xs__whiteSpace * SOAP_FMAC2 wsdl_instantiate_xs__whiteSpace(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_xs__whiteSpace(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xs__whiteSpace *p;
	size_t k = sizeof(xs__whiteSpace);
	if (n < 0)
	{	p = SOAP_NEW(xs__whiteSpace);
	}
	else
	{	p = SOAP_NEW_ARRAY(xs__whiteSpace, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xs__whiteSpace location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_xs__whiteSpace, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int xs__whiteSpace::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xs__whiteSpace(soap, tag ? tag : "xs:whiteSpace", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xs__whiteSpace::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xs__whiteSpace(soap, this, tag, type);
}

SOAP_FMAC3 xs__whiteSpace * SOAP_FMAC4 soap_get_xs__whiteSpace(struct soap *soap, xs__whiteSpace *p, const char *tag, const char *type)
{
	if ((p = soap_in_xs__whiteSpace(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xs__length::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &this->xs__length::value);
	soap_default_xsd__boolean(soap, &this->xs__length::fixed);
	this->xs__length::annotation = NULL;
}

void xs__length::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToxs__annotation(soap, &this->xs__length::annotation);
#endif
}

int xs__length::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xs__length(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xs__length(struct soap *soap, const char *tag, int id, const xs__length *a, const char *type)
{
	if (((xs__length*)a)->value)
		soap_set_attr(soap, "value", soap_xsd__string2s(soap, ((xs__length*)a)->value), 1);
	soap_set_attr(soap, "fixed", soap_xsd__boolean2s(soap, ((xs__length*)a)->fixed), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xs__length), type))
		return soap->error;
	if (soap_out_PointerToxs__annotation(soap, "xs:annotation", -1, &a->xs__length::annotation, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *xs__length::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xs__length(soap, tag, this, type);
}

SOAP_FMAC3 xs__length * SOAP_FMAC4 soap_in_xs__length(struct soap *soap, const char *tag, xs__length *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (xs__length *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xs__length, sizeof(xs__length), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_xs__length)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (xs__length *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__string(soap, soap_attr_value(soap, "value", 1, 0), &((xs__length*)a)->value))
		return NULL;
	if (soap_s2xsd__boolean(soap, soap_attr_value(soap, "fixed", 5, 0), &((xs__length*)a)->fixed))
		return NULL;
	size_t soap_flag_annotation1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_annotation1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxs__annotation(soap, "xs:annotation", &a->xs__length::annotation, "xs:annotation"))
				{	soap_flag_annotation1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (xs__length *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xs__length, SOAP_TYPE_xs__length, sizeof(xs__length), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 xs__length * SOAP_FMAC2 wsdl_instantiate_xs__length(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_xs__length(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xs__length *p;
	size_t k = sizeof(xs__length);
	if (n < 0)
	{	p = SOAP_NEW(xs__length);
	}
	else
	{	p = SOAP_NEW_ARRAY(xs__length, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xs__length location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_xs__length, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int xs__length::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xs__length(soap, tag ? tag : "xs:length", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xs__length::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xs__length(soap, this, tag, type);
}

SOAP_FMAC3 xs__length * SOAP_FMAC4 soap_get_xs__length(struct soap *soap, xs__length *p, const char *tag, const char *type)
{
	if ((p = soap_in_xs__length(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xs__simpleContent::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->xs__simpleContent::extension = NULL;
	this->xs__simpleContent::restriction = NULL;
}

void xs__simpleContent::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToxs__extension(soap, &this->xs__simpleContent::extension);
	soap_serialize_PointerToxs__restriction(soap, &this->xs__simpleContent::restriction);
#endif
}

int xs__simpleContent::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xs__simpleContent(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xs__simpleContent(struct soap *soap, const char *tag, int id, const xs__simpleContent *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xs__simpleContent), type))
		return soap->error;
	if (soap_out_PointerToxs__extension(soap, "xs:extension", -1, &a->xs__simpleContent::extension, ""))
		return soap->error;
	if (soap_out_PointerToxs__restriction(soap, "xs:restriction", -1, &a->xs__simpleContent::restriction, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *xs__simpleContent::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xs__simpleContent(soap, tag, this, type);
}

SOAP_FMAC3 xs__simpleContent * SOAP_FMAC4 soap_in_xs__simpleContent(struct soap *soap, const char *tag, xs__simpleContent *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (xs__simpleContent *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xs__simpleContent, sizeof(xs__simpleContent), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_xs__simpleContent)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (xs__simpleContent *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_extension1 = 1;
	size_t soap_flag_restriction1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxs__extension(soap, "xs:extension", &a->xs__simpleContent::extension, "xs:extension"))
				{	soap_flag_extension1--;
					continue;
				}
			}
			if (soap_flag_restriction1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxs__restriction(soap, "xs:restriction", &a->xs__simpleContent::restriction, "xs:restriction"))
				{	soap_flag_restriction1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (xs__simpleContent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xs__simpleContent, SOAP_TYPE_xs__simpleContent, sizeof(xs__simpleContent), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 xs__simpleContent * SOAP_FMAC2 wsdl_instantiate_xs__simpleContent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_xs__simpleContent(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xs__simpleContent *p;
	size_t k = sizeof(xs__simpleContent);
	if (n < 0)
	{	p = SOAP_NEW(xs__simpleContent);
	}
	else
	{	p = SOAP_NEW_ARRAY(xs__simpleContent, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xs__simpleContent location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_xs__simpleContent, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int xs__simpleContent::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xs__simpleContent(soap, tag ? tag : "xs:simpleContent", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xs__simpleContent::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xs__simpleContent(soap, this, tag, type);
}

SOAP_FMAC3 xs__simpleContent * SOAP_FMAC4 soap_get_xs__simpleContent(struct soap *soap, xs__simpleContent *p, const char *tag, const char *type)
{
	if ((p = soap_in_xs__simpleContent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xs__pattern::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &this->xs__pattern::value);
}

void xs__pattern::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int xs__pattern::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xs__pattern(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xs__pattern(struct soap *soap, const char *tag, int id, const xs__pattern *a, const char *type)
{
	if (((xs__pattern*)a)->value)
		soap_set_attr(soap, "value", soap_xsd__string2s(soap, ((xs__pattern*)a)->value), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xs__pattern), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *xs__pattern::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xs__pattern(soap, tag, this, type);
}

SOAP_FMAC3 xs__pattern * SOAP_FMAC4 soap_in_xs__pattern(struct soap *soap, const char *tag, xs__pattern *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (xs__pattern *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xs__pattern, sizeof(xs__pattern), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_xs__pattern)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (xs__pattern *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__string(soap, soap_attr_value(soap, "value", 1, 0), &((xs__pattern*)a)->value))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (xs__pattern *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xs__pattern, SOAP_TYPE_xs__pattern, sizeof(xs__pattern), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 xs__pattern * SOAP_FMAC2 wsdl_instantiate_xs__pattern(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_xs__pattern(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xs__pattern *p;
	size_t k = sizeof(xs__pattern);
	if (n < 0)
	{	p = SOAP_NEW(xs__pattern);
	}
	else
	{	p = SOAP_NEW_ARRAY(xs__pattern, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xs__pattern location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_xs__pattern, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int xs__pattern::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xs__pattern(soap, tag ? tag : "xs:pattern", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xs__pattern::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xs__pattern(soap, this, tag, type);
}

SOAP_FMAC3 xs__pattern * SOAP_FMAC4 soap_get_xs__pattern(struct soap *soap, xs__pattern *p, const char *tag, const char *type)
{
	if ((p = soap_in_xs__pattern(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xs__enumeration::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &this->xs__enumeration::value);
	soap_default_xsd__QName(soap, &this->xs__enumeration::value_);
	this->xs__enumeration::annotation = NULL;
}

void xs__enumeration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToxs__annotation(soap, &this->xs__enumeration::annotation);
#endif
}

int xs__enumeration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xs__enumeration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xs__enumeration(struct soap *soap, const char *tag, int id, const xs__enumeration *a, const char *type)
{
	if (((xs__enumeration*)a)->value)
		soap_set_attr(soap, "value", soap_xsd__string2s(soap, ((xs__enumeration*)a)->value), 1);
	if (((xs__enumeration*)a)->value_)
		soap_set_attr(soap, "value", soap_xsd__QName2s(soap, ((xs__enumeration*)a)->value_), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xs__enumeration), type))
		return soap->error;
	if (soap_out_PointerToxs__annotation(soap, "xs:annotation", -1, &a->xs__enumeration::annotation, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *xs__enumeration::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xs__enumeration(soap, tag, this, type);
}

SOAP_FMAC3 xs__enumeration * SOAP_FMAC4 soap_in_xs__enumeration(struct soap *soap, const char *tag, xs__enumeration *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (xs__enumeration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xs__enumeration, sizeof(xs__enumeration), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_xs__enumeration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (xs__enumeration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__string(soap, soap_attr_value(soap, "value", 1, 0), &((xs__enumeration*)a)->value))
		return NULL;
	if (soap_s2xsd__QName(soap, soap_attr_value(soap, "value", 2, 0), &((xs__enumeration*)a)->value_))
		return NULL;
	size_t soap_flag_annotation1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_annotation1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxs__annotation(soap, "xs:annotation", &a->xs__enumeration::annotation, "xs:annotation"))
				{	soap_flag_annotation1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (xs__enumeration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xs__enumeration, SOAP_TYPE_xs__enumeration, sizeof(xs__enumeration), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 xs__enumeration * SOAP_FMAC2 wsdl_instantiate_xs__enumeration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_xs__enumeration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xs__enumeration *p;
	size_t k = sizeof(xs__enumeration);
	if (n < 0)
	{	p = SOAP_NEW(xs__enumeration);
	}
	else
	{	p = SOAP_NEW_ARRAY(xs__enumeration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xs__enumeration location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_xs__enumeration, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int xs__enumeration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xs__enumeration(soap, tag ? tag : "xs:enumeration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xs__enumeration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xs__enumeration(soap, this, tag, type);
}

SOAP_FMAC3 xs__enumeration * SOAP_FMAC4 soap_get_xs__enumeration(struct soap *soap, xs__enumeration *p, const char *tag, const char *type)
{
	if ((p = soap_in_xs__enumeration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xs__attributeGroup::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__NCName(soap, &this->xs__attributeGroup::name);
	soap_default_xsd__QName(soap, &this->xs__attributeGroup::ref);
	this->xs__attributeGroup::annotation = NULL;
	soap_default_std__vectorTemplateOfxs__attribute(soap, &this->xs__attributeGroup::attribute);
	soap_default_std__vectorTemplateOfxs__attributeGroup(soap, &this->xs__attributeGroup::attributeGroup);
	this->xs__attributeGroup::anyAttribute = NULL;
	this->xs__attributeGroup::schemaRef = NULL;
	this->xs__attributeGroup::attributeGroupRef = NULL;
}

void xs__attributeGroup::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToxs__annotation(soap, &this->xs__attributeGroup::annotation);
	soap_serialize_std__vectorTemplateOfxs__attribute(soap, &this->xs__attributeGroup::attribute);
	soap_serialize_std__vectorTemplateOfxs__attributeGroup(soap, &this->xs__attributeGroup::attributeGroup);
	soap_serialize_PointerToxs__anyAttribute(soap, &this->xs__attributeGroup::anyAttribute);
	/* non-serializable schemaRef skipped */
	/* non-serializable attributeGroupRef skipped */
#endif
}

int xs__attributeGroup::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xs__attributeGroup(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xs__attributeGroup(struct soap *soap, const char *tag, int id, const xs__attributeGroup *a, const char *type)
{
	if (((xs__attributeGroup*)a)->name)
		soap_set_attr(soap, "name", soap_xsd__NCName2s(soap, ((xs__attributeGroup*)a)->name), 1);
	if (((xs__attributeGroup*)a)->ref)
		soap_set_attr(soap, "ref", soap_xsd__QName2s(soap, ((xs__attributeGroup*)a)->ref), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xs__attributeGroup), type))
		return soap->error;
	if (soap_out_PointerToxs__annotation(soap, "xs:annotation", -1, &a->xs__attributeGroup::annotation, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxs__attribute(soap, "xs:attribute", -1, &a->xs__attributeGroup::attribute, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxs__attributeGroup(soap, "xs:attributeGroup", -1, &a->xs__attributeGroup::attributeGroup, ""))
		return soap->error;
	if (soap_out_PointerToxs__anyAttribute(soap, "xs:anyAttribute", -1, &a->xs__attributeGroup::anyAttribute, ""))
		return soap->error;
	/* non-serializable schemaRef skipped */
	/* non-serializable attributeGroupRef skipped */
	return soap_element_end_out(soap, tag);
}

void *xs__attributeGroup::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xs__attributeGroup(soap, tag, this, type);
}

SOAP_FMAC3 xs__attributeGroup * SOAP_FMAC4 soap_in_xs__attributeGroup(struct soap *soap, const char *tag, xs__attributeGroup *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (xs__attributeGroup *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xs__attributeGroup, sizeof(xs__attributeGroup), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_xs__attributeGroup)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (xs__attributeGroup *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__NCName(soap, soap_attr_value(soap, "name", 5, 0), &((xs__attributeGroup*)a)->name))
		return NULL;
	if (soap_s2xsd__QName(soap, soap_attr_value(soap, "ref", 2, 0), &((xs__attributeGroup*)a)->ref))
		return NULL;
	size_t soap_flag_annotation1 = 1;
	size_t soap_flag_anyAttribute1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_annotation1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxs__annotation(soap, "xs:annotation", &a->xs__attributeGroup::annotation, "xs:annotation"))
				{	soap_flag_annotation1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxs__attribute(soap, "xs:attribute", &a->xs__attributeGroup::attribute, "xs:attribute"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxs__attributeGroup(soap, "xs:attributeGroup", &a->xs__attributeGroup::attributeGroup, "xs:attributeGroup"))
					continue;
			}
			if (soap_flag_anyAttribute1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxs__anyAttribute(soap, "xs:anyAttribute", &a->xs__attributeGroup::anyAttribute, "xs:anyAttribute"))
				{	soap_flag_anyAttribute1--;
					continue;
				}
			}
			/* non-serializable schemaRef skipped */
			/* non-serializable attributeGroupRef skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (xs__attributeGroup *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xs__attributeGroup, SOAP_TYPE_xs__attributeGroup, sizeof(xs__attributeGroup), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 xs__attributeGroup * SOAP_FMAC2 wsdl_instantiate_xs__attributeGroup(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_xs__attributeGroup(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xs__attributeGroup *p;
	size_t k = sizeof(xs__attributeGroup);
	if (n < 0)
	{	p = SOAP_NEW(xs__attributeGroup);
	}
	else
	{	p = SOAP_NEW_ARRAY(xs__attributeGroup, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xs__attributeGroup location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_xs__attributeGroup, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int xs__attributeGroup::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xs__attributeGroup(soap, tag ? tag : "xs:attributeGroup", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xs__attributeGroup::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xs__attributeGroup(soap, this, tag, type);
}

SOAP_FMAC3 xs__attributeGroup * SOAP_FMAC4 soap_get_xs__attributeGroup(struct soap *soap, xs__attributeGroup *p, const char *tag, const char *type)
{
	if ((p = soap_in_xs__attributeGroup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xs__anyAttribute::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->xs__anyAttribute::namespace_ = (char*)"##any";
	this->xs__anyAttribute::processContents = (enum xs__processContents)0;
}

void xs__anyAttribute::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int xs__anyAttribute::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xs__anyAttribute(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xs__anyAttribute(struct soap *soap, const char *tag, int id, const xs__anyAttribute *a, const char *type)
{
	if (((xs__anyAttribute*)a)->namespace_)
		soap_set_attr(soap, "namespace", soap_xs__namespaceList2s(soap, ((xs__anyAttribute*)a)->namespace_), 1);
	soap_set_attr(soap, "processContents", soap_xs__processContents2s(soap, ((xs__anyAttribute*)a)->processContents), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xs__anyAttribute), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *xs__anyAttribute::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xs__anyAttribute(soap, tag, this, type);
}

SOAP_FMAC3 xs__anyAttribute * SOAP_FMAC4 soap_in_xs__anyAttribute(struct soap *soap, const char *tag, xs__anyAttribute *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (xs__anyAttribute *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xs__anyAttribute, sizeof(xs__anyAttribute), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_xs__anyAttribute)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (xs__anyAttribute *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xs__namespaceList(soap, soap_attr_value(soap, "namespace", 1, 0), &((xs__anyAttribute*)a)->namespace_))
		return NULL;
	if (soap_s2xs__processContents(soap, soap_attr_value(soap, "processContents", 5, 0), &((xs__anyAttribute*)a)->processContents))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (xs__anyAttribute *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xs__anyAttribute, SOAP_TYPE_xs__anyAttribute, sizeof(xs__anyAttribute), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 xs__anyAttribute * SOAP_FMAC2 wsdl_instantiate_xs__anyAttribute(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_xs__anyAttribute(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xs__anyAttribute *p;
	size_t k = sizeof(xs__anyAttribute);
	if (n < 0)
	{	p = SOAP_NEW(xs__anyAttribute);
	}
	else
	{	p = SOAP_NEW_ARRAY(xs__anyAttribute, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xs__anyAttribute location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_xs__anyAttribute, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int xs__anyAttribute::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xs__anyAttribute(soap, tag ? tag : "xs:anyAttribute", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xs__anyAttribute::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xs__anyAttribute(soap, this, tag, type);
}

SOAP_FMAC3 xs__anyAttribute * SOAP_FMAC4 soap_get_xs__anyAttribute(struct soap *soap, xs__anyAttribute *p, const char *tag, const char *type)
{
	if ((p = soap_in_xs__anyAttribute(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xs__contents::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->xs__contents::__union = 0;
}

void xs__contents::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xs__union_content(soap, this->xs__contents::__union, &this->xs__contents::__content);
#endif
}

int xs__contents::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xs__contents(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xs__contents(struct soap *soap, const char *tag, int id, const xs__contents *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xs__contents), type))
		return soap->error;
	if (soap_out_xs__union_content(soap, a->xs__contents::__union, &a->xs__contents::__content))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *xs__contents::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xs__contents(soap, tag, this, type);
}

SOAP_FMAC3 xs__contents * SOAP_FMAC4 soap_in_xs__contents(struct soap *soap, const char *tag, xs__contents *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (xs__contents *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xs__contents, sizeof(xs__contents), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (!tag || *tag == '-' || (soap->body && *soap->href != '#'))
	{
		if (!soap_in_xs__union_content(soap, &a->__union, &a->__content))
			return NULL;
		if (tag && *tag != '-')
		{	soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_TAG_MISMATCH || soap_element_end_in(soap, tag))
				return NULL;
		}
	}
	else
	{	a = (xs__contents *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xs__contents, SOAP_TYPE_xs__contents, sizeof(xs__contents), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 xs__contents * SOAP_FMAC2 wsdl_instantiate_xs__contents(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_xs__contents(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xs__contents *p;
	size_t k = sizeof(xs__contents);
	if (n < 0)
	{	p = SOAP_NEW(xs__contents);
	}
	else
	{	p = SOAP_NEW_ARRAY(xs__contents, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xs__contents location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_xs__contents, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int xs__contents::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xs__contents(soap, tag ? tag : "xs:contents", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xs__contents::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xs__contents(soap, this, tag, type);
}

SOAP_FMAC3 xs__contents * SOAP_FMAC4 soap_get_xs__contents(struct soap *soap, xs__contents *p, const char *tag, const char *type)
{
	if ((p = soap_in_xs__contents(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xs__any::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->xs__any::namespace_ = (char*)"##any";
	this->xs__any::processContents = (enum xs__processContents)0;
	soap_default_xsd__token(soap, &this->xs__any::minOccurs);
	soap_default_xsd__token(soap, &this->xs__any::maxOccurs);
	soap_default_std__vectorTemplateOfxs__element(soap, &this->xs__any::element);
}

void xs__any::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxs__element(soap, &this->xs__any::element);
#endif
}

int xs__any::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xs__any(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xs__any(struct soap *soap, const char *tag, int id, const xs__any *a, const char *type)
{
	if (((xs__any*)a)->namespace_)
		soap_set_attr(soap, "namespace", soap_xs__namespaceList2s(soap, ((xs__any*)a)->namespace_), 1);
	soap_set_attr(soap, "processContents", soap_xs__processContents2s(soap, ((xs__any*)a)->processContents), 1);
	if (((xs__any*)a)->minOccurs)
		soap_set_attr(soap, "minOccurs", soap_xsd__token2s(soap, ((xs__any*)a)->minOccurs), 1);
	if (((xs__any*)a)->maxOccurs)
		soap_set_attr(soap, "maxOccurs", soap_xsd__token2s(soap, ((xs__any*)a)->maxOccurs), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xs__any), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxs__element(soap, "xs:element", -1, &a->xs__any::element, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *xs__any::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xs__any(soap, tag, this, type);
}

SOAP_FMAC3 xs__any * SOAP_FMAC4 soap_in_xs__any(struct soap *soap, const char *tag, xs__any *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (xs__any *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xs__any, sizeof(xs__any), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_xs__any)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (xs__any *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xs__namespaceList(soap, soap_attr_value(soap, "namespace", 1, 0), &((xs__any*)a)->namespace_))
		return NULL;
	if (soap_s2xs__processContents(soap, soap_attr_value(soap, "processContents", 5, 0), &((xs__any*)a)->processContents))
		return NULL;
	if (soap_s2xsd__token(soap, soap_attr_value(soap, "minOccurs", 5, 0), &((xs__any*)a)->minOccurs))
		return NULL;
	if (soap_s2xsd__token(soap, soap_attr_value(soap, "maxOccurs", 5, 0), &((xs__any*)a)->maxOccurs))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxs__element(soap, "xs:element", &a->xs__any::element, "xs:element"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (xs__any *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xs__any, SOAP_TYPE_xs__any, sizeof(xs__any), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 xs__any * SOAP_FMAC2 wsdl_instantiate_xs__any(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_xs__any(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xs__any *p;
	size_t k = sizeof(xs__any);
	if (n < 0)
	{	p = SOAP_NEW(xs__any);
	}
	else
	{	p = SOAP_NEW_ARRAY(xs__any, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xs__any location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_xs__any, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int xs__any::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xs__any(soap, tag ? tag : "xs:any", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xs__any::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xs__any(soap, this, tag, type);
}

SOAP_FMAC3 xs__any * SOAP_FMAC4 soap_get_xs__any(struct soap *soap, xs__any *p, const char *tag, const char *type)
{
	if ((p = soap_in_xs__any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xs__all::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxs__element(soap, &this->xs__all::element);
}

void xs__all::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxs__element(soap, &this->xs__all::element);
#endif
}

int xs__all::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xs__all(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xs__all(struct soap *soap, const char *tag, int id, const xs__all *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xs__all), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxs__element(soap, "xs:element", -1, &a->xs__all::element, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *xs__all::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xs__all(soap, tag, this, type);
}

SOAP_FMAC3 xs__all * SOAP_FMAC4 soap_in_xs__all(struct soap *soap, const char *tag, xs__all *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (xs__all *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xs__all, sizeof(xs__all), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_xs__all)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (xs__all *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxs__element(soap, "xs:element", &a->xs__all::element, "xs:element"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (xs__all *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xs__all, SOAP_TYPE_xs__all, sizeof(xs__all), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 xs__all * SOAP_FMAC2 wsdl_instantiate_xs__all(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_xs__all(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xs__all *p;
	size_t k = sizeof(xs__all);
	if (n < 0)
	{	p = SOAP_NEW(xs__all);
	}
	else
	{	p = SOAP_NEW_ARRAY(xs__all, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xs__all location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_xs__all, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int xs__all::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xs__all(soap, tag ? tag : "xs:all", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xs__all::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xs__all(soap, this, tag, type);
}

SOAP_FMAC3 xs__all * SOAP_FMAC4 soap_get_xs__all(struct soap *soap, xs__all *p, const char *tag, const char *type)
{
	if ((p = soap_in_xs__all(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xs__attribute::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__NCName(soap, &this->xs__attribute::name);
	soap_default_xsd__QName(soap, &this->xs__attribute::ref);
	soap_default_xsd__QName(soap, &this->xs__attribute::type);
	this->xs__attribute::use = (enum xs__attribute_use)0;
	soap_default_xsd__string(soap, &this->xs__attribute::default_);
	soap_default_xsd__QName(soap, &this->xs__attribute::default__);
	soap_default_xsd__string(soap, &this->xs__attribute::fixed);
	soap_default_xsd__QName(soap, &this->xs__attribute::fixed_);
	this->xs__attribute::form = NULL;
	soap_default_xsd__boolean(soap, &this->xs__attribute::inheritable);
	soap_default_xsd__anyURI(soap, &this->xs__attribute::targetNamespace);
	soap_default_xsd__QName(soap, &this->xs__attribute::wsdl__arrayType);
	this->xs__attribute::annotation = NULL;
	this->xs__attribute::simpleType = NULL;
	this->xs__attribute::schemaRef = NULL;
	this->xs__attribute::attributeRef = NULL;
	this->xs__attribute::simpleTypeRef = NULL;
}

void xs__attribute::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToxs__annotation(soap, &this->xs__attribute::annotation);
	soap_serialize_PointerToxs__simpleType(soap, &this->xs__attribute::simpleType);
	/* non-serializable schemaRef skipped */
	/* non-serializable attributeRef skipped */
	/* non-serializable simpleTypeRef skipped */
#endif
}

int xs__attribute::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xs__attribute(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xs__attribute(struct soap *soap, const char *tag, int id, const xs__attribute *a, const char *type)
{
	if (((xs__attribute*)a)->name)
		soap_set_attr(soap, "name", soap_xsd__NCName2s(soap, ((xs__attribute*)a)->name), 1);
	if (((xs__attribute*)a)->ref)
		soap_set_attr(soap, "ref", soap_xsd__QName2s(soap, ((xs__attribute*)a)->ref), 1);
	if (((xs__attribute*)a)->type)
		soap_set_attr(soap, "type", soap_xsd__QName2s(soap, ((xs__attribute*)a)->type), 1);
	soap_set_attr(soap, "use", soap_xs__attribute_use2s(soap, ((xs__attribute*)a)->use), 1);
	if (((xs__attribute*)a)->default_)
		soap_set_attr(soap, "default", soap_xsd__string2s(soap, ((xs__attribute*)a)->default_), 1);
	if (((xs__attribute*)a)->default__)
		soap_set_attr(soap, "default", soap_xsd__QName2s(soap, ((xs__attribute*)a)->default__), 1);
	if (((xs__attribute*)a)->fixed)
		soap_set_attr(soap, "fixed", soap_xsd__string2s(soap, ((xs__attribute*)a)->fixed), 1);
	if (((xs__attribute*)a)->fixed_)
		soap_set_attr(soap, "fixed", soap_xsd__QName2s(soap, ((xs__attribute*)a)->fixed_), 1);
	if (((xs__attribute*)a)->form)
	{	soap_set_attr(soap, "form", soap_xs__formChoice2s(soap, *((xs__attribute*)a)->form), 1);
	}
	soap_set_attr(soap, "inheritable", soap_xsd__boolean2s(soap, ((xs__attribute*)a)->inheritable), 1);
	if (((xs__attribute*)a)->targetNamespace)
		soap_set_attr(soap, "targetNamespace", soap_xsd__anyURI2s(soap, ((xs__attribute*)a)->targetNamespace), 1);
	if (((xs__attribute*)a)->wsdl__arrayType)
		soap_set_attr(soap, "wsdl:arrayType", soap_xsd__QName2s(soap, ((xs__attribute*)a)->wsdl__arrayType), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xs__attribute), type))
		return soap->error;
	if (soap_out_PointerToxs__annotation(soap, "xs:annotation", -1, &a->xs__attribute::annotation, ""))
		return soap->error;
	if (soap_out_PointerToxs__simpleType(soap, "xs:simpleType", -1, &a->xs__attribute::simpleType, ""))
		return soap->error;
	/* non-serializable schemaRef skipped */
	/* non-serializable attributeRef skipped */
	/* non-serializable simpleTypeRef skipped */
	return soap_element_end_out(soap, tag);
}

void *xs__attribute::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xs__attribute(soap, tag, this, type);
}

SOAP_FMAC3 xs__attribute * SOAP_FMAC4 soap_in_xs__attribute(struct soap *soap, const char *tag, xs__attribute *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (xs__attribute *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xs__attribute, sizeof(xs__attribute), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_xs__attribute)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (xs__attribute *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__NCName(soap, soap_attr_value(soap, "name", 5, 0), &((xs__attribute*)a)->name))
		return NULL;
	if (soap_s2xsd__QName(soap, soap_attr_value(soap, "ref", 2, 0), &((xs__attribute*)a)->ref))
		return NULL;
	if (soap_s2xsd__QName(soap, soap_attr_value(soap, "type", 2, 0), &((xs__attribute*)a)->type))
		return NULL;
	if (soap_s2xs__attribute_use(soap, soap_attr_value(soap, "use", 5, 0), &((xs__attribute*)a)->use))
		return NULL;
	if (soap_s2xsd__string(soap, soap_attr_value(soap, "default", 1, 0), &((xs__attribute*)a)->default_))
		return NULL;
	if (soap_s2xsd__QName(soap, soap_attr_value(soap, "default", 2, 0), &((xs__attribute*)a)->default__))
		return NULL;
	if (soap_s2xsd__string(soap, soap_attr_value(soap, "fixed", 1, 0), &((xs__attribute*)a)->fixed))
		return NULL;
	if (soap_s2xsd__QName(soap, soap_attr_value(soap, "fixed", 2, 0), &((xs__attribute*)a)->fixed_))
		return NULL;
	{
		const char *t = soap_attr_value(soap, "form", 5, 0);
		if (t)
		{
			if (!(((xs__attribute*)a)->form = (enum xs__formChoice *)soap_malloc(soap, sizeof(enum xs__formChoice))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xs__formChoice(soap, t, ((xs__attribute*)a)->form))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2xsd__boolean(soap, soap_attr_value(soap, "inheritable", 5, 0), &((xs__attribute*)a)->inheritable))
		return NULL;
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "targetNamespace", 4, 0), &((xs__attribute*)a)->targetNamespace))
		return NULL;
	if (soap_s2xsd__QName(soap, soap_attr_value(soap, "wsdl:arrayType", 2, 0), &((xs__attribute*)a)->wsdl__arrayType))
		return NULL;
	size_t soap_flag_annotation1 = 1;
	size_t soap_flag_simpleType1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_annotation1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxs__annotation(soap, "xs:annotation", &a->xs__attribute::annotation, "xs:annotation"))
				{	soap_flag_annotation1--;
					continue;
				}
			}
			if (soap_flag_simpleType1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxs__simpleType(soap, "xs:simpleType", &a->xs__attribute::simpleType, "xs:simpleType"))
				{	soap_flag_simpleType1--;
					continue;
				}
			}
			/* non-serializable schemaRef skipped */
			/* non-serializable attributeRef skipped */
			/* non-serializable simpleTypeRef skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (xs__attribute *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xs__attribute, SOAP_TYPE_xs__attribute, sizeof(xs__attribute), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 xs__attribute * SOAP_FMAC2 wsdl_instantiate_xs__attribute(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_xs__attribute(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xs__attribute *p;
	size_t k = sizeof(xs__attribute);
	if (n < 0)
	{	p = SOAP_NEW(xs__attribute);
	}
	else
	{	p = SOAP_NEW_ARRAY(xs__attribute, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xs__attribute location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_xs__attribute, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int xs__attribute::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xs__attribute(soap, tag ? tag : "xs:attribute", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xs__attribute::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xs__attribute(soap, this, tag, type);
}

SOAP_FMAC3 xs__attribute * SOAP_FMAC4 soap_get_xs__attribute(struct soap *soap, xs__attribute *p, const char *tag, const char *type)
{
	if ((p = soap_in_xs__attribute(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xs__element::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__NCName(soap, &this->xs__element::name);
	soap_default_xsd__QName(soap, &this->xs__element::ref);
	soap_default_xsd__QName(soap, &this->xs__element::type);
	soap_default_xsd__string(soap, &this->xs__element::default_);
	soap_default_xsd__QName(soap, &this->xs__element::default__);
	soap_default_xsd__string(soap, &this->xs__element::fixed);
	soap_default_xsd__QName(soap, &this->xs__element::fixed_);
	this->xs__element::form = NULL;
	this->xs__element::nillable = (bool)0;
	this->xs__element::abstract = (bool)0;
	soap_default_xsd__QName(soap, &this->xs__element::substitutionGroup);
	soap_default_xsd__token(soap, &this->xs__element::minOccurs);
	soap_default_xsd__token(soap, &this->xs__element::maxOccurs);
	soap_default_xsd__anyURI(soap, &this->xs__element::targetNamespace);
	soap_default_xsd__string(soap, &this->xs__element::xmime__expectedContentTypes);
	this->xs__element::annotation = NULL;
	this->xs__element::simpleType = NULL;
	this->xs__element::complexType = NULL;
	soap_default_std__vectorTemplateOfxs__alternative(soap, &this->xs__element::alternative);
	soap_default_xsd__string(soap, &this->xs__element::unique);
	this->xs__element::schemaRef = NULL;
	this->xs__element::elementRef = NULL;
	this->xs__element::simpleTypeRef = NULL;
	this->xs__element::complexTypeRef = NULL;
	soap_default_std__vectorTemplateOfPointerToxs__element(soap, &this->xs__element::substitutions);
}

void xs__element::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToxs__annotation(soap, &this->xs__element::annotation);
	soap_serialize_PointerToxs__simpleType(soap, &this->xs__element::simpleType);
	soap_serialize_PointerToxs__complexType(soap, &this->xs__element::complexType);
	soap_serialize_std__vectorTemplateOfxs__alternative(soap, &this->xs__element::alternative);
	soap_serialize_xsd__string(soap, (char*const*)&this->xs__element::unique);
	/* non-serializable schemaRef skipped */
	/* non-serializable elementRef skipped */
	/* non-serializable simpleTypeRef skipped */
	/* non-serializable complexTypeRef skipped */
	/* non-serializable substitutions skipped */
#endif
}

int xs__element::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xs__element(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xs__element(struct soap *soap, const char *tag, int id, const xs__element *a, const char *type)
{
	if (((xs__element*)a)->name)
		soap_set_attr(soap, "name", soap_xsd__NCName2s(soap, ((xs__element*)a)->name), 1);
	if (((xs__element*)a)->ref)
		soap_set_attr(soap, "ref", soap_xsd__QName2s(soap, ((xs__element*)a)->ref), 1);
	if (((xs__element*)a)->type)
		soap_set_attr(soap, "type", soap_xsd__QName2s(soap, ((xs__element*)a)->type), 1);
	if (((xs__element*)a)->default_)
		soap_set_attr(soap, "default", soap_xsd__string2s(soap, ((xs__element*)a)->default_), 1);
	if (((xs__element*)a)->default__)
		soap_set_attr(soap, "default", soap_xsd__QName2s(soap, ((xs__element*)a)->default__), 1);
	if (((xs__element*)a)->fixed)
		soap_set_attr(soap, "fixed", soap_xsd__string2s(soap, ((xs__element*)a)->fixed), 1);
	if (((xs__element*)a)->fixed_)
		soap_set_attr(soap, "fixed", soap_xsd__QName2s(soap, ((xs__element*)a)->fixed_), 1);
	if (((xs__element*)a)->form)
	{	soap_set_attr(soap, "form", soap_xs__formChoice2s(soap, *((xs__element*)a)->form), 1);
	}
	soap_set_attr(soap, "nillable", soap_xsd__boolean2s(soap, ((xs__element*)a)->nillable), 1);
	soap_set_attr(soap, "abstract", soap_xsd__boolean2s(soap, ((xs__element*)a)->abstract), 1);
	if (((xs__element*)a)->substitutionGroup)
		soap_set_attr(soap, "substitutionGroup", soap_xsd__QName2s(soap, ((xs__element*)a)->substitutionGroup), 1);
	if (((xs__element*)a)->minOccurs)
		soap_set_attr(soap, "minOccurs", soap_xsd__token2s(soap, ((xs__element*)a)->minOccurs), 1);
	if (((xs__element*)a)->maxOccurs)
		soap_set_attr(soap, "maxOccurs", soap_xsd__token2s(soap, ((xs__element*)a)->maxOccurs), 1);
	if (((xs__element*)a)->targetNamespace)
		soap_set_attr(soap, "targetNamespace", soap_xsd__anyURI2s(soap, ((xs__element*)a)->targetNamespace), 1);
	if (((xs__element*)a)->xmime__expectedContentTypes)
		soap_set_attr(soap, "xmime:expectedContentTypes", soap_xsd__string2s(soap, ((xs__element*)a)->xmime__expectedContentTypes), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xs__element), type))
		return soap->error;
	if (soap_out_PointerToxs__annotation(soap, "xs:annotation", -1, &a->xs__element::annotation, ""))
		return soap->error;
	if (soap_out_PointerToxs__simpleType(soap, "xs:simpleType", -1, &a->xs__element::simpleType, ""))
		return soap->error;
	if (soap_out_PointerToxs__complexType(soap, "xs:complexType", -1, &a->xs__element::complexType, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxs__alternative(soap, "xs:alternative", -1, &a->xs__element::alternative, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "xs:unique", -1, (char*const*)&a->xs__element::unique, ""))
		return soap->error;
	/* non-serializable schemaRef skipped */
	/* non-serializable elementRef skipped */
	/* non-serializable simpleTypeRef skipped */
	/* non-serializable complexTypeRef skipped */
	/* non-serializable substitutions skipped */
	return soap_element_end_out(soap, tag);
}

void *xs__element::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xs__element(soap, tag, this, type);
}

SOAP_FMAC3 xs__element * SOAP_FMAC4 soap_in_xs__element(struct soap *soap, const char *tag, xs__element *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (xs__element *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xs__element, sizeof(xs__element), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_xs__element)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (xs__element *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__NCName(soap, soap_attr_value(soap, "name", 5, 0), &((xs__element*)a)->name))
		return NULL;
	if (soap_s2xsd__QName(soap, soap_attr_value(soap, "ref", 2, 0), &((xs__element*)a)->ref))
		return NULL;
	if (soap_s2xsd__QName(soap, soap_attr_value(soap, "type", 2, 0), &((xs__element*)a)->type))
		return NULL;
	if (soap_s2xsd__string(soap, soap_attr_value(soap, "default", 1, 0), &((xs__element*)a)->default_))
		return NULL;
	if (soap_s2xsd__QName(soap, soap_attr_value(soap, "default", 2, 0), &((xs__element*)a)->default__))
		return NULL;
	if (soap_s2xsd__string(soap, soap_attr_value(soap, "fixed", 1, 0), &((xs__element*)a)->fixed))
		return NULL;
	if (soap_s2xsd__QName(soap, soap_attr_value(soap, "fixed", 2, 0), &((xs__element*)a)->fixed_))
		return NULL;
	{
		const char *t = soap_attr_value(soap, "form", 5, 0);
		if (t)
		{
			if (!(((xs__element*)a)->form = (enum xs__formChoice *)soap_malloc(soap, sizeof(enum xs__formChoice))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xs__formChoice(soap, t, ((xs__element*)a)->form))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2xsd__boolean(soap, soap_attr_value(soap, "nillable", 5, 0), &((xs__element*)a)->nillable))
		return NULL;
	if (soap_s2xsd__boolean(soap, soap_attr_value(soap, "abstract", 5, 0), &((xs__element*)a)->abstract))
		return NULL;
	if (soap_s2xsd__QName(soap, soap_attr_value(soap, "substitutionGroup", 2, 0), &((xs__element*)a)->substitutionGroup))
		return NULL;
	if (soap_s2xsd__token(soap, soap_attr_value(soap, "minOccurs", 5, 0), &((xs__element*)a)->minOccurs))
		return NULL;
	if (soap_s2xsd__token(soap, soap_attr_value(soap, "maxOccurs", 5, 0), &((xs__element*)a)->maxOccurs))
		return NULL;
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "targetNamespace", 4, 0), &((xs__element*)a)->targetNamespace))
		return NULL;
	if (soap_s2xsd__string(soap, soap_attr_value(soap, "xmime:expectedContentTypes", 1, 0), &((xs__element*)a)->xmime__expectedContentTypes))
		return NULL;
	size_t soap_flag_annotation1 = 1;
	size_t soap_flag_simpleType1 = 1;
	size_t soap_flag_complexType1 = 1;
	size_t soap_flag_unique1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_annotation1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxs__annotation(soap, "xs:annotation", &a->xs__element::annotation, "xs:annotation"))
				{	soap_flag_annotation1--;
					continue;
				}
			}
			if (soap_flag_simpleType1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxs__simpleType(soap, "xs:simpleType", &a->xs__element::simpleType, "xs:simpleType"))
				{	soap_flag_simpleType1--;
					continue;
				}
			}
			if (soap_flag_complexType1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxs__complexType(soap, "xs:complexType", &a->xs__element::complexType, "xs:complexType"))
				{	soap_flag_complexType1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxs__alternative(soap, "xs:alternative", &a->xs__element::alternative, "xs:alternative"))
					continue;
			}
			if (soap_flag_unique1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "xs:unique", (char**)&a->xs__element::unique, "xsd:string"))
				{	soap_flag_unique1--;
					continue;
				}
			}
			/* non-serializable schemaRef skipped */
			/* non-serializable elementRef skipped */
			/* non-serializable simpleTypeRef skipped */
			/* non-serializable complexTypeRef skipped */
			/* non-serializable substitutions skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (xs__element *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xs__element, SOAP_TYPE_xs__element, sizeof(xs__element), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 xs__element * SOAP_FMAC2 wsdl_instantiate_xs__element(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_xs__element(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xs__element *p;
	size_t k = sizeof(xs__element);
	if (n < 0)
	{	p = SOAP_NEW(xs__element);
	}
	else
	{	p = SOAP_NEW_ARRAY(xs__element, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xs__element location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_xs__element, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int xs__element::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xs__element(soap, tag ? tag : "xs:element", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xs__element::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xs__element(soap, this, tag, type);
}

SOAP_FMAC3 xs__element * SOAP_FMAC4 soap_get_xs__element(struct soap *soap, xs__element *p, const char *tag, const char *type)
{
	if ((p = soap_in_xs__element(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xs__alternative::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &this->xs__alternative::test);
	soap_default_xsd__QName(soap, &this->xs__alternative::type);
	soap_default_xsd__anyURI(soap, &this->xs__alternative::xpathDefaultNamespace);
	this->xs__alternative::annotation = NULL;
}

void xs__alternative::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToxs__annotation(soap, &this->xs__alternative::annotation);
#endif
}

int xs__alternative::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xs__alternative(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xs__alternative(struct soap *soap, const char *tag, int id, const xs__alternative *a, const char *type)
{
	if (((xs__alternative*)a)->test)
		soap_set_attr(soap, "test", soap_xsd__string2s(soap, ((xs__alternative*)a)->test), 1);
	if (((xs__alternative*)a)->type)
		soap_set_attr(soap, "type", soap_xsd__QName2s(soap, ((xs__alternative*)a)->type), 1);
	if (((xs__alternative*)a)->xpathDefaultNamespace)
		soap_set_attr(soap, "xpathDefaultNamespace", soap_xsd__anyURI2s(soap, ((xs__alternative*)a)->xpathDefaultNamespace), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xs__alternative), type))
		return soap->error;
	if (soap_out_PointerToxs__annotation(soap, "xs:annotation", -1, &a->xs__alternative::annotation, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *xs__alternative::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xs__alternative(soap, tag, this, type);
}

SOAP_FMAC3 xs__alternative * SOAP_FMAC4 soap_in_xs__alternative(struct soap *soap, const char *tag, xs__alternative *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (xs__alternative *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xs__alternative, sizeof(xs__alternative), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_xs__alternative)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (xs__alternative *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__string(soap, soap_attr_value(soap, "test", 1, 0), &((xs__alternative*)a)->test))
		return NULL;
	if (soap_s2xsd__QName(soap, soap_attr_value(soap, "type", 2, 0), &((xs__alternative*)a)->type))
		return NULL;
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "xpathDefaultNamespace", 4, 0), &((xs__alternative*)a)->xpathDefaultNamespace))
		return NULL;
	size_t soap_flag_annotation1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_annotation1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxs__annotation(soap, "xs:annotation", &a->xs__alternative::annotation, "xs:annotation"))
				{	soap_flag_annotation1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (xs__alternative *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xs__alternative, SOAP_TYPE_xs__alternative, sizeof(xs__alternative), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 xs__alternative * SOAP_FMAC2 wsdl_instantiate_xs__alternative(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_xs__alternative(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xs__alternative *p;
	size_t k = sizeof(xs__alternative);
	if (n < 0)
	{	p = SOAP_NEW(xs__alternative);
	}
	else
	{	p = SOAP_NEW_ARRAY(xs__alternative, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xs__alternative location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_xs__alternative, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int xs__alternative::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xs__alternative(soap, tag ? tag : "xs:alternative", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xs__alternative::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xs__alternative(soap, this, tag, type);
}

SOAP_FMAC3 xs__alternative * SOAP_FMAC4 soap_get_xs__alternative(struct soap *soap, xs__alternative *p, const char *tag, const char *type)
{
	if ((p = soap_in_xs__alternative(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xs__assert::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &this->xs__assert::test);
	soap_default_xsd__anyURI(soap, &this->xs__assert::xpathDefaultNamespace);
	this->xs__assert::annotation = NULL;
}

void xs__assert::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToxs__annotation(soap, &this->xs__assert::annotation);
#endif
}

int xs__assert::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xs__assert(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xs__assert(struct soap *soap, const char *tag, int id, const xs__assert *a, const char *type)
{
	if (((xs__assert*)a)->test)
		soap_set_attr(soap, "test", soap_xsd__string2s(soap, ((xs__assert*)a)->test), 1);
	if (((xs__assert*)a)->xpathDefaultNamespace)
		soap_set_attr(soap, "xpathDefaultNamespace", soap_xsd__anyURI2s(soap, ((xs__assert*)a)->xpathDefaultNamespace), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xs__assert), type))
		return soap->error;
	if (soap_out_PointerToxs__annotation(soap, "xs:annotation", -1, &a->xs__assert::annotation, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *xs__assert::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xs__assert(soap, tag, this, type);
}

SOAP_FMAC3 xs__assert * SOAP_FMAC4 soap_in_xs__assert(struct soap *soap, const char *tag, xs__assert *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (xs__assert *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xs__assert, sizeof(xs__assert), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_xs__assert)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (xs__assert *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__string(soap, soap_attr_value(soap, "test", 1, 0), &((xs__assert*)a)->test))
		return NULL;
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "xpathDefaultNamespace", 4, 0), &((xs__assert*)a)->xpathDefaultNamespace))
		return NULL;
	size_t soap_flag_annotation1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_annotation1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxs__annotation(soap, "xs:annotation", &a->xs__assert::annotation, "xs:annotation"))
				{	soap_flag_annotation1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (xs__assert *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xs__assert, SOAP_TYPE_xs__assert, sizeof(xs__assert), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 xs__assert * SOAP_FMAC2 wsdl_instantiate_xs__assert(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_xs__assert(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xs__assert *p;
	size_t k = sizeof(xs__assert);
	if (n < 0)
	{	p = SOAP_NEW(xs__assert);
	}
	else
	{	p = SOAP_NEW_ARRAY(xs__assert, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xs__assert location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_xs__assert, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int xs__assert::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xs__assert(soap, tag ? tag : "xs:assert", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xs__assert::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xs__assert(soap, this, tag, type);
}

SOAP_FMAC3 xs__assert * SOAP_FMAC4 soap_get_xs__assert(struct soap *soap, xs__assert *p, const char *tag, const char *type)
{
	if ((p = soap_in_xs__assert(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xs__annotation::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfstring(soap, &this->xs__annotation::documentation);
}

void xs__annotation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfstring(soap, &this->xs__annotation::documentation);
#endif
}

int xs__annotation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xs__annotation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xs__annotation(struct soap *soap, const char *tag, int id, const xs__annotation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xs__annotation), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstring(soap, "xs:documentation", -1, &a->xs__annotation::documentation, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *xs__annotation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xs__annotation(soap, tag, this, type);
}

SOAP_FMAC3 xs__annotation * SOAP_FMAC4 soap_in_xs__annotation(struct soap *soap, const char *tag, xs__annotation *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (xs__annotation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xs__annotation, sizeof(xs__annotation), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_xs__annotation)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (xs__annotation *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfstring(soap, "xs:documentation", &a->xs__annotation::documentation, "xsd:string"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (xs__annotation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xs__annotation, SOAP_TYPE_xs__annotation, sizeof(xs__annotation), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 xs__annotation * SOAP_FMAC2 wsdl_instantiate_xs__annotation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_xs__annotation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xs__annotation *p;
	size_t k = sizeof(xs__annotation);
	if (n < 0)
	{	p = SOAP_NEW(xs__annotation);
	}
	else
	{	p = SOAP_NEW_ARRAY(xs__annotation, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xs__annotation location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_xs__annotation, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int xs__annotation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xs__annotation(soap, tag ? tag : "xs:annotation", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xs__annotation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xs__annotation(soap, this, tag, type);
}

SOAP_FMAC3 xs__annotation * SOAP_FMAC4 soap_get_xs__annotation(struct soap *soap, xs__annotation *p, const char *tag, const char *type)
{
	if ((p = soap_in_xs__annotation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xs__union::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__NMTOKENS(soap, &this->xs__union::memberTypes);
	soap_default_std__vectorTemplateOfxs__simpleType(soap, &this->xs__union::simpleType);
}

void xs__union::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxs__simpleType(soap, &this->xs__union::simpleType);
#endif
}

int xs__union::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xs__union(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xs__union(struct soap *soap, const char *tag, int id, const xs__union *a, const char *type)
{
	if (((xs__union*)a)->memberTypes)
		soap_set_attr(soap, "memberTypes", soap_xsd__NMTOKENS2s(soap, ((xs__union*)a)->memberTypes), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xs__union), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxs__simpleType(soap, "xs:simpleType", -1, &a->xs__union::simpleType, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *xs__union::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xs__union(soap, tag, this, type);
}

SOAP_FMAC3 xs__union * SOAP_FMAC4 soap_in_xs__union(struct soap *soap, const char *tag, xs__union *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (xs__union *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xs__union, sizeof(xs__union), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_xs__union)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (xs__union *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__NMTOKENS(soap, soap_attr_value(soap, "memberTypes", 5, 0), &((xs__union*)a)->memberTypes))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxs__simpleType(soap, "xs:simpleType", &a->xs__union::simpleType, "xs:simpleType"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (xs__union *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xs__union, SOAP_TYPE_xs__union, sizeof(xs__union), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 xs__union * SOAP_FMAC2 wsdl_instantiate_xs__union(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_xs__union(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xs__union *p;
	size_t k = sizeof(xs__union);
	if (n < 0)
	{	p = SOAP_NEW(xs__union);
	}
	else
	{	p = SOAP_NEW_ARRAY(xs__union, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xs__union location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_xs__union, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int xs__union::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xs__union(soap, tag ? tag : "xs:union", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xs__union::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xs__union(soap, this, tag, type);
}

SOAP_FMAC3 xs__union * SOAP_FMAC4 soap_get_xs__union(struct soap *soap, xs__union *p, const char *tag, const char *type)
{
	if ((p = soap_in_xs__union(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xs__list::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__QName(soap, &this->xs__list::itemType);
	this->xs__list::restriction = NULL;
	soap_default_std__vectorTemplateOfxs__simpleType(soap, &this->xs__list::simpleType);
	this->xs__list::itemTypeRef = NULL;
}

void xs__list::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToxs__restriction(soap, &this->xs__list::restriction);
	soap_serialize_std__vectorTemplateOfxs__simpleType(soap, &this->xs__list::simpleType);
	/* non-serializable itemTypeRef skipped */
#endif
}

int xs__list::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xs__list(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xs__list(struct soap *soap, const char *tag, int id, const xs__list *a, const char *type)
{
	if (((xs__list*)a)->itemType)
		soap_set_attr(soap, "itemType", soap_xsd__QName2s(soap, ((xs__list*)a)->itemType), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xs__list), type))
		return soap->error;
	if (soap_out_PointerToxs__restriction(soap, "xs:restriction", -1, &a->xs__list::restriction, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxs__simpleType(soap, "xs:simpleType", -1, &a->xs__list::simpleType, ""))
		return soap->error;
	/* non-serializable itemTypeRef skipped */
	return soap_element_end_out(soap, tag);
}

void *xs__list::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xs__list(soap, tag, this, type);
}

SOAP_FMAC3 xs__list * SOAP_FMAC4 soap_in_xs__list(struct soap *soap, const char *tag, xs__list *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (xs__list *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xs__list, sizeof(xs__list), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_xs__list)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (xs__list *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__QName(soap, soap_attr_value(soap, "itemType", 2, 0), &((xs__list*)a)->itemType))
		return NULL;
	size_t soap_flag_restriction1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_restriction1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxs__restriction(soap, "xs:restriction", &a->xs__list::restriction, "xs:restriction"))
				{	soap_flag_restriction1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxs__simpleType(soap, "xs:simpleType", &a->xs__list::simpleType, "xs:simpleType"))
					continue;
			}
			/* non-serializable itemTypeRef skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (xs__list *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xs__list, SOAP_TYPE_xs__list, sizeof(xs__list), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 xs__list * SOAP_FMAC2 wsdl_instantiate_xs__list(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_xs__list(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xs__list *p;
	size_t k = sizeof(xs__list);
	if (n < 0)
	{	p = SOAP_NEW(xs__list);
	}
	else
	{	p = SOAP_NEW_ARRAY(xs__list, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xs__list location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_xs__list, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int xs__list::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xs__list(soap, tag ? tag : "xs:list", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xs__list::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xs__list(soap, this, tag, type);
}

SOAP_FMAC3 xs__list * SOAP_FMAC4 soap_get_xs__list(struct soap *soap, xs__list *p, const char *tag, const char *type)
{
	if ((p = soap_in_xs__list(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xs__group::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__NCName(soap, &this->xs__group::name);
	soap_default_xsd__QName(soap, &this->xs__group::ref);
	soap_default_xsd__token(soap, &this->xs__group::minOccurs);
	soap_default_xsd__token(soap, &this->xs__group::maxOccurs);
	this->xs__group::annotation = NULL;
	this->xs__group::all = NULL;
	this->xs__group::choice = NULL;
	this->xs__group::sequence = NULL;
	this->xs__group::schemaRef = NULL;
	this->xs__group::groupRef = NULL;
}

void xs__group::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToxs__annotation(soap, &this->xs__group::annotation);
	soap_serialize_PointerToxs__all(soap, &this->xs__group::all);
	soap_serialize_PointerToxs__seqchoice(soap, &this->xs__group::choice);
	soap_serialize_PointerToxs__seqchoice(soap, &this->xs__group::sequence);
	/* non-serializable schemaRef skipped */
	/* non-serializable groupRef skipped */
#endif
}

int xs__group::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xs__group(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xs__group(struct soap *soap, const char *tag, int id, const xs__group *a, const char *type)
{
	if (((xs__group*)a)->name)
		soap_set_attr(soap, "name", soap_xsd__NCName2s(soap, ((xs__group*)a)->name), 1);
	if (((xs__group*)a)->ref)
		soap_set_attr(soap, "ref", soap_xsd__QName2s(soap, ((xs__group*)a)->ref), 1);
	if (((xs__group*)a)->minOccurs)
		soap_set_attr(soap, "minOccurs", soap_xsd__token2s(soap, ((xs__group*)a)->minOccurs), 1);
	if (((xs__group*)a)->maxOccurs)
		soap_set_attr(soap, "maxOccurs", soap_xsd__token2s(soap, ((xs__group*)a)->maxOccurs), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xs__group), type))
		return soap->error;
	if (soap_out_PointerToxs__annotation(soap, "xs:annotation", -1, &a->xs__group::annotation, ""))
		return soap->error;
	if (soap_out_PointerToxs__all(soap, "xs:all", -1, &a->xs__group::all, ""))
		return soap->error;
	if (soap_out_PointerToxs__seqchoice(soap, "xs:choice", -1, &a->xs__group::choice, ""))
		return soap->error;
	if (soap_out_PointerToxs__seqchoice(soap, "xs:sequence", -1, &a->xs__group::sequence, ""))
		return soap->error;
	/* non-serializable schemaRef skipped */
	/* non-serializable groupRef skipped */
	return soap_element_end_out(soap, tag);
}

void *xs__group::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xs__group(soap, tag, this, type);
}

SOAP_FMAC3 xs__group * SOAP_FMAC4 soap_in_xs__group(struct soap *soap, const char *tag, xs__group *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (xs__group *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xs__group, sizeof(xs__group), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_xs__group)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (xs__group *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__NCName(soap, soap_attr_value(soap, "name", 5, 0), &((xs__group*)a)->name))
		return NULL;
	if (soap_s2xsd__QName(soap, soap_attr_value(soap, "ref", 2, 0), &((xs__group*)a)->ref))
		return NULL;
	if (soap_s2xsd__token(soap, soap_attr_value(soap, "minOccurs", 5, 0), &((xs__group*)a)->minOccurs))
		return NULL;
	if (soap_s2xsd__token(soap, soap_attr_value(soap, "maxOccurs", 5, 0), &((xs__group*)a)->maxOccurs))
		return NULL;
	size_t soap_flag_annotation1 = 1;
	size_t soap_flag_all1 = 1;
	size_t soap_flag_choice1 = 1;
	size_t soap_flag_sequence1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_annotation1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxs__annotation(soap, "xs:annotation", &a->xs__group::annotation, "xs:annotation"))
				{	soap_flag_annotation1--;
					continue;
				}
			}
			if (soap_flag_all1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxs__all(soap, "xs:all", &a->xs__group::all, "xs:all"))
				{	soap_flag_all1--;
					continue;
				}
			}
			if (soap_flag_choice1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxs__seqchoice(soap, "xs:choice", &a->xs__group::choice, "xs:seqchoice"))
				{	soap_flag_choice1--;
					continue;
				}
			}
			if (soap_flag_sequence1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxs__seqchoice(soap, "xs:sequence", &a->xs__group::sequence, "xs:seqchoice"))
				{	soap_flag_sequence1--;
					continue;
				}
			}
			/* non-serializable schemaRef skipped */
			/* non-serializable groupRef skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (xs__group *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xs__group, SOAP_TYPE_xs__group, sizeof(xs__group), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 xs__group * SOAP_FMAC2 wsdl_instantiate_xs__group(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_xs__group(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xs__group *p;
	size_t k = sizeof(xs__group);
	if (n < 0)
	{	p = SOAP_NEW(xs__group);
	}
	else
	{	p = SOAP_NEW_ARRAY(xs__group, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xs__group location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_xs__group, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int xs__group::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xs__group(soap, tag ? tag : "xs:group", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xs__group::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xs__group(soap, this, tag, type);
}

SOAP_FMAC3 xs__group * SOAP_FMAC4 soap_get_xs__group(struct soap *soap, xs__group *p, const char *tag, const char *type)
{
	if ((p = soap_in_xs__group(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xs__seqchoice::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__token(soap, &this->xs__seqchoice::minOccurs);
	soap_default_xsd__token(soap, &this->xs__seqchoice::maxOccurs);
	this->xs__seqchoice::annotation = NULL;
	soap_default_std__vectorTemplateOfxs__contents(soap, &this->xs__seqchoice::__contents);
	this->xs__seqchoice::schemaRef = NULL;
}

void xs__seqchoice::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToxs__annotation(soap, &this->xs__seqchoice::annotation);
	soap_serialize_std__vectorTemplateOfxs__contents(soap, &this->xs__seqchoice::__contents);
	/* non-serializable schemaRef skipped */
#endif
}

int xs__seqchoice::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xs__seqchoice(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xs__seqchoice(struct soap *soap, const char *tag, int id, const xs__seqchoice *a, const char *type)
{
	if (((xs__seqchoice*)a)->minOccurs)
		soap_set_attr(soap, "minOccurs", soap_xsd__token2s(soap, ((xs__seqchoice*)a)->minOccurs), 1);
	if (((xs__seqchoice*)a)->maxOccurs)
		soap_set_attr(soap, "maxOccurs", soap_xsd__token2s(soap, ((xs__seqchoice*)a)->maxOccurs), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xs__seqchoice), type))
		return soap->error;
	if (soap_out_PointerToxs__annotation(soap, "xs:annotation", -1, &a->xs__seqchoice::annotation, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxs__contents(soap, "-contents", -1, &a->xs__seqchoice::__contents, ""))
		return soap->error;
	/* non-serializable schemaRef skipped */
	return soap_element_end_out(soap, tag);
}

void *xs__seqchoice::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xs__seqchoice(soap, tag, this, type);
}

SOAP_FMAC3 xs__seqchoice * SOAP_FMAC4 soap_in_xs__seqchoice(struct soap *soap, const char *tag, xs__seqchoice *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (xs__seqchoice *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xs__seqchoice, sizeof(xs__seqchoice), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_xs__seqchoice)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (xs__seqchoice *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__token(soap, soap_attr_value(soap, "minOccurs", 5, 0), &((xs__seqchoice*)a)->minOccurs))
		return NULL;
	if (soap_s2xsd__token(soap, soap_attr_value(soap, "maxOccurs", 5, 0), &((xs__seqchoice*)a)->maxOccurs))
		return NULL;
	size_t soap_flag_annotation1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_annotation1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxs__annotation(soap, "xs:annotation", &a->xs__seqchoice::annotation, "xs:annotation"))
				{	soap_flag_annotation1--;
					continue;
				}
			}
			/* non-serializable schemaRef skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxs__contents(soap, "-contents", &a->xs__seqchoice::__contents, "xs:contents"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (xs__seqchoice *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xs__seqchoice, SOAP_TYPE_xs__seqchoice, sizeof(xs__seqchoice), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 xs__seqchoice * SOAP_FMAC2 wsdl_instantiate_xs__seqchoice(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_xs__seqchoice(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xs__seqchoice *p;
	size_t k = sizeof(xs__seqchoice);
	if (n < 0)
	{	p = SOAP_NEW(xs__seqchoice);
	}
	else
	{	p = SOAP_NEW_ARRAY(xs__seqchoice, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xs__seqchoice location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_xs__seqchoice, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int xs__seqchoice::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xs__seqchoice(soap, tag ? tag : "xs:seqchoice", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xs__seqchoice::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xs__seqchoice(soap, this, tag, type);
}

SOAP_FMAC3 xs__seqchoice * SOAP_FMAC4 soap_get_xs__seqchoice(struct soap *soap, xs__seqchoice *p, const char *tag, const char *type)
{
	if ((p = soap_in_xs__seqchoice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xs__restriction::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__QName(soap, &this->xs__restriction::base);
	this->xs__restriction::simpleType = NULL;
	this->xs__restriction::attributeGroup = NULL;
	this->xs__restriction::group = NULL;
	this->xs__restriction::all = NULL;
	this->xs__restriction::choice = NULL;
	this->xs__restriction::sequence = NULL;
	soap_default_std__vectorTemplateOfxs__attribute(soap, &this->xs__restriction::attribute);
	this->xs__restriction::anyAttribute = NULL;
	soap_default_std__vectorTemplateOfxs__enumeration(soap, &this->xs__restriction::enumeration);
	soap_default_std__vectorTemplateOfxs__pattern(soap, &this->xs__restriction::pattern);
	this->xs__restriction::whiteSpace = NULL;
	this->xs__restriction::length = NULL;
	this->xs__restriction::minLength = NULL;
	this->xs__restriction::maxLength = NULL;
	this->xs__restriction::precision = NULL;
	this->xs__restriction::scale = NULL;
	this->xs__restriction::totalDigits = NULL;
	this->xs__restriction::fractionDigits = NULL;
	this->xs__restriction::minInclusive = NULL;
	this->xs__restriction::maxInclusive = NULL;
	this->xs__restriction::minExclusive = NULL;
	this->xs__restriction::maxExclusive = NULL;
	this->xs__restriction::annotation = NULL;
	soap_default_std__vectorTemplateOfxs__assert(soap, &this->xs__restriction::assert);
	this->xs__restriction::assertion = NULL;
	this->xs__restriction::simpleTypeRef = NULL;
	this->xs__restriction::complexTypeRef = NULL;
}

void xs__restriction::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToxs__simpleType(soap, &this->xs__restriction::simpleType);
	soap_serialize_PointerToxs__attributeGroup(soap, &this->xs__restriction::attributeGroup);
	soap_serialize_PointerToxs__group(soap, &this->xs__restriction::group);
	soap_serialize_PointerToxs__all(soap, &this->xs__restriction::all);
	soap_serialize_PointerToxs__seqchoice(soap, &this->xs__restriction::choice);
	soap_serialize_PointerToxs__seqchoice(soap, &this->xs__restriction::sequence);
	soap_serialize_std__vectorTemplateOfxs__attribute(soap, &this->xs__restriction::attribute);
	soap_serialize_PointerToxs__anyAttribute(soap, &this->xs__restriction::anyAttribute);
	soap_serialize_std__vectorTemplateOfxs__enumeration(soap, &this->xs__restriction::enumeration);
	soap_serialize_std__vectorTemplateOfxs__pattern(soap, &this->xs__restriction::pattern);
	soap_serialize_PointerToxs__whiteSpace(soap, &this->xs__restriction::whiteSpace);
	soap_serialize_PointerToxs__length(soap, &this->xs__restriction::length);
	soap_serialize_PointerToxs__length(soap, &this->xs__restriction::minLength);
	soap_serialize_PointerToxs__length(soap, &this->xs__restriction::maxLength);
	soap_serialize_PointerToxs__length(soap, &this->xs__restriction::precision);
	soap_serialize_PointerToxs__length(soap, &this->xs__restriction::scale);
	soap_serialize_PointerToxs__length(soap, &this->xs__restriction::totalDigits);
	soap_serialize_PointerToxs__length(soap, &this->xs__restriction::fractionDigits);
	soap_serialize_PointerToxs__length(soap, &this->xs__restriction::minInclusive);
	soap_serialize_PointerToxs__length(soap, &this->xs__restriction::maxInclusive);
	soap_serialize_PointerToxs__length(soap, &this->xs__restriction::minExclusive);
	soap_serialize_PointerToxs__length(soap, &this->xs__restriction::maxExclusive);
	soap_serialize_PointerToxs__annotation(soap, &this->xs__restriction::annotation);
	soap_serialize_std__vectorTemplateOfxs__assert(soap, &this->xs__restriction::assert);
	soap_serialize_PointerToxs__assert(soap, &this->xs__restriction::assertion);
	/* non-serializable simpleTypeRef skipped */
	/* non-serializable complexTypeRef skipped */
#endif
}

int xs__restriction::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xs__restriction(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xs__restriction(struct soap *soap, const char *tag, int id, const xs__restriction *a, const char *type)
{
	if (((xs__restriction*)a)->base)
		soap_set_attr(soap, "base", soap_xsd__QName2s(soap, ((xs__restriction*)a)->base), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xs__restriction), type))
		return soap->error;
	if (soap_out_PointerToxs__simpleType(soap, "xs:simpleType", -1, &a->xs__restriction::simpleType, ""))
		return soap->error;
	if (soap_out_PointerToxs__attributeGroup(soap, "xs:attributeGroup", -1, &a->xs__restriction::attributeGroup, ""))
		return soap->error;
	if (soap_out_PointerToxs__group(soap, "xs:group", -1, &a->xs__restriction::group, ""))
		return soap->error;
	if (soap_out_PointerToxs__all(soap, "xs:all", -1, &a->xs__restriction::all, ""))
		return soap->error;
	if (soap_out_PointerToxs__seqchoice(soap, "xs:choice", -1, &a->xs__restriction::choice, ""))
		return soap->error;
	if (soap_out_PointerToxs__seqchoice(soap, "xs:sequence", -1, &a->xs__restriction::sequence, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxs__attribute(soap, "xs:attribute", -1, &a->xs__restriction::attribute, ""))
		return soap->error;
	if (soap_out_PointerToxs__anyAttribute(soap, "xs:anyAttribute", -1, &a->xs__restriction::anyAttribute, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxs__enumeration(soap, "xs:enumeration", -1, &a->xs__restriction::enumeration, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxs__pattern(soap, "xs:pattern", -1, &a->xs__restriction::pattern, ""))
		return soap->error;
	if (soap_out_PointerToxs__whiteSpace(soap, "xs:whiteSpace", -1, &a->xs__restriction::whiteSpace, ""))
		return soap->error;
	if (soap_out_PointerToxs__length(soap, "xs:length", -1, &a->xs__restriction::length, ""))
		return soap->error;
	if (soap_out_PointerToxs__length(soap, "xs:minLength", -1, &a->xs__restriction::minLength, ""))
		return soap->error;
	if (soap_out_PointerToxs__length(soap, "xs:maxLength", -1, &a->xs__restriction::maxLength, ""))
		return soap->error;
	if (soap_out_PointerToxs__length(soap, "xs:precision", -1, &a->xs__restriction::precision, ""))
		return soap->error;
	if (soap_out_PointerToxs__length(soap, "xs:scale", -1, &a->xs__restriction::scale, ""))
		return soap->error;
	if (soap_out_PointerToxs__length(soap, "xs:totalDigits", -1, &a->xs__restriction::totalDigits, ""))
		return soap->error;
	if (soap_out_PointerToxs__length(soap, "xs:fractionDigits", -1, &a->xs__restriction::fractionDigits, ""))
		return soap->error;
	if (soap_out_PointerToxs__length(soap, "xs:minInclusive", -1, &a->xs__restriction::minInclusive, ""))
		return soap->error;
	if (soap_out_PointerToxs__length(soap, "xs:maxInclusive", -1, &a->xs__restriction::maxInclusive, ""))
		return soap->error;
	if (soap_out_PointerToxs__length(soap, "xs:minExclusive", -1, &a->xs__restriction::minExclusive, ""))
		return soap->error;
	if (soap_out_PointerToxs__length(soap, "xs:maxExclusive", -1, &a->xs__restriction::maxExclusive, ""))
		return soap->error;
	if (soap_out_PointerToxs__annotation(soap, "xs:annotation", -1, &a->xs__restriction::annotation, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxs__assert(soap, "xs:assert", -1, &a->xs__restriction::assert, ""))
		return soap->error;
	if (soap_out_PointerToxs__assert(soap, "xs:assertion", -1, &a->xs__restriction::assertion, ""))
		return soap->error;
	/* non-serializable simpleTypeRef skipped */
	/* non-serializable complexTypeRef skipped */
	return soap_element_end_out(soap, tag);
}

void *xs__restriction::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xs__restriction(soap, tag, this, type);
}

SOAP_FMAC3 xs__restriction * SOAP_FMAC4 soap_in_xs__restriction(struct soap *soap, const char *tag, xs__restriction *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (xs__restriction *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xs__restriction, sizeof(xs__restriction), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_xs__restriction)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (xs__restriction *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__QName(soap, soap_attr_value(soap, "base", 2, 0), &((xs__restriction*)a)->base))
		return NULL;
	size_t soap_flag_simpleType1 = 1;
	size_t soap_flag_attributeGroup1 = 1;
	size_t soap_flag_group1 = 1;
	size_t soap_flag_all1 = 1;
	size_t soap_flag_choice1 = 1;
	size_t soap_flag_sequence1 = 1;
	size_t soap_flag_anyAttribute1 = 1;
	size_t soap_flag_whiteSpace1 = 1;
	size_t soap_flag_length1 = 1;
	size_t soap_flag_minLength1 = 1;
	size_t soap_flag_maxLength1 = 1;
	size_t soap_flag_precision1 = 1;
	size_t soap_flag_scale1 = 1;
	size_t soap_flag_totalDigits1 = 1;
	size_t soap_flag_fractionDigits1 = 1;
	size_t soap_flag_minInclusive1 = 1;
	size_t soap_flag_maxInclusive1 = 1;
	size_t soap_flag_minExclusive1 = 1;
	size_t soap_flag_maxExclusive1 = 1;
	size_t soap_flag_annotation1 = 1;
	size_t soap_flag_assertion1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_simpleType1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxs__simpleType(soap, "xs:simpleType", &a->xs__restriction::simpleType, "xs:simpleType"))
				{	soap_flag_simpleType1--;
					continue;
				}
			}
			if (soap_flag_attributeGroup1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxs__attributeGroup(soap, "xs:attributeGroup", &a->xs__restriction::attributeGroup, "xs:attributeGroup"))
				{	soap_flag_attributeGroup1--;
					continue;
				}
			}
			if (soap_flag_group1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxs__group(soap, "xs:group", &a->xs__restriction::group, "xs:group"))
				{	soap_flag_group1--;
					continue;
				}
			}
			if (soap_flag_all1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxs__all(soap, "xs:all", &a->xs__restriction::all, "xs:all"))
				{	soap_flag_all1--;
					continue;
				}
			}
			if (soap_flag_choice1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxs__seqchoice(soap, "xs:choice", &a->xs__restriction::choice, "xs:seqchoice"))
				{	soap_flag_choice1--;
					continue;
				}
			}
			if (soap_flag_sequence1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxs__seqchoice(soap, "xs:sequence", &a->xs__restriction::sequence, "xs:seqchoice"))
				{	soap_flag_sequence1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxs__attribute(soap, "xs:attribute", &a->xs__restriction::attribute, "xs:attribute"))
					continue;
			}
			if (soap_flag_anyAttribute1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxs__anyAttribute(soap, "xs:anyAttribute", &a->xs__restriction::anyAttribute, "xs:anyAttribute"))
				{	soap_flag_anyAttribute1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxs__enumeration(soap, "xs:enumeration", &a->xs__restriction::enumeration, "xs:enumeration"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxs__pattern(soap, "xs:pattern", &a->xs__restriction::pattern, "xs:pattern"))
					continue;
			}
			if (soap_flag_whiteSpace1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxs__whiteSpace(soap, "xs:whiteSpace", &a->xs__restriction::whiteSpace, "xs:whiteSpace"))
				{	soap_flag_whiteSpace1--;
					continue;
				}
			}
			if (soap_flag_length1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxs__length(soap, "xs:length", &a->xs__restriction::length, "xs:length"))
				{	soap_flag_length1--;
					continue;
				}
			}
			if (soap_flag_minLength1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxs__length(soap, "xs:minLength", &a->xs__restriction::minLength, "xs:length"))
				{	soap_flag_minLength1--;
					continue;
				}
			}
			if (soap_flag_maxLength1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxs__length(soap, "xs:maxLength", &a->xs__restriction::maxLength, "xs:length"))
				{	soap_flag_maxLength1--;
					continue;
				}
			}
			if (soap_flag_precision1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxs__length(soap, "xs:precision", &a->xs__restriction::precision, "xs:length"))
				{	soap_flag_precision1--;
					continue;
				}
			}
			if (soap_flag_scale1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxs__length(soap, "xs:scale", &a->xs__restriction::scale, "xs:length"))
				{	soap_flag_scale1--;
					continue;
				}
			}
			if (soap_flag_totalDigits1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxs__length(soap, "xs:totalDigits", &a->xs__restriction::totalDigits, "xs:length"))
				{	soap_flag_totalDigits1--;
					continue;
				}
			}
			if (soap_flag_fractionDigits1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxs__length(soap, "xs:fractionDigits", &a->xs__restriction::fractionDigits, "xs:length"))
				{	soap_flag_fractionDigits1--;
					continue;
				}
			}
			if (soap_flag_minInclusive1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxs__length(soap, "xs:minInclusive", &a->xs__restriction::minInclusive, "xs:length"))
				{	soap_flag_minInclusive1--;
					continue;
				}
			}
			if (soap_flag_maxInclusive1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxs__length(soap, "xs:maxInclusive", &a->xs__restriction::maxInclusive, "xs:length"))
				{	soap_flag_maxInclusive1--;
					continue;
				}
			}
			if (soap_flag_minExclusive1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxs__length(soap, "xs:minExclusive", &a->xs__restriction::minExclusive, "xs:length"))
				{	soap_flag_minExclusive1--;
					continue;
				}
			}
			if (soap_flag_maxExclusive1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxs__length(soap, "xs:maxExclusive", &a->xs__restriction::maxExclusive, "xs:length"))
				{	soap_flag_maxExclusive1--;
					continue;
				}
			}
			if (soap_flag_annotation1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxs__annotation(soap, "xs:annotation", &a->xs__restriction::annotation, "xs:annotation"))
				{	soap_flag_annotation1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxs__assert(soap, "xs:assert", &a->xs__restriction::assert, "xs:assert"))
					continue;
			}
			if (soap_flag_assertion1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxs__assert(soap, "xs:assertion", &a->xs__restriction::assertion, "xs:assert"))
				{	soap_flag_assertion1--;
					continue;
				}
			}
			/* non-serializable simpleTypeRef skipped */
			/* non-serializable complexTypeRef skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (xs__restriction *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xs__restriction, SOAP_TYPE_xs__restriction, sizeof(xs__restriction), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 xs__restriction * SOAP_FMAC2 wsdl_instantiate_xs__restriction(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_xs__restriction(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xs__restriction *p;
	size_t k = sizeof(xs__restriction);
	if (n < 0)
	{	p = SOAP_NEW(xs__restriction);
	}
	else
	{	p = SOAP_NEW_ARRAY(xs__restriction, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xs__restriction location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_xs__restriction, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int xs__restriction::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xs__restriction(soap, tag ? tag : "xs:restriction", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xs__restriction::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xs__restriction(soap, this, tag, type);
}

SOAP_FMAC3 xs__restriction * SOAP_FMAC4 soap_get_xs__restriction(struct soap *soap, xs__restriction *p, const char *tag, const char *type)
{
	if ((p = soap_in_xs__restriction(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xs__extension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__QName(soap, &this->xs__extension::base);
	this->xs__extension::group = NULL;
	this->xs__extension::all = NULL;
	this->xs__extension::choice = NULL;
	this->xs__extension::sequence = NULL;
	soap_default_std__vectorTemplateOfxs__attribute(soap, &this->xs__extension::attribute);
	soap_default_std__vectorTemplateOfxs__attributeGroup(soap, &this->xs__extension::attributeGroup);
	this->xs__extension::anyAttribute = NULL;
	this->xs__extension::annotation = NULL;
	soap_default_std__vectorTemplateOfxs__assert(soap, &this->xs__extension::assert);
	this->xs__extension::simpleTypeRef = NULL;
	this->xs__extension::complexTypeRef = NULL;
}

void xs__extension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToxs__group(soap, &this->xs__extension::group);
	soap_serialize_PointerToxs__all(soap, &this->xs__extension::all);
	soap_serialize_PointerToxs__seqchoice(soap, &this->xs__extension::choice);
	soap_serialize_PointerToxs__seqchoice(soap, &this->xs__extension::sequence);
	soap_serialize_std__vectorTemplateOfxs__attribute(soap, &this->xs__extension::attribute);
	soap_serialize_std__vectorTemplateOfxs__attributeGroup(soap, &this->xs__extension::attributeGroup);
	soap_serialize_PointerToxs__anyAttribute(soap, &this->xs__extension::anyAttribute);
	soap_serialize_PointerToxs__annotation(soap, &this->xs__extension::annotation);
	soap_serialize_std__vectorTemplateOfxs__assert(soap, &this->xs__extension::assert);
	/* non-serializable simpleTypeRef skipped */
	/* non-serializable complexTypeRef skipped */
#endif
}

int xs__extension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xs__extension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xs__extension(struct soap *soap, const char *tag, int id, const xs__extension *a, const char *type)
{
	if (((xs__extension*)a)->base)
		soap_set_attr(soap, "base", soap_xsd__QName2s(soap, ((xs__extension*)a)->base), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xs__extension), type))
		return soap->error;
	if (soap_out_PointerToxs__group(soap, "xs:group", -1, &a->xs__extension::group, ""))
		return soap->error;
	if (soap_out_PointerToxs__all(soap, "xs:all", -1, &a->xs__extension::all, ""))
		return soap->error;
	if (soap_out_PointerToxs__seqchoice(soap, "xs:choice", -1, &a->xs__extension::choice, ""))
		return soap->error;
	if (soap_out_PointerToxs__seqchoice(soap, "xs:sequence", -1, &a->xs__extension::sequence, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxs__attribute(soap, "xs:attribute", -1, &a->xs__extension::attribute, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxs__attributeGroup(soap, "xs:attributeGroup", -1, &a->xs__extension::attributeGroup, ""))
		return soap->error;
	if (soap_out_PointerToxs__anyAttribute(soap, "xs:anyAttribute", -1, &a->xs__extension::anyAttribute, ""))
		return soap->error;
	if (soap_out_PointerToxs__annotation(soap, "xs:annotation", -1, &a->xs__extension::annotation, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxs__assert(soap, "xs:assert", -1, &a->xs__extension::assert, ""))
		return soap->error;
	/* non-serializable simpleTypeRef skipped */
	/* non-serializable complexTypeRef skipped */
	return soap_element_end_out(soap, tag);
}

void *xs__extension::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xs__extension(soap, tag, this, type);
}

SOAP_FMAC3 xs__extension * SOAP_FMAC4 soap_in_xs__extension(struct soap *soap, const char *tag, xs__extension *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (xs__extension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xs__extension, sizeof(xs__extension), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_xs__extension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (xs__extension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__QName(soap, soap_attr_value(soap, "base", 2, 0), &((xs__extension*)a)->base))
		return NULL;
	size_t soap_flag_group1 = 1;
	size_t soap_flag_all1 = 1;
	size_t soap_flag_choice1 = 1;
	size_t soap_flag_sequence1 = 1;
	size_t soap_flag_anyAttribute1 = 1;
	size_t soap_flag_annotation1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_group1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxs__group(soap, "xs:group", &a->xs__extension::group, "xs:group"))
				{	soap_flag_group1--;
					continue;
				}
			}
			if (soap_flag_all1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxs__all(soap, "xs:all", &a->xs__extension::all, "xs:all"))
				{	soap_flag_all1--;
					continue;
				}
			}
			if (soap_flag_choice1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxs__seqchoice(soap, "xs:choice", &a->xs__extension::choice, "xs:seqchoice"))
				{	soap_flag_choice1--;
					continue;
				}
			}
			if (soap_flag_sequence1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxs__seqchoice(soap, "xs:sequence", &a->xs__extension::sequence, "xs:seqchoice"))
				{	soap_flag_sequence1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxs__attribute(soap, "xs:attribute", &a->xs__extension::attribute, "xs:attribute"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxs__attributeGroup(soap, "xs:attributeGroup", &a->xs__extension::attributeGroup, "xs:attributeGroup"))
					continue;
			}
			if (soap_flag_anyAttribute1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxs__anyAttribute(soap, "xs:anyAttribute", &a->xs__extension::anyAttribute, "xs:anyAttribute"))
				{	soap_flag_anyAttribute1--;
					continue;
				}
			}
			if (soap_flag_annotation1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxs__annotation(soap, "xs:annotation", &a->xs__extension::annotation, "xs:annotation"))
				{	soap_flag_annotation1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxs__assert(soap, "xs:assert", &a->xs__extension::assert, "xs:assert"))
					continue;
			}
			/* non-serializable simpleTypeRef skipped */
			/* non-serializable complexTypeRef skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (xs__extension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xs__extension, SOAP_TYPE_xs__extension, sizeof(xs__extension), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 xs__extension * SOAP_FMAC2 wsdl_instantiate_xs__extension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_xs__extension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xs__extension *p;
	size_t k = sizeof(xs__extension);
	if (n < 0)
	{	p = SOAP_NEW(xs__extension);
	}
	else
	{	p = SOAP_NEW_ARRAY(xs__extension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xs__extension location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_xs__extension, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int xs__extension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xs__extension(soap, tag ? tag : "xs:extension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xs__extension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xs__extension(soap, this, tag, type);
}

SOAP_FMAC3 xs__extension * SOAP_FMAC4 soap_get_xs__extension(struct soap *soap, xs__extension *p, const char *tag, const char *type)
{
	if ((p = soap_in_xs__extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xs__complexType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__NMTOKEN(soap, &this->xs__complexType::name);
	this->xs__complexType::abstract = (bool)0;
	this->xs__complexType::mixed = (bool)0;
	this->xs__complexType::defaultAttributesApply = (bool)1;
	soap_default_xsd__string(soap, &this->xs__complexType::vc__minVersion);
	soap_default_xsd__string(soap, &this->xs__complexType::vc__maxVersion);
	this->xs__complexType::annotation = NULL;
	this->xs__complexType::simpleContent = NULL;
	this->xs__complexType::complexContent = NULL;
	this->xs__complexType::all = NULL;
	this->xs__complexType::choice = NULL;
	this->xs__complexType::sequence = NULL;
	this->xs__complexType::group = NULL;
	this->xs__complexType::any = NULL;
	soap_default_std__vectorTemplateOfxs__attribute(soap, &this->xs__complexType::attribute);
	soap_default_std__vectorTemplateOfxs__attributeGroup(soap, &this->xs__complexType::attributeGroup);
	this->xs__complexType::anyAttribute = NULL;
	soap_default_std__vectorTemplateOfxs__assert(soap, &this->xs__complexType::assert);
	this->xs__complexType::schemaRef = NULL;
	soap_default_int(soap, &this->xs__complexType::level);
}

void xs__complexType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToxs__annotation(soap, &this->xs__complexType::annotation);
	soap_serialize_PointerToxs__simpleContent(soap, &this->xs__complexType::simpleContent);
	soap_serialize_PointerToxs__complexContent(soap, &this->xs__complexType::complexContent);
	soap_serialize_PointerToxs__all(soap, &this->xs__complexType::all);
	soap_serialize_PointerToxs__seqchoice(soap, &this->xs__complexType::choice);
	soap_serialize_PointerToxs__seqchoice(soap, &this->xs__complexType::sequence);
	soap_serialize_PointerToxs__group(soap, &this->xs__complexType::group);
	soap_serialize_PointerToxs__any(soap, &this->xs__complexType::any);
	soap_serialize_std__vectorTemplateOfxs__attribute(soap, &this->xs__complexType::attribute);
	soap_serialize_std__vectorTemplateOfxs__attributeGroup(soap, &this->xs__complexType::attributeGroup);
	soap_serialize_PointerToxs__anyAttribute(soap, &this->xs__complexType::anyAttribute);
	soap_serialize_std__vectorTemplateOfxs__assert(soap, &this->xs__complexType::assert);
	/* non-serializable schemaRef skipped */
	/* non-serializable level skipped */
#endif
}

int xs__complexType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xs__complexType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xs__complexType(struct soap *soap, const char *tag, int id, const xs__complexType *a, const char *type)
{
	if (((xs__complexType*)a)->name)
		soap_set_attr(soap, "name", soap_xsd__NMTOKEN2s(soap, ((xs__complexType*)a)->name), 1);
	soap_set_attr(soap, "abstract", soap_xsd__boolean2s(soap, ((xs__complexType*)a)->abstract), 1);
	soap_set_attr(soap, "mixed", soap_xsd__boolean2s(soap, ((xs__complexType*)a)->mixed), 1);
	soap_set_attr(soap, "defaultAttributesApply", soap_xsd__boolean2s(soap, ((xs__complexType*)a)->defaultAttributesApply), 1);
	if (((xs__complexType*)a)->vc__minVersion)
		soap_set_attr(soap, "vc:minVersion", soap_xsd__string2s(soap, ((xs__complexType*)a)->vc__minVersion), 1);
	if (((xs__complexType*)a)->vc__maxVersion)
		soap_set_attr(soap, "vc:maxVersion", soap_xsd__string2s(soap, ((xs__complexType*)a)->vc__maxVersion), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xs__complexType), type))
		return soap->error;
	if (soap_out_PointerToxs__annotation(soap, "xs:annotation", -1, &a->xs__complexType::annotation, ""))
		return soap->error;
	if (soap_out_PointerToxs__simpleContent(soap, "xs:simpleContent", -1, &a->xs__complexType::simpleContent, ""))
		return soap->error;
	if (soap_out_PointerToxs__complexContent(soap, "xs:complexContent", -1, &a->xs__complexType::complexContent, ""))
		return soap->error;
	if (soap_out_PointerToxs__all(soap, "xs:all", -1, &a->xs__complexType::all, ""))
		return soap->error;
	if (soap_out_PointerToxs__seqchoice(soap, "xs:choice", -1, &a->xs__complexType::choice, ""))
		return soap->error;
	if (soap_out_PointerToxs__seqchoice(soap, "xs:sequence", -1, &a->xs__complexType::sequence, ""))
		return soap->error;
	if (soap_out_PointerToxs__group(soap, "xs:group", -1, &a->xs__complexType::group, ""))
		return soap->error;
	if (soap_out_PointerToxs__any(soap, "xs:any", -1, &a->xs__complexType::any, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxs__attribute(soap, "xs:attribute", -1, &a->xs__complexType::attribute, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxs__attributeGroup(soap, "xs:attributeGroup", -1, &a->xs__complexType::attributeGroup, ""))
		return soap->error;
	if (soap_out_PointerToxs__anyAttribute(soap, "xs:anyAttribute", -1, &a->xs__complexType::anyAttribute, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxs__assert(soap, "xs:assert", -1, &a->xs__complexType::assert, ""))
		return soap->error;
	/* non-serializable schemaRef skipped */
	/* non-serializable level skipped */
	return soap_element_end_out(soap, tag);
}

void *xs__complexType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xs__complexType(soap, tag, this, type);
}

SOAP_FMAC3 xs__complexType * SOAP_FMAC4 soap_in_xs__complexType(struct soap *soap, const char *tag, xs__complexType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (xs__complexType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xs__complexType, sizeof(xs__complexType), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_xs__complexType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (xs__complexType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__NMTOKEN(soap, soap_attr_value(soap, "name", 5, 0), &((xs__complexType*)a)->name))
		return NULL;
	if (soap_s2xsd__boolean(soap, soap_attr_value(soap, "abstract", 5, 0), &((xs__complexType*)a)->abstract))
		return NULL;
	if (soap_s2xsd__boolean(soap, soap_attr_value(soap, "mixed", 5, 0), &((xs__complexType*)a)->mixed))
		return NULL;
	if (soap_s2xsd__boolean(soap, soap_attr_value(soap, "defaultAttributesApply", 5, 0), &((xs__complexType*)a)->defaultAttributesApply))
		return NULL;
	if (soap_s2xsd__string(soap, soap_attr_value(soap, "vc:minVersion", 1, 0), &((xs__complexType*)a)->vc__minVersion))
		return NULL;
	if (soap_s2xsd__string(soap, soap_attr_value(soap, "vc:maxVersion", 1, 0), &((xs__complexType*)a)->vc__maxVersion))
		return NULL;
	size_t soap_flag_annotation1 = 1;
	size_t soap_flag_simpleContent1 = 1;
	size_t soap_flag_complexContent1 = 1;
	size_t soap_flag_all1 = 1;
	size_t soap_flag_choice1 = 1;
	size_t soap_flag_sequence1 = 1;
	size_t soap_flag_group1 = 1;
	size_t soap_flag_any1 = 1;
	size_t soap_flag_anyAttribute1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_annotation1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxs__annotation(soap, "xs:annotation", &a->xs__complexType::annotation, "xs:annotation"))
				{	soap_flag_annotation1--;
					continue;
				}
			}
			if (soap_flag_simpleContent1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxs__simpleContent(soap, "xs:simpleContent", &a->xs__complexType::simpleContent, "xs:simpleContent"))
				{	soap_flag_simpleContent1--;
					continue;
				}
			}
			if (soap_flag_complexContent1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxs__complexContent(soap, "xs:complexContent", &a->xs__complexType::complexContent, "xs:complexContent"))
				{	soap_flag_complexContent1--;
					continue;
				}
			}
			if (soap_flag_all1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxs__all(soap, "xs:all", &a->xs__complexType::all, "xs:all"))
				{	soap_flag_all1--;
					continue;
				}
			}
			if (soap_flag_choice1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxs__seqchoice(soap, "xs:choice", &a->xs__complexType::choice, "xs:seqchoice"))
				{	soap_flag_choice1--;
					continue;
				}
			}
			if (soap_flag_sequence1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxs__seqchoice(soap, "xs:sequence", &a->xs__complexType::sequence, "xs:seqchoice"))
				{	soap_flag_sequence1--;
					continue;
				}
			}
			if (soap_flag_group1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxs__group(soap, "xs:group", &a->xs__complexType::group, "xs:group"))
				{	soap_flag_group1--;
					continue;
				}
			}
			if (soap_flag_any1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxs__any(soap, "xs:any", &a->xs__complexType::any, "xs:any"))
				{	soap_flag_any1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxs__attribute(soap, "xs:attribute", &a->xs__complexType::attribute, "xs:attribute"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxs__attributeGroup(soap, "xs:attributeGroup", &a->xs__complexType::attributeGroup, "xs:attributeGroup"))
					continue;
			}
			if (soap_flag_anyAttribute1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxs__anyAttribute(soap, "xs:anyAttribute", &a->xs__complexType::anyAttribute, "xs:anyAttribute"))
				{	soap_flag_anyAttribute1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxs__assert(soap, "xs:assert", &a->xs__complexType::assert, "xs:assert"))
					continue;
			}
			/* non-serializable schemaRef skipped */
			/* non-serializable level skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (xs__complexType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xs__complexType, SOAP_TYPE_xs__complexType, sizeof(xs__complexType), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 xs__complexType * SOAP_FMAC2 wsdl_instantiate_xs__complexType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_xs__complexType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xs__complexType *p;
	size_t k = sizeof(xs__complexType);
	if (n < 0)
	{	p = SOAP_NEW(xs__complexType);
	}
	else
	{	p = SOAP_NEW_ARRAY(xs__complexType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xs__complexType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_xs__complexType, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int xs__complexType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xs__complexType(soap, tag ? tag : "xs:complexType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xs__complexType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xs__complexType(soap, this, tag, type);
}

SOAP_FMAC3 xs__complexType * SOAP_FMAC4 soap_get_xs__complexType(struct soap *soap, xs__complexType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xs__complexType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xs__simpleType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__NMTOKEN(soap, &this->xs__simpleType::name);
	soap_default_xsd__string(soap, &this->xs__simpleType::vc__minVersion);
	soap_default_xsd__string(soap, &this->xs__simpleType::vc__maxVersion);
	this->xs__simpleType::annotation = NULL;
	this->xs__simpleType::restriction = NULL;
	this->xs__simpleType::list = NULL;
	this->xs__simpleType::union_ = NULL;
	this->xs__simpleType::schemaRef = NULL;
	soap_default_int(soap, &this->xs__simpleType::level);
}

void xs__simpleType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToxs__annotation(soap, &this->xs__simpleType::annotation);
	soap_serialize_PointerToxs__restriction(soap, &this->xs__simpleType::restriction);
	soap_serialize_PointerToxs__list(soap, &this->xs__simpleType::list);
	soap_serialize_PointerToxs__union(soap, &this->xs__simpleType::union_);
	/* non-serializable schemaRef skipped */
	/* non-serializable level skipped */
#endif
}

int xs__simpleType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xs__simpleType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xs__simpleType(struct soap *soap, const char *tag, int id, const xs__simpleType *a, const char *type)
{
	if (((xs__simpleType*)a)->name)
		soap_set_attr(soap, "name", soap_xsd__NMTOKEN2s(soap, ((xs__simpleType*)a)->name), 1);
	if (((xs__simpleType*)a)->vc__minVersion)
		soap_set_attr(soap, "vc:minVersion", soap_xsd__string2s(soap, ((xs__simpleType*)a)->vc__minVersion), 1);
	if (((xs__simpleType*)a)->vc__maxVersion)
		soap_set_attr(soap, "vc:maxVersion", soap_xsd__string2s(soap, ((xs__simpleType*)a)->vc__maxVersion), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xs__simpleType), type))
		return soap->error;
	if (soap_out_PointerToxs__annotation(soap, "xs:annotation", -1, &a->xs__simpleType::annotation, ""))
		return soap->error;
	if (soap_out_PointerToxs__restriction(soap, "xs:restriction", -1, &a->xs__simpleType::restriction, ""))
		return soap->error;
	if (soap_out_PointerToxs__list(soap, "xs:list", -1, &a->xs__simpleType::list, ""))
		return soap->error;
	if (soap_out_PointerToxs__union(soap, "xs:union", -1, &a->xs__simpleType::union_, ""))
		return soap->error;
	/* non-serializable schemaRef skipped */
	/* non-serializable level skipped */
	return soap_element_end_out(soap, tag);
}

void *xs__simpleType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xs__simpleType(soap, tag, this, type);
}

SOAP_FMAC3 xs__simpleType * SOAP_FMAC4 soap_in_xs__simpleType(struct soap *soap, const char *tag, xs__simpleType *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (xs__simpleType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xs__simpleType, sizeof(xs__simpleType), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_xs__simpleType)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (xs__simpleType *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__NMTOKEN(soap, soap_attr_value(soap, "name", 5, 0), &((xs__simpleType*)a)->name))
		return NULL;
	if (soap_s2xsd__string(soap, soap_attr_value(soap, "vc:minVersion", 1, 0), &((xs__simpleType*)a)->vc__minVersion))
		return NULL;
	if (soap_s2xsd__string(soap, soap_attr_value(soap, "vc:maxVersion", 1, 0), &((xs__simpleType*)a)->vc__maxVersion))
		return NULL;
	size_t soap_flag_annotation1 = 1;
	size_t soap_flag_restriction1 = 1;
	size_t soap_flag_list1 = 1;
	size_t soap_flag_union_1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_annotation1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxs__annotation(soap, "xs:annotation", &a->xs__simpleType::annotation, "xs:annotation"))
				{	soap_flag_annotation1--;
					continue;
				}
			}
			if (soap_flag_restriction1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxs__restriction(soap, "xs:restriction", &a->xs__simpleType::restriction, "xs:restriction"))
				{	soap_flag_restriction1--;
					continue;
				}
			}
			if (soap_flag_list1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxs__list(soap, "xs:list", &a->xs__simpleType::list, "xs:list"))
				{	soap_flag_list1--;
					continue;
				}
			}
			if (soap_flag_union_1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxs__union(soap, "xs:union", &a->xs__simpleType::union_, "xs:union"))
				{	soap_flag_union_1--;
					continue;
				}
			}
			/* non-serializable schemaRef skipped */
			/* non-serializable level skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (xs__simpleType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xs__simpleType, SOAP_TYPE_xs__simpleType, sizeof(xs__simpleType), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 xs__simpleType * SOAP_FMAC2 wsdl_instantiate_xs__simpleType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_xs__simpleType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xs__simpleType *p;
	size_t k = sizeof(xs__simpleType);
	if (n < 0)
	{	p = SOAP_NEW(xs__simpleType);
	}
	else
	{	p = SOAP_NEW_ARRAY(xs__simpleType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xs__simpleType location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_xs__simpleType, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int xs__simpleType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xs__simpleType(soap, tag ? tag : "xs:simpleType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xs__simpleType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xs__simpleType(soap, this, tag, type);
}

SOAP_FMAC3 xs__simpleType * SOAP_FMAC4 soap_get_xs__simpleType(struct soap *soap, xs__simpleType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xs__simpleType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xs__schema::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xs__schema::targetNamespace = (char*)"";
	soap_default_xsd__string(soap, &this->xs__schema::version);
	soap_default_xsd__NCName(soap, &this->xs__schema::defaultAttributes);
	this->xs__schema::attributeFormDefault = (enum xs__formChoice)0;
	this->xs__schema::elementFormDefault = (enum xs__formChoice)0;
	this->xs__schema::annotation = NULL;
	soap_default_std__vectorTemplateOfxs__include(soap, &this->xs__schema::include);
	soap_default_std__vectorTemplateOfxs__override(soap, &this->xs__schema::override_);
	soap_default_std__vectorTemplateOfxs__redefine(soap, &this->xs__schema::redefine);
	soap_default_std__vectorTemplateOfxs__import(soap, &this->xs__schema::import);
	soap_default_std__vectorTemplateOfxs__attribute(soap, &this->xs__schema::attribute);
	soap_default_std__vectorTemplateOfxs__element(soap, &this->xs__schema::element);
	soap_default_std__vectorTemplateOfxs__group(soap, &this->xs__schema::group);
	soap_default_std__vectorTemplateOfxs__attributeGroup(soap, &this->xs__schema::attributeGroup);
	soap_default_std__vectorTemplateOfxs__simpleType(soap, &this->xs__schema::simpleType);
	soap_default_std__vectorTemplateOfxs__complexType(soap, &this->xs__schema::complexType);
	/* transient soap skipped */
	this->xs__schema::attributeGroupRef = NULL;
	soap_default_bool(soap, &this->xs__schema::updated);
	soap_default_string(soap, &this->xs__schema::location);
	soap_default_int(soap, &this->xs__schema::redirs);
	/* transient builtinTypeSet skipped */
	/* transient builtinElementSet skipped */
	/* transient builtinAttributeSet skipped */
}

void xs__schema::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToxs__annotation(soap, &this->xs__schema::annotation);
	soap_serialize_std__vectorTemplateOfxs__include(soap, &this->xs__schema::include);
	soap_serialize_std__vectorTemplateOfxs__override(soap, &this->xs__schema::override_);
	soap_serialize_std__vectorTemplateOfxs__redefine(soap, &this->xs__schema::redefine);
	soap_serialize_std__vectorTemplateOfxs__import(soap, &this->xs__schema::import);
	soap_serialize_std__vectorTemplateOfxs__attribute(soap, &this->xs__schema::attribute);
	soap_serialize_std__vectorTemplateOfxs__element(soap, &this->xs__schema::element);
	soap_serialize_std__vectorTemplateOfxs__group(soap, &this->xs__schema::group);
	soap_serialize_std__vectorTemplateOfxs__attributeGroup(soap, &this->xs__schema::attributeGroup);
	soap_serialize_std__vectorTemplateOfxs__simpleType(soap, &this->xs__schema::simpleType);
	soap_serialize_std__vectorTemplateOfxs__complexType(soap, &this->xs__schema::complexType);
	/* non-serializable attributeGroupRef skipped */
	/* non-serializable updated skipped */
	/* non-serializable location skipped */
	/* non-serializable redirs skipped */
	/* non-serializable builtinTypeSet skipped */
	/* non-serializable builtinElementSet skipped */
	/* non-serializable builtinAttributeSet skipped */
#endif
}

int xs__schema::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xs__schema(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xs__schema(struct soap *soap, const char *tag, int id, const xs__schema *a, const char *type)
{
	if (((xs__schema*)a)->targetNamespace)
		soap_set_attr(soap, "targetNamespace", soap_xsd__anyURI2s(soap, ((xs__schema*)a)->targetNamespace), 1);
	if (((xs__schema*)a)->version)
		soap_set_attr(soap, "version", soap_xsd__string2s(soap, ((xs__schema*)a)->version), 1);
	if (((xs__schema*)a)->defaultAttributes)
		soap_set_attr(soap, "defaultAttributes", soap_xsd__NCName2s(soap, ((xs__schema*)a)->defaultAttributes), 1);
	soap_set_attr(soap, "attributeFormDefault", soap_xs__formChoice2s(soap, ((xs__schema*)a)->attributeFormDefault), 1);
	soap_set_attr(soap, "elementFormDefault", soap_xs__formChoice2s(soap, ((xs__schema*)a)->elementFormDefault), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xs__schema), type))
		return soap->error;
	if (soap_out_PointerToxs__annotation(soap, "xs:annotation", -1, &a->xs__schema::annotation, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxs__include(soap, "xs:include", -1, &a->xs__schema::include, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxs__override(soap, "xs:override", -1, &a->xs__schema::override_, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxs__redefine(soap, "xs:redefine", -1, &a->xs__schema::redefine, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxs__import(soap, "xs:import", -1, &a->xs__schema::import, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxs__attribute(soap, "xs:attribute", -1, &a->xs__schema::attribute, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxs__element(soap, "xs:element", -1, &a->xs__schema::element, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxs__group(soap, "xs:group", -1, &a->xs__schema::group, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxs__attributeGroup(soap, "xs:attributeGroup", -1, &a->xs__schema::attributeGroup, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxs__simpleType(soap, "xs:simpleType", -1, &a->xs__schema::simpleType, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxs__complexType(soap, "xs:complexType", -1, &a->xs__schema::complexType, ""))
		return soap->error;
	/* non-serializable attributeGroupRef skipped */
	/* non-serializable updated skipped */
	/* non-serializable location skipped */
	/* non-serializable redirs skipped */
	/* non-serializable builtinTypeSet skipped */
	/* non-serializable builtinElementSet skipped */
	/* non-serializable builtinAttributeSet skipped */
	return soap_element_end_out(soap, tag);
}

void *xs__schema::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xs__schema(soap, tag, this, type);
}

SOAP_FMAC3 xs__schema * SOAP_FMAC4 soap_in_xs__schema(struct soap *soap, const char *tag, xs__schema *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (xs__schema *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xs__schema, sizeof(xs__schema), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_xs__schema)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (xs__schema *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "targetNamespace", 4, 0), &((xs__schema*)a)->targetNamespace))
		return NULL;
	if (soap_s2xsd__string(soap, soap_attr_value(soap, "version", 1, 0), &((xs__schema*)a)->version))
		return NULL;
	if (soap_s2xsd__NCName(soap, soap_attr_value(soap, "defaultAttributes", 5, 0), &((xs__schema*)a)->defaultAttributes))
		return NULL;
	if (soap_s2xs__formChoice(soap, soap_attr_value(soap, "attributeFormDefault", 5, 0), &((xs__schema*)a)->attributeFormDefault))
		return NULL;
	if (soap_s2xs__formChoice(soap, soap_attr_value(soap, "elementFormDefault", 5, 0), &((xs__schema*)a)->elementFormDefault))
		return NULL;
	size_t soap_flag_annotation1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_annotation1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxs__annotation(soap, "xs:annotation", &a->xs__schema::annotation, "xs:annotation"))
				{	soap_flag_annotation1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxs__include(soap, "xs:include", &a->xs__schema::include, "xs:include"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxs__override(soap, "xs:override", &a->xs__schema::override_, "xs:override"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxs__redefine(soap, "xs:redefine", &a->xs__schema::redefine, "xs:redefine"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxs__import(soap, "xs:import", &a->xs__schema::import, "xs:import"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxs__attribute(soap, "xs:attribute", &a->xs__schema::attribute, "xs:attribute"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxs__element(soap, "xs:element", &a->xs__schema::element, "xs:element"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxs__group(soap, "xs:group", &a->xs__schema::group, "xs:group"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxs__attributeGroup(soap, "xs:attributeGroup", &a->xs__schema::attributeGroup, "xs:attributeGroup"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxs__simpleType(soap, "xs:simpleType", &a->xs__schema::simpleType, "xs:simpleType"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxs__complexType(soap, "xs:complexType", &a->xs__schema::complexType, "xs:complexType"))
					continue;
			}
			/* non-serializable attributeGroupRef skipped */
			/* non-serializable updated skipped */
			/* non-serializable location skipped */
			/* non-serializable redirs skipped */
			/* non-serializable builtinTypeSet skipped */
			/* non-serializable builtinElementSet skipped */
			/* non-serializable builtinAttributeSet skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if (a->get(soap))
			return NULL;
	}
	else
	{	a = (xs__schema *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xs__schema, SOAP_TYPE_xs__schema, sizeof(xs__schema), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 xs__schema * SOAP_FMAC2 wsdl_instantiate_xs__schema(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_xs__schema(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (soap && type && !soap_match_tag(soap, type, "wsdl:types"))
		return wsdl_instantiate_wsdl__types(soap, n, NULL, NULL, size);
	xs__schema *p;
	size_t k = sizeof(xs__schema);
	if (n < 0)
	{	p = SOAP_NEW(xs__schema);
		if (p)
			((xs__schema*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(xs__schema, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((xs__schema*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xs__schema location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_xs__schema, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int xs__schema::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xs__schema(soap, tag ? tag : "xs:schema", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xs__schema::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xs__schema(soap, this, tag, type);
}

SOAP_FMAC3 xs__schema * SOAP_FMAC4 soap_get_xs__schema(struct soap *soap, xs__schema *p, const char *tag, const char *type)
{
	if ((p = soap_in_xs__schema(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsdl__definitions::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__NMTOKEN(soap, &this->wsdl__definitions::name);
	this->wsdl__definitions::targetNamespace = (char*)"";
	soap_default_xsd__NMTOKEN(soap, &this->wsdl__definitions::version);
	soap_default_std__vectorTemplateOfwsdl__import(soap, &this->wsdl__definitions::import);
	soap_default_xsd__string(soap, &this->wsdl__definitions::documentation);
	this->wsdl__definitions::types = NULL;
	soap_default_std__vectorTemplateOfwsdl__message(soap, &this->wsdl__definitions::message);
	soap_default_std__vectorTemplateOfwsdl__portType(soap, &this->wsdl__definitions::portType);
	soap_default_std__vectorTemplateOfwsdl__portType(soap, &this->wsdl__definitions::interface_);
	soap_default_std__vectorTemplateOfwsdl__binding(soap, &this->wsdl__definitions::binding);
	soap_default_std__vectorTemplateOfwsdl__service(soap, &this->wsdl__definitions::service);
	soap_default_xsd__string(soap, &this->wsdl__definitions::wsp__UsingPolicy);
	soap_default_std__vectorTemplateOfwsp__Policy(soap, &this->wsdl__definitions::wsp__Policy_);
	soap_default_std__vectorTemplateOfplnk__tPartnerLinkType(soap, &this->wsdl__definitions::plnk__partnerLinkType);
	soap_default_std__vectorTemplateOfvprop__tProperty(soap, &this->wsdl__definitions::vprop__property);
	soap_default_std__vectorTemplateOfvprop__tPropertyAlias(soap, &this->wsdl__definitions::vprop__propertyAlias);
	soap_default_std__vectorTemplateOfgwsdl__portType(soap, &this->wsdl__definitions::gwsdl__portType_);
	/* transient soap skipped */
	soap_default_bool(soap, &this->wsdl__definitions::soap12);
	soap_default_bool(soap, &this->wsdl__definitions::updated);
	soap_default_string(soap, &this->wsdl__definitions::location);
	soap_default_int(soap, &this->wsdl__definitions::redirs);
	/* transient builtinTypeSet skipped */
	/* transient builtinElementSet skipped */
	/* transient builtinAttributeSet skipped */
	this->wsdl__definitions::appRef = NULL;
}

void wsdl__definitions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfwsdl__import(soap, &this->wsdl__definitions::import);
	soap_serialize_xsd__string(soap, (char*const*)&this->wsdl__definitions::documentation);
	soap_serialize_PointerTowsdl__types(soap, &this->wsdl__definitions::types);
	soap_serialize_std__vectorTemplateOfwsdl__message(soap, &this->wsdl__definitions::message);
	soap_serialize_std__vectorTemplateOfwsdl__portType(soap, &this->wsdl__definitions::portType);
	soap_serialize_std__vectorTemplateOfwsdl__portType(soap, &this->wsdl__definitions::interface_);
	soap_serialize_std__vectorTemplateOfwsdl__binding(soap, &this->wsdl__definitions::binding);
	soap_serialize_std__vectorTemplateOfwsdl__service(soap, &this->wsdl__definitions::service);
	soap_serialize_xsd__string(soap, (char*const*)&this->wsdl__definitions::wsp__UsingPolicy);
	soap_serialize_std__vectorTemplateOfwsp__Policy(soap, &this->wsdl__definitions::wsp__Policy_);
	soap_serialize_std__vectorTemplateOfplnk__tPartnerLinkType(soap, &this->wsdl__definitions::plnk__partnerLinkType);
	soap_serialize_std__vectorTemplateOfvprop__tProperty(soap, &this->wsdl__definitions::vprop__property);
	soap_serialize_std__vectorTemplateOfvprop__tPropertyAlias(soap, &this->wsdl__definitions::vprop__propertyAlias);
	soap_serialize_std__vectorTemplateOfgwsdl__portType(soap, &this->wsdl__definitions::gwsdl__portType_);
	/* non-serializable soap12 skipped */
	/* non-serializable updated skipped */
	/* non-serializable location skipped */
	/* non-serializable redirs skipped */
	/* non-serializable builtinTypeSet skipped */
	/* non-serializable builtinElementSet skipped */
	/* non-serializable builtinAttributeSet skipped */
	/* non-serializable appRef skipped */
#endif
}

int wsdl__definitions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsdl__definitions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdl__definitions(struct soap *soap, const char *tag, int id, const wsdl__definitions *a, const char *type)
{
	if (((wsdl__definitions*)a)->name)
		soap_set_attr(soap, "name", soap_xsd__NMTOKEN2s(soap, ((wsdl__definitions*)a)->name), 1);
	if (((wsdl__definitions*)a)->targetNamespace)
		soap_set_attr(soap, "targetNamespace", soap_xsd__anyURI2s(soap, ((wsdl__definitions*)a)->targetNamespace), 1);
	if (((wsdl__definitions*)a)->version)
		soap_set_attr(soap, "version", soap_xsd__NMTOKEN2s(soap, ((wsdl__definitions*)a)->version), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsdl__definitions), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfwsdl__import(soap, "wsdl:import", -1, &a->wsdl__definitions::import, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "wsdl:documentation", -1, (char*const*)&a->wsdl__definitions::documentation, ""))
		return soap->error;
	if (soap_out_PointerTowsdl__types(soap, "wsdl:types", -1, &a->wsdl__definitions::types, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfwsdl__message(soap, "wsdl:message", -1, &a->wsdl__definitions::message, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfwsdl__portType(soap, "wsdl:portType", -1, &a->wsdl__definitions::portType, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfwsdl__portType(soap, "wsdl:interface", -1, &a->wsdl__definitions::interface_, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfwsdl__binding(soap, "wsdl:binding", -1, &a->wsdl__definitions::binding, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfwsdl__service(soap, "wsdl:service", -1, &a->wsdl__definitions::service, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "wsp:UsingPolicy", -1, (char*const*)&a->wsdl__definitions::wsp__UsingPolicy, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfwsp__Policy(soap, "wsp:Policy", -1, &a->wsdl__definitions::wsp__Policy_, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfplnk__tPartnerLinkType(soap, "plnk:partnerLinkType", -1, &a->wsdl__definitions::plnk__partnerLinkType, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfvprop__tProperty(soap, "vprop:property", -1, &a->wsdl__definitions::vprop__property, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfvprop__tPropertyAlias(soap, "vprop:propertyAlias", -1, &a->wsdl__definitions::vprop__propertyAlias, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfgwsdl__portType(soap, "gwsdl:portType", -1, &a->wsdl__definitions::gwsdl__portType_, ""))
		return soap->error;
	/* non-serializable soap12 skipped */
	/* non-serializable updated skipped */
	/* non-serializable location skipped */
	/* non-serializable redirs skipped */
	/* non-serializable builtinTypeSet skipped */
	/* non-serializable builtinElementSet skipped */
	/* non-serializable builtinAttributeSet skipped */
	/* non-serializable appRef skipped */
	return soap_element_end_out(soap, tag);
}

void *wsdl__definitions::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wsdl__definitions(soap, tag, this, type);
}

SOAP_FMAC3 wsdl__definitions * SOAP_FMAC4 soap_in_wsdl__definitions(struct soap *soap, const char *tag, wsdl__definitions *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsdl__definitions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsdl__definitions, sizeof(wsdl__definitions), soap->type, soap->arrayType, wsdl_instantiate, wsdl_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsdl__definitions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (wsdl__definitions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__NMTOKEN(soap, soap_attr_value(soap, "name", 5, 0), &((wsdl__definitions*)a)->name))
		return NULL;
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "targetNamespace", 4, 0), &((wsdl__definitions*)a)->targetNamespace))
		return NULL;
	if (soap_s2xsd__NMTOKEN(soap, soap_attr_value(soap, "version", 5, 0), &((wsdl__definitions*)a)->version))
		return NULL;
	size_t soap_flag_documentation1 = 1;
	size_t soap_flag_types1 = 1;
	size_t soap_flag_wsp__UsingPolicy1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfwsdl__import(soap, "wsdl:import", &a->wsdl__definitions::import, "wsdl:import"))
					continue;
			}
			if (soap_flag_documentation1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "wsdl:documentation", (char**)&a->wsdl__definitions::documentation, "xsd:string"))
				{	soap_flag_documentation1--;
					continue;
				}
			}
			if (soap_flag_types1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsdl__types(soap, "wsdl:types", &a->wsdl__definitions::types, "wsdl:types"))
				{	soap_flag_types1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfwsdl__message(soap, "wsdl:message", &a->wsdl__definitions::message, "wsdl:message"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfwsdl__portType(soap, "wsdl:portType", &a->wsdl__definitions::portType, "wsdl:portType"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfwsdl__portType(soap, "wsdl:interface", &a->wsdl__definitions::interface_, "wsdl:portType"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfwsdl__binding(soap, "wsdl:binding", &a->wsdl__definitions::binding, "wsdl:binding"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfwsdl__service(soap, "wsdl:service", &a->wsdl__definitions::service, "wsdl:service"))
					continue;
			}
			if (soap_flag_wsp__UsingPolicy1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "wsp:UsingPolicy", (char**)&a->wsdl__definitions::wsp__UsingPolicy, "xsd:string"))
				{	soap_flag_wsp__UsingPolicy1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfwsp__Policy(soap, "wsp:Policy", &a->wsdl__definitions::wsp__Policy_, "wsp:Policy"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfplnk__tPartnerLinkType(soap, "plnk:partnerLinkType", &a->wsdl__definitions::plnk__partnerLinkType, "plnk:tPartnerLinkType"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfvprop__tProperty(soap, "vprop:property", &a->wsdl__definitions::vprop__property, "vprop:tProperty"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfvprop__tPropertyAlias(soap, "vprop:propertyAlias", &a->wsdl__definitions::vprop__propertyAlias, "vprop:tPropertyAlias"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfgwsdl__portType(soap, "gwsdl:portType", &a->wsdl__definitions::gwsdl__portType_, "gwsdl:portType"))
					continue;
			}
			/* non-serializable soap12 skipped */
			/* non-serializable updated skipped */
			/* non-serializable location skipped */
			/* non-serializable redirs skipped */
			/* non-serializable builtinTypeSet skipped */
			/* non-serializable builtinElementSet skipped */
			/* non-serializable builtinAttributeSet skipped */
			/* non-serializable appRef skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if (a->get(soap))
			return NULL;
	}
	else
	{	a = (wsdl__definitions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsdl__definitions, SOAP_TYPE_wsdl__definitions, sizeof(wsdl__definitions), 0, wsdl_finsert, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsdl__definitions * SOAP_FMAC2 wsdl_instantiate_wsdl__definitions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_wsdl__definitions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsdl__definitions *p;
	size_t k = sizeof(wsdl__definitions);
	if (n < 0)
	{	p = SOAP_NEW(wsdl__definitions);
		if (p)
			((wsdl__definitions*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(wsdl__definitions, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((wsdl__definitions*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsdl__definitions location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_wsdl__definitions, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

int wsdl__definitions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsdl__definitions(soap, tag ? tag : "wsdl:definitions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsdl__definitions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsdl__definitions(soap, this, tag, type);
}

SOAP_FMAC3 wsdl__definitions * SOAP_FMAC4 soap_get_wsdl__definitions(struct soap *soap, wsdl__definitions *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsdl__definitions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->faultcode);
	soap_serialize_string(soap, (char*const*)&a->faultstring);
	soap_serialize_string(soap, (char*const*)&a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Node);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)(void*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, (char*const*)&a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, (char*const*)&a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, (char*const*)&a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, (char*const*)&a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__QName(soap, "faultcode", (char**)&a->faultcode, "xsd:QName"))
				{	soap_flag_faultcode--;
					continue;
				}
			}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "faultstring", (char**)&a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "faultactor", (char**)&a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Node", (char**)&a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Role", (char**)&a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, wsdl_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 wsdl_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_SOAP_ENV__Fault(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Fault *p;
	size_t k = sizeof(struct SOAP_ENV__Fault);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Fault);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Fault, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Fault location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_SOAP_ENV__Fault, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Fault(soap, tag ? tag : "SOAP-ENV:Fault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, (char*const*)&a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Text", (char**)&a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, wsdl_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 wsdl_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_SOAP_ENV__Reason(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Reason *p;
	size_t k = sizeof(struct SOAP_ENV__Reason);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Reason);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Reason, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Reason location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_SOAP_ENV__Reason, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL);
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, wsdl_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 wsdl_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_SOAP_ENV__Detail(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Detail *p;
	size_t k = sizeof(struct SOAP_ENV__Detail);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Detail);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Detail, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Detail location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_SOAP_ENV__Detail, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)(void*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__QName(soap, "SOAP-ENV:Value", (char**)&a->SOAP_ENV__Value, "xsd:QName"))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, wsdl_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 wsdl_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_SOAP_ENV__Code(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Code *p;
	size_t k = sizeof(struct SOAP_ENV__Code);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Code);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Code, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Code location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_SOAP_ENV__Code, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, wsdl_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 wsdl_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_SOAP_ENV__Header(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Header *p;
	size_t k = sizeof(struct SOAP_ENV__Header);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Header);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Header, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Header location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_SOAP_ENV__Header, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Header(soap, tag ? tag : "SOAP-ENV:Header", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsdl__union_ioput(struct soap *soap, int choice, const union wsdl__union_ioput *a)
{
	(void)soap; (void)choice; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	switch (choice)
	{
	case SOAP_UNION_wsdl__union_ioput_input:
		soap_serialize_PointerTowsdl__ioput(soap, &a->input);
		break;
	case SOAP_UNION_wsdl__union_ioput_output:
		soap_serialize_PointerTowsdl__ioput(soap, &a->output);
		break;
	default:
		break;
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdl__union_ioput(struct soap *soap, int choice, const union wsdl__union_ioput *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION_wsdl__union_ioput_input:
		return soap_out_PointerTowsdl__ioput(soap, "wsdl:input", -1, &a->input, "");
	case SOAP_UNION_wsdl__union_ioput_output:
		return soap_out_PointerTowsdl__ioput(soap, "wsdl:output", -1, &a->output, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union wsdl__union_ioput * SOAP_FMAC4 soap_in_wsdl__union_ioput(struct soap *soap, int *choice, union wsdl__union_ioput *a)
{
	(void)a; /* appease -Wall -Werror */	soap->error = SOAP_TAG_MISMATCH;
	a->input = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTowsdl__ioput(soap, "wsdl:input", &a->input, "wsdl:ioput"))
	{	*choice = SOAP_UNION_wsdl__union_ioput_input;
		return a;
	}
	a->output = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTowsdl__ioput(soap, "wsdl:output", &a->output, "wsdl:ioput"))
	{	*choice = SOAP_UNION_wsdl__union_ioput_output;
		return a;
	}
	*choice = 0;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xs__union_content(struct soap *soap, int choice, const union xs__union_content *a)
{
	(void)soap; (void)choice; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	switch (choice)
	{
	case SOAP_UNION_xs__union_content_element:
		soap_serialize_PointerToxs__element(soap, &a->element);
		break;
	case SOAP_UNION_xs__union_content_group:
		soap_serialize_PointerToxs__group(soap, &a->group);
		break;
	case SOAP_UNION_xs__union_content_choice:
		soap_serialize_PointerToxs__seqchoice(soap, &a->choice);
		break;
	case SOAP_UNION_xs__union_content_sequence:
		soap_serialize_PointerToxs__seqchoice(soap, &a->sequence);
		break;
	case SOAP_UNION_xs__union_content_any:
		soap_serialize_PointerToxs__any(soap, &a->any);
		break;
	default:
		break;
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xs__union_content(struct soap *soap, int choice, const union xs__union_content *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION_xs__union_content_element:
		return soap_out_PointerToxs__element(soap, "xs:element", -1, &a->element, "");
	case SOAP_UNION_xs__union_content_group:
		return soap_out_PointerToxs__group(soap, "xs:group", -1, &a->group, "");
	case SOAP_UNION_xs__union_content_choice:
		return soap_out_PointerToxs__seqchoice(soap, "xs:choice", -1, &a->choice, "");
	case SOAP_UNION_xs__union_content_sequence:
		return soap_out_PointerToxs__seqchoice(soap, "xs:sequence", -1, &a->sequence, "");
	case SOAP_UNION_xs__union_content_any:
		return soap_out_PointerToxs__any(soap, "xs:any", -1, &a->any, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union xs__union_content * SOAP_FMAC4 soap_in_xs__union_content(struct soap *soap, int *choice, union xs__union_content *a)
{
	(void)a; /* appease -Wall -Werror */	soap->error = SOAP_TAG_MISMATCH;
	a->element = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerToxs__element(soap, "xs:element", &a->element, "xs:element"))
	{	*choice = SOAP_UNION_xs__union_content_element;
		return a;
	}
	a->group = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerToxs__group(soap, "xs:group", &a->group, "xs:group"))
	{	*choice = SOAP_UNION_xs__union_content_group;
		return a;
	}
	a->choice = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerToxs__seqchoice(soap, "xs:choice", &a->choice, "xs:seqchoice"))
	{	*choice = SOAP_UNION_xs__union_content_choice;
		return a;
	}
	a->sequence = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerToxs__seqchoice(soap, "xs:sequence", &a->sequence, "xs:seqchoice"))
	{	*choice = SOAP_UNION_xs__union_content_sequence;
		return a;
	}
	a->any = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerToxs__any(soap, "xs:any", &a->any, "xs:any"))
	{	*choice = SOAP_UNION_xs__union_content_any;
		return a;
	}
	*choice = 0;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code, &mark);
	if (id < 0)
		return soap->error;
	soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowadl__application(struct soap *soap, wadl__application *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wadl__application))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowadl__application(struct soap *soap, const char *tag, int id, wadl__application *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wadl__application, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wadl__application ? type : NULL);
}

SOAP_FMAC3 wadl__application ** SOAP_FMAC4 soap_in_PointerTowadl__application(struct soap *soap, const char *tag, wadl__application **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wadl__application **)soap_malloc(soap, sizeof(wadl__application *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wadl__application *)wsdl_instantiate_wadl__application(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wadl__application **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wadl__application, sizeof(wadl__application), 0, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowadl__application(struct soap *soap, wadl__application *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowadl__application(soap, tag ? tag : "wadl:application", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wadl__application ** SOAP_FMAC4 soap_get_PointerTowadl__application(struct soap *soap, wadl__application **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowadl__application(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsdl__types(struct soap *soap, wsdl__types *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsdl__types))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsdl__types(struct soap *soap, const char *tag, int id, wsdl__types *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsdl__types, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wsdl__types ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 wsdl__types ** SOAP_FMAC4 soap_in_PointerTowsdl__types(struct soap *soap, const char *tag, wsdl__types **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wsdl__types **)soap_malloc(soap, sizeof(wsdl__types *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wsdl__types *)wsdl_instantiate_wsdl__types(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wsdl__types **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsdl__types, sizeof(wsdl__types), 0, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsdl__types(struct soap *soap, wsdl__types *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsdl__types(soap, tag ? tag : "wsdl:types", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wsdl__types ** SOAP_FMAC4 soap_get_PointerTowsdl__types(struct soap *soap, wsdl__types **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsdl__types(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsdl__binding(struct soap *soap, wsdl__binding *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsdl__binding))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsdl__binding(struct soap *soap, const char *tag, int id, wsdl__binding *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsdl__binding, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wsdl__binding ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 wsdl__binding ** SOAP_FMAC4 soap_in_PointerTowsdl__binding(struct soap *soap, const char *tag, wsdl__binding **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wsdl__binding **)soap_malloc(soap, sizeof(wsdl__binding *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wsdl__binding *)wsdl_instantiate_wsdl__binding(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wsdl__binding **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsdl__binding, sizeof(wsdl__binding), 0, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsdl__binding(struct soap *soap, wsdl__binding *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsdl__binding(soap, tag ? tag : "wsdl:binding", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wsdl__binding ** SOAP_FMAC4 soap_get_PointerTowsdl__binding(struct soap *soap, wsdl__binding **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsdl__binding(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTohttp__address(struct soap *soap, http__address *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_http__address))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTohttp__address(struct soap *soap, const char *tag, int id, http__address *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_http__address, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_http__address ? type : NULL);
}

SOAP_FMAC3 http__address ** SOAP_FMAC4 soap_in_PointerTohttp__address(struct soap *soap, const char *tag, http__address **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (http__address **)soap_malloc(soap, sizeof(http__address *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (http__address *)wsdl_instantiate_http__address(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (http__address **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_http__address, sizeof(http__address), 0, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTohttp__address(struct soap *soap, http__address *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTohttp__address(soap, tag ? tag : "http:address", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 http__address ** SOAP_FMAC4 soap_get_PointerTohttp__address(struct soap *soap, http__address **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTohttp__address(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosoap__address(struct soap *soap, soap__address *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_soap__address))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosoap__address(struct soap *soap, const char *tag, int id, soap__address *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_soap__address, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_soap__address ? type : NULL);
}

SOAP_FMAC3 soap__address ** SOAP_FMAC4 soap_in_PointerTosoap__address(struct soap *soap, const char *tag, soap__address **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (soap__address **)soap_malloc(soap, sizeof(soap__address *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (soap__address *)wsdl_instantiate_soap__address(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (soap__address **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_soap__address, sizeof(soap__address), 0, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosoap__address(struct soap *soap, soap__address *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosoap__address(soap, tag ? tag : "soap:address", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 soap__address ** SOAP_FMAC4 soap_get_PointerTosoap__address(struct soap *soap, soap__address **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosoap__address(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__string(struct soap *soap, char **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__string))
		soap_serialize_xsd__string(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__string(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__string, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerToxsd__string(struct soap *soap, const char *tag, char ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__string, sizeof(char *), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__string(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxsd__string(soap, tag ? tag : "xsd:string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerToxsd__string(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTohttp__binding(struct soap *soap, http__binding *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_http__binding))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTohttp__binding(struct soap *soap, const char *tag, int id, http__binding *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_http__binding, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_http__binding ? type : NULL);
}

SOAP_FMAC3 http__binding ** SOAP_FMAC4 soap_in_PointerTohttp__binding(struct soap *soap, const char *tag, http__binding **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (http__binding **)soap_malloc(soap, sizeof(http__binding *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (http__binding *)wsdl_instantiate_http__binding(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (http__binding **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_http__binding, sizeof(http__binding), 0, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTohttp__binding(struct soap *soap, http__binding *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTohttp__binding(soap, tag ? tag : "http:binding", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 http__binding ** SOAP_FMAC4 soap_get_PointerTohttp__binding(struct soap *soap, http__binding **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTohttp__binding(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosoap__binding(struct soap *soap, soap__binding *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_soap__binding))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosoap__binding(struct soap *soap, const char *tag, int id, soap__binding *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_soap__binding, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_soap__binding ? type : NULL);
}

SOAP_FMAC3 soap__binding ** SOAP_FMAC4 soap_in_PointerTosoap__binding(struct soap *soap, const char *tag, soap__binding **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (soap__binding **)soap_malloc(soap, sizeof(soap__binding *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (soap__binding *)wsdl_instantiate_soap__binding(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (soap__binding **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_soap__binding, sizeof(soap__binding), 0, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosoap__binding(struct soap *soap, soap__binding *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosoap__binding(soap, tag ? tag : "soap:binding", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 soap__binding ** SOAP_FMAC4 soap_get_PointerTosoap__binding(struct soap *soap, soap__binding **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosoap__binding(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsdl__ext_ioput(struct soap *soap, wsdl__ext_ioput *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsdl__ext_ioput))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsdl__ext_ioput(struct soap *soap, const char *tag, int id, wsdl__ext_ioput *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsdl__ext_ioput, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wsdl__ext_ioput ? type : NULL);
}

SOAP_FMAC3 wsdl__ext_ioput ** SOAP_FMAC4 soap_in_PointerTowsdl__ext_ioput(struct soap *soap, const char *tag, wsdl__ext_ioput **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wsdl__ext_ioput **)soap_malloc(soap, sizeof(wsdl__ext_ioput *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wsdl__ext_ioput *)wsdl_instantiate_wsdl__ext_ioput(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wsdl__ext_ioput **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsdl__ext_ioput, sizeof(wsdl__ext_ioput), 0, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsdl__ext_ioput(struct soap *soap, wsdl__ext_ioput *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsdl__ext_ioput(soap, tag ? tag : "wsdl:ext-ioput", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wsdl__ext_ioput ** SOAP_FMAC4 soap_get_PointerTowsdl__ext_ioput(struct soap *soap, wsdl__ext_ioput **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsdl__ext_ioput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTohttp__operation(struct soap *soap, http__operation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_http__operation))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTohttp__operation(struct soap *soap, const char *tag, int id, http__operation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_http__operation, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_http__operation ? type : NULL);
}

SOAP_FMAC3 http__operation ** SOAP_FMAC4 soap_in_PointerTohttp__operation(struct soap *soap, const char *tag, http__operation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (http__operation **)soap_malloc(soap, sizeof(http__operation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (http__operation *)wsdl_instantiate_http__operation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (http__operation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_http__operation, sizeof(http__operation), 0, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTohttp__operation(struct soap *soap, http__operation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTohttp__operation(soap, tag ? tag : "http:operation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 http__operation ** SOAP_FMAC4 soap_get_PointerTohttp__operation(struct soap *soap, http__operation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTohttp__operation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosoap__operation(struct soap *soap, soap__operation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_soap__operation))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosoap__operation(struct soap *soap, const char *tag, int id, soap__operation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_soap__operation, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_soap__operation ? type : NULL);
}

SOAP_FMAC3 soap__operation ** SOAP_FMAC4 soap_in_PointerTosoap__operation(struct soap *soap, const char *tag, soap__operation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (soap__operation **)soap_malloc(soap, sizeof(soap__operation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (soap__operation *)wsdl_instantiate_soap__operation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (soap__operation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_soap__operation, sizeof(soap__operation), 0, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosoap__operation(struct soap *soap, soap__operation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosoap__operation(soap, tag ? tag : "soap:operation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 soap__operation ** SOAP_FMAC4 soap_get_PointerTosoap__operation(struct soap *soap, soap__operation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosoap__operation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsdl__fault(struct soap *soap, wsdl__fault *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsdl__fault))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsdl__fault(struct soap *soap, const char *tag, int id, wsdl__fault *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsdl__fault, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wsdl__fault ? type : NULL);
}

SOAP_FMAC3 wsdl__fault ** SOAP_FMAC4 soap_in_PointerTowsdl__fault(struct soap *soap, const char *tag, wsdl__fault **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wsdl__fault **)soap_malloc(soap, sizeof(wsdl__fault *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wsdl__fault *)wsdl_instantiate_wsdl__fault(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wsdl__fault **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsdl__fault, sizeof(wsdl__fault), 0, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsdl__fault(struct soap *soap, wsdl__fault *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsdl__fault(soap, tag ? tag : "wsdl:fault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wsdl__fault ** SOAP_FMAC4 soap_get_PointerTowsdl__fault(struct soap *soap, wsdl__fault **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsdl__fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosoap__fault(struct soap *soap, soap__fault *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_soap__fault))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosoap__fault(struct soap *soap, const char *tag, int id, soap__fault *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_soap__fault, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_soap__fault ? type : NULL);
}

SOAP_FMAC3 soap__fault ** SOAP_FMAC4 soap_in_PointerTosoap__fault(struct soap *soap, const char *tag, soap__fault **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (soap__fault **)soap_malloc(soap, sizeof(soap__fault *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (soap__fault *)wsdl_instantiate_soap__fault(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (soap__fault **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_soap__fault, sizeof(soap__fault), 0, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosoap__fault(struct soap *soap, soap__fault *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosoap__fault(soap, tag ? tag : "soap:fault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 soap__fault ** SOAP_FMAC4 soap_get_PointerTosoap__fault(struct soap *soap, soap__fault **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosoap__fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTomime__mimeXml(struct soap *soap, mime__mimeXml *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_mime__mimeXml))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTomime__mimeXml(struct soap *soap, const char *tag, int id, mime__mimeXml *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_mime__mimeXml, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_mime__mimeXml ? type : NULL);
}

SOAP_FMAC3 mime__mimeXml ** SOAP_FMAC4 soap_in_PointerTomime__mimeXml(struct soap *soap, const char *tag, mime__mimeXml **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (mime__mimeXml **)soap_malloc(soap, sizeof(mime__mimeXml *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (mime__mimeXml *)wsdl_instantiate_mime__mimeXml(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (mime__mimeXml **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_mime__mimeXml, sizeof(mime__mimeXml), 0, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTomime__mimeXml(struct soap *soap, mime__mimeXml *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTomime__mimeXml(soap, tag ? tag : "mime:mimeXml", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 mime__mimeXml ** SOAP_FMAC4 soap_get_PointerTomime__mimeXml(struct soap *soap, mime__mimeXml **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTomime__mimeXml(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTomime__content(struct soap *soap, mime__content *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_mime__content))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTomime__content(struct soap *soap, const char *tag, int id, mime__content *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_mime__content, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_mime__content ? type : NULL);
}

SOAP_FMAC3 mime__content ** SOAP_FMAC4 soap_in_PointerTomime__content(struct soap *soap, const char *tag, mime__content **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (mime__content **)soap_malloc(soap, sizeof(mime__content *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (mime__content *)wsdl_instantiate_mime__content(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (mime__content **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_mime__content, sizeof(mime__content), 0, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTomime__content(struct soap *soap, mime__content *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTomime__content(soap, tag ? tag : "mime:content", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 mime__content ** SOAP_FMAC4 soap_get_PointerTomime__content(struct soap *soap, mime__content **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTomime__content(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTomime__multipartRelated(struct soap *soap, mime__multipartRelated *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_mime__multipartRelated))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTomime__multipartRelated(struct soap *soap, const char *tag, int id, mime__multipartRelated *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_mime__multipartRelated, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_mime__multipartRelated ? type : NULL);
}

SOAP_FMAC3 mime__multipartRelated ** SOAP_FMAC4 soap_in_PointerTomime__multipartRelated(struct soap *soap, const char *tag, mime__multipartRelated **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (mime__multipartRelated **)soap_malloc(soap, sizeof(mime__multipartRelated *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (mime__multipartRelated *)wsdl_instantiate_mime__multipartRelated(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (mime__multipartRelated **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_mime__multipartRelated, sizeof(mime__multipartRelated), 0, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTomime__multipartRelated(struct soap *soap, mime__multipartRelated *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTomime__multipartRelated(soap, tag ? tag : "mime:multipartRelated", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 mime__multipartRelated ** SOAP_FMAC4 soap_get_PointerTomime__multipartRelated(struct soap *soap, mime__multipartRelated **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTomime__multipartRelated(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodime__message(struct soap *soap, dime__message *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_dime__message))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTodime__message(struct soap *soap, const char *tag, int id, dime__message *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_dime__message, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_dime__message ? type : NULL);
}

SOAP_FMAC3 dime__message ** SOAP_FMAC4 soap_in_PointerTodime__message(struct soap *soap, const char *tag, dime__message **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (dime__message **)soap_malloc(soap, sizeof(dime__message *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (dime__message *)wsdl_instantiate_dime__message(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (dime__message **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_dime__message, sizeof(dime__message), 0, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodime__message(struct soap *soap, dime__message *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTodime__message(soap, tag ? tag : "dime:message", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 dime__message ** SOAP_FMAC4 soap_get_PointerTodime__message(struct soap *soap, dime__message **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTodime__message(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsdl__ioput(struct soap *soap, wsdl__ioput *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsdl__ioput))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsdl__ioput(struct soap *soap, const char *tag, int id, wsdl__ioput *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsdl__ioput, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wsdl__ioput ? type : NULL);
}

SOAP_FMAC3 wsdl__ioput ** SOAP_FMAC4 soap_in_PointerTowsdl__ioput(struct soap *soap, const char *tag, wsdl__ioput **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wsdl__ioput **)soap_malloc(soap, sizeof(wsdl__ioput *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wsdl__ioput *)wsdl_instantiate_wsdl__ioput(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wsdl__ioput **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsdl__ioput, sizeof(wsdl__ioput), 0, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsdl__ioput(struct soap *soap, wsdl__ioput *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsdl__ioput(soap, tag ? tag : "wsdl:ioput", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wsdl__ioput ** SOAP_FMAC4 soap_get_PointerTowsdl__ioput(struct soap *soap, wsdl__ioput **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsdl__ioput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsdl__definitions(struct soap *soap, wsdl__definitions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsdl__definitions))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsdl__definitions(struct soap *soap, const char *tag, int id, wsdl__definitions *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsdl__definitions, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wsdl__definitions ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 wsdl__definitions ** SOAP_FMAC4 soap_in_PointerTowsdl__definitions(struct soap *soap, const char *tag, wsdl__definitions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wsdl__definitions **)soap_malloc(soap, sizeof(wsdl__definitions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wsdl__definitions *)wsdl_instantiate_wsdl__definitions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wsdl__definitions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsdl__definitions, sizeof(wsdl__definitions), 0, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsdl__definitions(struct soap *soap, wsdl__definitions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsdl__definitions(soap, tag ? tag : "wsdl:definitions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wsdl__definitions ** SOAP_FMAC4 soap_get_PointerTowsdl__definitions(struct soap *soap, wsdl__definitions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsdl__definitions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovprop__tProperty(struct soap *soap, vprop__tProperty *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_vprop__tProperty))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTovprop__tProperty(struct soap *soap, const char *tag, int id, vprop__tProperty *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vprop__tProperty, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_vprop__tProperty ? type : NULL);
}

SOAP_FMAC3 vprop__tProperty ** SOAP_FMAC4 soap_in_PointerTovprop__tProperty(struct soap *soap, const char *tag, vprop__tProperty **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (vprop__tProperty **)soap_malloc(soap, sizeof(vprop__tProperty *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (vprop__tProperty *)wsdl_instantiate_vprop__tProperty(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (vprop__tProperty **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vprop__tProperty, sizeof(vprop__tProperty), 0, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovprop__tProperty(struct soap *soap, vprop__tProperty *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTovprop__tProperty(soap, tag ? tag : "vprop:tProperty", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 vprop__tProperty ** SOAP_FMAC4 soap_get_PointerTovprop__tProperty(struct soap *soap, vprop__tProperty **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTovprop__tProperty(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovprop__tQuery(struct soap *soap, vprop__tQuery *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_vprop__tQuery))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTovprop__tQuery(struct soap *soap, const char *tag, int id, vprop__tQuery *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vprop__tQuery, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_vprop__tQuery ? type : NULL);
}

SOAP_FMAC3 vprop__tQuery ** SOAP_FMAC4 soap_in_PointerTovprop__tQuery(struct soap *soap, const char *tag, vprop__tQuery **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (vprop__tQuery **)soap_malloc(soap, sizeof(vprop__tQuery *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (vprop__tQuery *)wsdl_instantiate_vprop__tQuery(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (vprop__tQuery **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vprop__tQuery, sizeof(vprop__tQuery), 0, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovprop__tQuery(struct soap *soap, vprop__tQuery *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTovprop__tQuery(soap, tag ? tag : "vprop:tQuery", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 vprop__tQuery ** SOAP_FMAC4 soap_get_PointerTovprop__tQuery(struct soap *soap, vprop__tQuery **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTovprop__tQuery(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToplnk__tPartnerLinkType(struct soap *soap, plnk__tPartnerLinkType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_plnk__tPartnerLinkType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToplnk__tPartnerLinkType(struct soap *soap, const char *tag, int id, plnk__tPartnerLinkType *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_plnk__tPartnerLinkType, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_plnk__tPartnerLinkType ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 plnk__tPartnerLinkType ** SOAP_FMAC4 soap_in_PointerToplnk__tPartnerLinkType(struct soap *soap, const char *tag, plnk__tPartnerLinkType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (plnk__tPartnerLinkType **)soap_malloc(soap, sizeof(plnk__tPartnerLinkType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (plnk__tPartnerLinkType *)wsdl_instantiate_plnk__tPartnerLinkType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (plnk__tPartnerLinkType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_plnk__tPartnerLinkType, sizeof(plnk__tPartnerLinkType), 0, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToplnk__tPartnerLinkType(struct soap *soap, plnk__tPartnerLinkType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToplnk__tPartnerLinkType(soap, tag ? tag : "plnk:tPartnerLinkType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 plnk__tPartnerLinkType ** SOAP_FMAC4 soap_get_PointerToplnk__tPartnerLinkType(struct soap *soap, plnk__tPartnerLinkType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToplnk__tPartnerLinkType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsdl__portType(struct soap *soap, wsdl__portType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsdl__portType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsdl__portType(struct soap *soap, const char *tag, int id, wsdl__portType *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsdl__portType, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wsdl__portType ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 wsdl__portType ** SOAP_FMAC4 soap_in_PointerTowsdl__portType(struct soap *soap, const char *tag, wsdl__portType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wsdl__portType **)soap_malloc(soap, sizeof(wsdl__portType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wsdl__portType *)wsdl_instantiate_wsdl__portType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wsdl__portType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsdl__portType, sizeof(wsdl__portType), 0, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsdl__portType(struct soap *soap, wsdl__portType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsdl__portType(soap, tag ? tag : "wsdl:portType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wsdl__portType ** SOAP_FMAC4 soap_get_PointerTowsdl__portType(struct soap *soap, wsdl__portType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsdl__portType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsp__AppliesTo(struct soap *soap, wsp__AppliesTo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsp__AppliesTo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsp__AppliesTo(struct soap *soap, const char *tag, int id, wsp__AppliesTo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsp__AppliesTo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wsp__AppliesTo ? type : NULL);
}

SOAP_FMAC3 wsp__AppliesTo ** SOAP_FMAC4 soap_in_PointerTowsp__AppliesTo(struct soap *soap, const char *tag, wsp__AppliesTo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wsp__AppliesTo **)soap_malloc(soap, sizeof(wsp__AppliesTo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wsp__AppliesTo *)wsdl_instantiate_wsp__AppliesTo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wsp__AppliesTo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsp__AppliesTo, sizeof(wsp__AppliesTo), 0, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsp__AppliesTo(struct soap *soap, wsp__AppliesTo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsp__AppliesTo(soap, tag ? tag : "wsp:AppliesTo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wsp__AppliesTo ** SOAP_FMAC4 soap_get_PointerTowsp__AppliesTo(struct soap *soap, wsp__AppliesTo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsp__AppliesTo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsrmp5__RMAssertion(struct soap *soap, wsrmp5__RMAssertion *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsrmp5__RMAssertion))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsrmp5__RMAssertion(struct soap *soap, const char *tag, int id, wsrmp5__RMAssertion *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsrmp5__RMAssertion, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wsrmp5__RMAssertion ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 wsrmp5__RMAssertion ** SOAP_FMAC4 soap_in_PointerTowsrmp5__RMAssertion(struct soap *soap, const char *tag, wsrmp5__RMAssertion **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wsrmp5__RMAssertion **)soap_malloc(soap, sizeof(wsrmp5__RMAssertion *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wsrmp5__RMAssertion *)wsdl_instantiate_wsrmp5__RMAssertion(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wsrmp5__RMAssertion **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsrmp5__RMAssertion, sizeof(wsrmp5__RMAssertion), 0, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsrmp5__RMAssertion(struct soap *soap, wsrmp5__RMAssertion *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsrmp5__RMAssertion(soap, tag ? tag : "wsrmp5:RMAssertion", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wsrmp5__RMAssertion ** SOAP_FMAC4 soap_get_PointerTowsrmp5__RMAssertion(struct soap *soap, wsrmp5__RMAssertion **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsrmp5__RMAssertion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsrmp__RMAssertion(struct soap *soap, wsrmp__RMAssertion *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsrmp__RMAssertion))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsrmp__RMAssertion(struct soap *soap, const char *tag, int id, wsrmp__RMAssertion *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsrmp__RMAssertion, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wsrmp__RMAssertion ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 wsrmp__RMAssertion ** SOAP_FMAC4 soap_in_PointerTowsrmp__RMAssertion(struct soap *soap, const char *tag, wsrmp__RMAssertion **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wsrmp__RMAssertion **)soap_malloc(soap, sizeof(wsrmp__RMAssertion *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wsrmp__RMAssertion *)wsdl_instantiate_wsrmp__RMAssertion(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wsrmp__RMAssertion **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsrmp__RMAssertion, sizeof(wsrmp__RMAssertion), 0, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsrmp__RMAssertion(struct soap *soap, wsrmp__RMAssertion *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsrmp__RMAssertion(soap, tag ? tag : "wsrmp:RMAssertion", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wsrmp__RMAssertion ** SOAP_FMAC4 soap_get_PointerTowsrmp__RMAssertion(struct soap *soap, wsrmp__RMAssertion **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsrmp__RMAssertion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsp__Assertion(struct soap *soap, wsp__Assertion *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsp__Assertion))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsp__Assertion(struct soap *soap, const char *tag, int id, wsp__Assertion *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsp__Assertion, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wsp__Assertion ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 wsp__Assertion ** SOAP_FMAC4 soap_in_PointerTowsp__Assertion(struct soap *soap, const char *tag, wsp__Assertion **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wsp__Assertion **)soap_malloc(soap, sizeof(wsp__Assertion *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wsp__Assertion *)wsdl_instantiate_wsp__Assertion(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wsp__Assertion **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsp__Assertion, sizeof(wsp__Assertion), 0, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsp__Assertion(struct soap *soap, wsp__Assertion *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsp__Assertion(soap, tag ? tag : "wsp:Assertion", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wsp__Assertion ** SOAP_FMAC4 soap_get_PointerTowsp__Assertion(struct soap *soap, wsp__Assertion **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsp__Assertion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosp__Token(struct soap *soap, sp__Token *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_sp__Token))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosp__Token(struct soap *soap, const char *tag, int id, sp__Token *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_sp__Token, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_sp__Token ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 sp__Token ** SOAP_FMAC4 soap_in_PointerTosp__Token(struct soap *soap, const char *tag, sp__Token **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (sp__Token **)soap_malloc(soap, sizeof(sp__Token *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (sp__Token *)wsdl_instantiate_sp__Token(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (sp__Token **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_sp__Token, sizeof(sp__Token), 0, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosp__Token(struct soap *soap, sp__Token *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosp__Token(soap, tag ? tag : "sp:Token", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 sp__Token ** SOAP_FMAC4 soap_get_PointerTosp__Token(struct soap *soap, sp__Token **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosp__Token(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosp__Elements(struct soap *soap, sp__Elements *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_sp__Elements))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosp__Elements(struct soap *soap, const char *tag, int id, sp__Elements *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_sp__Elements, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_sp__Elements ? type : NULL);
}

SOAP_FMAC3 sp__Elements ** SOAP_FMAC4 soap_in_PointerTosp__Elements(struct soap *soap, const char *tag, sp__Elements **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (sp__Elements **)soap_malloc(soap, sizeof(sp__Elements *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (sp__Elements *)wsdl_instantiate_sp__Elements(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (sp__Elements **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_sp__Elements, sizeof(sp__Elements), 0, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosp__Elements(struct soap *soap, sp__Elements *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosp__Elements(soap, tag ? tag : "sp:Elements", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 sp__Elements ** SOAP_FMAC4 soap_get_PointerTosp__Elements(struct soap *soap, sp__Elements **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosp__Elements(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsp__PolicyReference(struct soap *soap, wsp__PolicyReference *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsp__PolicyReference))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsp__PolicyReference(struct soap *soap, const char *tag, int id, wsp__PolicyReference *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsp__PolicyReference, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wsp__PolicyReference ? type : NULL);
}

SOAP_FMAC3 wsp__PolicyReference ** SOAP_FMAC4 soap_in_PointerTowsp__PolicyReference(struct soap *soap, const char *tag, wsp__PolicyReference **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wsp__PolicyReference **)soap_malloc(soap, sizeof(wsp__PolicyReference *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wsp__PolicyReference *)wsdl_instantiate_wsp__PolicyReference(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wsp__PolicyReference **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsp__PolicyReference, sizeof(wsp__PolicyReference), 0, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsp__PolicyReference(struct soap *soap, wsp__PolicyReference *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsp__PolicyReference(soap, tag ? tag : "wsp:PolicyReference", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wsp__PolicyReference ** SOAP_FMAC4 soap_get_PointerTowsp__PolicyReference(struct soap *soap, wsp__PolicyReference **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsp__PolicyReference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsrmp5__Timeout(struct soap *soap, wsrmp5__Timeout *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsrmp5__Timeout))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsrmp5__Timeout(struct soap *soap, const char *tag, int id, wsrmp5__Timeout *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsrmp5__Timeout, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wsrmp5__Timeout ? type : NULL);
}

SOAP_FMAC3 wsrmp5__Timeout ** SOAP_FMAC4 soap_in_PointerTowsrmp5__Timeout(struct soap *soap, const char *tag, wsrmp5__Timeout **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wsrmp5__Timeout **)soap_malloc(soap, sizeof(wsrmp5__Timeout *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wsrmp5__Timeout *)wsdl_instantiate_wsrmp5__Timeout(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wsrmp5__Timeout **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsrmp5__Timeout, sizeof(wsrmp5__Timeout), 0, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsrmp5__Timeout(struct soap *soap, wsrmp5__Timeout *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsrmp5__Timeout(soap, tag ? tag : "wsrmp5:Timeout", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wsrmp5__Timeout ** SOAP_FMAC4 soap_get_PointerTowsrmp5__Timeout(struct soap *soap, wsrmp5__Timeout **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsrmp5__Timeout(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsrmp__Timeout(struct soap *soap, wsrmp__Timeout *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsrmp__Timeout))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsrmp__Timeout(struct soap *soap, const char *tag, int id, wsrmp__Timeout *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsrmp__Timeout, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wsrmp__Timeout ? type : NULL);
}

SOAP_FMAC3 wsrmp__Timeout ** SOAP_FMAC4 soap_in_PointerTowsrmp__Timeout(struct soap *soap, const char *tag, wsrmp__Timeout **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wsrmp__Timeout **)soap_malloc(soap, sizeof(wsrmp__Timeout *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wsrmp__Timeout *)wsdl_instantiate_wsrmp__Timeout(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wsrmp__Timeout **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsrmp__Timeout, sizeof(wsrmp__Timeout), 0, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsrmp__Timeout(struct soap *soap, wsrmp__Timeout *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsrmp__Timeout(soap, tag ? tag : "wsrmp:Timeout", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wsrmp__Timeout ** SOAP_FMAC4 soap_get_PointerTowsrmp__Timeout(struct soap *soap, wsrmp__Timeout **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsrmp__Timeout(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowst__Claims(struct soap *soap, wst__Claims *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wst__Claims))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowst__Claims(struct soap *soap, const char *tag, int id, wst__Claims *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wst__Claims, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wst__Claims ? type : NULL);
}

SOAP_FMAC3 wst__Claims ** SOAP_FMAC4 soap_in_PointerTowst__Claims(struct soap *soap, const char *tag, wst__Claims **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wst__Claims **)soap_malloc(soap, sizeof(wst__Claims *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wst__Claims *)wsdl_instantiate_wst__Claims(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wst__Claims **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wst__Claims, sizeof(wst__Claims), 0, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowst__Claims(struct soap *soap, wst__Claims *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowst__Claims(soap, tag ? tag : "wst:Claims", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wst__Claims ** SOAP_FMAC4 soap_get_PointerTowst__Claims(struct soap *soap, wst__Claims **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowst__Claims(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsa__EndpointReferenceType(struct soap *soap, wsa__EndpointReferenceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsa__EndpointReferenceType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsa__EndpointReferenceType(struct soap *soap, const char *tag, int id, wsa__EndpointReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsa__EndpointReferenceType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wsa__EndpointReferenceType ? type : NULL);
}

SOAP_FMAC3 wsa__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTowsa__EndpointReferenceType(struct soap *soap, const char *tag, wsa__EndpointReferenceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wsa__EndpointReferenceType **)soap_malloc(soap, sizeof(wsa__EndpointReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wsa__EndpointReferenceType *)wsdl_instantiate_wsa__EndpointReferenceType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wsa__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsa__EndpointReferenceType, sizeof(wsa__EndpointReferenceType), 0, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsa__EndpointReferenceType(struct soap *soap, wsa__EndpointReferenceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsa__EndpointReferenceType(soap, tag ? tag : "wsa:EndpointReferenceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wsa__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTowsa__EndpointReferenceType(struct soap *soap, wsa__EndpointReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsa__EndpointReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsp__Content(struct soap *soap, wsp__Content *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsp__Content))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsp__Content(struct soap *soap, const char *tag, int id, wsp__Content *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsp__Content, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wsp__Content ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 wsp__Content ** SOAP_FMAC4 soap_in_PointerTowsp__Content(struct soap *soap, const char *tag, wsp__Content **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wsp__Content **)soap_malloc(soap, sizeof(wsp__Content *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wsp__Content *)wsdl_instantiate_wsp__Content(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wsp__Content **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsp__Content, sizeof(wsp__Content), 0, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsp__Content(struct soap *soap, wsp__Content *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsp__Content(soap, tag ? tag : "wsp:Content", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wsp__Content ** SOAP_FMAC4 soap_get_PointerTowsp__Content(struct soap *soap, wsp__Content **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsp__Content(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsp__Policy(struct soap *soap, wsp__Policy *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsp__Policy))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsp__Policy(struct soap *soap, const char *tag, int id, wsp__Policy *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsp__Policy, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wsp__Policy ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 wsp__Policy ** SOAP_FMAC4 soap_in_PointerTowsp__Policy(struct soap *soap, const char *tag, wsp__Policy **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wsp__Policy **)soap_malloc(soap, sizeof(wsp__Policy *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wsp__Policy *)wsdl_instantiate_wsp__Policy(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wsp__Policy **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsp__Policy, sizeof(wsp__Policy), 0, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsp__Policy(struct soap *soap, wsp__Policy *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsp__Policy(soap, tag ? tag : "wsp:Policy", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wsp__Policy ** SOAP_FMAC4 soap_get_PointerTowsp__Policy(struct soap *soap, wsp__Policy **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsp__Policy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosd__staticServiceDataValues(struct soap *soap, sd__staticServiceDataValues *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_sd__staticServiceDataValues))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosd__staticServiceDataValues(struct soap *soap, const char *tag, int id, sd__staticServiceDataValues *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_sd__staticServiceDataValues, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_sd__staticServiceDataValues ? type : NULL);
}

SOAP_FMAC3 sd__staticServiceDataValues ** SOAP_FMAC4 soap_in_PointerTosd__staticServiceDataValues(struct soap *soap, const char *tag, sd__staticServiceDataValues **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (sd__staticServiceDataValues **)soap_malloc(soap, sizeof(sd__staticServiceDataValues *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (sd__staticServiceDataValues *)wsdl_instantiate_sd__staticServiceDataValues(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (sd__staticServiceDataValues **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_sd__staticServiceDataValues, sizeof(sd__staticServiceDataValues), 0, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosd__staticServiceDataValues(struct soap *soap, sd__staticServiceDataValues *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosd__staticServiceDataValues(soap, tag ? tag : "sd:staticServiceDataValues", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 sd__staticServiceDataValues ** SOAP_FMAC4 soap_get_PointerTosd__staticServiceDataValues(struct soap *soap, sd__staticServiceDataValues **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosd__staticServiceDataValues(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsdl__operation(struct soap *soap, wsdl__operation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsdl__operation))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsdl__operation(struct soap *soap, const char *tag, int id, wsdl__operation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsdl__operation, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wsdl__operation ? type : NULL);
}

SOAP_FMAC3 wsdl__operation ** SOAP_FMAC4 soap_in_PointerTowsdl__operation(struct soap *soap, const char *tag, wsdl__operation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wsdl__operation **)soap_malloc(soap, sizeof(wsdl__operation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wsdl__operation *)wsdl_instantiate_wsdl__operation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wsdl__operation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsdl__operation, sizeof(wsdl__operation), 0, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsdl__operation(struct soap *soap, wsdl__operation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsdl__operation(soap, tag ? tag : "wsdl:operation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wsdl__operation ** SOAP_FMAC4 soap_get_PointerTowsdl__operation(struct soap *soap, wsdl__operation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsdl__operation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosoap__body(struct soap *soap, soap__body *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_soap__body))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosoap__body(struct soap *soap, const char *tag, int id, soap__body *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_soap__body, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_soap__body ? type : NULL);
}

SOAP_FMAC3 soap__body ** SOAP_FMAC4 soap_in_PointerTosoap__body(struct soap *soap, const char *tag, soap__body **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (soap__body **)soap_malloc(soap, sizeof(soap__body *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (soap__body *)wsdl_instantiate_soap__body(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (soap__body **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_soap__body, sizeof(soap__body), 0, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosoap__body(struct soap *soap, soap__body *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosoap__body(soap, tag ? tag : "soap:body", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 soap__body ** SOAP_FMAC4 soap_get_PointerTosoap__body(struct soap *soap, soap__body **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosoap__body(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsdl__part(struct soap *soap, wsdl__part *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsdl__part))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsdl__part(struct soap *soap, const char *tag, int id, wsdl__part *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsdl__part, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wsdl__part ? type : NULL);
}

SOAP_FMAC3 wsdl__part ** SOAP_FMAC4 soap_in_PointerTowsdl__part(struct soap *soap, const char *tag, wsdl__part **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wsdl__part **)soap_malloc(soap, sizeof(wsdl__part *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wsdl__part *)wsdl_instantiate_wsdl__part(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wsdl__part **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsdl__part, sizeof(wsdl__part), 0, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsdl__part(struct soap *soap, wsdl__part *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsdl__part(soap, tag ? tag : "wsdl:part", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wsdl__part ** SOAP_FMAC4 soap_get_PointerTowsdl__part(struct soap *soap, wsdl__part **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsdl__part(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsdl__message(struct soap *soap, wsdl__message *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsdl__message))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsdl__message(struct soap *soap, const char *tag, int id, wsdl__message *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsdl__message, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wsdl__message ? type : NULL);
}

SOAP_FMAC3 wsdl__message ** SOAP_FMAC4 soap_in_PointerTowsdl__message(struct soap *soap, const char *tag, wsdl__message **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wsdl__message **)soap_malloc(soap, sizeof(wsdl__message *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wsdl__message *)wsdl_instantiate_wsdl__message(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wsdl__message **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsdl__message, sizeof(wsdl__message), 0, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsdl__message(struct soap *soap, wsdl__message *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsdl__message(soap, tag ? tag : "wsdl:message", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wsdl__message ** SOAP_FMAC4 soap_get_PointerTowsdl__message(struct soap *soap, wsdl__message **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsdl__message(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosoap__styleChoice(struct soap *soap, enum soap__styleChoice *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_soap__styleChoice);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosoap__styleChoice(struct soap *soap, const char *tag, int id, enum soap__styleChoice *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_soap__styleChoice, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_soap__styleChoice(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum soap__styleChoice ** SOAP_FMAC4 soap_in_PointerTosoap__styleChoice(struct soap *soap, const char *tag, enum soap__styleChoice **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum soap__styleChoice **)soap_malloc(soap, sizeof(enum soap__styleChoice *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_soap__styleChoice(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum soap__styleChoice **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_soap__styleChoice, sizeof(enum soap__styleChoice), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosoap__styleChoice(struct soap *soap, enum soap__styleChoice *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosoap__styleChoice(soap, tag ? tag : "soap:styleChoice", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum soap__styleChoice ** SOAP_FMAC4 soap_get_PointerTosoap__styleChoice(struct soap *soap, enum soap__styleChoice **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosoap__styleChoice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowadl__grammars(struct soap *soap, wadl__grammars *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wadl__grammars))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowadl__grammars(struct soap *soap, const char *tag, int id, wadl__grammars *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wadl__grammars, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wadl__grammars ? type : NULL);
}

SOAP_FMAC3 wadl__grammars ** SOAP_FMAC4 soap_in_PointerTowadl__grammars(struct soap *soap, const char *tag, wadl__grammars **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wadl__grammars **)soap_malloc(soap, sizeof(wadl__grammars *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wadl__grammars *)wsdl_instantiate_wadl__grammars(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wadl__grammars **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wadl__grammars, sizeof(wadl__grammars), 0, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowadl__grammars(struct soap *soap, wadl__grammars *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowadl__grammars(soap, tag ? tag : "wadl:grammars", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wadl__grammars ** SOAP_FMAC4 soap_get_PointerTowadl__grammars(struct soap *soap, wadl__grammars **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowadl__grammars(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowadl__resource(struct soap *soap, wadl__resource *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wadl__resource))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowadl__resource(struct soap *soap, const char *tag, int id, wadl__resource *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wadl__resource, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wadl__resource ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 wadl__resource ** SOAP_FMAC4 soap_in_PointerTowadl__resource(struct soap *soap, const char *tag, wadl__resource **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wadl__resource **)soap_malloc(soap, sizeof(wadl__resource *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wadl__resource *)wsdl_instantiate_wadl__resource(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wadl__resource **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wadl__resource, sizeof(wadl__resource), 0, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowadl__resource(struct soap *soap, wadl__resource *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowadl__resource(soap, tag ? tag : "wadl:resource", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wadl__resource ** SOAP_FMAC4 soap_get_PointerTowadl__resource(struct soap *soap, wadl__resource **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowadl__resource(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowadl__method(struct soap *soap, wadl__method *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wadl__method))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowadl__method(struct soap *soap, const char *tag, int id, wadl__method *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wadl__method, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wadl__method ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 wadl__method ** SOAP_FMAC4 soap_in_PointerTowadl__method(struct soap *soap, const char *tag, wadl__method **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wadl__method **)soap_malloc(soap, sizeof(wadl__method *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wadl__method *)wsdl_instantiate_wadl__method(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wadl__method **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wadl__method, sizeof(wadl__method), 0, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowadl__method(struct soap *soap, wadl__method *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowadl__method(soap, tag ? tag : "wadl:method", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wadl__method ** SOAP_FMAC4 soap_get_PointerTowadl__method(struct soap *soap, wadl__method **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowadl__method(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowadl__request(struct soap *soap, wadl__request *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wadl__request))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowadl__request(struct soap *soap, const char *tag, int id, wadl__request *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wadl__request, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wadl__request ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 wadl__request ** SOAP_FMAC4 soap_in_PointerTowadl__request(struct soap *soap, const char *tag, wadl__request **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wadl__request **)soap_malloc(soap, sizeof(wadl__request *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wadl__request *)wsdl_instantiate_wadl__request(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wadl__request **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wadl__request, sizeof(wadl__request), 0, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowadl__request(struct soap *soap, wadl__request *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowadl__request(soap, tag ? tag : "wadl:request", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wadl__request ** SOAP_FMAC4 soap_get_PointerTowadl__request(struct soap *soap, wadl__request **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowadl__request(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowadl__representation(struct soap *soap, wadl__representation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wadl__representation))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowadl__representation(struct soap *soap, const char *tag, int id, wadl__representation *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wadl__representation, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wadl__representation ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 wadl__representation ** SOAP_FMAC4 soap_in_PointerTowadl__representation(struct soap *soap, const char *tag, wadl__representation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wadl__representation **)soap_malloc(soap, sizeof(wadl__representation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wadl__representation *)wsdl_instantiate_wadl__representation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wadl__representation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wadl__representation, sizeof(wadl__representation), 0, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowadl__representation(struct soap *soap, wadl__representation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowadl__representation(soap, tag ? tag : "wadl:representation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wadl__representation ** SOAP_FMAC4 soap_get_PointerTowadl__representation(struct soap *soap, wadl__representation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowadl__representation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowadl__param(struct soap *soap, wadl__param *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wadl__param))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowadl__param(struct soap *soap, const char *tag, int id, wadl__param *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wadl__param, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wadl__param ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 wadl__param ** SOAP_FMAC4 soap_in_PointerTowadl__param(struct soap *soap, const char *tag, wadl__param **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wadl__param **)soap_malloc(soap, sizeof(wadl__param *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wadl__param *)wsdl_instantiate_wadl__param(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wadl__param **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wadl__param, sizeof(wadl__param), 0, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowadl__param(struct soap *soap, wadl__param *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowadl__param(soap, tag ? tag : "wadl:param", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wadl__param ** SOAP_FMAC4 soap_get_PointerTowadl__param(struct soap *soap, wadl__param **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowadl__param(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowadl__link(struct soap *soap, wadl__link *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wadl__link))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowadl__link(struct soap *soap, const char *tag, int id, wadl__link *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wadl__link, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wadl__link ? type : NULL);
}

SOAP_FMAC3 wadl__link ** SOAP_FMAC4 soap_in_PointerTowadl__link(struct soap *soap, const char *tag, wadl__link **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wadl__link **)soap_malloc(soap, sizeof(wadl__link *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wadl__link *)wsdl_instantiate_wadl__link(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wadl__link **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wadl__link, sizeof(wadl__link), 0, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowadl__link(struct soap *soap, wadl__link *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowadl__link(soap, tag ? tag : "wadl:link", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wadl__link ** SOAP_FMAC4 soap_get_PointerTowadl__link(struct soap *soap, wadl__link **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowadl__link(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowadl__ParamStyle(struct soap *soap, enum wadl__ParamStyle *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_wadl__ParamStyle);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowadl__ParamStyle(struct soap *soap, const char *tag, int id, enum wadl__ParamStyle *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wadl__ParamStyle, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wadl__ParamStyle(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum wadl__ParamStyle ** SOAP_FMAC4 soap_in_PointerTowadl__ParamStyle(struct soap *soap, const char *tag, enum wadl__ParamStyle **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum wadl__ParamStyle **)soap_malloc(soap, sizeof(enum wadl__ParamStyle *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wadl__ParamStyle(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum wadl__ParamStyle **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wadl__ParamStyle, sizeof(enum wadl__ParamStyle), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowadl__ParamStyle(struct soap *soap, enum wadl__ParamStyle *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowadl__ParamStyle(soap, tag ? tag : "wadl:ParamStyle", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum wadl__ParamStyle ** SOAP_FMAC4 soap_get_PointerTowadl__ParamStyle(struct soap *soap, enum wadl__ParamStyle **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowadl__ParamStyle(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowadl__resource_USCOREtype(struct soap *soap, wadl__resource_USCOREtype *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wadl__resource_USCOREtype))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowadl__resource_USCOREtype(struct soap *soap, const char *tag, int id, wadl__resource_USCOREtype *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wadl__resource_USCOREtype, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wadl__resource_USCOREtype ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 wadl__resource_USCOREtype ** SOAP_FMAC4 soap_in_PointerTowadl__resource_USCOREtype(struct soap *soap, const char *tag, wadl__resource_USCOREtype **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wadl__resource_USCOREtype **)soap_malloc(soap, sizeof(wadl__resource_USCOREtype *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wadl__resource_USCOREtype *)wsdl_instantiate_wadl__resource_USCOREtype(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wadl__resource_USCOREtype **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wadl__resource_USCOREtype, sizeof(wadl__resource_USCOREtype), 0, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowadl__resource_USCOREtype(struct soap *soap, wadl__resource_USCOREtype *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowadl__resource_USCOREtype(soap, tag ? tag : "wadl:resource_type", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wadl__resource_USCOREtype ** SOAP_FMAC4 soap_get_PointerTowadl__resource_USCOREtype(struct soap *soap, wadl__resource_USCOREtype **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowadl__resource_USCOREtype(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxs__complexContent(struct soap *soap, xs__complexContent *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xs__complexContent))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxs__complexContent(struct soap *soap, const char *tag, int id, xs__complexContent *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xs__complexContent, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_xs__complexContent ? type : NULL);
}

SOAP_FMAC3 xs__complexContent ** SOAP_FMAC4 soap_in_PointerToxs__complexContent(struct soap *soap, const char *tag, xs__complexContent **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (xs__complexContent **)soap_malloc(soap, sizeof(xs__complexContent *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (xs__complexContent *)wsdl_instantiate_xs__complexContent(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (xs__complexContent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xs__complexContent, sizeof(xs__complexContent), 0, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxs__complexContent(struct soap *soap, xs__complexContent *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxs__complexContent(soap, tag ? tag : "xs:complexContent", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 xs__complexContent ** SOAP_FMAC4 soap_get_PointerToxs__complexContent(struct soap *soap, xs__complexContent **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxs__complexContent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxs__simpleContent(struct soap *soap, xs__simpleContent *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xs__simpleContent))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxs__simpleContent(struct soap *soap, const char *tag, int id, xs__simpleContent *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xs__simpleContent, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_xs__simpleContent ? type : NULL);
}

SOAP_FMAC3 xs__simpleContent ** SOAP_FMAC4 soap_in_PointerToxs__simpleContent(struct soap *soap, const char *tag, xs__simpleContent **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (xs__simpleContent **)soap_malloc(soap, sizeof(xs__simpleContent *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (xs__simpleContent *)wsdl_instantiate_xs__simpleContent(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (xs__simpleContent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xs__simpleContent, sizeof(xs__simpleContent), 0, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxs__simpleContent(struct soap *soap, xs__simpleContent *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxs__simpleContent(soap, tag ? tag : "xs:simpleContent", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 xs__simpleContent ** SOAP_FMAC4 soap_get_PointerToxs__simpleContent(struct soap *soap, xs__simpleContent **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxs__simpleContent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxs__assert(struct soap *soap, xs__assert *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xs__assert))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxs__assert(struct soap *soap, const char *tag, int id, xs__assert *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xs__assert, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_xs__assert ? type : NULL);
}

SOAP_FMAC3 xs__assert ** SOAP_FMAC4 soap_in_PointerToxs__assert(struct soap *soap, const char *tag, xs__assert **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (xs__assert **)soap_malloc(soap, sizeof(xs__assert *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (xs__assert *)wsdl_instantiate_xs__assert(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (xs__assert **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xs__assert, sizeof(xs__assert), 0, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxs__assert(struct soap *soap, xs__assert *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxs__assert(soap, tag ? tag : "xs:assert", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 xs__assert ** SOAP_FMAC4 soap_get_PointerToxs__assert(struct soap *soap, xs__assert **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxs__assert(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxs__length(struct soap *soap, xs__length *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xs__length))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxs__length(struct soap *soap, const char *tag, int id, xs__length *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xs__length, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_xs__length ? type : NULL);
}

SOAP_FMAC3 xs__length ** SOAP_FMAC4 soap_in_PointerToxs__length(struct soap *soap, const char *tag, xs__length **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (xs__length **)soap_malloc(soap, sizeof(xs__length *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (xs__length *)wsdl_instantiate_xs__length(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (xs__length **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xs__length, sizeof(xs__length), 0, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxs__length(struct soap *soap, xs__length *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxs__length(soap, tag ? tag : "xs:length", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 xs__length ** SOAP_FMAC4 soap_get_PointerToxs__length(struct soap *soap, xs__length **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxs__length(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxs__whiteSpace(struct soap *soap, xs__whiteSpace *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xs__whiteSpace))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxs__whiteSpace(struct soap *soap, const char *tag, int id, xs__whiteSpace *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xs__whiteSpace, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_xs__whiteSpace ? type : NULL);
}

SOAP_FMAC3 xs__whiteSpace ** SOAP_FMAC4 soap_in_PointerToxs__whiteSpace(struct soap *soap, const char *tag, xs__whiteSpace **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (xs__whiteSpace **)soap_malloc(soap, sizeof(xs__whiteSpace *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (xs__whiteSpace *)wsdl_instantiate_xs__whiteSpace(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (xs__whiteSpace **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xs__whiteSpace, sizeof(xs__whiteSpace), 0, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxs__whiteSpace(struct soap *soap, xs__whiteSpace *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxs__whiteSpace(soap, tag ? tag : "xs:whiteSpace", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 xs__whiteSpace ** SOAP_FMAC4 soap_get_PointerToxs__whiteSpace(struct soap *soap, xs__whiteSpace **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxs__whiteSpace(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxs__union(struct soap *soap, xs__union *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xs__union))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxs__union(struct soap *soap, const char *tag, int id, xs__union *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xs__union, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_xs__union ? type : NULL);
}

SOAP_FMAC3 xs__union ** SOAP_FMAC4 soap_in_PointerToxs__union(struct soap *soap, const char *tag, xs__union **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (xs__union **)soap_malloc(soap, sizeof(xs__union *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (xs__union *)wsdl_instantiate_xs__union(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (xs__union **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xs__union, sizeof(xs__union), 0, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxs__union(struct soap *soap, xs__union *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxs__union(soap, tag ? tag : "xs:union", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 xs__union ** SOAP_FMAC4 soap_get_PointerToxs__union(struct soap *soap, xs__union **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxs__union(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxs__list(struct soap *soap, xs__list *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xs__list))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxs__list(struct soap *soap, const char *tag, int id, xs__list *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xs__list, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_xs__list ? type : NULL);
}

SOAP_FMAC3 xs__list ** SOAP_FMAC4 soap_in_PointerToxs__list(struct soap *soap, const char *tag, xs__list **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (xs__list **)soap_malloc(soap, sizeof(xs__list *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (xs__list *)wsdl_instantiate_xs__list(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (xs__list **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xs__list, sizeof(xs__list), 0, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxs__list(struct soap *soap, xs__list *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxs__list(soap, tag ? tag : "xs:list", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 xs__list ** SOAP_FMAC4 soap_get_PointerToxs__list(struct soap *soap, xs__list **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxs__list(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxs__restriction(struct soap *soap, xs__restriction *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xs__restriction))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxs__restriction(struct soap *soap, const char *tag, int id, xs__restriction *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xs__restriction, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_xs__restriction ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 xs__restriction ** SOAP_FMAC4 soap_in_PointerToxs__restriction(struct soap *soap, const char *tag, xs__restriction **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (xs__restriction **)soap_malloc(soap, sizeof(xs__restriction *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (xs__restriction *)wsdl_instantiate_xs__restriction(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (xs__restriction **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xs__restriction, sizeof(xs__restriction), 0, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxs__restriction(struct soap *soap, xs__restriction *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxs__restriction(soap, tag ? tag : "xs:restriction", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 xs__restriction ** SOAP_FMAC4 soap_get_PointerToxs__restriction(struct soap *soap, xs__restriction **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxs__restriction(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxs__extension(struct soap *soap, xs__extension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xs__extension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxs__extension(struct soap *soap, const char *tag, int id, xs__extension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xs__extension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_xs__extension ? type : NULL);
}

SOAP_FMAC3 xs__extension ** SOAP_FMAC4 soap_in_PointerToxs__extension(struct soap *soap, const char *tag, xs__extension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (xs__extension **)soap_malloc(soap, sizeof(xs__extension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (xs__extension *)wsdl_instantiate_xs__extension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (xs__extension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xs__extension, sizeof(xs__extension), 0, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxs__extension(struct soap *soap, xs__extension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxs__extension(soap, tag ? tag : "xs:extension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 xs__extension ** SOAP_FMAC4 soap_get_PointerToxs__extension(struct soap *soap, xs__extension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxs__extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxs__attributeGroup(struct soap *soap, xs__attributeGroup *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xs__attributeGroup))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxs__attributeGroup(struct soap *soap, const char *tag, int id, xs__attributeGroup *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xs__attributeGroup, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_xs__attributeGroup ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 xs__attributeGroup ** SOAP_FMAC4 soap_in_PointerToxs__attributeGroup(struct soap *soap, const char *tag, xs__attributeGroup **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (xs__attributeGroup **)soap_malloc(soap, sizeof(xs__attributeGroup *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (xs__attributeGroup *)wsdl_instantiate_xs__attributeGroup(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (xs__attributeGroup **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xs__attributeGroup, sizeof(xs__attributeGroup), 0, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxs__attributeGroup(struct soap *soap, xs__attributeGroup *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxs__attributeGroup(soap, tag ? tag : "xs:attributeGroup", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 xs__attributeGroup ** SOAP_FMAC4 soap_get_PointerToxs__attributeGroup(struct soap *soap, xs__attributeGroup **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxs__attributeGroup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxs__anyAttribute(struct soap *soap, xs__anyAttribute *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xs__anyAttribute))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxs__anyAttribute(struct soap *soap, const char *tag, int id, xs__anyAttribute *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xs__anyAttribute, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_xs__anyAttribute ? type : NULL);
}

SOAP_FMAC3 xs__anyAttribute ** SOAP_FMAC4 soap_in_PointerToxs__anyAttribute(struct soap *soap, const char *tag, xs__anyAttribute **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (xs__anyAttribute **)soap_malloc(soap, sizeof(xs__anyAttribute *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (xs__anyAttribute *)wsdl_instantiate_xs__anyAttribute(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (xs__anyAttribute **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xs__anyAttribute, sizeof(xs__anyAttribute), 0, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxs__anyAttribute(struct soap *soap, xs__anyAttribute *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxs__anyAttribute(soap, tag ? tag : "xs:anyAttribute", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 xs__anyAttribute ** SOAP_FMAC4 soap_get_PointerToxs__anyAttribute(struct soap *soap, xs__anyAttribute **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxs__anyAttribute(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxs__all(struct soap *soap, xs__all *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xs__all))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxs__all(struct soap *soap, const char *tag, int id, xs__all *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xs__all, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_xs__all ? type : NULL);
}

SOAP_FMAC3 xs__all ** SOAP_FMAC4 soap_in_PointerToxs__all(struct soap *soap, const char *tag, xs__all **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (xs__all **)soap_malloc(soap, sizeof(xs__all *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (xs__all *)wsdl_instantiate_xs__all(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (xs__all **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xs__all, sizeof(xs__all), 0, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxs__all(struct soap *soap, xs__all *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxs__all(soap, tag ? tag : "xs:all", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 xs__all ** SOAP_FMAC4 soap_get_PointerToxs__all(struct soap *soap, xs__all **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxs__all(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxs__any(struct soap *soap, xs__any *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xs__any))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxs__any(struct soap *soap, const char *tag, int id, xs__any *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xs__any, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_xs__any ? type : NULL);
}

SOAP_FMAC3 xs__any ** SOAP_FMAC4 soap_in_PointerToxs__any(struct soap *soap, const char *tag, xs__any **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (xs__any **)soap_malloc(soap, sizeof(xs__any *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (xs__any *)wsdl_instantiate_xs__any(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (xs__any **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xs__any, sizeof(xs__any), 0, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxs__any(struct soap *soap, xs__any *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxs__any(soap, tag ? tag : "xs:any", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 xs__any ** SOAP_FMAC4 soap_get_PointerToxs__any(struct soap *soap, xs__any **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxs__any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxs__seqchoice(struct soap *soap, xs__seqchoice *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xs__seqchoice))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxs__seqchoice(struct soap *soap, const char *tag, int id, xs__seqchoice *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xs__seqchoice, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_xs__seqchoice ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 xs__seqchoice ** SOAP_FMAC4 soap_in_PointerToxs__seqchoice(struct soap *soap, const char *tag, xs__seqchoice **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (xs__seqchoice **)soap_malloc(soap, sizeof(xs__seqchoice *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (xs__seqchoice *)wsdl_instantiate_xs__seqchoice(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (xs__seqchoice **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xs__seqchoice, sizeof(xs__seqchoice), 0, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxs__seqchoice(struct soap *soap, xs__seqchoice *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxs__seqchoice(soap, tag ? tag : "xs:seqchoice", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 xs__seqchoice ** SOAP_FMAC4 soap_get_PointerToxs__seqchoice(struct soap *soap, xs__seqchoice **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxs__seqchoice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxs__group(struct soap *soap, xs__group *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xs__group))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxs__group(struct soap *soap, const char *tag, int id, xs__group *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xs__group, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_xs__group ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 xs__group ** SOAP_FMAC4 soap_in_PointerToxs__group(struct soap *soap, const char *tag, xs__group **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (xs__group **)soap_malloc(soap, sizeof(xs__group *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (xs__group *)wsdl_instantiate_xs__group(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (xs__group **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xs__group, sizeof(xs__group), 0, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxs__group(struct soap *soap, xs__group *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxs__group(soap, tag ? tag : "xs:group", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 xs__group ** SOAP_FMAC4 soap_get_PointerToxs__group(struct soap *soap, xs__group **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxs__group(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xs__namespaceList(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_xs__namespaceList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xs__namespaceList(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xs__namespaceList);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xs__namespaceList(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_xs__namespaceList, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xs__namespaceList(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_xs__namespaceList(soap, tag ? tag : "xs:namespaceList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xs__namespaceList(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xs__namespaceList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxs__attribute(struct soap *soap, xs__attribute *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xs__attribute))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxs__attribute(struct soap *soap, const char *tag, int id, xs__attribute *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xs__attribute, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_xs__attribute ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 xs__attribute ** SOAP_FMAC4 soap_in_PointerToxs__attribute(struct soap *soap, const char *tag, xs__attribute **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (xs__attribute **)soap_malloc(soap, sizeof(xs__attribute *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (xs__attribute *)wsdl_instantiate_xs__attribute(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (xs__attribute **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xs__attribute, sizeof(xs__attribute), 0, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxs__attribute(struct soap *soap, xs__attribute *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxs__attribute(soap, tag ? tag : "xs:attribute", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 xs__attribute ** SOAP_FMAC4 soap_get_PointerToxs__attribute(struct soap *soap, xs__attribute **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxs__attribute(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__vectorTemplateOfPointerToxs__element(struct soap *soap, std::vector<xs__element *> *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_std__vectorTemplateOfPointerToxs__element))
		soap_serialize_std__vectorTemplateOfPointerToxs__element(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__vectorTemplateOfPointerToxs__element(struct soap *soap, const char *tag, int id, std::vector<xs__element *> *const*a, const char *type)
{
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	return soap_out_std__vectorTemplateOfPointerToxs__element(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::vector<xs__element *> ** SOAP_FMAC4 soap_in_PointerTostd__vectorTemplateOfPointerToxs__element(struct soap *soap, const char *tag, std::vector<xs__element *> **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	soap_revert(soap);
	if (!a)
	{	if (!(a = (std::vector<xs__element *> **)soap_malloc(soap, sizeof(std::vector<xs__element *> *))))
			return NULL;
		*a = NULL;
	}
	if (!(*a = soap_in_std__vectorTemplateOfPointerToxs__element(soap, tag, *a, type)))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__vectorTemplateOfPointerToxs__element(struct soap *soap, std::vector<xs__element *> *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTostd__vectorTemplateOfPointerToxs__element(soap, tag ? tag : "", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::vector<xs__element *> ** SOAP_FMAC4 soap_get_PointerTostd__vectorTemplateOfPointerToxs__element(struct soap *soap, std::vector<xs__element *> **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__vectorTemplateOfPointerToxs__element(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxs__element(struct soap *soap, xs__element *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xs__element))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxs__element(struct soap *soap, const char *tag, int id, xs__element *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xs__element, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_xs__element ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 xs__element ** SOAP_FMAC4 soap_in_PointerToxs__element(struct soap *soap, const char *tag, xs__element **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (xs__element **)soap_malloc(soap, sizeof(xs__element *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (xs__element *)wsdl_instantiate_xs__element(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (xs__element **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xs__element, sizeof(xs__element), 0, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxs__element(struct soap *soap, xs__element *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxs__element(soap, tag ? tag : "xs:element", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 xs__element ** SOAP_FMAC4 soap_get_PointerToxs__element(struct soap *soap, xs__element **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxs__element(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxs__schema(struct soap *soap, xs__schema *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xs__schema))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxs__schema(struct soap *soap, const char *tag, int id, xs__schema *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xs__schema, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_xs__schema ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 xs__schema ** SOAP_FMAC4 soap_in_PointerToxs__schema(struct soap *soap, const char *tag, xs__schema **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (xs__schema **)soap_malloc(soap, sizeof(xs__schema *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (xs__schema *)wsdl_instantiate_xs__schema(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (xs__schema **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xs__schema, sizeof(xs__schema), 0, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxs__schema(struct soap *soap, xs__schema *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxs__schema(soap, tag ? tag : "xs:schema", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 xs__schema ** SOAP_FMAC4 soap_get_PointerToxs__schema(struct soap *soap, xs__schema **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxs__schema(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxs__complexType(struct soap *soap, xs__complexType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xs__complexType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxs__complexType(struct soap *soap, const char *tag, int id, xs__complexType *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xs__complexType, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_xs__complexType ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 xs__complexType ** SOAP_FMAC4 soap_in_PointerToxs__complexType(struct soap *soap, const char *tag, xs__complexType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (xs__complexType **)soap_malloc(soap, sizeof(xs__complexType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (xs__complexType *)wsdl_instantiate_xs__complexType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (xs__complexType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xs__complexType, sizeof(xs__complexType), 0, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxs__complexType(struct soap *soap, xs__complexType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxs__complexType(soap, tag ? tag : "xs:complexType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 xs__complexType ** SOAP_FMAC4 soap_get_PointerToxs__complexType(struct soap *soap, xs__complexType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxs__complexType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxs__simpleType(struct soap *soap, xs__simpleType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xs__simpleType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxs__simpleType(struct soap *soap, const char *tag, int id, xs__simpleType *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xs__simpleType, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_xs__simpleType ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 xs__simpleType ** SOAP_FMAC4 soap_in_PointerToxs__simpleType(struct soap *soap, const char *tag, xs__simpleType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (xs__simpleType **)soap_malloc(soap, sizeof(xs__simpleType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (xs__simpleType *)wsdl_instantiate_xs__simpleType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (xs__simpleType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xs__simpleType, sizeof(xs__simpleType), 0, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxs__simpleType(struct soap *soap, xs__simpleType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxs__simpleType(soap, tag ? tag : "xs:simpleType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 xs__simpleType ** SOAP_FMAC4 soap_get_PointerToxs__simpleType(struct soap *soap, xs__simpleType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxs__simpleType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxs__formChoice(struct soap *soap, enum xs__formChoice *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_xs__formChoice);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxs__formChoice(struct soap *soap, const char *tag, int id, enum xs__formChoice *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xs__formChoice, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_xs__formChoice(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum xs__formChoice ** SOAP_FMAC4 soap_in_PointerToxs__formChoice(struct soap *soap, const char *tag, enum xs__formChoice **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum xs__formChoice **)soap_malloc(soap, sizeof(enum xs__formChoice *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xs__formChoice(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum xs__formChoice **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xs__formChoice, sizeof(enum xs__formChoice), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxs__formChoice(struct soap *soap, enum xs__formChoice *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxs__formChoice(soap, tag ? tag : "xs:formChoice", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum xs__formChoice ** SOAP_FMAC4 soap_get_PointerToxs__formChoice(struct soap *soap, enum xs__formChoice **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxs__formChoice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxs__annotation(struct soap *soap, xs__annotation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xs__annotation))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxs__annotation(struct soap *soap, const char *tag, int id, xs__annotation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xs__annotation, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_xs__annotation ? type : NULL);
}

SOAP_FMAC3 xs__annotation ** SOAP_FMAC4 soap_in_PointerToxs__annotation(struct soap *soap, const char *tag, xs__annotation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (xs__annotation **)soap_malloc(soap, sizeof(xs__annotation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (xs__annotation *)wsdl_instantiate_xs__annotation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (xs__annotation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xs__annotation, sizeof(xs__annotation), 0, wsdl_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxs__annotation(struct soap *soap, xs__annotation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxs__annotation(soap, tag ? tag : "xs:annotation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 xs__annotation ** SOAP_FMAC4 soap_get_PointerToxs__annotation(struct soap *soap, xs__annotation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxs__annotation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__string(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_xsd__string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__string(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__string, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_xsd__string(soap, tag ? tag : "xsd:string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__token(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_xsd__token);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__token(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__token);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__token(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__token, 5, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__token(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_xsd__token(soap, tag ? tag : "xsd:token", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__token(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__token(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__QName(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_xsd__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__QName, 2, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_xsd__QName(soap, tag ? tag : "xsd:QName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__NMTOKENS(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_xsd__NMTOKENS);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__NMTOKENS(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__NMTOKENS);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__NMTOKENS(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__NMTOKENS, 5, 0, -1, "(\\c+[ ])*\\c+");
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__NMTOKENS(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_xsd__NMTOKENS(soap, tag ? tag : "xsd:NMTOKENS", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__NMTOKENS(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__NMTOKENS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__NMTOKEN(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_xsd__NMTOKEN);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__NMTOKEN(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__NMTOKEN);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__NMTOKEN(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__NMTOKEN, 5, 0, -1, "\\c+");
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__NMTOKEN(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_xsd__NMTOKEN(soap, tag ? tag : "xsd:NMTOKEN", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__NMTOKEN(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__NMTOKEN(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__NCName(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_xsd__NCName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__NCName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__NCName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__NCName(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__NCName, 5, 0, -1, "[\\i-[:]][\\c-[:]]*");
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__NCName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_xsd__NCName(soap, tag ? tag : "xsd:NCName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__NCName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__NCName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__ID(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_xsd__ID);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__ID(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__ID);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__ID(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__ID, 5, 0, -1, "[\\i-[:]][\\c-[:]]*");
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__ID(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_xsd__ID(soap, tag ? tag : "xsd:ID", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__ID(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__ID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__anyURI(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_xsd__anyURI);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anyURI(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__anyURI);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__anyURI(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__anyURI, 4, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__anyURI(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_xsd__anyURI(soap, tag ? tag : "xsd:anyURI", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__anyURI(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anyURI(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__QName(soap, tag ? tag : "QName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_new_string(struct soap *soap, int n)
{
	char * *a = static_cast<char * *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(char *)));
	for (char * *p = a; p && n--; ++p)
		soap_default_string(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfgwsdl__portType(struct soap *soap, std::vector<gwsdl__portType> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfgwsdl__portType(struct soap *soap, const std::vector<gwsdl__portType> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<gwsdl__portType> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfgwsdl__portType(struct soap *soap, const char *tag, int id, const std::vector<gwsdl__portType> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<gwsdl__portType> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<gwsdl__portType> * SOAP_FMAC4 soap_in_std__vectorTemplateOfgwsdl__portType(struct soap *soap, const char *tag, std::vector<gwsdl__portType> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfgwsdl__portType(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		gwsdl__portType n;
		n.soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_gwsdl__portType, SOAP_TYPE_std__vectorTemplateOfgwsdl__portType, sizeof(gwsdl__portType), 0, wsdl_finsert, wsdl_fbase))
				break;
			if (!soap_in_gwsdl__portType(soap, tag, NULL, "gwsdl:portType"))
				break;
		}
		else
		{	if (!soap_in_gwsdl__portType(soap, tag, &n, "gwsdl:portType"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(gwsdl__portType));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(gwsdl__portType));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(gwsdl__portType));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<gwsdl__portType>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfgwsdl__portType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_std__vectorTemplateOfgwsdl__portType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<gwsdl__portType> *p;
	size_t k = sizeof(std::vector<gwsdl__portType> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<gwsdl__portType> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<gwsdl__portType> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<gwsdl__portType>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfgwsdl__portType, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfvprop__tPropertyAlias(struct soap *soap, std::vector<vprop__tPropertyAlias> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfvprop__tPropertyAlias(struct soap *soap, const std::vector<vprop__tPropertyAlias> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<vprop__tPropertyAlias> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfvprop__tPropertyAlias(struct soap *soap, const char *tag, int id, const std::vector<vprop__tPropertyAlias> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<vprop__tPropertyAlias> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<vprop__tPropertyAlias> * SOAP_FMAC4 soap_in_std__vectorTemplateOfvprop__tPropertyAlias(struct soap *soap, const char *tag, std::vector<vprop__tPropertyAlias> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfvprop__tPropertyAlias(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		vprop__tPropertyAlias n;
		n.soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_vprop__tPropertyAlias, SOAP_TYPE_std__vectorTemplateOfvprop__tPropertyAlias, sizeof(vprop__tPropertyAlias), 0, wsdl_finsert, wsdl_fbase))
				break;
			if (!soap_in_vprop__tPropertyAlias(soap, tag, NULL, "vprop:tPropertyAlias"))
				break;
		}
		else
		{	if (!soap_in_vprop__tPropertyAlias(soap, tag, &n, "vprop:tPropertyAlias"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(vprop__tPropertyAlias));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(vprop__tPropertyAlias));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(vprop__tPropertyAlias));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<vprop__tPropertyAlias>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfvprop__tPropertyAlias(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_std__vectorTemplateOfvprop__tPropertyAlias(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<vprop__tPropertyAlias> *p;
	size_t k = sizeof(std::vector<vprop__tPropertyAlias> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<vprop__tPropertyAlias> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<vprop__tPropertyAlias> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<vprop__tPropertyAlias>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfvprop__tPropertyAlias, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfvprop__tProperty(struct soap *soap, std::vector<vprop__tProperty> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfvprop__tProperty(struct soap *soap, const std::vector<vprop__tProperty> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<vprop__tProperty> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfvprop__tProperty(struct soap *soap, const char *tag, int id, const std::vector<vprop__tProperty> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<vprop__tProperty> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<vprop__tProperty> * SOAP_FMAC4 soap_in_std__vectorTemplateOfvprop__tProperty(struct soap *soap, const char *tag, std::vector<vprop__tProperty> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfvprop__tProperty(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		vprop__tProperty n;
		n.soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_vprop__tProperty, SOAP_TYPE_std__vectorTemplateOfvprop__tProperty, sizeof(vprop__tProperty), 0, wsdl_finsert, wsdl_fbase))
				break;
			if (!soap_in_vprop__tProperty(soap, tag, NULL, "vprop:tProperty"))
				break;
		}
		else
		{	if (!soap_in_vprop__tProperty(soap, tag, &n, "vprop:tProperty"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(vprop__tProperty));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(vprop__tProperty));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(vprop__tProperty));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<vprop__tProperty>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfvprop__tProperty(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_std__vectorTemplateOfvprop__tProperty(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<vprop__tProperty> *p;
	size_t k = sizeof(std::vector<vprop__tProperty> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<vprop__tProperty> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<vprop__tProperty> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<vprop__tProperty>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfvprop__tProperty, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfplnk__tPartnerLinkType(struct soap *soap, std::vector<plnk__tPartnerLinkType> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfplnk__tPartnerLinkType(struct soap *soap, const std::vector<plnk__tPartnerLinkType> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<plnk__tPartnerLinkType> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfplnk__tPartnerLinkType(struct soap *soap, const char *tag, int id, const std::vector<plnk__tPartnerLinkType> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<plnk__tPartnerLinkType> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<plnk__tPartnerLinkType> * SOAP_FMAC4 soap_in_std__vectorTemplateOfplnk__tPartnerLinkType(struct soap *soap, const char *tag, std::vector<plnk__tPartnerLinkType> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfplnk__tPartnerLinkType(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		plnk__tPartnerLinkType n;
		n.soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_plnk__tPartnerLinkType, SOAP_TYPE_std__vectorTemplateOfplnk__tPartnerLinkType, sizeof(plnk__tPartnerLinkType), 0, wsdl_finsert, wsdl_fbase))
				break;
			if (!soap_in_plnk__tPartnerLinkType(soap, tag, NULL, "plnk:tPartnerLinkType"))
				break;
		}
		else
		{	if (!soap_in_plnk__tPartnerLinkType(soap, tag, &n, "plnk:tPartnerLinkType"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(plnk__tPartnerLinkType));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(plnk__tPartnerLinkType));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(plnk__tPartnerLinkType));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<plnk__tPartnerLinkType>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfplnk__tPartnerLinkType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_std__vectorTemplateOfplnk__tPartnerLinkType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<plnk__tPartnerLinkType> *p;
	size_t k = sizeof(std::vector<plnk__tPartnerLinkType> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<plnk__tPartnerLinkType> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<plnk__tPartnerLinkType> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<plnk__tPartnerLinkType>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfplnk__tPartnerLinkType, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfwsdl__service(struct soap *soap, std::vector<wsdl__service> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfwsdl__service(struct soap *soap, const std::vector<wsdl__service> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<wsdl__service> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfwsdl__service(struct soap *soap, const char *tag, int id, const std::vector<wsdl__service> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<wsdl__service> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<wsdl__service> * SOAP_FMAC4 soap_in_std__vectorTemplateOfwsdl__service(struct soap *soap, const char *tag, std::vector<wsdl__service> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfwsdl__service(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		wsdl__service n;
		n.soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_wsdl__service, SOAP_TYPE_std__vectorTemplateOfwsdl__service, sizeof(wsdl__service), 0, wsdl_finsert, wsdl_fbase))
				break;
			if (!soap_in_wsdl__service(soap, tag, NULL, "wsdl:service"))
				break;
		}
		else
		{	if (!soap_in_wsdl__service(soap, tag, &n, "wsdl:service"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(wsdl__service));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(wsdl__service));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(wsdl__service));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<wsdl__service>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfwsdl__service(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_std__vectorTemplateOfwsdl__service(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<wsdl__service> *p;
	size_t k = sizeof(std::vector<wsdl__service> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<wsdl__service> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<wsdl__service> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<wsdl__service>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfwsdl__service, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfwsdl__binding(struct soap *soap, std::vector<wsdl__binding> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfwsdl__binding(struct soap *soap, const std::vector<wsdl__binding> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<wsdl__binding> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfwsdl__binding(struct soap *soap, const char *tag, int id, const std::vector<wsdl__binding> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<wsdl__binding> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<wsdl__binding> * SOAP_FMAC4 soap_in_std__vectorTemplateOfwsdl__binding(struct soap *soap, const char *tag, std::vector<wsdl__binding> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfwsdl__binding(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		wsdl__binding n;
		n.soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_wsdl__binding, SOAP_TYPE_std__vectorTemplateOfwsdl__binding, sizeof(wsdl__binding), 0, wsdl_finsert, wsdl_fbase))
				break;
			if (!soap_in_wsdl__binding(soap, tag, NULL, "wsdl:binding"))
				break;
		}
		else
		{	if (!soap_in_wsdl__binding(soap, tag, &n, "wsdl:binding"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(wsdl__binding));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(wsdl__binding));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(wsdl__binding));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<wsdl__binding>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfwsdl__binding(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_std__vectorTemplateOfwsdl__binding(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<wsdl__binding> *p;
	size_t k = sizeof(std::vector<wsdl__binding> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<wsdl__binding> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<wsdl__binding> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<wsdl__binding>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfwsdl__binding, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfwsdl__portType(struct soap *soap, std::vector<wsdl__portType> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfwsdl__portType(struct soap *soap, const std::vector<wsdl__portType> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<wsdl__portType> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfwsdl__portType(struct soap *soap, const char *tag, int id, const std::vector<wsdl__portType> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<wsdl__portType> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<wsdl__portType> * SOAP_FMAC4 soap_in_std__vectorTemplateOfwsdl__portType(struct soap *soap, const char *tag, std::vector<wsdl__portType> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfwsdl__portType(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		wsdl__portType n;
		n.soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_wsdl__portType, SOAP_TYPE_std__vectorTemplateOfwsdl__portType, sizeof(wsdl__portType), 0, wsdl_finsert, wsdl_fbase))
				break;
			if (!soap_in_wsdl__portType(soap, tag, NULL, "wsdl:portType"))
				break;
		}
		else
		{	if (!soap_in_wsdl__portType(soap, tag, &n, "wsdl:portType"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(wsdl__portType));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(wsdl__portType));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(wsdl__portType));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<wsdl__portType>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfwsdl__portType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_std__vectorTemplateOfwsdl__portType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<wsdl__portType> *p;
	size_t k = sizeof(std::vector<wsdl__portType> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<wsdl__portType> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<wsdl__portType> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<wsdl__portType>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfwsdl__portType, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfwsdl__message(struct soap *soap, std::vector<wsdl__message> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfwsdl__message(struct soap *soap, const std::vector<wsdl__message> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<wsdl__message> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfwsdl__message(struct soap *soap, const char *tag, int id, const std::vector<wsdl__message> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<wsdl__message> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<wsdl__message> * SOAP_FMAC4 soap_in_std__vectorTemplateOfwsdl__message(struct soap *soap, const char *tag, std::vector<wsdl__message> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfwsdl__message(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		wsdl__message n;
		n.soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_wsdl__message, SOAP_TYPE_std__vectorTemplateOfwsdl__message, sizeof(wsdl__message), 0, wsdl_finsert, wsdl_fbase))
				break;
			if (!soap_in_wsdl__message(soap, tag, NULL, "wsdl:message"))
				break;
		}
		else
		{	if (!soap_in_wsdl__message(soap, tag, &n, "wsdl:message"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(wsdl__message));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(wsdl__message));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(wsdl__message));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<wsdl__message>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfwsdl__message(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_std__vectorTemplateOfwsdl__message(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<wsdl__message> *p;
	size_t k = sizeof(std::vector<wsdl__message> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<wsdl__message> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<wsdl__message> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<wsdl__message>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfwsdl__message, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfwsdl__import(struct soap *soap, std::vector<wsdl__import> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfwsdl__import(struct soap *soap, const std::vector<wsdl__import> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<wsdl__import> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfwsdl__import(struct soap *soap, const char *tag, int id, const std::vector<wsdl__import> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<wsdl__import> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<wsdl__import> * SOAP_FMAC4 soap_in_std__vectorTemplateOfwsdl__import(struct soap *soap, const char *tag, std::vector<wsdl__import> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfwsdl__import(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		wsdl__import n;
		n.soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_wsdl__import, SOAP_TYPE_std__vectorTemplateOfwsdl__import, sizeof(wsdl__import), 0, wsdl_finsert, wsdl_fbase))
				break;
			if (!soap_in_wsdl__import(soap, tag, NULL, "wsdl:import"))
				break;
		}
		else
		{	if (!soap_in_wsdl__import(soap, tag, &n, "wsdl:import"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(wsdl__import));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(wsdl__import));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(wsdl__import));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<wsdl__import>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfwsdl__import(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_std__vectorTemplateOfwsdl__import(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<wsdl__import> *p;
	size_t k = sizeof(std::vector<wsdl__import> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<wsdl__import> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<wsdl__import> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<wsdl__import>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfwsdl__import, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfwsdl__port(struct soap *soap, std::vector<wsdl__port> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfwsdl__port(struct soap *soap, const std::vector<wsdl__port> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<wsdl__port> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfwsdl__port(struct soap *soap, const char *tag, int id, const std::vector<wsdl__port> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<wsdl__port> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<wsdl__port> * SOAP_FMAC4 soap_in_std__vectorTemplateOfwsdl__port(struct soap *soap, const char *tag, std::vector<wsdl__port> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfwsdl__port(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		wsdl__port n;
		n.soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_wsdl__port, SOAP_TYPE_std__vectorTemplateOfwsdl__port, sizeof(wsdl__port), 0, wsdl_finsert, wsdl_fbase))
				break;
			if (!soap_in_wsdl__port(soap, tag, NULL, "wsdl:port"))
				break;
		}
		else
		{	if (!soap_in_wsdl__port(soap, tag, &n, "wsdl:port"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(wsdl__port));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(wsdl__port));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(wsdl__port));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<wsdl__port>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfwsdl__port(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_std__vectorTemplateOfwsdl__port(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<wsdl__port> *p;
	size_t k = sizeof(std::vector<wsdl__port> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<wsdl__port> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<wsdl__port> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<wsdl__port>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfwsdl__port, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfwsdl__ext_operation(struct soap *soap, std::vector<wsdl__ext_operation> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfwsdl__ext_operation(struct soap *soap, const std::vector<wsdl__ext_operation> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<wsdl__ext_operation> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfwsdl__ext_operation(struct soap *soap, const char *tag, int id, const std::vector<wsdl__ext_operation> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<wsdl__ext_operation> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<wsdl__ext_operation> * SOAP_FMAC4 soap_in_std__vectorTemplateOfwsdl__ext_operation(struct soap *soap, const char *tag, std::vector<wsdl__ext_operation> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfwsdl__ext_operation(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		wsdl__ext_operation n;
		n.soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_wsdl__ext_operation, SOAP_TYPE_std__vectorTemplateOfwsdl__ext_operation, sizeof(wsdl__ext_operation), 0, wsdl_finsert, wsdl_fbase))
				break;
			if (!soap_in_wsdl__ext_operation(soap, tag, NULL, "wsdl:ext-operation"))
				break;
		}
		else
		{	if (!soap_in_wsdl__ext_operation(soap, tag, &n, "wsdl:ext-operation"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(wsdl__ext_operation));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(wsdl__ext_operation));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(wsdl__ext_operation));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<wsdl__ext_operation>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfwsdl__ext_operation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_std__vectorTemplateOfwsdl__ext_operation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<wsdl__ext_operation> *p;
	size_t k = sizeof(std::vector<wsdl__ext_operation> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<wsdl__ext_operation> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<wsdl__ext_operation> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<wsdl__ext_operation>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfwsdl__ext_operation, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfwsdl__ext_fault(struct soap *soap, std::vector<wsdl__ext_fault> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfwsdl__ext_fault(struct soap *soap, const std::vector<wsdl__ext_fault> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<wsdl__ext_fault> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfwsdl__ext_fault(struct soap *soap, const char *tag, int id, const std::vector<wsdl__ext_fault> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<wsdl__ext_fault> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<wsdl__ext_fault> * SOAP_FMAC4 soap_in_std__vectorTemplateOfwsdl__ext_fault(struct soap *soap, const char *tag, std::vector<wsdl__ext_fault> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfwsdl__ext_fault(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		wsdl__ext_fault n;
		n.soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_wsdl__ext_fault, SOAP_TYPE_std__vectorTemplateOfwsdl__ext_fault, sizeof(wsdl__ext_fault), 0, wsdl_finsert, wsdl_fbase))
				break;
			if (!soap_in_wsdl__ext_fault(soap, tag, NULL, "wsdl:ext-fault"))
				break;
		}
		else
		{	if (!soap_in_wsdl__ext_fault(soap, tag, &n, "wsdl:ext-fault"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(wsdl__ext_fault));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(wsdl__ext_fault));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(wsdl__ext_fault));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<wsdl__ext_fault>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfwsdl__ext_fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_std__vectorTemplateOfwsdl__ext_fault(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<wsdl__ext_fault> *p;
	size_t k = sizeof(std::vector<wsdl__ext_fault> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<wsdl__ext_fault> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<wsdl__ext_fault> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<wsdl__ext_fault>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfwsdl__ext_fault, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfwhttp__header(struct soap *soap, std::vector<whttp__header> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfwhttp__header(struct soap *soap, const std::vector<whttp__header> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<whttp__header> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfwhttp__header(struct soap *soap, const char *tag, int id, const std::vector<whttp__header> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<whttp__header> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<whttp__header> * SOAP_FMAC4 soap_in_std__vectorTemplateOfwhttp__header(struct soap *soap, const char *tag, std::vector<whttp__header> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfwhttp__header(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		whttp__header n;
		n.soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_whttp__header, SOAP_TYPE_std__vectorTemplateOfwhttp__header, sizeof(whttp__header), 0, wsdl_finsert, wsdl_fbase))
				break;
			if (!soap_in_whttp__header(soap, tag, NULL, "whttp:header"))
				break;
		}
		else
		{	if (!soap_in_whttp__header(soap, tag, &n, "whttp:header"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(whttp__header));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(whttp__header));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(whttp__header));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<whttp__header>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfwhttp__header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_std__vectorTemplateOfwhttp__header(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<whttp__header> *p;
	size_t k = sizeof(std::vector<whttp__header> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<whttp__header> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<whttp__header> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<whttp__header>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfwhttp__header, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfwsoap__header(struct soap *soap, std::vector<wsoap__header> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfwsoap__header(struct soap *soap, const std::vector<wsoap__header> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<wsoap__header> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfwsoap__header(struct soap *soap, const char *tag, int id, const std::vector<wsoap__header> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<wsoap__header> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<wsoap__header> * SOAP_FMAC4 soap_in_std__vectorTemplateOfwsoap__header(struct soap *soap, const char *tag, std::vector<wsoap__header> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfwsoap__header(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		wsoap__header n;
		n.soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_wsoap__header, SOAP_TYPE_std__vectorTemplateOfwsoap__header, sizeof(wsoap__header), 0, wsdl_finsert, wsdl_fbase))
				break;
			if (!soap_in_wsoap__header(soap, tag, NULL, "wsoap:header"))
				break;
		}
		else
		{	if (!soap_in_wsoap__header(soap, tag, &n, "wsoap:header"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(wsoap__header));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(wsoap__header));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(wsoap__header));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<wsoap__header>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfwsoap__header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_std__vectorTemplateOfwsoap__header(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<wsoap__header> *p;
	size_t k = sizeof(std::vector<wsoap__header> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<wsoap__header> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<wsoap__header> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<wsoap__header>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfwsoap__header, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfwsoap__module(struct soap *soap, std::vector<wsoap__module> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfwsoap__module(struct soap *soap, const std::vector<wsoap__module> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<wsoap__module> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfwsoap__module(struct soap *soap, const char *tag, int id, const std::vector<wsoap__module> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<wsoap__module> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<wsoap__module> * SOAP_FMAC4 soap_in_std__vectorTemplateOfwsoap__module(struct soap *soap, const char *tag, std::vector<wsoap__module> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfwsoap__module(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		wsoap__module n;
		n.soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_wsoap__module, SOAP_TYPE_std__vectorTemplateOfwsoap__module, sizeof(wsoap__module), 0, wsdl_finsert, wsdl_fbase))
				break;
			if (!soap_in_wsoap__module(soap, tag, NULL, "wsoap:module"))
				break;
		}
		else
		{	if (!soap_in_wsoap__module(soap, tag, &n, "wsoap:module"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(wsoap__module));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(wsoap__module));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(wsoap__module));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<wsoap__module>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfwsoap__module(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_std__vectorTemplateOfwsoap__module(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<wsoap__module> *p;
	size_t k = sizeof(std::vector<wsoap__module> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<wsoap__module> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<wsoap__module> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<wsoap__module>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfwsoap__module, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfwsdl__operation(struct soap *soap, std::vector<wsdl__operation> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfwsdl__operation(struct soap *soap, const std::vector<wsdl__operation> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<wsdl__operation> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfwsdl__operation(struct soap *soap, const char *tag, int id, const std::vector<wsdl__operation> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<wsdl__operation> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<wsdl__operation> * SOAP_FMAC4 soap_in_std__vectorTemplateOfwsdl__operation(struct soap *soap, const char *tag, std::vector<wsdl__operation> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfwsdl__operation(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		wsdl__operation n;
		n.soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_wsdl__operation, SOAP_TYPE_std__vectorTemplateOfwsdl__operation, sizeof(wsdl__operation), 0, wsdl_finsert, wsdl_fbase))
				break;
			if (!soap_in_wsdl__operation(soap, tag, NULL, "wsdl:operation"))
				break;
		}
		else
		{	if (!soap_in_wsdl__operation(soap, tag, &n, "wsdl:operation"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(wsdl__operation));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(wsdl__operation));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(wsdl__operation));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<wsdl__operation>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfwsdl__operation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_std__vectorTemplateOfwsdl__operation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<wsdl__operation> *p;
	size_t k = sizeof(std::vector<wsdl__operation> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<wsdl__operation> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<wsdl__operation> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<wsdl__operation>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfwsdl__operation, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfwsdl__fault(struct soap *soap, std::vector<wsdl__fault> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfwsdl__fault(struct soap *soap, const std::vector<wsdl__fault> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<wsdl__fault> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfwsdl__fault(struct soap *soap, const char *tag, int id, const std::vector<wsdl__fault> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<wsdl__fault> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<wsdl__fault> * SOAP_FMAC4 soap_in_std__vectorTemplateOfwsdl__fault(struct soap *soap, const char *tag, std::vector<wsdl__fault> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfwsdl__fault(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		wsdl__fault n;
		n.soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_wsdl__fault, SOAP_TYPE_std__vectorTemplateOfwsdl__fault, sizeof(wsdl__fault), 0, wsdl_finsert, wsdl_fbase))
				break;
			if (!soap_in_wsdl__fault(soap, tag, NULL, "wsdl:fault"))
				break;
		}
		else
		{	if (!soap_in_wsdl__fault(soap, tag, &n, "wsdl:fault"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(wsdl__fault));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(wsdl__fault));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(wsdl__fault));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<wsdl__fault>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfwsdl__fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_std__vectorTemplateOfwsdl__fault(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<wsdl__fault> *p;
	size_t k = sizeof(std::vector<wsdl__fault> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<wsdl__fault> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<wsdl__fault> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<wsdl__fault>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfwsdl__fault, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfwsdl__part(struct soap *soap, std::vector<wsdl__part> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfwsdl__part(struct soap *soap, const std::vector<wsdl__part> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<wsdl__part> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfwsdl__part(struct soap *soap, const char *tag, int id, const std::vector<wsdl__part> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<wsdl__part> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<wsdl__part> * SOAP_FMAC4 soap_in_std__vectorTemplateOfwsdl__part(struct soap *soap, const char *tag, std::vector<wsdl__part> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfwsdl__part(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		wsdl__part n;
		n.soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_wsdl__part, SOAP_TYPE_std__vectorTemplateOfwsdl__part, sizeof(wsdl__part), 0, wsdl_finsert, wsdl_fbase))
				break;
			if (!soap_in_wsdl__part(soap, tag, NULL, "wsdl:part"))
				break;
		}
		else
		{	if (!soap_in_wsdl__part(soap, tag, &n, "wsdl:part"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(wsdl__part));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(wsdl__part));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(wsdl__part));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<wsdl__part>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfwsdl__part(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_std__vectorTemplateOfwsdl__part(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<wsdl__part> *p;
	size_t k = sizeof(std::vector<wsdl__part> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<wsdl__part> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<wsdl__part> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<wsdl__part>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfwsdl__part, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfwsp__PolicyReference(struct soap *soap, std::vector<wsp__PolicyReference> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfwsp__PolicyReference(struct soap *soap, const std::vector<wsp__PolicyReference> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<wsp__PolicyReference> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfwsp__PolicyReference(struct soap *soap, const char *tag, int id, const std::vector<wsp__PolicyReference> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<wsp__PolicyReference> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<wsp__PolicyReference> * SOAP_FMAC4 soap_in_std__vectorTemplateOfwsp__PolicyReference(struct soap *soap, const char *tag, std::vector<wsp__PolicyReference> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfwsp__PolicyReference(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		wsp__PolicyReference n;
		n.soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_wsp__PolicyReference, SOAP_TYPE_std__vectorTemplateOfwsp__PolicyReference, sizeof(wsp__PolicyReference), 0, wsdl_finsert, wsdl_fbase))
				break;
			if (!soap_in_wsp__PolicyReference(soap, tag, NULL, "wsp:PolicyReference"))
				break;
		}
		else
		{	if (!soap_in_wsp__PolicyReference(soap, tag, &n, "wsp:PolicyReference"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(wsp__PolicyReference));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(wsp__PolicyReference));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(wsp__PolicyReference));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<wsp__PolicyReference>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfwsp__PolicyReference(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_std__vectorTemplateOfwsp__PolicyReference(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<wsp__PolicyReference> *p;
	size_t k = sizeof(std::vector<wsp__PolicyReference> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<wsp__PolicyReference> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<wsp__PolicyReference> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<wsp__PolicyReference>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfwsp__PolicyReference, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfwsp__Policy(struct soap *soap, std::vector<wsp__Policy> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfwsp__Policy(struct soap *soap, const std::vector<wsp__Policy> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<wsp__Policy> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfwsp__Policy(struct soap *soap, const char *tag, int id, const std::vector<wsp__Policy> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<wsp__Policy> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<wsp__Policy> * SOAP_FMAC4 soap_in_std__vectorTemplateOfwsp__Policy(struct soap *soap, const char *tag, std::vector<wsp__Policy> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfwsp__Policy(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		wsp__Policy n;
		n.soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_wsp__Policy, SOAP_TYPE_std__vectorTemplateOfwsp__Policy, sizeof(wsp__Policy), 0, wsdl_finsert, wsdl_fbase))
				break;
			if (!soap_in_wsp__Policy(soap, tag, NULL, "wsp:Policy"))
				break;
		}
		else
		{	if (!soap_in_wsp__Policy(soap, tag, &n, "wsp:Policy"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(wsp__Policy));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(wsp__Policy));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(wsp__Policy));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<wsp__Policy>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfwsp__Policy(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_std__vectorTemplateOfwsp__Policy(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<wsp__Policy> *p;
	size_t k = sizeof(std::vector<wsp__Policy> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<wsp__Policy> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<wsp__Policy> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<wsp__Policy>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfwsp__Policy, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerToxs__schema(struct soap *soap, std::vector<xs__schema *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerToxs__schema(struct soap *soap, const std::vector<xs__schema *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<xs__schema *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerToxs__schema(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerToxs__schema(struct soap *soap, const char *tag, int id, const std::vector<xs__schema *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<xs__schema *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerToxs__schema(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<xs__schema *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerToxs__schema(struct soap *soap, const char *tag, std::vector<xs__schema *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerToxs__schema(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		xs__schema *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_xs__schema, SOAP_TYPE_std__vectorTemplateOfPointerToxs__schema, sizeof(xs__schema), 1, wsdl_finsert, wsdl_fbase))
				break;
			if (!soap_in_PointerToxs__schema(soap, tag, NULL, "xs:schema"))
				break;
		}
		else
		{	if (!soap_in_PointerToxs__schema(soap, tag, &n, "xs:schema"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<xs__schema *>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfPointerToxs__schema(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_std__vectorTemplateOfPointerToxs__schema(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<xs__schema *> *p;
	size_t k = sizeof(std::vector<xs__schema *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<xs__schema *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<xs__schema *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<xs__schema *>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfPointerToxs__schema, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfplnk__tRole(struct soap *soap, std::vector<plnk__tRole> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfplnk__tRole(struct soap *soap, const std::vector<plnk__tRole> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<plnk__tRole> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfplnk__tRole(struct soap *soap, const char *tag, int id, const std::vector<plnk__tRole> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<plnk__tRole> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<plnk__tRole> * SOAP_FMAC4 soap_in_std__vectorTemplateOfplnk__tRole(struct soap *soap, const char *tag, std::vector<plnk__tRole> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfplnk__tRole(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		plnk__tRole n;
		n.soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_plnk__tRole, SOAP_TYPE_std__vectorTemplateOfplnk__tRole, sizeof(plnk__tRole), 0, wsdl_finsert, wsdl_fbase))
				break;
			if (!soap_in_plnk__tRole(soap, tag, NULL, "plnk:tRole"))
				break;
		}
		else
		{	if (!soap_in_plnk__tRole(soap, tag, &n, "plnk:tRole"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(plnk__tRole));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(plnk__tRole));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(plnk__tRole));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<plnk__tRole>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfplnk__tRole(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_std__vectorTemplateOfplnk__tRole(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<plnk__tRole> *p;
	size_t k = sizeof(std::vector<plnk__tRole> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<plnk__tRole> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<plnk__tRole> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<plnk__tRole>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfplnk__tRole, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfwsp__Attachment(struct soap *soap, std::vector<wsp__Attachment> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfwsp__Attachment(struct soap *soap, const std::vector<wsp__Attachment> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<wsp__Attachment> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfwsp__Attachment(struct soap *soap, const char *tag, int id, const std::vector<wsp__Attachment> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<wsp__Attachment> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<wsp__Attachment> * SOAP_FMAC4 soap_in_std__vectorTemplateOfwsp__Attachment(struct soap *soap, const char *tag, std::vector<wsp__Attachment> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfwsp__Attachment(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		wsp__Attachment n;
		n.soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_wsp__Attachment, SOAP_TYPE_std__vectorTemplateOfwsp__Attachment, sizeof(wsp__Attachment), 0, wsdl_finsert, wsdl_fbase))
				break;
			if (!soap_in_wsp__Attachment(soap, tag, NULL, "wsp:Attachment"))
				break;
		}
		else
		{	if (!soap_in_wsp__Attachment(soap, tag, &n, "wsp:Attachment"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(wsp__Attachment));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(wsp__Attachment));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(wsp__Attachment));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<wsp__Attachment>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfwsp__Attachment(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_std__vectorTemplateOfwsp__Attachment(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<wsp__Attachment> *p;
	size_t k = sizeof(std::vector<wsp__Attachment> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<wsp__Attachment> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<wsp__Attachment> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<wsp__Attachment>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfwsp__Attachment, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf_XML(struct soap *soap, std::vector<char *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf_XML(struct soap *soap, const std::vector<char *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf_XML(struct soap *soap, const char *tag, int id, const std::vector<char *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<char *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_outliteral(soap, tag, (char*const*)&(*i), NULL))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<char *> * SOAP_FMAC4 soap_in_std__vectorTemplateOf_XML(struct soap *soap, const char *tag, std::vector<char *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOf_XML(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		char *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE__XML, SOAP_TYPE_std__vectorTemplateOf_XML, sizeof(char *), 1, wsdl_finsert, wsdl_fbase))
				break;
			if (!soap_inliteral(soap, tag, NULL))
				break;
		}
		else
		{	if (!soap_inliteral(soap, tag, &n))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<char *>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOf_XML(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_std__vectorTemplateOf_XML(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<char *> *p;
	size_t k = sizeof(std::vector<char *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<char *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<char *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<char *>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOf_XML, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfsp__Parts(struct soap *soap, std::vector<sp__Parts> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfsp__Parts(struct soap *soap, const std::vector<sp__Parts> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<sp__Parts> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfsp__Parts(struct soap *soap, const char *tag, int id, const std::vector<sp__Parts> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<sp__Parts> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<sp__Parts> * SOAP_FMAC4 soap_in_std__vectorTemplateOfsp__Parts(struct soap *soap, const char *tag, std::vector<sp__Parts> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfsp__Parts(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		sp__Parts n;
		n.soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_sp__Parts, SOAP_TYPE_std__vectorTemplateOfsp__Parts, sizeof(sp__Parts), 0, wsdl_finsert, wsdl_fbase))
				break;
			if (!soap_in_sp__Parts(soap, tag, NULL, "sp:Parts"))
				break;
		}
		else
		{	if (!soap_in_sp__Parts(soap, tag, &n, "sp:Parts"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(sp__Parts));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(sp__Parts));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(sp__Parts));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<sp__Parts>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfsp__Parts(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_std__vectorTemplateOfsp__Parts(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<sp__Parts> *p;
	size_t k = sizeof(std::vector<sp__Parts> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<sp__Parts> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<sp__Parts> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<sp__Parts>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfsp__Parts, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTowsp__Content(struct soap *soap, std::vector<wsp__Content *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTowsp__Content(struct soap *soap, const std::vector<wsp__Content *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<wsp__Content *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTowsp__Content(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTowsp__Content(struct soap *soap, const char *tag, int id, const std::vector<wsp__Content *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<wsp__Content *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTowsp__Content(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<wsp__Content *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTowsp__Content(struct soap *soap, const char *tag, std::vector<wsp__Content *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTowsp__Content(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		wsp__Content *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_wsp__Content, SOAP_TYPE_std__vectorTemplateOfPointerTowsp__Content, sizeof(wsp__Content), 1, wsdl_finsert, wsdl_fbase))
				break;
			if (!soap_in_PointerTowsp__Content(soap, tag, NULL, "wsp:Content"))
				break;
		}
		else
		{	if (!soap_in_PointerTowsp__Content(soap, tag, &n, "wsp:Content"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<wsp__Content *>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfPointerTowsp__Content(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_std__vectorTemplateOfPointerTowsp__Content(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<wsp__Content *> *p;
	size_t k = sizeof(std::vector<wsp__Content *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<wsp__Content *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<wsp__Content *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<wsp__Content *>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfPointerTowsp__Content, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfxsd__string(struct soap *soap, std::vector<char *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfxsd__string(struct soap *soap, const std::vector<char *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<char *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_xsd__string(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfxsd__string(struct soap *soap, const char *tag, int id, const std::vector<char *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<char *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_xsd__string(soap, tag, -1, (char*const*)&(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<char *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfxsd__string(struct soap *soap, const char *tag, std::vector<char *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfxsd__string(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		char *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_xsd__string, SOAP_TYPE_std__vectorTemplateOfxsd__string, sizeof(char *), 1, wsdl_finsert, wsdl_fbase))
				break;
			if (!soap_in_xsd__string(soap, tag, NULL, "xsd:string"))
				break;
		}
		else
		{	if (!soap_in_xsd__string(soap, tag, &n, "xsd:string"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<char *>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfxsd__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_std__vectorTemplateOfxsd__string(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<char *> *p;
	size_t k = sizeof(std::vector<char *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<char *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<char *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<char *>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfxsd__string, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfsp__Header(struct soap *soap, std::vector<sp__Header> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfsp__Header(struct soap *soap, const std::vector<sp__Header> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<sp__Header> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfsp__Header(struct soap *soap, const char *tag, int id, const std::vector<sp__Header> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<sp__Header> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<sp__Header> * SOAP_FMAC4 soap_in_std__vectorTemplateOfsp__Header(struct soap *soap, const char *tag, std::vector<sp__Header> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfsp__Header(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		sp__Header n;
		n.soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_sp__Header, SOAP_TYPE_std__vectorTemplateOfsp__Header, sizeof(sp__Header), 0, wsdl_finsert, wsdl_fbase))
				break;
			if (!soap_in_sp__Header(soap, tag, NULL, "sp:Header"))
				break;
		}
		else
		{	if (!soap_in_sp__Header(soap, tag, &n, "sp:Header"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(sp__Header));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(sp__Header));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(sp__Header));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<sp__Header>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfsp__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_std__vectorTemplateOfsp__Header(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<sp__Header> *p;
	size_t k = sizeof(std::vector<sp__Header> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<sp__Header> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<sp__Header> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<sp__Header>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfsp__Header, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfsd__serviceData(struct soap *soap, std::vector<sd__serviceData> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfsd__serviceData(struct soap *soap, const std::vector<sd__serviceData> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<sd__serviceData> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfsd__serviceData(struct soap *soap, const char *tag, int id, const std::vector<sd__serviceData> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<sd__serviceData> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<sd__serviceData> * SOAP_FMAC4 soap_in_std__vectorTemplateOfsd__serviceData(struct soap *soap, const char *tag, std::vector<sd__serviceData> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfsd__serviceData(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		sd__serviceData n;
		n.soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_sd__serviceData, SOAP_TYPE_std__vectorTemplateOfsd__serviceData, sizeof(sd__serviceData), 0, wsdl_finsert, wsdl_fbase))
				break;
			if (!soap_in_sd__serviceData(soap, tag, NULL, "sd:serviceData"))
				break;
		}
		else
		{	if (!soap_in_sd__serviceData(soap, tag, &n, "sd:serviceData"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(sd__serviceData));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(sd__serviceData));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(sd__serviceData));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<sd__serviceData>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfsd__serviceData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_std__vectorTemplateOfsd__serviceData(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<sd__serviceData> *p;
	size_t k = sizeof(std::vector<sd__serviceData> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<sd__serviceData> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<sd__serviceData> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<sd__serviceData>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfsd__serviceData, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTowsdl__operation(struct soap *soap, std::vector<wsdl__operation *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTowsdl__operation(struct soap *soap, const std::vector<wsdl__operation *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<wsdl__operation *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTowsdl__operation(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTowsdl__operation(struct soap *soap, const char *tag, int id, const std::vector<wsdl__operation *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<wsdl__operation *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTowsdl__operation(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<wsdl__operation *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTowsdl__operation(struct soap *soap, const char *tag, std::vector<wsdl__operation *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTowsdl__operation(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		wsdl__operation *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_wsdl__operation, SOAP_TYPE_std__vectorTemplateOfPointerTowsdl__operation, sizeof(wsdl__operation), 1, wsdl_finsert, wsdl_fbase))
				break;
			if (!soap_in_PointerTowsdl__operation(soap, tag, NULL, "wsdl:operation"))
				break;
		}
		else
		{	if (!soap_in_PointerTowsdl__operation(soap, tag, &n, "wsdl:operation"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<wsdl__operation *>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfPointerTowsdl__operation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_std__vectorTemplateOfPointerTowsdl__operation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<wsdl__operation *> *p;
	size_t k = sizeof(std::vector<wsdl__operation *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<wsdl__operation *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<wsdl__operation *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<wsdl__operation *>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfPointerTowsdl__operation, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfmime__part(struct soap *soap, std::vector<mime__part> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfmime__part(struct soap *soap, const std::vector<mime__part> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<mime__part> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfmime__part(struct soap *soap, const char *tag, int id, const std::vector<mime__part> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<mime__part> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<mime__part> * SOAP_FMAC4 soap_in_std__vectorTemplateOfmime__part(struct soap *soap, const char *tag, std::vector<mime__part> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfmime__part(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		mime__part n;
		n.soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_mime__part, SOAP_TYPE_std__vectorTemplateOfmime__part, sizeof(mime__part), 0, wsdl_finsert, wsdl_fbase))
				break;
			if (!soap_in_mime__part(soap, tag, NULL, "mime:part"))
				break;
		}
		else
		{	if (!soap_in_mime__part(soap, tag, &n, "mime:part"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(mime__part));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(mime__part));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(mime__part));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<mime__part>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfmime__part(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_std__vectorTemplateOfmime__part(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<mime__part> *p;
	size_t k = sizeof(std::vector<mime__part> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<mime__part> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<mime__part> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<mime__part>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfmime__part, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfmime__content(struct soap *soap, std::vector<mime__content> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfmime__content(struct soap *soap, const std::vector<mime__content> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<mime__content> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfmime__content(struct soap *soap, const char *tag, int id, const std::vector<mime__content> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<mime__content> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<mime__content> * SOAP_FMAC4 soap_in_std__vectorTemplateOfmime__content(struct soap *soap, const char *tag, std::vector<mime__content> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfmime__content(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		mime__content n;
		n.soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_mime__content, SOAP_TYPE_std__vectorTemplateOfmime__content, sizeof(mime__content), 0, wsdl_finsert, wsdl_fbase))
				break;
			if (!soap_in_mime__content(soap, tag, NULL, "mime:content"))
				break;
		}
		else
		{	if (!soap_in_mime__content(soap, tag, &n, "mime:content"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(mime__content));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(mime__content));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(mime__content));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<mime__content>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfmime__content(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_std__vectorTemplateOfmime__content(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<mime__content> *p;
	size_t k = sizeof(std::vector<mime__content> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<mime__content> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<mime__content> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<mime__content>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfmime__content, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfsoap__header(struct soap *soap, std::vector<soap__header> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfsoap__header(struct soap *soap, const std::vector<soap__header> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<soap__header> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfsoap__header(struct soap *soap, const char *tag, int id, const std::vector<soap__header> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<soap__header> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<soap__header> * SOAP_FMAC4 soap_in_std__vectorTemplateOfsoap__header(struct soap *soap, const char *tag, std::vector<soap__header> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfsoap__header(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		soap__header n;
		n.soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_soap__header, SOAP_TYPE_std__vectorTemplateOfsoap__header, sizeof(soap__header), 0, wsdl_finsert, wsdl_fbase))
				break;
			if (!soap_in_soap__header(soap, tag, NULL, "soap:header"))
				break;
		}
		else
		{	if (!soap_in_soap__header(soap, tag, &n, "soap:header"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(soap__header));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(soap__header));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(soap__header));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<soap__header>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfsoap__header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_std__vectorTemplateOfsoap__header(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<soap__header> *p;
	size_t k = sizeof(std::vector<soap__header> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<soap__header> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<soap__header> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<soap__header>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfsoap__header, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfsoap__headerfault(struct soap *soap, std::vector<soap__headerfault> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfsoap__headerfault(struct soap *soap, const std::vector<soap__headerfault> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<soap__headerfault> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfsoap__headerfault(struct soap *soap, const char *tag, int id, const std::vector<soap__headerfault> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<soap__headerfault> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<soap__headerfault> * SOAP_FMAC4 soap_in_std__vectorTemplateOfsoap__headerfault(struct soap *soap, const char *tag, std::vector<soap__headerfault> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfsoap__headerfault(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		soap__headerfault n;
		n.soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_soap__headerfault, SOAP_TYPE_std__vectorTemplateOfsoap__headerfault, sizeof(soap__headerfault), 0, wsdl_finsert, wsdl_fbase))
				break;
			if (!soap_in_soap__headerfault(soap, tag, NULL, "soap:headerfault"))
				break;
		}
		else
		{	if (!soap_in_soap__headerfault(soap, tag, &n, "soap:headerfault"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(soap__headerfault));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(soap__headerfault));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(soap__headerfault));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<soap__headerfault>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfsoap__headerfault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_std__vectorTemplateOfsoap__headerfault(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<soap__headerfault> *p;
	size_t k = sizeof(std::vector<soap__headerfault> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<soap__headerfault> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<soap__headerfault> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<soap__headerfault>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfsoap__headerfault, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfwadl__method(struct soap *soap, std::vector<wadl__method> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfwadl__method(struct soap *soap, const std::vector<wadl__method> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<wadl__method> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfwadl__method(struct soap *soap, const char *tag, int id, const std::vector<wadl__method> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<wadl__method> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<wadl__method> * SOAP_FMAC4 soap_in_std__vectorTemplateOfwadl__method(struct soap *soap, const char *tag, std::vector<wadl__method> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfwadl__method(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		wadl__method n;
		n.soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_wadl__method, SOAP_TYPE_std__vectorTemplateOfwadl__method, sizeof(wadl__method), 0, wsdl_finsert, wsdl_fbase))
				break;
			if (!soap_in_wadl__method(soap, tag, NULL, "wadl:method"))
				break;
		}
		else
		{	if (!soap_in_wadl__method(soap, tag, &n, "wadl:method"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(wadl__method));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(wadl__method));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(wadl__method));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<wadl__method>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfwadl__method(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_std__vectorTemplateOfwadl__method(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<wadl__method> *p;
	size_t k = sizeof(std::vector<wadl__method> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<wadl__method> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<wadl__method> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<wadl__method>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfwadl__method, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfwadl__resource_USCOREtype(struct soap *soap, std::vector<wadl__resource_USCOREtype> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfwadl__resource_USCOREtype(struct soap *soap, const std::vector<wadl__resource_USCOREtype> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<wadl__resource_USCOREtype> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfwadl__resource_USCOREtype(struct soap *soap, const char *tag, int id, const std::vector<wadl__resource_USCOREtype> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<wadl__resource_USCOREtype> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<wadl__resource_USCOREtype> * SOAP_FMAC4 soap_in_std__vectorTemplateOfwadl__resource_USCOREtype(struct soap *soap, const char *tag, std::vector<wadl__resource_USCOREtype> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfwadl__resource_USCOREtype(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		wadl__resource_USCOREtype n;
		n.soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_wadl__resource_USCOREtype, SOAP_TYPE_std__vectorTemplateOfwadl__resource_USCOREtype, sizeof(wadl__resource_USCOREtype), 0, wsdl_finsert, wsdl_fbase))
				break;
			if (!soap_in_wadl__resource_USCOREtype(soap, tag, NULL, "wadl:resource_type"))
				break;
		}
		else
		{	if (!soap_in_wadl__resource_USCOREtype(soap, tag, &n, "wadl:resource_type"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(wadl__resource_USCOREtype));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(wadl__resource_USCOREtype));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(wadl__resource_USCOREtype));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<wadl__resource_USCOREtype>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfwadl__resource_USCOREtype(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_std__vectorTemplateOfwadl__resource_USCOREtype(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<wadl__resource_USCOREtype> *p;
	size_t k = sizeof(std::vector<wadl__resource_USCOREtype> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<wadl__resource_USCOREtype> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<wadl__resource_USCOREtype> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<wadl__resource_USCOREtype>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfwadl__resource_USCOREtype, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfwadl__resources(struct soap *soap, std::vector<wadl__resources> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfwadl__resources(struct soap *soap, const std::vector<wadl__resources> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<wadl__resources> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfwadl__resources(struct soap *soap, const char *tag, int id, const std::vector<wadl__resources> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<wadl__resources> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<wadl__resources> * SOAP_FMAC4 soap_in_std__vectorTemplateOfwadl__resources(struct soap *soap, const char *tag, std::vector<wadl__resources> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfwadl__resources(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		wadl__resources n;
		n.soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_wadl__resources, SOAP_TYPE_std__vectorTemplateOfwadl__resources, sizeof(wadl__resources), 0, wsdl_finsert, wsdl_fbase))
				break;
			if (!soap_in_wadl__resources(soap, tag, NULL, "wadl:resources"))
				break;
		}
		else
		{	if (!soap_in_wadl__resources(soap, tag, &n, "wadl:resources"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(wadl__resources));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(wadl__resources));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(wadl__resources));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<wadl__resources>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfwadl__resources(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_std__vectorTemplateOfwadl__resources(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<wadl__resources> *p;
	size_t k = sizeof(std::vector<wadl__resources> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<wadl__resources> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<wadl__resources> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<wadl__resources>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfwadl__resources, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfwadl__resource(struct soap *soap, std::vector<wadl__resource> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfwadl__resource(struct soap *soap, const std::vector<wadl__resource> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<wadl__resource> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfwadl__resource(struct soap *soap, const char *tag, int id, const std::vector<wadl__resource> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<wadl__resource> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<wadl__resource> * SOAP_FMAC4 soap_in_std__vectorTemplateOfwadl__resource(struct soap *soap, const char *tag, std::vector<wadl__resource> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfwadl__resource(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		wadl__resource n;
		n.soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_wadl__resource, SOAP_TYPE_std__vectorTemplateOfwadl__resource, sizeof(wadl__resource), 0, wsdl_finsert, wsdl_fbase))
				break;
			if (!soap_in_wadl__resource(soap, tag, NULL, "wadl:resource"))
				break;
		}
		else
		{	if (!soap_in_wadl__resource(soap, tag, &n, "wadl:resource"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(wadl__resource));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(wadl__resource));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(wadl__resource));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<wadl__resource>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfwadl__resource(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_std__vectorTemplateOfwadl__resource(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<wadl__resource> *p;
	size_t k = sizeof(std::vector<wadl__resource> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<wadl__resource> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<wadl__resource> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<wadl__resource>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfwadl__resource, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTowadl__resource_USCOREtype(struct soap *soap, std::vector<wadl__resource_USCOREtype *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTowadl__resource_USCOREtype(struct soap *soap, const std::vector<wadl__resource_USCOREtype *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<wadl__resource_USCOREtype *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTowadl__resource_USCOREtype(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTowadl__resource_USCOREtype(struct soap *soap, const char *tag, int id, const std::vector<wadl__resource_USCOREtype *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<wadl__resource_USCOREtype *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTowadl__resource_USCOREtype(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<wadl__resource_USCOREtype *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTowadl__resource_USCOREtype(struct soap *soap, const char *tag, std::vector<wadl__resource_USCOREtype *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTowadl__resource_USCOREtype(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		wadl__resource_USCOREtype *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_wadl__resource_USCOREtype, SOAP_TYPE_std__vectorTemplateOfPointerTowadl__resource_USCOREtype, sizeof(wadl__resource_USCOREtype), 1, wsdl_finsert, wsdl_fbase))
				break;
			if (!soap_in_PointerTowadl__resource_USCOREtype(soap, tag, NULL, "wadl:resource_type"))
				break;
		}
		else
		{	if (!soap_in_PointerTowadl__resource_USCOREtype(soap, tag, &n, "wadl:resource_type"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<wadl__resource_USCOREtype *>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfPointerTowadl__resource_USCOREtype(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_std__vectorTemplateOfPointerTowadl__resource_USCOREtype(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<wadl__resource_USCOREtype *> *p;
	size_t k = sizeof(std::vector<wadl__resource_USCOREtype *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<wadl__resource_USCOREtype *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<wadl__resource_USCOREtype *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<wadl__resource_USCOREtype *>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfPointerTowadl__resource_USCOREtype, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf__wadl__method_resource_choice(struct soap *soap, std::vector<__wadl__method_resource_choice> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf__wadl__method_resource_choice(struct soap *soap, const std::vector<__wadl__method_resource_choice> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<__wadl__method_resource_choice> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf__wadl__method_resource_choice(struct soap *soap, const char *tag, int id, const std::vector<__wadl__method_resource_choice> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<__wadl__method_resource_choice> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<__wadl__method_resource_choice> * SOAP_FMAC4 soap_in_std__vectorTemplateOf__wadl__method_resource_choice(struct soap *soap, const char *tag, std::vector<__wadl__method_resource_choice> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOf__wadl__method_resource_choice(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		__wadl__method_resource_choice n;
		n.soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE___wadl__method_resource_choice, SOAP_TYPE_std__vectorTemplateOf__wadl__method_resource_choice, sizeof(__wadl__method_resource_choice), 0, wsdl_finsert, wsdl_fbase))
				break;
			if (!soap_in___wadl__method_resource_choice(soap, tag, NULL, "-wadl:method-resource-choice"))
				break;
		}
		else
		{	if (!soap_in___wadl__method_resource_choice(soap, tag, &n, "-wadl:method-resource-choice"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(__wadl__method_resource_choice));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(__wadl__method_resource_choice));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(__wadl__method_resource_choice));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<__wadl__method_resource_choice>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOf__wadl__method_resource_choice(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_std__vectorTemplateOf__wadl__method_resource_choice(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<__wadl__method_resource_choice> *p;
	size_t k = sizeof(std::vector<__wadl__method_resource_choice> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<__wadl__method_resource_choice> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<__wadl__method_resource_choice> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<__wadl__method_resource_choice>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOf__wadl__method_resource_choice, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfwadl__response(struct soap *soap, std::vector<wadl__response> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfwadl__response(struct soap *soap, const std::vector<wadl__response> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<wadl__response> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfwadl__response(struct soap *soap, const char *tag, int id, const std::vector<wadl__response> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<wadl__response> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<wadl__response> * SOAP_FMAC4 soap_in_std__vectorTemplateOfwadl__response(struct soap *soap, const char *tag, std::vector<wadl__response> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfwadl__response(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		wadl__response n;
		n.soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_wadl__response, SOAP_TYPE_std__vectorTemplateOfwadl__response, sizeof(wadl__response), 0, wsdl_finsert, wsdl_fbase))
				break;
			if (!soap_in_wadl__response(soap, tag, NULL, "wadl:response"))
				break;
		}
		else
		{	if (!soap_in_wadl__response(soap, tag, &n, "wadl:response"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(wadl__response));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(wadl__response));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(wadl__response));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<wadl__response>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfwadl__response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_std__vectorTemplateOfwadl__response(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<wadl__response> *p;
	size_t k = sizeof(std::vector<wadl__response> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<wadl__response> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<wadl__response> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<wadl__response>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfwadl__response, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfwadl__representation(struct soap *soap, std::vector<wadl__representation> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfwadl__representation(struct soap *soap, const std::vector<wadl__representation> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<wadl__representation> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfwadl__representation(struct soap *soap, const char *tag, int id, const std::vector<wadl__representation> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<wadl__representation> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<wadl__representation> * SOAP_FMAC4 soap_in_std__vectorTemplateOfwadl__representation(struct soap *soap, const char *tag, std::vector<wadl__representation> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfwadl__representation(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		wadl__representation n;
		n.soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_wadl__representation, SOAP_TYPE_std__vectorTemplateOfwadl__representation, sizeof(wadl__representation), 0, wsdl_finsert, wsdl_fbase))
				break;
			if (!soap_in_wadl__representation(soap, tag, NULL, "wadl:representation"))
				break;
		}
		else
		{	if (!soap_in_wadl__representation(soap, tag, &n, "wadl:representation"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(wadl__representation));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(wadl__representation));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(wadl__representation));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<wadl__representation>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfwadl__representation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_std__vectorTemplateOfwadl__representation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<wadl__representation> *p;
	size_t k = sizeof(std::vector<wadl__representation> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<wadl__representation> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<wadl__representation> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<wadl__representation>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfwadl__representation, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfwadl__param(struct soap *soap, std::vector<wadl__param> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfwadl__param(struct soap *soap, const std::vector<wadl__param> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<wadl__param> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfwadl__param(struct soap *soap, const char *tag, int id, const std::vector<wadl__param> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<wadl__param> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<wadl__param> * SOAP_FMAC4 soap_in_std__vectorTemplateOfwadl__param(struct soap *soap, const char *tag, std::vector<wadl__param> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfwadl__param(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		wadl__param n;
		n.soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_wadl__param, SOAP_TYPE_std__vectorTemplateOfwadl__param, sizeof(wadl__param), 0, wsdl_finsert, wsdl_fbase))
				break;
			if (!soap_in_wadl__param(soap, tag, NULL, "wadl:param"))
				break;
		}
		else
		{	if (!soap_in_wadl__param(soap, tag, &n, "wadl:param"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(wadl__param));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(wadl__param));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(wadl__param));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<wadl__param>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfwadl__param(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_std__vectorTemplateOfwadl__param(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<wadl__param> *p;
	size_t k = sizeof(std::vector<wadl__param> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<wadl__param> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<wadl__param> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<wadl__param>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfwadl__param, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfwadl__include(struct soap *soap, std::vector<wadl__include> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfwadl__include(struct soap *soap, const std::vector<wadl__include> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<wadl__include> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfwadl__include(struct soap *soap, const char *tag, int id, const std::vector<wadl__include> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<wadl__include> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<wadl__include> * SOAP_FMAC4 soap_in_std__vectorTemplateOfwadl__include(struct soap *soap, const char *tag, std::vector<wadl__include> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfwadl__include(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		wadl__include n;
		n.soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_wadl__include, SOAP_TYPE_std__vectorTemplateOfwadl__include, sizeof(wadl__include), 0, wsdl_finsert, wsdl_fbase))
				break;
			if (!soap_in_wadl__include(soap, tag, NULL, "wadl:include"))
				break;
		}
		else
		{	if (!soap_in_wadl__include(soap, tag, &n, "wadl:include"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(wadl__include));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(wadl__include));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(wadl__include));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<wadl__include>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfwadl__include(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_std__vectorTemplateOfwadl__include(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<wadl__include> *p;
	size_t k = sizeof(std::vector<wadl__include> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<wadl__include> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<wadl__include> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<wadl__include>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfwadl__include, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfwadl__option(struct soap *soap, std::vector<wadl__option> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfwadl__option(struct soap *soap, const std::vector<wadl__option> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<wadl__option> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfwadl__option(struct soap *soap, const char *tag, int id, const std::vector<wadl__option> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<wadl__option> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<wadl__option> * SOAP_FMAC4 soap_in_std__vectorTemplateOfwadl__option(struct soap *soap, const char *tag, std::vector<wadl__option> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfwadl__option(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		wadl__option n;
		n.soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_wadl__option, SOAP_TYPE_std__vectorTemplateOfwadl__option, sizeof(wadl__option), 0, wsdl_finsert, wsdl_fbase))
				break;
			if (!soap_in_wadl__option(soap, tag, NULL, "wadl:option"))
				break;
		}
		else
		{	if (!soap_in_wadl__option(soap, tag, &n, "wadl:option"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(wadl__option));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(wadl__option));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(wadl__option));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<wadl__option>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfwadl__option(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_std__vectorTemplateOfwadl__option(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<wadl__option> *p;
	size_t k = sizeof(std::vector<wadl__option> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<wadl__option> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<wadl__option> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<wadl__option>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfwadl__option, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfwadl__doc(struct soap *soap, std::vector<wadl__doc> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfwadl__doc(struct soap *soap, const std::vector<wadl__doc> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<wadl__doc> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfwadl__doc(struct soap *soap, const char *tag, int id, const std::vector<wadl__doc> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<wadl__doc> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<wadl__doc> * SOAP_FMAC4 soap_in_std__vectorTemplateOfwadl__doc(struct soap *soap, const char *tag, std::vector<wadl__doc> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfwadl__doc(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		wadl__doc n;
		n.soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_wadl__doc, SOAP_TYPE_std__vectorTemplateOfwadl__doc, sizeof(wadl__doc), 0, wsdl_finsert, wsdl_fbase))
				break;
			if (!soap_in_wadl__doc(soap, tag, NULL, "wadl:doc"))
				break;
		}
		else
		{	if (!soap_in_wadl__doc(soap, tag, &n, "wadl:doc"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(wadl__doc));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(wadl__doc));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(wadl__doc));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<wadl__doc>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfwadl__doc(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_std__vectorTemplateOfwadl__doc(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<wadl__doc> *p;
	size_t k = sizeof(std::vector<wadl__doc> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<wadl__doc> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<wadl__doc> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<wadl__doc>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfwadl__doc, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfxs__import(struct soap *soap, std::vector<xs__import> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfxs__import(struct soap *soap, const std::vector<xs__import> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<xs__import> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfxs__import(struct soap *soap, const char *tag, int id, const std::vector<xs__import> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<xs__import> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<xs__import> * SOAP_FMAC4 soap_in_std__vectorTemplateOfxs__import(struct soap *soap, const char *tag, std::vector<xs__import> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfxs__import(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		xs__import n;
		n.soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_xs__import, SOAP_TYPE_std__vectorTemplateOfxs__import, sizeof(xs__import), 0, wsdl_finsert, wsdl_fbase))
				break;
			if (!soap_in_xs__import(soap, tag, NULL, "xs:import"))
				break;
		}
		else
		{	if (!soap_in_xs__import(soap, tag, &n, "xs:import"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(xs__import));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(xs__import));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(xs__import));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<xs__import>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfxs__import(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_std__vectorTemplateOfxs__import(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<xs__import> *p;
	size_t k = sizeof(std::vector<xs__import> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<xs__import> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<xs__import> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<xs__import>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfxs__import, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfxs__redefine(struct soap *soap, std::vector<xs__redefine> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfxs__redefine(struct soap *soap, const std::vector<xs__redefine> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<xs__redefine> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfxs__redefine(struct soap *soap, const char *tag, int id, const std::vector<xs__redefine> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<xs__redefine> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<xs__redefine> * SOAP_FMAC4 soap_in_std__vectorTemplateOfxs__redefine(struct soap *soap, const char *tag, std::vector<xs__redefine> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfxs__redefine(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		xs__redefine n;
		n.soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_xs__redefine, SOAP_TYPE_std__vectorTemplateOfxs__redefine, sizeof(xs__redefine), 0, wsdl_finsert, wsdl_fbase))
				break;
			if (!soap_in_xs__redefine(soap, tag, NULL, "xs:redefine"))
				break;
		}
		else
		{	if (!soap_in_xs__redefine(soap, tag, &n, "xs:redefine"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(xs__redefine));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(xs__redefine));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(xs__redefine));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<xs__redefine>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfxs__redefine(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_std__vectorTemplateOfxs__redefine(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<xs__redefine> *p;
	size_t k = sizeof(std::vector<xs__redefine> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<xs__redefine> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<xs__redefine> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<xs__redefine>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfxs__redefine, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfxs__override(struct soap *soap, std::vector<xs__override> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfxs__override(struct soap *soap, const std::vector<xs__override> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<xs__override> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfxs__override(struct soap *soap, const char *tag, int id, const std::vector<xs__override> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<xs__override> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<xs__override> * SOAP_FMAC4 soap_in_std__vectorTemplateOfxs__override(struct soap *soap, const char *tag, std::vector<xs__override> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfxs__override(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		xs__override n;
		n.soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_xs__override, SOAP_TYPE_std__vectorTemplateOfxs__override, sizeof(xs__override), 0, wsdl_finsert, wsdl_fbase))
				break;
			if (!soap_in_xs__override(soap, tag, NULL, "xs:override"))
				break;
		}
		else
		{	if (!soap_in_xs__override(soap, tag, &n, "xs:override"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(xs__override));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(xs__override));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(xs__override));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<xs__override>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfxs__override(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_std__vectorTemplateOfxs__override(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<xs__override> *p;
	size_t k = sizeof(std::vector<xs__override> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<xs__override> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<xs__override> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<xs__override>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfxs__override, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfxs__include(struct soap *soap, std::vector<xs__include> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfxs__include(struct soap *soap, const std::vector<xs__include> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<xs__include> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfxs__include(struct soap *soap, const char *tag, int id, const std::vector<xs__include> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<xs__include> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<xs__include> * SOAP_FMAC4 soap_in_std__vectorTemplateOfxs__include(struct soap *soap, const char *tag, std::vector<xs__include> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfxs__include(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		xs__include n;
		n.soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_xs__include, SOAP_TYPE_std__vectorTemplateOfxs__include, sizeof(xs__include), 0, wsdl_finsert, wsdl_fbase))
				break;
			if (!soap_in_xs__include(soap, tag, NULL, "xs:include"))
				break;
		}
		else
		{	if (!soap_in_xs__include(soap, tag, &n, "xs:include"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(xs__include));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(xs__include));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(xs__include));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<xs__include>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfxs__include(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_std__vectorTemplateOfxs__include(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<xs__include> *p;
	size_t k = sizeof(std::vector<xs__include> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<xs__include> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<xs__include> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<xs__include>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfxs__include, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfxs__complexType(struct soap *soap, std::vector<xs__complexType> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfxs__complexType(struct soap *soap, const std::vector<xs__complexType> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<xs__complexType> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfxs__complexType(struct soap *soap, const char *tag, int id, const std::vector<xs__complexType> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<xs__complexType> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<xs__complexType> * SOAP_FMAC4 soap_in_std__vectorTemplateOfxs__complexType(struct soap *soap, const char *tag, std::vector<xs__complexType> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfxs__complexType(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		xs__complexType n;
		n.soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_xs__complexType, SOAP_TYPE_std__vectorTemplateOfxs__complexType, sizeof(xs__complexType), 0, wsdl_finsert, wsdl_fbase))
				break;
			if (!soap_in_xs__complexType(soap, tag, NULL, "xs:complexType"))
				break;
		}
		else
		{	if (!soap_in_xs__complexType(soap, tag, &n, "xs:complexType"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(xs__complexType));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(xs__complexType));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(xs__complexType));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<xs__complexType>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfxs__complexType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_std__vectorTemplateOfxs__complexType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<xs__complexType> *p;
	size_t k = sizeof(std::vector<xs__complexType> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<xs__complexType> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<xs__complexType> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<xs__complexType>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfxs__complexType, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfxs__group(struct soap *soap, std::vector<xs__group> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfxs__group(struct soap *soap, const std::vector<xs__group> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<xs__group> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfxs__group(struct soap *soap, const char *tag, int id, const std::vector<xs__group> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<xs__group> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<xs__group> * SOAP_FMAC4 soap_in_std__vectorTemplateOfxs__group(struct soap *soap, const char *tag, std::vector<xs__group> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfxs__group(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		xs__group n;
		n.soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_xs__group, SOAP_TYPE_std__vectorTemplateOfxs__group, sizeof(xs__group), 0, wsdl_finsert, wsdl_fbase))
				break;
			if (!soap_in_xs__group(soap, tag, NULL, "xs:group"))
				break;
		}
		else
		{	if (!soap_in_xs__group(soap, tag, &n, "xs:group"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(xs__group));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(xs__group));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(xs__group));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<xs__group>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfxs__group(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_std__vectorTemplateOfxs__group(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<xs__group> *p;
	size_t k = sizeof(std::vector<xs__group> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<xs__group> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<xs__group> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<xs__group>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfxs__group, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfxs__simpleType(struct soap *soap, std::vector<xs__simpleType> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfxs__simpleType(struct soap *soap, const std::vector<xs__simpleType> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<xs__simpleType> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfxs__simpleType(struct soap *soap, const char *tag, int id, const std::vector<xs__simpleType> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<xs__simpleType> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<xs__simpleType> * SOAP_FMAC4 soap_in_std__vectorTemplateOfxs__simpleType(struct soap *soap, const char *tag, std::vector<xs__simpleType> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfxs__simpleType(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		xs__simpleType n;
		n.soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_xs__simpleType, SOAP_TYPE_std__vectorTemplateOfxs__simpleType, sizeof(xs__simpleType), 0, wsdl_finsert, wsdl_fbase))
				break;
			if (!soap_in_xs__simpleType(soap, tag, NULL, "xs:simpleType"))
				break;
		}
		else
		{	if (!soap_in_xs__simpleType(soap, tag, &n, "xs:simpleType"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(xs__simpleType));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(xs__simpleType));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(xs__simpleType));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<xs__simpleType>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfxs__simpleType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_std__vectorTemplateOfxs__simpleType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<xs__simpleType> *p;
	size_t k = sizeof(std::vector<xs__simpleType> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<xs__simpleType> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<xs__simpleType> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<xs__simpleType>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfxs__simpleType, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfxs__pattern(struct soap *soap, std::vector<xs__pattern> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfxs__pattern(struct soap *soap, const std::vector<xs__pattern> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<xs__pattern> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfxs__pattern(struct soap *soap, const char *tag, int id, const std::vector<xs__pattern> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<xs__pattern> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<xs__pattern> * SOAP_FMAC4 soap_in_std__vectorTemplateOfxs__pattern(struct soap *soap, const char *tag, std::vector<xs__pattern> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfxs__pattern(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		xs__pattern n;
		n.soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_xs__pattern, SOAP_TYPE_std__vectorTemplateOfxs__pattern, sizeof(xs__pattern), 0, wsdl_finsert, wsdl_fbase))
				break;
			if (!soap_in_xs__pattern(soap, tag, NULL, "xs:pattern"))
				break;
		}
		else
		{	if (!soap_in_xs__pattern(soap, tag, &n, "xs:pattern"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(xs__pattern));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(xs__pattern));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(xs__pattern));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<xs__pattern>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfxs__pattern(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_std__vectorTemplateOfxs__pattern(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<xs__pattern> *p;
	size_t k = sizeof(std::vector<xs__pattern> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<xs__pattern> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<xs__pattern> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<xs__pattern>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfxs__pattern, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfxs__enumeration(struct soap *soap, std::vector<xs__enumeration> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfxs__enumeration(struct soap *soap, const std::vector<xs__enumeration> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<xs__enumeration> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfxs__enumeration(struct soap *soap, const char *tag, int id, const std::vector<xs__enumeration> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<xs__enumeration> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<xs__enumeration> * SOAP_FMAC4 soap_in_std__vectorTemplateOfxs__enumeration(struct soap *soap, const char *tag, std::vector<xs__enumeration> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfxs__enumeration(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		xs__enumeration n;
		n.soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_xs__enumeration, SOAP_TYPE_std__vectorTemplateOfxs__enumeration, sizeof(xs__enumeration), 0, wsdl_finsert, wsdl_fbase))
				break;
			if (!soap_in_xs__enumeration(soap, tag, NULL, "xs:enumeration"))
				break;
		}
		else
		{	if (!soap_in_xs__enumeration(soap, tag, &n, "xs:enumeration"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(xs__enumeration));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(xs__enumeration));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(xs__enumeration));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<xs__enumeration>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfxs__enumeration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_std__vectorTemplateOfxs__enumeration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<xs__enumeration> *p;
	size_t k = sizeof(std::vector<xs__enumeration> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<xs__enumeration> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<xs__enumeration> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<xs__enumeration>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfxs__enumeration, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfxs__assert(struct soap *soap, std::vector<xs__assert> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfxs__assert(struct soap *soap, const std::vector<xs__assert> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<xs__assert> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfxs__assert(struct soap *soap, const char *tag, int id, const std::vector<xs__assert> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<xs__assert> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<xs__assert> * SOAP_FMAC4 soap_in_std__vectorTemplateOfxs__assert(struct soap *soap, const char *tag, std::vector<xs__assert> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfxs__assert(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		xs__assert n;
		n.soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_xs__assert, SOAP_TYPE_std__vectorTemplateOfxs__assert, sizeof(xs__assert), 0, wsdl_finsert, wsdl_fbase))
				break;
			if (!soap_in_xs__assert(soap, tag, NULL, "xs:assert"))
				break;
		}
		else
		{	if (!soap_in_xs__assert(soap, tag, &n, "xs:assert"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(xs__assert));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(xs__assert));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(xs__assert));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<xs__assert>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfxs__assert(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_std__vectorTemplateOfxs__assert(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<xs__assert> *p;
	size_t k = sizeof(std::vector<xs__assert> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<xs__assert> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<xs__assert> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<xs__assert>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfxs__assert, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfxs__attributeGroup(struct soap *soap, std::vector<xs__attributeGroup> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfxs__attributeGroup(struct soap *soap, const std::vector<xs__attributeGroup> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<xs__attributeGroup> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfxs__attributeGroup(struct soap *soap, const char *tag, int id, const std::vector<xs__attributeGroup> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<xs__attributeGroup> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<xs__attributeGroup> * SOAP_FMAC4 soap_in_std__vectorTemplateOfxs__attributeGroup(struct soap *soap, const char *tag, std::vector<xs__attributeGroup> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfxs__attributeGroup(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		xs__attributeGroup n;
		n.soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_xs__attributeGroup, SOAP_TYPE_std__vectorTemplateOfxs__attributeGroup, sizeof(xs__attributeGroup), 0, wsdl_finsert, wsdl_fbase))
				break;
			if (!soap_in_xs__attributeGroup(soap, tag, NULL, "xs:attributeGroup"))
				break;
		}
		else
		{	if (!soap_in_xs__attributeGroup(soap, tag, &n, "xs:attributeGroup"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(xs__attributeGroup));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(xs__attributeGroup));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(xs__attributeGroup));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<xs__attributeGroup>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfxs__attributeGroup(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_std__vectorTemplateOfxs__attributeGroup(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<xs__attributeGroup> *p;
	size_t k = sizeof(std::vector<xs__attributeGroup> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<xs__attributeGroup> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<xs__attributeGroup> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<xs__attributeGroup>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfxs__attributeGroup, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfxs__attribute(struct soap *soap, std::vector<xs__attribute> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfxs__attribute(struct soap *soap, const std::vector<xs__attribute> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<xs__attribute> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfxs__attribute(struct soap *soap, const char *tag, int id, const std::vector<xs__attribute> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<xs__attribute> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<xs__attribute> * SOAP_FMAC4 soap_in_std__vectorTemplateOfxs__attribute(struct soap *soap, const char *tag, std::vector<xs__attribute> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfxs__attribute(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		xs__attribute n;
		n.soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_xs__attribute, SOAP_TYPE_std__vectorTemplateOfxs__attribute, sizeof(xs__attribute), 0, wsdl_finsert, wsdl_fbase))
				break;
			if (!soap_in_xs__attribute(soap, tag, NULL, "xs:attribute"))
				break;
		}
		else
		{	if (!soap_in_xs__attribute(soap, tag, &n, "xs:attribute"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(xs__attribute));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(xs__attribute));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(xs__attribute));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<xs__attribute>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfxs__attribute(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_std__vectorTemplateOfxs__attribute(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<xs__attribute> *p;
	size_t k = sizeof(std::vector<xs__attribute> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<xs__attribute> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<xs__attribute> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<xs__attribute>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfxs__attribute, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfxs__contents(struct soap *soap, std::vector<xs__contents> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfxs__contents(struct soap *soap, const std::vector<xs__contents> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<xs__contents> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfxs__contents(struct soap *soap, const char *tag, int id, const std::vector<xs__contents> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<xs__contents> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<xs__contents> * SOAP_FMAC4 soap_in_std__vectorTemplateOfxs__contents(struct soap *soap, const char *tag, std::vector<xs__contents> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfxs__contents(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		xs__contents n;
		n.soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_xs__contents, SOAP_TYPE_std__vectorTemplateOfxs__contents, sizeof(xs__contents), 0, wsdl_finsert, wsdl_fbase))
				break;
			if (!soap_in_xs__contents(soap, tag, NULL, "xs:contents"))
				break;
		}
		else
		{	if (!soap_in_xs__contents(soap, tag, &n, "xs:contents"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(xs__contents));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(xs__contents));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(xs__contents));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<xs__contents>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfxs__contents(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_std__vectorTemplateOfxs__contents(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<xs__contents> *p;
	size_t k = sizeof(std::vector<xs__contents> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<xs__contents> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<xs__contents> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<xs__contents>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfxs__contents, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfxs__element(struct soap *soap, std::vector<xs__element> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfxs__element(struct soap *soap, const std::vector<xs__element> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<xs__element> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfxs__element(struct soap *soap, const char *tag, int id, const std::vector<xs__element> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<xs__element> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<xs__element> * SOAP_FMAC4 soap_in_std__vectorTemplateOfxs__element(struct soap *soap, const char *tag, std::vector<xs__element> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfxs__element(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		xs__element n;
		n.soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_xs__element, SOAP_TYPE_std__vectorTemplateOfxs__element, sizeof(xs__element), 0, wsdl_finsert, wsdl_fbase))
				break;
			if (!soap_in_xs__element(soap, tag, NULL, "xs:element"))
				break;
		}
		else
		{	if (!soap_in_xs__element(soap, tag, &n, "xs:element"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(xs__element));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(xs__element));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(xs__element));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<xs__element>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfxs__element(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_std__vectorTemplateOfxs__element(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<xs__element> *p;
	size_t k = sizeof(std::vector<xs__element> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<xs__element> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<xs__element> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<xs__element>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfxs__element, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerToxs__element(struct soap *soap, std::vector<xs__element *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerToxs__element(struct soap *soap, const std::vector<xs__element *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<xs__element *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerToxs__element(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerToxs__element(struct soap *soap, const char *tag, int id, const std::vector<xs__element *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<xs__element *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerToxs__element(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<xs__element *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerToxs__element(struct soap *soap, const char *tag, std::vector<xs__element *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerToxs__element(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		xs__element *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_xs__element, SOAP_TYPE_std__vectorTemplateOfPointerToxs__element, sizeof(xs__element), 1, wsdl_finsert, wsdl_fbase))
				break;
			if (!soap_in_PointerToxs__element(soap, tag, NULL, "xs:element"))
				break;
		}
		else
		{	if (!soap_in_PointerToxs__element(soap, tag, &n, "xs:element"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<xs__element *>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfPointerToxs__element(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_std__vectorTemplateOfPointerToxs__element(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<xs__element *> *p;
	size_t k = sizeof(std::vector<xs__element *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<xs__element *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<xs__element *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<xs__element *>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfPointerToxs__element, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfxs__alternative(struct soap *soap, std::vector<xs__alternative> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfxs__alternative(struct soap *soap, const std::vector<xs__alternative> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<xs__alternative> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfxs__alternative(struct soap *soap, const char *tag, int id, const std::vector<xs__alternative> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<xs__alternative> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<xs__alternative> * SOAP_FMAC4 soap_in_std__vectorTemplateOfxs__alternative(struct soap *soap, const char *tag, std::vector<xs__alternative> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfxs__alternative(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		xs__alternative n;
		n.soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_xs__alternative, SOAP_TYPE_std__vectorTemplateOfxs__alternative, sizeof(xs__alternative), 0, wsdl_finsert, wsdl_fbase))
				break;
			if (!soap_in_xs__alternative(soap, tag, NULL, "xs:alternative"))
				break;
		}
		else
		{	if (!soap_in_xs__alternative(soap, tag, &n, "xs:alternative"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(xs__alternative));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(xs__alternative));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(xs__alternative));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<xs__alternative>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfxs__alternative(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_std__vectorTemplateOfxs__alternative(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<xs__alternative> *p;
	size_t k = sizeof(std::vector<xs__alternative> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<xs__alternative> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<xs__alternative> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<xs__alternative>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfxs__alternative, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfstring(struct soap *soap, std::vector<char *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfstring(struct soap *soap, const std::vector<char *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<char *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_string(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfstring(struct soap *soap, const char *tag, int id, const std::vector<char *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<char *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_string(soap, tag, -1, (char*const*)&(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<char *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfstring(struct soap *soap, const char *tag, std::vector<char *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfstring(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		char *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_string, SOAP_TYPE_std__vectorTemplateOfstring, sizeof(char *), 1, wsdl_finsert, wsdl_fbase))
				break;
			if (!soap_in_string(soap, tag, NULL, "xsd:string"))
				break;
		}
		else
		{	if (!soap_in_string(soap, tag, &n, "xsd:string"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<char *>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfstring(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "wsdl_instantiate_std__vectorTemplateOfstring(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<char *> *p;
	size_t k = sizeof(std::vector<char *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<char *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<char *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<char *>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfstring, n, wsdl_fdelete);
	if (size)
		*size = k;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of wsdlC.cpp */
