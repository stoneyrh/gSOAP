/* wsdlStub.h
   Generated by gSOAP 2.8.24 from ./wsdl.h

gSOAP XML Web services tools
Copyright (C) 2000-2015, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#ifndef wsdlStub_H
#define wsdlStub_H
#include <vector>
#include "includes.h"
#include "stdsoap2.h"
#if GSOAP_VERSION != 20824
# error "GSOAP VERSION 20824 MISMATCH IN GENERATED CODE VERSUS LIBRARY CODE: PLEASE REINSTALL PACKAGE"
#endif


/******************************************************************************\
 *                                                                            *
 * Enumerations                                                               *
 *                                                                            *
\******************************************************************************/

#ifndef SOAP_TYPE_xs__formChoice
#define SOAP_TYPE_xs__formChoice (34)
/* xs:formChoice */
enum xs__formChoice { unqualified = 0, qualified = 1 };
#endif

#ifndef SOAP_TYPE_xs__attribute_use
#define SOAP_TYPE_xs__attribute_use (62)
/* xs:attribute-use */
enum xs__attribute_use { optional = 0, prohibited = 1, required = 2, default_ = 3, fixed_ = 4 };
#endif

#ifndef SOAP_TYPE_xs__processContents
#define SOAP_TYPE_xs__processContents (77)
/* xs:processContents */
enum xs__processContents { strict = 0, skip = 1, lax = 2 };
#endif

#ifndef SOAP_TYPE_soap__styleChoice
#define SOAP_TYPE_soap__styleChoice (230)
/* soap:styleChoice */
enum soap__styleChoice { rpc = 0, document = 1 };
#endif

#ifndef SOAP_TYPE_soap__useChoice
#define SOAP_TYPE_soap__useChoice (234)
/* soap:useChoice */
enum soap__useChoice { literal = 0, encoded = 1 };
#endif

#ifndef SOAP_TYPE_sd__mutability
#define SOAP_TYPE_sd__mutability (277)
/* sd:mutability */
enum sd__mutability { static_ = 0, constant = 1, extendable = 2, mutable_ = 3 };
#endif


/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Classes and Structs                                                        *
 *                                                                            *
\******************************************************************************/


#if 0 /* volatile type: do not declare here, because it is declared already in a library or in other parts of the user's project */

#endif







#ifndef SOAP_TYPE_xs__annotation
#define SOAP_TYPE_xs__annotation (30)
/* xs:annotation */
class SOAP_CMAC xs__annotation
{
public:
	char *documentation;	/* optional element of XSD type xsd:string */
public:
	/// Return the unique type ID value SOAP_TYPE_xs__annotation (30)
	virtual int soap_type(void) const { return 30; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type xs__annotation, default initialized and not managed by a soap context
	virtual xs__annotation *soap_alloc(void) const { return SOAP_NEW(xs__annotation); }
	         xs__annotation() { xs__annotation::soap_default(NULL); }
	virtual ~xs__annotation() { }
	friend xs__annotation *soap_instantiate_xs__annotation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

#ifndef SOAP_TYPE_xs__assert
#define SOAP_TYPE_xs__assert (31)
/* xs:assert */
class SOAP_CMAC xs__assert
{
public:
	char *test;	/* optional attribute of XSD type xsd:string */
	char *xpathDefaultNamespace;	/* optional attribute of XSD type xsd:anyURI */
	xs__annotation *annotation;	/* optional element of XSD type xs:annotation */
public:
	/// Return the unique type ID value SOAP_TYPE_xs__assert (31)
	virtual int soap_type(void) const { return 31; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type xs__assert, default initialized and not managed by a soap context
	virtual xs__assert *soap_alloc(void) const { return SOAP_NEW(xs__assert); }
	         xs__assert() { xs__assert::soap_default(NULL); }
	virtual ~xs__assert() { }
	friend xs__assert *soap_instantiate_xs__assert(struct soap*, int, const char*, const char*, size_t*);
};
#endif

#ifndef SOAP_TYPE_xs__alternative
#define SOAP_TYPE_xs__alternative (33)
/* xs:alternative */
class SOAP_CMAC xs__alternative
{
public:
	char *test;	/* optional attribute of XSD type xsd:string */
	char *type;	/* optional attribute of XSD type xsd:QName */
	char *xpathDefaultNamespace;	/* optional attribute of XSD type xsd:anyURI */
	xs__annotation *annotation;	/* optional element of XSD type xs:annotation */
public:
	/// Return the unique type ID value SOAP_TYPE_xs__alternative (33)
	virtual int soap_type(void) const { return 33; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type xs__alternative, default initialized and not managed by a soap context
	virtual xs__alternative *soap_alloc(void) const { return SOAP_NEW(xs__alternative); }
	         xs__alternative() { xs__alternative::soap_default(NULL); }
	virtual ~xs__alternative() { }
	friend xs__alternative *soap_instantiate_xs__alternative(struct soap*, int, const char*, const char*, size_t*);
};
#endif

#ifndef SOAP_TYPE_xs__element
#define SOAP_TYPE_xs__element (35)
/* Type xs__element is a recursive data type (in)directly referencing itself through its (base) class members */
/* xs:element */
class SOAP_CMAC xs__element
{
public:
	char *name;	/* optional attribute of XSD type xsd:NCName */
	char *ref;	/* optional attribute of XSD type xsd:QName */
	char *type;	/* optional attribute of XSD type xsd:QName */
	char *default_;	/* optional attribute of XSD type xsd:string */
	char *default__;	/* optional attribute of XSD type xsd:QName */
	char *fixed;	/* optional attribute of XSD type xsd:string */
	char *fixed_;	/* optional attribute of XSD type xsd:QName */
	enum xs__formChoice *form;	/* optional attribute of XSD type xs:formChoice */
	bool nillable;	/* optional attribute of XSD type xsd:boolean */
	bool abstract;	/* optional attribute of XSD type xsd:boolean */
	char *substitutionGroup;	/* optional attribute of XSD type xsd:QName */
	char *minOccurs;	/* optional attribute of XSD type xsd:string */
	char *maxOccurs;	/* optional attribute of XSD type xsd:string */
	char *targetNamespace;	/* optional attribute of XSD type xsd:anyURI */
	char *xmime__expectedContentTypes;	/* optional attribute of XSD type xsd:string */
	xs__annotation *annotation;	/* optional element of XSD type xs:annotation */
	class xs__simpleType *simpleType;	/* optional element of XSD type xs:simpleType */
	class xs__complexType *complexType;	/* optional element of XSD type xs:complexType */
	std::vector<xs__alternative> alternative;	/* optional element of XSD type xs:alternative */
	char *unique;	/* optional element of XSD type xsd:string */
private:
	class xs__schema *schemaRef;	/* not serialized */
	xs__element *elementRef;	/* not serialized */
	xs__simpleType *simpleTypeRef;	/* not serialized */
	xs__complexType *complexTypeRef;	/* not serialized */
	std::vector<xs__element *> substitutions;	/* not serialized */
public:
	xs__element();
	int traverse(xs__schema &_param_1);
	void schemaPtr(xs__schema *_param_2);
	void elementPtr(xs__element *_param_3);
	void simpleTypePtr(xs__simpleType *_param_4);
	void complexTypePtr(xs__complexType *_param_5);
	xs__schema *schemaPtr() const;
	xs__element *elementPtr() const;
	xs__simpleType *simpleTypePtr() const;
	xs__complexType *complexTypePtr() const;
	const std::vector<xs__element *> *substitutionsPtr() const;
public:
	/// Return the unique type ID value SOAP_TYPE_xs__element (35)
	virtual int soap_type(void) const { return 35; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type xs__element, default initialized and not managed by a soap context
	virtual xs__element *soap_alloc(void) const { return SOAP_NEW(xs__element); }
	virtual ~xs__element() { }
	friend xs__element *soap_instantiate_xs__element(struct soap*, int, const char*, const char*, size_t*);
};
#endif

#ifndef SOAP_TYPE_xs__attribute
#define SOAP_TYPE_xs__attribute (63)
/* Type xs__attribute is a recursive data type (in)directly referencing itself through its (base) class members */
/* xs:attribute */
class SOAP_CMAC xs__attribute
{
public:
	char *name;	/* optional attribute of XSD type xsd:NCName */
	char *ref;	/* optional attribute of XSD type xsd:QName */
	char *type;	/* optional attribute of XSD type xsd:QName */
	enum xs__attribute_use use;	/* optional attribute of XSD type xs:attribute-use */
	char *default_;	/* optional attribute of XSD type xsd:string */
	char *default__;	/* optional attribute of XSD type xsd:QName */
	char *fixed;	/* optional attribute of XSD type xsd:string */
	char *fixed_;	/* optional attribute of XSD type xsd:QName */
	enum xs__formChoice *form;	/* optional attribute of XSD type xs:formChoice */
	bool inheritable;	/* optional attribute of XSD type xsd:boolean */
	char *targetNamespace;	/* optional attribute of XSD type xsd:anyURI */
	char *wsdl__arrayType;	/* optional attribute of XSD type xsd:QName */
	xs__annotation *annotation;	/* optional element of XSD type xs:annotation */
	xs__simpleType *simpleType;	/* optional element of XSD type xs:simpleType */
private:
	xs__schema *schemaRef;	/* not serialized */
	xs__attribute *attributeRef;	/* not serialized */
	xs__simpleType *simpleTypeRef;	/* not serialized */
public:
	xs__attribute();
	int traverse(xs__schema &_param_6);
	void schemaPtr(xs__schema *_param_7);
	void attributePtr(xs__attribute *_param_8);
	void simpleTypePtr(xs__simpleType *_param_9);
	xs__schema *schemaPtr() const;
	xs__attribute *attributePtr() const;
	xs__simpleType *simpleTypePtr() const;
public:
	/// Return the unique type ID value SOAP_TYPE_xs__attribute (63)
	virtual int soap_type(void) const { return 63; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type xs__attribute, default initialized and not managed by a soap context
	virtual xs__attribute *soap_alloc(void) const { return SOAP_NEW(xs__attribute); }
	virtual ~xs__attribute() { }
	friend xs__attribute *soap_instantiate_xs__attribute(struct soap*, int, const char*, const char*, size_t*);
};
#endif

#ifndef SOAP_TYPE_xs__all
#define SOAP_TYPE_xs__all (74)
/* xs:all */
class SOAP_CMAC xs__all
{
public:
	std::vector<xs__element> element;	/* optional element of XSD type xs:element */
	int traverse(xs__schema &_param_10);
public:
	/// Return the unique type ID value SOAP_TYPE_xs__all (74)
	virtual int soap_type(void) const { return 74; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type xs__all, default initialized and not managed by a soap context
	virtual xs__all *soap_alloc(void) const { return SOAP_NEW(xs__all); }
	         xs__all() { xs__all::soap_default(NULL); }
	virtual ~xs__all() { }
	friend xs__all *soap_instantiate_xs__all(struct soap*, int, const char*, const char*, size_t*);
};
#endif

#ifndef SOAP_TYPE_xs__any
#define SOAP_TYPE_xs__any (79)
/* xs:any */
class SOAP_CMAC xs__any
{
public:
	char *namespace_;	/* optional attribute of XSD type xs:namespaceList */
	enum xs__processContents processContents;	/* optional attribute of XSD type xs:processContents */
	char *minOccurs;	/* optional attribute of XSD type xsd:string */
	char *maxOccurs;	/* optional attribute of XSD type xsd:string */
	std::vector<xs__element> element;	/* optional element of XSD type xs:element */
	int traverse(xs__schema &_param_11);
public:
	/// Return the unique type ID value SOAP_TYPE_xs__any (79)
	virtual int soap_type(void) const { return 79; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type xs__any, default initialized and not managed by a soap context
	virtual xs__any *soap_alloc(void) const { return SOAP_NEW(xs__any); }
	         xs__any() { xs__any::soap_default(NULL); }
	virtual ~xs__any() { }
	friend xs__any *soap_instantiate_xs__any(struct soap*, int, const char*, const char*, size_t*);
};
#endif

#ifndef SOAP_TYPE_xs__union_content
#define SOAP_TYPE_xs__union_content (85)
/* xsd:choice */
union xs__union_content
{
#define SOAP_UNION_xs__union_content_element	(1)
	xs__element *element;
#define SOAP_UNION_xs__union_content_group	(2)
	class xs__group *group;
#define SOAP_UNION_xs__union_content_choice	(3)
	class xs__seqchoice *choice;
#define SOAP_UNION_xs__union_content_sequence	(4)
	xs__seqchoice *sequence;
#define SOAP_UNION_xs__union_content_any	(5)
	xs__any *any;
};
#endif

#ifndef SOAP_TYPE_xs__contents
#define SOAP_TYPE_xs__contents (81)
/* Choice: */
class SOAP_CMAC xs__contents
{
public:
	int __union;	/* union discriminant (of union defined below) */
	union xs__union_content __content;
	int traverse(xs__schema &_param_12);
public:
	/// Return the unique type ID value SOAP_TYPE_xs__contents (81)
	virtual int soap_type(void) const { return 81; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type xs__contents, default initialized and not managed by a soap context
	virtual xs__contents *soap_alloc(void) const { return SOAP_NEW(xs__contents); }
	         xs__contents() { xs__contents::soap_default(NULL); }
	virtual ~xs__contents() { }
	friend xs__contents *soap_instantiate_xs__contents(struct soap*, int, const char*, const char*, size_t*);
};
#endif

#ifndef SOAP_TYPE_xs__seqchoice
#define SOAP_TYPE_xs__seqchoice (26)
/* Type xs__seqchoice is a recursive data type (in)directly referencing itself through its (base) class members */
/* xs:seqchoice */
class SOAP_CMAC xs__seqchoice
{
public:
	char *minOccurs;	/* optional attribute of XSD type xsd:string */
	char *maxOccurs;	/* optional attribute of XSD type xsd:string */
	xs__annotation *annotation;	/* optional element of XSD type xs:annotation */
	std::vector<xs__contents> __contents;
private:
	xs__schema *schemaRef;	/* not serialized */
public:
	xs__seqchoice();
	int traverse(xs__schema &_param_13);
	void schemaPtr(xs__schema *_param_14);
	xs__schema *schemaPtr() const;
public:
	/// Return the unique type ID value SOAP_TYPE_xs__seqchoice (26)
	virtual int soap_type(void) const { return 26; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type xs__seqchoice, default initialized and not managed by a soap context
	virtual xs__seqchoice *soap_alloc(void) const { return SOAP_NEW(xs__seqchoice); }
	virtual ~xs__seqchoice() { }
	friend xs__seqchoice *soap_instantiate_xs__seqchoice(struct soap*, int, const char*, const char*, size_t*);
};
#endif

#ifndef SOAP_TYPE_xs__group
#define SOAP_TYPE_xs__group (27)
/* Type xs__group is a recursive data type (in)directly referencing itself through its (base) class members */
/* xs:group */
class SOAP_CMAC xs__group
{
public:
	char *name;	/* optional attribute of XSD type xsd:NCName */
	char *ref;	/* optional attribute of XSD type xsd:QName */
	char *minOccurs;	/* optional attribute of XSD type xsd:string */
	char *maxOccurs;	/* optional attribute of XSD type xsd:string */
	xs__annotation *annotation;	/* optional element of XSD type xs:annotation */
	xs__all *all;	/* optional element of XSD type xs:all */
	xs__seqchoice *choice;	/* optional element of XSD type xs:seqchoice */
	xs__seqchoice *sequence;	/* optional element of XSD type xs:seqchoice */
private:
	xs__schema *schemaRef;	/* not serialized */
	xs__group *groupRef;	/* not serialized */
public:
	xs__group();
	int traverse(xs__schema &_param_15);
	void schemaPtr(xs__schema *_param_16);
	void groupPtr(xs__group *_param_17);
	xs__schema *schemaPtr() const;
	xs__group *groupPtr() const;
public:
	/// Return the unique type ID value SOAP_TYPE_xs__group (27)
	virtual int soap_type(void) const { return 27; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type xs__group, default initialized and not managed by a soap context
	virtual xs__group *soap_alloc(void) const { return SOAP_NEW(xs__group); }
	virtual ~xs__group() { }
	friend xs__group *soap_instantiate_xs__group(struct soap*, int, const char*, const char*, size_t*);
};
#endif

#ifndef SOAP_TYPE_xs__anyAttribute
#define SOAP_TYPE_xs__anyAttribute (100)
/* xs:anyAttribute */
class SOAP_CMAC xs__anyAttribute
{
public:
	char *namespace_;	/* optional attribute of XSD type xs:namespaceList */
	enum xs__processContents processContents;	/* optional attribute of XSD type xs:processContents */
public:
	/// Return the unique type ID value SOAP_TYPE_xs__anyAttribute (100)
	virtual int soap_type(void) const { return 100; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type xs__anyAttribute, default initialized and not managed by a soap context
	virtual xs__anyAttribute *soap_alloc(void) const { return SOAP_NEW(xs__anyAttribute); }
	         xs__anyAttribute() { xs__anyAttribute::soap_default(NULL); }
	virtual ~xs__anyAttribute() { }
	friend xs__anyAttribute *soap_instantiate_xs__anyAttribute(struct soap*, int, const char*, const char*, size_t*);
};
#endif

#ifndef SOAP_TYPE_xs__attributeGroup
#define SOAP_TYPE_xs__attributeGroup (101)
/* Type xs__attributeGroup is a recursive data type (in)directly referencing itself through its (base) class members */
/* xs:attributeGroup */
class SOAP_CMAC xs__attributeGroup
{
public:
	char *name;	/* optional attribute of XSD type xsd:NCName */
	char *ref;	/* optional attribute of XSD type xsd:QName */
	xs__annotation *annotation;	/* optional element of XSD type xs:annotation */
	std::vector<xs__attribute> attribute;	/* optional element of XSD type xs:attribute */
	std::vector<xs__attributeGroup> attributeGroup;	/* optional element of XSD type xs:attributeGroup */
	xs__anyAttribute *anyAttribute;	/* optional element of XSD type xs:anyAttribute */
private:
	xs__schema *schemaRef;	/* not serialized */
	xs__attributeGroup *attributeGroupRef;	/* not serialized */
public:
	xs__attributeGroup();
	int traverse(xs__schema &_param_18);
	void schemaPtr(xs__schema *_param_19);
	void attributeGroupPtr(xs__attributeGroup *_param_20);
	xs__schema *schemaPtr() const;
	xs__attributeGroup *attributeGroupPtr() const;
public:
	/// Return the unique type ID value SOAP_TYPE_xs__attributeGroup (101)
	virtual int soap_type(void) const { return 101; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type xs__attributeGroup, default initialized and not managed by a soap context
	virtual xs__attributeGroup *soap_alloc(void) const { return SOAP_NEW(xs__attributeGroup); }
	virtual ~xs__attributeGroup() { }
	friend xs__attributeGroup *soap_instantiate_xs__attributeGroup(struct soap*, int, const char*, const char*, size_t*);
};
#endif

#ifndef SOAP_TYPE_xs__enumeration
#define SOAP_TYPE_xs__enumeration (113)
/* xs:enumeration */
class SOAP_CMAC xs__enumeration
{
public:
	char *value;	/* optional attribute of XSD type xsd:string */
	char *value_;	/* optional attribute of XSD type xsd:QName */
	xs__annotation *annotation;	/* optional element of XSD type xs:annotation */
	int traverse(xs__schema &_param_21);
public:
	/// Return the unique type ID value SOAP_TYPE_xs__enumeration (113)
	virtual int soap_type(void) const { return 113; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type xs__enumeration, default initialized and not managed by a soap context
	virtual xs__enumeration *soap_alloc(void) const { return SOAP_NEW(xs__enumeration); }
	         xs__enumeration() { xs__enumeration::soap_default(NULL); }
	virtual ~xs__enumeration() { }
	friend xs__enumeration *soap_instantiate_xs__enumeration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

#ifndef SOAP_TYPE_xs__pattern
#define SOAP_TYPE_xs__pattern (115)
/* xs:pattern */
class SOAP_CMAC xs__pattern
{
public:
	char *value;	/* optional attribute of XSD type xsd:string */
	int traverse(xs__schema &_param_22);
public:
	/// Return the unique type ID value SOAP_TYPE_xs__pattern (115)
	virtual int soap_type(void) const { return 115; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type xs__pattern, default initialized and not managed by a soap context
	virtual xs__pattern *soap_alloc(void) const { return SOAP_NEW(xs__pattern); }
	         xs__pattern() { xs__pattern::soap_default(NULL); }
	virtual ~xs__pattern() { }
	friend xs__pattern *soap_instantiate_xs__pattern(struct soap*, int, const char*, const char*, size_t*);
};
#endif

#ifndef SOAP_TYPE_xs__simpleContent
#define SOAP_TYPE_xs__simpleContent (117)
/* xs:simpleContent */
class SOAP_CMAC xs__simpleContent
{
public:
	class xs__extension *extension;	/* optional element of XSD type xs:extension */
	class xs__restriction *restriction;	/* optional element of XSD type xs:restriction */
	int traverse(xs__schema &_param_23);
public:
	/// Return the unique type ID value SOAP_TYPE_xs__simpleContent (117)
	virtual int soap_type(void) const { return 117; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type xs__simpleContent, default initialized and not managed by a soap context
	virtual xs__simpleContent *soap_alloc(void) const { return SOAP_NEW(xs__simpleContent); }
	         xs__simpleContent() { xs__simpleContent::soap_default(NULL); }
	virtual ~xs__simpleContent() { }
	friend xs__simpleContent *soap_instantiate_xs__simpleContent(struct soap*, int, const char*, const char*, size_t*);
};
#endif

#ifndef SOAP_TYPE_xs__simpleType
#define SOAP_TYPE_xs__simpleType (22)
/* Type xs__simpleType is a recursive data type (in)directly referencing itself through its (base) class members */
/* xs:simpleType */
class SOAP_CMAC xs__simpleType
{
public:
	char *name;	/* optional attribute of XSD type xsd:NMTOKEN */
	char *vc__minVersion;	/* optional attribute of XSD type xsd:string */
	char *vc__maxVersion;	/* optional attribute of XSD type xsd:string */
	xs__annotation *annotation;	/* optional element of XSD type xs:annotation */
	xs__restriction *restriction;	/* optional element of XSD type xs:restriction */
	class xs__list *list;	/* optional element of XSD type xs:list */
	class xs__union *union_;	/* optional element of XSD type xs:union */
private:
	xs__schema *schemaRef;	/* not serialized */
	int level;	/* not serialized */
public:
	xs__simpleType();
	int traverse(xs__schema &_param_24);
	void schemaPtr(xs__schema *_param_25);
	xs__schema *schemaPtr() const;
	int baseLevel();
public:
	/// Return the unique type ID value SOAP_TYPE_xs__simpleType (22)
	virtual int soap_type(void) const { return 22; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type xs__simpleType, default initialized and not managed by a soap context
	virtual xs__simpleType *soap_alloc(void) const { return SOAP_NEW(xs__simpleType); }
	virtual ~xs__simpleType() { }
	friend xs__simpleType *soap_instantiate_xs__simpleType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

#ifndef SOAP_TYPE_xs__extension
#define SOAP_TYPE_xs__extension (24)
/* xs:extension */
class SOAP_CMAC xs__extension
{
public:
	char *base;	/* optional attribute of XSD type xsd:QName */
	xs__group *group;	/* optional element of XSD type xs:group */
	xs__all *all;	/* optional element of XSD type xs:all */
	xs__seqchoice *choice;	/* optional element of XSD type xs:seqchoice */
	xs__seqchoice *sequence;	/* optional element of XSD type xs:seqchoice */
	std::vector<xs__attribute> attribute;	/* optional element of XSD type xs:attribute */
	std::vector<xs__attributeGroup> attributeGroup;	/* optional element of XSD type xs:attributeGroup */
	xs__anyAttribute *anyAttribute;	/* optional element of XSD type xs:anyAttribute */
	xs__annotation *annotation;	/* optional element of XSD type xs:annotation */
	std::vector<xs__assert> assert;	/* optional element of XSD type xs:assert */
private:
	xs__simpleType *simpleTypeRef;	/* not serialized */
	xs__complexType *complexTypeRef;	/* not serialized */
public:
	xs__extension();
	int traverse(xs__schema &_param_26);
	void simpleTypePtr(xs__simpleType *_param_27);
	void complexTypePtr(xs__complexType *_param_28);
	xs__simpleType *simpleTypePtr() const;
	xs__complexType *complexTypePtr() const;
public:
	/// Return the unique type ID value SOAP_TYPE_xs__extension (24)
	virtual int soap_type(void) const { return 24; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type xs__extension, default initialized and not managed by a soap context
	virtual xs__extension *soap_alloc(void) const { return SOAP_NEW(xs__extension); }
	virtual ~xs__extension() { }
	friend xs__extension *soap_instantiate_xs__extension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

#ifndef SOAP_TYPE_xs__length
#define SOAP_TYPE_xs__length (135)
/* xs:length */
class SOAP_CMAC xs__length
{
public:
	char *value;	/* optional attribute of XSD type xsd:string */
	bool fixed;	/* optional attribute of XSD type xsd:boolean */
	xs__annotation *annotation;	/* optional element of XSD type xs:annotation */
public:
	/// Return the unique type ID value SOAP_TYPE_xs__length (135)
	virtual int soap_type(void) const { return 135; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type xs__length, default initialized and not managed by a soap context
	virtual xs__length *soap_alloc(void) const { return SOAP_NEW(xs__length); }
	         xs__length() { xs__length::soap_default(NULL); }
	virtual ~xs__length() { }
	friend xs__length *soap_instantiate_xs__length(struct soap*, int, const char*, const char*, size_t*);
};
#endif

#ifndef SOAP_TYPE_xs__whiteSpace
#define SOAP_TYPE_xs__whiteSpace (136)
/* xs:whiteSpace */
class SOAP_CMAC xs__whiteSpace
{
public:
	char *value;	/* optional attribute of XSD type xsd:string */
public:
	/// Return the unique type ID value SOAP_TYPE_xs__whiteSpace (136)
	virtual int soap_type(void) const { return 136; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type xs__whiteSpace, default initialized and not managed by a soap context
	virtual xs__whiteSpace *soap_alloc(void) const { return SOAP_NEW(xs__whiteSpace); }
	         xs__whiteSpace() { xs__whiteSpace::soap_default(NULL); }
	virtual ~xs__whiteSpace() { }
	friend xs__whiteSpace *soap_instantiate_xs__whiteSpace(struct soap*, int, const char*, const char*, size_t*);
};
#endif

#ifndef SOAP_TYPE_xs__restriction
#define SOAP_TYPE_xs__restriction (25)
/* Type xs__restriction is a recursive data type (in)directly referencing itself through its (base) class members */
/* xs:restriction */
class SOAP_CMAC xs__restriction
{
public:
	char *base;	/* optional attribute of XSD type xsd:QName */
	xs__simpleType *simpleType;	/* optional element of XSD type xs:simpleType */
	xs__attributeGroup *attributeGroup;	/* optional element of XSD type xs:attributeGroup */
	xs__group *group;	/* optional element of XSD type xs:group */
	xs__all *all;	/* optional element of XSD type xs:all */
	xs__seqchoice *choice;	/* optional element of XSD type xs:seqchoice */
	xs__seqchoice *sequence;	/* optional element of XSD type xs:seqchoice */
	std::vector<xs__attribute> attribute;	/* optional element of XSD type xs:attribute */
	xs__anyAttribute *anyAttribute;	/* optional element of XSD type xs:anyAttribute */
	std::vector<xs__enumeration> enumeration;	/* optional element of XSD type xs:enumeration */
	std::vector<xs__pattern> pattern;	/* optional element of XSD type xs:pattern */
	xs__whiteSpace *whiteSpace;	/* optional element of XSD type xs:whiteSpace */
	xs__length *length;	/* optional element of XSD type xs:length */
	xs__length *minLength;	/* optional element of XSD type xs:length */
	xs__length *maxLength;	/* optional element of XSD type xs:length */
	xs__length *precision;	/* optional element of XSD type xs:length */
	xs__length *scale;	/* optional element of XSD type xs:length */
	xs__length *totalDigits;	/* optional element of XSD type xs:length */
	xs__length *fractionDigits;	/* optional element of XSD type xs:length */
	xs__length *minInclusive;	/* optional element of XSD type xs:length */
	xs__length *maxInclusive;	/* optional element of XSD type xs:length */
	xs__length *minExclusive;	/* optional element of XSD type xs:length */
	xs__length *maxExclusive;	/* optional element of XSD type xs:length */
	xs__annotation *annotation;	/* optional element of XSD type xs:annotation */
	std::vector<xs__assert> assert;	/* optional element of XSD type xs:assert */
	xs__assert *assertion;	/* optional element of XSD type xs:assert */
private:
	xs__simpleType *simpleTypeRef;	/* not serialized */
	xs__complexType *complexTypeRef;	/* not serialized */
public:
	xs__restriction();
	int traverse(xs__schema &_param_29);
	void simpleTypePtr(xs__simpleType *_param_30);
	void complexTypePtr(xs__complexType *_param_31);
	xs__simpleType *simpleTypePtr() const;
	xs__complexType *complexTypePtr() const;
public:
	/// Return the unique type ID value SOAP_TYPE_xs__restriction (25)
	virtual int soap_type(void) const { return 25; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type xs__restriction, default initialized and not managed by a soap context
	virtual xs__restriction *soap_alloc(void) const { return SOAP_NEW(xs__restriction); }
	virtual ~xs__restriction() { }
	friend xs__restriction *soap_instantiate_xs__restriction(struct soap*, int, const char*, const char*, size_t*);
};
#endif

#ifndef SOAP_TYPE_xs__list
#define SOAP_TYPE_xs__list (28)
/* xs:list */
class SOAP_CMAC xs__list
{
public:
	char *itemType;	/* optional attribute of XSD type xsd:QName */
	xs__restriction *restriction;	/* optional element of XSD type xs:restriction */
	std::vector<xs__simpleType> simpleType;	/* optional element of XSD type xs:simpleType */
private:
	xs__simpleType *itemTypeRef;	/* not serialized */
public:
	xs__list();
	int traverse(xs__schema &_param_32);
	void itemTypePtr(xs__simpleType *_param_33);
	xs__simpleType *itemTypePtr() const;
public:
	/// Return the unique type ID value SOAP_TYPE_xs__list (28)
	virtual int soap_type(void) const { return 28; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type xs__list, default initialized and not managed by a soap context
	virtual xs__list *soap_alloc(void) const { return SOAP_NEW(xs__list); }
	virtual ~xs__list() { }
	friend xs__list *soap_instantiate_xs__list(struct soap*, int, const char*, const char*, size_t*);
};
#endif

#ifndef SOAP_TYPE_xs__union
#define SOAP_TYPE_xs__union (29)
/* xs:union */
class SOAP_CMAC xs__union
{
public:
	char *memberTypes;	/* optional attribute of XSD type xsd:NMTOKENS */
	std::vector<xs__simpleType> simpleType;	/* optional element of XSD type xs:simpleType */
	int traverse(xs__schema &_param_34);
public:
	/// Return the unique type ID value SOAP_TYPE_xs__union (29)
	virtual int soap_type(void) const { return 29; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type xs__union, default initialized and not managed by a soap context
	virtual xs__union *soap_alloc(void) const { return SOAP_NEW(xs__union); }
	         xs__union() { xs__union::soap_default(NULL); }
	virtual ~xs__union() { }
	friend xs__union *soap_instantiate_xs__union(struct soap*, int, const char*, const char*, size_t*);
};
#endif

#ifndef SOAP_TYPE_xs__complexContent
#define SOAP_TYPE_xs__complexContent (154)
/* xs:complexContent */
class SOAP_CMAC xs__complexContent
{
public:
	bool mixed;	/* optional attribute of XSD type xsd:boolean */
	xs__extension *extension;	/* optional element of XSD type xs:extension */
	xs__restriction *restriction;	/* optional element of XSD type xs:restriction */
	xs__annotation *annotation;	/* optional element of XSD type xs:annotation */
	int traverse(xs__schema &_param_35);
public:
	/// Return the unique type ID value SOAP_TYPE_xs__complexContent (154)
	virtual int soap_type(void) const { return 154; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type xs__complexContent, default initialized and not managed by a soap context
	virtual xs__complexContent *soap_alloc(void) const { return SOAP_NEW(xs__complexContent); }
	         xs__complexContent() { xs__complexContent::soap_default(NULL); }
	virtual ~xs__complexContent() { }
	friend xs__complexContent *soap_instantiate_xs__complexContent(struct soap*, int, const char*, const char*, size_t*);
};
#endif

#ifndef SOAP_TYPE_xs__complexType
#define SOAP_TYPE_xs__complexType (23)
/* Type xs__complexType is a recursive data type (in)directly referencing itself through its (base) class members */
/* xs:complexType */
class SOAP_CMAC xs__complexType
{
public:
	char *name;	/* optional attribute of XSD type xsd:NMTOKEN */
	bool abstract;	/* optional attribute of XSD type xsd:boolean */
	bool mixed;	/* optional attribute of XSD type xsd:boolean */
	bool defaultAttributesApply;	/* optional attribute of XSD type xsd:boolean */
	char *vc__minVersion;	/* optional attribute of XSD type xsd:string */
	char *vc__maxVersion;	/* optional attribute of XSD type xsd:string */
	xs__annotation *annotation;	/* optional element of XSD type xs:annotation */
	xs__simpleContent *simpleContent;	/* optional element of XSD type xs:simpleContent */
	xs__complexContent *complexContent;	/* optional element of XSD type xs:complexContent */
	xs__all *all;	/* optional element of XSD type xs:all */
	xs__seqchoice *choice;	/* optional element of XSD type xs:seqchoice */
	xs__seqchoice *sequence;	/* optional element of XSD type xs:seqchoice */
	xs__any *any;	/* optional element of XSD type xs:any */
	std::vector<xs__attribute> attribute;	/* optional element of XSD type xs:attribute */
	std::vector<xs__attributeGroup> attributeGroup;	/* optional element of XSD type xs:attributeGroup */
	xs__anyAttribute *anyAttribute;	/* optional element of XSD type xs:anyAttribute */
	std::vector<xs__assert> assert;	/* optional element of XSD type xs:assert */
private:
	xs__schema *schemaRef;	/* not serialized */
	int level;	/* not serialized */
public:
	xs__complexType();
	int traverse(xs__schema &_param_36);
	void schemaPtr(xs__schema *_param_37);
	xs__schema *schemaPtr() const;
	int baseLevel();
public:
	/// Return the unique type ID value SOAP_TYPE_xs__complexType (23)
	virtual int soap_type(void) const { return 23; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type xs__complexType, default initialized and not managed by a soap context
	virtual xs__complexType *soap_alloc(void) const { return SOAP_NEW(xs__complexType); }
	virtual ~xs__complexType() { }
	friend xs__complexType *soap_instantiate_xs__complexType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

#ifndef SOAP_TYPE_xs__import
#define SOAP_TYPE_xs__import (163)
/* xs:import */
class SOAP_CMAC xs__import
{
public:
	char *namespace_;	/* optional attribute of XSD type xsd:anyURI */
	char *schemaLocation;	/* optional attribute of XSD type xsd:anyURI */
private:
	xs__schema *schemaRef;	/* not serialized */
public:
	xs__import();
	int traverse(xs__schema &_param_38);
	void schemaPtr(xs__schema *_param_39);
	xs__schema *schemaPtr() const;
public:
	/// Return the unique type ID value SOAP_TYPE_xs__import (163)
	virtual int soap_type(void) const { return 163; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type xs__import, default initialized and not managed by a soap context
	virtual xs__import *soap_alloc(void) const { return SOAP_NEW(xs__import); }
	virtual ~xs__import() { }
	friend xs__import *soap_instantiate_xs__import(struct soap*, int, const char*, const char*, size_t*);
};
#endif

#ifndef SOAP_TYPE_xs__include
#define SOAP_TYPE_xs__include (168)
/* xs:include */
class SOAP_CMAC xs__include
{
public:
	char *schemaLocation;	/* optional attribute of XSD type xsd:anyURI */
private:
	xs__schema *schemaRef;	/* not serialized */
public:
	xs__include();
	int preprocess(xs__schema &_param_40);
	int traverse(xs__schema &_param_41);
	void schemaPtr(xs__schema *_param_42);
	xs__schema *schemaPtr() const;
public:
	/// Return the unique type ID value SOAP_TYPE_xs__include (168)
	virtual int soap_type(void) const { return 168; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type xs__include, default initialized and not managed by a soap context
	virtual xs__include *soap_alloc(void) const { return SOAP_NEW(xs__include); }
	virtual ~xs__include() { }
	friend xs__include *soap_instantiate_xs__include(struct soap*, int, const char*, const char*, size_t*);
};
#endif

#ifndef SOAP_TYPE_xs__override
#define SOAP_TYPE_xs__override (174)
/* xs:override */
class SOAP_CMAC xs__override
{
public:
	char *schemaLocation;	/* optional attribute of XSD type xsd:anyURI */
	std::vector<xs__attribute> attribute;	/* optional element of XSD type xs:attribute */
	std::vector<xs__element> element;	/* optional element of XSD type xs:element */
	std::vector<xs__group> group;	/* optional element of XSD type xs:group */
	std::vector<xs__attributeGroup> attributeGroup;	/* optional element of XSD type xs:attributeGroup */
	std::vector<xs__simpleType> simpleType;	/* optional element of XSD type xs:simpleType */
	std::vector<xs__complexType> complexType;	/* optional element of XSD type xs:complexType */
private:
	xs__schema *schemaRef;	/* not serialized */
public:
	xs__override();
	int preprocess(xs__schema &_param_43);
	int traverse(xs__schema &_param_44);
	void schemaPtr(xs__schema *_param_45);
	xs__schema *schemaPtr() const;
public:
	/// Return the unique type ID value SOAP_TYPE_xs__override (174)
	virtual int soap_type(void) const { return 174; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type xs__override, default initialized and not managed by a soap context
	virtual xs__override *soap_alloc(void) const { return SOAP_NEW(xs__override); }
	virtual ~xs__override() { }
	friend xs__override *soap_instantiate_xs__override(struct soap*, int, const char*, const char*, size_t*);
};
#endif

#ifndef SOAP_TYPE_xs__redefine
#define SOAP_TYPE_xs__redefine (182)
/* xs:redefine */
class SOAP_CMAC xs__redefine
{
public:
	char *schemaLocation;	/* optional attribute of XSD type xsd:anyURI */
	std::vector<xs__group> group;	/* optional element of XSD type xs:group */
	std::vector<xs__attributeGroup> attributeGroup;	/* optional element of XSD type xs:attributeGroup */
	std::vector<xs__simpleType> simpleType;	/* optional element of XSD type xs:simpleType */
	std::vector<xs__complexType> complexType;	/* optional element of XSD type xs:complexType */
private:
	xs__schema *schemaRef;	/* not serialized */
public:
	xs__redefine();
	int preprocess(xs__schema &_param_46);
	int traverse(xs__schema &_param_47);
	void schemaPtr(xs__schema *_param_48);
	xs__schema *schemaPtr() const;
public:
	/// Return the unique type ID value SOAP_TYPE_xs__redefine (182)
	virtual int soap_type(void) const { return 182; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type xs__redefine, default initialized and not managed by a soap context
	virtual xs__redefine *soap_alloc(void) const { return SOAP_NEW(xs__redefine); }
	virtual ~xs__redefine() { }
	friend xs__redefine *soap_instantiate_xs__redefine(struct soap*, int, const char*, const char*, size_t*);
};
#endif

#ifndef SOAP_TYPE_xs__schema
#define SOAP_TYPE_xs__schema (21)
/* Type xs__schema is a recursive data type (in)directly referencing itself through its (base) class members */
/* xs:schema */
class SOAP_CMAC xs__schema
{
public:
	char *targetNamespace;	/* optional attribute of XSD type xsd:anyURI */
	char *version;	/* optional attribute of XSD type xsd:string */
	char *defaultAttributes;	/* optional attribute of XSD type xsd:NCName */
	enum xs__formChoice attributeFormDefault;	/* optional attribute of XSD type xs:formChoice */
	enum xs__formChoice elementFormDefault;	/* optional attribute of XSD type xs:formChoice */
	xs__annotation *annotation;	/* optional element of XSD type xs:annotation */
	std::vector<xs__include> include;	/* optional element of XSD type xs:include */
	std::vector<xs__override> override_;	/* optional element of XSD type xs:override */
	std::vector<xs__redefine> redefine;	/* optional element of XSD type xs:redefine */
	std::vector<xs__import> import;	/* optional element of XSD type xs:import */
	std::vector<xs__attribute> attribute;	/* optional element of XSD type xs:attribute */
	std::vector<xs__element> element;	/* optional element of XSD type xs:element */
	std::vector<xs__group> group;	/* optional element of XSD type xs:group */
	std::vector<xs__attributeGroup> attributeGroup;	/* optional element of XSD type xs:attributeGroup */
	std::vector<xs__simpleType> simpleType;	/* optional element of XSD type xs:simpleType */
	std::vector<xs__complexType> complexType;	/* optional element of XSD type xs:complexType */
	struct soap *soap;	/* transient (not serialized) */
private:
	xs__attributeGroup *attributeGroupRef;	/* not serialized */
	bool updated;	/* not serialized */
	char *location;	/* not serialized */
	int redirs;	/* not serialized */
	SetOfString builtinTypeSet;	/* transient (not serialized) */	/* not serialized */
	SetOfString builtinElementSet;	/* transient (not serialized) */	/* not serialized */
	SetOfString builtinAttributeSet;	/* transient (not serialized) */	/* not serialized */
public:
	xs__schema();
	xs__schema(struct soap *_param_49);
	xs__schema(struct soap *_param_50, const char *_param_51, const char *_param_52);
	virtual ~xs__schema();
	int get(struct soap *_param_53);
	int preprocess();
	int insert(xs__schema &_param_54);
	int traverse();
	int read(const char *_param_55, const char *_param_56);
	void sourceLocation(const char *_param_57);
	const char *sourceLocation();
	xs__attributeGroup *attributeGroupPtr() const;
	int error();
	void print_fault();
	void builtinType(const char *_param_58);
	void builtinElement(const char *_param_59);
	void builtinAttribute(const char *_param_60);
	const SetOfString &builtinTypes() const;	/* not serialized */
	const SetOfString &builtinElements() const;	/* not serialized */
	const SetOfString &builtinAttributes() const;	/* not serialized */
	bool empty() const;
	friend ostream &operator<<(ostream &_param_61, const xs__schema &_param_62);
	friend istream &operator>>(istream &_param_63, xs__schema &_param_64);
public:
	/// Return the unique type ID value SOAP_TYPE_xs__schema (21)
	virtual int soap_type(void) const { return 21; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type xs__schema, default initialized and not managed by a soap context
	virtual xs__schema *soap_alloc(void) const { return SOAP_NEW(xs__schema); }
	friend xs__schema *soap_instantiate_xs__schema(struct soap*, int, const char*, const char*, size_t*);
};
#endif

#ifndef SOAP_TYPE_soap__binding
#define SOAP_TYPE_soap__binding (231)
/* soap:binding */
class SOAP_CMAC soap__binding
{
public:
	char *transport;	/* optional attribute of XSD type xsd:anyURI */
	enum soap__styleChoice *style;	/* optional attribute of XSD type soap:styleChoice */
public:
	/// Return the unique type ID value SOAP_TYPE_soap__binding (231)
	virtual int soap_type(void) const { return 231; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type soap__binding, default initialized and not managed by a soap context
	virtual soap__binding *soap_alloc(void) const { return SOAP_NEW(soap__binding); }
	         soap__binding() { soap__binding::soap_default(NULL); }
	virtual ~soap__binding() { }
	friend soap__binding *soap_instantiate_soap__binding(struct soap*, int, const char*, const char*, size_t*);
};
#endif

#ifndef SOAP_TYPE_soap__operation
#define SOAP_TYPE_soap__operation (233)
/* soap:operation */
class SOAP_CMAC soap__operation
{
public:
	char *soapAction;	/* optional attribute of XSD type xsd:anyURI */
	bool soapActionRequired;	/* optional attribute of XSD type xsd:boolean */
	enum soap__styleChoice *style;	/* optional attribute of XSD type soap:styleChoice */
public:
	/// Return the unique type ID value SOAP_TYPE_soap__operation (233)
	virtual int soap_type(void) const { return 233; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type soap__operation, default initialized and not managed by a soap context
	virtual soap__operation *soap_alloc(void) const { return SOAP_NEW(soap__operation); }
	         soap__operation() { soap__operation::soap_default(NULL); }
	virtual ~soap__operation() { }
	friend soap__operation *soap_instantiate_soap__operation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

#ifndef SOAP_TYPE_soap__body
#define SOAP_TYPE_soap__body (235)
/* soap:body */
class SOAP_CMAC soap__body
{
public:
	char *encodingStyle;	/* optional attribute of XSD type xsd:anyURI */
	char *parts;	/* optional attribute of XSD type xsd:NMTOKENS */
	enum soap__useChoice use;	/* optional attribute of XSD type soap:useChoice */
	char *namespace_;	/* optional attribute of XSD type xsd:anyURI */
public:
	/// Return the unique type ID value SOAP_TYPE_soap__body (235)
	virtual int soap_type(void) const { return 235; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type soap__body, default initialized and not managed by a soap context
	virtual soap__body *soap_alloc(void) const { return SOAP_NEW(soap__body); }
	         soap__body() { soap__body::soap_default(NULL); }
	virtual ~soap__body() { }
	friend soap__body *soap_instantiate_soap__body(struct soap*, int, const char*, const char*, size_t*);
};
#endif

#ifndef SOAP_TYPE_soap__fault
#define SOAP_TYPE_soap__fault (236)
/* soap:fault */
class SOAP_CMAC soap__fault
{
public:
	char *name;	/* optional attribute of XSD type xsd:NMTOKEN */
	char *encodingStyle;	/* optional attribute of XSD type xsd:anyURI */
	enum soap__useChoice use;	/* optional attribute of XSD type soap:useChoice */
	char *namespace_;	/* optional attribute of XSD type xsd:anyURI */
public:
	/// Return the unique type ID value SOAP_TYPE_soap__fault (236)
	virtual int soap_type(void) const { return 236; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type soap__fault, default initialized and not managed by a soap context
	virtual soap__fault *soap_alloc(void) const { return SOAP_NEW(soap__fault); }
	         soap__fault() { soap__fault::soap_default(NULL); }
	virtual ~soap__fault() { }
	friend soap__fault *soap_instantiate_soap__fault(struct soap*, int, const char*, const char*, size_t*);
};
#endif

#ifndef SOAP_TYPE_soap__headerfault
#define SOAP_TYPE_soap__headerfault (237)
/* soap:headerfault */
class SOAP_CMAC soap__headerfault
{
public:
	char *message;	/* optional attribute of XSD type xsd:QName */
	char *part;	/* optional attribute of XSD type xsd:NMTOKEN */
	enum soap__useChoice use;	/* optional attribute of XSD type soap:useChoice */
	char *encodingStyle;	/* optional attribute of XSD type xsd:anyURI */
	char *namespace_;	/* optional attribute of XSD type xsd:anyURI */
private:
	class wsdl__message *messageRef;	/* not serialized */
	class wsdl__part *partRef;	/* not serialized */
public:
	int traverse(class wsdl__definitions &_param_65);
	void messagePtr(wsdl__message *_param_66);
	void partPtr(wsdl__part *_param_67);
	wsdl__message *messagePtr() const;
	wsdl__part *partPtr() const;
public:
	/// Return the unique type ID value SOAP_TYPE_soap__headerfault (237)
	virtual int soap_type(void) const { return 237; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type soap__headerfault, default initialized and not managed by a soap context
	virtual soap__headerfault *soap_alloc(void) const { return SOAP_NEW(soap__headerfault); }
	         soap__headerfault() { soap__headerfault::soap_default(NULL); }
	virtual ~soap__headerfault() { }
	friend soap__headerfault *soap_instantiate_soap__headerfault(struct soap*, int, const char*, const char*, size_t*);
};
#endif

#ifndef SOAP_TYPE_soap__header
#define SOAP_TYPE_soap__header (248)
/* soap:header */
class SOAP_CMAC soap__header
{
public:
	char *message;	/* optional attribute of XSD type xsd:QName */
	char *part;	/* optional attribute of XSD type xsd:NMTOKEN */
	enum soap__useChoice use;	/* optional attribute of XSD type soap:useChoice */
	char *encodingStyle;	/* optional attribute of XSD type xsd:anyURI */
	char *namespace_;	/* optional attribute of XSD type xsd:anyURI */
	std::vector<soap__headerfault> headerfault;	/* optional element of XSD type soap:headerfault */
private:
	wsdl__message *messageRef;	/* not serialized */
	wsdl__part *partRef;	/* not serialized */
public:
	int traverse(wsdl__definitions &_param_68);
	void messagePtr(wsdl__message *_param_69);
	void partPtr(wsdl__part *_param_70);
	wsdl__message *messagePtr() const;
	wsdl__part *partPtr() const;
public:
	/// Return the unique type ID value SOAP_TYPE_soap__header (248)
	virtual int soap_type(void) const { return 248; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type soap__header, default initialized and not managed by a soap context
	virtual soap__header *soap_alloc(void) const { return SOAP_NEW(soap__header); }
	         soap__header() { soap__header::soap_default(NULL); }
	virtual ~soap__header() { }
	friend soap__header *soap_instantiate_soap__header(struct soap*, int, const char*, const char*, size_t*);
};
#endif

#ifndef SOAP_TYPE_soap__address
#define SOAP_TYPE_soap__address (255)
/* soap:address */
class SOAP_CMAC soap__address
{
public:
	char *location;	/* optional attribute of XSD type xsd:anyURI */
public:
	/// Return the unique type ID value SOAP_TYPE_soap__address (255)
	virtual int soap_type(void) const { return 255; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type soap__address, default initialized and not managed by a soap context
	virtual soap__address *soap_alloc(void) const { return SOAP_NEW(soap__address); }
	         soap__address() { soap__address::soap_default(NULL); }
	virtual ~soap__address() { }
	friend soap__address *soap_instantiate_soap__address(struct soap*, int, const char*, const char*, size_t*);
};
#endif

#ifndef SOAP_TYPE_wsoap__module
#define SOAP_TYPE_wsoap__module (256)
/* wsoap:module */
class SOAP_CMAC wsoap__module
{
public:
	char *ref;	/* optional attribute of XSD type xsd:anyURI */
	bool required;	/* optional attribute of XSD type xsd:boolean */
public:
	/// Return the unique type ID value SOAP_TYPE_wsoap__module (256)
	virtual int soap_type(void) const { return 256; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsoap__module, default initialized and not managed by a soap context
	virtual wsoap__module *soap_alloc(void) const { return SOAP_NEW(wsoap__module); }
	         wsoap__module() { wsoap__module::soap_default(NULL); }
	virtual ~wsoap__module() { }
	friend wsoap__module *soap_instantiate_wsoap__module(struct soap*, int, const char*, const char*, size_t*);
};
#endif

#ifndef SOAP_TYPE_wsoap__header
#define SOAP_TYPE_wsoap__header (257)
/* wsoap:header */
class SOAP_CMAC wsoap__header
{
public:
	char *element;	/* optional attribute of XSD type xsd:QName */
	bool mustUnderstand_;	/* optional attribute of XSD type xsd:boolean */
	bool required;	/* optional attribute of XSD type xsd:boolean */
private:
	xs__element *elementRef;	/* not serialized */
public:
	int traverse(wsdl__definitions &_param_71);
	void elementPtr(xs__element *_param_72);
	xs__element *elementPtr() const;
public:
	/// Return the unique type ID value SOAP_TYPE_wsoap__header (257)
	virtual int soap_type(void) const { return 257; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsoap__header, default initialized and not managed by a soap context
	virtual wsoap__header *soap_alloc(void) const { return SOAP_NEW(wsoap__header); }
	         wsoap__header() { wsoap__header::soap_default(NULL); }
	virtual ~wsoap__header() { }
	friend wsoap__header *soap_instantiate_wsoap__header(struct soap*, int, const char*, const char*, size_t*);
};
#endif

#ifndef SOAP_TYPE_mime__content
#define SOAP_TYPE_mime__content (261)
/* mime:content */
class SOAP_CMAC mime__content
{
public:
	char *part;	/* optional attribute of XSD type xsd:NMTOKEN */
	char *type;	/* optional attribute of XSD type xsd:string */
public:
	/// Return the unique type ID value SOAP_TYPE_mime__content (261)
	virtual int soap_type(void) const { return 261; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type mime__content, default initialized and not managed by a soap context
	virtual mime__content *soap_alloc(void) const { return SOAP_NEW(mime__content); }
	         mime__content() { mime__content::soap_default(NULL); }
	virtual ~mime__content() { }
	friend mime__content *soap_instantiate_mime__content(struct soap*, int, const char*, const char*, size_t*);
};
#endif

#ifndef SOAP_TYPE_mime__part
#define SOAP_TYPE_mime__part (262)
/* mime:part */
class SOAP_CMAC mime__part
{
public:
	soap__body *soap__body_;	/* optional element of XSD type soap:body */
	std::vector<soap__header> soap__header_;	/* optional element of XSD type soap:header */
	std::vector<mime__content> content;	/* optional element of XSD type mime:content */
	int traverse(wsdl__definitions &_param_73);
public:
	/// Return the unique type ID value SOAP_TYPE_mime__part (262)
	virtual int soap_type(void) const { return 262; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type mime__part, default initialized and not managed by a soap context
	virtual mime__part *soap_alloc(void) const { return SOAP_NEW(mime__part); }
	         mime__part() { mime__part::soap_default(NULL); }
	virtual ~mime__part() { }
	friend mime__part *soap_instantiate_mime__part(struct soap*, int, const char*, const char*, size_t*);
};
#endif

#ifndef SOAP_TYPE_mime__multipartRelated
#define SOAP_TYPE_mime__multipartRelated (267)
/* mime:multipartRelated */
class SOAP_CMAC mime__multipartRelated
{
public:
	std::vector<mime__part> part;	/* optional element of XSD type mime:part */
	int traverse(wsdl__definitions &_param_74);
public:
	/// Return the unique type ID value SOAP_TYPE_mime__multipartRelated (267)
	virtual int soap_type(void) const { return 267; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type mime__multipartRelated, default initialized and not managed by a soap context
	virtual mime__multipartRelated *soap_alloc(void) const { return SOAP_NEW(mime__multipartRelated); }
	         mime__multipartRelated() { mime__multipartRelated::soap_default(NULL); }
	virtual ~mime__multipartRelated() { }
	friend mime__multipartRelated *soap_instantiate_mime__multipartRelated(struct soap*, int, const char*, const char*, size_t*);
};
#endif

#ifndef SOAP_TYPE_mime__mimeXml
#define SOAP_TYPE_mime__mimeXml (270)
/* mime:mimeXml */
class SOAP_CMAC mime__mimeXml
{
public:
	char *part;	/* optional attribute of XSD type xsd:NMTOKEN */
public:
	/// Return the unique type ID value SOAP_TYPE_mime__mimeXml (270)
	virtual int soap_type(void) const { return 270; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type mime__mimeXml, default initialized and not managed by a soap context
	virtual mime__mimeXml *soap_alloc(void) const { return SOAP_NEW(mime__mimeXml); }
	         mime__mimeXml() { mime__mimeXml::soap_default(NULL); }
	virtual ~mime__mimeXml() { }
	friend mime__mimeXml *soap_instantiate_mime__mimeXml(struct soap*, int, const char*, const char*, size_t*);
};
#endif

#ifndef SOAP_TYPE_dime__message
#define SOAP_TYPE_dime__message (271)
/* dime:message */
class SOAP_CMAC dime__message
{
public:
	char *layout;	/* optional attribute of XSD type xsd:anyURI */
public:
	/// Return the unique type ID value SOAP_TYPE_dime__message (271)
	virtual int soap_type(void) const { return 271; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type dime__message, default initialized and not managed by a soap context
	virtual dime__message *soap_alloc(void) const { return SOAP_NEW(dime__message); }
	         dime__message() { dime__message::soap_default(NULL); }
	virtual ~dime__message() { }
	friend dime__message *soap_instantiate_dime__message(struct soap*, int, const char*, const char*, size_t*);
};
#endif

#ifndef SOAP_TYPE_http__address
#define SOAP_TYPE_http__address (272)
/* http:address */
class SOAP_CMAC http__address
{
public:
	char *location;	/* optional attribute of XSD type xsd:anyURI */
public:
	/// Return the unique type ID value SOAP_TYPE_http__address (272)
	virtual int soap_type(void) const { return 272; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type http__address, default initialized and not managed by a soap context
	virtual http__address *soap_alloc(void) const { return SOAP_NEW(http__address); }
	         http__address() { http__address::soap_default(NULL); }
	virtual ~http__address() { }
	friend http__address *soap_instantiate_http__address(struct soap*, int, const char*, const char*, size_t*);
};
#endif

#ifndef SOAP_TYPE_http__binding
#define SOAP_TYPE_http__binding (273)
/* http:binding */
class SOAP_CMAC http__binding
{
public:
	char *verb;	/* optional attribute of XSD type xsd:NMTOKEN */
public:
	/// Return the unique type ID value SOAP_TYPE_http__binding (273)
	virtual int soap_type(void) const { return 273; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type http__binding, default initialized and not managed by a soap context
	virtual http__binding *soap_alloc(void) const { return SOAP_NEW(http__binding); }
	         http__binding() { http__binding::soap_default(NULL); }
	virtual ~http__binding() { }
	friend http__binding *soap_instantiate_http__binding(struct soap*, int, const char*, const char*, size_t*);
};
#endif

#ifndef SOAP_TYPE_http__operation
#define SOAP_TYPE_http__operation (274)
/* http:operation */
class SOAP_CMAC http__operation
{
public:
	char *location;	/* optional attribute of XSD type xsd:anyURI */
public:
	/// Return the unique type ID value SOAP_TYPE_http__operation (274)
	virtual int soap_type(void) const { return 274; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type http__operation, default initialized and not managed by a soap context
	virtual http__operation *soap_alloc(void) const { return SOAP_NEW(http__operation); }
	         http__operation() { http__operation::soap_default(NULL); }
	virtual ~http__operation() { }
	friend http__operation *soap_instantiate_http__operation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

#ifndef SOAP_TYPE_whttp__header
#define SOAP_TYPE_whttp__header (275)
/* whttp:header */
class SOAP_CMAC whttp__header
{
public:
	char *name;	/* optional attribute of XSD type xsd:string */
	char *type;	/* optional attribute of XSD type xsd:QName */
	bool required;	/* optional attribute of XSD type xsd:boolean */
public:
	/// Return the unique type ID value SOAP_TYPE_whttp__header (275)
	virtual int soap_type(void) const { return 275; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type whttp__header, default initialized and not managed by a soap context
	virtual whttp__header *soap_alloc(void) const { return SOAP_NEW(whttp__header); }
	         whttp__header() { whttp__header::soap_default(NULL); }
	virtual ~whttp__header() { }
	friend whttp__header *soap_instantiate_whttp__header(struct soap*, int, const char*, const char*, size_t*);
};
#endif

#ifndef SOAP_TYPE_sd__serviceData
#define SOAP_TYPE_sd__serviceData (278)
/* sd:serviceData */
class SOAP_CMAC sd__serviceData
{
public:
	char *name;	/* optional attribute of XSD type xsd:NMTOKEN */
	char *type;	/* optional attribute of XSD type xsd:QName */
	bool nillable;	/* optional attribute of XSD type xsd:boolean */
	char *minOccurs;	/* optional attribute of XSD type xsd:string */
	char *maxOccurs;	/* optional attribute of XSD type xsd:string */
	enum sd__mutability mutability;	/* optional attribute of XSD type sd:mutability */
	bool modifiable;	/* optional attribute of XSD type xsd:boolean */
public:
	/// Return the unique type ID value SOAP_TYPE_sd__serviceData (278)
	virtual int soap_type(void) const { return 278; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type sd__serviceData, default initialized and not managed by a soap context
	virtual sd__serviceData *soap_alloc(void) const { return SOAP_NEW(sd__serviceData); }
	         sd__serviceData() { sd__serviceData::soap_default(NULL); }
	virtual ~sd__serviceData() { }
	friend sd__serviceData *soap_instantiate_sd__serviceData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

#ifndef SOAP_TYPE_sd__staticServiceDataValues
#define SOAP_TYPE_sd__staticServiceDataValues (279)
/* sd:staticServiceDataValues */
class SOAP_CMAC sd__staticServiceDataValues
{
public:
	int __type;	/* any type of element <any> (defined below)
	   WARNING: do not create a cyclic data structure graph throught this element unless SOAP encoding or SOAP_XML_GRAPH are used for id-ref serialization */
	void *_any;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_sd__staticServiceDataValues (279)
	virtual int soap_type(void) const { return 279; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type sd__staticServiceDataValues, default initialized and not managed by a soap context
	virtual sd__staticServiceDataValues *soap_alloc(void) const { return SOAP_NEW(sd__staticServiceDataValues); }
	         sd__staticServiceDataValues() { sd__staticServiceDataValues::soap_default(NULL); }
	virtual ~sd__staticServiceDataValues() { }
	friend sd__staticServiceDataValues *soap_instantiate_sd__staticServiceDataValues(struct soap*, int, const char*, const char*, size_t*);
};
#endif

#ifndef SOAP_TYPE_gwsdl__portType
#define SOAP_TYPE_gwsdl__portType (281)
/* gwsdl:portType */
class SOAP_CMAC gwsdl__portType
{
public:
	char *name;	/* optional attribute of XSD type xsd:NMTOKEN */
	char *extends;	/* optional attribute of XSD type xsd:QName */
	char *documentation;	/* optional element of XSD type xsd:string */
	std::vector<class wsdl__operation *> operation;	/* optional element of XSD type wsdl:operation */
	std::vector<sd__serviceData> sd__serviceData_;	/* optional element of XSD type sd:serviceData */
	sd__staticServiceDataValues *sd__staticServiceDataValues_;	/* optional element of XSD type sd:staticServiceDataValues */
public:
	/// Return the unique type ID value SOAP_TYPE_gwsdl__portType (281)
	virtual int soap_type(void) const { return 281; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gwsdl__portType, default initialized and not managed by a soap context
	virtual gwsdl__portType *soap_alloc(void) const { return SOAP_NEW(gwsdl__portType); }
	         gwsdl__portType() { gwsdl__portType::soap_default(NULL); }
	virtual ~gwsdl__portType() { }
	friend gwsdl__portType *soap_instantiate_gwsdl__portType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

#ifndef SOAP_TYPE_wsa__EndpointReferenceType
#define SOAP_TYPE_wsa__EndpointReferenceType (286)
/* wsa:EndpointReferenceType */
class SOAP_CMAC wsa__EndpointReferenceType
{
public:
	char *Address;	/* optional element of XSD type xsd:anyURI */
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_wsa__EndpointReferenceType (286)
	virtual int soap_type(void) const { return 286; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsa__EndpointReferenceType, default initialized and not managed by a soap context
	virtual wsa__EndpointReferenceType *soap_alloc(void) const { return SOAP_NEW(wsa__EndpointReferenceType); }
	         wsa__EndpointReferenceType() { wsa__EndpointReferenceType::soap_default(NULL); }
	virtual ~wsa__EndpointReferenceType() { }
	friend wsa__EndpointReferenceType *soap_instantiate_wsa__EndpointReferenceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif





#ifndef SOAP_TYPE_wsp__PolicyReference
#define SOAP_TYPE_wsp__PolicyReference (291)
/* wsp:PolicyReference */
class SOAP_CMAC wsp__PolicyReference
{
public:
	char *URI;	/* optional attribute of XSD type xsd:anyURI */
	char *Digest;	/* optional attribute of XSD type xsd:string */
	char *DigestAlgorithm;	/* optional attribute of XSD type xsd:anyURI */
private:
	class wsp__Policy *policyRef;	/* not serialized */
public:
	int traverse(wsdl__definitions &_param_75);
	void policyPtr(wsp__Policy *_param_76);
	wsp__Policy *policyPtr() const;
public:
	/// Return the unique type ID value SOAP_TYPE_wsp__PolicyReference (291)
	virtual int soap_type(void) const { return 291; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsp__PolicyReference, default initialized and not managed by a soap context
	virtual wsp__PolicyReference *soap_alloc(void) const { return SOAP_NEW(wsp__PolicyReference); }
	         wsp__PolicyReference() { wsp__PolicyReference::soap_default(NULL); }
	virtual ~wsp__PolicyReference() { }
	friend wsp__PolicyReference *soap_instantiate_wsp__PolicyReference(struct soap*, int, const char*, const char*, size_t*);
};
#endif

#ifndef SOAP_TYPE_wsp__Assertion
#define SOAP_TYPE_wsp__Assertion (297)
/* Type wsp__Assertion is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsp:Assertion */
class SOAP_CMAC wsp__Assertion
{
public:
	bool Optional;	/* optional attribute of XSD type xsd:boolean */
	bool Ignorable;	/* optional attribute of XSD type xsd:boolean */
	class wsp__Content *Policy;	/* optional element of XSD type wsp:Content */
public:
	/// Return the unique type ID value SOAP_TYPE_wsp__Assertion (297)
	virtual int soap_type(void) const { return 297; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsp__Assertion, default initialized and not managed by a soap context
	virtual wsp__Assertion *soap_alloc(void) const { return SOAP_NEW(wsp__Assertion); }
	         wsp__Assertion() { wsp__Assertion::soap_default(NULL); }
	virtual ~wsp__Assertion() { }
	friend wsp__Assertion *soap_instantiate_wsp__Assertion(struct soap*, int, const char*, const char*, size_t*);
};
#endif

#ifndef SOAP_TYPE_wst__Claims
#define SOAP_TYPE_wst__Claims (299)
/* Primitive wst:Claims schema type: */
class SOAP_CMAC wst__Claims
{
public:
	char *Dialect;	/* optional attribute of XSD type xsd:string */
	char *__item;	/* mixed XML content */
public:
	/// Return the unique type ID value SOAP_TYPE_wst__Claims (299)
	virtual int soap_type(void) const { return 299; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wst__Claims, default initialized and not managed by a soap context
	virtual wst__Claims *soap_alloc(void) const { return SOAP_NEW(wst__Claims); }
	         wst__Claims() { wst__Claims::soap_default(NULL); }
	virtual ~wst__Claims() { }
	friend wst__Claims *soap_instantiate_wst__Claims(struct soap*, int, const char*, const char*, size_t*);
};
#endif

#ifndef SOAP_TYPE_sp__Header
#define SOAP_TYPE_sp__Header (300)
/* sp:Header */
class SOAP_CMAC sp__Header
{
public:
	char *Name;	/* optional attribute of XSD type xsd:NCName */
	char *Namespace;	/* optional attribute of XSD type xsd:anyURI */
public:
	/// Return the unique type ID value SOAP_TYPE_sp__Header (300)
	virtual int soap_type(void) const { return 300; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type sp__Header, default initialized and not managed by a soap context
	virtual sp__Header *soap_alloc(void) const { return SOAP_NEW(sp__Header); }
	         sp__Header() { sp__Header::soap_default(NULL); }
	virtual ~sp__Header() { }
	friend sp__Header *soap_instantiate_sp__Header(struct soap*, int, const char*, const char*, size_t*);
};
#endif

#ifndef SOAP_TYPE_sp__Parts
#define SOAP_TYPE_sp__Parts (301)
/* sp:Parts */
class SOAP_CMAC sp__Parts
{
public:
	char *Body;	/* optional element of XSD type xsd:string */
	std::vector<sp__Header> Header;	/* optional element of XSD type sp:Header */
	char *Attachments;	/* optional element of XSD type xsd:string */
public:
	/// Return the unique type ID value SOAP_TYPE_sp__Parts (301)
	virtual int soap_type(void) const { return 301; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type sp__Parts, default initialized and not managed by a soap context
	virtual sp__Parts *soap_alloc(void) const { return SOAP_NEW(sp__Parts); }
	         sp__Parts() { sp__Parts::soap_default(NULL); }
	virtual ~sp__Parts() { }
	friend sp__Parts *soap_instantiate_sp__Parts(struct soap*, int, const char*, const char*, size_t*);
};
#endif

#ifndef SOAP_TYPE_sp__Elements
#define SOAP_TYPE_sp__Elements (303)
/* sp:Elements */
class SOAP_CMAC sp__Elements
{
public:
	char *XPathVersion;	/* optional attribute of XSD type xsd:anyURI */
	std::vector<char *> XPath;	/* optional element of XSD type xsd:string */
public:
	/// Return the unique type ID value SOAP_TYPE_sp__Elements (303)
	virtual int soap_type(void) const { return 303; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type sp__Elements, default initialized and not managed by a soap context
	virtual sp__Elements *soap_alloc(void) const { return SOAP_NEW(sp__Elements); }
	         sp__Elements() { sp__Elements::soap_default(NULL); }
	virtual ~sp__Elements() { }
	friend sp__Elements *soap_instantiate_sp__Elements(struct soap*, int, const char*, const char*, size_t*);
};
#endif

#ifndef SOAP_TYPE_sp__Token
#define SOAP_TYPE_sp__Token (305)
/* Type sp__Token is a recursive data type (in)directly referencing itself through its (base) class members */
/* sp:Token */
class SOAP_CMAC sp__Token : public wsp__Assertion
{
public:
	char *IncludeToken;	/* optional attribute of XSD type xsd:anyURI */
	wsa__EndpointReferenceType *Issuer;	/* optional element of XSD type wsa:EndpointReferenceType */
	char *IssuerName;	/* optional element of XSD type xsd:anyURI */
	wst__Claims *wst__Claims_;	/* optional element of XSD type wst:Claims */
public:
	/// Return the unique type ID value SOAP_TYPE_sp__Token (305)
	virtual int soap_type(void) const { return 305; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type sp__Token, default initialized and not managed by a soap context
	virtual sp__Token *soap_alloc(void) const { return SOAP_NEW(sp__Token); }
	         sp__Token() { sp__Token::soap_default(NULL); }
	virtual ~sp__Token() { }
	friend sp__Token *soap_instantiate_sp__Token(struct soap*, int, const char*, const char*, size_t*);
};
#endif

#ifndef SOAP_TYPE_wsrmp__Timeout
#define SOAP_TYPE_wsrmp__Timeout (308)
/* wsrmp:Timeout */
class SOAP_CMAC wsrmp__Timeout
{
public:
	char *Milliseconds;	/* optional attribute of XSD type xsd:string */
public:
	/// Return the unique type ID value SOAP_TYPE_wsrmp__Timeout (308)
	virtual int soap_type(void) const { return 308; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsrmp__Timeout, default initialized and not managed by a soap context
	virtual wsrmp__Timeout *soap_alloc(void) const { return SOAP_NEW(wsrmp__Timeout); }
	         wsrmp__Timeout() { wsrmp__Timeout::soap_default(NULL); }
	virtual ~wsrmp__Timeout() { }
	friend wsrmp__Timeout *soap_instantiate_wsrmp__Timeout(struct soap*, int, const char*, const char*, size_t*);
};
#endif

#ifndef SOAP_TYPE_wsrmp__RMAssertion
#define SOAP_TYPE_wsrmp__RMAssertion (309)
/* Type wsrmp__RMAssertion is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsrmp:RMAssertion */
class SOAP_CMAC wsrmp__RMAssertion : public wsp__Assertion
{
public:
	wsrmp__Timeout *InactivityTimeout;	/* optional element of XSD type wsrmp:Timeout */
	wsrmp__Timeout *BaseRetransmissionInterval;	/* optional element of XSD type wsrmp:Timeout */
	wsrmp__Timeout *AcknowledgementInterval;	/* optional element of XSD type wsrmp:Timeout */
	char *ExponentialBackoff;	/* optional element of XSD type xsd:string */
public:
	/// Return the unique type ID value SOAP_TYPE_wsrmp__RMAssertion (309)
	virtual int soap_type(void) const { return 309; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsrmp__RMAssertion, default initialized and not managed by a soap context
	virtual wsrmp__RMAssertion *soap_alloc(void) const { return SOAP_NEW(wsrmp__RMAssertion); }
	         wsrmp__RMAssertion() { wsrmp__RMAssertion::soap_default(NULL); }
	virtual ~wsrmp__RMAssertion() { }
	friend wsrmp__RMAssertion *soap_instantiate_wsrmp__RMAssertion(struct soap*, int, const char*, const char*, size_t*);
};
#endif

#ifndef SOAP_TYPE_wsp__Content
#define SOAP_TYPE_wsp__Content (288)
/* Type wsp__Content is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsp:Content */
class SOAP_CMAC wsp__Content
{
public:
	wsp__Policy *Policy;	/* optional element of XSD type wsp:Policy */
	wsp__PolicyReference *PolicyReference;	/* optional element of XSD type wsp:PolicyReference */
	std::vector<wsp__Content *> All;	/* optional element of XSD type wsp:Content */
	std::vector<wsp__Content *> ExactlyOne;	/* optional element of XSD type wsp:Content */
	std::vector<sp__Parts> sp__SignedParts;	/* optional element of XSD type sp:Parts */
	std::vector<sp__Parts> sp__EncryptedParts;	/* optional element of XSD type sp:Parts */
	std::vector<sp__Parts> sp__RequiredParts;	/* optional element of XSD type sp:Parts */
	sp__Elements *sp__SignedElements;	/* optional element of XSD type sp:Elements */
	sp__Elements *sp__EncryptedElements;	/* optional element of XSD type sp:Elements */
	sp__Elements *sp__ContentEncryptedElements;	/* optional element of XSD type sp:Elements */
	sp__Elements *sp__RequiredElements;	/* optional element of XSD type sp:Elements */
	sp__Token *sp__UsernameToken;	/* optional element of XSD type sp:Token */
	sp__Token *sp__IssuedToken;	/* optional element of XSD type sp:Token */
	sp__Token *sp__X509Token;	/* optional element of XSD type sp:Token */
	sp__Token *sp__KerberosToken;	/* optional element of XSD type sp:Token */
	sp__Token *sp__SpnegoContextToken;	/* optional element of XSD type sp:Token */
	sp__Token *sp__SecurityContextToken;	/* optional element of XSD type sp:Token */
	sp__Token *sp__SecureConversationToken;	/* optional element of XSD type sp:Token */
	sp__Token *sp__SamlToken;	/* optional element of XSD type sp:Token */
	sp__Token *sp__RelToken;	/* optional element of XSD type sp:Token */
	sp__Token *sp__HttpsToken;	/* optional element of XSD type sp:Token */
	sp__Token *sp__KeyValueToken;	/* optional element of XSD type sp:Token */
	wsp__Assertion *sp__TransportBinding;	/* optional element of XSD type wsp:Assertion */
	wsp__Assertion *sp__TransportToken;	/* optional element of XSD type wsp:Assertion */
	wsp__Assertion *sp__AlgorithmSuite;	/* optional element of XSD type wsp:Assertion */
	wsp__Assertion *sp__Layout;	/* optional element of XSD type wsp:Assertion */
	wsp__Assertion *sp__SymmetricBinding;	/* optional element of XSD type wsp:Assertion */
	wsp__Assertion *sp__AsymmetricBinding;	/* optional element of XSD type wsp:Assertion */
	wsp__Assertion *sp__ProtectionToken;	/* optional element of XSD type wsp:Assertion */
	wsp__Assertion *sp__InitiatorToken;	/* optional element of XSD type wsp:Assertion */
	wsp__Assertion *sp__InitiatorSignatureToken;	/* optional element of XSD type wsp:Assertion */
	wsp__Assertion *sp__InitiatorEncryptionToken;	/* optional element of XSD type wsp:Assertion */
	wsp__Assertion *sp__RecipientToken;	/* optional element of XSD type wsp:Assertion */
	wsp__Assertion *sp__SupportingTokens;	/* optional element of XSD type wsp:Assertion */
	wsp__Assertion *sp__SignedSupportingTokens;	/* optional element of XSD type wsp:Assertion */
	wsp__Assertion *sp__EndorsingSupportingTokens;	/* optional element of XSD type wsp:Assertion */
	wsp__Assertion *sp__SignedEndorsingSupportingTokens;	/* optional element of XSD type wsp:Assertion */
	wsp__Assertion *sp__SignedEncryptedSupportingTokens;	/* optional element of XSD type wsp:Assertion */
	wsp__Assertion *sp__EncryptedSupportingTokens;	/* optional element of XSD type wsp:Assertion */
	wsp__Assertion *sp__EndorsingEncryptedSupportingTokens;	/* optional element of XSD type wsp:Assertion */
	wsp__Assertion *sp__SignedEndorsingEncryptedSupportingTokens;	/* optional element of XSD type wsp:Assertion */
	wsp__Assertion *sp__Wss10;	/* optional element of XSD type wsp:Assertion */
	wsp__Assertion *sp__Wss11;	/* optional element of XSD type wsp:Assertion */
	wsp__Assertion *sp__Trust10;	/* optional element of XSD type wsp:Assertion */
	wsp__Assertion *sp__Trust13;	/* optional element of XSD type wsp:Assertion */
	wsp__Content *sp__BootstrapPolicy;	/* optional element of XSD type wsp:Content */
	char *wsaw__UsingAddressing;	/* optional element of XSD type xsd:string */
	wsp__Assertion *wsam__Addressing;	/* optional element of XSD type wsp:Assertion */
	wsrmp__RMAssertion *wsrmp__RMAssertion_;	/* optional element of XSD type wsrmp:RMAssertion */
	wsrmp__RMAssertion *wsrmp__DeliveryAssurance;	/* optional element of XSD type wsrmp:RMAssertion */
	char *wsrmp__AtLeastOnce;	/* optional element of XSD type xsd:string */
	char *wsrmp__AtMostOnce;	/* optional element of XSD type xsd:string */
	char *wsrmp__ExactlyOnce;	/* optional element of XSD type xsd:string */
	char *wsrmp__InOrder;	/* optional element of XSD type xsd:string */
	wsp__Assertion *sp__NoPassword;	/* optional element of XSD type wsp:Assertion */
	wsp__Assertion *sp__HashPassword;	/* optional element of XSD type wsp:Assertion */
	wsp__Assertion *sp__IncludeTimestamp;	/* optional element of XSD type wsp:Assertion */
	wsp__Assertion *sp__EncryptBeforeSigning;	/* optional element of XSD type wsp:Assertion */
	wsp__Assertion *sp__EncryptSignature;	/* optional element of XSD type wsp:Assertion */
	wsp__Assertion *sp__ProtectTokens;	/* optional element of XSD type wsp:Assertion */
	wsp__Assertion *sp__OnlySignEntireHeadersAndBody;	/* optional element of XSD type wsp:Assertion */
	char *sp__RequireDerivedKeys;	/* optional element of XSD type xsd:string */
	char *sp__RequireImpliedDerivedKeys;	/* optional element of XSD type xsd:string */
	char *sp__RequireExplicitDerivedKeys;	/* optional element of XSD type xsd:string */
	char *sp__WssUsernameToken10;	/* optional element of XSD type xsd:string */
	char *sp__WssUsernameToken11;	/* optional element of XSD type xsd:string */
	char *sp__RequireExternalReference;	/* optional element of XSD type xsd:string */
	char *sp__RequireInternalReference;	/* optional element of XSD type xsd:string */
	char *sp__RequireKeyIdentifierReference;	/* optional element of XSD type xsd:string */
	char *sp__RequireIssuerSerialReference;	/* optional element of XSD type xsd:string */
	char *sp__RequireEmbeddedTokenReference;	/* optional element of XSD type xsd:string */
	char *sp__RequireThumbprintReference;	/* optional element of XSD type xsd:string */
	char *sp__WssX509V3Token10;	/* optional element of XSD type xsd:string */
	char *sp__WssX509Pkcs7Token10;	/* optional element of XSD type xsd:string */
	char *sp__WssX509PkiPathV1Token10;	/* optional element of XSD type xsd:string */
	char *sp__WssX509V1Token11;	/* optional element of XSD type xsd:string */
	char *sp__WssX509V3Token11;	/* optional element of XSD type xsd:string */
	char *sp__WssX509Pkcs7Token11;	/* optional element of XSD type xsd:string */
	char *sp__WssX509PkiPathV1Token11;	/* optional element of XSD type xsd:string */
	char *sp__WssKerberosV5ApReqToken11;	/* optional element of XSD type xsd:string */
	char *sp__WssGssKerberosV5ApReqToken11;	/* optional element of XSD type xsd:string */
	char *sp__WssRelV10Token10;	/* optional element of XSD type xsd:string */
	char *sp__WssRelV20Token10;	/* optional element of XSD type xsd:string */
	char *sp__WssRelV10Token11;	/* optional element of XSD type xsd:string */
	char *sp__WssRelV20Token11;	/* optional element of XSD type xsd:string */
	char *sp__MustNotSendCancel;	/* optional element of XSD type xsd:string */
	char *sp__MustNotSendAmend;	/* optional element of XSD type xsd:string */
	char *sp__MustNotSendRenew;	/* optional element of XSD type xsd:string */
	char *sp__MustSupportRefKeyIdentifier;	/* optional element of XSD type xsd:string */
	char *sp__MustSupportRefIssuerSerial;	/* optional element of XSD type xsd:string */
	char *sp__MustSupportRefExternalURI;	/* optional element of XSD type xsd:string */
	char *sp__MustSupportRefEmbeddedToken;	/* optional element of XSD type xsd:string */
	char *sp__MustSupportRefThumbprint;	/* optional element of XSD type xsd:string */
	char *sp__MustSupportRefEncryptedKey;	/* optional element of XSD type xsd:string */
	char *sp__RequireSignatureConfirmation;	/* optional element of XSD type xsd:string */
	char *sp__MustSupportClientChallenge;	/* optional element of XSD type xsd:string */
	char *sp__MustSupportServerChallenge;	/* optional element of XSD type xsd:string */
	char *sp__RequireClientEntropy;	/* optional element of XSD type xsd:string */
	char *sp__RequireServerEntropy;	/* optional element of XSD type xsd:string */
	char *sp__MustSupportIssuedTokens;	/* optional element of XSD type xsd:string */
	char *sp__RequireRequestSecurityTokenCollection;	/* optional element of XSD type xsd:string */
	char *sp__RequireAppliesTo;	/* optional element of XSD type xsd:string */
	char *sp__RequireExternalUriReference;	/* optional element of XSD type xsd:string */
	char *sp__SC13SecurityContextToken;	/* optional element of XSD type xsd:string */
	char *sp__Strict;	/* optional element of XSD type xsd:string */
	char *sp__Lax;	/* optional element of XSD type xsd:string */
	char *sp__LaxTsFirst;	/* optional element of XSD type xsd:string */
	char *sp__LaxTsLast;	/* optional element of XSD type xsd:string */
	char *sp__HttpBasicAuthentication;	/* optional element of XSD type xsd:string */
	char *sp__HttpDigestAuthentication;	/* optional element of XSD type xsd:string */
	char *sp__RequireClientCertificate;	/* optional element of XSD type xsd:string */
	char *sp__Basic256;	/* optional element of XSD type xsd:string */
	char *sp__Basic192;	/* optional element of XSD type xsd:string */
	char *sp__Basic128;	/* optional element of XSD type xsd:string */
	char *sp__TripleDes;	/* optional element of XSD type xsd:string */
	char *sp__Basic256Rsa15;	/* optional element of XSD type xsd:string */
	char *sp__Basic192Rsa15;	/* optional element of XSD type xsd:string */
	char *sp__Basic128Rsa15;	/* optional element of XSD type xsd:string */
	char *sp__TripleDesRsa15;	/* optional element of XSD type xsd:string */
	char *sp__Basic256Sha256;	/* optional element of XSD type xsd:string */
	char *sp__Basic192Sha256;	/* optional element of XSD type xsd:string */
	char *sp__Basic128Sha256;	/* optional element of XSD type xsd:string */
	char *sp__TripleDesSha256;	/* optional element of XSD type xsd:string */
	char *sp__Basic256Sha256Rsa15;	/* optional element of XSD type xsd:string */
	char *sp__Basic192Sha256Rsa15;	/* optional element of XSD type xsd:string */
	char *sp__Basic128Sha256Rsa15;	/* optional element of XSD type xsd:string */
	char *sp__TripleDesSha256Rsa15;	/* optional element of XSD type xsd:string */
	char *sp__InclusiveC14N;	/* optional element of XSD type xsd:string */
	char *sp__SOAPNormalization10;	/* optional element of XSD type xsd:string */
	char *sp__STRTransform10;	/* optional element of XSD type xsd:string */
	char *sp__Path10;	/* optional element of XSD type xsd:string */
	char *sp__XPathFilter20;	/* optional element of XSD type xsd:string */
	char *sp__AbsXPath;	/* optional element of XSD type xsd:string */
	char *wsam__AnonymousResponses;	/* optional element of XSD type xsd:string */
	char *wsam__NonAnonymousResponses;	/* optional element of XSD type xsd:string */
	std::vector<char *> __any;
	int traverse(wsdl__definitions &_param_77);
	void generate(Service &service, Types &types, int indent) const;
public:
	/// Return the unique type ID value SOAP_TYPE_wsp__Content (288)
	virtual int soap_type(void) const { return 288; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsp__Content, default initialized and not managed by a soap context
	virtual wsp__Content *soap_alloc(void) const { return SOAP_NEW(wsp__Content); }
	         wsp__Content() { wsp__Content::soap_default(NULL); }
	virtual ~wsp__Content() { }
	friend wsp__Content *soap_instantiate_wsp__Content(struct soap*, int, const char*, const char*, size_t*);
};
#endif

#ifndef SOAP_TYPE_wsp__Policy
#define SOAP_TYPE_wsp__Policy (287)
/* Type wsp__Policy is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsp:Policy */
class SOAP_CMAC wsp__Policy : public wsp__Content
{
public:
	char *xml__base;	/* optional attribute of XSD type xsd:anyURI */
	char *wsu__Id;	/* optional attribute of XSD type xsd:string */
	char *TargetNamespace;	/* optional attribute of XSD type xsd:anyURI */
public:
	/// Return the unique type ID value SOAP_TYPE_wsp__Policy (287)
	virtual int soap_type(void) const { return 287; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsp__Policy, default initialized and not managed by a soap context
	virtual wsp__Policy *soap_alloc(void) const { return SOAP_NEW(wsp__Policy); }
	         wsp__Policy() { wsp__Policy::soap_default(NULL); }
	virtual ~wsp__Policy() { }
	friend wsp__Policy *soap_instantiate_wsp__Policy(struct soap*, int, const char*, const char*, size_t*);
};
#endif

#ifndef SOAP_TYPE_wsp__Attachment
#define SOAP_TYPE_wsp__Attachment (323)
/* wsp:Attachment */
class SOAP_CMAC wsp__Attachment
{
public:
	wsp__Policy *Policy;	/* optional element of XSD type wsp:Policy */
	wsp__PolicyReference *PolicyReference;	/* optional element of XSD type wsp:PolicyReference */
public:
	/// Return the unique type ID value SOAP_TYPE_wsp__Attachment (323)
	virtual int soap_type(void) const { return 323; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsp__Attachment, default initialized and not managed by a soap context
	virtual wsp__Attachment *soap_alloc(void) const { return SOAP_NEW(wsp__Attachment); }
	         wsp__Attachment() { wsp__Attachment::soap_default(NULL); }
	virtual ~wsp__Attachment() { }
	friend wsp__Attachment *soap_instantiate_wsp__Attachment(struct soap*, int, const char*, const char*, size_t*);
};
#endif

#ifndef SOAP_TYPE_wsp__AppliesTo
#define SOAP_TYPE_wsp__AppliesTo (324)
/* wsp:AppliesTo */
class SOAP_CMAC wsp__AppliesTo
{
public:
	char *__any;
public:
	/// Return the unique type ID value SOAP_TYPE_wsp__AppliesTo (324)
	virtual int soap_type(void) const { return 324; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsp__AppliesTo, default initialized and not managed by a soap context
	virtual wsp__AppliesTo *soap_alloc(void) const { return SOAP_NEW(wsp__AppliesTo); }
	         wsp__AppliesTo() { wsp__AppliesTo::soap_default(NULL); }
	virtual ~wsp__AppliesTo() { }
	friend wsp__AppliesTo *soap_instantiate_wsp__AppliesTo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

#ifndef SOAP_TYPE_wsp__PolicyAttachment
#define SOAP_TYPE_wsp__PolicyAttachment (325)
/* wsp:PolicyAttachment */
class SOAP_CMAC wsp__PolicyAttachment
{
public:
	wsp__AppliesTo *AppliesTo;	/* optional element of XSD type wsp:AppliesTo */
	std::vector<wsp__Attachment> Attachment;	/* optional element of XSD type wsp:Attachment */
public:
	/// Return the unique type ID value SOAP_TYPE_wsp__PolicyAttachment (325)
	virtual int soap_type(void) const { return 325; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsp__PolicyAttachment, default initialized and not managed by a soap context
	virtual wsp__PolicyAttachment *soap_alloc(void) const { return SOAP_NEW(wsp__PolicyAttachment); }
	         wsp__PolicyAttachment() { wsp__PolicyAttachment::soap_default(NULL); }
	virtual ~wsp__PolicyAttachment() { }
	friend wsp__PolicyAttachment *soap_instantiate_wsp__PolicyAttachment(struct soap*, int, const char*, const char*, size_t*);
};
#endif

#ifndef SOAP_TYPE_plnk__tRole
#define SOAP_TYPE_plnk__tRole (330)
/* plnk:tRole */
class SOAP_CMAC plnk__tRole
{
public:
	char *name;	/* optional attribute of XSD type xsd:NCName */
	char *portType;	/* optional attribute of XSD type xsd:QName */
	char *documentation;	/* optional element of XSD type xsd:string */
private:
	class wsdl__portType *portTypeRef;	/* not serialized */
	class plnk__tPartnerLinkType *plnkRef;	/* not serialized */
public:
	plnk__tRole();
	int traverse(wsdl__definitions &_param_78);
	wsdl__portType *portTypePtr() const;
	void plnkPtr(plnk__tPartnerLinkType *_param_79);
	plnk__tPartnerLinkType *plnkPtr() const;
public:
	/// Return the unique type ID value SOAP_TYPE_plnk__tRole (330)
	virtual int soap_type(void) const { return 330; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type plnk__tRole, default initialized and not managed by a soap context
	virtual plnk__tRole *soap_alloc(void) const { return SOAP_NEW(plnk__tRole); }
	virtual ~plnk__tRole() { }
	friend plnk__tRole *soap_instantiate_plnk__tRole(struct soap*, int, const char*, const char*, size_t*);
};
#endif

#ifndef SOAP_TYPE_plnk__tPartnerLinkType
#define SOAP_TYPE_plnk__tPartnerLinkType (329)
/* Type plnk__tPartnerLinkType is a recursive data type (in)directly referencing itself through its (base) class members */
/* plnk:tPartnerLinkType */
class SOAP_CMAC plnk__tPartnerLinkType
{
public:
	char *name;	/* optional attribute of XSD type xsd:NCName */
	std::vector<plnk__tRole> role;	/* optional element of XSD type plnk:tRole */
	char *documentation;	/* optional element of XSD type xsd:string */
	int traverse(wsdl__definitions &_param_80);
public:
	/// Return the unique type ID value SOAP_TYPE_plnk__tPartnerLinkType (329)
	virtual int soap_type(void) const { return 329; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type plnk__tPartnerLinkType, default initialized and not managed by a soap context
	virtual plnk__tPartnerLinkType *soap_alloc(void) const { return SOAP_NEW(plnk__tPartnerLinkType); }
	         plnk__tPartnerLinkType() { plnk__tPartnerLinkType::soap_default(NULL); }
	virtual ~plnk__tPartnerLinkType() { }
	friend plnk__tPartnerLinkType *soap_instantiate_plnk__tPartnerLinkType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

#ifndef SOAP_TYPE_vprop__tQuery
#define SOAP_TYPE_vprop__tQuery (341)
/* vprop:tQuery */
class SOAP_CMAC vprop__tQuery
{
public:
	char *queryLanguage;	/* optional attribute of XSD type xsd:anyURI */
	char *__mixed;
public:
	/// Return the unique type ID value SOAP_TYPE_vprop__tQuery (341)
	virtual int soap_type(void) const { return 341; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type vprop__tQuery, default initialized and not managed by a soap context
	virtual vprop__tQuery *soap_alloc(void) const { return SOAP_NEW(vprop__tQuery); }
	         vprop__tQuery() { vprop__tQuery::soap_default(NULL); }
	virtual ~vprop__tQuery() { }
	friend vprop__tQuery *soap_instantiate_vprop__tQuery(struct soap*, int, const char*, const char*, size_t*);
};
#endif

#ifndef SOAP_TYPE_vprop__tProperty
#define SOAP_TYPE_vprop__tProperty (342)
/* vprop:tProperty */
class SOAP_CMAC vprop__tProperty
{
public:
	char *name;	/* optional attribute of XSD type xsd:NCName */
	char *type;	/* optional attribute of XSD type xsd:QName */
	char *element;	/* optional attribute of XSD type xsd:QName */
	char *documentation;	/* optional element of XSD type xsd:string */
	int traverse(wsdl__definitions &_param_81);
public:
	/// Return the unique type ID value SOAP_TYPE_vprop__tProperty (342)
	virtual int soap_type(void) const { return 342; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type vprop__tProperty, default initialized and not managed by a soap context
	virtual vprop__tProperty *soap_alloc(void) const { return SOAP_NEW(vprop__tProperty); }
	         vprop__tProperty() { vprop__tProperty::soap_default(NULL); }
	virtual ~vprop__tProperty() { }
	friend vprop__tProperty *soap_instantiate_vprop__tProperty(struct soap*, int, const char*, const char*, size_t*);
};
#endif

#ifndef SOAP_TYPE_vprop__tPropertyAlias
#define SOAP_TYPE_vprop__tPropertyAlias (344)
/* vprop:tPropertyAlias */
class SOAP_CMAC vprop__tPropertyAlias
{
public:
	vprop__tQuery *query;	/* optional element of XSD type vprop:tQuery */
	char *propertyName;	/* optional attribute of XSD type xsd:QName */
	char *messageType;	/* optional attribute of XSD type xsd:QName */
	char *part;	/* optional attribute of XSD type xsd:NCName */
	char *type;	/* optional attribute of XSD type xsd:QName */
	char *element;	/* optional attribute of XSD type xsd:QName */
	char *documentation;	/* optional element of XSD type xsd:string */
private:
	vprop__tProperty *vpropRef;	/* not serialized */
public:
	int traverse(wsdl__definitions &_param_82);
	vprop__tProperty *vpropPtr() const;
public:
	/// Return the unique type ID value SOAP_TYPE_vprop__tPropertyAlias (344)
	virtual int soap_type(void) const { return 344; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type vprop__tPropertyAlias, default initialized and not managed by a soap context
	virtual vprop__tPropertyAlias *soap_alloc(void) const { return SOAP_NEW(vprop__tPropertyAlias); }
	         vprop__tPropertyAlias() { vprop__tPropertyAlias::soap_default(NULL); }
	virtual ~vprop__tPropertyAlias() { }
	friend vprop__tPropertyAlias *soap_instantiate_vprop__tPropertyAlias(struct soap*, int, const char*, const char*, size_t*);
};
#endif

#ifndef SOAP_TYPE_wsdl__import
#define SOAP_TYPE_wsdl__import (349)
/* wsdl:import */
class SOAP_CMAC wsdl__import
{
public:
	char *namespace_;	/* optional attribute of XSD type xsd:anyURI */
	char *location;	/* optional attribute of XSD type xsd:anyURI */
private:
	wsdl__definitions *definitionsRef;	/* not serialized */
public:
	wsdl__import();
	int preprocess(wsdl__definitions &_param_83);
	int traverse(wsdl__definitions &_param_84);
	void definitionsPtr(wsdl__definitions *_param_85);
	wsdl__definitions *definitionsPtr() const;
public:
	/// Return the unique type ID value SOAP_TYPE_wsdl__import (349)
	virtual int soap_type(void) const { return 349; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsdl__import, default initialized and not managed by a soap context
	virtual wsdl__import *soap_alloc(void) const { return SOAP_NEW(wsdl__import); }
	virtual ~wsdl__import() { }
	friend wsdl__import *soap_instantiate_wsdl__import(struct soap*, int, const char*, const char*, size_t*);
};
#endif

#ifndef SOAP_TYPE_wsdl__types
#define SOAP_TYPE_wsdl__types (357)
/* Type wsdl__types is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsdl:types */
class SOAP_CMAC wsdl__types : public xs__schema
{
public:
	char *documentation;	/* optional element of XSD type xsd:string */
	std::vector<xs__schema *> xs__schema_;	/* optional element of XSD type xs:schema */
	int preprocess(wsdl__definitions &_param_86);
	int traverse(wsdl__definitions &_param_87);
public:
	/// Return the unique type ID value SOAP_TYPE_wsdl__types (357)
	virtual int soap_type(void) const { return 357; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsdl__types, default initialized and not managed by a soap context
	virtual wsdl__types *soap_alloc(void) const { return SOAP_NEW(wsdl__types); }
	         wsdl__types() { wsdl__types::soap_default(NULL); }
	friend wsdl__types *soap_instantiate_wsdl__types(struct soap*, int, const char*, const char*, size_t*);
};
#endif

#ifndef SOAP_TYPE_wsdl__part
#define SOAP_TYPE_wsdl__part (229)
/* wsdl:part */
class SOAP_CMAC wsdl__part
{
public:
	char *name;	/* optional attribute of XSD type xsd:NMTOKEN */
	char *element;	/* optional attribute of XSD type xsd:QName */
	char *type;	/* optional attribute of XSD type xsd:QName */
	char *documentation;	/* optional element of XSD type xsd:string */
private:
	xs__element *elementRef;	/* not serialized */
	xs__simpleType *simpleTypeRef;	/* not serialized */
	xs__complexType *complexTypeRef;	/* not serialized */
public:
	wsdl__part();
	int traverse(wsdl__definitions &_param_88);
	void elementPtr(xs__element *_param_89);
	void simpleTypePtr(xs__simpleType *_param_90);
	void complexTypePtr(xs__complexType *_param_91);
	xs__element *elementPtr() const;
	xs__simpleType *simpleTypePtr() const;
	xs__complexType *complexTypePtr() const;
public:
	/// Return the unique type ID value SOAP_TYPE_wsdl__part (229)
	virtual int soap_type(void) const { return 229; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsdl__part, default initialized and not managed by a soap context
	virtual wsdl__part *soap_alloc(void) const { return SOAP_NEW(wsdl__part); }
	virtual ~wsdl__part() { }
	friend wsdl__part *soap_instantiate_wsdl__part(struct soap*, int, const char*, const char*, size_t*);
};
#endif

#ifndef SOAP_TYPE_wsdl__message
#define SOAP_TYPE_wsdl__message (228)
/* wsdl:message */
class SOAP_CMAC wsdl__message
{
public:
	char *name;	/* optional attribute of XSD type xsd:NMTOKEN */
	char *documentation;	/* optional element of XSD type xsd:string */
	std::vector<wsp__Policy> wsp__Policy_;	/* optional element of XSD type wsp:Policy */
	std::vector<wsp__PolicyReference> wsp__PolicyReference_;	/* optional element of XSD type wsp:PolicyReference */
	std::vector<wsdl__part> part;	/* optional element of XSD type wsdl:part */
	int traverse(wsdl__definitions &_param_92);
public:
	/// Return the unique type ID value SOAP_TYPE_wsdl__message (228)
	virtual int soap_type(void) const { return 228; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsdl__message, default initialized and not managed by a soap context
	virtual wsdl__message *soap_alloc(void) const { return SOAP_NEW(wsdl__message); }
	         wsdl__message() { wsdl__message::soap_default(NULL); }
	virtual ~wsdl__message() { }
	friend wsdl__message *soap_instantiate_wsdl__message(struct soap*, int, const char*, const char*, size_t*);
};
#endif

#ifndef SOAP_TYPE_wsdl__ioput
#define SOAP_TYPE_wsdl__ioput (373)
/* wsdl:ioput */
class SOAP_CMAC wsdl__ioput
{
public:
	char *name;	/* optional attribute of XSD type xsd:NMTOKEN */
	char *message;	/* optional attribute of XSD type xsd:QName */
	char *messageLabel;	/* optional attribute of XSD type xsd:NMTOKEN */
	char *element;	/* optional attribute of XSD type xsd:QName */
	char *wsa__Action;	/* optional attribute of XSD type xsd:anyURI */
	char *wsam__Action;	/* optional attribute of XSD type xsd:anyURI */
	char *documentation;	/* optional element of XSD type xsd:string */
	wsp__Policy *wsp__Policy_;	/* optional element of XSD type wsp:Policy */
	wsp__PolicyReference *wsp__PolicyReference_;	/* optional element of XSD type wsp:PolicyReference */
private:
	wsdl__message *messageRef;	/* not serialized */
	xs__element *elementRef;	/* not serialized */
public:
	wsdl__ioput();
	int traverse(wsdl__definitions &_param_93);
	void messagePtr(wsdl__message *_param_94);
	wsdl__message *messagePtr() const;
	void elementPtr(xs__element *_param_95);
	xs__element *elementPtr() const;
public:
	/// Return the unique type ID value SOAP_TYPE_wsdl__ioput (373)
	virtual int soap_type(void) const { return 373; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsdl__ioput, default initialized and not managed by a soap context
	virtual wsdl__ioput *soap_alloc(void) const { return SOAP_NEW(wsdl__ioput); }
	virtual ~wsdl__ioput() { }
	friend wsdl__ioput *soap_instantiate_wsdl__ioput(struct soap*, int, const char*, const char*, size_t*);
};
#endif

#ifndef SOAP_TYPE_wsdl__fault
#define SOAP_TYPE_wsdl__fault (380)
/* wsdl:fault */
class SOAP_CMAC wsdl__fault
{
public:
	char *name;	/* optional attribute of XSD type xsd:NMTOKEN */
	char *message;	/* optional attribute of XSD type xsd:QName */
	char *ref;	/* optional attribute of XSD type xsd:QName */
	char *messageLabel;	/* optional attribute of XSD type xsd:NMTOKEN */
	char *element;	/* optional attribute of XSD type xsd:QName */
	char *wsa__Action;	/* optional attribute of XSD type xsd:anyURI */
	char *wsam__Action;	/* optional attribute of XSD type xsd:anyURI */
	char *documentation;	/* optional element of XSD type xsd:string */
	wsp__Policy *wsp__Policy_;	/* optional element of XSD type wsp:Policy */
	wsp__PolicyReference *wsp__PolicyReference_;	/* optional element of XSD type wsp:PolicyReference */
private:
	wsdl__message *messageRef;	/* not serialized */
	xs__element *elementRef;	/* not serialized */
public:
	wsdl__fault();
	int traverse(wsdl__definitions &_param_96);
	void messagePtr(wsdl__message *_param_97);
	wsdl__message *messagePtr() const;
	void elementPtr(xs__element *_param_98);
	xs__element *elementPtr() const;
public:
	/// Return the unique type ID value SOAP_TYPE_wsdl__fault (380)
	virtual int soap_type(void) const { return 380; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsdl__fault, default initialized and not managed by a soap context
	virtual wsdl__fault *soap_alloc(void) const { return SOAP_NEW(wsdl__fault); }
	virtual ~wsdl__fault() { }
	friend wsdl__fault *soap_instantiate_wsdl__fault(struct soap*, int, const char*, const char*, size_t*);
};
#endif

#ifndef SOAP_TYPE_wsdl__union_ioput
#define SOAP_TYPE_wsdl__union_ioput (388)
/* xsd:choice */
union wsdl__union_ioput
{
#define SOAP_UNION_wsdl__union_ioput_input	(1)
	wsdl__ioput *input;
#define SOAP_UNION_wsdl__union_ioput_output	(2)
	wsdl__ioput *output;
};
#endif

#ifndef SOAP_TYPE_wsdl__operation
#define SOAP_TYPE_wsdl__operation (276)
/* wsdl:operation */
class SOAP_CMAC wsdl__operation
{
public:
	char *name;	/* optional attribute of XSD type xsd:NMTOKEN */
	char *pattern;	/* optional attribute of XSD type xsd:anyURI */
	char *style;	/* optional attribute of XSD type xsd:anyURI */
	char *wrpc__signature;	/* optional attribute of XSD type xsd:string */
	char *parameterOrder;	/* optional attribute of XSD type xsd:string */
	char *documentation;	/* optional element of XSD type xsd:string */
	wsp__Policy *wsp__Policy_;	/* optional element of XSD type wsp:Policy */
	wsp__PolicyReference *wsp__PolicyReference_;	/* optional element of XSD type wsp:PolicyReference */
	int __union1;	/* union discriminant (of union defined below) */
	union wsdl__union_ioput __ioput1;
	int __union2;	/* union discriminant (of union defined below) */
	union wsdl__union_ioput __ioput2;
	std::vector<wsdl__fault> fault;	/* optional element of XSD type wsdl:fault */
	std::vector<wsdl__fault> infault;	/* optional element of XSD type wsdl:fault */
	std::vector<wsdl__fault> outfault;	/* optional element of XSD type wsdl:fault */
	int traverse(wsdl__definitions &_param_99);
public:
	/// Return the unique type ID value SOAP_TYPE_wsdl__operation (276)
	virtual int soap_type(void) const { return 276; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsdl__operation, default initialized and not managed by a soap context
	virtual wsdl__operation *soap_alloc(void) const { return SOAP_NEW(wsdl__operation); }
	         wsdl__operation() { wsdl__operation::soap_default(NULL); }
	virtual ~wsdl__operation() { }
	friend wsdl__operation *soap_instantiate_wsdl__operation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

#ifndef SOAP_TYPE_wsdl__portType
#define SOAP_TYPE_wsdl__portType (328)
/* Type wsdl__portType is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsdl:portType */
class SOAP_CMAC wsdl__portType
{
public:
	char *name;	/* optional attribute of XSD type xsd:NMTOKEN */
	char *extends;	/* optional attribute of XSD type xsd:QName */
	char *styleDefault;	/* optional attribute of XSD type xsd:anyURI */
	char *documentation;	/* optional element of XSD type xsd:string */
	wsp__Policy *wsp__Policy_;	/* optional element of XSD type wsp:Policy */
	wsp__PolicyReference *wsp__PolicyReference_;	/* optional element of XSD type wsp:PolicyReference */
	std::vector<wsdl__fault> fault;	/* optional element of XSD type wsdl:fault */
	std::vector<wsdl__operation> operation;	/* optional element of XSD type wsdl:operation */
private:
	wsdl__definitions *definitionsRef;	/* not serialized */
public:
	wsdl__portType();
	int traverse(wsdl__definitions &_param_100);
	void definitionsPtr(wsdl__definitions *_param_101);
	wsdl__definitions *definitionsPtr() const;
public:
	/// Return the unique type ID value SOAP_TYPE_wsdl__portType (328)
	virtual int soap_type(void) const { return 328; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsdl__portType, default initialized and not managed by a soap context
	virtual wsdl__portType *soap_alloc(void) const { return SOAP_NEW(wsdl__portType); }
	virtual ~wsdl__portType() { }
	friend wsdl__portType *soap_instantiate_wsdl__portType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

#ifndef SOAP_TYPE_wsdl__ext_ioput
#define SOAP_TYPE_wsdl__ext_ioput (396)
/* wsdl:ext-ioput */
class SOAP_CMAC wsdl__ext_ioput
{
public:
	char *name;	/* optional attribute of XSD type xsd:NMTOKEN */
	char *messageLabel;	/* optional attribute of XSD type xsd:NMTOKEN */
	char *documentation;	/* optional element of XSD type xsd:string */
	wsp__Policy *wsp__Policy_;	/* optional element of XSD type wsp:Policy */
	wsp__PolicyReference *wsp__PolicyReference_;	/* optional element of XSD type wsp:PolicyReference */
	dime__message *dime__message_;	/* optional element of XSD type dime:message */
	soap__body *soap__body_;	/* optional element of XSD type soap:body */
	char *http__urlEncoded;	/* optional element of XSD type xsd:string */
	mime__multipartRelated *mime__multipartRelated_;	/* optional element of XSD type mime:multipartRelated */
	mime__content *mime__content_;	/* optional element of XSD type mime:content */
	mime__mimeXml *mime__mimeXml_;	/* optional element of XSD type mime:mimeXml */
	std::vector<soap__header> soap__header_;	/* optional element of XSD type soap:header */
	std::vector<wsoap__module> wsoap__module_;	/* optional element of XSD type wsoap:module */
	std::vector<wsoap__header> wsoap__header_;	/* optional element of XSD type wsoap:header */
	std::vector<whttp__header> whttp__header_;	/* optional element of XSD type whttp:header */
	int traverse(wsdl__definitions &_param_102);
public:
	/// Return the unique type ID value SOAP_TYPE_wsdl__ext_ioput (396)
	virtual int soap_type(void) const { return 396; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsdl__ext_ioput, default initialized and not managed by a soap context
	virtual wsdl__ext_ioput *soap_alloc(void) const { return SOAP_NEW(wsdl__ext_ioput); }
	         wsdl__ext_ioput() { wsdl__ext_ioput::soap_default(NULL); }
	virtual ~wsdl__ext_ioput() { }
	friend wsdl__ext_ioput *soap_instantiate_wsdl__ext_ioput(struct soap*, int, const char*, const char*, size_t*);
};
#endif

#ifndef SOAP_TYPE_wsdl__ext_fault
#define SOAP_TYPE_wsdl__ext_fault (405)
/* wsdl:ext-fault */
class SOAP_CMAC wsdl__ext_fault
{
public:
	char *name;	/* optional attribute of XSD type xsd:NMTOKEN */
	char *ref;	/* optional attribute of XSD type xsd:QName */
	char *messageLabel;	/* optional attribute of XSD type xsd:NMTOKEN */
	char *wsoap__code;	/* optional attribute of XSD type xsd:QName */
	char *wsoap__subcodes;	/* optional attribute of XSD type xsd:QName */
	char *documentation;	/* optional element of XSD type xsd:string */
	wsp__Policy *wsp__Policy_;	/* optional element of XSD type wsp:Policy */
	wsp__PolicyReference *wsp__PolicyReference_;	/* optional element of XSD type wsp:PolicyReference */
	soap__fault *soap__fault_;	/* optional element of XSD type soap:fault */
	std::vector<wsoap__module> wsoap__module_;	/* optional element of XSD type wsoap:module */
private:
	wsdl__fault *faultRef;	/* not serialized */
public:
	wsdl__ext_fault();
	int traverse(wsdl__definitions &_param_103, wsdl__portType *_param_104);
	void faultPtr(wsdl__fault *_param_105);
	wsdl__fault *faultPtr() const;
public:
	/// Return the unique type ID value SOAP_TYPE_wsdl__ext_fault (405)
	virtual int soap_type(void) const { return 405; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsdl__ext_fault, default initialized and not managed by a soap context
	virtual wsdl__ext_fault *soap_alloc(void) const { return SOAP_NEW(wsdl__ext_fault); }
	virtual ~wsdl__ext_fault() { }
	friend wsdl__ext_fault *soap_instantiate_wsdl__ext_fault(struct soap*, int, const char*, const char*, size_t*);
};
#endif

#ifndef SOAP_TYPE_wsdl__ext_operation
#define SOAP_TYPE_wsdl__ext_operation (414)
/* wsdl:ext-operation */
class SOAP_CMAC wsdl__ext_operation
{
public:
	char *name;	/* optional attribute of XSD type xsd:NMTOKEN */
	char *ref;	/* optional attribute of XSD type xsd:QName */
	char *wsoap__mep;	/* optional attribute of XSD type xsd:anyURI */
	char *wsoap__action;	/* optional attribute of XSD type xsd:anyURI */
	char *whttp__method;	/* optional attribute of XSD type xsd:string */
	char *whttp__location;	/* optional attribute of XSD type xsd:string */
	char *documentation;	/* optional element of XSD type xsd:string */
	wsp__Policy *wsp__Policy_;	/* optional element of XSD type wsp:Policy */
	wsp__PolicyReference *wsp__PolicyReference_;	/* optional element of XSD type wsp:PolicyReference */
	soap__operation *soap__operation_;	/* optional element of XSD type soap:operation */
	http__operation *http__operation_;	/* optional element of XSD type http:operation */
	wsdl__ext_ioput *input;	/* optional element of XSD type wsdl:ext-ioput */
	wsdl__ext_ioput *output;	/* optional element of XSD type wsdl:ext-ioput */
	std::vector<wsdl__ext_fault> fault;	/* optional element of XSD type wsdl:ext-fault */
	std::vector<wsdl__ext_fault> infault;	/* optional element of XSD type wsdl:ext-fault */
	std::vector<wsdl__ext_fault> outfault;	/* optional element of XSD type wsdl:ext-fault */
private:
	wsdl__operation *operationRef;	/* not serialized */
public:
	wsdl__ext_operation();
	int traverse(wsdl__definitions &_param_106, wsdl__portType *_param_107);
	void operationPtr(wsdl__operation *_param_108);
	wsdl__operation *operationPtr() const;
public:
	/// Return the unique type ID value SOAP_TYPE_wsdl__ext_operation (414)
	virtual int soap_type(void) const { return 414; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsdl__ext_operation, default initialized and not managed by a soap context
	virtual wsdl__ext_operation *soap_alloc(void) const { return SOAP_NEW(wsdl__ext_operation); }
	virtual ~wsdl__ext_operation() { }
	friend wsdl__ext_operation *soap_instantiate_wsdl__ext_operation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

#ifndef SOAP_TYPE_wsdl__binding
#define SOAP_TYPE_wsdl__binding (424)
/* Type wsdl__binding is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsdl:binding */
class SOAP_CMAC wsdl__binding
{
public:
	char *name;	/* optional attribute of XSD type xsd:NMTOKEN */
	char *type;	/* optional attribute of XSD type xsd:QName */
	char *type_;	/* optional attribute of XSD type xsd:anyURI */
	char *interface_;	/* optional attribute of XSD type xsd:QName */
	bool whttp__cookies;	/* optional attribute of XSD type xsd:boolean */
	char *wsoap__version;	/* optional attribute of XSD type xsd:string */
	char *wsoap__protocol;	/* optional attribute of XSD type xsd:anyURI */
	char *wsoap__mepDefault;	/* optional attribute of XSD type xsd:anyURI */
	char *whttp__methodDefault;	/* optional attribute of XSD type xsd:string */
	char *documentation;	/* optional element of XSD type xsd:string */
	std::vector<wsp__Policy> wsp__Policy_;	/* optional element of XSD type wsp:Policy */
	std::vector<wsp__PolicyReference> wsp__PolicyReference_;	/* optional element of XSD type wsp:PolicyReference */
	soap__binding *soap__binding_;	/* optional element of XSD type soap:binding */
	http__binding *http__binding_;	/* optional element of XSD type http:binding */
	std::vector<wsoap__module> wsoap__module_;	/* optional element of XSD type wsoap:module */
	std::vector<wsdl__ext_fault> fault;	/* optional element of XSD type wsdl:ext-fault */
	std::vector<wsdl__ext_operation> operation;	/* optional element of XSD type wsdl:ext-operation */
private:
	wsdl__portType *portTypeRef;	/* not serialized */
public:
	wsdl__binding();
	int traverse(wsdl__definitions &_param_109);
	void portTypePtr(wsdl__portType *_param_110);
	wsdl__portType *portTypePtr() const;
public:
	/// Return the unique type ID value SOAP_TYPE_wsdl__binding (424)
	virtual int soap_type(void) const { return 424; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsdl__binding, default initialized and not managed by a soap context
	virtual wsdl__binding *soap_alloc(void) const { return SOAP_NEW(wsdl__binding); }
	virtual ~wsdl__binding() { }
	friend wsdl__binding *soap_instantiate_wsdl__binding(struct soap*, int, const char*, const char*, size_t*);
};
#endif

#ifndef SOAP_TYPE_wsdl__port
#define SOAP_TYPE_wsdl__port (432)
/* wsdl:port */
class SOAP_CMAC wsdl__port
{
public:
	char *name;	/* optional attribute of XSD type xsd:NMTOKEN */
	char *binding;	/* optional attribute of XSD type xsd:QName */
	char *address;	/* optional attribute of XSD type xsd:anyURI */
	char *whttp__authenticationScheme;	/* optional attribute of XSD type xsd:NMTOKEN */
	char *whttp__authenticationRealm;	/* optional attribute of XSD type xsd:NMTOKEN */
	char *documentation;	/* optional element of XSD type xsd:string */
	wsp__Policy *wsp__Policy_;	/* optional element of XSD type wsp:Policy */
	wsp__PolicyReference *wsp__PolicyReference_;	/* optional element of XSD type wsp:PolicyReference */
	wsa__EndpointReferenceType *wsa__EndpointReference;	/* optional element of XSD type wsa:EndpointReferenceType */
	soap__address *soap__address_;	/* optional element of XSD type soap:address */
	http__address *http__address_;	/* optional element of XSD type http:address */
private:
	wsdl__binding *bindingRef;	/* not serialized */
public:
	wsdl__port();
	int traverse(wsdl__definitions &_param_111);
	void bindingPtr(wsdl__binding *_param_112);
	wsdl__binding *bindingPtr() const;
public:
	/// Return the unique type ID value SOAP_TYPE_wsdl__port (432)
	virtual int soap_type(void) const { return 432; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsdl__port, default initialized and not managed by a soap context
	virtual wsdl__port *soap_alloc(void) const { return SOAP_NEW(wsdl__port); }
	virtual ~wsdl__port() { }
	friend wsdl__port *soap_instantiate_wsdl__port(struct soap*, int, const char*, const char*, size_t*);
};
#endif

#ifndef SOAP_TYPE_wsdl__service
#define SOAP_TYPE_wsdl__service (441)
/* Type wsdl__service is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsdl:service */
class SOAP_CMAC wsdl__service
{
public:
	char *name;	/* optional attribute of XSD type xsd:NMTOKEN */
	char *interface_;	/* optional attribute of XSD type xsd:QName */
	char *documentation;	/* optional element of XSD type xsd:string */
	std::vector<wsp__Policy> wsp__Policy_;	/* optional element of XSD type wsp:Policy */
	std::vector<wsp__PolicyReference> wsp__PolicyReference_;	/* optional element of XSD type wsp:PolicyReference */
	std::vector<wsdl__port> port;	/* optional element of XSD type wsdl:port */
	std::vector<wsdl__port> endpoint;	/* optional element of XSD type wsdl:port */
	int traverse(wsdl__definitions &_param_113);
public:
	/// Return the unique type ID value SOAP_TYPE_wsdl__service (441)
	virtual int soap_type(void) const { return 441; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsdl__service, default initialized and not managed by a soap context
	virtual wsdl__service *soap_alloc(void) const { return SOAP_NEW(wsdl__service); }
	         wsdl__service() { wsdl__service::soap_default(NULL); }
	virtual ~wsdl__service() { }
	friend wsdl__service *soap_instantiate_wsdl__service(struct soap*, int, const char*, const char*, size_t*);
};
#endif

#ifndef SOAP_TYPE_wsdl__definitions
#define SOAP_TYPE_wsdl__definitions (227)
/* Type wsdl__definitions is a recursive data type (in)directly referencing itself through its (base) class members */
/* wsdl:definitions */
class SOAP_CMAC wsdl__definitions
{
public:
	char *name;	/* optional attribute of XSD type xsd:NMTOKEN */
	char *targetNamespace;	/* optional attribute of XSD type xsd:anyURI */
	char *version;	/* optional attribute of XSD type xsd:NMTOKEN */
	std::vector<wsdl__import> import;	/* optional element of XSD type wsdl:import */
	char *documentation;	/* optional element of XSD type xsd:string */
	wsdl__types *types;	/* optional element of XSD type wsdl:types */
	std::vector<wsdl__message> message;	/* optional element of XSD type wsdl:message */
	std::vector<wsdl__portType> portType;	/* optional element of XSD type wsdl:portType */
	std::vector<wsdl__portType> interface_;	/* optional element of XSD type wsdl:portType */
	std::vector<wsdl__binding> binding;	/* optional element of XSD type wsdl:binding */
	std::vector<wsdl__service> service;	/* optional element of XSD type wsdl:service */
	char *wsp__UsingPolicy;	/* optional element of XSD type xsd:string */
	std::vector<wsp__Policy> wsp__Policy_;	/* optional element of XSD type wsp:Policy */
	std::vector<plnk__tPartnerLinkType> plnk__partnerLinkType;	/* optional element of XSD type plnk:tPartnerLinkType */
	std::vector<vprop__tProperty> vprop__property;	/* optional element of XSD type vprop:tProperty */
	std::vector<vprop__tPropertyAlias> vprop__propertyAlias;	/* optional element of XSD type vprop:tPropertyAlias */
	std::vector<gwsdl__portType> gwsdl__portType_;	/* optional element of XSD type gwsdl:portType */
	struct soap *soap;	/* transient (not serialized) */
private:
	bool soap12;	/* not serialized */
	bool updated;	/* not serialized */
	char *location;	/* not serialized */
	int redirs;	/* not serialized */
	SetOfString builtinTypeSet;	/* transient (not serialized) */	/* not serialized */
	SetOfString builtinElementSet;	/* transient (not serialized) */	/* not serialized */
	SetOfString builtinAttributeSet;	/* transient (not serialized) */	/* not serialized */
public:
	wsdl__definitions();
	wsdl__definitions(struct soap *_param_114);
	wsdl__definitions(struct soap *_param_115, const char *_param_116, const char *_param_117);
	virtual ~wsdl__definitions();
	int get(struct soap *_param_118);
	int preprocess();
	int traverse();
	int read(int _param_119, char **_param_120);
	int read(const char *cwd, const char *_param_121);
	const char *sourceLocation();
	int error();
	bool is_updated();
	void print_fault();
	void builtinType(const char *_param_122);
	void builtinTypes(const SetOfString &_param_123);
	void builtinElement(const char *_param_124);
	void builtinElements(const SetOfString &_param_125);
	void builtinAttribute(const char *_param_126);
	void builtinAttributes(const SetOfString &_param_127);
	const SetOfString &builtinTypes() const;	/* not serialized */
	const SetOfString &builtinElements() const;	/* not serialized */
	const SetOfString &builtinAttributes() const;	/* not serialized */
	friend ostream &operator<<(ostream &_param_128, const wsdl__definitions &_param_129);
	friend istream &operator>>(istream &_param_130, wsdl__definitions &_param_131);
public:
	/// Return the unique type ID value SOAP_TYPE_wsdl__definitions (227)
	virtual int soap_type(void) const { return 227; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type wsdl__definitions, default initialized and not managed by a soap context
	virtual wsdl__definitions *soap_alloc(void) const { return SOAP_NEW(wsdl__definitions); }
	friend wsdl__definitions *soap_instantiate_wsdl__definitions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (483)
/* SOAP Header: */
struct SOAP_ENV__Header
{
public:
	int soap_type() const { return 483; } /* = unique type id SOAP_TYPE_SOAP_ENV__Header */
	         SOAP_ENV__Header();
	virtual ~SOAP_ENV__Header() { }
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (484)
/* Type SOAP_ENV__Code is a recursive data type (in)directly referencing itself through its (base) class members */
/* SOAP Fault Code: */
struct SOAP_ENV__Code
{
public:
	char *SOAP_ENV__Value;	/* optional element of XSD type xsd:QName */
	struct SOAP_ENV__Code *SOAP_ENV__Subcode;	/* optional element of XSD type SOAP-ENV:Code */
public:
	int soap_type() const { return 484; } /* = unique type id SOAP_TYPE_SOAP_ENV__Code */
	         SOAP_ENV__Code();
	virtual ~SOAP_ENV__Code() { }
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (486)
/* SOAP-ENV:Detail */
struct SOAP_ENV__Detail
{
public:
	char *__any;
	int __type;	/* any type of element <fault> (defined below)
	   WARNING: do not create a cyclic data structure graph throught this element unless SOAP encoding or SOAP_XML_GRAPH are used for id-ref serialization */
	void *fault;	/* transient (not serialized) */
public:
	int soap_type() const { return 486; } /* = unique type id SOAP_TYPE_SOAP_ENV__Detail */
	         SOAP_ENV__Detail();
	virtual ~SOAP_ENV__Detail() { }
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (487)
/* SOAP-ENV:Reason */
struct SOAP_ENV__Reason
{
public:
	char *SOAP_ENV__Text;	/* optional element of XSD type xsd:string */
public:
	int soap_type() const { return 487; } /* = unique type id SOAP_TYPE_SOAP_ENV__Reason */
	         SOAP_ENV__Reason();
	virtual ~SOAP_ENV__Reason() { }
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (488)
/* SOAP Fault: */
struct SOAP_ENV__Fault
{
public:
	char *faultcode;	/* optional element of XSD type xsd:QName */
	char *faultstring;	/* optional element of XSD type xsd:string */
	char *faultactor;	/* optional element of XSD type xsd:string */
	struct SOAP_ENV__Detail *detail;	/* optional element of XSD type SOAP-ENV:Detail */
	struct SOAP_ENV__Code *SOAP_ENV__Code;	/* optional element of XSD type SOAP-ENV:Code */
	struct SOAP_ENV__Reason *SOAP_ENV__Reason;	/* optional element of XSD type SOAP-ENV:Reason */
	char *SOAP_ENV__Node;	/* optional element of XSD type xsd:string */
	char *SOAP_ENV__Role;	/* optional element of XSD type xsd:string */
	struct SOAP_ENV__Detail *SOAP_ENV__Detail;	/* optional element of XSD type SOAP-ENV:Detail */
public:
	int soap_type() const { return 488; } /* = unique type id SOAP_TYPE_SOAP_ENV__Fault */
	         SOAP_ENV__Fault();
	virtual ~SOAP_ENV__Fault() { }
};
#endif

#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/

#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
typedef char *_QName;
#endif

#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (6)
typedef char *_XML;
#endif

#ifndef SOAP_TYPE_xsd__anyURI
#define SOAP_TYPE_xsd__anyURI (8)
typedef char *xsd__anyURI;
#endif

#ifndef SOAP_TYPE_xsd__ID
#define SOAP_TYPE_xsd__ID (9)
typedef char *xsd__ID;
#endif

#ifndef SOAP_TYPE_xsd__NCName
#define SOAP_TYPE_xsd__NCName (10)
typedef char *xsd__NCName;
#endif

#ifndef SOAP_TYPE_xsd__NMTOKEN
#define SOAP_TYPE_xsd__NMTOKEN (11)
typedef char *xsd__NMTOKEN;
#endif

#ifndef SOAP_TYPE_xsd__NMTOKENS
#define SOAP_TYPE_xsd__NMTOKENS (12)
typedef char *xsd__NMTOKENS;
#endif

#ifndef SOAP_TYPE_xsd__QName
#define SOAP_TYPE_xsd__QName (13)
typedef char *xsd__QName;
#endif

#ifndef SOAP_TYPE_xsd__string
#define SOAP_TYPE_xsd__string (14)
typedef char *xsd__string;
#endif

#ifndef SOAP_TYPE_xsd__boolean
#define SOAP_TYPE_xsd__boolean (16)
typedef bool xsd__boolean;
#endif

#ifndef SOAP_TYPE_xs__namespaceList
#define SOAP_TYPE_xs__namespaceList (78)
typedef char *xs__namespaceList;
#endif


/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


extern ostream &operator<<(ostream &o, const xs__schema &e);

extern istream &operator>>(istream &i, xs__schema &e);

extern ostream &operator<<(ostream &o, const wsdl__definitions &e);

extern istream &operator>>(istream &i, wsdl__definitions &e);

#endif

/* End of wsdlStub.h */
