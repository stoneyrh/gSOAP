/* wsdlStub.h
   Generated by gSOAP 2.8.33 for ./wsdl.h

gSOAP XML Web services tools
Copyright (C) 2000-2016, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#include <vector>
#include "includes.h"

#ifndef wsdlStub_H
#define wsdlStub_H
#include "stdsoap2.h"
#if GSOAP_VERSION != 20833
# error "GSOAP VERSION 20833 MISMATCH IN GENERATED CODE VERSUS LIBRARY CODE: PLEASE REINSTALL PACKAGE"
#endif


/******************************************************************************\
 *                                                                            *
 * Enumeration Types                                                          *
 *                                                                            *
\******************************************************************************/


/* schema.h:75 */
#ifndef SOAP_TYPE_xs__formChoice
#define SOAP_TYPE_xs__formChoice (35)
/* xs:formChoice */
enum xs__formChoice {
	unqualified = 0,
	qualified = 1
};
#endif

/* schema.h:119 */
#ifndef SOAP_TYPE_xs__attribute_use
#define SOAP_TYPE_xs__attribute_use (63)
/* xs:attribute-use */
enum xs__attribute_use {
	optional = 0,
	prohibited = 1,
	required = 2,
	default_ = 3,
	fixed_ = 4
};
#endif

/* schema.h:159 */
#ifndef SOAP_TYPE_xs__processContents
#define SOAP_TYPE_xs__processContents (78)
/* xs:processContents */
enum xs__processContents {
	strict = 0,
	skip = 1,
	lax = 2
};
#endif

/* soap.h:46 */
#ifndef SOAP_TYPE_soap__styleChoice
#define SOAP_TYPE_soap__styleChoice (231)
/* soap:styleChoice */
enum soap__styleChoice {
	rpc = 0,
	document = 1
};
#endif

/* soap.h:61 */
#ifndef SOAP_TYPE_soap__useChoice
#define SOAP_TYPE_soap__useChoice (235)
/* soap:useChoice */
enum soap__useChoice {
	literal = 0,
	encoded = 1
};
#endif

/* gwsdl.h:43 */
#ifndef SOAP_TYPE_sd__mutability
#define SOAP_TYPE_sd__mutability (278)
/* sd:mutability */
enum sd__mutability {
	static_ = 0,
	constant = 1,
	extendable = 2,
	mutable_ = 3
};
#endif

/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Classes, Structs and Unions                                                *
 *                                                                            *
\******************************************************************************/

class xs__annotation;	/* schema.h:55 */
class xs__assert;	/* schema.h:60 */
class xs__alternative;	/* schema.h:67 */
class xs__element;	/* schema.h:77 */
class xs__attribute;	/* schema.h:121 */
class xs__all;	/* schema.h:152 */
class xs__any;	/* schema.h:163 */
union xs__union_content;	/* schema.h:183 */
class xs__contents;	/* schema.h:174 */
class xs__seqchoice;	/* schema.h:50 */
class xs__group;	/* schema.h:51 */
class xs__anyAttribute;	/* schema.h:225 */
class xs__attributeGroup;	/* schema.h:231 */
class xs__enumeration;	/* schema.h:251 */
class xs__pattern;	/* schema.h:260 */
class xs__simpleContent;	/* schema.h:267 */
class xs__simpleType;	/* schema.h:46 */
class xs__extension;	/* schema.h:48 */
class xs__length;	/* schema.h:319 */
class xs__whiteSpace;	/* schema.h:326 */
class xs__restriction;	/* schema.h:49 */
class xs__list;	/* schema.h:52 */
class xs__union;	/* schema.h:53 */
class xs__complexContent;	/* schema.h:393 */
class xs__complexType;	/* schema.h:47 */
class xs__import;	/* schema.h:434 */
class xs__include;	/* schema.h:447 */
class xs__override;	/* schema.h:460 */
class xs__redefine;	/* schema.h:479 */
class xs__schema;	/* schema.h:45 */
class soap__binding;	/* soap.h:48 */
class soap__operation;	/* soap.h:54 */
class soap__body;	/* soap.h:63 */
class soap__fault;	/* soap.h:71 */
class soap__headerfault;	/* soap.h:79 */
class soap__header;	/* soap.h:97 */
class soap__address;	/* soap.h:116 */
class wsoap__module;	/* soap.h:121 */
class wsoap__header;	/* soap.h:127 */
class mime__content;	/* mime.h:46 */
class mime__part;	/* mime.h:52 */
class mime__multipartRelated;	/* mime.h:61 */
class mime__mimeXml;	/* mime.h:68 */
class dime__message;	/* dime.h:40 */
class http__address;	/* http.h:46 */
class http__binding;	/* http.h:51 */
class http__operation;	/* http.h:56 */
class whttp__header;	/* http.h:61 */
class sd__serviceData;	/* gwsdl.h:45 */
class sd__staticServiceDataValues;	/* gwsdl.h:58 */
class gwsdl__portType;	/* gwsdl.h:64 */
class wsa__EndpointReferenceType;	/* wsam.h:49 */
class wsp__PolicyReference;	/* wsp.h:50 */
class wsp__Assertion;	/* wsp.h:63 */
class wst__Claims;	/* wst.h:39 */
class sp__Header;	/* sp.h:45 */
class sp__Parts;	/* sp.h:51 */
class sp__Elements;	/* sp.h:58 */
class sp__Token;	/* sp.h:64 */
class wsrmp__Timeout;	/* wsrmp.h:47 */
class wsrmp__RMAssertion;	/* wsrmp.h:52 */
class wsrmp5__Timeout;	/* wsrmp.h:61 */
class wsrmp5__RMAssertion;	/* wsrmp.h:66 */
class wsp__Content;	/* wsp.h:45 */
class wsp__Policy;	/* wsp.h:44 */
class wsp__Attachment;	/* wsp.h:260 */
class wsp__AppliesTo;	/* wsp.h:266 */
class wsp__PolicyAttachment;	/* wsp.h:271 */
class plnk__tRole;	/* bpel.h:50 */
class plnk__tPartnerLinkType;	/* bpel.h:48 */
class vprop__tQuery;	/* bpel.h:75 */
class vprop__tProperty;	/* bpel.h:81 */
class vprop__tPropertyAlias;	/* bpel.h:91 */
class wsdl__import;	/* ./wsdl.h:55 */
class wsdl__types;	/* ./wsdl.h:69 */
class wsdl__part;	/* soap.h:44 */
class wsdl__message;	/* soap.h:43 */
class wsdl__ioput;	/* ./wsdl.h:110 */
class wsdl__fault;	/* ./wsdl.h:133 */
union wsdl__union_ioput;	/* ./wsdl.h:171 */
class wsdl__operation;	/* gwsdl.h:41 */
class wsdl__portType;	/* bpel.h:47 */
class wsdl__ext_ioput;	/* ./wsdl.h:200 */
class wsdl__ext_fault;	/* ./wsdl.h:221 */
class wsdl__ext_operation;	/* ./wsdl.h:242 */
class wsdl__binding;	/* ./wsdl.h:269 */
class wsdl__port;	/* ./wsdl.h:297 */
class wsdl__service;	/* ./wsdl.h:320 */
class wsdl__definitions;	/* soap.h:42 */

/* schema.h:55 */
#ifndef SOAP_TYPE_xs__annotation
#define SOAP_TYPE_xs__annotation (30)
/* complex XSD type 'xs:annotation': */
class SOAP_CMAC xs__annotation {
      public:
        /// Optional element 'xs:documentation' of XSD type 'xsd:string'
        std::vector<char *> documentation;
      public:
        /// Return unique type id SOAP_TYPE_xs__annotation
        virtual int soap_type(void) const { return SOAP_TYPE_xs__annotation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xs__annotation, default initialized and not managed by a soap context
        virtual xs__annotation *soap_alloc(void) const { return SOAP_NEW(xs__annotation); }
      public:
        /// Constructor with initializations
        xs__annotation()
        {
        }
        virtual ~xs__annotation() { }
        /// Friend allocator used by soap_new_xs__annotation(struct soap*, int)
        friend SOAP_FMAC1 xs__annotation * SOAP_FMAC2 wsdl_instantiate_xs__annotation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* schema.h:60 */
#ifndef SOAP_TYPE_xs__assert
#define SOAP_TYPE_xs__assert (32)
/* complex XSD type 'xs:assert': */
class SOAP_CMAC xs__assert {
      public:
        /// optional attribute 'test' of XSD type 'xsd:string'
        char *test;
        /// optional attribute 'xpathDefaultNamespace' of XSD type 'xsd:anyURI'
        char *xpathDefaultNamespace;
        /// Optional element 'xs:annotation' of XSD type 'xs:annotation'
        xs__annotation *annotation;
      public:
        /// Return unique type id SOAP_TYPE_xs__assert
        virtual int soap_type(void) const { return SOAP_TYPE_xs__assert; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xs__assert, default initialized and not managed by a soap context
        virtual xs__assert *soap_alloc(void) const { return SOAP_NEW(xs__assert); }
      public:
        /// Constructor with initializations
        xs__assert()
        {
          test = (char *)0;
          xpathDefaultNamespace = (char *)0;
          annotation = (xs__annotation *)0;
        }
        virtual ~xs__assert() { }
        /// Friend allocator used by soap_new_xs__assert(struct soap*, int)
        friend SOAP_FMAC1 xs__assert * SOAP_FMAC2 wsdl_instantiate_xs__assert(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* schema.h:67 */
#ifndef SOAP_TYPE_xs__alternative
#define SOAP_TYPE_xs__alternative (34)
/* complex XSD type 'xs:alternative': */
class SOAP_CMAC xs__alternative {
      public:
        /// optional attribute 'test' of XSD type 'xsd:string'
        char *test;
        /// optional attribute 'type' of XSD type 'xsd:QName'
        char *type;
        /// optional attribute 'xpathDefaultNamespace' of XSD type 'xsd:anyURI'
        char *xpathDefaultNamespace;
        /// Optional element 'xs:annotation' of XSD type 'xs:annotation'
        xs__annotation *annotation;
      public:
        /// Return unique type id SOAP_TYPE_xs__alternative
        virtual int soap_type(void) const { return SOAP_TYPE_xs__alternative; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xs__alternative, default initialized and not managed by a soap context
        virtual xs__alternative *soap_alloc(void) const { return SOAP_NEW(xs__alternative); }
      public:
        /// Constructor with initializations
        xs__alternative()
        {
          test = (char *)0;
          type = (char *)0;
          xpathDefaultNamespace = (char *)0;
          annotation = (xs__annotation *)0;
        }
        virtual ~xs__alternative() { }
        /// Friend allocator used by soap_new_xs__alternative(struct soap*, int)
        friend SOAP_FMAC1 xs__alternative * SOAP_FMAC2 wsdl_instantiate_xs__alternative(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* schema.h:77 */
#ifndef SOAP_TYPE_xs__element
#define SOAP_TYPE_xs__element (36)
/* Type xs__element is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'xs:element': */
class SOAP_CMAC xs__element {
      public:
        /// optional attribute 'name' of XSD type 'xsd:NCName'
        char *name;
        /// optional attribute 'ref' of XSD type 'xsd:QName'
        char *ref;
        /// optional attribute 'type' of XSD type 'xsd:QName'
        char *type;
        /// optional attribute 'default' of XSD type 'xsd:string'
        char *default_;
        /// optional attribute 'default' of XSD type 'xsd:QName'
        char *default__;
        /// optional attribute 'fixed' of XSD type 'xsd:string'
        char *fixed;
        /// optional attribute 'fixed' of XSD type 'xsd:QName'
        char *fixed_;
        /// optional attribute 'form' of XSD type 'xs:formChoice'
        enum xs__formChoice *form;
        /// optional attribute 'nillable' of XSD type 'xsd:boolean'
        bool nillable;	///< default = (bool)0
        /// optional attribute 'abstract' of XSD type 'xsd:boolean'
        bool abstract;	///< default = (bool)0
        /// optional attribute 'substitutionGroup' of XSD type 'xsd:QName'
        char *substitutionGroup;
        /// optional attribute 'minOccurs' of XSD type 'xsd:string'
        char *minOccurs;
        /// optional attribute 'maxOccurs' of XSD type 'xsd:string'
        char *maxOccurs;
        /// optional attribute 'targetNamespace' of XSD type 'xsd:anyURI'
        char *targetNamespace;
        /// optional attribute 'xmime:expectedContentTypes' of XSD type 'xsd:string'
        char *xmime__expectedContentTypes;
        /// Optional element 'xs:annotation' of XSD type 'xs:annotation'
        xs__annotation *annotation;
        /// Optional element 'xs:simpleType' of XSD type 'xs:simpleType'
        xs__simpleType *simpleType;
        /// Optional element 'xs:complexType' of XSD type 'xs:complexType'
        xs__complexType *complexType;
        /// Optional element 'xs:alternative' of XSD type 'xs:alternative'
        std::vector<xs__alternative> alternative;
        /// Optional element 'xs:unique' of XSD type 'xsd:string'
        char *unique;
      private:
        /// Not serialized
        xs__schema *schemaRef;
        /// Not serialized
        xs__element *elementRef;
        /// Not serialized
        xs__simpleType *simpleTypeRef;
        /// Not serialized
        xs__complexType *complexTypeRef;
        /// Not serialized
        std::vector<xs__element *> substitutions;
      public:
        xs__element();
        int traverse(xs__schema &_param_1);
        void schemaPtr(xs__schema *_param_1);
        void elementPtr(xs__element *_param_1);
        void simpleTypePtr(xs__simpleType *_param_1);
        void complexTypePtr(xs__complexType *_param_1);
        xs__schema *schemaPtr() const;
        xs__element *elementPtr() const;
        xs__simpleType *simpleTypePtr() const;
        xs__complexType *complexTypePtr() const;
        const std::vector<xs__element *> *substitutionsPtr() const;
      public:
        /// Return unique type id SOAP_TYPE_xs__element
        virtual int soap_type(void) const { return SOAP_TYPE_xs__element; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xs__element, default initialized and not managed by a soap context
        virtual xs__element *soap_alloc(void) const { return SOAP_NEW(xs__element); }
        virtual ~xs__element() { }
        /// Friend allocator used by soap_new_xs__element(struct soap*, int)
        friend SOAP_FMAC1 xs__element * SOAP_FMAC2 wsdl_instantiate_xs__element(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* schema.h:121 */
#ifndef SOAP_TYPE_xs__attribute
#define SOAP_TYPE_xs__attribute (64)
/* Type xs__attribute is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'xs:attribute': */
class SOAP_CMAC xs__attribute {
      public:
        /// optional attribute 'name' of XSD type 'xsd:NCName'
        char *name;
        /// optional attribute 'ref' of XSD type 'xsd:QName'
        char *ref;
        /// optional attribute 'type' of XSD type 'xsd:QName'
        char *type;
        /// optional attribute 'use' of XSD type 'xs:attribute-use'
        enum xs__attribute_use use;	///< default = (enum xs__attribute_use)0
        /// optional attribute 'default' of XSD type 'xsd:string'
        char *default_;
        /// optional attribute 'default' of XSD type 'xsd:QName'
        char *default__;
        /// optional attribute 'fixed' of XSD type 'xsd:string'
        char *fixed;
        /// optional attribute 'fixed' of XSD type 'xsd:QName'
        char *fixed_;
        /// optional attribute 'form' of XSD type 'xs:formChoice'
        enum xs__formChoice *form;
        /// optional attribute 'inheritable' of XSD type 'xsd:boolean'
        bool inheritable;
        /// optional attribute 'targetNamespace' of XSD type 'xsd:anyURI'
        char *targetNamespace;
        /// optional attribute 'wsdl:arrayType' of XSD type 'xsd:QName'
        char *wsdl__arrayType;
        /// Optional element 'xs:annotation' of XSD type 'xs:annotation'
        xs__annotation *annotation;
        /// Optional element 'xs:simpleType' of XSD type 'xs:simpleType'
        xs__simpleType *simpleType;
      private:
        /// Not serialized
        xs__schema *schemaRef;
        /// Not serialized
        xs__attribute *attributeRef;
        /// Not serialized
        xs__simpleType *simpleTypeRef;
      public:
        xs__attribute();
        int traverse(xs__schema &_param_1);
        void schemaPtr(xs__schema *_param_1);
        void attributePtr(xs__attribute *_param_1);
        void simpleTypePtr(xs__simpleType *_param_1);
        xs__schema *schemaPtr() const;
        xs__attribute *attributePtr() const;
        xs__simpleType *simpleTypePtr() const;
      public:
        /// Return unique type id SOAP_TYPE_xs__attribute
        virtual int soap_type(void) const { return SOAP_TYPE_xs__attribute; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xs__attribute, default initialized and not managed by a soap context
        virtual xs__attribute *soap_alloc(void) const { return SOAP_NEW(xs__attribute); }
        virtual ~xs__attribute() { }
        /// Friend allocator used by soap_new_xs__attribute(struct soap*, int)
        friend SOAP_FMAC1 xs__attribute * SOAP_FMAC2 wsdl_instantiate_xs__attribute(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* schema.h:152 */
#ifndef SOAP_TYPE_xs__all
#define SOAP_TYPE_xs__all (75)
/* complex XSD type 'xs:all': */
class SOAP_CMAC xs__all {
      public:
        /// Optional element 'xs:element' of XSD type 'xs:element'
        std::vector<xs__element> element;
        int traverse(xs__schema &_param_1);
      public:
        /// Return unique type id SOAP_TYPE_xs__all
        virtual int soap_type(void) const { return SOAP_TYPE_xs__all; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xs__all, default initialized and not managed by a soap context
        virtual xs__all *soap_alloc(void) const { return SOAP_NEW(xs__all); }
      public:
        /// Constructor with initializations
        xs__all()
        {
        }
        virtual ~xs__all() { }
        /// Friend allocator used by soap_new_xs__all(struct soap*, int)
        friend SOAP_FMAC1 xs__all * SOAP_FMAC2 wsdl_instantiate_xs__all(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* schema.h:163 */
#ifndef SOAP_TYPE_xs__any
#define SOAP_TYPE_xs__any (80)
/* complex XSD type 'xs:any': */
class SOAP_CMAC xs__any {
      public:
        /// optional attribute 'namespace' of XSD type 'xs:namespaceList'
        char *namespace_;	///< default = (char*)"##any"
        /// optional attribute 'processContents' of XSD type 'xs:processContents'
        enum xs__processContents processContents;	///< default = (enum xs__processContents)0
        /// optional attribute 'minOccurs' of XSD type 'xsd:string'
        char *minOccurs;
        /// optional attribute 'maxOccurs' of XSD type 'xsd:string'
        char *maxOccurs;
        /// Optional element 'xs:element' of XSD type 'xs:element'
        std::vector<xs__element> element;
        int traverse(xs__schema &_param_1);
      public:
        /// Return unique type id SOAP_TYPE_xs__any
        virtual int soap_type(void) const { return SOAP_TYPE_xs__any; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xs__any, default initialized and not managed by a soap context
        virtual xs__any *soap_alloc(void) const { return SOAP_NEW(xs__any); }
      public:
        /// Constructor with initializations
        xs__any()
        {
          namespace_ = (char*)"##any";
          processContents = (enum xs__processContents)0;
          minOccurs = (char *)0;
          maxOccurs = (char *)0;
        }
        virtual ~xs__any() { }
        /// Friend allocator used by soap_new_xs__any(struct soap*, int)
        friend SOAP_FMAC1 xs__any * SOAP_FMAC2 wsdl_instantiate_xs__any(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* schema.h:183 */
#ifndef SOAP_TYPE_xs__union_content
#define SOAP_TYPE_xs__union_content (86)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union xs__union_content
{
        #define SOAP_UNION_xs__union_content_element	(1)	/**< union variant selector value for member element */
        xs__element *element;
        #define SOAP_UNION_xs__union_content_group	(2)	/**< union variant selector value for member group */
        xs__group *group;
        #define SOAP_UNION_xs__union_content_choice	(3)	/**< union variant selector value for member choice */
        xs__seqchoice *choice;
        #define SOAP_UNION_xs__union_content_sequence	(4)	/**< union variant selector value for member sequence */
        xs__seqchoice *sequence;
        #define SOAP_UNION_xs__union_content_any	(5)	/**< union variant selector value for member any */
        xs__any *any;
};
#endif

/* schema.h:174 */
#ifndef SOAP_TYPE_xs__contents
#define SOAP_TYPE_xs__contents (82)
/* Choice: */
class SOAP_CMAC xs__contents {
      public:
        /// Union with union xs__union_content variant selector __union set to one of: SOAP_UNION_xs__union_content_element SOAP_UNION_xs__union_content_group SOAP_UNION_xs__union_content_choice SOAP_UNION_xs__union_content_sequence SOAP_UNION_xs__union_content_any
        int __union;
        union xs__union_content __content;
        int traverse(xs__schema &_param_1);
      public:
        /// Return unique type id SOAP_TYPE_xs__contents
        virtual int soap_type(void) const { return SOAP_TYPE_xs__contents; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xs__contents, default initialized and not managed by a soap context
        virtual xs__contents *soap_alloc(void) const { return SOAP_NEW(xs__contents); }
      public:
        /// Constructor with initializations
        xs__contents()
        {
          __union = 0;
        }
        virtual ~xs__contents() { }
        /// Friend allocator used by soap_new_xs__contents(struct soap*, int)
        friend SOAP_FMAC1 xs__contents * SOAP_FMAC2 wsdl_instantiate_xs__contents(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* schema.h:50 */
#ifndef SOAP_TYPE_xs__seqchoice
#define SOAP_TYPE_xs__seqchoice (26)
/* Type xs__seqchoice is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'xs:seqchoice': */
class SOAP_CMAC xs__seqchoice {
      public:
        /// optional attribute 'minOccurs' of XSD type 'xsd:string'
        char *minOccurs;
        /// optional attribute 'maxOccurs' of XSD type 'xsd:string'
        char *maxOccurs;
        /// Optional element 'xs:annotation' of XSD type 'xs:annotation'
        xs__annotation *annotation;
        std::vector<xs__contents> __contents;
      private:
        /// Not serialized
        xs__schema *schemaRef;
      public:
        xs__seqchoice();
        int traverse(xs__schema &_param_1);
        void schemaPtr(xs__schema *_param_1);
        xs__schema *schemaPtr() const;
      public:
        /// Return unique type id SOAP_TYPE_xs__seqchoice
        virtual int soap_type(void) const { return SOAP_TYPE_xs__seqchoice; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xs__seqchoice, default initialized and not managed by a soap context
        virtual xs__seqchoice *soap_alloc(void) const { return SOAP_NEW(xs__seqchoice); }
        virtual ~xs__seqchoice() { }
        /// Friend allocator used by soap_new_xs__seqchoice(struct soap*, int)
        friend SOAP_FMAC1 xs__seqchoice * SOAP_FMAC2 wsdl_instantiate_xs__seqchoice(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* schema.h:51 */
#ifndef SOAP_TYPE_xs__group
#define SOAP_TYPE_xs__group (27)
/* Type xs__group is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'xs:group': */
class SOAP_CMAC xs__group {
      public:
        /// optional attribute 'name' of XSD type 'xsd:NCName'
        char *name;
        /// optional attribute 'ref' of XSD type 'xsd:QName'
        char *ref;
        /// optional attribute 'minOccurs' of XSD type 'xsd:string'
        char *minOccurs;
        /// optional attribute 'maxOccurs' of XSD type 'xsd:string'
        char *maxOccurs;
        /// Optional element 'xs:annotation' of XSD type 'xs:annotation'
        xs__annotation *annotation;
        /// Optional element 'xs:all' of XSD type 'xs:all'
        xs__all *all;
        /// Optional element 'xs:choice' of XSD type 'xs:seqchoice'
        xs__seqchoice *choice;
        /// Optional element 'xs:sequence' of XSD type 'xs:seqchoice'
        xs__seqchoice *sequence;
      private:
        /// Not serialized
        xs__schema *schemaRef;
        /// Not serialized
        xs__group *groupRef;
      public:
        xs__group();
        int traverse(xs__schema &_param_1);
        void schemaPtr(xs__schema *_param_1);
        void groupPtr(xs__group *_param_1);
        xs__schema *schemaPtr() const;
        xs__group *groupPtr() const;
      public:
        /// Return unique type id SOAP_TYPE_xs__group
        virtual int soap_type(void) const { return SOAP_TYPE_xs__group; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xs__group, default initialized and not managed by a soap context
        virtual xs__group *soap_alloc(void) const { return SOAP_NEW(xs__group); }
        virtual ~xs__group() { }
        /// Friend allocator used by soap_new_xs__group(struct soap*, int)
        friend SOAP_FMAC1 xs__group * SOAP_FMAC2 wsdl_instantiate_xs__group(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* schema.h:225 */
#ifndef SOAP_TYPE_xs__anyAttribute
#define SOAP_TYPE_xs__anyAttribute (101)
/* complex XSD type 'xs:anyAttribute': */
class SOAP_CMAC xs__anyAttribute {
      public:
        /// optional attribute 'namespace' of XSD type 'xs:namespaceList'
        char *namespace_;	///< default = (char*)"##any"
        /// optional attribute 'processContents' of XSD type 'xs:processContents'
        enum xs__processContents processContents;	///< default = (enum xs__processContents)0
      public:
        /// Return unique type id SOAP_TYPE_xs__anyAttribute
        virtual int soap_type(void) const { return SOAP_TYPE_xs__anyAttribute; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xs__anyAttribute, default initialized and not managed by a soap context
        virtual xs__anyAttribute *soap_alloc(void) const { return SOAP_NEW(xs__anyAttribute); }
      public:
        /// Constructor with initializations
        xs__anyAttribute()
        {
          namespace_ = (char*)"##any";
          processContents = (enum xs__processContents)0;
        }
        virtual ~xs__anyAttribute() { }
        /// Friend allocator used by soap_new_xs__anyAttribute(struct soap*, int)
        friend SOAP_FMAC1 xs__anyAttribute * SOAP_FMAC2 wsdl_instantiate_xs__anyAttribute(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* schema.h:231 */
#ifndef SOAP_TYPE_xs__attributeGroup
#define SOAP_TYPE_xs__attributeGroup (102)
/* Type xs__attributeGroup is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'xs:attributeGroup': */
class SOAP_CMAC xs__attributeGroup {
      public:
        /// optional attribute 'name' of XSD type 'xsd:NCName'
        char *name;
        /// optional attribute 'ref' of XSD type 'xsd:QName'
        char *ref;
        /// Optional element 'xs:annotation' of XSD type 'xs:annotation'
        xs__annotation *annotation;
        /// Optional element 'xs:attribute' of XSD type 'xs:attribute'
        std::vector<xs__attribute> attribute;
        /// Optional element 'xs:attributeGroup' of XSD type 'xs:attributeGroup'
        std::vector<xs__attributeGroup> attributeGroup;
        /// Optional element 'xs:anyAttribute' of XSD type 'xs:anyAttribute'
        xs__anyAttribute *anyAttribute;
      private:
        /// Not serialized
        xs__schema *schemaRef;
        /// Not serialized
        xs__attributeGroup *attributeGroupRef;
      public:
        xs__attributeGroup();
        int traverse(xs__schema &_param_1);
        void schemaPtr(xs__schema *_param_1);
        void attributeGroupPtr(xs__attributeGroup *_param_1);
        xs__schema *schemaPtr() const;
        xs__attributeGroup *attributeGroupPtr() const;
      public:
        /// Return unique type id SOAP_TYPE_xs__attributeGroup
        virtual int soap_type(void) const { return SOAP_TYPE_xs__attributeGroup; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xs__attributeGroup, default initialized and not managed by a soap context
        virtual xs__attributeGroup *soap_alloc(void) const { return SOAP_NEW(xs__attributeGroup); }
        virtual ~xs__attributeGroup() { }
        /// Friend allocator used by soap_new_xs__attributeGroup(struct soap*, int)
        friend SOAP_FMAC1 xs__attributeGroup * SOAP_FMAC2 wsdl_instantiate_xs__attributeGroup(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* schema.h:251 */
#ifndef SOAP_TYPE_xs__enumeration
#define SOAP_TYPE_xs__enumeration (114)
/* complex XSD type 'xs:enumeration': */
class SOAP_CMAC xs__enumeration {
      public:
        /// optional attribute 'value' of XSD type 'xsd:string'
        char *value;
        /// optional attribute 'value' of XSD type 'xsd:QName'
        char *value_;
        /// Optional element 'xs:annotation' of XSD type 'xs:annotation'
        xs__annotation *annotation;
        int traverse(xs__schema &_param_1);
      public:
        /// Return unique type id SOAP_TYPE_xs__enumeration
        virtual int soap_type(void) const { return SOAP_TYPE_xs__enumeration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xs__enumeration, default initialized and not managed by a soap context
        virtual xs__enumeration *soap_alloc(void) const { return SOAP_NEW(xs__enumeration); }
      public:
        /// Constructor with initializations
        xs__enumeration()
        {
          value = (char *)0;
          value_ = (char *)0;
          annotation = (xs__annotation *)0;
        }
        virtual ~xs__enumeration() { }
        /// Friend allocator used by soap_new_xs__enumeration(struct soap*, int)
        friend SOAP_FMAC1 xs__enumeration * SOAP_FMAC2 wsdl_instantiate_xs__enumeration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* schema.h:260 */
#ifndef SOAP_TYPE_xs__pattern
#define SOAP_TYPE_xs__pattern (116)
/* complex XSD type 'xs:pattern': */
class SOAP_CMAC xs__pattern {
      public:
        /// optional attribute 'value' of XSD type 'xsd:string'
        char *value;
        int traverse(xs__schema &_param_1);
      public:
        /// Return unique type id SOAP_TYPE_xs__pattern
        virtual int soap_type(void) const { return SOAP_TYPE_xs__pattern; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xs__pattern, default initialized and not managed by a soap context
        virtual xs__pattern *soap_alloc(void) const { return SOAP_NEW(xs__pattern); }
      public:
        /// Constructor with initializations
        xs__pattern()
        {
          value = (char *)0;
        }
        virtual ~xs__pattern() { }
        /// Friend allocator used by soap_new_xs__pattern(struct soap*, int)
        friend SOAP_FMAC1 xs__pattern * SOAP_FMAC2 wsdl_instantiate_xs__pattern(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* schema.h:267 */
#ifndef SOAP_TYPE_xs__simpleContent
#define SOAP_TYPE_xs__simpleContent (118)
/* complex XSD type 'xs:simpleContent': */
class SOAP_CMAC xs__simpleContent {
      public:
        /// Optional element 'xs:extension' of XSD type 'xs:extension'
        xs__extension *extension;
        /// Optional element 'xs:restriction' of XSD type 'xs:restriction'
        xs__restriction *restriction;
        int traverse(xs__schema &_param_1);
      public:
        /// Return unique type id SOAP_TYPE_xs__simpleContent
        virtual int soap_type(void) const { return SOAP_TYPE_xs__simpleContent; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xs__simpleContent, default initialized and not managed by a soap context
        virtual xs__simpleContent *soap_alloc(void) const { return SOAP_NEW(xs__simpleContent); }
      public:
        /// Constructor with initializations
        xs__simpleContent()
        {
          extension = (xs__extension *)0;
          restriction = (xs__restriction *)0;
        }
        virtual ~xs__simpleContent() { }
        /// Friend allocator used by soap_new_xs__simpleContent(struct soap*, int)
        friend SOAP_FMAC1 xs__simpleContent * SOAP_FMAC2 wsdl_instantiate_xs__simpleContent(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* schema.h:46 */
#ifndef SOAP_TYPE_xs__simpleType
#define SOAP_TYPE_xs__simpleType (22)
/* Type xs__simpleType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'xs:simpleType': */
class SOAP_CMAC xs__simpleType {
      public:
        /// optional attribute 'name' of XSD type 'xsd:NMTOKEN'
        char *name;
        /// optional attribute 'vc:minVersion' of XSD type 'xsd:string'
        char *vc__minVersion;
        /// optional attribute 'vc:maxVersion' of XSD type 'xsd:string'
        char *vc__maxVersion;
        /// Optional element 'xs:annotation' of XSD type 'xs:annotation'
        xs__annotation *annotation;
        /// Optional element 'xs:restriction' of XSD type 'xs:restriction'
        xs__restriction *restriction;
        /// Optional element 'xs:list' of XSD type 'xs:list'
        xs__list *list;
        /// Optional element 'xs:union' of XSD type 'xs:union'
        xs__union *union_;
      private:
        /// Not serialized
        xs__schema *schemaRef;
        /// Not serialized
        int level;
      public:
        xs__simpleType();
        int traverse(xs__schema &_param_1);
        void schemaPtr(xs__schema *_param_1);
        xs__schema *schemaPtr() const;
        int baseLevel();
      public:
        /// Return unique type id SOAP_TYPE_xs__simpleType
        virtual int soap_type(void) const { return SOAP_TYPE_xs__simpleType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xs__simpleType, default initialized and not managed by a soap context
        virtual xs__simpleType *soap_alloc(void) const { return SOAP_NEW(xs__simpleType); }
        virtual ~xs__simpleType() { }
        /// Friend allocator used by soap_new_xs__simpleType(struct soap*, int)
        friend SOAP_FMAC1 xs__simpleType * SOAP_FMAC2 wsdl_instantiate_xs__simpleType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* schema.h:48 */
#ifndef SOAP_TYPE_xs__extension
#define SOAP_TYPE_xs__extension (24)
/* complex XSD type 'xs:extension': */
class SOAP_CMAC xs__extension {
      public:
        /// optional attribute 'base' of XSD type 'xsd:QName'
        char *base;
        /// Optional element 'xs:group' of XSD type 'xs:group'
        xs__group *group;
        /// Optional element 'xs:all' of XSD type 'xs:all'
        xs__all *all;
        /// Optional element 'xs:choice' of XSD type 'xs:seqchoice'
        xs__seqchoice *choice;
        /// Optional element 'xs:sequence' of XSD type 'xs:seqchoice'
        xs__seqchoice *sequence;
        /// Optional element 'xs:attribute' of XSD type 'xs:attribute'
        std::vector<xs__attribute> attribute;
        /// Optional element 'xs:attributeGroup' of XSD type 'xs:attributeGroup'
        std::vector<xs__attributeGroup> attributeGroup;
        /// Optional element 'xs:anyAttribute' of XSD type 'xs:anyAttribute'
        xs__anyAttribute *anyAttribute;
        /// Optional element 'xs:annotation' of XSD type 'xs:annotation'
        xs__annotation *annotation;
        /// Optional element 'xs:assert' of XSD type 'xs:assert'
        std::vector<xs__assert> assert;
      private:
        /// Not serialized
        xs__simpleType *simpleTypeRef;
        /// Not serialized
        xs__complexType *complexTypeRef;
      public:
        xs__extension();
        int traverse(xs__schema &_param_1);
        void simpleTypePtr(xs__simpleType *_param_1);
        void complexTypePtr(xs__complexType *_param_1);
        xs__simpleType *simpleTypePtr() const;
        xs__complexType *complexTypePtr() const;
      public:
        /// Return unique type id SOAP_TYPE_xs__extension
        virtual int soap_type(void) const { return SOAP_TYPE_xs__extension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xs__extension, default initialized and not managed by a soap context
        virtual xs__extension *soap_alloc(void) const { return SOAP_NEW(xs__extension); }
        virtual ~xs__extension() { }
        /// Friend allocator used by soap_new_xs__extension(struct soap*, int)
        friend SOAP_FMAC1 xs__extension * SOAP_FMAC2 wsdl_instantiate_xs__extension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* schema.h:319 */
#ifndef SOAP_TYPE_xs__length
#define SOAP_TYPE_xs__length (136)
/* complex XSD type 'xs:length': */
class SOAP_CMAC xs__length {
      public:
        /// optional attribute 'value' of XSD type 'xsd:string'
        char *value;
        /// optional attribute 'fixed' of XSD type 'xsd:boolean'
        bool fixed;
        /// Optional element 'xs:annotation' of XSD type 'xs:annotation'
        xs__annotation *annotation;
      public:
        /// Return unique type id SOAP_TYPE_xs__length
        virtual int soap_type(void) const { return SOAP_TYPE_xs__length; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xs__length, default initialized and not managed by a soap context
        virtual xs__length *soap_alloc(void) const { return SOAP_NEW(xs__length); }
      public:
        /// Constructor with initializations
        xs__length()
        {
          value = (char *)0;
          fixed = (bool)0;
          annotation = (xs__annotation *)0;
        }
        virtual ~xs__length() { }
        /// Friend allocator used by soap_new_xs__length(struct soap*, int)
        friend SOAP_FMAC1 xs__length * SOAP_FMAC2 wsdl_instantiate_xs__length(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* schema.h:326 */
#ifndef SOAP_TYPE_xs__whiteSpace
#define SOAP_TYPE_xs__whiteSpace (137)
/* complex XSD type 'xs:whiteSpace': */
class SOAP_CMAC xs__whiteSpace {
      public:
        /// optional attribute 'value' of XSD type 'xsd:string'
        char *value;
      public:
        /// Return unique type id SOAP_TYPE_xs__whiteSpace
        virtual int soap_type(void) const { return SOAP_TYPE_xs__whiteSpace; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xs__whiteSpace, default initialized and not managed by a soap context
        virtual xs__whiteSpace *soap_alloc(void) const { return SOAP_NEW(xs__whiteSpace); }
      public:
        /// Constructor with initializations
        xs__whiteSpace()
        {
          value = (char *)0;
        }
        virtual ~xs__whiteSpace() { }
        /// Friend allocator used by soap_new_xs__whiteSpace(struct soap*, int)
        friend SOAP_FMAC1 xs__whiteSpace * SOAP_FMAC2 wsdl_instantiate_xs__whiteSpace(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* schema.h:49 */
#ifndef SOAP_TYPE_xs__restriction
#define SOAP_TYPE_xs__restriction (25)
/* Type xs__restriction is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'xs:restriction': */
class SOAP_CMAC xs__restriction {
      public:
        /// optional attribute 'base' of XSD type 'xsd:QName'
        char *base;
        /// Optional element 'xs:simpleType' of XSD type 'xs:simpleType'
        xs__simpleType *simpleType;
        /// Optional element 'xs:attributeGroup' of XSD type 'xs:attributeGroup'
        xs__attributeGroup *attributeGroup;
        /// Optional element 'xs:group' of XSD type 'xs:group'
        xs__group *group;
        /// Optional element 'xs:all' of XSD type 'xs:all'
        xs__all *all;
        /// Optional element 'xs:choice' of XSD type 'xs:seqchoice'
        xs__seqchoice *choice;
        /// Optional element 'xs:sequence' of XSD type 'xs:seqchoice'
        xs__seqchoice *sequence;
        /// Optional element 'xs:attribute' of XSD type 'xs:attribute'
        std::vector<xs__attribute> attribute;
        /// Optional element 'xs:anyAttribute' of XSD type 'xs:anyAttribute'
        xs__anyAttribute *anyAttribute;
        /// Optional element 'xs:enumeration' of XSD type 'xs:enumeration'
        std::vector<xs__enumeration> enumeration;
        /// Optional element 'xs:pattern' of XSD type 'xs:pattern'
        std::vector<xs__pattern> pattern;
        /// Optional element 'xs:whiteSpace' of XSD type 'xs:whiteSpace'
        xs__whiteSpace *whiteSpace;
        /// Optional element 'xs:length' of XSD type 'xs:length'
        xs__length *length;
        /// Optional element 'xs:minLength' of XSD type 'xs:length'
        xs__length *minLength;
        /// Optional element 'xs:maxLength' of XSD type 'xs:length'
        xs__length *maxLength;
        /// Optional element 'xs:precision' of XSD type 'xs:length'
        xs__length *precision;
        /// Optional element 'xs:scale' of XSD type 'xs:length'
        xs__length *scale;
        /// Optional element 'xs:totalDigits' of XSD type 'xs:length'
        xs__length *totalDigits;
        /// Optional element 'xs:fractionDigits' of XSD type 'xs:length'
        xs__length *fractionDigits;
        /// Optional element 'xs:minInclusive' of XSD type 'xs:length'
        xs__length *minInclusive;
        /// Optional element 'xs:maxInclusive' of XSD type 'xs:length'
        xs__length *maxInclusive;
        /// Optional element 'xs:minExclusive' of XSD type 'xs:length'
        xs__length *minExclusive;
        /// Optional element 'xs:maxExclusive' of XSD type 'xs:length'
        xs__length *maxExclusive;
        /// Optional element 'xs:annotation' of XSD type 'xs:annotation'
        xs__annotation *annotation;
        /// Optional element 'xs:assert' of XSD type 'xs:assert'
        std::vector<xs__assert> assert;
        /// Optional element 'xs:assertion' of XSD type 'xs:assert'
        xs__assert *assertion;
      private:
        /// Not serialized
        xs__simpleType *simpleTypeRef;
        /// Not serialized
        xs__complexType *complexTypeRef;
      public:
        xs__restriction();
        int traverse(xs__schema &_param_1);
        void simpleTypePtr(xs__simpleType *_param_1);
        void complexTypePtr(xs__complexType *_param_1);
        xs__simpleType *simpleTypePtr() const;
        xs__complexType *complexTypePtr() const;
      public:
        /// Return unique type id SOAP_TYPE_xs__restriction
        virtual int soap_type(void) const { return SOAP_TYPE_xs__restriction; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xs__restriction, default initialized and not managed by a soap context
        virtual xs__restriction *soap_alloc(void) const { return SOAP_NEW(xs__restriction); }
        virtual ~xs__restriction() { }
        /// Friend allocator used by soap_new_xs__restriction(struct soap*, int)
        friend SOAP_FMAC1 xs__restriction * SOAP_FMAC2 wsdl_instantiate_xs__restriction(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* schema.h:52 */
#ifndef SOAP_TYPE_xs__list
#define SOAP_TYPE_xs__list (28)
/* complex XSD type 'xs:list': */
class SOAP_CMAC xs__list {
      public:
        /// optional attribute 'itemType' of XSD type 'xsd:QName'
        char *itemType;
        /// Optional element 'xs:restriction' of XSD type 'xs:restriction'
        xs__restriction *restriction;
        /// Optional element 'xs:simpleType' of XSD type 'xs:simpleType'
        std::vector<xs__simpleType> simpleType;
      private:
        /// Not serialized
        xs__simpleType *itemTypeRef;
      public:
        xs__list();
        int traverse(xs__schema &_param_1);
        void itemTypePtr(xs__simpleType *_param_1);
        xs__simpleType *itemTypePtr() const;
      public:
        /// Return unique type id SOAP_TYPE_xs__list
        virtual int soap_type(void) const { return SOAP_TYPE_xs__list; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xs__list, default initialized and not managed by a soap context
        virtual xs__list *soap_alloc(void) const { return SOAP_NEW(xs__list); }
        virtual ~xs__list() { }
        /// Friend allocator used by soap_new_xs__list(struct soap*, int)
        friend SOAP_FMAC1 xs__list * SOAP_FMAC2 wsdl_instantiate_xs__list(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* schema.h:53 */
#ifndef SOAP_TYPE_xs__union
#define SOAP_TYPE_xs__union (29)
/* complex XSD type 'xs:union': */
class SOAP_CMAC xs__union {
      public:
        /// optional attribute 'memberTypes' of XSD type 'xsd:NMTOKENS'
        char *memberTypes;
        /// Optional element 'xs:simpleType' of XSD type 'xs:simpleType'
        std::vector<xs__simpleType> simpleType;
        int traverse(xs__schema &_param_1);
      public:
        /// Return unique type id SOAP_TYPE_xs__union
        virtual int soap_type(void) const { return SOAP_TYPE_xs__union; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xs__union, default initialized and not managed by a soap context
        virtual xs__union *soap_alloc(void) const { return SOAP_NEW(xs__union); }
      public:
        /// Constructor with initializations
        xs__union()
        {
          memberTypes = (char *)0;
        }
        virtual ~xs__union() { }
        /// Friend allocator used by soap_new_xs__union(struct soap*, int)
        friend SOAP_FMAC1 xs__union * SOAP_FMAC2 wsdl_instantiate_xs__union(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* schema.h:393 */
#ifndef SOAP_TYPE_xs__complexContent
#define SOAP_TYPE_xs__complexContent (155)
/* complex XSD type 'xs:complexContent': */
class SOAP_CMAC xs__complexContent {
      public:
        /// optional attribute 'mixed' of XSD type 'xsd:boolean'
        bool mixed;	///< default = (bool)0
        /// Optional element 'xs:extension' of XSD type 'xs:extension'
        xs__extension *extension;
        /// Optional element 'xs:restriction' of XSD type 'xs:restriction'
        xs__restriction *restriction;
        /// Optional element 'xs:annotation' of XSD type 'xs:annotation'
        xs__annotation *annotation;
        int traverse(xs__schema &_param_1);
      public:
        /// Return unique type id SOAP_TYPE_xs__complexContent
        virtual int soap_type(void) const { return SOAP_TYPE_xs__complexContent; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xs__complexContent, default initialized and not managed by a soap context
        virtual xs__complexContent *soap_alloc(void) const { return SOAP_NEW(xs__complexContent); }
      public:
        /// Constructor with initializations
        xs__complexContent()
        {
          mixed = (bool)0;
          extension = (xs__extension *)0;
          restriction = (xs__restriction *)0;
          annotation = (xs__annotation *)0;
        }
        virtual ~xs__complexContent() { }
        /// Friend allocator used by soap_new_xs__complexContent(struct soap*, int)
        friend SOAP_FMAC1 xs__complexContent * SOAP_FMAC2 wsdl_instantiate_xs__complexContent(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* schema.h:47 */
#ifndef SOAP_TYPE_xs__complexType
#define SOAP_TYPE_xs__complexType (23)
/* Type xs__complexType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'xs:complexType': */
class SOAP_CMAC xs__complexType {
      public:
        /// optional attribute 'name' of XSD type 'xsd:NMTOKEN'
        char *name;
        /// optional attribute 'abstract' of XSD type 'xsd:boolean'
        bool abstract;	///< default = (bool)0
        /// optional attribute 'mixed' of XSD type 'xsd:boolean'
        bool mixed;	///< default = (bool)0
        /// optional attribute 'defaultAttributesApply' of XSD type 'xsd:boolean'
        bool defaultAttributesApply;	///< default = (bool)1
        /// optional attribute 'vc:minVersion' of XSD type 'xsd:string'
        char *vc__minVersion;
        /// optional attribute 'vc:maxVersion' of XSD type 'xsd:string'
        char *vc__maxVersion;
        /// Optional element 'xs:annotation' of XSD type 'xs:annotation'
        xs__annotation *annotation;
        /// Optional element 'xs:simpleContent' of XSD type 'xs:simpleContent'
        xs__simpleContent *simpleContent;
        /// Optional element 'xs:complexContent' of XSD type 'xs:complexContent'
        xs__complexContent *complexContent;
        /// Optional element 'xs:all' of XSD type 'xs:all'
        xs__all *all;
        /// Optional element 'xs:choice' of XSD type 'xs:seqchoice'
        xs__seqchoice *choice;
        /// Optional element 'xs:sequence' of XSD type 'xs:seqchoice'
        xs__seqchoice *sequence;
        /// Optional element 'xs:group' of XSD type 'xs:group'
        xs__group *group;
        /// Optional element 'xs:any' of XSD type 'xs:any'
        xs__any *any;
        /// Optional element 'xs:attribute' of XSD type 'xs:attribute'
        std::vector<xs__attribute> attribute;
        /// Optional element 'xs:attributeGroup' of XSD type 'xs:attributeGroup'
        std::vector<xs__attributeGroup> attributeGroup;
        /// Optional element 'xs:anyAttribute' of XSD type 'xs:anyAttribute'
        xs__anyAttribute *anyAttribute;
        /// Optional element 'xs:assert' of XSD type 'xs:assert'
        std::vector<xs__assert> assert;
      private:
        /// Not serialized
        xs__schema *schemaRef;
        /// Not serialized
        int level;
      public:
        xs__complexType();
        int traverse(xs__schema &_param_1);
        void schemaPtr(xs__schema *_param_1);
        xs__schema *schemaPtr() const;
        int baseLevel();
      public:
        /// Return unique type id SOAP_TYPE_xs__complexType
        virtual int soap_type(void) const { return SOAP_TYPE_xs__complexType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xs__complexType, default initialized and not managed by a soap context
        virtual xs__complexType *soap_alloc(void) const { return SOAP_NEW(xs__complexType); }
        virtual ~xs__complexType() { }
        /// Friend allocator used by soap_new_xs__complexType(struct soap*, int)
        friend SOAP_FMAC1 xs__complexType * SOAP_FMAC2 wsdl_instantiate_xs__complexType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* schema.h:434 */
#ifndef SOAP_TYPE_xs__import
#define SOAP_TYPE_xs__import (164)
/* complex XSD type 'xs:import': */
class SOAP_CMAC xs__import {
      public:
        /// optional attribute 'namespace' of XSD type 'xsd:anyURI'
        char *namespace_;
        /// optional attribute 'schemaLocation' of XSD type 'xsd:anyURI'
        char *schemaLocation;
      private:
        /// Not serialized
        xs__schema *schemaRef;
      public:
        xs__import();
        int traverse(xs__schema &_param_1);
        void schemaPtr(xs__schema *_param_1);
        xs__schema *schemaPtr() const;
      public:
        /// Return unique type id SOAP_TYPE_xs__import
        virtual int soap_type(void) const { return SOAP_TYPE_xs__import; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xs__import, default initialized and not managed by a soap context
        virtual xs__import *soap_alloc(void) const { return SOAP_NEW(xs__import); }
        virtual ~xs__import() { }
        /// Friend allocator used by soap_new_xs__import(struct soap*, int)
        friend SOAP_FMAC1 xs__import * SOAP_FMAC2 wsdl_instantiate_xs__import(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* schema.h:447 */
#ifndef SOAP_TYPE_xs__include
#define SOAP_TYPE_xs__include (169)
/* complex XSD type 'xs:include': */
class SOAP_CMAC xs__include {
      public:
        /// optional attribute 'schemaLocation' of XSD type 'xsd:anyURI'
        char *schemaLocation;
      private:
        /// Not serialized
        xs__schema *schemaRef;
      public:
        xs__include();
        int preprocess(xs__schema &_param_1);
        int traverse(xs__schema &_param_1);
        void schemaPtr(xs__schema *_param_1);
        xs__schema *schemaPtr() const;
      public:
        /// Return unique type id SOAP_TYPE_xs__include
        virtual int soap_type(void) const { return SOAP_TYPE_xs__include; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xs__include, default initialized and not managed by a soap context
        virtual xs__include *soap_alloc(void) const { return SOAP_NEW(xs__include); }
        virtual ~xs__include() { }
        /// Friend allocator used by soap_new_xs__include(struct soap*, int)
        friend SOAP_FMAC1 xs__include * SOAP_FMAC2 wsdl_instantiate_xs__include(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* schema.h:460 */
#ifndef SOAP_TYPE_xs__override
#define SOAP_TYPE_xs__override (175)
/* complex XSD type 'xs:override': */
class SOAP_CMAC xs__override {
      public:
        /// optional attribute 'schemaLocation' of XSD type 'xsd:anyURI'
        char *schemaLocation;
        /// Optional element 'xs:attribute' of XSD type 'xs:attribute'
        std::vector<xs__attribute> attribute;
        /// Optional element 'xs:element' of XSD type 'xs:element'
        std::vector<xs__element> element;
        /// Optional element 'xs:group' of XSD type 'xs:group'
        std::vector<xs__group> group;
        /// Optional element 'xs:attributeGroup' of XSD type 'xs:attributeGroup'
        std::vector<xs__attributeGroup> attributeGroup;
        /// Optional element 'xs:simpleType' of XSD type 'xs:simpleType'
        std::vector<xs__simpleType> simpleType;
        /// Optional element 'xs:complexType' of XSD type 'xs:complexType'
        std::vector<xs__complexType> complexType;
      private:
        /// Not serialized
        xs__schema *schemaRef;
      public:
        xs__override();
        int preprocess(xs__schema &_param_1);
        int traverse(xs__schema &_param_1);
        void schemaPtr(xs__schema *_param_1);
        xs__schema *schemaPtr() const;
      public:
        /// Return unique type id SOAP_TYPE_xs__override
        virtual int soap_type(void) const { return SOAP_TYPE_xs__override; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xs__override, default initialized and not managed by a soap context
        virtual xs__override *soap_alloc(void) const { return SOAP_NEW(xs__override); }
        virtual ~xs__override() { }
        /// Friend allocator used by soap_new_xs__override(struct soap*, int)
        friend SOAP_FMAC1 xs__override * SOAP_FMAC2 wsdl_instantiate_xs__override(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* schema.h:479 */
#ifndef SOAP_TYPE_xs__redefine
#define SOAP_TYPE_xs__redefine (183)
/* complex XSD type 'xs:redefine': */
class SOAP_CMAC xs__redefine {
      public:
        /// optional attribute 'schemaLocation' of XSD type 'xsd:anyURI'
        char *schemaLocation;
        /// Optional element 'xs:group' of XSD type 'xs:group'
        std::vector<xs__group> group;
        /// Optional element 'xs:attributeGroup' of XSD type 'xs:attributeGroup'
        std::vector<xs__attributeGroup> attributeGroup;
        /// Optional element 'xs:simpleType' of XSD type 'xs:simpleType'
        std::vector<xs__simpleType> simpleType;
        /// Optional element 'xs:complexType' of XSD type 'xs:complexType'
        std::vector<xs__complexType> complexType;
      private:
        /// Not serialized
        xs__schema *schemaRef;
      public:
        xs__redefine();
        int preprocess(xs__schema &_param_1);
        int traverse(xs__schema &_param_1);
        void schemaPtr(xs__schema *_param_1);
        xs__schema *schemaPtr() const;
      public:
        /// Return unique type id SOAP_TYPE_xs__redefine
        virtual int soap_type(void) const { return SOAP_TYPE_xs__redefine; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xs__redefine, default initialized and not managed by a soap context
        virtual xs__redefine *soap_alloc(void) const { return SOAP_NEW(xs__redefine); }
        virtual ~xs__redefine() { }
        /// Friend allocator used by soap_new_xs__redefine(struct soap*, int)
        friend SOAP_FMAC1 xs__redefine * SOAP_FMAC2 wsdl_instantiate_xs__redefine(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* schema.h:45 */
#ifndef SOAP_TYPE_xs__schema
#define SOAP_TYPE_xs__schema (21)
/* Type xs__schema is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'xs:schema': */
class SOAP_CMAC xs__schema {
      public:
        /// optional attribute 'targetNamespace' of XSD type 'xsd:anyURI'
        char *targetNamespace;	///< default = (char*)""
        /// optional attribute 'version' of XSD type 'xsd:string'
        char *version;
        /// optional attribute 'defaultAttributes' of XSD type 'xsd:NCName'
        char *defaultAttributes;
        /// optional attribute 'attributeFormDefault' of XSD type 'xs:formChoice'
        enum xs__formChoice attributeFormDefault;	///< default = (enum xs__formChoice)0
        /// optional attribute 'elementFormDefault' of XSD type 'xs:formChoice'
        enum xs__formChoice elementFormDefault;	///< default = (enum xs__formChoice)0
        /// Optional element 'xs:annotation' of XSD type 'xs:annotation'
        xs__annotation *annotation;
        /// Optional element 'xs:include' of XSD type 'xs:include'
        std::vector<xs__include> include;
        /// Optional element 'xs:override' of XSD type 'xs:override'
        std::vector<xs__override> override_;
        /// Optional element 'xs:redefine' of XSD type 'xs:redefine'
        std::vector<xs__redefine> redefine;
        /// Optional element 'xs:import' of XSD type 'xs:import'
        std::vector<xs__import> import;
        /// Optional element 'xs:attribute' of XSD type 'xs:attribute'
        std::vector<xs__attribute> attribute;
        /// Optional element 'xs:element' of XSD type 'xs:element'
        std::vector<xs__element> element;
        /// Optional element 'xs:group' of XSD type 'xs:group'
        std::vector<xs__group> group;
        /// Optional element 'xs:attributeGroup' of XSD type 'xs:attributeGroup'
        std::vector<xs__attributeGroup> attributeGroup;
        /// Optional element 'xs:simpleType' of XSD type 'xs:simpleType'
        std::vector<xs__simpleType> simpleType;
        /// Optional element 'xs:complexType' of XSD type 'xs:complexType'
        std::vector<xs__complexType> complexType;
        /// Context that manages this object
        struct soap *soap;
      private:
        /// Not serialized
        xs__attributeGroup *attributeGroupRef;
        /// Not serialized
        bool updated;
        /// Not serialized
        char *location;
        /// Not serialized
        int redirs;
        /// Not serialized
        SetOfString builtinTypeSet;
        /// Not serialized
        SetOfString builtinElementSet;
        /// Not serialized
        SetOfString builtinAttributeSet;
      public:
        xs__schema();
        xs__schema(struct soap *_param_1);
        xs__schema(struct soap *_param_1, const char *_param_2, const char *_param_3);
        virtual ~xs__schema();
        int get(struct soap *_param_1);
        int preprocess();
        int insert(xs__schema &_param_1);
        int traverse();
        int read(const char *_param_1, const char *_param_2);
        void sourceLocation(const char *_param_1);
        const char *sourceLocation();
        xs__attributeGroup *attributeGroupPtr() const;
        int error();
        void print_fault();
        void builtinType(const char *_param_1);
        void builtinElement(const char *_param_1);
        void builtinAttribute(const char *_param_1);
        const SetOfString &builtinTypes() const;
        const SetOfString &builtinElements() const;
        const SetOfString &builtinAttributes() const;
        bool empty() const;
        friend ostream &operator<<(ostream &_param_1, const xs__schema &_param_2);
        friend istream &operator>>(istream &_param_1, xs__schema &_param_2);
      public:
        /// Return unique type id SOAP_TYPE_xs__schema
        virtual int soap_type(void) const { return SOAP_TYPE_xs__schema; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xs__schema, default initialized and not managed by a soap context
        virtual xs__schema *soap_alloc(void) const { return SOAP_NEW(xs__schema); }
        /// Friend allocator used by soap_new_xs__schema(struct soap*, int)
        friend SOAP_FMAC1 xs__schema * SOAP_FMAC2 wsdl_instantiate_xs__schema(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap.h:48 */
#ifndef SOAP_TYPE_soap__binding
#define SOAP_TYPE_soap__binding (232)
/* complex XSD type 'soap:binding': */
class SOAP_CMAC soap__binding {
      public:
        /// optional attribute 'transport' of XSD type 'xsd:anyURI'
        char *transport;
        /// optional attribute 'style' of XSD type 'soap:styleChoice'
        enum soap__styleChoice *style;
      public:
        /// Return unique type id SOAP_TYPE_soap__binding
        virtual int soap_type(void) const { return SOAP_TYPE_soap__binding; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type soap__binding, default initialized and not managed by a soap context
        virtual soap__binding *soap_alloc(void) const { return SOAP_NEW(soap__binding); }
      public:
        /// Constructor with initializations
        soap__binding()
        {
          transport = (char *)0;
          style = (enum soap__styleChoice *)0;
        }
        virtual ~soap__binding() { }
        /// Friend allocator used by soap_new_soap__binding(struct soap*, int)
        friend SOAP_FMAC1 soap__binding * SOAP_FMAC2 wsdl_instantiate_soap__binding(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap.h:54 */
#ifndef SOAP_TYPE_soap__operation
#define SOAP_TYPE_soap__operation (234)
/* complex XSD type 'soap:operation': */
class SOAP_CMAC soap__operation {
      public:
        /// optional attribute 'soapAction' of XSD type 'xsd:anyURI'
        char *soapAction;
        /// optional attribute 'soapActionRequired' of XSD type 'xsd:boolean'
        bool soapActionRequired;	///< default = (bool)1
        /// optional attribute 'style' of XSD type 'soap:styleChoice'
        enum soap__styleChoice *style;
      public:
        /// Return unique type id SOAP_TYPE_soap__operation
        virtual int soap_type(void) const { return SOAP_TYPE_soap__operation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type soap__operation, default initialized and not managed by a soap context
        virtual soap__operation *soap_alloc(void) const { return SOAP_NEW(soap__operation); }
      public:
        /// Constructor with initializations
        soap__operation()
        {
          soapAction = (char *)0;
          soapActionRequired = (bool)1;
          style = (enum soap__styleChoice *)0;
        }
        virtual ~soap__operation() { }
        /// Friend allocator used by soap_new_soap__operation(struct soap*, int)
        friend SOAP_FMAC1 soap__operation * SOAP_FMAC2 wsdl_instantiate_soap__operation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap.h:63 */
#ifndef SOAP_TYPE_soap__body
#define SOAP_TYPE_soap__body (236)
/* complex XSD type 'soap:body': */
class SOAP_CMAC soap__body {
      public:
        /// optional attribute 'encodingStyle' of XSD type 'xsd:anyURI'
        char *encodingStyle;
        /// optional attribute 'parts' of XSD type 'xsd:NMTOKENS'
        char *parts;
        /// optional attribute 'use' of XSD type 'soap:useChoice'
        enum soap__useChoice use;
        /// optional attribute 'namespace' of XSD type 'xsd:anyURI'
        char *namespace_;
      public:
        /// Return unique type id SOAP_TYPE_soap__body
        virtual int soap_type(void) const { return SOAP_TYPE_soap__body; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type soap__body, default initialized and not managed by a soap context
        virtual soap__body *soap_alloc(void) const { return SOAP_NEW(soap__body); }
      public:
        /// Constructor with initializations
        soap__body()
        {
          encodingStyle = (char *)0;
          parts = (char *)0;
          use = (enum soap__useChoice)0;
          namespace_ = (char *)0;
        }
        virtual ~soap__body() { }
        /// Friend allocator used by soap_new_soap__body(struct soap*, int)
        friend SOAP_FMAC1 soap__body * SOAP_FMAC2 wsdl_instantiate_soap__body(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap.h:71 */
#ifndef SOAP_TYPE_soap__fault
#define SOAP_TYPE_soap__fault (237)
/* complex XSD type 'soap:fault': */
class SOAP_CMAC soap__fault {
      public:
        /// optional attribute 'name' of XSD type 'xsd:NMTOKEN'
        char *name;
        /// optional attribute 'encodingStyle' of XSD type 'xsd:anyURI'
        char *encodingStyle;
        /// optional attribute 'use' of XSD type 'soap:useChoice'
        enum soap__useChoice use;
        /// optional attribute 'namespace' of XSD type 'xsd:anyURI'
        char *namespace_;
      public:
        /// Return unique type id SOAP_TYPE_soap__fault
        virtual int soap_type(void) const { return SOAP_TYPE_soap__fault; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type soap__fault, default initialized and not managed by a soap context
        virtual soap__fault *soap_alloc(void) const { return SOAP_NEW(soap__fault); }
      public:
        /// Constructor with initializations
        soap__fault()
        {
          name = (char *)0;
          encodingStyle = (char *)0;
          use = (enum soap__useChoice)0;
          namespace_ = (char *)0;
        }
        virtual ~soap__fault() { }
        /// Friend allocator used by soap_new_soap__fault(struct soap*, int)
        friend SOAP_FMAC1 soap__fault * SOAP_FMAC2 wsdl_instantiate_soap__fault(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap.h:79 */
#ifndef SOAP_TYPE_soap__headerfault
#define SOAP_TYPE_soap__headerfault (238)
/* complex XSD type 'soap:headerfault': */
class SOAP_CMAC soap__headerfault {
      public:
        /// optional attribute 'message' of XSD type 'xsd:QName'
        char *message;
        /// optional attribute 'part' of XSD type 'xsd:NMTOKEN'
        char *part;
        /// optional attribute 'use' of XSD type 'soap:useChoice'
        enum soap__useChoice use;
        /// optional attribute 'encodingStyle' of XSD type 'xsd:anyURI'
        char *encodingStyle;
        /// optional attribute 'namespace' of XSD type 'xsd:anyURI'
        char *namespace_;
      private:
        /// Not serialized
        wsdl__message *messageRef;
        /// Not serialized
        wsdl__part *partRef;
      public:
        int traverse(wsdl__definitions &_param_1);
        void messagePtr(wsdl__message *_param_1);
        void partPtr(wsdl__part *_param_1);
        wsdl__message *messagePtr() const;
        wsdl__part *partPtr() const;
      public:
        /// Return unique type id SOAP_TYPE_soap__headerfault
        virtual int soap_type(void) const { return SOAP_TYPE_soap__headerfault; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type soap__headerfault, default initialized and not managed by a soap context
        virtual soap__headerfault *soap_alloc(void) const { return SOAP_NEW(soap__headerfault); }
      public:
        /// Constructor with initializations
        soap__headerfault()
        {
          message = (char *)0;
          part = (char *)0;
          use = (enum soap__useChoice)0;
          encodingStyle = (char *)0;
          namespace_ = (char *)0;
          messageRef = (wsdl__message *)0;
          partRef = (wsdl__part *)0;
        }
        virtual ~soap__headerfault() { }
        /// Friend allocator used by soap_new_soap__headerfault(struct soap*, int)
        friend SOAP_FMAC1 soap__headerfault * SOAP_FMAC2 wsdl_instantiate_soap__headerfault(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap.h:97 */
#ifndef SOAP_TYPE_soap__header
#define SOAP_TYPE_soap__header (249)
/* complex XSD type 'soap:header': */
class SOAP_CMAC soap__header {
      public:
        /// optional attribute 'message' of XSD type 'xsd:QName'
        char *message;
        /// optional attribute 'part' of XSD type 'xsd:NMTOKEN'
        char *part;
        /// optional attribute 'use' of XSD type 'soap:useChoice'
        enum soap__useChoice use;
        /// optional attribute 'encodingStyle' of XSD type 'xsd:anyURI'
        char *encodingStyle;
        /// optional attribute 'namespace' of XSD type 'xsd:anyURI'
        char *namespace_;
        /// Optional element 'headerfault' of XSD type 'soap:headerfault'
        std::vector<soap__headerfault> headerfault;
      private:
        /// Not serialized
        wsdl__message *messageRef;
        /// Not serialized
        wsdl__part *partRef;
      public:
        int traverse(wsdl__definitions &_param_1);
        void messagePtr(wsdl__message *_param_1);
        void partPtr(wsdl__part *_param_1);
        wsdl__message *messagePtr() const;
        wsdl__part *partPtr() const;
      public:
        /// Return unique type id SOAP_TYPE_soap__header
        virtual int soap_type(void) const { return SOAP_TYPE_soap__header; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type soap__header, default initialized and not managed by a soap context
        virtual soap__header *soap_alloc(void) const { return SOAP_NEW(soap__header); }
      public:
        /// Constructor with initializations
        soap__header()
        {
          message = (char *)0;
          part = (char *)0;
          use = (enum soap__useChoice)0;
          encodingStyle = (char *)0;
          namespace_ = (char *)0;
          messageRef = (wsdl__message *)0;
          partRef = (wsdl__part *)0;
        }
        virtual ~soap__header() { }
        /// Friend allocator used by soap_new_soap__header(struct soap*, int)
        friend SOAP_FMAC1 soap__header * SOAP_FMAC2 wsdl_instantiate_soap__header(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap.h:116 */
#ifndef SOAP_TYPE_soap__address
#define SOAP_TYPE_soap__address (256)
/* complex XSD type 'soap:address': */
class SOAP_CMAC soap__address {
      public:
        /// optional attribute 'location' of XSD type 'xsd:anyURI'
        char *location;
      public:
        /// Return unique type id SOAP_TYPE_soap__address
        virtual int soap_type(void) const { return SOAP_TYPE_soap__address; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type soap__address, default initialized and not managed by a soap context
        virtual soap__address *soap_alloc(void) const { return SOAP_NEW(soap__address); }
      public:
        /// Constructor with initializations
        soap__address()
        {
          location = (char *)0;
        }
        virtual ~soap__address() { }
        /// Friend allocator used by soap_new_soap__address(struct soap*, int)
        friend SOAP_FMAC1 soap__address * SOAP_FMAC2 wsdl_instantiate_soap__address(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap.h:121 */
#ifndef SOAP_TYPE_wsoap__module
#define SOAP_TYPE_wsoap__module (257)
/* complex XSD type 'wsoap:module': */
class SOAP_CMAC wsoap__module {
      public:
        /// optional attribute 'ref' of XSD type 'xsd:anyURI'
        char *ref;
        /// optional attribute 'required' of XSD type 'xsd:boolean'
        bool required;	///< default = (bool)0
      public:
        /// Return unique type id SOAP_TYPE_wsoap__module
        virtual int soap_type(void) const { return SOAP_TYPE_wsoap__module; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsoap__module, default initialized and not managed by a soap context
        virtual wsoap__module *soap_alloc(void) const { return SOAP_NEW(wsoap__module); }
      public:
        /// Constructor with initializations
        wsoap__module()
        {
          ref = (char *)0;
          required = (bool)0;
        }
        virtual ~wsoap__module() { }
        /// Friend allocator used by soap_new_wsoap__module(struct soap*, int)
        friend SOAP_FMAC1 wsoap__module * SOAP_FMAC2 wsdl_instantiate_wsoap__module(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap.h:127 */
#ifndef SOAP_TYPE_wsoap__header
#define SOAP_TYPE_wsoap__header (258)
/* complex XSD type 'wsoap:header': */
class SOAP_CMAC wsoap__header {
      public:
        /// optional attribute 'element' of XSD type 'xsd:QName'
        char *element;
        /// optional attribute 'mustUnderstand' of XSD type 'xsd:boolean'
        bool mustUnderstand_;	///< default = (bool)0
        /// optional attribute 'required' of XSD type 'xsd:boolean'
        bool required;	///< default = (bool)0
      private:
        /// Not serialized
        xs__element *elementRef;
      public:
        int traverse(wsdl__definitions &_param_1);
        void elementPtr(xs__element *_param_1);
        xs__element *elementPtr() const;
      public:
        /// Return unique type id SOAP_TYPE_wsoap__header
        virtual int soap_type(void) const { return SOAP_TYPE_wsoap__header; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsoap__header, default initialized and not managed by a soap context
        virtual wsoap__header *soap_alloc(void) const { return SOAP_NEW(wsoap__header); }
      public:
        /// Constructor with initializations
        wsoap__header()
        {
          element = (char *)0;
          mustUnderstand_ = (bool)0;
          required = (bool)0;
          elementRef = (xs__element *)0;
        }
        virtual ~wsoap__header() { }
        /// Friend allocator used by soap_new_wsoap__header(struct soap*, int)
        friend SOAP_FMAC1 wsoap__header * SOAP_FMAC2 wsdl_instantiate_wsoap__header(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mime.h:46 */
#ifndef SOAP_TYPE_mime__content
#define SOAP_TYPE_mime__content (262)
/* complex XSD type 'mime:content': */
class SOAP_CMAC mime__content {
      public:
        /// optional attribute 'part' of XSD type 'xsd:NMTOKEN'
        char *part;
        /// optional attribute 'type' of XSD type 'xsd:string'
        char *type;
      public:
        /// Return unique type id SOAP_TYPE_mime__content
        virtual int soap_type(void) const { return SOAP_TYPE_mime__content; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type mime__content, default initialized and not managed by a soap context
        virtual mime__content *soap_alloc(void) const { return SOAP_NEW(mime__content); }
      public:
        /// Constructor with initializations
        mime__content()
        {
          part = (char *)0;
          type = (char *)0;
        }
        virtual ~mime__content() { }
        /// Friend allocator used by soap_new_mime__content(struct soap*, int)
        friend SOAP_FMAC1 mime__content * SOAP_FMAC2 wsdl_instantiate_mime__content(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mime.h:52 */
#ifndef SOAP_TYPE_mime__part
#define SOAP_TYPE_mime__part (263)
/* complex XSD type 'mime:part': */
class SOAP_CMAC mime__part {
      public:
        /// Optional element 'soap:body' of XSD type 'soap:body'
        soap__body *soap__body_;
        /// Optional element 'soap:header' of XSD type 'soap:header'
        std::vector<soap__header> soap__header_;
        /// Optional element 'mime:content' of XSD type 'mime:content'
        std::vector<mime__content> content;
        int traverse(wsdl__definitions &_param_1);
      public:
        /// Return unique type id SOAP_TYPE_mime__part
        virtual int soap_type(void) const { return SOAP_TYPE_mime__part; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type mime__part, default initialized and not managed by a soap context
        virtual mime__part *soap_alloc(void) const { return SOAP_NEW(mime__part); }
      public:
        /// Constructor with initializations
        mime__part()
        {
          soap__body_ = (soap__body *)0;
        }
        virtual ~mime__part() { }
        /// Friend allocator used by soap_new_mime__part(struct soap*, int)
        friend SOAP_FMAC1 mime__part * SOAP_FMAC2 wsdl_instantiate_mime__part(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mime.h:61 */
#ifndef SOAP_TYPE_mime__multipartRelated
#define SOAP_TYPE_mime__multipartRelated (268)
/* complex XSD type 'mime:multipartRelated': */
class SOAP_CMAC mime__multipartRelated {
      public:
        /// Optional element 'mime:part' of XSD type 'mime:part'
        std::vector<mime__part> part;
        int traverse(wsdl__definitions &_param_1);
      public:
        /// Return unique type id SOAP_TYPE_mime__multipartRelated
        virtual int soap_type(void) const { return SOAP_TYPE_mime__multipartRelated; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type mime__multipartRelated, default initialized and not managed by a soap context
        virtual mime__multipartRelated *soap_alloc(void) const { return SOAP_NEW(mime__multipartRelated); }
      public:
        /// Constructor with initializations
        mime__multipartRelated()
        {
        }
        virtual ~mime__multipartRelated() { }
        /// Friend allocator used by soap_new_mime__multipartRelated(struct soap*, int)
        friend SOAP_FMAC1 mime__multipartRelated * SOAP_FMAC2 wsdl_instantiate_mime__multipartRelated(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mime.h:68 */
#ifndef SOAP_TYPE_mime__mimeXml
#define SOAP_TYPE_mime__mimeXml (271)
/* complex XSD type 'mime:mimeXml': */
class SOAP_CMAC mime__mimeXml {
      public:
        /// optional attribute 'part' of XSD type 'xsd:NMTOKEN'
        char *part;
      public:
        /// Return unique type id SOAP_TYPE_mime__mimeXml
        virtual int soap_type(void) const { return SOAP_TYPE_mime__mimeXml; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type mime__mimeXml, default initialized and not managed by a soap context
        virtual mime__mimeXml *soap_alloc(void) const { return SOAP_NEW(mime__mimeXml); }
      public:
        /// Constructor with initializations
        mime__mimeXml()
        {
          part = (char *)0;
        }
        virtual ~mime__mimeXml() { }
        /// Friend allocator used by soap_new_mime__mimeXml(struct soap*, int)
        friend SOAP_FMAC1 mime__mimeXml * SOAP_FMAC2 wsdl_instantiate_mime__mimeXml(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* dime.h:40 */
#ifndef SOAP_TYPE_dime__message
#define SOAP_TYPE_dime__message (272)
/* complex XSD type 'dime:message': */
class SOAP_CMAC dime__message {
      public:
        /// optional attribute 'layout' of XSD type 'xsd:anyURI'
        char *layout;
      public:
        /// Return unique type id SOAP_TYPE_dime__message
        virtual int soap_type(void) const { return SOAP_TYPE_dime__message; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type dime__message, default initialized and not managed by a soap context
        virtual dime__message *soap_alloc(void) const { return SOAP_NEW(dime__message); }
      public:
        /// Constructor with initializations
        dime__message()
        {
          layout = (char *)0;
        }
        virtual ~dime__message() { }
        /// Friend allocator used by soap_new_dime__message(struct soap*, int)
        friend SOAP_FMAC1 dime__message * SOAP_FMAC2 wsdl_instantiate_dime__message(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* http.h:46 */
#ifndef SOAP_TYPE_http__address
#define SOAP_TYPE_http__address (273)
/* complex XSD type 'http:address': */
class SOAP_CMAC http__address {
      public:
        /// optional attribute 'location' of XSD type 'xsd:anyURI'
        char *location;
      public:
        /// Return unique type id SOAP_TYPE_http__address
        virtual int soap_type(void) const { return SOAP_TYPE_http__address; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type http__address, default initialized and not managed by a soap context
        virtual http__address *soap_alloc(void) const { return SOAP_NEW(http__address); }
      public:
        /// Constructor with initializations
        http__address()
        {
          location = (char *)0;
        }
        virtual ~http__address() { }
        /// Friend allocator used by soap_new_http__address(struct soap*, int)
        friend SOAP_FMAC1 http__address * SOAP_FMAC2 wsdl_instantiate_http__address(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* http.h:51 */
#ifndef SOAP_TYPE_http__binding
#define SOAP_TYPE_http__binding (274)
/* complex XSD type 'http:binding': */
class SOAP_CMAC http__binding {
      public:
        /// optional attribute 'verb' of XSD type 'xsd:NMTOKEN'
        char *verb;
      public:
        /// Return unique type id SOAP_TYPE_http__binding
        virtual int soap_type(void) const { return SOAP_TYPE_http__binding; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type http__binding, default initialized and not managed by a soap context
        virtual http__binding *soap_alloc(void) const { return SOAP_NEW(http__binding); }
      public:
        /// Constructor with initializations
        http__binding()
        {
          verb = (char *)0;
        }
        virtual ~http__binding() { }
        /// Friend allocator used by soap_new_http__binding(struct soap*, int)
        friend SOAP_FMAC1 http__binding * SOAP_FMAC2 wsdl_instantiate_http__binding(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* http.h:56 */
#ifndef SOAP_TYPE_http__operation
#define SOAP_TYPE_http__operation (275)
/* complex XSD type 'http:operation': */
class SOAP_CMAC http__operation {
      public:
        /// optional attribute 'location' of XSD type 'xsd:anyURI'
        char *location;
      public:
        /// Return unique type id SOAP_TYPE_http__operation
        virtual int soap_type(void) const { return SOAP_TYPE_http__operation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type http__operation, default initialized and not managed by a soap context
        virtual http__operation *soap_alloc(void) const { return SOAP_NEW(http__operation); }
      public:
        /// Constructor with initializations
        http__operation()
        {
          location = (char *)0;
        }
        virtual ~http__operation() { }
        /// Friend allocator used by soap_new_http__operation(struct soap*, int)
        friend SOAP_FMAC1 http__operation * SOAP_FMAC2 wsdl_instantiate_http__operation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* http.h:61 */
#ifndef SOAP_TYPE_whttp__header
#define SOAP_TYPE_whttp__header (276)
/* complex XSD type 'whttp:header': */
class SOAP_CMAC whttp__header {
      public:
        /// optional attribute 'name' of XSD type 'xsd:string'
        char *name;
        /// optional attribute 'type' of XSD type 'xsd:QName'
        char *type;
        /// optional attribute 'required' of XSD type 'xsd:boolean'
        bool required;	///< default = (bool)0
      public:
        /// Return unique type id SOAP_TYPE_whttp__header
        virtual int soap_type(void) const { return SOAP_TYPE_whttp__header; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type whttp__header, default initialized and not managed by a soap context
        virtual whttp__header *soap_alloc(void) const { return SOAP_NEW(whttp__header); }
      public:
        /// Constructor with initializations
        whttp__header()
        {
          name = (char *)0;
          type = (char *)0;
          required = (bool)0;
        }
        virtual ~whttp__header() { }
        /// Friend allocator used by soap_new_whttp__header(struct soap*, int)
        friend SOAP_FMAC1 whttp__header * SOAP_FMAC2 wsdl_instantiate_whttp__header(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* gwsdl.h:45 */
#ifndef SOAP_TYPE_sd__serviceData
#define SOAP_TYPE_sd__serviceData (279)
/* complex XSD type 'sd:serviceData': */
class SOAP_CMAC sd__serviceData {
      public:
        /// optional attribute 'name' of XSD type 'xsd:NMTOKEN'
        char *name;
        /// optional attribute 'type' of XSD type 'xsd:QName'
        char *type;
        /// optional attribute 'nillable' of XSD type 'xsd:boolean'
        bool nillable;	///< default = (bool)0
        /// optional attribute 'minOccurs' of XSD type 'xsd:string'
        char *minOccurs;
        /// optional attribute 'maxOccurs' of XSD type 'xsd:string'
        char *maxOccurs;
        /// optional attribute 'mutability' of XSD type 'sd:mutability'
        enum sd__mutability mutability;	///< default = (enum sd__mutability)2
        /// optional attribute 'modifiable' of XSD type 'xsd:boolean'
        bool modifiable;	///< default = (bool)0
      public:
        /// Return unique type id SOAP_TYPE_sd__serviceData
        virtual int soap_type(void) const { return SOAP_TYPE_sd__serviceData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type sd__serviceData, default initialized and not managed by a soap context
        virtual sd__serviceData *soap_alloc(void) const { return SOAP_NEW(sd__serviceData); }
      public:
        /// Constructor with initializations
        sd__serviceData()
        {
          name = (char *)0;
          type = (char *)0;
          nillable = (bool)0;
          minOccurs = (char *)0;
          maxOccurs = (char *)0;
          mutability = (enum sd__mutability)2;
          modifiable = (bool)0;
        }
        virtual ~sd__serviceData() { }
        /// Friend allocator used by soap_new_sd__serviceData(struct soap*, int)
        friend SOAP_FMAC1 sd__serviceData * SOAP_FMAC2 wsdl_instantiate_sd__serviceData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* gwsdl.h:58 */
#ifndef SOAP_TYPE_sd__staticServiceDataValues
#define SOAP_TYPE_sd__staticServiceDataValues (280)
/* complex XSD type 'sd:staticServiceDataValues': */
class SOAP_CMAC sd__staticServiceDataValues {
      public:
        /// Any type of element 'any' assigned to _any with its SOAP_TYPE_T assigned to __type
        /// Do not create a cyclic data structure throught this member unless SOAP encoding or SOAP_XML_GRAPH are used for id-ref serialization
        int __type;
        void *_any;
      public:
        /// Return unique type id SOAP_TYPE_sd__staticServiceDataValues
        virtual int soap_type(void) const { return SOAP_TYPE_sd__staticServiceDataValues; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type sd__staticServiceDataValues, default initialized and not managed by a soap context
        virtual sd__staticServiceDataValues *soap_alloc(void) const { return SOAP_NEW(sd__staticServiceDataValues); }
      public:
        /// Constructor with initializations
        sd__staticServiceDataValues()
        {
          __type = 0;
          _any = NULL;
        }
        virtual ~sd__staticServiceDataValues() { }
        /// Friend allocator used by soap_new_sd__staticServiceDataValues(struct soap*, int)
        friend SOAP_FMAC1 sd__staticServiceDataValues * SOAP_FMAC2 wsdl_instantiate_sd__staticServiceDataValues(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* gwsdl.h:64 */
#ifndef SOAP_TYPE_gwsdl__portType
#define SOAP_TYPE_gwsdl__portType (282)
/* complex XSD type 'gwsdl:portType': */
class SOAP_CMAC gwsdl__portType {
      public:
        /// optional attribute 'name' of XSD type 'xsd:NMTOKEN'
        char *name;
        /// optional attribute 'extends' of XSD type 'xsd:QName'
        char *extends;
        /// Optional element 'documentation' of XSD type 'xsd:string'
        char *documentation;
        /// Optional element 'operation' of XSD type 'wsdl:operation'
        std::vector<wsdl__operation *> operation;
        /// Optional element 'sd:serviceData' of XSD type 'sd:serviceData'
        std::vector<sd__serviceData> sd__serviceData_;
        /// Optional element 'sd:staticServiceDataValues' of XSD type 'sd:staticServiceDataValues'
        sd__staticServiceDataValues *sd__staticServiceDataValues_;
      public:
        /// Return unique type id SOAP_TYPE_gwsdl__portType
        virtual int soap_type(void) const { return SOAP_TYPE_gwsdl__portType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gwsdl__portType, default initialized and not managed by a soap context
        virtual gwsdl__portType *soap_alloc(void) const { return SOAP_NEW(gwsdl__portType); }
      public:
        /// Constructor with initializations
        gwsdl__portType()
        {
          name = (char *)0;
          extends = (char *)0;
          documentation = (char *)0;
          sd__staticServiceDataValues_ = (sd__staticServiceDataValues *)0;
        }
        virtual ~gwsdl__portType() { }
        /// Friend allocator used by soap_new_gwsdl__portType(struct soap*, int)
        friend SOAP_FMAC1 gwsdl__portType * SOAP_FMAC2 wsdl_instantiate_gwsdl__portType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsam.h:49 */
#ifndef SOAP_TYPE_wsa__EndpointReferenceType
#define SOAP_TYPE_wsa__EndpointReferenceType (287)
/* complex XSD type 'wsa:EndpointReferenceType': */
class SOAP_CMAC wsa__EndpointReferenceType {
      public:
        /// Optional element 'wsa:Address' of XSD type 'xsd:anyURI'
        char *Address;
        char *__any;
      public:
        /// Return unique type id SOAP_TYPE_wsa__EndpointReferenceType
        virtual int soap_type(void) const { return SOAP_TYPE_wsa__EndpointReferenceType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsa__EndpointReferenceType, default initialized and not managed by a soap context
        virtual wsa__EndpointReferenceType *soap_alloc(void) const { return SOAP_NEW(wsa__EndpointReferenceType); }
      public:
        /// Constructor with initializations
        wsa__EndpointReferenceType()
        {
          Address = (char *)0;
          __any = (char *)0;
        }
        virtual ~wsa__EndpointReferenceType() { }
        /// Friend allocator used by soap_new_wsa__EndpointReferenceType(struct soap*, int)
        friend SOAP_FMAC1 wsa__EndpointReferenceType * SOAP_FMAC2 wsdl_instantiate_wsa__EndpointReferenceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsp.h:50 */
#ifndef SOAP_TYPE_wsp__PolicyReference
#define SOAP_TYPE_wsp__PolicyReference (292)
/* complex XSD type 'wsp:PolicyReference': */
class SOAP_CMAC wsp__PolicyReference {
      public:
        /// optional attribute 'URI' of XSD type 'xsd:anyURI'
        char *URI;
        /// optional attribute 'Digest' of XSD type 'xsd:string'
        char *Digest;
        /// optional attribute 'DigestAlgorithm' of XSD type 'xsd:anyURI'
        char *DigestAlgorithm;
      private:
        /// Not serialized
        wsp__Policy *policyRef;
      public:
        int traverse(wsdl__definitions &_param_1);
        void policyPtr(wsp__Policy *_param_1);
        wsp__Policy *policyPtr() const;
      public:
        /// Return unique type id SOAP_TYPE_wsp__PolicyReference
        virtual int soap_type(void) const { return SOAP_TYPE_wsp__PolicyReference; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsp__PolicyReference, default initialized and not managed by a soap context
        virtual wsp__PolicyReference *soap_alloc(void) const { return SOAP_NEW(wsp__PolicyReference); }
      public:
        /// Constructor with initializations
        wsp__PolicyReference()
        {
          URI = (char *)0;
          Digest = (char *)0;
          DigestAlgorithm = (char *)0;
          policyRef = (wsp__Policy *)0;
        }
        virtual ~wsp__PolicyReference() { }
        /// Friend allocator used by soap_new_wsp__PolicyReference(struct soap*, int)
        friend SOAP_FMAC1 wsp__PolicyReference * SOAP_FMAC2 wsdl_instantiate_wsp__PolicyReference(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsp.h:63 */
#ifndef SOAP_TYPE_wsp__Assertion
#define SOAP_TYPE_wsp__Assertion (298)
/* Type wsp__Assertion is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'wsp:Assertion': */
class SOAP_CMAC wsp__Assertion {
      public:
        /// optional attribute 'Optional' of XSD type 'xsd:boolean'
        bool Optional;	///< default = (bool)0
        /// optional attribute 'Ignorable' of XSD type 'xsd:boolean'
        bool Ignorable;	///< default = (bool)0
        /// Optional element 'wsp:Policy' of XSD type 'wsp:Content'
        wsp__Content *Policy;
      public:
        /// Return unique type id SOAP_TYPE_wsp__Assertion
        virtual int soap_type(void) const { return SOAP_TYPE_wsp__Assertion; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsp__Assertion, default initialized and not managed by a soap context
        virtual wsp__Assertion *soap_alloc(void) const { return SOAP_NEW(wsp__Assertion); }
      public:
        /// Constructor with initializations
        wsp__Assertion()
        {
          Optional = (bool)0;
          Ignorable = (bool)0;
          Policy = (wsp__Content *)0;
        }
        virtual ~wsp__Assertion() { }
        /// Friend allocator used by soap_new_wsp__Assertion(struct soap*, int)
        friend SOAP_FMAC1 wsp__Assertion * SOAP_FMAC2 wsdl_instantiate_wsp__Assertion(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wst.h:39 */
#ifndef SOAP_TYPE_wst__Claims
#define SOAP_TYPE_wst__Claims (300)
/* simple XSD type 'wst:Claims': */
class SOAP_CMAC wst__Claims {
      public:
        /// optional attribute 'Dialect' of XSD type 'xsd:string'
        char *Dialect;
        /// Simple content of XSD type 'xsd:string' wrapped by this struct
        char *__item;
      public:
        /// Return unique type id SOAP_TYPE_wst__Claims
        virtual int soap_type(void) const { return SOAP_TYPE_wst__Claims; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wst__Claims, default initialized and not managed by a soap context
        virtual wst__Claims *soap_alloc(void) const { return SOAP_NEW(wst__Claims); }
      public:
        /// Constructor with initializations
        wst__Claims()
        {
          Dialect = (char *)0;
          __item = (char *)0;
        }
        virtual ~wst__Claims() { }
        /// Friend allocator used by soap_new_wst__Claims(struct soap*, int)
        friend SOAP_FMAC1 wst__Claims * SOAP_FMAC2 wsdl_instantiate_wst__Claims(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sp.h:45 */
#ifndef SOAP_TYPE_sp__Header
#define SOAP_TYPE_sp__Header (301)
/* complex XSD type 'sp:Header': */
class SOAP_CMAC sp__Header {
      public:
        /// optional attribute 'Name' of XSD type 'xsd:NCName'
        char *Name;
        /// optional attribute 'Namespace' of XSD type 'xsd:anyURI'
        char *Namespace;
      public:
        /// Return unique type id SOAP_TYPE_sp__Header
        virtual int soap_type(void) const { return SOAP_TYPE_sp__Header; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type sp__Header, default initialized and not managed by a soap context
        virtual sp__Header *soap_alloc(void) const { return SOAP_NEW(sp__Header); }
      public:
        /// Constructor with initializations
        sp__Header()
        {
          Name = (char *)0;
          Namespace = (char *)0;
        }
        virtual ~sp__Header() { }
        /// Friend allocator used by soap_new_sp__Header(struct soap*, int)
        friend SOAP_FMAC1 sp__Header * SOAP_FMAC2 wsdl_instantiate_sp__Header(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sp.h:51 */
#ifndef SOAP_TYPE_sp__Parts
#define SOAP_TYPE_sp__Parts (302)
/* complex XSD type 'sp:Parts': */
class SOAP_CMAC sp__Parts {
      public:
        /// Optional element 'sp:Body' of XSD type 'xsd:string'
        char *Body;
        /// Optional element 'sp:Header' of XSD type 'sp:Header'
        std::vector<sp__Header> Header;
        /// Optional element 'sp:Attachments' of XSD type 'xsd:string'
        char *Attachments;
      public:
        /// Return unique type id SOAP_TYPE_sp__Parts
        virtual int soap_type(void) const { return SOAP_TYPE_sp__Parts; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type sp__Parts, default initialized and not managed by a soap context
        virtual sp__Parts *soap_alloc(void) const { return SOAP_NEW(sp__Parts); }
      public:
        /// Constructor with initializations
        sp__Parts()
        {
          Body = (char *)0;
          Attachments = (char *)0;
        }
        virtual ~sp__Parts() { }
        /// Friend allocator used by soap_new_sp__Parts(struct soap*, int)
        friend SOAP_FMAC1 sp__Parts * SOAP_FMAC2 wsdl_instantiate_sp__Parts(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sp.h:58 */
#ifndef SOAP_TYPE_sp__Elements
#define SOAP_TYPE_sp__Elements (304)
/* complex XSD type 'sp:Elements': */
class SOAP_CMAC sp__Elements {
      public:
        /// optional attribute 'XPathVersion' of XSD type 'xsd:anyURI'
        char *XPathVersion;
        /// Optional element 'sp:XPath' of XSD type 'xsd:string'
        std::vector<char *> XPath;
      public:
        /// Return unique type id SOAP_TYPE_sp__Elements
        virtual int soap_type(void) const { return SOAP_TYPE_sp__Elements; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type sp__Elements, default initialized and not managed by a soap context
        virtual sp__Elements *soap_alloc(void) const { return SOAP_NEW(sp__Elements); }
      public:
        /// Constructor with initializations
        sp__Elements()
        {
          XPathVersion = (char *)0;
        }
        virtual ~sp__Elements() { }
        /// Friend allocator used by soap_new_sp__Elements(struct soap*, int)
        friend SOAP_FMAC1 sp__Elements * SOAP_FMAC2 wsdl_instantiate_sp__Elements(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sp.h:64 */
#ifndef SOAP_TYPE_sp__Token
#define SOAP_TYPE_sp__Token (306)
/* Type sp__Token is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'sp:Token': */
class SOAP_CMAC sp__Token : public wsp__Assertion {
      public:
        /// optional attribute 'IncludeToken' of XSD type 'xsd:anyURI'
        char *IncludeToken;
        /// Optional element 'sp:Issuer' of XSD type 'wsa:EndpointReferenceType'
        wsa__EndpointReferenceType *Issuer;
        /// Optional element 'sp:IssuerName' of XSD type 'xsd:anyURI'
        char *IssuerName;
        /// Optional element 'wst:Claims' of XSD type 'wst:Claims'
        wst__Claims *wst__Claims_;
      public:
        /// Return unique type id SOAP_TYPE_sp__Token
        virtual int soap_type(void) const { return SOAP_TYPE_sp__Token; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type sp__Token, default initialized and not managed by a soap context
        virtual sp__Token *soap_alloc(void) const { return SOAP_NEW(sp__Token); }
      public:
        /// Constructor with initializations
        sp__Token()
        {
          IncludeToken = (char *)0;
          Issuer = (wsa__EndpointReferenceType *)0;
          IssuerName = (char *)0;
          wst__Claims_ = (wst__Claims *)0;
        }
        virtual ~sp__Token() { }
        /// Friend allocator used by soap_new_sp__Token(struct soap*, int)
        friend SOAP_FMAC1 sp__Token * SOAP_FMAC2 wsdl_instantiate_sp__Token(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsrmp.h:47 */
#ifndef SOAP_TYPE_wsrmp__Timeout
#define SOAP_TYPE_wsrmp__Timeout (309)
/* complex XSD type 'wsrmp:Timeout': */
class SOAP_CMAC wsrmp__Timeout {
      public:
        /// optional attribute 'Milliseconds' of XSD type 'xsd:string'
        char *Milliseconds;
      public:
        /// Return unique type id SOAP_TYPE_wsrmp__Timeout
        virtual int soap_type(void) const { return SOAP_TYPE_wsrmp__Timeout; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsrmp__Timeout, default initialized and not managed by a soap context
        virtual wsrmp__Timeout *soap_alloc(void) const { return SOAP_NEW(wsrmp__Timeout); }
      public:
        /// Constructor with initializations
        wsrmp__Timeout()
        {
          Milliseconds = (char *)0;
        }
        virtual ~wsrmp__Timeout() { }
        /// Friend allocator used by soap_new_wsrmp__Timeout(struct soap*, int)
        friend SOAP_FMAC1 wsrmp__Timeout * SOAP_FMAC2 wsdl_instantiate_wsrmp__Timeout(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsrmp.h:52 */
#ifndef SOAP_TYPE_wsrmp__RMAssertion
#define SOAP_TYPE_wsrmp__RMAssertion (310)
/* Type wsrmp__RMAssertion is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'wsrmp:RMAssertion': */
class SOAP_CMAC wsrmp__RMAssertion : public wsp__Assertion {
      public:
        /// Optional element 'wsrmp:InactivityTimeout' of XSD type 'wsrmp:Timeout'
        wsrmp__Timeout *InactivityTimeout;
        /// Optional element 'wsrmp:BaseRetransmissionInterval' of XSD type 'wsrmp:Timeout'
        wsrmp__Timeout *BaseRetransmissionInterval;
        /// Optional element 'wsrmp:AcknowledgementInterval' of XSD type 'wsrmp:Timeout'
        wsrmp__Timeout *AcknowledgementInterval;
        /// Optional element 'wsrmp:ExponentialBackoff' of XSD type 'xsd:string'
        char *ExponentialBackoff;
      public:
        /// Return unique type id SOAP_TYPE_wsrmp__RMAssertion
        virtual int soap_type(void) const { return SOAP_TYPE_wsrmp__RMAssertion; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsrmp__RMAssertion, default initialized and not managed by a soap context
        virtual wsrmp__RMAssertion *soap_alloc(void) const { return SOAP_NEW(wsrmp__RMAssertion); }
      public:
        /// Constructor with initializations
        wsrmp__RMAssertion()
        {
          InactivityTimeout = (wsrmp__Timeout *)0;
          BaseRetransmissionInterval = (wsrmp__Timeout *)0;
          AcknowledgementInterval = (wsrmp__Timeout *)0;
          ExponentialBackoff = (char *)0;
        }
        virtual ~wsrmp__RMAssertion() { }
        /// Friend allocator used by soap_new_wsrmp__RMAssertion(struct soap*, int)
        friend SOAP_FMAC1 wsrmp__RMAssertion * SOAP_FMAC2 wsdl_instantiate_wsrmp__RMAssertion(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsrmp.h:61 */
#ifndef SOAP_TYPE_wsrmp5__Timeout
#define SOAP_TYPE_wsrmp5__Timeout (312)
/* complex XSD type 'wsrmp5:Timeout': */
class SOAP_CMAC wsrmp5__Timeout {
      public:
        /// optional attribute 'Milliseconds' of XSD type 'xsd:string'
        char *Milliseconds;
      public:
        /// Return unique type id SOAP_TYPE_wsrmp5__Timeout
        virtual int soap_type(void) const { return SOAP_TYPE_wsrmp5__Timeout; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsrmp5__Timeout, default initialized and not managed by a soap context
        virtual wsrmp5__Timeout *soap_alloc(void) const { return SOAP_NEW(wsrmp5__Timeout); }
      public:
        /// Constructor with initializations
        wsrmp5__Timeout()
        {
          Milliseconds = (char *)0;
        }
        virtual ~wsrmp5__Timeout() { }
        /// Friend allocator used by soap_new_wsrmp5__Timeout(struct soap*, int)
        friend SOAP_FMAC1 wsrmp5__Timeout * SOAP_FMAC2 wsdl_instantiate_wsrmp5__Timeout(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsrmp.h:66 */
#ifndef SOAP_TYPE_wsrmp5__RMAssertion
#define SOAP_TYPE_wsrmp5__RMAssertion (313)
/* Type wsrmp5__RMAssertion is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'wsrmp5:RMAssertion': */
class SOAP_CMAC wsrmp5__RMAssertion : public wsp__Assertion {
      public:
        /// Optional element 'wsrmp5:InactivityTimeout' of XSD type 'wsrmp5:Timeout'
        wsrmp5__Timeout *InactivityTimeout;
        /// Optional element 'wsrmp5:BaseRetransmissionInterval' of XSD type 'wsrmp5:Timeout'
        wsrmp5__Timeout *BaseRetransmissionInterval;
        /// Optional element 'wsrmp5:AcknowledgementInterval' of XSD type 'wsrmp5:Timeout'
        wsrmp5__Timeout *AcknowledgementInterval;
        /// Optional element 'wsrmp5:ExponentialBackoff' of XSD type 'xsd:string'
        char *ExponentialBackoff;
      public:
        /// Return unique type id SOAP_TYPE_wsrmp5__RMAssertion
        virtual int soap_type(void) const { return SOAP_TYPE_wsrmp5__RMAssertion; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsrmp5__RMAssertion, default initialized and not managed by a soap context
        virtual wsrmp5__RMAssertion *soap_alloc(void) const { return SOAP_NEW(wsrmp5__RMAssertion); }
      public:
        /// Constructor with initializations
        wsrmp5__RMAssertion()
        {
          InactivityTimeout = (wsrmp5__Timeout *)0;
          BaseRetransmissionInterval = (wsrmp5__Timeout *)0;
          AcknowledgementInterval = (wsrmp5__Timeout *)0;
          ExponentialBackoff = (char *)0;
        }
        virtual ~wsrmp5__RMAssertion() { }
        /// Friend allocator used by soap_new_wsrmp5__RMAssertion(struct soap*, int)
        friend SOAP_FMAC1 wsrmp5__RMAssertion * SOAP_FMAC2 wsdl_instantiate_wsrmp5__RMAssertion(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsp.h:45 */
#ifndef SOAP_TYPE_wsp__Content
#define SOAP_TYPE_wsp__Content (289)
/* Type wsp__Content is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'wsp:Content': */
class SOAP_CMAC wsp__Content {
      public:
        /// Optional element 'wsp:Policy' of XSD type 'wsp:Policy'
        wsp__Policy *Policy;
        /// Optional element 'wsp:PolicyReference' of XSD type 'wsp:PolicyReference'
        wsp__PolicyReference *PolicyReference;
        /// Optional element 'wsp:All' of XSD type 'wsp:Content'
        std::vector<wsp__Content *> All;
        /// Optional element 'wsp:ExactlyOne' of XSD type 'wsp:Content'
        std::vector<wsp__Content *> ExactlyOne;
        /// Optional element 'sp:SignedParts' of XSD type 'sp:Parts'
        std::vector<sp__Parts> sp__SignedParts;
        /// Optional element 'sp:EncryptedParts' of XSD type 'sp:Parts'
        std::vector<sp__Parts> sp__EncryptedParts;
        /// Optional element 'sp:RequiredParts' of XSD type 'sp:Parts'
        std::vector<sp__Parts> sp__RequiredParts;
        /// Optional element 'sp:SignedElements' of XSD type 'sp:Elements'
        sp__Elements *sp__SignedElements;
        /// Optional element 'sp:EncryptedElements' of XSD type 'sp:Elements'
        sp__Elements *sp__EncryptedElements;
        /// Optional element 'sp:ContentEncryptedElements' of XSD type 'sp:Elements'
        sp__Elements *sp__ContentEncryptedElements;
        /// Optional element 'sp:RequiredElements' of XSD type 'sp:Elements'
        sp__Elements *sp__RequiredElements;
        /// Optional element 'sp:UsernameToken' of XSD type 'sp:Token'
        sp__Token *sp__UsernameToken;
        /// Optional element 'sp:IssuedToken' of XSD type 'sp:Token'
        sp__Token *sp__IssuedToken;
        /// Optional element 'sp:X509Token' of XSD type 'sp:Token'
        sp__Token *sp__X509Token;
        /// Optional element 'sp:KerberosToken' of XSD type 'sp:Token'
        sp__Token *sp__KerberosToken;
        /// Optional element 'sp:SpnegoContextToken' of XSD type 'sp:Token'
        sp__Token *sp__SpnegoContextToken;
        /// Optional element 'sp:SecurityContextToken' of XSD type 'sp:Token'
        sp__Token *sp__SecurityContextToken;
        /// Optional element 'sp:SecureConversationToken' of XSD type 'sp:Token'
        sp__Token *sp__SecureConversationToken;
        /// Optional element 'sp:SamlToken' of XSD type 'sp:Token'
        sp__Token *sp__SamlToken;
        /// Optional element 'sp:RelToken' of XSD type 'sp:Token'
        sp__Token *sp__RelToken;
        /// Optional element 'sp:HttpsToken' of XSD type 'sp:Token'
        sp__Token *sp__HttpsToken;
        /// Optional element 'sp:KeyValueToken' of XSD type 'sp:Token'
        sp__Token *sp__KeyValueToken;
        /// Optional element 'sp:TransportBinding' of XSD type 'wsp:Assertion'
        wsp__Assertion *sp__TransportBinding;
        /// Optional element 'sp:TransportToken' of XSD type 'wsp:Assertion'
        wsp__Assertion *sp__TransportToken;
        /// Optional element 'sp:AlgorithmSuite' of XSD type 'wsp:Assertion'
        wsp__Assertion *sp__AlgorithmSuite;
        /// Optional element 'sp:Layout' of XSD type 'wsp:Assertion'
        wsp__Assertion *sp__Layout;
        /// Optional element 'sp:SymmetricBinding' of XSD type 'wsp:Assertion'
        wsp__Assertion *sp__SymmetricBinding;
        /// Optional element 'sp:AsymmetricBinding' of XSD type 'wsp:Assertion'
        wsp__Assertion *sp__AsymmetricBinding;
        /// Optional element 'sp:ProtectionToken' of XSD type 'wsp:Assertion'
        wsp__Assertion *sp__ProtectionToken;
        /// Optional element 'sp:InitiatorToken' of XSD type 'wsp:Assertion'
        wsp__Assertion *sp__InitiatorToken;
        /// Optional element 'sp:InitiatorSignatureToken' of XSD type 'wsp:Assertion'
        wsp__Assertion *sp__InitiatorSignatureToken;
        /// Optional element 'sp:InitiatorEncryptionToken' of XSD type 'wsp:Assertion'
        wsp__Assertion *sp__InitiatorEncryptionToken;
        /// Optional element 'sp:RecipientToken' of XSD type 'wsp:Assertion'
        wsp__Assertion *sp__RecipientToken;
        /// Optional element 'sp:SupportingTokens' of XSD type 'wsp:Assertion'
        wsp__Assertion *sp__SupportingTokens;
        /// Optional element 'sp:SignedSupportingTokens' of XSD type 'wsp:Assertion'
        wsp__Assertion *sp__SignedSupportingTokens;
        /// Optional element 'sp:EndorsingSupportingTokens' of XSD type 'wsp:Assertion'
        wsp__Assertion *sp__EndorsingSupportingTokens;
        /// Optional element 'sp:SignedEndorsingSupportingTokens' of XSD type 'wsp:Assertion'
        wsp__Assertion *sp__SignedEndorsingSupportingTokens;
        /// Optional element 'sp:SignedEncryptedSupportingTokens' of XSD type 'wsp:Assertion'
        wsp__Assertion *sp__SignedEncryptedSupportingTokens;
        /// Optional element 'sp:EncryptedSupportingTokens' of XSD type 'wsp:Assertion'
        wsp__Assertion *sp__EncryptedSupportingTokens;
        /// Optional element 'sp:EndorsingEncryptedSupportingTokens' of XSD type 'wsp:Assertion'
        wsp__Assertion *sp__EndorsingEncryptedSupportingTokens;
        /// Optional element 'sp:SignedEndorsingEncryptedSupportingTokens' of XSD type 'wsp:Assertion'
        wsp__Assertion *sp__SignedEndorsingEncryptedSupportingTokens;
        /// Optional element 'sp:Wss10' of XSD type 'wsp:Assertion'
        wsp__Assertion *sp__Wss10;
        /// Optional element 'sp:Wss11' of XSD type 'wsp:Assertion'
        wsp__Assertion *sp__Wss11;
        /// Optional element 'sp:Trust10' of XSD type 'wsp:Assertion'
        wsp__Assertion *sp__Trust10;
        /// Optional element 'sp:Trust13' of XSD type 'wsp:Assertion'
        wsp__Assertion *sp__Trust13;
        /// Optional element 'sp:BootstrapPolicy' of XSD type 'wsp:Content'
        wsp__Content *sp__BootstrapPolicy;
        /// Optional element 'wsaw:UsingAddressing' of XSD type 'xsd:string'
        char *wsaw__UsingAddressing;
        /// Optional element 'wsam:Addressing' of XSD type 'wsp:Assertion'
        wsp__Assertion *wsam__Addressing;
        /// Optional element 'wsrmp:RMAssertion' of XSD type 'wsrmp:RMAssertion'
        wsrmp__RMAssertion *wsrmp__RMAssertion_;
        /// Optional element 'wsrmp:DeliveryAssurance' of XSD type 'wsrmp:RMAssertion'
        wsrmp__RMAssertion *wsrmp__DeliveryAssurance;
        /// Optional element 'wsrmp:AtLeastOnce' of XSD type 'xsd:string'
        char *wsrmp__AtLeastOnce;
        /// Optional element 'wsrmp:AtMostOnce' of XSD type 'xsd:string'
        char *wsrmp__AtMostOnce;
        /// Optional element 'wsrmp:ExactlyOnce' of XSD type 'xsd:string'
        char *wsrmp__ExactlyOnce;
        /// Optional element 'wsrmp:InOrder' of XSD type 'xsd:string'
        char *wsrmp__InOrder;
        /// Optional element 'wsrmp5:RMAssertion' of XSD type 'wsrmp5:RMAssertion'
        wsrmp5__RMAssertion *wsrmp5__RMAssertion_;
        /// Optional element 'wsrmp5:DeliveryAssurance' of XSD type 'wsrmp5:RMAssertion'
        wsrmp5__RMAssertion *wsrmp5__DeliveryAssurance;
        /// Optional element 'wsrmp5:AtLeastOnce' of XSD type 'xsd:string'
        char *wsrmp5__AtLeastOnce;
        /// Optional element 'wsrmp5:AtMostOnce' of XSD type 'xsd:string'
        char *wsrmp5__AtMostOnce;
        /// Optional element 'wsrmp5:ExactlyOnce' of XSD type 'xsd:string'
        char *wsrmp5__ExactlyOnce;
        /// Optional element 'wsrmp5:InOrder' of XSD type 'xsd:string'
        char *wsrmp5__InOrder;
        /// Optional element 'sp:NoPassword' of XSD type 'wsp:Assertion'
        wsp__Assertion *sp__NoPassword;
        /// Optional element 'sp:HashPassword' of XSD type 'wsp:Assertion'
        wsp__Assertion *sp__HashPassword;
        /// Optional element 'sp:IncludeTimestamp' of XSD type 'wsp:Assertion'
        wsp__Assertion *sp__IncludeTimestamp;
        /// Optional element 'sp:EncryptBeforeSigning' of XSD type 'wsp:Assertion'
        wsp__Assertion *sp__EncryptBeforeSigning;
        /// Optional element 'sp:EncryptSignature' of XSD type 'wsp:Assertion'
        wsp__Assertion *sp__EncryptSignature;
        /// Optional element 'sp:ProtectTokens' of XSD type 'wsp:Assertion'
        wsp__Assertion *sp__ProtectTokens;
        /// Optional element 'sp:OnlySignEntireHeadersAndBody' of XSD type 'wsp:Assertion'
        wsp__Assertion *sp__OnlySignEntireHeadersAndBody;
        /// Optional element 'sp:RequireDerivedKeys' of XSD type 'xsd:string'
        char *sp__RequireDerivedKeys;
        /// Optional element 'sp:RequireImpliedDerivedKeys' of XSD type 'xsd:string'
        char *sp__RequireImpliedDerivedKeys;
        /// Optional element 'sp:RequireExplicitDerivedKeys' of XSD type 'xsd:string'
        char *sp__RequireExplicitDerivedKeys;
        /// Optional element 'sp:WssUsernameToken10' of XSD type 'xsd:string'
        char *sp__WssUsernameToken10;
        /// Optional element 'sp:WssUsernameToken11' of XSD type 'xsd:string'
        char *sp__WssUsernameToken11;
        /// Optional element 'sp:RequireExternalReference' of XSD type 'xsd:string'
        char *sp__RequireExternalReference;
        /// Optional element 'sp:RequireInternalReference' of XSD type 'xsd:string'
        char *sp__RequireInternalReference;
        /// Optional element 'sp:RequireKeyIdentifierReference' of XSD type 'xsd:string'
        char *sp__RequireKeyIdentifierReference;
        /// Optional element 'sp:RequireIssuerSerialReference' of XSD type 'xsd:string'
        char *sp__RequireIssuerSerialReference;
        /// Optional element 'sp:RequireEmbeddedTokenReference' of XSD type 'xsd:string'
        char *sp__RequireEmbeddedTokenReference;
        /// Optional element 'sp:RequireThumbprintReference' of XSD type 'xsd:string'
        char *sp__RequireThumbprintReference;
        /// Optional element 'sp:WssX509V3Token10' of XSD type 'xsd:string'
        char *sp__WssX509V3Token10;
        /// Optional element 'sp:WssX509Pkcs7Token10' of XSD type 'xsd:string'
        char *sp__WssX509Pkcs7Token10;
        /// Optional element 'sp:WssX509PkiPathV1Token10' of XSD type 'xsd:string'
        char *sp__WssX509PkiPathV1Token10;
        /// Optional element 'sp:WssX509V1Token11' of XSD type 'xsd:string'
        char *sp__WssX509V1Token11;
        /// Optional element 'sp:WssX509V3Token11' of XSD type 'xsd:string'
        char *sp__WssX509V3Token11;
        /// Optional element 'sp:WssX509Pkcs7Token11' of XSD type 'xsd:string'
        char *sp__WssX509Pkcs7Token11;
        /// Optional element 'sp:WssX509PkiPathV1Token11' of XSD type 'xsd:string'
        char *sp__WssX509PkiPathV1Token11;
        /// Optional element 'sp:WssKerberosV5ApReqToken11' of XSD type 'xsd:string'
        char *sp__WssKerberosV5ApReqToken11;
        /// Optional element 'sp:WssGssKerberosV5ApReqToken11' of XSD type 'xsd:string'
        char *sp__WssGssKerberosV5ApReqToken11;
        /// Optional element 'sp:WssRelV10Token10' of XSD type 'xsd:string'
        char *sp__WssRelV10Token10;
        /// Optional element 'sp:WssRelV20Token10' of XSD type 'xsd:string'
        char *sp__WssRelV20Token10;
        /// Optional element 'sp:WssRelV10Token11' of XSD type 'xsd:string'
        char *sp__WssRelV10Token11;
        /// Optional element 'sp:WssRelV20Token11' of XSD type 'xsd:string'
        char *sp__WssRelV20Token11;
        /// Optional element 'sp:MustNotSendCancel' of XSD type 'xsd:string'
        char *sp__MustNotSendCancel;
        /// Optional element 'sp:MustNotSendAmend' of XSD type 'xsd:string'
        char *sp__MustNotSendAmend;
        /// Optional element 'sp:MustNotSendRenew' of XSD type 'xsd:string'
        char *sp__MustNotSendRenew;
        /// Optional element 'sp:MustSupportRefKeyIdentifier' of XSD type 'xsd:string'
        char *sp__MustSupportRefKeyIdentifier;
        /// Optional element 'sp:MustSupportRefIssuerSerial' of XSD type 'xsd:string'
        char *sp__MustSupportRefIssuerSerial;
        /// Optional element 'sp:MustSupportRefExternalURI' of XSD type 'xsd:string'
        char *sp__MustSupportRefExternalURI;
        /// Optional element 'sp:MustSupportRefEmbeddedToken' of XSD type 'xsd:string'
        char *sp__MustSupportRefEmbeddedToken;
        /// Optional element 'sp:MustSupportRefThumbprint' of XSD type 'xsd:string'
        char *sp__MustSupportRefThumbprint;
        /// Optional element 'sp:MustSupportRefEncryptedKey' of XSD type 'xsd:string'
        char *sp__MustSupportRefEncryptedKey;
        /// Optional element 'sp:RequireSignatureConfirmation' of XSD type 'xsd:string'
        char *sp__RequireSignatureConfirmation;
        /// Optional element 'sp:MustSupportClientChallenge' of XSD type 'xsd:string'
        char *sp__MustSupportClientChallenge;
        /// Optional element 'sp:MustSupportServerChallenge' of XSD type 'xsd:string'
        char *sp__MustSupportServerChallenge;
        /// Optional element 'sp:RequireClientEntropy' of XSD type 'xsd:string'
        char *sp__RequireClientEntropy;
        /// Optional element 'sp:RequireServerEntropy' of XSD type 'xsd:string'
        char *sp__RequireServerEntropy;
        /// Optional element 'sp:MustSupportIssuedTokens' of XSD type 'xsd:string'
        char *sp__MustSupportIssuedTokens;
        /// Optional element 'sp:RequireRequestSecurityTokenCollection' of XSD type 'xsd:string'
        char *sp__RequireRequestSecurityTokenCollection;
        /// Optional element 'sp:RequireAppliesTo' of XSD type 'xsd:string'
        char *sp__RequireAppliesTo;
        /// Optional element 'sp:RequireExternalUriReference' of XSD type 'xsd:string'
        char *sp__RequireExternalUriReference;
        /// Optional element 'sp:SC13SecurityContextToken' of XSD type 'xsd:string'
        char *sp__SC13SecurityContextToken;
        /// Optional element 'sp:Strict' of XSD type 'xsd:string'
        char *sp__Strict;
        /// Optional element 'sp:Lax' of XSD type 'xsd:string'
        char *sp__Lax;
        /// Optional element 'sp:LaxTsFirst' of XSD type 'xsd:string'
        char *sp__LaxTsFirst;
        /// Optional element 'sp:LaxTsLast' of XSD type 'xsd:string'
        char *sp__LaxTsLast;
        /// Optional element 'sp:HttpBasicAuthentication' of XSD type 'xsd:string'
        char *sp__HttpBasicAuthentication;
        /// Optional element 'sp:HttpDigestAuthentication' of XSD type 'xsd:string'
        char *sp__HttpDigestAuthentication;
        /// Optional element 'sp:RequireClientCertificate' of XSD type 'xsd:string'
        char *sp__RequireClientCertificate;
        /// Optional element 'sp:Basic256' of XSD type 'xsd:string'
        char *sp__Basic256;
        /// Optional element 'sp:Basic192' of XSD type 'xsd:string'
        char *sp__Basic192;
        /// Optional element 'sp:Basic128' of XSD type 'xsd:string'
        char *sp__Basic128;
        /// Optional element 'sp:TripleDes' of XSD type 'xsd:string'
        char *sp__TripleDes;
        /// Optional element 'sp:Basic256Rsa15' of XSD type 'xsd:string'
        char *sp__Basic256Rsa15;
        /// Optional element 'sp:Basic192Rsa15' of XSD type 'xsd:string'
        char *sp__Basic192Rsa15;
        /// Optional element 'sp:Basic128Rsa15' of XSD type 'xsd:string'
        char *sp__Basic128Rsa15;
        /// Optional element 'sp:TripleDesRsa15' of XSD type 'xsd:string'
        char *sp__TripleDesRsa15;
        /// Optional element 'sp:Basic256Sha256' of XSD type 'xsd:string'
        char *sp__Basic256Sha256;
        /// Optional element 'sp:Basic192Sha256' of XSD type 'xsd:string'
        char *sp__Basic192Sha256;
        /// Optional element 'sp:Basic128Sha256' of XSD type 'xsd:string'
        char *sp__Basic128Sha256;
        /// Optional element 'sp:TripleDesSha256' of XSD type 'xsd:string'
        char *sp__TripleDesSha256;
        /// Optional element 'sp:Basic256Sha256Rsa15' of XSD type 'xsd:string'
        char *sp__Basic256Sha256Rsa15;
        /// Optional element 'sp:Basic192Sha256Rsa15' of XSD type 'xsd:string'
        char *sp__Basic192Sha256Rsa15;
        /// Optional element 'sp:Basic128Sha256Rsa15' of XSD type 'xsd:string'
        char *sp__Basic128Sha256Rsa15;
        /// Optional element 'sp:TripleDesSha256Rsa15' of XSD type 'xsd:string'
        char *sp__TripleDesSha256Rsa15;
        /// Optional element 'sp:InclusiveC14N' of XSD type 'xsd:string'
        char *sp__InclusiveC14N;
        /// Optional element 'sp:SOAPNormalization10' of XSD type 'xsd:string'
        char *sp__SOAPNormalization10;
        /// Optional element 'sp:STRTransform10' of XSD type 'xsd:string'
        char *sp__STRTransform10;
        /// Optional element 'sp:Path10' of XSD type 'xsd:string'
        char *sp__Path10;
        /// Optional element 'sp:XPathFilter20' of XSD type 'xsd:string'
        char *sp__XPathFilter20;
        /// Optional element 'sp:AbsXPath' of XSD type 'xsd:string'
        char *sp__AbsXPath;
        /// Optional element 'wsam:AnonymousResponses' of XSD type 'xsd:string'
        char *wsam__AnonymousResponses;
        /// Optional element 'wsam:NonAnonymousResponses' of XSD type 'xsd:string'
        char *wsam__NonAnonymousResponses;
        std::vector<char *> __any;
        int traverse(wsdl__definitions &_param_1);
        void generate(Service &service, Types &types, int indent) const;
      public:
        /// Return unique type id SOAP_TYPE_wsp__Content
        virtual int soap_type(void) const { return SOAP_TYPE_wsp__Content; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsp__Content, default initialized and not managed by a soap context
        virtual wsp__Content *soap_alloc(void) const { return SOAP_NEW(wsp__Content); }
      public:
        /// Constructor with initializations
        wsp__Content()
        {
          Policy = (wsp__Policy *)0;
          PolicyReference = (wsp__PolicyReference *)0;
          sp__SignedElements = (sp__Elements *)0;
          sp__EncryptedElements = (sp__Elements *)0;
          sp__ContentEncryptedElements = (sp__Elements *)0;
          sp__RequiredElements = (sp__Elements *)0;
          sp__UsernameToken = (sp__Token *)0;
          sp__IssuedToken = (sp__Token *)0;
          sp__X509Token = (sp__Token *)0;
          sp__KerberosToken = (sp__Token *)0;
          sp__SpnegoContextToken = (sp__Token *)0;
          sp__SecurityContextToken = (sp__Token *)0;
          sp__SecureConversationToken = (sp__Token *)0;
          sp__SamlToken = (sp__Token *)0;
          sp__RelToken = (sp__Token *)0;
          sp__HttpsToken = (sp__Token *)0;
          sp__KeyValueToken = (sp__Token *)0;
          sp__TransportBinding = (wsp__Assertion *)0;
          sp__TransportToken = (wsp__Assertion *)0;
          sp__AlgorithmSuite = (wsp__Assertion *)0;
          sp__Layout = (wsp__Assertion *)0;
          sp__SymmetricBinding = (wsp__Assertion *)0;
          sp__AsymmetricBinding = (wsp__Assertion *)0;
          sp__ProtectionToken = (wsp__Assertion *)0;
          sp__InitiatorToken = (wsp__Assertion *)0;
          sp__InitiatorSignatureToken = (wsp__Assertion *)0;
          sp__InitiatorEncryptionToken = (wsp__Assertion *)0;
          sp__RecipientToken = (wsp__Assertion *)0;
          sp__SupportingTokens = (wsp__Assertion *)0;
          sp__SignedSupportingTokens = (wsp__Assertion *)0;
          sp__EndorsingSupportingTokens = (wsp__Assertion *)0;
          sp__SignedEndorsingSupportingTokens = (wsp__Assertion *)0;
          sp__SignedEncryptedSupportingTokens = (wsp__Assertion *)0;
          sp__EncryptedSupportingTokens = (wsp__Assertion *)0;
          sp__EndorsingEncryptedSupportingTokens = (wsp__Assertion *)0;
          sp__SignedEndorsingEncryptedSupportingTokens = (wsp__Assertion *)0;
          sp__Wss10 = (wsp__Assertion *)0;
          sp__Wss11 = (wsp__Assertion *)0;
          sp__Trust10 = (wsp__Assertion *)0;
          sp__Trust13 = (wsp__Assertion *)0;
          sp__BootstrapPolicy = (wsp__Content *)0;
          wsaw__UsingAddressing = (char *)0;
          wsam__Addressing = (wsp__Assertion *)0;
          wsrmp__RMAssertion_ = (wsrmp__RMAssertion *)0;
          wsrmp__DeliveryAssurance = (wsrmp__RMAssertion *)0;
          wsrmp__AtLeastOnce = (char *)0;
          wsrmp__AtMostOnce = (char *)0;
          wsrmp__ExactlyOnce = (char *)0;
          wsrmp__InOrder = (char *)0;
          wsrmp5__RMAssertion_ = (wsrmp5__RMAssertion *)0;
          wsrmp5__DeliveryAssurance = (wsrmp5__RMAssertion *)0;
          wsrmp5__AtLeastOnce = (char *)0;
          wsrmp5__AtMostOnce = (char *)0;
          wsrmp5__ExactlyOnce = (char *)0;
          wsrmp5__InOrder = (char *)0;
          sp__NoPassword = (wsp__Assertion *)0;
          sp__HashPassword = (wsp__Assertion *)0;
          sp__IncludeTimestamp = (wsp__Assertion *)0;
          sp__EncryptBeforeSigning = (wsp__Assertion *)0;
          sp__EncryptSignature = (wsp__Assertion *)0;
          sp__ProtectTokens = (wsp__Assertion *)0;
          sp__OnlySignEntireHeadersAndBody = (wsp__Assertion *)0;
          sp__RequireDerivedKeys = (char *)0;
          sp__RequireImpliedDerivedKeys = (char *)0;
          sp__RequireExplicitDerivedKeys = (char *)0;
          sp__WssUsernameToken10 = (char *)0;
          sp__WssUsernameToken11 = (char *)0;
          sp__RequireExternalReference = (char *)0;
          sp__RequireInternalReference = (char *)0;
          sp__RequireKeyIdentifierReference = (char *)0;
          sp__RequireIssuerSerialReference = (char *)0;
          sp__RequireEmbeddedTokenReference = (char *)0;
          sp__RequireThumbprintReference = (char *)0;
          sp__WssX509V3Token10 = (char *)0;
          sp__WssX509Pkcs7Token10 = (char *)0;
          sp__WssX509PkiPathV1Token10 = (char *)0;
          sp__WssX509V1Token11 = (char *)0;
          sp__WssX509V3Token11 = (char *)0;
          sp__WssX509Pkcs7Token11 = (char *)0;
          sp__WssX509PkiPathV1Token11 = (char *)0;
          sp__WssKerberosV5ApReqToken11 = (char *)0;
          sp__WssGssKerberosV5ApReqToken11 = (char *)0;
          sp__WssRelV10Token10 = (char *)0;
          sp__WssRelV20Token10 = (char *)0;
          sp__WssRelV10Token11 = (char *)0;
          sp__WssRelV20Token11 = (char *)0;
          sp__MustNotSendCancel = (char *)0;
          sp__MustNotSendAmend = (char *)0;
          sp__MustNotSendRenew = (char *)0;
          sp__MustSupportRefKeyIdentifier = (char *)0;
          sp__MustSupportRefIssuerSerial = (char *)0;
          sp__MustSupportRefExternalURI = (char *)0;
          sp__MustSupportRefEmbeddedToken = (char *)0;
          sp__MustSupportRefThumbprint = (char *)0;
          sp__MustSupportRefEncryptedKey = (char *)0;
          sp__RequireSignatureConfirmation = (char *)0;
          sp__MustSupportClientChallenge = (char *)0;
          sp__MustSupportServerChallenge = (char *)0;
          sp__RequireClientEntropy = (char *)0;
          sp__RequireServerEntropy = (char *)0;
          sp__MustSupportIssuedTokens = (char *)0;
          sp__RequireRequestSecurityTokenCollection = (char *)0;
          sp__RequireAppliesTo = (char *)0;
          sp__RequireExternalUriReference = (char *)0;
          sp__SC13SecurityContextToken = (char *)0;
          sp__Strict = (char *)0;
          sp__Lax = (char *)0;
          sp__LaxTsFirst = (char *)0;
          sp__LaxTsLast = (char *)0;
          sp__HttpBasicAuthentication = (char *)0;
          sp__HttpDigestAuthentication = (char *)0;
          sp__RequireClientCertificate = (char *)0;
          sp__Basic256 = (char *)0;
          sp__Basic192 = (char *)0;
          sp__Basic128 = (char *)0;
          sp__TripleDes = (char *)0;
          sp__Basic256Rsa15 = (char *)0;
          sp__Basic192Rsa15 = (char *)0;
          sp__Basic128Rsa15 = (char *)0;
          sp__TripleDesRsa15 = (char *)0;
          sp__Basic256Sha256 = (char *)0;
          sp__Basic192Sha256 = (char *)0;
          sp__Basic128Sha256 = (char *)0;
          sp__TripleDesSha256 = (char *)0;
          sp__Basic256Sha256Rsa15 = (char *)0;
          sp__Basic192Sha256Rsa15 = (char *)0;
          sp__Basic128Sha256Rsa15 = (char *)0;
          sp__TripleDesSha256Rsa15 = (char *)0;
          sp__InclusiveC14N = (char *)0;
          sp__SOAPNormalization10 = (char *)0;
          sp__STRTransform10 = (char *)0;
          sp__Path10 = (char *)0;
          sp__XPathFilter20 = (char *)0;
          sp__AbsXPath = (char *)0;
          wsam__AnonymousResponses = (char *)0;
          wsam__NonAnonymousResponses = (char *)0;
        }
        virtual ~wsp__Content() { }
        /// Friend allocator used by soap_new_wsp__Content(struct soap*, int)
        friend SOAP_FMAC1 wsp__Content * SOAP_FMAC2 wsdl_instantiate_wsp__Content(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsp.h:44 */
#ifndef SOAP_TYPE_wsp__Policy
#define SOAP_TYPE_wsp__Policy (288)
/* Type wsp__Policy is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'wsp:Policy': */
class SOAP_CMAC wsp__Policy : public wsp__Content {
      public:
        /// optional attribute 'xml:base' of XSD type 'xsd:anyURI'
        char *xml__base;
        /// optional attribute 'wsu:Id' of XSD type 'xsd:string'
        char *wsu__Id;
        /// optional attribute 'TargetNamespace' of XSD type 'xsd:anyURI'
        char *TargetNamespace;
      public:
        /// Return unique type id SOAP_TYPE_wsp__Policy
        virtual int soap_type(void) const { return SOAP_TYPE_wsp__Policy; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsp__Policy, default initialized and not managed by a soap context
        virtual wsp__Policy *soap_alloc(void) const { return SOAP_NEW(wsp__Policy); }
      public:
        /// Constructor with initializations
        wsp__Policy()
        {
          xml__base = (char *)0;
          wsu__Id = (char *)0;
          TargetNamespace = (char *)0;
        }
        virtual ~wsp__Policy() { }
        /// Friend allocator used by soap_new_wsp__Policy(struct soap*, int)
        friend SOAP_FMAC1 wsp__Policy * SOAP_FMAC2 wsdl_instantiate_wsp__Policy(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsp.h:260 */
#ifndef SOAP_TYPE_wsp__Attachment
#define SOAP_TYPE_wsp__Attachment (328)
/* complex XSD type 'wsp:Attachment': */
class SOAP_CMAC wsp__Attachment {
      public:
        /// Optional element 'wsp:Policy' of XSD type 'wsp:Policy'
        wsp__Policy *Policy;
        /// Optional element 'wsp:PolicyReference' of XSD type 'wsp:PolicyReference'
        wsp__PolicyReference *PolicyReference;
      public:
        /// Return unique type id SOAP_TYPE_wsp__Attachment
        virtual int soap_type(void) const { return SOAP_TYPE_wsp__Attachment; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsp__Attachment, default initialized and not managed by a soap context
        virtual wsp__Attachment *soap_alloc(void) const { return SOAP_NEW(wsp__Attachment); }
      public:
        /// Constructor with initializations
        wsp__Attachment()
        {
          Policy = (wsp__Policy *)0;
          PolicyReference = (wsp__PolicyReference *)0;
        }
        virtual ~wsp__Attachment() { }
        /// Friend allocator used by soap_new_wsp__Attachment(struct soap*, int)
        friend SOAP_FMAC1 wsp__Attachment * SOAP_FMAC2 wsdl_instantiate_wsp__Attachment(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsp.h:266 */
#ifndef SOAP_TYPE_wsp__AppliesTo
#define SOAP_TYPE_wsp__AppliesTo (329)
/* complex XSD type 'wsp:AppliesTo': */
class SOAP_CMAC wsp__AppliesTo {
      public:
        char *__any;
      public:
        /// Return unique type id SOAP_TYPE_wsp__AppliesTo
        virtual int soap_type(void) const { return SOAP_TYPE_wsp__AppliesTo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsp__AppliesTo, default initialized and not managed by a soap context
        virtual wsp__AppliesTo *soap_alloc(void) const { return SOAP_NEW(wsp__AppliesTo); }
      public:
        /// Constructor with initializations
        wsp__AppliesTo()
        {
          __any = (char *)0;
        }
        virtual ~wsp__AppliesTo() { }
        /// Friend allocator used by soap_new_wsp__AppliesTo(struct soap*, int)
        friend SOAP_FMAC1 wsp__AppliesTo * SOAP_FMAC2 wsdl_instantiate_wsp__AppliesTo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsp.h:271 */
#ifndef SOAP_TYPE_wsp__PolicyAttachment
#define SOAP_TYPE_wsp__PolicyAttachment (330)
/* complex XSD type 'wsp:PolicyAttachment': */
class SOAP_CMAC wsp__PolicyAttachment {
      public:
        /// Optional element 'wsp:AppliesTo' of XSD type 'wsp:AppliesTo'
        wsp__AppliesTo *AppliesTo;
        /// Optional element 'wsp:Attachment' of XSD type 'wsp:Attachment'
        std::vector<wsp__Attachment> Attachment;
      public:
        /// Return unique type id SOAP_TYPE_wsp__PolicyAttachment
        virtual int soap_type(void) const { return SOAP_TYPE_wsp__PolicyAttachment; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsp__PolicyAttachment, default initialized and not managed by a soap context
        virtual wsp__PolicyAttachment *soap_alloc(void) const { return SOAP_NEW(wsp__PolicyAttachment); }
      public:
        /// Constructor with initializations
        wsp__PolicyAttachment()
        {
          AppliesTo = (wsp__AppliesTo *)0;
        }
        virtual ~wsp__PolicyAttachment() { }
        /// Friend allocator used by soap_new_wsp__PolicyAttachment(struct soap*, int)
        friend SOAP_FMAC1 wsp__PolicyAttachment * SOAP_FMAC2 wsdl_instantiate_wsp__PolicyAttachment(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bpel.h:50 */
#ifndef SOAP_TYPE_plnk__tRole
#define SOAP_TYPE_plnk__tRole (335)
/* complex XSD type 'plnk:tRole': */
class SOAP_CMAC plnk__tRole {
      public:
        /// optional attribute 'name' of XSD type 'xsd:NCName'
        char *name;
        /// optional attribute 'portType' of XSD type 'xsd:QName'
        char *portType;
        /// Optional element 'plnk:documentation' of XSD type 'xsd:string'
        char *documentation;
      private:
        /// Not serialized
        wsdl__portType *portTypeRef;
        /// Not serialized
        plnk__tPartnerLinkType *plnkRef;
      public:
        plnk__tRole();
        int traverse(wsdl__definitions &_param_1);
        wsdl__portType *portTypePtr() const;
        void plnkPtr(plnk__tPartnerLinkType *_param_1);
        plnk__tPartnerLinkType *plnkPtr() const;
      public:
        /// Return unique type id SOAP_TYPE_plnk__tRole
        virtual int soap_type(void) const { return SOAP_TYPE_plnk__tRole; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type plnk__tRole, default initialized and not managed by a soap context
        virtual plnk__tRole *soap_alloc(void) const { return SOAP_NEW(plnk__tRole); }
        virtual ~plnk__tRole() { }
        /// Friend allocator used by soap_new_plnk__tRole(struct soap*, int)
        friend SOAP_FMAC1 plnk__tRole * SOAP_FMAC2 wsdl_instantiate_plnk__tRole(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bpel.h:48 */
#ifndef SOAP_TYPE_plnk__tPartnerLinkType
#define SOAP_TYPE_plnk__tPartnerLinkType (334)
/* Type plnk__tPartnerLinkType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'plnk:tPartnerLinkType': */
class SOAP_CMAC plnk__tPartnerLinkType {
      public:
        /// optional attribute 'name' of XSD type 'xsd:NCName'
        char *name;
        /// Optional element 'plnk:role' of XSD type 'plnk:tRole'
        std::vector<plnk__tRole> role;
        /// Optional element 'plnk:documentation' of XSD type 'xsd:string'
        char *documentation;
        int traverse(wsdl__definitions &_param_1);
      public:
        /// Return unique type id SOAP_TYPE_plnk__tPartnerLinkType
        virtual int soap_type(void) const { return SOAP_TYPE_plnk__tPartnerLinkType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type plnk__tPartnerLinkType, default initialized and not managed by a soap context
        virtual plnk__tPartnerLinkType *soap_alloc(void) const { return SOAP_NEW(plnk__tPartnerLinkType); }
      public:
        /// Constructor with initializations
        plnk__tPartnerLinkType()
        {
          name = (char *)0;
          documentation = (char *)0;
        }
        virtual ~plnk__tPartnerLinkType() { }
        /// Friend allocator used by soap_new_plnk__tPartnerLinkType(struct soap*, int)
        friend SOAP_FMAC1 plnk__tPartnerLinkType * SOAP_FMAC2 wsdl_instantiate_plnk__tPartnerLinkType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bpel.h:75 */
#ifndef SOAP_TYPE_vprop__tQuery
#define SOAP_TYPE_vprop__tQuery (346)
/* complex XSD type 'vprop:tQuery': */
class SOAP_CMAC vprop__tQuery {
      public:
        /// optional attribute 'queryLanguage' of XSD type 'xsd:anyURI'
        char *queryLanguage;	///< default = (char*)"urn:oasis:names:tc:wsbpel:2.0:sublang:xpath1.0"
        char *__mixed;
      public:
        /// Return unique type id SOAP_TYPE_vprop__tQuery
        virtual int soap_type(void) const { return SOAP_TYPE_vprop__tQuery; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type vprop__tQuery, default initialized and not managed by a soap context
        virtual vprop__tQuery *soap_alloc(void) const { return SOAP_NEW(vprop__tQuery); }
      public:
        /// Constructor with initializations
        vprop__tQuery()
        {
          queryLanguage = (char*)"urn:oasis:names:tc:wsbpel:2.0:sublang:xpath1.0";
          __mixed = (char *)0;
        }
        virtual ~vprop__tQuery() { }
        /// Friend allocator used by soap_new_vprop__tQuery(struct soap*, int)
        friend SOAP_FMAC1 vprop__tQuery * SOAP_FMAC2 wsdl_instantiate_vprop__tQuery(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bpel.h:81 */
#ifndef SOAP_TYPE_vprop__tProperty
#define SOAP_TYPE_vprop__tProperty (347)
/* complex XSD type 'vprop:tProperty': */
class SOAP_CMAC vprop__tProperty {
      public:
        /// optional attribute 'name' of XSD type 'xsd:NCName'
        char *name;
        /// optional attribute 'type' of XSD type 'xsd:QName'
        char *type;
        /// optional attribute 'element' of XSD type 'xsd:QName'
        char *element;
        /// Optional element 'vprop:documentation' of XSD type 'xsd:string'
        char *documentation;
        int traverse(wsdl__definitions &_param_1);
      public:
        /// Return unique type id SOAP_TYPE_vprop__tProperty
        virtual int soap_type(void) const { return SOAP_TYPE_vprop__tProperty; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type vprop__tProperty, default initialized and not managed by a soap context
        virtual vprop__tProperty *soap_alloc(void) const { return SOAP_NEW(vprop__tProperty); }
      public:
        /// Constructor with initializations
        vprop__tProperty()
        {
          name = (char *)0;
          type = (char *)0;
          element = (char *)0;
          documentation = (char *)0;
        }
        virtual ~vprop__tProperty() { }
        /// Friend allocator used by soap_new_vprop__tProperty(struct soap*, int)
        friend SOAP_FMAC1 vprop__tProperty * SOAP_FMAC2 wsdl_instantiate_vprop__tProperty(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bpel.h:91 */
#ifndef SOAP_TYPE_vprop__tPropertyAlias
#define SOAP_TYPE_vprop__tPropertyAlias (349)
/* complex XSD type 'vprop:tPropertyAlias': */
class SOAP_CMAC vprop__tPropertyAlias {
      public:
        /// Optional element 'vprop:query' of XSD type 'vprop:tQuery'
        vprop__tQuery *query;
        /// optional attribute 'propertyName' of XSD type 'xsd:QName'
        char *propertyName;
        /// optional attribute 'messageType' of XSD type 'xsd:QName'
        char *messageType;
        /// optional attribute 'part' of XSD type 'xsd:NCName'
        char *part;
        /// optional attribute 'type' of XSD type 'xsd:QName'
        char *type;
        /// optional attribute 'element' of XSD type 'xsd:QName'
        char *element;
        /// Optional element 'vprop:documentation' of XSD type 'xsd:string'
        char *documentation;
      private:
        /// Not serialized
        vprop__tProperty *vpropRef;
      public:
        int traverse(wsdl__definitions &_param_1);
        vprop__tProperty *vpropPtr() const;
      public:
        /// Return unique type id SOAP_TYPE_vprop__tPropertyAlias
        virtual int soap_type(void) const { return SOAP_TYPE_vprop__tPropertyAlias; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type vprop__tPropertyAlias, default initialized and not managed by a soap context
        virtual vprop__tPropertyAlias *soap_alloc(void) const { return SOAP_NEW(vprop__tPropertyAlias); }
      public:
        /// Constructor with initializations
        vprop__tPropertyAlias()
        {
          query = (vprop__tQuery *)0;
          propertyName = (char *)0;
          messageType = (char *)0;
          part = (char *)0;
          type = (char *)0;
          element = (char *)0;
          documentation = (char *)0;
          vpropRef = (vprop__tProperty *)0;
        }
        virtual ~vprop__tPropertyAlias() { }
        /// Friend allocator used by soap_new_vprop__tPropertyAlias(struct soap*, int)
        friend SOAP_FMAC1 vprop__tPropertyAlias * SOAP_FMAC2 wsdl_instantiate_vprop__tPropertyAlias(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ./wsdl.h:55 */
#ifndef SOAP_TYPE_wsdl__import
#define SOAP_TYPE_wsdl__import (354)
/* complex XSD type 'wsdl:import': */
class SOAP_CMAC wsdl__import {
      public:
        /// optional attribute 'namespace' of XSD type 'xsd:anyURI'
        char *namespace_;
        /// optional attribute 'location' of XSD type 'xsd:anyURI'
        char *location;
      private:
        /// Not serialized
        wsdl__definitions *definitionsRef;
      public:
        wsdl__import();
        int preprocess(wsdl__definitions &_param_1);
        int traverse(wsdl__definitions &_param_1);
        void definitionsPtr(wsdl__definitions *_param_1);
        wsdl__definitions *definitionsPtr() const;
      public:
        /// Return unique type id SOAP_TYPE_wsdl__import
        virtual int soap_type(void) const { return SOAP_TYPE_wsdl__import; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsdl__import, default initialized and not managed by a soap context
        virtual wsdl__import *soap_alloc(void) const { return SOAP_NEW(wsdl__import); }
        virtual ~wsdl__import() { }
        /// Friend allocator used by soap_new_wsdl__import(struct soap*, int)
        friend SOAP_FMAC1 wsdl__import * SOAP_FMAC2 wsdl_instantiate_wsdl__import(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ./wsdl.h:69 */
#ifndef SOAP_TYPE_wsdl__types
#define SOAP_TYPE_wsdl__types (362)
/* Type wsdl__types is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'wsdl:types': */
class SOAP_CMAC wsdl__types : public xs__schema {
      public:
        /// Optional element 'wsdl:documentation' of XSD type 'xsd:string'
        char *documentation;
        /// Optional element 'xs:schema' of XSD type 'xs:schema'
        std::vector<xs__schema *> xs__schema_;
        int preprocess(wsdl__definitions &_param_1);
        int traverse(wsdl__definitions &_param_1);
      public:
        /// Return unique type id SOAP_TYPE_wsdl__types
        virtual int soap_type(void) const { return SOAP_TYPE_wsdl__types; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsdl__types, default initialized and not managed by a soap context
        virtual wsdl__types *soap_alloc(void) const { return SOAP_NEW(wsdl__types); }
      public:
        /// Constructor with initializations
        wsdl__types()
        {
          documentation = (char *)0;
        }
        /// Friend allocator used by soap_new_wsdl__types(struct soap*, int)
        friend SOAP_FMAC1 wsdl__types * SOAP_FMAC2 wsdl_instantiate_wsdl__types(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap.h:44 */
#ifndef SOAP_TYPE_wsdl__part
#define SOAP_TYPE_wsdl__part (230)
/* complex XSD type 'wsdl:part': */
class SOAP_CMAC wsdl__part {
      public:
        /// optional attribute 'name' of XSD type 'xsd:NMTOKEN'
        char *name;
        /// optional attribute 'element' of XSD type 'xsd:QName'
        char *element;
        /// optional attribute 'type' of XSD type 'xsd:QName'
        char *type;
        /// Optional element 'wsdl:documentation' of XSD type 'xsd:string'
        char *documentation;
      private:
        /// Not serialized
        xs__element *elementRef;
        /// Not serialized
        xs__simpleType *simpleTypeRef;
        /// Not serialized
        xs__complexType *complexTypeRef;
      public:
        wsdl__part();
        int traverse(wsdl__definitions &_param_1);
        void elementPtr(xs__element *_param_1);
        void simpleTypePtr(xs__simpleType *_param_1);
        void complexTypePtr(xs__complexType *_param_1);
        xs__element *elementPtr() const;
        xs__simpleType *simpleTypePtr() const;
        xs__complexType *complexTypePtr() const;
      public:
        /// Return unique type id SOAP_TYPE_wsdl__part
        virtual int soap_type(void) const { return SOAP_TYPE_wsdl__part; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsdl__part, default initialized and not managed by a soap context
        virtual wsdl__part *soap_alloc(void) const { return SOAP_NEW(wsdl__part); }
        virtual ~wsdl__part() { }
        /// Friend allocator used by soap_new_wsdl__part(struct soap*, int)
        friend SOAP_FMAC1 wsdl__part * SOAP_FMAC2 wsdl_instantiate_wsdl__part(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap.h:43 */
#ifndef SOAP_TYPE_wsdl__message
#define SOAP_TYPE_wsdl__message (229)
/* complex XSD type 'wsdl:message': */
class SOAP_CMAC wsdl__message {
      public:
        /// optional attribute 'name' of XSD type 'xsd:NMTOKEN'
        char *name;
        /// Optional element 'wsdl:documentation' of XSD type 'xsd:string'
        char *documentation;
        /// Optional element 'wsp:Policy' of XSD type 'wsp:Policy'
        std::vector<wsp__Policy> wsp__Policy_;
        /// Optional element 'wsp:PolicyReference' of XSD type 'wsp:PolicyReference'
        std::vector<wsp__PolicyReference> wsp__PolicyReference_;
        /// Optional element 'wsdl:part' of XSD type 'wsdl:part'
        std::vector<wsdl__part> part;
        int traverse(wsdl__definitions &_param_1);
      public:
        /// Return unique type id SOAP_TYPE_wsdl__message
        virtual int soap_type(void) const { return SOAP_TYPE_wsdl__message; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsdl__message, default initialized and not managed by a soap context
        virtual wsdl__message *soap_alloc(void) const { return SOAP_NEW(wsdl__message); }
      public:
        /// Constructor with initializations
        wsdl__message()
        {
          name = (char *)0;
          documentation = (char *)0;
        }
        virtual ~wsdl__message() { }
        /// Friend allocator used by soap_new_wsdl__message(struct soap*, int)
        friend SOAP_FMAC1 wsdl__message * SOAP_FMAC2 wsdl_instantiate_wsdl__message(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ./wsdl.h:110 */
#ifndef SOAP_TYPE_wsdl__ioput
#define SOAP_TYPE_wsdl__ioput (378)
/* complex XSD type 'wsdl:ioput': */
class SOAP_CMAC wsdl__ioput {
      public:
        /// optional attribute 'name' of XSD type 'xsd:NMTOKEN'
        char *name;
        /// optional attribute 'message' of XSD type 'xsd:QName'
        char *message;
        /// optional attribute 'messageLabel' of XSD type 'xsd:NMTOKEN'
        char *messageLabel;
        /// optional attribute 'element' of XSD type 'xsd:QName'
        char *element;
        /// optional attribute 'wsa:Action' of XSD type 'xsd:anyURI'
        char *wsa__Action;
        /// optional attribute 'wsam:Action' of XSD type 'xsd:anyURI'
        char *wsam__Action;
        /// Optional element 'wsdl:documentation' of XSD type 'xsd:string'
        char *documentation;
        /// Optional element 'wsp:Policy' of XSD type 'wsp:Policy'
        wsp__Policy *wsp__Policy_;
        /// Optional element 'wsp:PolicyReference' of XSD type 'wsp:PolicyReference'
        wsp__PolicyReference *wsp__PolicyReference_;
      private:
        /// Not serialized
        wsdl__message *messageRef;
        /// Not serialized
        xs__element *elementRef;
      public:
        wsdl__ioput();
        int traverse(wsdl__definitions &_param_1);
        void messagePtr(wsdl__message *_param_1);
        wsdl__message *messagePtr() const;
        void elementPtr(xs__element *_param_1);
        xs__element *elementPtr() const;
      public:
        /// Return unique type id SOAP_TYPE_wsdl__ioput
        virtual int soap_type(void) const { return SOAP_TYPE_wsdl__ioput; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsdl__ioput, default initialized and not managed by a soap context
        virtual wsdl__ioput *soap_alloc(void) const { return SOAP_NEW(wsdl__ioput); }
        virtual ~wsdl__ioput() { }
        /// Friend allocator used by soap_new_wsdl__ioput(struct soap*, int)
        friend SOAP_FMAC1 wsdl__ioput * SOAP_FMAC2 wsdl_instantiate_wsdl__ioput(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ./wsdl.h:133 */
#ifndef SOAP_TYPE_wsdl__fault
#define SOAP_TYPE_wsdl__fault (385)
/* complex XSD type 'wsdl:fault': */
class SOAP_CMAC wsdl__fault {
      public:
        /// optional attribute 'name' of XSD type 'xsd:NMTOKEN'
        char *name;
        /// optional attribute 'message' of XSD type 'xsd:QName'
        char *message;
        /// optional attribute 'ref' of XSD type 'xsd:QName'
        char *ref;
        /// optional attribute 'messageLabel' of XSD type 'xsd:NMTOKEN'
        char *messageLabel;
        /// optional attribute 'element' of XSD type 'xsd:QName'
        char *element;
        /// optional attribute 'wsa:Action' of XSD type 'xsd:anyURI'
        char *wsa__Action;
        /// optional attribute 'wsam:Action' of XSD type 'xsd:anyURI'
        char *wsam__Action;
        /// Optional element 'wsdl:documentation' of XSD type 'xsd:string'
        char *documentation;
        /// Optional element 'wsp:Policy' of XSD type 'wsp:Policy'
        wsp__Policy *wsp__Policy_;
        /// Optional element 'wsp:PolicyReference' of XSD type 'wsp:PolicyReference'
        wsp__PolicyReference *wsp__PolicyReference_;
      private:
        /// Not serialized
        wsdl__message *messageRef;
        /// Not serialized
        xs__element *elementRef;
      public:
        wsdl__fault();
        int traverse(wsdl__definitions &_param_1);
        void messagePtr(wsdl__message *_param_1);
        wsdl__message *messagePtr() const;
        void elementPtr(xs__element *_param_1);
        xs__element *elementPtr() const;
      public:
        /// Return unique type id SOAP_TYPE_wsdl__fault
        virtual int soap_type(void) const { return SOAP_TYPE_wsdl__fault; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsdl__fault, default initialized and not managed by a soap context
        virtual wsdl__fault *soap_alloc(void) const { return SOAP_NEW(wsdl__fault); }
        virtual ~wsdl__fault() { }
        /// Friend allocator used by soap_new_wsdl__fault(struct soap*, int)
        friend SOAP_FMAC1 wsdl__fault * SOAP_FMAC2 wsdl_instantiate_wsdl__fault(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ./wsdl.h:171 */
#ifndef SOAP_TYPE_wsdl__union_ioput
#define SOAP_TYPE_wsdl__union_ioput (393)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union wsdl__union_ioput
{
        #define SOAP_UNION_wsdl__union_ioput_input	(1)	/**< union variant selector value for member input */
        wsdl__ioput *input;
        #define SOAP_UNION_wsdl__union_ioput_output	(2)	/**< union variant selector value for member output */
        wsdl__ioput *output;
};
#endif

/* gwsdl.h:41 */
#ifndef SOAP_TYPE_wsdl__operation
#define SOAP_TYPE_wsdl__operation (277)
/* complex XSD type 'wsdl:operation': */
class SOAP_CMAC wsdl__operation {
      public:
        /// optional attribute 'name' of XSD type 'xsd:NMTOKEN'
        char *name;
        /// optional attribute 'pattern' of XSD type 'xsd:anyURI'
        char *pattern;
        /// optional attribute 'style' of XSD type 'xsd:anyURI'
        char *style;
        /// optional attribute 'wrpc:signature' of XSD type 'xsd:string'
        char *wrpc__signature;
        /// optional attribute 'parameterOrder' of XSD type 'xsd:string'
        char *parameterOrder;
        /// Optional element 'wsdl:documentation' of XSD type 'xsd:string'
        char *documentation;
        /// Optional element 'wsp:Policy' of XSD type 'wsp:Policy'
        wsp__Policy *wsp__Policy_;
        /// Optional element 'wsp:PolicyReference' of XSD type 'wsp:PolicyReference'
        wsp__PolicyReference *wsp__PolicyReference_;
        /// Union with union wsdl__union_ioput variant selector __union1 set to one of: SOAP_UNION_wsdl__union_ioput_input SOAP_UNION_wsdl__union_ioput_output
        int __union1;
        union wsdl__union_ioput __ioput1;
        /// Union with union wsdl__union_ioput variant selector __union2 set to one of: SOAP_UNION_wsdl__union_ioput_input SOAP_UNION_wsdl__union_ioput_output
        int __union2;
        union wsdl__union_ioput __ioput2;
        /// Optional element 'wsdl:fault' of XSD type 'wsdl:fault'
        std::vector<wsdl__fault> fault;
        /// Optional element 'wsdl:infault' of XSD type 'wsdl:fault'
        std::vector<wsdl__fault> infault;
        /// Optional element 'wsdl:outfault' of XSD type 'wsdl:fault'
        std::vector<wsdl__fault> outfault;
        int traverse(wsdl__definitions &_param_1);
      public:
        /// Return unique type id SOAP_TYPE_wsdl__operation
        virtual int soap_type(void) const { return SOAP_TYPE_wsdl__operation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsdl__operation, default initialized and not managed by a soap context
        virtual wsdl__operation *soap_alloc(void) const { return SOAP_NEW(wsdl__operation); }
      public:
        /// Constructor with initializations
        wsdl__operation()
        {
          name = (char *)0;
          pattern = (char *)0;
          style = (char *)0;
          wrpc__signature = (char *)0;
          parameterOrder = (char *)0;
          documentation = (char *)0;
          wsp__Policy_ = (wsp__Policy *)0;
          wsp__PolicyReference_ = (wsp__PolicyReference *)0;
          __union1 = 0;
          __union2 = 0;
        }
        virtual ~wsdl__operation() { }
        /// Friend allocator used by soap_new_wsdl__operation(struct soap*, int)
        friend SOAP_FMAC1 wsdl__operation * SOAP_FMAC2 wsdl_instantiate_wsdl__operation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bpel.h:47 */
#ifndef SOAP_TYPE_wsdl__portType
#define SOAP_TYPE_wsdl__portType (333)
/* Type wsdl__portType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'wsdl:portType': */
class SOAP_CMAC wsdl__portType {
      public:
        /// optional attribute 'name' of XSD type 'xsd:NMTOKEN'
        char *name;
        /// optional attribute 'extends' of XSD type 'xsd:QName'
        char *extends;
        /// optional attribute 'styleDefault' of XSD type 'xsd:anyURI'
        char *styleDefault;
        /// Optional element 'wsdl:documentation' of XSD type 'xsd:string'
        char *documentation;
        /// Optional element 'wsp:Policy' of XSD type 'wsp:Policy'
        wsp__Policy *wsp__Policy_;
        /// Optional element 'wsp:PolicyReference' of XSD type 'wsp:PolicyReference'
        wsp__PolicyReference *wsp__PolicyReference_;
        /// Optional element 'wsdl:fault' of XSD type 'wsdl:fault'
        std::vector<wsdl__fault> fault;
        /// Optional element 'wsdl:operation' of XSD type 'wsdl:operation'
        std::vector<wsdl__operation> operation;
      private:
        /// Not serialized
        wsdl__definitions *definitionsRef;
      public:
        wsdl__portType();
        int traverse(wsdl__definitions &_param_1);
        void definitionsPtr(wsdl__definitions *_param_1);
        wsdl__definitions *definitionsPtr() const;
      public:
        /// Return unique type id SOAP_TYPE_wsdl__portType
        virtual int soap_type(void) const { return SOAP_TYPE_wsdl__portType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsdl__portType, default initialized and not managed by a soap context
        virtual wsdl__portType *soap_alloc(void) const { return SOAP_NEW(wsdl__portType); }
        virtual ~wsdl__portType() { }
        /// Friend allocator used by soap_new_wsdl__portType(struct soap*, int)
        friend SOAP_FMAC1 wsdl__portType * SOAP_FMAC2 wsdl_instantiate_wsdl__portType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ./wsdl.h:200 */
#ifndef SOAP_TYPE_wsdl__ext_ioput
#define SOAP_TYPE_wsdl__ext_ioput (401)
/* complex XSD type 'wsdl:ext-ioput': */
class SOAP_CMAC wsdl__ext_ioput {
      public:
        /// optional attribute 'name' of XSD type 'xsd:NMTOKEN'
        char *name;
        /// optional attribute 'messageLabel' of XSD type 'xsd:NMTOKEN'
        char *messageLabel;
        /// Optional element 'wsdl:documentation' of XSD type 'xsd:string'
        char *documentation;
        /// Optional element 'wsp:Policy' of XSD type 'wsp:Policy'
        wsp__Policy *wsp__Policy_;
        /// Optional element 'wsp:PolicyReference' of XSD type 'wsp:PolicyReference'
        wsp__PolicyReference *wsp__PolicyReference_;
        /// Optional element 'dime:message' of XSD type 'dime:message'
        dime__message *dime__message_;
        /// Optional element 'soap:body' of XSD type 'soap:body'
        soap__body *soap__body_;
        /// Optional element 'http:urlEncoded' of XSD type 'xsd:string'
        char *http__urlEncoded;
        /// Optional element 'mime:multipartRelated' of XSD type 'mime:multipartRelated'
        mime__multipartRelated *mime__multipartRelated_;
        /// Optional element 'mime:content' of XSD type 'mime:content'
        mime__content *mime__content_;
        /// Optional element 'mime:mimeXml' of XSD type 'mime:mimeXml'
        mime__mimeXml *mime__mimeXml_;
        /// Optional element 'soap:header' of XSD type 'soap:header'
        std::vector<soap__header> soap__header_;
        /// Optional element 'wsoap:module' of XSD type 'wsoap:module'
        std::vector<wsoap__module> wsoap__module_;
        /// Optional element 'wsoap:header' of XSD type 'wsoap:header'
        std::vector<wsoap__header> wsoap__header_;
        /// Optional element 'whttp:header' of XSD type 'whttp:header'
        std::vector<whttp__header> whttp__header_;
        int traverse(wsdl__definitions &_param_1);
      public:
        /// Return unique type id SOAP_TYPE_wsdl__ext_ioput
        virtual int soap_type(void) const { return SOAP_TYPE_wsdl__ext_ioput; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsdl__ext_ioput, default initialized and not managed by a soap context
        virtual wsdl__ext_ioput *soap_alloc(void) const { return SOAP_NEW(wsdl__ext_ioput); }
      public:
        /// Constructor with initializations
        wsdl__ext_ioput()
        {
          name = (char *)0;
          messageLabel = (char *)0;
          documentation = (char *)0;
          wsp__Policy_ = (wsp__Policy *)0;
          wsp__PolicyReference_ = (wsp__PolicyReference *)0;
          dime__message_ = (dime__message *)0;
          soap__body_ = (soap__body *)0;
          http__urlEncoded = (char *)0;
          mime__multipartRelated_ = (mime__multipartRelated *)0;
          mime__content_ = (mime__content *)0;
          mime__mimeXml_ = (mime__mimeXml *)0;
        }
        virtual ~wsdl__ext_ioput() { }
        /// Friend allocator used by soap_new_wsdl__ext_ioput(struct soap*, int)
        friend SOAP_FMAC1 wsdl__ext_ioput * SOAP_FMAC2 wsdl_instantiate_wsdl__ext_ioput(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ./wsdl.h:221 */
#ifndef SOAP_TYPE_wsdl__ext_fault
#define SOAP_TYPE_wsdl__ext_fault (410)
/* complex XSD type 'wsdl:ext-fault': */
class SOAP_CMAC wsdl__ext_fault {
      public:
        /// optional attribute 'name' of XSD type 'xsd:NMTOKEN'
        char *name;
        /// optional attribute 'ref' of XSD type 'xsd:QName'
        char *ref;
        /// optional attribute 'messageLabel' of XSD type 'xsd:NMTOKEN'
        char *messageLabel;
        /// optional attribute 'wsoap:code' of XSD type 'xsd:QName'
        char *wsoap__code;
        /// optional attribute 'wsoap:subcodes' of XSD type 'xsd:QName'
        char *wsoap__subcodes;
        /// Optional element 'wsdl:documentation' of XSD type 'xsd:string'
        char *documentation;
        /// Optional element 'wsp:Policy' of XSD type 'wsp:Policy'
        wsp__Policy *wsp__Policy_;
        /// Optional element 'wsp:PolicyReference' of XSD type 'wsp:PolicyReference'
        wsp__PolicyReference *wsp__PolicyReference_;
        /// Optional element 'soap:fault' of XSD type 'soap:fault'
        soap__fault *soap__fault_;
        /// Optional element 'wsoap:module' of XSD type 'wsoap:module'
        std::vector<wsoap__module> wsoap__module_;
      private:
        /// Not serialized
        wsdl__fault *faultRef;
      public:
        wsdl__ext_fault();
        int traverse(wsdl__definitions &_param_1, wsdl__portType *_param_2);
        void faultPtr(wsdl__fault *_param_1);
        wsdl__fault *faultPtr() const;
      public:
        /// Return unique type id SOAP_TYPE_wsdl__ext_fault
        virtual int soap_type(void) const { return SOAP_TYPE_wsdl__ext_fault; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsdl__ext_fault, default initialized and not managed by a soap context
        virtual wsdl__ext_fault *soap_alloc(void) const { return SOAP_NEW(wsdl__ext_fault); }
        virtual ~wsdl__ext_fault() { }
        /// Friend allocator used by soap_new_wsdl__ext_fault(struct soap*, int)
        friend SOAP_FMAC1 wsdl__ext_fault * SOAP_FMAC2 wsdl_instantiate_wsdl__ext_fault(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ./wsdl.h:242 */
#ifndef SOAP_TYPE_wsdl__ext_operation
#define SOAP_TYPE_wsdl__ext_operation (419)
/* complex XSD type 'wsdl:ext-operation': */
class SOAP_CMAC wsdl__ext_operation {
      public:
        /// optional attribute 'name' of XSD type 'xsd:NMTOKEN'
        char *name;
        /// optional attribute 'ref' of XSD type 'xsd:QName'
        char *ref;
        /// optional attribute 'wsoap:mep' of XSD type 'xsd:anyURI'
        char *wsoap__mep;
        /// optional attribute 'wsoap:action' of XSD type 'xsd:anyURI'
        char *wsoap__action;
        /// optional attribute 'whttp:method' of XSD type 'xsd:string'
        char *whttp__method;
        /// optional attribute 'whttp:location' of XSD type 'xsd:string'
        char *whttp__location;
        /// Optional element 'wsdl:documentation' of XSD type 'xsd:string'
        char *documentation;
        /// Optional element 'wsp:Policy' of XSD type 'wsp:Policy'
        wsp__Policy *wsp__Policy_;
        /// Optional element 'wsp:PolicyReference' of XSD type 'wsp:PolicyReference'
        wsp__PolicyReference *wsp__PolicyReference_;
        /// Optional element 'soap:operation' of XSD type 'soap:operation'
        soap__operation *soap__operation_;
        /// Optional element 'http:operation' of XSD type 'http:operation'
        http__operation *http__operation_;
        /// Optional element 'wsdl:input' of XSD type 'wsdl:ext-ioput'
        wsdl__ext_ioput *input;
        /// Optional element 'wsdl:output' of XSD type 'wsdl:ext-ioput'
        wsdl__ext_ioput *output;
        /// Optional element 'wsdl:fault' of XSD type 'wsdl:ext-fault'
        std::vector<wsdl__ext_fault> fault;
        /// Optional element 'wsdl:infault' of XSD type 'wsdl:ext-fault'
        std::vector<wsdl__ext_fault> infault;
        /// Optional element 'wsdl:outfault' of XSD type 'wsdl:ext-fault'
        std::vector<wsdl__ext_fault> outfault;
      private:
        /// Not serialized
        wsdl__operation *operationRef;
      public:
        wsdl__ext_operation();
        int traverse(wsdl__definitions &_param_1, wsdl__portType *_param_2);
        void operationPtr(wsdl__operation *_param_1);
        wsdl__operation *operationPtr() const;
      public:
        /// Return unique type id SOAP_TYPE_wsdl__ext_operation
        virtual int soap_type(void) const { return SOAP_TYPE_wsdl__ext_operation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsdl__ext_operation, default initialized and not managed by a soap context
        virtual wsdl__ext_operation *soap_alloc(void) const { return SOAP_NEW(wsdl__ext_operation); }
        virtual ~wsdl__ext_operation() { }
        /// Friend allocator used by soap_new_wsdl__ext_operation(struct soap*, int)
        friend SOAP_FMAC1 wsdl__ext_operation * SOAP_FMAC2 wsdl_instantiate_wsdl__ext_operation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ./wsdl.h:269 */
#ifndef SOAP_TYPE_wsdl__binding
#define SOAP_TYPE_wsdl__binding (429)
/* Type wsdl__binding is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'wsdl:binding': */
class SOAP_CMAC wsdl__binding {
      public:
        /// optional attribute 'name' of XSD type 'xsd:NMTOKEN'
        char *name;
        /// optional attribute 'type' of XSD type 'xsd:QName'
        char *type;
        /// optional attribute 'type' of XSD type 'xsd:anyURI'
        char *type_;
        /// optional attribute 'interface' of XSD type 'xsd:QName'
        char *interface_;
        /// optional attribute 'whttp:cookies' of XSD type 'xsd:boolean'
        bool whttp__cookies;	///< default = (bool)0
        /// optional attribute 'wsoap:version' of XSD type 'xsd:string'
        char *wsoap__version;
        /// optional attribute 'wsoap:protocol' of XSD type 'xsd:anyURI'
        char *wsoap__protocol;
        /// optional attribute 'wsoap:mepDefault' of XSD type 'xsd:anyURI'
        char *wsoap__mepDefault;
        /// optional attribute 'whttp:methodDefault' of XSD type 'xsd:string'
        char *whttp__methodDefault;
        /// Optional element 'wsdl:documentation' of XSD type 'xsd:string'
        char *documentation;
        /// Optional element 'wsp:Policy' of XSD type 'wsp:Policy'
        std::vector<wsp__Policy> wsp__Policy_;
        /// Optional element 'wsp:PolicyReference' of XSD type 'wsp:PolicyReference'
        std::vector<wsp__PolicyReference> wsp__PolicyReference_;
        /// Optional element 'soap:binding' of XSD type 'soap:binding'
        soap__binding *soap__binding_;
        /// Optional element 'http:binding' of XSD type 'http:binding'
        http__binding *http__binding_;
        /// Optional element 'wsoap:module' of XSD type 'wsoap:module'
        std::vector<wsoap__module> wsoap__module_;
        /// Optional element 'wsdl:fault' of XSD type 'wsdl:ext-fault'
        std::vector<wsdl__ext_fault> fault;
        /// Optional element 'wsdl:operation' of XSD type 'wsdl:ext-operation'
        std::vector<wsdl__ext_operation> operation;
      private:
        /// Not serialized
        wsdl__portType *portTypeRef;
      public:
        wsdl__binding();
        int traverse(wsdl__definitions &_param_1);
        void portTypePtr(wsdl__portType *_param_1);
        wsdl__portType *portTypePtr() const;
      public:
        /// Return unique type id SOAP_TYPE_wsdl__binding
        virtual int soap_type(void) const { return SOAP_TYPE_wsdl__binding; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsdl__binding, default initialized and not managed by a soap context
        virtual wsdl__binding *soap_alloc(void) const { return SOAP_NEW(wsdl__binding); }
        virtual ~wsdl__binding() { }
        /// Friend allocator used by soap_new_wsdl__binding(struct soap*, int)
        friend SOAP_FMAC1 wsdl__binding * SOAP_FMAC2 wsdl_instantiate_wsdl__binding(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ./wsdl.h:297 */
#ifndef SOAP_TYPE_wsdl__port
#define SOAP_TYPE_wsdl__port (437)
/* complex XSD type 'wsdl:port': */
class SOAP_CMAC wsdl__port {
      public:
        /// optional attribute 'name' of XSD type 'xsd:NMTOKEN'
        char *name;
        /// optional attribute 'binding' of XSD type 'xsd:QName'
        char *binding;
        /// optional attribute 'address' of XSD type 'xsd:anyURI'
        char *address;
        /// optional attribute 'whttp:authenticationScheme' of XSD type 'xsd:NMTOKEN'
        char *whttp__authenticationScheme;
        /// optional attribute 'whttp:authenticationRealm' of XSD type 'xsd:NMTOKEN'
        char *whttp__authenticationRealm;
        /// Optional element 'wsdl:documentation' of XSD type 'xsd:string'
        char *documentation;
        /// Optional element 'wsp:Policy' of XSD type 'wsp:Policy'
        wsp__Policy *wsp__Policy_;
        /// Optional element 'wsp:PolicyReference' of XSD type 'wsp:PolicyReference'
        wsp__PolicyReference *wsp__PolicyReference_;
        /// Optional element 'wsa:EndpointReference' of XSD type 'wsa:EndpointReferenceType'
        wsa__EndpointReferenceType *wsa__EndpointReference;
        /// Optional element 'wsaw:UsingAddressing' of XSD type 'xsd:string'
        char **wsaw__UsingAddressing;
        /// Optional element 'soap:address' of XSD type 'soap:address'
        soap__address *soap__address_;
        /// Optional element 'http:address' of XSD type 'http:address'
        http__address *http__address_;
      private:
        /// Not serialized
        wsdl__binding *bindingRef;
      public:
        wsdl__port();
        int traverse(wsdl__definitions &_param_1);
        void bindingPtr(wsdl__binding *_param_1);
        wsdl__binding *bindingPtr() const;
      public:
        /// Return unique type id SOAP_TYPE_wsdl__port
        virtual int soap_type(void) const { return SOAP_TYPE_wsdl__port; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsdl__port, default initialized and not managed by a soap context
        virtual wsdl__port *soap_alloc(void) const { return SOAP_NEW(wsdl__port); }
        virtual ~wsdl__port() { }
        /// Friend allocator used by soap_new_wsdl__port(struct soap*, int)
        friend SOAP_FMAC1 wsdl__port * SOAP_FMAC2 wsdl_instantiate_wsdl__port(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ./wsdl.h:320 */
#ifndef SOAP_TYPE_wsdl__service
#define SOAP_TYPE_wsdl__service (447)
/* Type wsdl__service is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'wsdl:service': */
class SOAP_CMAC wsdl__service {
      public:
        /// optional attribute 'name' of XSD type 'xsd:NMTOKEN'
        char *name;
        /// optional attribute 'interface' of XSD type 'xsd:QName'
        char *interface_;
        /// Optional element 'wsdl:documentation' of XSD type 'xsd:string'
        char *documentation;
        /// Optional element 'wsp:Policy' of XSD type 'wsp:Policy'
        std::vector<wsp__Policy> wsp__Policy_;
        /// Optional element 'wsp:PolicyReference' of XSD type 'wsp:PolicyReference'
        std::vector<wsp__PolicyReference> wsp__PolicyReference_;
        /// Optional element 'wsdl:port' of XSD type 'wsdl:port'
        std::vector<wsdl__port> port;
        /// Optional element 'wsdl:endpoint' of XSD type 'wsdl:port'
        std::vector<wsdl__port> endpoint;
        int traverse(wsdl__definitions &_param_1);
      public:
        /// Return unique type id SOAP_TYPE_wsdl__service
        virtual int soap_type(void) const { return SOAP_TYPE_wsdl__service; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsdl__service, default initialized and not managed by a soap context
        virtual wsdl__service *soap_alloc(void) const { return SOAP_NEW(wsdl__service); }
      public:
        /// Constructor with initializations
        wsdl__service()
        {
          name = (char *)0;
          interface_ = (char *)0;
          documentation = (char *)0;
        }
        virtual ~wsdl__service() { }
        /// Friend allocator used by soap_new_wsdl__service(struct soap*, int)
        friend SOAP_FMAC1 wsdl__service * SOAP_FMAC2 wsdl_instantiate_wsdl__service(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap.h:42 */
#ifndef SOAP_TYPE_wsdl__definitions
#define SOAP_TYPE_wsdl__definitions (228)
/* Type wsdl__definitions is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'wsdl:definitions': */
class SOAP_CMAC wsdl__definitions {
      public:
        /// optional attribute 'name' of XSD type 'xsd:NMTOKEN'
        char *name;
        /// optional attribute 'targetNamespace' of XSD type 'xsd:anyURI'
        char *targetNamespace;	///< default = (char*)""
        /// optional attribute 'version' of XSD type 'xsd:NMTOKEN'
        char *version;
        /// Optional element 'wsdl:import' of XSD type 'wsdl:import'
        std::vector<wsdl__import> import;
        /// Optional element 'wsdl:documentation' of XSD type 'xsd:string'
        char *documentation;
        /// Optional element 'wsdl:types' of XSD type 'wsdl:types'
        wsdl__types *types;
        /// Optional element 'wsdl:message' of XSD type 'wsdl:message'
        std::vector<wsdl__message> message;
        /// Optional element 'wsdl:portType' of XSD type 'wsdl:portType'
        std::vector<wsdl__portType> portType;
        /// Optional element 'wsdl:interface' of XSD type 'wsdl:portType'
        std::vector<wsdl__portType> interface_;
        /// Optional element 'wsdl:binding' of XSD type 'wsdl:binding'
        std::vector<wsdl__binding> binding;
        /// Optional element 'wsdl:service' of XSD type 'wsdl:service'
        std::vector<wsdl__service> service;
        /// Optional element 'wsp:UsingPolicy' of XSD type 'xsd:string'
        char *wsp__UsingPolicy;
        /// Optional element 'wsp:Policy' of XSD type 'wsp:Policy'
        std::vector<wsp__Policy> wsp__Policy_;
        /// Optional element 'plnk:partnerLinkType' of XSD type 'plnk:tPartnerLinkType'
        std::vector<plnk__tPartnerLinkType> plnk__partnerLinkType;
        /// Optional element 'vprop:property' of XSD type 'vprop:tProperty'
        std::vector<vprop__tProperty> vprop__property;
        /// Optional element 'vprop:propertyAlias' of XSD type 'vprop:tPropertyAlias'
        std::vector<vprop__tPropertyAlias> vprop__propertyAlias;
        /// Optional element 'gwsdl:portType' of XSD type 'gwsdl:portType'
        std::vector<gwsdl__portType> gwsdl__portType_;
        /// Context that manages this object
        struct soap *soap;
      private:
        /// Not serialized
        bool soap12;
        /// Not serialized
        bool updated;
        /// Not serialized
        char *location;
        /// Not serialized
        int redirs;
        /// Not serialized
        SetOfString builtinTypeSet;
        /// Not serialized
        SetOfString builtinElementSet;
        /// Not serialized
        SetOfString builtinAttributeSet;
      public:
        wsdl__definitions();
        wsdl__definitions(struct soap *_param_1);
        wsdl__definitions(struct soap *_param_1, const char *_param_2, const char *_param_3);
        virtual ~wsdl__definitions();
        int get(struct soap *_param_1);
        int preprocess();
        int traverse();
        int read(int _param_1, char **_param_2);
        int read(const char *cwd, const char *_param_1);
        const char *sourceLocation();
        int error();
        bool is_updated();
        void print_fault();
        void builtinType(const char *_param_1);
        void builtinTypes(const SetOfString &_param_1);
        void builtinElement(const char *_param_1);
        void builtinElements(const SetOfString &_param_1);
        void builtinAttribute(const char *_param_1);
        void builtinAttributes(const SetOfString &_param_1);
        const SetOfString &builtinTypes() const;
        const SetOfString &builtinElements() const;
        const SetOfString &builtinAttributes() const;
        friend ostream &operator<<(ostream &_param_1, const wsdl__definitions &_param_2);
        friend istream &operator>>(istream &_param_1, wsdl__definitions &_param_2);
      public:
        /// Return unique type id SOAP_TYPE_wsdl__definitions
        virtual int soap_type(void) const { return SOAP_TYPE_wsdl__definitions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsdl__definitions, default initialized and not managed by a soap context
        virtual wsdl__definitions *soap_alloc(void) const { return SOAP_NEW(wsdl__definitions); }
        /// Friend allocator used by soap_new_wsdl__definitions(struct soap*, int)
        friend SOAP_FMAC1 wsdl__definitions * SOAP_FMAC2 wsdl_instantiate_wsdl__definitions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ./wsdl.h:392 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (489)
/* SOAP_ENV__Header: */
struct SOAP_ENV__Header {
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Header */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Header; }
        /** Constructor with member initializations */
        SOAP_ENV__Header()
        {
        }
        /** Friend allocator used by soap_new_SOAP_ENV__Header(struct soap*, int) */
        friend SOAP_FMAC1 SOAP_ENV__Header * SOAP_FMAC2 wsdl_instantiate_SOAP_ENV__Header(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* ./wsdl.h:392 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (490)
/* Type SOAP_ENV__Code is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* SOAP_ENV__Code: */
struct SOAP_ENV__Code {
      public:
        /** Optional element 'SOAP-ENV:Value' of XSD type 'xsd:QName' */
        char *SOAP_ENV__Value;
        /** Optional element 'SOAP-ENV:Subcode' of XSD type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Subcode;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Code */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Code; }
        /** Constructor with member initializations */
        SOAP_ENV__Code()
        {
          SOAP_ENV__Value = (char *)0;
          SOAP_ENV__Subcode = (struct SOAP_ENV__Code *)0;
        }
        /** Friend allocator used by soap_new_SOAP_ENV__Code(struct soap*, int) */
        friend SOAP_FMAC1 SOAP_ENV__Code * SOAP_FMAC2 wsdl_instantiate_SOAP_ENV__Code(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* ./wsdl.h:392 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (492)
/* SOAP_ENV__Detail: */
struct SOAP_ENV__Detail {
      public:
        char *__any;
        /** Any type of element 'fault' assigned to fault with its SOAP_TYPE_T assigned to __type */
        /** Do not create a cyclic data structure throught this member unless SOAP encoding or SOAP_XML_GRAPH are used for id-ref serialization */
        int __type;
        void *fault;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Detail */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Detail; }
        /** Constructor with member initializations */
        SOAP_ENV__Detail()
        {
          __any = (char *)0;
          __type = 0;
          fault = NULL;
        }
        /** Friend allocator used by soap_new_SOAP_ENV__Detail(struct soap*, int) */
        friend SOAP_FMAC1 SOAP_ENV__Detail * SOAP_FMAC2 wsdl_instantiate_SOAP_ENV__Detail(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* ./wsdl.h:392 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (493)
/* SOAP_ENV__Reason: */
struct SOAP_ENV__Reason {
      public:
        /** Optional element 'SOAP-ENV:Text' of XSD type 'xsd:string' */
        char *SOAP_ENV__Text;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Reason */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Reason; }
        /** Constructor with member initializations */
        SOAP_ENV__Reason()
        {
          SOAP_ENV__Text = (char *)0;
        }
        /** Friend allocator used by soap_new_SOAP_ENV__Reason(struct soap*, int) */
        friend SOAP_FMAC1 SOAP_ENV__Reason * SOAP_FMAC2 wsdl_instantiate_SOAP_ENV__Reason(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* ./wsdl.h:392 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (494)
/* SOAP_ENV__Fault: */
struct SOAP_ENV__Fault {
      public:
        /** Optional element 'faultcode' of XSD type 'xsd:QName' */
        char *faultcode;
        /** Optional element 'faultstring' of XSD type 'xsd:string' */
        char *faultstring;
        /** Optional element 'faultactor' of XSD type 'xsd:string' */
        char *faultactor;
        /** Optional element 'detail' of XSD type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *detail;
        /** Optional element 'SOAP-ENV:Code' of XSD type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Code;
        /** Optional element 'SOAP-ENV:Reason' of XSD type 'SOAP-ENV:Reason' */
        struct SOAP_ENV__Reason *SOAP_ENV__Reason;
        /** Optional element 'SOAP-ENV:Node' of XSD type 'xsd:string' */
        char *SOAP_ENV__Node;
        /** Optional element 'SOAP-ENV:Role' of XSD type 'xsd:string' */
        char *SOAP_ENV__Role;
        /** Optional element 'SOAP-ENV:Detail' of XSD type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *SOAP_ENV__Detail;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Fault */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Fault; }
        /** Constructor with member initializations */
        SOAP_ENV__Fault()
        {
          faultcode = (char *)0;
          faultstring = (char *)0;
          faultactor = (char *)0;
          detail = (struct SOAP_ENV__Detail *)0;
          SOAP_ENV__Code = (struct SOAP_ENV__Code *)0;
          SOAP_ENV__Reason = (struct SOAP_ENV__Reason *)0;
          SOAP_ENV__Node = (char *)0;
          SOAP_ENV__Role = (char *)0;
          SOAP_ENV__Detail = (struct SOAP_ENV__Detail *)0;
        }
        /** Friend allocator used by soap_new_SOAP_ENV__Fault(struct soap*, int) */
        friend SOAP_FMAC1 SOAP_ENV__Fault * SOAP_FMAC2 wsdl_instantiate_SOAP_ENV__Fault(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/


/* stlvector.h:53 */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
typedef char *_QName;
#endif

/* stlvector.h:53 */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (6)
typedef char *_XML;
#endif

/* imports.h:37 */
#ifndef SOAP_TYPE_xsd__anyURI
#define SOAP_TYPE_xsd__anyURI (8)
typedef char *xsd__anyURI;
#endif

/* imports.h:38 */
#ifndef SOAP_TYPE_xsd__ID
#define SOAP_TYPE_xsd__ID (9)
typedef char *xsd__ID;
#endif

/* imports.h:39 */
#ifndef SOAP_TYPE_xsd__NCName
#define SOAP_TYPE_xsd__NCName (10)
typedef char *xsd__NCName;
#endif

/* imports.h:40 */
#ifndef SOAP_TYPE_xsd__NMTOKEN
#define SOAP_TYPE_xsd__NMTOKEN (11)
typedef char *xsd__NMTOKEN;
#endif

/* imports.h:41 */
#ifndef SOAP_TYPE_xsd__NMTOKENS
#define SOAP_TYPE_xsd__NMTOKENS (12)
typedef char *xsd__NMTOKENS;
#endif

/* imports.h:42 */
#ifndef SOAP_TYPE_xsd__QName
#define SOAP_TYPE_xsd__QName (13)
typedef char *xsd__QName;
#endif

/* imports.h:43 */
#ifndef SOAP_TYPE_xsd__string
#define SOAP_TYPE_xsd__string (14)
typedef char *xsd__string;
#endif

/* imports.h:44 */
#ifndef SOAP_TYPE_xsd__boolean
#define SOAP_TYPE_xsd__boolean (16)
typedef bool xsd__boolean;
#endif

/* schema.h:161 */
#ifndef SOAP_TYPE_xs__namespaceList
#define SOAP_TYPE_xs__namespaceList (79)
typedef char *xs__namespaceList;
#endif

/******************************************************************************\
 *                                                                            *
 * Serializable Types                                                         *
 *                                                                            *
\******************************************************************************/


/* char has binding name 'byte' for type 'xsd:byte' */
#ifndef SOAP_TYPE_byte
#define SOAP_TYPE_byte (3)
#endif

/* int has binding name 'int' for type 'xsd:int' */
#ifndef SOAP_TYPE_int
#define SOAP_TYPE_int (1)
#endif

/* enum sd__mutability has binding name 'sd__mutability' for type 'sd:mutability' */
#ifndef SOAP_TYPE_sd__mutability
#define SOAP_TYPE_sd__mutability (278)
#endif

/* enum soap__useChoice has binding name 'soap__useChoice' for type 'soap:useChoice' */
#ifndef SOAP_TYPE_soap__useChoice
#define SOAP_TYPE_soap__useChoice (235)
#endif

/* enum soap__styleChoice has binding name 'soap__styleChoice' for type 'soap:styleChoice' */
#ifndef SOAP_TYPE_soap__styleChoice
#define SOAP_TYPE_soap__styleChoice (231)
#endif

/* enum xs__processContents has binding name 'xs__processContents' for type 'xs:processContents' */
#ifndef SOAP_TYPE_xs__processContents
#define SOAP_TYPE_xs__processContents (78)
#endif

/* enum xs__attribute_use has binding name 'xs__attribute_use' for type 'xs:attribute-use' */
#ifndef SOAP_TYPE_xs__attribute_use
#define SOAP_TYPE_xs__attribute_use (63)
#endif

/* enum xs__formChoice has binding name 'xs__formChoice' for type 'xs:formChoice' */
#ifndef SOAP_TYPE_xs__formChoice
#define SOAP_TYPE_xs__formChoice (35)
#endif

/* xsd__boolean has binding name 'xsd__boolean' for type 'xsd:boolean' */
#ifndef SOAP_TYPE_xsd__boolean
#define SOAP_TYPE_xsd__boolean (16)
#endif

/* bool has binding name 'bool' for type 'xsd:boolean' */
#ifndef SOAP_TYPE_bool
#define SOAP_TYPE_bool (15)
#endif

/* wsdl__service has binding name 'wsdl__service' for type 'wsdl:service' */
#ifndef SOAP_TYPE_wsdl__service
#define SOAP_TYPE_wsdl__service (447)
#endif

/* wsdl__port has binding name 'wsdl__port' for type 'wsdl:port' */
#ifndef SOAP_TYPE_wsdl__port
#define SOAP_TYPE_wsdl__port (437)
#endif

/* wsdl__binding has binding name 'wsdl__binding' for type 'wsdl:binding' */
#ifndef SOAP_TYPE_wsdl__binding
#define SOAP_TYPE_wsdl__binding (429)
#endif

/* wsdl__ext_operation has binding name 'wsdl__ext_operation' for type 'wsdl:ext-operation' */
#ifndef SOAP_TYPE_wsdl__ext_operation
#define SOAP_TYPE_wsdl__ext_operation (419)
#endif

/* wsdl__ext_fault has binding name 'wsdl__ext_fault' for type 'wsdl:ext-fault' */
#ifndef SOAP_TYPE_wsdl__ext_fault
#define SOAP_TYPE_wsdl__ext_fault (410)
#endif

/* wsdl__ext_ioput has binding name 'wsdl__ext_ioput' for type 'wsdl:ext-ioput' */
#ifndef SOAP_TYPE_wsdl__ext_ioput
#define SOAP_TYPE_wsdl__ext_ioput (401)
#endif

/* wsdl__fault has binding name 'wsdl__fault' for type 'wsdl:fault' */
#ifndef SOAP_TYPE_wsdl__fault
#define SOAP_TYPE_wsdl__fault (385)
#endif

/* wsdl__ioput has binding name 'wsdl__ioput' for type 'wsdl:ioput' */
#ifndef SOAP_TYPE_wsdl__ioput
#define SOAP_TYPE_wsdl__ioput (378)
#endif

/* wsdl__types has binding name 'wsdl__types' for type 'wsdl:types' */
#ifndef SOAP_TYPE_wsdl__types
#define SOAP_TYPE_wsdl__types (362)
#endif

/* wsdl__import has binding name 'wsdl__import' for type 'wsdl:import' */
#ifndef SOAP_TYPE_wsdl__import
#define SOAP_TYPE_wsdl__import (354)
#endif

/* vprop__tPropertyAlias has binding name 'vprop__tPropertyAlias' for type 'vprop:tPropertyAlias' */
#ifndef SOAP_TYPE_vprop__tPropertyAlias
#define SOAP_TYPE_vprop__tPropertyAlias (349)
#endif

/* vprop__tProperty has binding name 'vprop__tProperty' for type 'vprop:tProperty' */
#ifndef SOAP_TYPE_vprop__tProperty
#define SOAP_TYPE_vprop__tProperty (347)
#endif

/* vprop__tQuery has binding name 'vprop__tQuery' for type 'vprop:tQuery' */
#ifndef SOAP_TYPE_vprop__tQuery
#define SOAP_TYPE_vprop__tQuery (346)
#endif

/* plnk__tRole has binding name 'plnk__tRole' for type 'plnk:tRole' */
#ifndef SOAP_TYPE_plnk__tRole
#define SOAP_TYPE_plnk__tRole (335)
#endif

/* plnk__tPartnerLinkType has binding name 'plnk__tPartnerLinkType' for type 'plnk:tPartnerLinkType' */
#ifndef SOAP_TYPE_plnk__tPartnerLinkType
#define SOAP_TYPE_plnk__tPartnerLinkType (334)
#endif

/* wsdl__portType has binding name 'wsdl__portType' for type 'wsdl:portType' */
#ifndef SOAP_TYPE_wsdl__portType
#define SOAP_TYPE_wsdl__portType (333)
#endif

/* wsp__PolicyAttachment has binding name 'wsp__PolicyAttachment' for type 'wsp:PolicyAttachment' */
#ifndef SOAP_TYPE_wsp__PolicyAttachment
#define SOAP_TYPE_wsp__PolicyAttachment (330)
#endif

/* wsp__AppliesTo has binding name 'wsp__AppliesTo' for type 'wsp:AppliesTo' */
#ifndef SOAP_TYPE_wsp__AppliesTo
#define SOAP_TYPE_wsp__AppliesTo (329)
#endif

/* wsp__Attachment has binding name 'wsp__Attachment' for type 'wsp:Attachment' */
#ifndef SOAP_TYPE_wsp__Attachment
#define SOAP_TYPE_wsp__Attachment (328)
#endif

/* wsrmp5__RMAssertion has binding name 'wsrmp5__RMAssertion' for type 'wsrmp5:RMAssertion' */
#ifndef SOAP_TYPE_wsrmp5__RMAssertion
#define SOAP_TYPE_wsrmp5__RMAssertion (313)
#endif

/* wsrmp5__Timeout has binding name 'wsrmp5__Timeout' for type 'wsrmp5:Timeout' */
#ifndef SOAP_TYPE_wsrmp5__Timeout
#define SOAP_TYPE_wsrmp5__Timeout (312)
#endif

/* wsrmp__RMAssertion has binding name 'wsrmp__RMAssertion' for type 'wsrmp:RMAssertion' */
#ifndef SOAP_TYPE_wsrmp__RMAssertion
#define SOAP_TYPE_wsrmp__RMAssertion (310)
#endif

/* wsrmp__Timeout has binding name 'wsrmp__Timeout' for type 'wsrmp:Timeout' */
#ifndef SOAP_TYPE_wsrmp__Timeout
#define SOAP_TYPE_wsrmp__Timeout (309)
#endif

/* sp__Token has binding name 'sp__Token' for type 'sp:Token' */
#ifndef SOAP_TYPE_sp__Token
#define SOAP_TYPE_sp__Token (306)
#endif

/* sp__Elements has binding name 'sp__Elements' for type 'sp:Elements' */
#ifndef SOAP_TYPE_sp__Elements
#define SOAP_TYPE_sp__Elements (304)
#endif

/* sp__Parts has binding name 'sp__Parts' for type 'sp:Parts' */
#ifndef SOAP_TYPE_sp__Parts
#define SOAP_TYPE_sp__Parts (302)
#endif

/* sp__Header has binding name 'sp__Header' for type 'sp:Header' */
#ifndef SOAP_TYPE_sp__Header
#define SOAP_TYPE_sp__Header (301)
#endif

/* wst__Claims has binding name 'wst__Claims' for type 'wst:Claims' */
#ifndef SOAP_TYPE_wst__Claims
#define SOAP_TYPE_wst__Claims (300)
#endif

/* wsp__Assertion has binding name 'wsp__Assertion' for type 'wsp:Assertion' */
#ifndef SOAP_TYPE_wsp__Assertion
#define SOAP_TYPE_wsp__Assertion (298)
#endif

/* wsp__PolicyReference has binding name 'wsp__PolicyReference' for type 'wsp:PolicyReference' */
#ifndef SOAP_TYPE_wsp__PolicyReference
#define SOAP_TYPE_wsp__PolicyReference (292)
#endif

/* wsp__Content has binding name 'wsp__Content' for type 'wsp:Content' */
#ifndef SOAP_TYPE_wsp__Content
#define SOAP_TYPE_wsp__Content (289)
#endif

/* wsp__Policy has binding name 'wsp__Policy' for type 'wsp:Policy' */
#ifndef SOAP_TYPE_wsp__Policy
#define SOAP_TYPE_wsp__Policy (288)
#endif

/* wsa__EndpointReferenceType has binding name 'wsa__EndpointReferenceType' for type 'wsa:EndpointReferenceType' */
#ifndef SOAP_TYPE_wsa__EndpointReferenceType
#define SOAP_TYPE_wsa__EndpointReferenceType (287)
#endif

/* gwsdl__portType has binding name 'gwsdl__portType' for type 'gwsdl:portType' */
#ifndef SOAP_TYPE_gwsdl__portType
#define SOAP_TYPE_gwsdl__portType (282)
#endif

/* sd__staticServiceDataValues has binding name 'sd__staticServiceDataValues' for type 'sd:staticServiceDataValues' */
#ifndef SOAP_TYPE_sd__staticServiceDataValues
#define SOAP_TYPE_sd__staticServiceDataValues (280)
#endif

/* sd__serviceData has binding name 'sd__serviceData' for type 'sd:serviceData' */
#ifndef SOAP_TYPE_sd__serviceData
#define SOAP_TYPE_sd__serviceData (279)
#endif

/* wsdl__operation has binding name 'wsdl__operation' for type 'wsdl:operation' */
#ifndef SOAP_TYPE_wsdl__operation
#define SOAP_TYPE_wsdl__operation (277)
#endif

/* whttp__header has binding name 'whttp__header' for type 'whttp:header' */
#ifndef SOAP_TYPE_whttp__header
#define SOAP_TYPE_whttp__header (276)
#endif

/* http__operation has binding name 'http__operation' for type 'http:operation' */
#ifndef SOAP_TYPE_http__operation
#define SOAP_TYPE_http__operation (275)
#endif

/* http__binding has binding name 'http__binding' for type 'http:binding' */
#ifndef SOAP_TYPE_http__binding
#define SOAP_TYPE_http__binding (274)
#endif

/* http__address has binding name 'http__address' for type 'http:address' */
#ifndef SOAP_TYPE_http__address
#define SOAP_TYPE_http__address (273)
#endif

/* dime__message has binding name 'dime__message' for type 'dime:message' */
#ifndef SOAP_TYPE_dime__message
#define SOAP_TYPE_dime__message (272)
#endif

/* mime__mimeXml has binding name 'mime__mimeXml' for type 'mime:mimeXml' */
#ifndef SOAP_TYPE_mime__mimeXml
#define SOAP_TYPE_mime__mimeXml (271)
#endif

/* mime__multipartRelated has binding name 'mime__multipartRelated' for type 'mime:multipartRelated' */
#ifndef SOAP_TYPE_mime__multipartRelated
#define SOAP_TYPE_mime__multipartRelated (268)
#endif

/* mime__part has binding name 'mime__part' for type 'mime:part' */
#ifndef SOAP_TYPE_mime__part
#define SOAP_TYPE_mime__part (263)
#endif

/* mime__content has binding name 'mime__content' for type 'mime:content' */
#ifndef SOAP_TYPE_mime__content
#define SOAP_TYPE_mime__content (262)
#endif

/* wsoap__header has binding name 'wsoap__header' for type 'wsoap:header' */
#ifndef SOAP_TYPE_wsoap__header
#define SOAP_TYPE_wsoap__header (258)
#endif

/* wsoap__module has binding name 'wsoap__module' for type 'wsoap:module' */
#ifndef SOAP_TYPE_wsoap__module
#define SOAP_TYPE_wsoap__module (257)
#endif

/* soap__address has binding name 'soap__address' for type 'soap:address' */
#ifndef SOAP_TYPE_soap__address
#define SOAP_TYPE_soap__address (256)
#endif

/* soap__header has binding name 'soap__header' for type 'soap:header' */
#ifndef SOAP_TYPE_soap__header
#define SOAP_TYPE_soap__header (249)
#endif

/* soap__headerfault has binding name 'soap__headerfault' for type 'soap:headerfault' */
#ifndef SOAP_TYPE_soap__headerfault
#define SOAP_TYPE_soap__headerfault (238)
#endif

/* soap__fault has binding name 'soap__fault' for type 'soap:fault' */
#ifndef SOAP_TYPE_soap__fault
#define SOAP_TYPE_soap__fault (237)
#endif

/* soap__body has binding name 'soap__body' for type 'soap:body' */
#ifndef SOAP_TYPE_soap__body
#define SOAP_TYPE_soap__body (236)
#endif

/* soap__operation has binding name 'soap__operation' for type 'soap:operation' */
#ifndef SOAP_TYPE_soap__operation
#define SOAP_TYPE_soap__operation (234)
#endif

/* soap__binding has binding name 'soap__binding' for type 'soap:binding' */
#ifndef SOAP_TYPE_soap__binding
#define SOAP_TYPE_soap__binding (232)
#endif

/* wsdl__part has binding name 'wsdl__part' for type 'wsdl:part' */
#ifndef SOAP_TYPE_wsdl__part
#define SOAP_TYPE_wsdl__part (230)
#endif

/* wsdl__message has binding name 'wsdl__message' for type 'wsdl:message' */
#ifndef SOAP_TYPE_wsdl__message
#define SOAP_TYPE_wsdl__message (229)
#endif

/* wsdl__definitions has binding name 'wsdl__definitions' for type 'wsdl:definitions' */
#ifndef SOAP_TYPE_wsdl__definitions
#define SOAP_TYPE_wsdl__definitions (228)
#endif

/* xs__redefine has binding name 'xs__redefine' for type 'xs:redefine' */
#ifndef SOAP_TYPE_xs__redefine
#define SOAP_TYPE_xs__redefine (183)
#endif

/* xs__override has binding name 'xs__override' for type 'xs:override' */
#ifndef SOAP_TYPE_xs__override
#define SOAP_TYPE_xs__override (175)
#endif

/* xs__include has binding name 'xs__include' for type 'xs:include' */
#ifndef SOAP_TYPE_xs__include
#define SOAP_TYPE_xs__include (169)
#endif

/* xs__import has binding name 'xs__import' for type 'xs:import' */
#ifndef SOAP_TYPE_xs__import
#define SOAP_TYPE_xs__import (164)
#endif

/* xs__complexContent has binding name 'xs__complexContent' for type 'xs:complexContent' */
#ifndef SOAP_TYPE_xs__complexContent
#define SOAP_TYPE_xs__complexContent (155)
#endif

/* xs__whiteSpace has binding name 'xs__whiteSpace' for type 'xs:whiteSpace' */
#ifndef SOAP_TYPE_xs__whiteSpace
#define SOAP_TYPE_xs__whiteSpace (137)
#endif

/* xs__length has binding name 'xs__length' for type 'xs:length' */
#ifndef SOAP_TYPE_xs__length
#define SOAP_TYPE_xs__length (136)
#endif

/* xs__simpleContent has binding name 'xs__simpleContent' for type 'xs:simpleContent' */
#ifndef SOAP_TYPE_xs__simpleContent
#define SOAP_TYPE_xs__simpleContent (118)
#endif

/* xs__pattern has binding name 'xs__pattern' for type 'xs:pattern' */
#ifndef SOAP_TYPE_xs__pattern
#define SOAP_TYPE_xs__pattern (116)
#endif

/* xs__enumeration has binding name 'xs__enumeration' for type 'xs:enumeration' */
#ifndef SOAP_TYPE_xs__enumeration
#define SOAP_TYPE_xs__enumeration (114)
#endif

/* xs__attributeGroup has binding name 'xs__attributeGroup' for type 'xs:attributeGroup' */
#ifndef SOAP_TYPE_xs__attributeGroup
#define SOAP_TYPE_xs__attributeGroup (102)
#endif

/* xs__anyAttribute has binding name 'xs__anyAttribute' for type 'xs:anyAttribute' */
#ifndef SOAP_TYPE_xs__anyAttribute
#define SOAP_TYPE_xs__anyAttribute (101)
#endif

/* xs__contents has binding name 'xs__contents' for type 'xs:contents' */
#ifndef SOAP_TYPE_xs__contents
#define SOAP_TYPE_xs__contents (82)
#endif

/* xs__any has binding name 'xs__any' for type 'xs:any' */
#ifndef SOAP_TYPE_xs__any
#define SOAP_TYPE_xs__any (80)
#endif

/* xs__all has binding name 'xs__all' for type 'xs:all' */
#ifndef SOAP_TYPE_xs__all
#define SOAP_TYPE_xs__all (75)
#endif

/* xs__attribute has binding name 'xs__attribute' for type 'xs:attribute' */
#ifndef SOAP_TYPE_xs__attribute
#define SOAP_TYPE_xs__attribute (64)
#endif

/* xs__element has binding name 'xs__element' for type 'xs:element' */
#ifndef SOAP_TYPE_xs__element
#define SOAP_TYPE_xs__element (36)
#endif

/* xs__alternative has binding name 'xs__alternative' for type 'xs:alternative' */
#ifndef SOAP_TYPE_xs__alternative
#define SOAP_TYPE_xs__alternative (34)
#endif

/* xs__assert has binding name 'xs__assert' for type 'xs:assert' */
#ifndef SOAP_TYPE_xs__assert
#define SOAP_TYPE_xs__assert (32)
#endif

/* xs__annotation has binding name 'xs__annotation' for type 'xs:annotation' */
#ifndef SOAP_TYPE_xs__annotation
#define SOAP_TYPE_xs__annotation (30)
#endif

/* xs__union has binding name 'xs__union' for type 'xs:union' */
#ifndef SOAP_TYPE_xs__union
#define SOAP_TYPE_xs__union (29)
#endif

/* xs__list has binding name 'xs__list' for type 'xs:list' */
#ifndef SOAP_TYPE_xs__list
#define SOAP_TYPE_xs__list (28)
#endif

/* xs__group has binding name 'xs__group' for type 'xs:group' */
#ifndef SOAP_TYPE_xs__group
#define SOAP_TYPE_xs__group (27)
#endif

/* xs__seqchoice has binding name 'xs__seqchoice' for type 'xs:seqchoice' */
#ifndef SOAP_TYPE_xs__seqchoice
#define SOAP_TYPE_xs__seqchoice (26)
#endif

/* xs__restriction has binding name 'xs__restriction' for type 'xs:restriction' */
#ifndef SOAP_TYPE_xs__restriction
#define SOAP_TYPE_xs__restriction (25)
#endif

/* xs__extension has binding name 'xs__extension' for type 'xs:extension' */
#ifndef SOAP_TYPE_xs__extension
#define SOAP_TYPE_xs__extension (24)
#endif

/* xs__complexType has binding name 'xs__complexType' for type 'xs:complexType' */
#ifndef SOAP_TYPE_xs__complexType
#define SOAP_TYPE_xs__complexType (23)
#endif

/* xs__simpleType has binding name 'xs__simpleType' for type 'xs:simpleType' */
#ifndef SOAP_TYPE_xs__simpleType
#define SOAP_TYPE_xs__simpleType (22)
#endif

/* xs__schema has binding name 'xs__schema' for type 'xs:schema' */
#ifndef SOAP_TYPE_xs__schema
#define SOAP_TYPE_xs__schema (21)
#endif

/* struct SOAP_ENV__Fault has binding name 'SOAP_ENV__Fault' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (494)
#endif

/* struct SOAP_ENV__Reason has binding name 'SOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (493)
#endif

/* struct SOAP_ENV__Detail has binding name 'SOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (492)
#endif

/* struct SOAP_ENV__Code has binding name 'SOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (490)
#endif

/* struct SOAP_ENV__Header has binding name 'SOAP_ENV__Header' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (489)
#endif

/* struct SOAP_ENV__Reason * has binding name 'PointerToSOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Reason
#define SOAP_TYPE_PointerToSOAP_ENV__Reason (496)
#endif

/* struct SOAP_ENV__Detail * has binding name 'PointerToSOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Detail
#define SOAP_TYPE_PointerToSOAP_ENV__Detail (495)
#endif

/* struct SOAP_ENV__Code * has binding name 'PointerToSOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Code
#define SOAP_TYPE_PointerToSOAP_ENV__Code (491)
#endif

/* wsdl__types * has binding name 'PointerTowsdl__types' for type 'wsdl:types' */
#ifndef SOAP_TYPE_PointerTowsdl__types
#define SOAP_TYPE_PointerTowsdl__types (451)
#endif

/* wsdl__binding * has binding name 'PointerTowsdl__binding' for type 'wsdl:binding' */
#ifndef SOAP_TYPE_PointerTowsdl__binding
#define SOAP_TYPE_PointerTowsdl__binding (441)
#endif

/* http__address * has binding name 'PointerTohttp__address' for type 'http:address' */
#ifndef SOAP_TYPE_PointerTohttp__address
#define SOAP_TYPE_PointerTohttp__address (440)
#endif

/* soap__address * has binding name 'PointerTosoap__address' for type 'soap:address' */
#ifndef SOAP_TYPE_PointerTosoap__address
#define SOAP_TYPE_PointerTosoap__address (439)
#endif

/* char ** has binding name 'PointerToxsd__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_PointerToxsd__string
#define SOAP_TYPE_PointerToxsd__string (438)
#endif

/* http__binding * has binding name 'PointerTohttp__binding' for type 'http:binding' */
#ifndef SOAP_TYPE_PointerTohttp__binding
#define SOAP_TYPE_PointerTohttp__binding (431)
#endif

/* soap__binding * has binding name 'PointerTosoap__binding' for type 'soap:binding' */
#ifndef SOAP_TYPE_PointerTosoap__binding
#define SOAP_TYPE_PointerTosoap__binding (430)
#endif

/* wsdl__ext_ioput * has binding name 'PointerTowsdl__ext_ioput' for type 'wsdl:ext-ioput' */
#ifndef SOAP_TYPE_PointerTowsdl__ext_ioput
#define SOAP_TYPE_PointerTowsdl__ext_ioput (422)
#endif

/* http__operation * has binding name 'PointerTohttp__operation' for type 'http:operation' */
#ifndef SOAP_TYPE_PointerTohttp__operation
#define SOAP_TYPE_PointerTohttp__operation (421)
#endif

/* soap__operation * has binding name 'PointerTosoap__operation' for type 'soap:operation' */
#ifndef SOAP_TYPE_PointerTosoap__operation
#define SOAP_TYPE_PointerTosoap__operation (420)
#endif

/* wsdl__fault * has binding name 'PointerTowsdl__fault' for type 'wsdl:fault' */
#ifndef SOAP_TYPE_PointerTowsdl__fault
#define SOAP_TYPE_PointerTowsdl__fault (412)
#endif

/* soap__fault * has binding name 'PointerTosoap__fault' for type 'soap:fault' */
#ifndef SOAP_TYPE_PointerTosoap__fault
#define SOAP_TYPE_PointerTosoap__fault (411)
#endif

/* mime__mimeXml * has binding name 'PointerTomime__mimeXml' for type 'mime:mimeXml' */
#ifndef SOAP_TYPE_PointerTomime__mimeXml
#define SOAP_TYPE_PointerTomime__mimeXml (405)
#endif

/* mime__content * has binding name 'PointerTomime__content' for type 'mime:content' */
#ifndef SOAP_TYPE_PointerTomime__content
#define SOAP_TYPE_PointerTomime__content (404)
#endif

/* mime__multipartRelated * has binding name 'PointerTomime__multipartRelated' for type 'mime:multipartRelated' */
#ifndef SOAP_TYPE_PointerTomime__multipartRelated
#define SOAP_TYPE_PointerTomime__multipartRelated (403)
#endif

/* dime__message * has binding name 'PointerTodime__message' for type 'dime:message' */
#ifndef SOAP_TYPE_PointerTodime__message
#define SOAP_TYPE_PointerTodime__message (402)
#endif

/* wsdl__ioput * has binding name 'PointerTowsdl__ioput' for type 'wsdl:ioput' */
#ifndef SOAP_TYPE_PointerTowsdl__ioput
#define SOAP_TYPE_PointerTowsdl__ioput (392)
#endif

/* wsdl__definitions * has binding name 'PointerTowsdl__definitions' for type 'wsdl:definitions' */
#ifndef SOAP_TYPE_PointerTowsdl__definitions
#define SOAP_TYPE_PointerTowsdl__definitions (355)
#endif

/* vprop__tProperty * has binding name 'PointerTovprop__tProperty' for type 'vprop:tProperty' */
#ifndef SOAP_TYPE_PointerTovprop__tProperty
#define SOAP_TYPE_PointerTovprop__tProperty (351)
#endif

/* vprop__tQuery * has binding name 'PointerTovprop__tQuery' for type 'vprop:tQuery' */
#ifndef SOAP_TYPE_PointerTovprop__tQuery
#define SOAP_TYPE_PointerTovprop__tQuery (350)
#endif

/* plnk__tPartnerLinkType * has binding name 'PointerToplnk__tPartnerLinkType' for type 'plnk:tPartnerLinkType' */
#ifndef SOAP_TYPE_PointerToplnk__tPartnerLinkType
#define SOAP_TYPE_PointerToplnk__tPartnerLinkType (337)
#endif

/* wsdl__portType * has binding name 'PointerTowsdl__portType' for type 'wsdl:portType' */
#ifndef SOAP_TYPE_PointerTowsdl__portType
#define SOAP_TYPE_PointerTowsdl__portType (336)
#endif

/* wsp__AppliesTo * has binding name 'PointerTowsp__AppliesTo' for type 'wsp:AppliesTo' */
#ifndef SOAP_TYPE_PointerTowsp__AppliesTo
#define SOAP_TYPE_PointerTowsp__AppliesTo (331)
#endif

/* wsrmp5__RMAssertion * has binding name 'PointerTowsrmp5__RMAssertion' for type 'wsrmp5:RMAssertion' */
#ifndef SOAP_TYPE_PointerTowsrmp5__RMAssertion
#define SOAP_TYPE_PointerTowsrmp5__RMAssertion (322)
#endif

/* wsrmp__RMAssertion * has binding name 'PointerTowsrmp__RMAssertion' for type 'wsrmp:RMAssertion' */
#ifndef SOAP_TYPE_PointerTowsrmp__RMAssertion
#define SOAP_TYPE_PointerTowsrmp__RMAssertion (321)
#endif

/* wsp__Assertion * has binding name 'PointerTowsp__Assertion' for type 'wsp:Assertion' */
#ifndef SOAP_TYPE_PointerTowsp__Assertion
#define SOAP_TYPE_PointerTowsp__Assertion (320)
#endif

/* sp__Token * has binding name 'PointerTosp__Token' for type 'sp:Token' */
#ifndef SOAP_TYPE_PointerTosp__Token
#define SOAP_TYPE_PointerTosp__Token (319)
#endif

/* sp__Elements * has binding name 'PointerTosp__Elements' for type 'sp:Elements' */
#ifndef SOAP_TYPE_PointerTosp__Elements
#define SOAP_TYPE_PointerTosp__Elements (318)
#endif

/* wsp__PolicyReference * has binding name 'PointerTowsp__PolicyReference' for type 'wsp:PolicyReference' */
#ifndef SOAP_TYPE_PointerTowsp__PolicyReference
#define SOAP_TYPE_PointerTowsp__PolicyReference (315)
#endif

/* wsrmp5__Timeout * has binding name 'PointerTowsrmp5__Timeout' for type 'wsrmp5:Timeout' */
#ifndef SOAP_TYPE_PointerTowsrmp5__Timeout
#define SOAP_TYPE_PointerTowsrmp5__Timeout (314)
#endif

/* wsrmp__Timeout * has binding name 'PointerTowsrmp__Timeout' for type 'wsrmp:Timeout' */
#ifndef SOAP_TYPE_PointerTowsrmp__Timeout
#define SOAP_TYPE_PointerTowsrmp__Timeout (311)
#endif

/* wst__Claims * has binding name 'PointerTowst__Claims' for type 'wst:Claims' */
#ifndef SOAP_TYPE_PointerTowst__Claims
#define SOAP_TYPE_PointerTowst__Claims (308)
#endif

/* wsa__EndpointReferenceType * has binding name 'PointerTowsa__EndpointReferenceType' for type 'wsa:EndpointReferenceType' */
#ifndef SOAP_TYPE_PointerTowsa__EndpointReferenceType
#define SOAP_TYPE_PointerTowsa__EndpointReferenceType (307)
#endif

/* wsp__Content * has binding name 'PointerTowsp__Content' for type 'wsp:Content' */
#ifndef SOAP_TYPE_PointerTowsp__Content
#define SOAP_TYPE_PointerTowsp__Content (299)
#endif

/* wsp__Policy * has binding name 'PointerTowsp__Policy' for type 'wsp:Policy' */
#ifndef SOAP_TYPE_PointerTowsp__Policy
#define SOAP_TYPE_PointerTowsp__Policy (293)
#endif

/* sd__staticServiceDataValues * has binding name 'PointerTosd__staticServiceDataValues' for type 'sd:staticServiceDataValues' */
#ifndef SOAP_TYPE_PointerTosd__staticServiceDataValues
#define SOAP_TYPE_PointerTosd__staticServiceDataValues (286)
#endif

/* wsdl__operation * has binding name 'PointerTowsdl__operation' for type 'wsdl:operation' */
#ifndef SOAP_TYPE_PointerTowsdl__operation
#define SOAP_TYPE_PointerTowsdl__operation (283)
#endif

/* soap__body * has binding name 'PointerTosoap__body' for type 'soap:body' */
#ifndef SOAP_TYPE_PointerTosoap__body
#define SOAP_TYPE_PointerTosoap__body (264)
#endif

/* wsdl__part * has binding name 'PointerTowsdl__part' for type 'wsdl:part' */
#ifndef SOAP_TYPE_PointerTowsdl__part
#define SOAP_TYPE_PointerTowsdl__part (240)
#endif

/* wsdl__message * has binding name 'PointerTowsdl__message' for type 'wsdl:message' */
#ifndef SOAP_TYPE_PointerTowsdl__message
#define SOAP_TYPE_PointerTowsdl__message (239)
#endif

/* enum soap__styleChoice * has binding name 'PointerTosoap__styleChoice' for type 'soap:styleChoice' */
#ifndef SOAP_TYPE_PointerTosoap__styleChoice
#define SOAP_TYPE_PointerTosoap__styleChoice (233)
#endif

/* xs__complexContent * has binding name 'PointerToxs__complexContent' for type 'xs:complexContent' */
#ifndef SOAP_TYPE_PointerToxs__complexContent
#define SOAP_TYPE_PointerToxs__complexContent (158)
#endif

/* xs__simpleContent * has binding name 'PointerToxs__simpleContent' for type 'xs:simpleContent' */
#ifndef SOAP_TYPE_PointerToxs__simpleContent
#define SOAP_TYPE_PointerToxs__simpleContent (157)
#endif

/* xs__assert * has binding name 'PointerToxs__assert' for type 'xs:assert' */
#ifndef SOAP_TYPE_PointerToxs__assert
#define SOAP_TYPE_PointerToxs__assert (142)
#endif

/* xs__length * has binding name 'PointerToxs__length' for type 'xs:length' */
#ifndef SOAP_TYPE_PointerToxs__length
#define SOAP_TYPE_PointerToxs__length (141)
#endif

/* xs__whiteSpace * has binding name 'PointerToxs__whiteSpace' for type 'xs:whiteSpace' */
#ifndef SOAP_TYPE_PointerToxs__whiteSpace
#define SOAP_TYPE_PointerToxs__whiteSpace (140)
#endif

/* xs__union * has binding name 'PointerToxs__union' for type 'xs:union' */
#ifndef SOAP_TYPE_PointerToxs__union
#define SOAP_TYPE_PointerToxs__union (123)
#endif

/* xs__list * has binding name 'PointerToxs__list' for type 'xs:list' */
#ifndef SOAP_TYPE_PointerToxs__list
#define SOAP_TYPE_PointerToxs__list (122)
#endif

/* xs__restriction * has binding name 'PointerToxs__restriction' for type 'xs:restriction' */
#ifndef SOAP_TYPE_PointerToxs__restriction
#define SOAP_TYPE_PointerToxs__restriction (120)
#endif

/* xs__extension * has binding name 'PointerToxs__extension' for type 'xs:extension' */
#ifndef SOAP_TYPE_PointerToxs__extension
#define SOAP_TYPE_PointerToxs__extension (119)
#endif

/* xs__attributeGroup * has binding name 'PointerToxs__attributeGroup' for type 'xs:attributeGroup' */
#ifndef SOAP_TYPE_PointerToxs__attributeGroup
#define SOAP_TYPE_PointerToxs__attributeGroup (106)
#endif

/* xs__anyAttribute * has binding name 'PointerToxs__anyAttribute' for type 'xs:anyAttribute' */
#ifndef SOAP_TYPE_PointerToxs__anyAttribute
#define SOAP_TYPE_PointerToxs__anyAttribute (105)
#endif

/* xs__all * has binding name 'PointerToxs__all' for type 'xs:all' */
#ifndef SOAP_TYPE_PointerToxs__all
#define SOAP_TYPE_PointerToxs__all (93)
#endif

/* xs__any * has binding name 'PointerToxs__any' for type 'xs:any' */
#ifndef SOAP_TYPE_PointerToxs__any
#define SOAP_TYPE_PointerToxs__any (85)
#endif

/* xs__seqchoice * has binding name 'PointerToxs__seqchoice' for type 'xs:seqchoice' */
#ifndef SOAP_TYPE_PointerToxs__seqchoice
#define SOAP_TYPE_PointerToxs__seqchoice (84)
#endif

/* xs__group * has binding name 'PointerToxs__group' for type 'xs:group' */
#ifndef SOAP_TYPE_PointerToxs__group
#define SOAP_TYPE_PointerToxs__group (83)
#endif

/* xs__namespaceList has binding name 'xs__namespaceList' for type 'xs:namespaceList' */
#ifndef SOAP_TYPE_xs__namespaceList
#define SOAP_TYPE_xs__namespaceList (79)
#endif

/* xs__attribute * has binding name 'PointerToxs__attribute' for type 'xs:attribute' */
#ifndef SOAP_TYPE_PointerToxs__attribute
#define SOAP_TYPE_PointerToxs__attribute (65)
#endif

/* std::vector<xs__element *> * has binding name 'PointerTostd__vectorTemplateOfPointerToxs__element' for type 'xs:element' */
#ifndef SOAP_TYPE_PointerTostd__vectorTemplateOfPointerToxs__element
#define SOAP_TYPE_PointerTostd__vectorTemplateOfPointerToxs__element (61)
#endif

/* xs__element * has binding name 'PointerToxs__element' for type 'xs:element' */
#ifndef SOAP_TYPE_PointerToxs__element
#define SOAP_TYPE_PointerToxs__element (42)
#endif

/* xs__schema * has binding name 'PointerToxs__schema' for type 'xs:schema' */
#ifndef SOAP_TYPE_PointerToxs__schema
#define SOAP_TYPE_PointerToxs__schema (41)
#endif

/* xs__complexType * has binding name 'PointerToxs__complexType' for type 'xs:complexType' */
#ifndef SOAP_TYPE_PointerToxs__complexType
#define SOAP_TYPE_PointerToxs__complexType (39)
#endif

/* xs__simpleType * has binding name 'PointerToxs__simpleType' for type 'xs:simpleType' */
#ifndef SOAP_TYPE_PointerToxs__simpleType
#define SOAP_TYPE_PointerToxs__simpleType (38)
#endif

/* enum xs__formChoice * has binding name 'PointerToxs__formChoice' for type 'xs:formChoice' */
#ifndef SOAP_TYPE_PointerToxs__formChoice
#define SOAP_TYPE_PointerToxs__formChoice (37)
#endif

/* xs__annotation * has binding name 'PointerToxs__annotation' for type 'xs:annotation' */
#ifndef SOAP_TYPE_PointerToxs__annotation
#define SOAP_TYPE_PointerToxs__annotation (33)
#endif

/* xsd__string has binding name 'xsd__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_xsd__string
#define SOAP_TYPE_xsd__string (14)
#endif

/* xsd__QName has binding name 'xsd__QName' for type 'xsd:QName' */
#ifndef SOAP_TYPE_xsd__QName
#define SOAP_TYPE_xsd__QName (13)
#endif

/* xsd__NMTOKENS has binding name 'xsd__NMTOKENS' for type 'xsd:NMTOKENS' */
#ifndef SOAP_TYPE_xsd__NMTOKENS
#define SOAP_TYPE_xsd__NMTOKENS (12)
#endif

/* xsd__NMTOKEN has binding name 'xsd__NMTOKEN' for type 'xsd:NMTOKEN' */
#ifndef SOAP_TYPE_xsd__NMTOKEN
#define SOAP_TYPE_xsd__NMTOKEN (11)
#endif

/* xsd__NCName has binding name 'xsd__NCName' for type 'xsd:NCName' */
#ifndef SOAP_TYPE_xsd__NCName
#define SOAP_TYPE_xsd__NCName (10)
#endif

/* xsd__ID has binding name 'xsd__ID' for type 'xsd:ID' */
#ifndef SOAP_TYPE_xsd__ID
#define SOAP_TYPE_xsd__ID (9)
#endif

/* xsd__anyURI has binding name 'xsd__anyURI' for type 'xsd:anyURI' */
#ifndef SOAP_TYPE_xsd__anyURI
#define SOAP_TYPE_xsd__anyURI (8)
#endif

/* _XML has binding name '_XML' for type '' */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (6)
#endif

/* _QName has binding name '_QName' for type 'xsd:QName' */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
#endif

/* char * has binding name 'string' for type 'xsd:string' */
#ifndef SOAP_TYPE_string
#define SOAP_TYPE_string (4)
#endif

/* std::vector<gwsdl__portType>  has binding name 'std__vectorTemplateOfgwsdl__portType' for type 'gwsdl:portType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfgwsdl__portType
#define SOAP_TYPE_std__vectorTemplateOfgwsdl__portType (459)
#endif

/* std::vector<vprop__tPropertyAlias>  has binding name 'std__vectorTemplateOfvprop__tPropertyAlias' for type 'vprop:tPropertyAlias' */
#ifndef SOAP_TYPE_std__vectorTemplateOfvprop__tPropertyAlias
#define SOAP_TYPE_std__vectorTemplateOfvprop__tPropertyAlias (458)
#endif

/* std::vector<vprop__tProperty>  has binding name 'std__vectorTemplateOfvprop__tProperty' for type 'vprop:tProperty' */
#ifndef SOAP_TYPE_std__vectorTemplateOfvprop__tProperty
#define SOAP_TYPE_std__vectorTemplateOfvprop__tProperty (457)
#endif

/* std::vector<plnk__tPartnerLinkType>  has binding name 'std__vectorTemplateOfplnk__tPartnerLinkType' for type 'plnk:tPartnerLinkType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfplnk__tPartnerLinkType
#define SOAP_TYPE_std__vectorTemplateOfplnk__tPartnerLinkType (456)
#endif

/* std::vector<wsdl__service>  has binding name 'std__vectorTemplateOfwsdl__service' for type 'wsdl:service' */
#ifndef SOAP_TYPE_std__vectorTemplateOfwsdl__service
#define SOAP_TYPE_std__vectorTemplateOfwsdl__service (455)
#endif

/* std::vector<wsdl__binding>  has binding name 'std__vectorTemplateOfwsdl__binding' for type 'wsdl:binding' */
#ifndef SOAP_TYPE_std__vectorTemplateOfwsdl__binding
#define SOAP_TYPE_std__vectorTemplateOfwsdl__binding (454)
#endif

/* std::vector<wsdl__portType>  has binding name 'std__vectorTemplateOfwsdl__portType' for type 'wsdl:portType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfwsdl__portType
#define SOAP_TYPE_std__vectorTemplateOfwsdl__portType (453)
#endif

/* std::vector<wsdl__message>  has binding name 'std__vectorTemplateOfwsdl__message' for type 'wsdl:message' */
#ifndef SOAP_TYPE_std__vectorTemplateOfwsdl__message
#define SOAP_TYPE_std__vectorTemplateOfwsdl__message (452)
#endif

/* std::vector<wsdl__import>  has binding name 'std__vectorTemplateOfwsdl__import' for type 'wsdl:import' */
#ifndef SOAP_TYPE_std__vectorTemplateOfwsdl__import
#define SOAP_TYPE_std__vectorTemplateOfwsdl__import (450)
#endif

/* std::vector<wsdl__port>  has binding name 'std__vectorTemplateOfwsdl__port' for type 'wsdl:port' */
#ifndef SOAP_TYPE_std__vectorTemplateOfwsdl__port
#define SOAP_TYPE_std__vectorTemplateOfwsdl__port (448)
#endif

/* std::vector<wsdl__ext_operation>  has binding name 'std__vectorTemplateOfwsdl__ext_operation' for type 'wsdl:ext-operation' */
#ifndef SOAP_TYPE_std__vectorTemplateOfwsdl__ext_operation
#define SOAP_TYPE_std__vectorTemplateOfwsdl__ext_operation (432)
#endif

/* std::vector<wsdl__ext_fault>  has binding name 'std__vectorTemplateOfwsdl__ext_fault' for type 'wsdl:ext-fault' */
#ifndef SOAP_TYPE_std__vectorTemplateOfwsdl__ext_fault
#define SOAP_TYPE_std__vectorTemplateOfwsdl__ext_fault (423)
#endif

/* std::vector<whttp__header>  has binding name 'std__vectorTemplateOfwhttp__header' for type 'whttp:header' */
#ifndef SOAP_TYPE_std__vectorTemplateOfwhttp__header
#define SOAP_TYPE_std__vectorTemplateOfwhttp__header (408)
#endif

/* std::vector<wsoap__header>  has binding name 'std__vectorTemplateOfwsoap__header' for type 'wsoap:header' */
#ifndef SOAP_TYPE_std__vectorTemplateOfwsoap__header
#define SOAP_TYPE_std__vectorTemplateOfwsoap__header (407)
#endif

/* std::vector<wsoap__module>  has binding name 'std__vectorTemplateOfwsoap__module' for type 'wsoap:module' */
#ifndef SOAP_TYPE_std__vectorTemplateOfwsoap__module
#define SOAP_TYPE_std__vectorTemplateOfwsoap__module (406)
#endif

/* std::vector<wsdl__operation>  has binding name 'std__vectorTemplateOfwsdl__operation' for type 'wsdl:operation' */
#ifndef SOAP_TYPE_std__vectorTemplateOfwsdl__operation
#define SOAP_TYPE_std__vectorTemplateOfwsdl__operation (396)
#endif

/* std::vector<wsdl__fault>  has binding name 'std__vectorTemplateOfwsdl__fault' for type 'wsdl:fault' */
#ifndef SOAP_TYPE_std__vectorTemplateOfwsdl__fault
#define SOAP_TYPE_std__vectorTemplateOfwsdl__fault (394)
#endif

/* std::vector<wsdl__part>  has binding name 'std__vectorTemplateOfwsdl__part' for type 'wsdl:part' */
#ifndef SOAP_TYPE_std__vectorTemplateOfwsdl__part
#define SOAP_TYPE_std__vectorTemplateOfwsdl__part (376)
#endif

/* std::vector<wsp__PolicyReference>  has binding name 'std__vectorTemplateOfwsp__PolicyReference' for type 'wsp:PolicyReference' */
#ifndef SOAP_TYPE_std__vectorTemplateOfwsp__PolicyReference
#define SOAP_TYPE_std__vectorTemplateOfwsp__PolicyReference (375)
#endif

/* std::vector<wsp__Policy>  has binding name 'std__vectorTemplateOfwsp__Policy' for type 'wsp:Policy' */
#ifndef SOAP_TYPE_std__vectorTemplateOfwsp__Policy
#define SOAP_TYPE_std__vectorTemplateOfwsp__Policy (374)
#endif

/* std::vector<xs__schema *>  has binding name 'std__vectorTemplateOfPointerToxs__schema' for type 'xs:schema' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerToxs__schema
#define SOAP_TYPE_std__vectorTemplateOfPointerToxs__schema (363)
#endif

/* std::vector<plnk__tRole>  has binding name 'std__vectorTemplateOfplnk__tRole' for type 'plnk:tRole' */
#ifndef SOAP_TYPE_std__vectorTemplateOfplnk__tRole
#define SOAP_TYPE_std__vectorTemplateOfplnk__tRole (344)
#endif

/* std::vector<wsp__Attachment>  has binding name 'std__vectorTemplateOfwsp__Attachment' for type 'wsp:Attachment' */
#ifndef SOAP_TYPE_std__vectorTemplateOfwsp__Attachment
#define SOAP_TYPE_std__vectorTemplateOfwsp__Attachment (332)
#endif

/* std::vector<char *>  has binding name 'std__vectorTemplateOf_XML' for type '' */
#ifndef SOAP_TYPE_std__vectorTemplateOf_XML
#define SOAP_TYPE_std__vectorTemplateOf_XML (323)
#endif

/* std::vector<sp__Parts>  has binding name 'std__vectorTemplateOfsp__Parts' for type 'sp:Parts' */
#ifndef SOAP_TYPE_std__vectorTemplateOfsp__Parts
#define SOAP_TYPE_std__vectorTemplateOfsp__Parts (317)
#endif

/* std::vector<wsp__Content *>  has binding name 'std__vectorTemplateOfPointerTowsp__Content' for type 'wsp:Content' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTowsp__Content
#define SOAP_TYPE_std__vectorTemplateOfPointerTowsp__Content (316)
#endif

/* std::vector<char *>  has binding name 'std__vectorTemplateOfxsd__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_std__vectorTemplateOfxsd__string
#define SOAP_TYPE_std__vectorTemplateOfxsd__string (305)
#endif

/* std::vector<sp__Header>  has binding name 'std__vectorTemplateOfsp__Header' for type 'sp:Header' */
#ifndef SOAP_TYPE_std__vectorTemplateOfsp__Header
#define SOAP_TYPE_std__vectorTemplateOfsp__Header (303)
#endif

/* std::vector<sd__serviceData>  has binding name 'std__vectorTemplateOfsd__serviceData' for type 'sd:serviceData' */
#ifndef SOAP_TYPE_std__vectorTemplateOfsd__serviceData
#define SOAP_TYPE_std__vectorTemplateOfsd__serviceData (285)
#endif

/* std::vector<wsdl__operation *>  has binding name 'std__vectorTemplateOfPointerTowsdl__operation' for type 'wsdl:operation' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTowsdl__operation
#define SOAP_TYPE_std__vectorTemplateOfPointerTowsdl__operation (284)
#endif

/* std::vector<mime__part>  has binding name 'std__vectorTemplateOfmime__part' for type 'mime:part' */
#ifndef SOAP_TYPE_std__vectorTemplateOfmime__part
#define SOAP_TYPE_std__vectorTemplateOfmime__part (269)
#endif

/* std::vector<mime__content>  has binding name 'std__vectorTemplateOfmime__content' for type 'mime:content' */
#ifndef SOAP_TYPE_std__vectorTemplateOfmime__content
#define SOAP_TYPE_std__vectorTemplateOfmime__content (266)
#endif

/* std::vector<soap__header>  has binding name 'std__vectorTemplateOfsoap__header' for type 'soap:header' */
#ifndef SOAP_TYPE_std__vectorTemplateOfsoap__header
#define SOAP_TYPE_std__vectorTemplateOfsoap__header (265)
#endif

/* std::vector<soap__headerfault>  has binding name 'std__vectorTemplateOfsoap__headerfault' for type 'soap:headerfault' */
#ifndef SOAP_TYPE_std__vectorTemplateOfsoap__headerfault
#define SOAP_TYPE_std__vectorTemplateOfsoap__headerfault (250)
#endif

/* std::vector<xs__import>  has binding name 'std__vectorTemplateOfxs__import' for type 'xs:import' */
#ifndef SOAP_TYPE_std__vectorTemplateOfxs__import
#define SOAP_TYPE_std__vectorTemplateOfxs__import (192)
#endif

/* std::vector<xs__redefine>  has binding name 'std__vectorTemplateOfxs__redefine' for type 'xs:redefine' */
#ifndef SOAP_TYPE_std__vectorTemplateOfxs__redefine
#define SOAP_TYPE_std__vectorTemplateOfxs__redefine (191)
#endif

/* std::vector<xs__override>  has binding name 'std__vectorTemplateOfxs__override' for type 'xs:override' */
#ifndef SOAP_TYPE_std__vectorTemplateOfxs__override
#define SOAP_TYPE_std__vectorTemplateOfxs__override (190)
#endif

/* std::vector<xs__include>  has binding name 'std__vectorTemplateOfxs__include' for type 'xs:include' */
#ifndef SOAP_TYPE_std__vectorTemplateOfxs__include
#define SOAP_TYPE_std__vectorTemplateOfxs__include (189)
#endif

/* std::vector<xs__complexType>  has binding name 'std__vectorTemplateOfxs__complexType' for type 'xs:complexType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfxs__complexType
#define SOAP_TYPE_std__vectorTemplateOfxs__complexType (177)
#endif

/* std::vector<xs__group>  has binding name 'std__vectorTemplateOfxs__group' for type 'xs:group' */
#ifndef SOAP_TYPE_std__vectorTemplateOfxs__group
#define SOAP_TYPE_std__vectorTemplateOfxs__group (176)
#endif

/* std::vector<xs__simpleType>  has binding name 'std__vectorTemplateOfxs__simpleType' for type 'xs:simpleType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfxs__simpleType
#define SOAP_TYPE_std__vectorTemplateOfxs__simpleType (149)
#endif

/* std::vector<xs__pattern>  has binding name 'std__vectorTemplateOfxs__pattern' for type 'xs:pattern' */
#ifndef SOAP_TYPE_std__vectorTemplateOfxs__pattern
#define SOAP_TYPE_std__vectorTemplateOfxs__pattern (139)
#endif

/* std::vector<xs__enumeration>  has binding name 'std__vectorTemplateOfxs__enumeration' for type 'xs:enumeration' */
#ifndef SOAP_TYPE_std__vectorTemplateOfxs__enumeration
#define SOAP_TYPE_std__vectorTemplateOfxs__enumeration (138)
#endif

/* std::vector<xs__assert>  has binding name 'std__vectorTemplateOfxs__assert' for type 'xs:assert' */
#ifndef SOAP_TYPE_std__vectorTemplateOfxs__assert
#define SOAP_TYPE_std__vectorTemplateOfxs__assert (129)
#endif

/* std::vector<xs__attributeGroup>  has binding name 'std__vectorTemplateOfxs__attributeGroup' for type 'xs:attributeGroup' */
#ifndef SOAP_TYPE_std__vectorTemplateOfxs__attributeGroup
#define SOAP_TYPE_std__vectorTemplateOfxs__attributeGroup (104)
#endif

/* std::vector<xs__attribute>  has binding name 'std__vectorTemplateOfxs__attribute' for type 'xs:attribute' */
#ifndef SOAP_TYPE_std__vectorTemplateOfxs__attribute
#define SOAP_TYPE_std__vectorTemplateOfxs__attribute (103)
#endif

/* std::vector<xs__contents>  has binding name 'std__vectorTemplateOfxs__contents' for type 'xs:contents' */
#ifndef SOAP_TYPE_std__vectorTemplateOfxs__contents
#define SOAP_TYPE_std__vectorTemplateOfxs__contents (88)
#endif

/* std::vector<xs__element>  has binding name 'std__vectorTemplateOfxs__element' for type 'xs:element' */
#ifndef SOAP_TYPE_std__vectorTemplateOfxs__element
#define SOAP_TYPE_std__vectorTemplateOfxs__element (76)
#endif

/* std::vector<xs__element *>  has binding name 'std__vectorTemplateOfPointerToxs__element' for type 'xs:element' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerToxs__element
#define SOAP_TYPE_std__vectorTemplateOfPointerToxs__element (43)
#endif

/* std::vector<xs__alternative>  has binding name 'std__vectorTemplateOfxs__alternative' for type 'xs:alternative' */
#ifndef SOAP_TYPE_std__vectorTemplateOfxs__alternative
#define SOAP_TYPE_std__vectorTemplateOfxs__alternative (40)
#endif

/* std::vector<char *>  has binding name 'std__vectorTemplateOfstring' for type 'xsd:string' */
#ifndef SOAP_TYPE_std__vectorTemplateOfstring
#define SOAP_TYPE_std__vectorTemplateOfstring (31)
#endif

/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


/* schema.h:549 */
extern ostream &operator<<(ostream &o, const xs__schema &e);

/* schema.h:550 */
extern istream &operator>>(istream &i, xs__schema &e);

/* ./wsdl.h:390 */
extern ostream &operator<<(ostream &o, const wsdl__definitions &e);

/* ./wsdl.h:391 */
extern istream &operator>>(istream &i, wsdl__definitions &e);

#endif

/* End of wsdlStub.h */
