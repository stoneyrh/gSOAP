/* wsdlStub.h
   Generated by gSOAP 2.8.122 for ../../gsoap/wsdl/wsdl.h

gSOAP XML Web services tools
Copyright (C) 2000-2021, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#include "includes.h"

#ifndef wsdlStub_H
#define wsdlStub_H
#include "stdsoap2.h"
#if GSOAP_VERSION != 208122
# error "GSOAP VERSION 208122 MISMATCH IN GENERATED CODE VERSUS LIBRARY CODE: PLEASE REINSTALL PACKAGE"
#endif


/******************************************************************************\
 *                                                                            *
 * Enumeration Types                                                          *
 *                                                                            *
\******************************************************************************/


/* schema.h:78 */
#ifndef SOAP_TYPE_xs__formChoice
#define SOAP_TYPE_xs__formChoice (37)
/* xs:formChoice */
enum xs__formChoice {
	unqualified = 0,
	qualified = 1
};
#endif

/* schema.h:126 */
#ifndef SOAP_TYPE_xs__attribute_use
#define SOAP_TYPE_xs__attribute_use (68)
/* xs:attribute-use */
enum xs__attribute_use {
	optional = 0,
	prohibited = 1,
	required = 2,
	default_ = 3,
	fixed_ = 4
};
#endif

/* schema.h:172 */
#ifndef SOAP_TYPE_xs__processContents
#define SOAP_TYPE_xs__processContents (86)
/* xs:processContents */
enum xs__processContents {
	strict = 0,
	skip = 1,
	lax = 2
};
#endif

/* wadl.h:46 */
#ifndef SOAP_TYPE_wadl__HTTPMethods
#define SOAP_TYPE_wadl__HTTPMethods (274)
/* wadl:HTTPMethods */
enum wadl__HTTPMethods {
	GET = 0,
	POST = 1,
	PUT = 2,
	HEAD = 3,
	DELETE_ = 4
};
#endif

/* wadl.h:48 */
#ifndef SOAP_TYPE_wadl__ParamStyle
#define SOAP_TYPE_wadl__ParamStyle (275)
/* wadl:ParamStyle */
enum wadl__ParamStyle {
	plain = 0,
	query = 1,
	matrix = 2,
	header = 3,
	template_ = 4
};
#endif

/* soap.h:50 */
#ifndef SOAP_TYPE_soap__styleChoice
#define SOAP_TYPE_soap__styleChoice (356)
/* soap:styleChoice */
enum soap__styleChoice {
	rpc = 0,
	document = 1
};
#endif

/* soap.h:65 */
#ifndef SOAP_TYPE_soap__useChoice
#define SOAP_TYPE_soap__useChoice (360)
/* soap:useChoice */
enum soap__useChoice {
	literal = 0,
	encoded = 1
};
#endif

/* gwsdl.h:43 */
#ifndef SOAP_TYPE_sd__mutability
#define SOAP_TYPE_sd__mutability (403)
/* sd:mutability */
enum sd__mutability {
	static_ = 0,
	constant = 1,
	extendable = 2,
	mutable_ = 3
};
#endif

/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Classes, Structs and Unions                                                *
 *                                                                            *
\******************************************************************************/

class xs__annotation;	/* schema.h:55 */
class xs__assert;	/* schema.h:61 */
class xs__alternative;	/* schema.h:69 */
class xs__element;	/* schema.h:80 */
class xs__attribute;	/* schema.h:128 */
class xs__all;	/* schema.h:163 */
class xs__any;	/* schema.h:176 */
union xs__union_content;	/* schema.h:194 */
class xs__contents;	/* schema.h:189 */
class xs__seqchoice;	/* schema.h:50 */
class xs__group;	/* schema.h:51 */
class xs__anyAttribute;	/* schema.h:248 */
class xs__attributeGroup;	/* schema.h:255 */
class xs__enumeration;	/* schema.h:278 */
class xs__pattern;	/* schema.h:288 */
class xs__simpleContent;	/* schema.h:296 */
class xs__simpleType;	/* schema.h:46 */
class xs__extension;	/* schema.h:48 */
class xs__length;	/* schema.h:363 */
class xs__whiteSpace;	/* schema.h:371 */
class xs__restriction;	/* schema.h:49 */
class xs__list;	/* schema.h:52 */
class xs__union;	/* schema.h:53 */
class xs__complexContent;	/* schema.h:449 */
class xs__complexType;	/* schema.h:47 */
class xs__import;	/* schema.h:503 */
class xs__include;	/* schema.h:520 */
class xs__override;	/* schema.h:534 */
class xs__redefine;	/* schema.h:554 */
class xs__schema;	/* schema.h:45 */
class wadl__doc;	/* wadl.h:50 */
class wadl__option;	/* wadl.h:57 */
class wadl__link;	/* wadl.h:64 */
class wadl__param;	/* wadl.h:79 */
class wadl__include;	/* wadl.h:110 */
class wadl__grammars;	/* wadl.h:118 */
class wadl__representation;	/* wadl.h:126 */
class wadl__request;	/* wadl.h:148 */
class wadl__response;	/* wadl.h:158 */
class wadl__method;	/* wadl.h:163 */
class __wadl__method_resource_choice;	/* wadl.h:181 */
class wadl__resource_USCOREtype;	/* wadl.h:42 */
class wadl__resource;	/* wadl.h:41 */
class wadl__resources;	/* wadl.h:212 */
class wadl__application;	/* wadl.h:221 */
class soap__binding;	/* soap.h:52 */
class soap__operation;	/* soap.h:58 */
class soap__body;	/* soap.h:67 */
class soap__fault;	/* soap.h:75 */
class soap__headerfault;	/* soap.h:83 */
class soap__header;	/* soap.h:101 */
class soap__address;	/* soap.h:120 */
class wsoap__module;	/* soap.h:125 */
class wsoap__header;	/* soap.h:131 */
class mime__content;	/* mime.h:46 */
class mime__part;	/* mime.h:52 */
class mime__multipartRelated;	/* mime.h:61 */
class mime__mimeXml;	/* mime.h:68 */
class dime__message;	/* dime.h:40 */
class http__address;	/* http.h:46 */
class http__binding;	/* http.h:51 */
class http__operation;	/* http.h:56 */
class whttp__header;	/* http.h:61 */
class sd__serviceData;	/* gwsdl.h:45 */
class sd__staticServiceDataValues;	/* gwsdl.h:58 */
class gwsdl__portType;	/* gwsdl.h:64 */
class wsa__EndpointReferenceType;	/* wsam.h:49 */
class wsp__PolicyReference;	/* wsp.h:50 */
class wsp__Assertion;	/* wsp.h:63 */
class wst__Claims;	/* wst.h:39 */
class sp__Header;	/* sp.h:45 */
class sp__Parts;	/* sp.h:51 */
class sp__Elements;	/* sp.h:58 */
class sp__Token;	/* sp.h:64 */
class wsrmp__Timeout;	/* wsrmp.h:47 */
class wsrmp__RMAssertion;	/* wsrmp.h:52 */
class wsrmp5__Timeout;	/* wsrmp.h:61 */
class wsrmp5__RMAssertion;	/* wsrmp.h:66 */
class wsp__Content;	/* wsp.h:45 */
class wsp__Policy;	/* wsp.h:44 */
class wsp__Attachment;	/* wsp.h:260 */
class wsp__AppliesTo;	/* wsp.h:266 */
class wsp__PolicyAttachment;	/* wsp.h:271 */
class plnk__tRole;	/* bpel.h:50 */
class plnk__tPartnerLinkType;	/* bpel.h:48 */
class vprop__tQuery;	/* bpel.h:75 */
class vprop__tProperty;	/* bpel.h:81 */
class vprop__tPropertyAlias;	/* bpel.h:91 */
class wsdl__import;	/* ../../gsoap/wsdl/wsdl.h:56 */
class wsdl__types;	/* ../../gsoap/wsdl/wsdl.h:71 */
class wsdl__part;	/* soap.h:48 */
class wsdl__message;	/* soap.h:47 */
class wsdl__ioput;	/* ../../gsoap/wsdl/wsdl.h:130 */
class wsdl__fault;	/* ../../gsoap/wsdl/wsdl.h:155 */
union wsdl__union_ioput;	/* ../../gsoap/wsdl/wsdl.h:193 */
class wsdl__operation;	/* gwsdl.h:41 */
class wsdl__portType;	/* bpel.h:47 */
class wsdl__ext_ioput;	/* ../../gsoap/wsdl/wsdl.h:226 */
class wsdl__ext_fault;	/* ../../gsoap/wsdl/wsdl.h:248 */
class wsdl__ext_operation;	/* ../../gsoap/wsdl/wsdl.h:269 */
class wsdl__binding;	/* ../../gsoap/wsdl/wsdl.h:297 */
class wsdl__port;	/* ../../gsoap/wsdl/wsdl.h:327 */
class wsdl__service;	/* ../../gsoap/wsdl/wsdl.h:350 */
class wsdl__definitions;	/* ../../gsoap/wsdl/wsdl.h:42 */

/* schema.h:55 */
#ifndef SOAP_TYPE_xs__annotation
#define SOAP_TYPE_xs__annotation (32)
/* complex XML schema type 'xs:annotation': */
class SOAP_CMAC xs__annotation {
      public:
        /// Optional element 'xs:documentation' of XML schema type 'xsd:string'
        std::vector<char *> documentation;
      public:
        /// Return unique type id SOAP_TYPE_xs__annotation
        virtual long soap_type(void) const { return SOAP_TYPE_xs__annotation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xs__annotation, default initialized and not managed by a soap context
        virtual xs__annotation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xs__annotation); }
      public:
        /// Constructor with default initializations
        xs__annotation() : documentation() { }
        virtual ~xs__annotation() { }
        /// Friend allocator used by soap_new_xs__annotation(struct soap*, int)
        friend SOAP_FMAC1 xs__annotation * SOAP_FMAC2 wsdl_instantiate_xs__annotation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* schema.h:61 */
#ifndef SOAP_TYPE_xs__assert
#define SOAP_TYPE_xs__assert (34)
/* complex XML schema type 'xs:assert': */
class SOAP_CMAC xs__assert {
      public:
        /// Optional attribute 'test' of XML schema type 'xsd:string'
        char *test;
        /// Optional attribute 'xpathDefaultNamespace' of XML schema type 'xsd:anyURI'
        char *xpathDefaultNamespace;
        /// Optional element 'xs:annotation' of XML schema type 'xs:annotation'
        xs__annotation *annotation;
      public:
        /// Return unique type id SOAP_TYPE_xs__assert
        virtual long soap_type(void) const { return SOAP_TYPE_xs__assert; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xs__assert, default initialized and not managed by a soap context
        virtual xs__assert *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xs__assert); }
      public:
        /// Constructor with default initializations
        xs__assert() : test(), xpathDefaultNamespace(), annotation() { }
        virtual ~xs__assert() { }
        /// Friend allocator used by soap_new_xs__assert(struct soap*, int)
        friend SOAP_FMAC1 xs__assert * SOAP_FMAC2 wsdl_instantiate_xs__assert(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* schema.h:69 */
#ifndef SOAP_TYPE_xs__alternative
#define SOAP_TYPE_xs__alternative (36)
/* complex XML schema type 'xs:alternative': */
class SOAP_CMAC xs__alternative {
      public:
        /// Optional attribute 'test' of XML schema type 'xsd:string'
        char *test;
        /// Optional attribute 'type' of XML schema type 'xsd:QName'
        char *type;
        /// Optional attribute 'xpathDefaultNamespace' of XML schema type 'xsd:anyURI'
        char *xpathDefaultNamespace;
        /// Optional element 'xs:annotation' of XML schema type 'xs:annotation'
        xs__annotation *annotation;
      public:
        /// Return unique type id SOAP_TYPE_xs__alternative
        virtual long soap_type(void) const { return SOAP_TYPE_xs__alternative; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xs__alternative, default initialized and not managed by a soap context
        virtual xs__alternative *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xs__alternative); }
      public:
        /// Constructor with default initializations
        xs__alternative() : test(), type(), xpathDefaultNamespace(), annotation() { }
        virtual ~xs__alternative() { }
        /// Friend allocator used by soap_new_xs__alternative(struct soap*, int)
        friend SOAP_FMAC1 xs__alternative * SOAP_FMAC2 wsdl_instantiate_xs__alternative(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* schema.h:80 */
#ifndef SOAP_TYPE_xs__element
#define SOAP_TYPE_xs__element (38)
/* Type xs__element is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'xs:element': */
class SOAP_CMAC xs__element {
      public:
        /// Optional attribute 'name' of XML schema type 'xsd:NCName'
        char *name;
        /// Optional attribute 'ref' of XML schema type 'xsd:QName'
        char *ref;
        /// Optional attribute 'type' of XML schema type 'xsd:QName'
        char *type;
        /// Optional attribute 'default' of XML schema type 'xsd:string'
        char *default_;
        /// Optional attribute 'default' of XML schema type 'xsd:QName'
        char *default__;
        /// Optional attribute 'fixed' of XML schema type 'xsd:string'
        char *fixed;
        /// Optional attribute 'fixed' of XML schema type 'xsd:QName'
        char *fixed_;
        /// Optional attribute 'form' of XML schema type 'xs:formChoice'
        enum xs__formChoice *form;
        /// Optional attribute 'nillable' of XML schema type 'xsd:boolean'
        bool nillable;	///< initialized with default value = (bool)0
        /// Optional attribute 'abstract' of XML schema type 'xsd:boolean'
        bool abstract;	///< initialized with default value = (bool)0
        /// Optional attribute 'substitutionGroup' of XML schema type 'xsd:QName'
        char *substitutionGroup;
        /// Optional attribute 'minOccurs' of XML schema type 'xsd:token'
        char *minOccurs;
        /// Optional attribute 'maxOccurs' of XML schema type 'xsd:token'
        char *maxOccurs;
        /// Optional attribute 'targetNamespace' of XML schema type 'xsd:anyURI'
        char *targetNamespace;
        /// Optional attribute 'xmime:expectedContentTypes' of XML schema type 'xsd:string'
        char *xmime__expectedContentTypes;
        /// Optional element 'xs:annotation' of XML schema type 'xs:annotation'
        xs__annotation *annotation;
        /// Optional element 'xs:simpleType' of XML schema type 'xs:simpleType'
        xs__simpleType *simpleType;
        /// Optional element 'xs:complexType' of XML schema type 'xs:complexType'
        xs__complexType *complexType;
        /// Optional element 'xs:alternative' of XML schema type 'xs:alternative'
        std::vector<xs__alternative> alternative;
        /// Optional element 'xs:unique' of XML schema type 'xsd:string'
        char *unique;
      private:
        /// Not serialized
        xs__schema *schemaRef;
        /// Not serialized
        xs__element *elementRef;
        /// Not serialized
        xs__simpleType *simpleTypeRef;
        /// Not serialized
        xs__complexType *complexTypeRef;
        /// Not serialized
        std::vector<xs__element *> substitutions;
        /// Not serialized
        bool used;
      public:
        xs__element();
        int traverse(xs__schema &_param_1);
        void schemaPtr(xs__schema *_param_1);
        void elementPtr(xs__element *_param_1);
        void simpleTypePtr(xs__simpleType *_param_1);
        void complexTypePtr(xs__complexType *_param_1);
        xs__schema *schemaPtr() const;
        xs__element *elementPtr() const;
        xs__simpleType *simpleTypePtr() const;
        xs__complexType *complexTypePtr() const;
        const std::vector<xs__element *> *substitutionsPtr() const;
        void mark();
        bool is_used() const;
      public:
        /// Return unique type id SOAP_TYPE_xs__element
        virtual long soap_type(void) const { return SOAP_TYPE_xs__element; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xs__element, default initialized and not managed by a soap context
        virtual xs__element *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xs__element); }
        virtual ~xs__element() { }
        /// Friend allocator used by soap_new_xs__element(struct soap*, int)
        friend SOAP_FMAC1 xs__element * SOAP_FMAC2 wsdl_instantiate_xs__element(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* schema.h:128 */
#ifndef SOAP_TYPE_xs__attribute
#define SOAP_TYPE_xs__attribute (69)
/* Type xs__attribute is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'xs:attribute': */
class SOAP_CMAC xs__attribute {
      public:
        /// Optional attribute 'name' of XML schema type 'xsd:NCName'
        char *name;
        /// Optional attribute 'ref' of XML schema type 'xsd:QName'
        char *ref;
        /// Optional attribute 'type' of XML schema type 'xsd:QName'
        char *type;
        /// Optional attribute 'use' of XML schema type 'xs:attribute-use'
        enum xs__attribute_use use;	///< initialized with default value = (enum xs__attribute_use)0
        /// Optional attribute 'default' of XML schema type 'xsd:string'
        char *default_;
        /// Optional attribute 'default' of XML schema type 'xsd:QName'
        char *default__;
        /// Optional attribute 'fixed' of XML schema type 'xsd:string'
        char *fixed;
        /// Optional attribute 'fixed' of XML schema type 'xsd:QName'
        char *fixed_;
        /// Optional attribute 'form' of XML schema type 'xs:formChoice'
        enum xs__formChoice *form;
        /// Optional attribute 'inheritable' of XML schema type 'xsd:boolean'
        bool inheritable;
        /// Optional attribute 'targetNamespace' of XML schema type 'xsd:anyURI'
        char *targetNamespace;
        /// Optional attribute 'wsdl:arrayType' of XML schema type 'xsd:QName'
        char *wsdl__arrayType;
        /// Optional element 'xs:annotation' of XML schema type 'xs:annotation'
        xs__annotation *annotation;
        /// Optional element 'xs:simpleType' of XML schema type 'xs:simpleType'
        xs__simpleType *simpleType;
      private:
        /// Not serialized
        xs__schema *schemaRef;
        /// Not serialized
        xs__attribute *attributeRef;
        /// Not serialized
        xs__simpleType *simpleTypeRef;
        /// Not serialized
        bool used;
      public:
        xs__attribute();
        int traverse(xs__schema &_param_1);
        void schemaPtr(xs__schema *_param_1);
        void attributePtr(xs__attribute *_param_1);
        void simpleTypePtr(xs__simpleType *_param_1);
        xs__schema *schemaPtr() const;
        xs__attribute *attributePtr() const;
        xs__simpleType *simpleTypePtr() const;
        void mark();
        bool is_used() const;
      public:
        /// Return unique type id SOAP_TYPE_xs__attribute
        virtual long soap_type(void) const { return SOAP_TYPE_xs__attribute; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xs__attribute, default initialized and not managed by a soap context
        virtual xs__attribute *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xs__attribute); }
        virtual ~xs__attribute() { }
        /// Friend allocator used by soap_new_xs__attribute(struct soap*, int)
        friend SOAP_FMAC1 xs__attribute * SOAP_FMAC2 wsdl_instantiate_xs__attribute(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* schema.h:163 */
#ifndef SOAP_TYPE_xs__all
#define SOAP_TYPE_xs__all (82)
/* complex XML schema type 'xs:all': */
class SOAP_CMAC xs__all {
      public:
        /// Optional element 'xs:element' of XML schema type 'xs:element'
        std::vector<xs__element> element;
        int traverse(xs__schema &_param_1);
        void mark();
      public:
        /// Return unique type id SOAP_TYPE_xs__all
        virtual long soap_type(void) const { return SOAP_TYPE_xs__all; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xs__all, default initialized and not managed by a soap context
        virtual xs__all *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xs__all); }
      public:
        /// Constructor with default initializations
        xs__all() : element() { }
        virtual ~xs__all() { }
        /// Friend allocator used by soap_new_xs__all(struct soap*, int)
        friend SOAP_FMAC1 xs__all * SOAP_FMAC2 wsdl_instantiate_xs__all(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* schema.h:176 */
#ifndef SOAP_TYPE_xs__any
#define SOAP_TYPE_xs__any (88)
/* complex XML schema type 'xs:any': */
class SOAP_CMAC xs__any {
      public:
        /// Optional attribute 'namespace' of XML schema type 'xs:namespaceList'
        char *namespace_;	///< initialized with default value = (char*)"##any"
        /// Optional attribute 'processContents' of XML schema type 'xs:processContents'
        enum xs__processContents processContents;	///< initialized with default value = (enum xs__processContents)0
        /// Optional attribute 'minOccurs' of XML schema type 'xsd:token'
        char *minOccurs;
        /// Optional attribute 'maxOccurs' of XML schema type 'xsd:token'
        char *maxOccurs;
        /// Optional element 'xs:element' of XML schema type 'xs:element'
        std::vector<xs__element> element;
        int traverse(xs__schema &_param_1);
        void mark();
      public:
        /// Return unique type id SOAP_TYPE_xs__any
        virtual long soap_type(void) const { return SOAP_TYPE_xs__any; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xs__any, default initialized and not managed by a soap context
        virtual xs__any *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xs__any); }
      public:
        /// Constructor with default initializations
        xs__any() : namespace_((char*)"##any"), processContents((enum xs__processContents)0), minOccurs(), maxOccurs(), element() { }
        virtual ~xs__any() { }
        /// Friend allocator used by soap_new_xs__any(struct soap*, int)
        friend SOAP_FMAC1 xs__any * SOAP_FMAC2 wsdl_instantiate_xs__any(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* schema.h:194 */
#ifndef SOAP_TYPE_xs__union_content
#define SOAP_TYPE_xs__union_content (92)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union xs__union_content
{
        #define SOAP_UNION_xs__union_content_element	(1)	/**< union variant selector value for member element */
        xs__element *element;
        #define SOAP_UNION_xs__union_content_group	(2)	/**< union variant selector value for member group */
        xs__group *group;
        #define SOAP_UNION_xs__union_content_choice	(3)	/**< union variant selector value for member choice */
        xs__seqchoice *choice;
        #define SOAP_UNION_xs__union_content_sequence	(4)	/**< union variant selector value for member sequence */
        xs__seqchoice *sequence;
        #define SOAP_UNION_xs__union_content_any	(5)	/**< union variant selector value for member any */
        xs__any *any;
};
#endif

/* schema.h:189 */
#ifndef SOAP_TYPE_xs__contents
#define SOAP_TYPE_xs__contents (91)
/* Choice: */
class SOAP_CMAC xs__contents {
      public:
        /// Union with union xs__union_content variant selector __union set to one of: SOAP_UNION_xs__union_content_element SOAP_UNION_xs__union_content_group SOAP_UNION_xs__union_content_choice SOAP_UNION_xs__union_content_sequence SOAP_UNION_xs__union_content_any
        int __union;
        union xs__union_content __content;
        int traverse(xs__schema &_param_1);
        void mark();
      public:
        /// Return unique type id SOAP_TYPE_xs__contents
        virtual long soap_type(void) const { return SOAP_TYPE_xs__contents; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xs__contents, default initialized and not managed by a soap context
        virtual xs__contents *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xs__contents); }
      public:
        /// Constructor with default initializations
        xs__contents() : __union() { }
        virtual ~xs__contents() { }
        /// Friend allocator used by soap_new_xs__contents(struct soap*, int)
        friend SOAP_FMAC1 xs__contents * SOAP_FMAC2 wsdl_instantiate_xs__contents(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* schema.h:50 */
#ifndef SOAP_TYPE_xs__seqchoice
#define SOAP_TYPE_xs__seqchoice (28)
/* Type xs__seqchoice is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'xs:seqchoice': */
class SOAP_CMAC xs__seqchoice {
      public:
        /// Optional attribute 'minOccurs' of XML schema type 'xsd:token'
        char *minOccurs;
        /// Optional attribute 'maxOccurs' of XML schema type 'xsd:token'
        char *maxOccurs;
        /// Optional element 'xs:annotation' of XML schema type 'xs:annotation'
        xs__annotation *annotation;
        std::vector<xs__contents> __contents;
      private:
        /// Not serialized
        xs__schema *schemaRef;
      public:
        xs__seqchoice();
        int traverse(xs__schema &_param_1);
        void schemaPtr(xs__schema *_param_1);
        xs__schema *schemaPtr() const;
        void mark();
      public:
        /// Return unique type id SOAP_TYPE_xs__seqchoice
        virtual long soap_type(void) const { return SOAP_TYPE_xs__seqchoice; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xs__seqchoice, default initialized and not managed by a soap context
        virtual xs__seqchoice *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xs__seqchoice); }
        virtual ~xs__seqchoice() { }
        /// Friend allocator used by soap_new_xs__seqchoice(struct soap*, int)
        friend SOAP_FMAC1 xs__seqchoice * SOAP_FMAC2 wsdl_instantiate_xs__seqchoice(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* schema.h:51 */
#ifndef SOAP_TYPE_xs__group
#define SOAP_TYPE_xs__group (29)
/* Type xs__group is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'xs:group': */
class SOAP_CMAC xs__group {
      public:
        /// Optional attribute 'name' of XML schema type 'xsd:NCName'
        char *name;
        /// Optional attribute 'ref' of XML schema type 'xsd:QName'
        char *ref;
        /// Optional attribute 'minOccurs' of XML schema type 'xsd:token'
        char *minOccurs;
        /// Optional attribute 'maxOccurs' of XML schema type 'xsd:token'
        char *maxOccurs;
        /// Optional element 'xs:annotation' of XML schema type 'xs:annotation'
        xs__annotation *annotation;
        /// Optional element 'xs:all' of XML schema type 'xs:all'
        xs__all *all;
        /// Optional element 'xs:choice' of XML schema type 'xs:seqchoice'
        xs__seqchoice *choice;
        /// Optional element 'xs:sequence' of XML schema type 'xs:seqchoice'
        xs__seqchoice *sequence;
      private:
        /// Not serialized
        xs__schema *schemaRef;
        /// Not serialized
        xs__group *groupRef;
        /// Not serialized
        bool used;
      public:
        xs__group();
        int traverse(xs__schema &_param_1);
        void schemaPtr(xs__schema *_param_1);
        void groupPtr(xs__group *_param_1);
        xs__schema *schemaPtr() const;
        xs__group *groupPtr() const;
        void mark();
      public:
        /// Return unique type id SOAP_TYPE_xs__group
        virtual long soap_type(void) const { return SOAP_TYPE_xs__group; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xs__group, default initialized and not managed by a soap context
        virtual xs__group *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xs__group); }
        virtual ~xs__group() { }
        /// Friend allocator used by soap_new_xs__group(struct soap*, int)
        friend SOAP_FMAC1 xs__group * SOAP_FMAC2 wsdl_instantiate_xs__group(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* schema.h:248 */
#ifndef SOAP_TYPE_xs__anyAttribute
#define SOAP_TYPE_xs__anyAttribute (113)
/* complex XML schema type 'xs:anyAttribute': */
class SOAP_CMAC xs__anyAttribute {
      public:
        /// Optional attribute 'namespace' of XML schema type 'xs:namespaceList'
        char *namespace_;	///< initialized with default value = (char*)"##any"
        /// Optional attribute 'processContents' of XML schema type 'xs:processContents'
        enum xs__processContents processContents;	///< initialized with default value = (enum xs__processContents)0
      public:
        /// Return unique type id SOAP_TYPE_xs__anyAttribute
        virtual long soap_type(void) const { return SOAP_TYPE_xs__anyAttribute; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xs__anyAttribute, default initialized and not managed by a soap context
        virtual xs__anyAttribute *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xs__anyAttribute); }
      public:
        /// Constructor with default initializations
        xs__anyAttribute() : namespace_((char*)"##any"), processContents((enum xs__processContents)0) { }
        virtual ~xs__anyAttribute() { }
        /// Friend allocator used by soap_new_xs__anyAttribute(struct soap*, int)
        friend SOAP_FMAC1 xs__anyAttribute * SOAP_FMAC2 wsdl_instantiate_xs__anyAttribute(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* schema.h:255 */
#ifndef SOAP_TYPE_xs__attributeGroup
#define SOAP_TYPE_xs__attributeGroup (114)
/* Type xs__attributeGroup is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'xs:attributeGroup': */
class SOAP_CMAC xs__attributeGroup {
      public:
        /// Optional attribute 'name' of XML schema type 'xsd:NCName'
        char *name;
        /// Optional attribute 'ref' of XML schema type 'xsd:QName'
        char *ref;
        /// Optional element 'xs:annotation' of XML schema type 'xs:annotation'
        xs__annotation *annotation;
        /// Optional element 'xs:attribute' of XML schema type 'xs:attribute'
        std::vector<xs__attribute> attribute;
        /// Optional element 'xs:attributeGroup' of XML schema type 'xs:attributeGroup'
        std::vector<xs__attributeGroup> attributeGroup;
        /// Optional element 'xs:anyAttribute' of XML schema type 'xs:anyAttribute'
        xs__anyAttribute *anyAttribute;
      private:
        /// Not serialized
        xs__schema *schemaRef;
        /// Not serialized
        xs__attributeGroup *attributeGroupRef;
        /// Not serialized
        bool used;
      public:
        xs__attributeGroup();
        int traverse(xs__schema &_param_1);
        void schemaPtr(xs__schema *_param_1);
        void attributeGroupPtr(xs__attributeGroup *_param_1);
        xs__schema *schemaPtr() const;
        xs__attributeGroup *attributeGroupPtr() const;
        void mark();
      public:
        /// Return unique type id SOAP_TYPE_xs__attributeGroup
        virtual long soap_type(void) const { return SOAP_TYPE_xs__attributeGroup; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xs__attributeGroup, default initialized and not managed by a soap context
        virtual xs__attributeGroup *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xs__attributeGroup); }
        virtual ~xs__attributeGroup() { }
        /// Friend allocator used by soap_new_xs__attributeGroup(struct soap*, int)
        friend SOAP_FMAC1 xs__attributeGroup * SOAP_FMAC2 wsdl_instantiate_xs__attributeGroup(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* schema.h:278 */
#ifndef SOAP_TYPE_xs__enumeration
#define SOAP_TYPE_xs__enumeration (127)
/* complex XML schema type 'xs:enumeration': */
class SOAP_CMAC xs__enumeration {
      public:
        /// Optional attribute 'value' of XML schema type 'xsd:string'
        char *value;
        /// Optional attribute 'value' of XML schema type 'xsd:QName'
        char *value_;
        /// Optional element 'xs:annotation' of XML schema type 'xs:annotation'
        xs__annotation *annotation;
        int traverse(xs__schema &_param_1);
      public:
        /// Return unique type id SOAP_TYPE_xs__enumeration
        virtual long soap_type(void) const { return SOAP_TYPE_xs__enumeration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xs__enumeration, default initialized and not managed by a soap context
        virtual xs__enumeration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xs__enumeration); }
      public:
        /// Constructor with default initializations
        xs__enumeration() : value(), value_(), annotation() { }
        virtual ~xs__enumeration() { }
        /// Friend allocator used by soap_new_xs__enumeration(struct soap*, int)
        friend SOAP_FMAC1 xs__enumeration * SOAP_FMAC2 wsdl_instantiate_xs__enumeration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* schema.h:288 */
#ifndef SOAP_TYPE_xs__pattern
#define SOAP_TYPE_xs__pattern (129)
/* complex XML schema type 'xs:pattern': */
class SOAP_CMAC xs__pattern {
      public:
        /// Optional attribute 'value' of XML schema type 'xsd:string'
        char *value;
        int traverse(xs__schema &_param_1);
      public:
        /// Return unique type id SOAP_TYPE_xs__pattern
        virtual long soap_type(void) const { return SOAP_TYPE_xs__pattern; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xs__pattern, default initialized and not managed by a soap context
        virtual xs__pattern *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xs__pattern); }
      public:
        /// Constructor with default initializations
        xs__pattern() : value() { }
        virtual ~xs__pattern() { }
        /// Friend allocator used by soap_new_xs__pattern(struct soap*, int)
        friend SOAP_FMAC1 xs__pattern * SOAP_FMAC2 wsdl_instantiate_xs__pattern(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* schema.h:296 */
#ifndef SOAP_TYPE_xs__simpleContent
#define SOAP_TYPE_xs__simpleContent (131)
/* complex XML schema type 'xs:simpleContent': */
class SOAP_CMAC xs__simpleContent {
      public:
        /// Optional element 'xs:extension' of XML schema type 'xs:extension'
        xs__extension *extension;
        /// Optional element 'xs:restriction' of XML schema type 'xs:restriction'
        xs__restriction *restriction;
        int traverse(xs__schema &_param_1);
        void mark();
      public:
        /// Return unique type id SOAP_TYPE_xs__simpleContent
        virtual long soap_type(void) const { return SOAP_TYPE_xs__simpleContent; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xs__simpleContent, default initialized and not managed by a soap context
        virtual xs__simpleContent *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xs__simpleContent); }
      public:
        /// Constructor with default initializations
        xs__simpleContent() : extension(), restriction() { }
        virtual ~xs__simpleContent() { }
        /// Friend allocator used by soap_new_xs__simpleContent(struct soap*, int)
        friend SOAP_FMAC1 xs__simpleContent * SOAP_FMAC2 wsdl_instantiate_xs__simpleContent(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* schema.h:46 */
#ifndef SOAP_TYPE_xs__simpleType
#define SOAP_TYPE_xs__simpleType (24)
/* Type xs__simpleType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'xs:simpleType': */
class SOAP_CMAC xs__simpleType {
      public:
        /// Optional attribute 'name' of XML schema type 'xsd:NMTOKEN'
        char *name;
        /// Optional attribute 'vc:minVersion' of XML schema type 'xsd:string'
        char *vc__minVersion;
        /// Optional attribute 'vc:maxVersion' of XML schema type 'xsd:string'
        char *vc__maxVersion;
        /// Optional element 'xs:annotation' of XML schema type 'xs:annotation'
        xs__annotation *annotation;
        /// Optional element 'xs:restriction' of XML schema type 'xs:restriction'
        xs__restriction *restriction;
        /// Optional element 'xs:list' of XML schema type 'xs:list'
        xs__list *list;
        /// Optional element 'xs:union' of XML schema type 'xs:union'
        xs__union *union_;
      private:
        /// Not serialized
        xs__schema *schemaRef;
        /// Not serialized
        std::vector<xs__complexType *> complextype_extensions;
        /// Not serialized
        std::vector<char *> extensions;
        /// Not serialized
        std::vector<char *> restrictions;
        /// Not serialized
        int level;
        /// Not serialized
        bool used;
      public:
        xs__simpleType();
        int traverse(xs__schema &_param_1);
        void schemaPtr(xs__schema *_param_1);
        xs__schema *schemaPtr() const;
        int baseLevel();
        void mark();
        bool is_used() const;
        void add_extension(xs__complexType *_param_1, xs__schema &_param_2, char *_param_3);
        void add_restriction(xs__schema &_param_1, char *_param_2);
        const std::vector<char *> &get_extensions() const;
        const std::vector<char *> &get_restrictions() const;
      public:
        /// Return unique type id SOAP_TYPE_xs__simpleType
        virtual long soap_type(void) const { return SOAP_TYPE_xs__simpleType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xs__simpleType, default initialized and not managed by a soap context
        virtual xs__simpleType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xs__simpleType); }
        virtual ~xs__simpleType() { }
        /// Friend allocator used by soap_new_xs__simpleType(struct soap*, int)
        friend SOAP_FMAC1 xs__simpleType * SOAP_FMAC2 wsdl_instantiate_xs__simpleType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* schema.h:48 */
#ifndef SOAP_TYPE_xs__extension
#define SOAP_TYPE_xs__extension (26)
/* complex XML schema type 'xs:extension': */
class SOAP_CMAC xs__extension {
      public:
        /// Optional attribute 'base' of XML schema type 'xsd:QName'
        char *base;
        /// Optional element 'xs:group' of XML schema type 'xs:group'
        xs__group *group;
        /// Optional element 'xs:all' of XML schema type 'xs:all'
        xs__all *all;
        /// Optional element 'xs:choice' of XML schema type 'xs:seqchoice'
        xs__seqchoice *choice;
        /// Optional element 'xs:sequence' of XML schema type 'xs:seqchoice'
        xs__seqchoice *sequence;
        /// Optional element 'xs:attribute' of XML schema type 'xs:attribute'
        std::vector<xs__attribute> attribute;
        /// Optional element 'xs:attributeGroup' of XML schema type 'xs:attributeGroup'
        std::vector<xs__attributeGroup> attributeGroup;
        /// Optional element 'xs:anyAttribute' of XML schema type 'xs:anyAttribute'
        xs__anyAttribute *anyAttribute;
        /// Optional element 'xs:annotation' of XML schema type 'xs:annotation'
        xs__annotation *annotation;
        /// Optional element 'xs:assert' of XML schema type 'xs:assert'
        std::vector<xs__assert> assert;
      private:
        /// Not serialized
        xs__simpleType *simpleTypeRef;
        /// Not serialized
        xs__complexType *complexTypeRef;
      public:
        xs__extension();
        int traverse(xs__schema &_param_1);
        void simpleTypePtr(xs__simpleType *_param_1);
        void complexTypePtr(xs__complexType *_param_1);
        xs__simpleType *simpleTypePtr() const;
        xs__complexType *complexTypePtr() const;
        void mark();
      public:
        /// Return unique type id SOAP_TYPE_xs__extension
        virtual long soap_type(void) const { return SOAP_TYPE_xs__extension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xs__extension, default initialized and not managed by a soap context
        virtual xs__extension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xs__extension); }
        virtual ~xs__extension() { }
        /// Friend allocator used by soap_new_xs__extension(struct soap*, int)
        friend SOAP_FMAC1 xs__extension * SOAP_FMAC2 wsdl_instantiate_xs__extension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* schema.h:363 */
#ifndef SOAP_TYPE_xs__length
#define SOAP_TYPE_xs__length (160)
/* complex XML schema type 'xs:length': */
class SOAP_CMAC xs__length {
      public:
        /// Optional attribute 'value' of XML schema type 'xsd:string'
        char *value;
        /// Optional attribute 'fixed' of XML schema type 'xsd:boolean'
        bool fixed;
        /// Optional element 'xs:annotation' of XML schema type 'xs:annotation'
        xs__annotation *annotation;
      public:
        /// Return unique type id SOAP_TYPE_xs__length
        virtual long soap_type(void) const { return SOAP_TYPE_xs__length; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xs__length, default initialized and not managed by a soap context
        virtual xs__length *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xs__length); }
      public:
        /// Constructor with default initializations
        xs__length() : value(), fixed(), annotation() { }
        virtual ~xs__length() { }
        /// Friend allocator used by soap_new_xs__length(struct soap*, int)
        friend SOAP_FMAC1 xs__length * SOAP_FMAC2 wsdl_instantiate_xs__length(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* schema.h:371 */
#ifndef SOAP_TYPE_xs__whiteSpace
#define SOAP_TYPE_xs__whiteSpace (161)
/* complex XML schema type 'xs:whiteSpace': */
class SOAP_CMAC xs__whiteSpace {
      public:
        /// Optional attribute 'value' of XML schema type 'xsd:string'
        char *value;
      public:
        /// Return unique type id SOAP_TYPE_xs__whiteSpace
        virtual long soap_type(void) const { return SOAP_TYPE_xs__whiteSpace; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xs__whiteSpace, default initialized and not managed by a soap context
        virtual xs__whiteSpace *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xs__whiteSpace); }
      public:
        /// Constructor with default initializations
        xs__whiteSpace() : value() { }
        virtual ~xs__whiteSpace() { }
        /// Friend allocator used by soap_new_xs__whiteSpace(struct soap*, int)
        friend SOAP_FMAC1 xs__whiteSpace * SOAP_FMAC2 wsdl_instantiate_xs__whiteSpace(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* schema.h:49 */
#ifndef SOAP_TYPE_xs__restriction
#define SOAP_TYPE_xs__restriction (27)
/* Type xs__restriction is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'xs:restriction': */
class SOAP_CMAC xs__restriction {
      public:
        /// Optional attribute 'base' of XML schema type 'xsd:QName'
        char *base;
        /// Optional element 'xs:simpleType' of XML schema type 'xs:simpleType'
        xs__simpleType *simpleType;
        /// Optional element 'xs:attributeGroup' of XML schema type 'xs:attributeGroup'
        xs__attributeGroup *attributeGroup;
        /// Optional element 'xs:group' of XML schema type 'xs:group'
        xs__group *group;
        /// Optional element 'xs:all' of XML schema type 'xs:all'
        xs__all *all;
        /// Optional element 'xs:choice' of XML schema type 'xs:seqchoice'
        xs__seqchoice *choice;
        /// Optional element 'xs:sequence' of XML schema type 'xs:seqchoice'
        xs__seqchoice *sequence;
        /// Optional element 'xs:attribute' of XML schema type 'xs:attribute'
        std::vector<xs__attribute> attribute;
        /// Optional element 'xs:anyAttribute' of XML schema type 'xs:anyAttribute'
        xs__anyAttribute *anyAttribute;
        /// Optional element 'xs:enumeration' of XML schema type 'xs:enumeration'
        std::vector<xs__enumeration> enumeration;
        /// Optional element 'xs:pattern' of XML schema type 'xs:pattern'
        std::vector<xs__pattern> pattern;
        /// Optional element 'xs:whiteSpace' of XML schema type 'xs:whiteSpace'
        xs__whiteSpace *whiteSpace;
        /// Optional element 'xs:length' of XML schema type 'xs:length'
        xs__length *length;
        /// Optional element 'xs:minLength' of XML schema type 'xs:length'
        xs__length *minLength;
        /// Optional element 'xs:maxLength' of XML schema type 'xs:length'
        xs__length *maxLength;
        /// Optional element 'xs:precision' of XML schema type 'xs:length'
        xs__length *precision;
        /// Optional element 'xs:scale' of XML schema type 'xs:length'
        xs__length *scale;
        /// Optional element 'xs:totalDigits' of XML schema type 'xs:length'
        xs__length *totalDigits;
        /// Optional element 'xs:fractionDigits' of XML schema type 'xs:length'
        xs__length *fractionDigits;
        /// Optional element 'xs:minInclusive' of XML schema type 'xs:length'
        xs__length *minInclusive;
        /// Optional element 'xs:maxInclusive' of XML schema type 'xs:length'
        xs__length *maxInclusive;
        /// Optional element 'xs:minExclusive' of XML schema type 'xs:length'
        xs__length *minExclusive;
        /// Optional element 'xs:maxExclusive' of XML schema type 'xs:length'
        xs__length *maxExclusive;
        /// Optional element 'xs:annotation' of XML schema type 'xs:annotation'
        xs__annotation *annotation;
        /// Optional element 'xs:assert' of XML schema type 'xs:assert'
        std::vector<xs__assert> assert;
        /// Optional element 'xs:assertion' of XML schema type 'xs:assert'
        xs__assert *assertion;
      private:
        /// Not serialized
        xs__simpleType *simpleTypeRef;
        /// Not serialized
        xs__complexType *complexTypeRef;
        /// Not serialized
        xs__simpleType *simpleArrayTypeRef;
        /// Not serialized
        xs__complexType *complexArrayTypeRef;
      public:
        xs__restriction();
        int traverse(xs__schema &_param_1);
        void simpleTypePtr(xs__simpleType *_param_1);
        void complexTypePtr(xs__complexType *_param_1);
        xs__simpleType *simpleTypePtr() const;
        xs__complexType *complexTypePtr() const;
        xs__simpleType *simpleArrayTypePtr() const;
        xs__complexType *complexArrayTypePtr() const;
        void mark();
      public:
        /// Return unique type id SOAP_TYPE_xs__restriction
        virtual long soap_type(void) const { return SOAP_TYPE_xs__restriction; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xs__restriction, default initialized and not managed by a soap context
        virtual xs__restriction *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xs__restriction); }
        virtual ~xs__restriction() { }
        /// Friend allocator used by soap_new_xs__restriction(struct soap*, int)
        friend SOAP_FMAC1 xs__restriction * SOAP_FMAC2 wsdl_instantiate_xs__restriction(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* schema.h:52 */
#ifndef SOAP_TYPE_xs__list
#define SOAP_TYPE_xs__list (30)
/* complex XML schema type 'xs:list': */
class SOAP_CMAC xs__list {
      public:
        /// Optional attribute 'itemType' of XML schema type 'xsd:QName'
        char *itemType;
        /// Optional element 'xs:restriction' of XML schema type 'xs:restriction'
        xs__restriction *restriction;
        /// Optional element 'xs:simpleType' of XML schema type 'xs:simpleType'
        std::vector<xs__simpleType> simpleType;
      private:
        /// Not serialized
        xs__simpleType *itemTypeRef;
      public:
        xs__list();
        int traverse(xs__schema &_param_1);
        void itemTypePtr(xs__simpleType *_param_1);
        xs__simpleType *itemTypePtr() const;
        void mark();
      public:
        /// Return unique type id SOAP_TYPE_xs__list
        virtual long soap_type(void) const { return SOAP_TYPE_xs__list; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xs__list, default initialized and not managed by a soap context
        virtual xs__list *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xs__list); }
        virtual ~xs__list() { }
        /// Friend allocator used by soap_new_xs__list(struct soap*, int)
        friend SOAP_FMAC1 xs__list * SOAP_FMAC2 wsdl_instantiate_xs__list(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* schema.h:53 */
#ifndef SOAP_TYPE_xs__union
#define SOAP_TYPE_xs__union (31)
/* complex XML schema type 'xs:union': */
class SOAP_CMAC xs__union {
      public:
        /// Optional attribute 'memberTypes' of XML schema type 'xsd:NMTOKENS'
        char *memberTypes;
        /// Optional element 'xs:simpleType' of XML schema type 'xs:simpleType'
        std::vector<xs__simpleType> simpleType;
        int traverse(xs__schema &_param_1);
        void mark();
      public:
        /// Return unique type id SOAP_TYPE_xs__union
        virtual long soap_type(void) const { return SOAP_TYPE_xs__union; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xs__union, default initialized and not managed by a soap context
        virtual xs__union *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xs__union); }
      public:
        /// Constructor with default initializations
        xs__union() : memberTypes(), simpleType() { }
        virtual ~xs__union() { }
        /// Friend allocator used by soap_new_xs__union(struct soap*, int)
        friend SOAP_FMAC1 xs__union * SOAP_FMAC2 wsdl_instantiate_xs__union(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* schema.h:449 */
#ifndef SOAP_TYPE_xs__complexContent
#define SOAP_TYPE_xs__complexContent (184)
/* complex XML schema type 'xs:complexContent': */
class SOAP_CMAC xs__complexContent {
      public:
        /// Optional attribute 'mixed' of XML schema type 'xsd:boolean'
        bool mixed;	///< initialized with default value = (bool)0
        /// Optional element 'xs:extension' of XML schema type 'xs:extension'
        xs__extension *extension;
        /// Optional element 'xs:restriction' of XML schema type 'xs:restriction'
        xs__restriction *restriction;
        /// Optional element 'xs:annotation' of XML schema type 'xs:annotation'
        xs__annotation *annotation;
        int traverse(xs__schema &_param_1);
        void mark();
      public:
        /// Return unique type id SOAP_TYPE_xs__complexContent
        virtual long soap_type(void) const { return SOAP_TYPE_xs__complexContent; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xs__complexContent, default initialized and not managed by a soap context
        virtual xs__complexContent *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xs__complexContent); }
      public:
        /// Constructor with default initializations
        xs__complexContent() : mixed((bool)0), extension(), restriction(), annotation() { }
        virtual ~xs__complexContent() { }
        /// Friend allocator used by soap_new_xs__complexContent(struct soap*, int)
        friend SOAP_FMAC1 xs__complexContent * SOAP_FMAC2 wsdl_instantiate_xs__complexContent(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* schema.h:47 */
#ifndef SOAP_TYPE_xs__complexType
#define SOAP_TYPE_xs__complexType (25)
/* Type xs__complexType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'xs:complexType': */
class SOAP_CMAC xs__complexType {
      public:
        /// Optional attribute 'name' of XML schema type 'xsd:NMTOKEN'
        char *name;
        /// Optional attribute 'abstract' of XML schema type 'xsd:boolean'
        bool abstract;	///< initialized with default value = (bool)0
        /// Optional attribute 'mixed' of XML schema type 'xsd:boolean'
        bool mixed;	///< initialized with default value = (bool)0
        /// Optional attribute 'defaultAttributesApply' of XML schema type 'xsd:boolean'
        bool defaultAttributesApply;	///< initialized with default value = (bool)1
        /// Optional attribute 'vc:minVersion' of XML schema type 'xsd:string'
        char *vc__minVersion;
        /// Optional attribute 'vc:maxVersion' of XML schema type 'xsd:string'
        char *vc__maxVersion;
        /// Optional element 'xs:annotation' of XML schema type 'xs:annotation'
        xs__annotation *annotation;
        /// Optional element 'xs:simpleContent' of XML schema type 'xs:simpleContent'
        xs__simpleContent *simpleContent;
        /// Optional element 'xs:complexContent' of XML schema type 'xs:complexContent'
        xs__complexContent *complexContent;
        /// Optional element 'xs:all' of XML schema type 'xs:all'
        xs__all *all;
        /// Optional element 'xs:choice' of XML schema type 'xs:seqchoice'
        xs__seqchoice *choice;
        /// Optional element 'xs:sequence' of XML schema type 'xs:seqchoice'
        xs__seqchoice *sequence;
        /// Optional element 'xs:group' of XML schema type 'xs:group'
        xs__group *group;
        /// Optional element 'xs:any' of XML schema type 'xs:any'
        xs__any *any;
        /// Optional element 'xs:attribute' of XML schema type 'xs:attribute'
        std::vector<xs__attribute> attribute;
        /// Optional element 'xs:attributeGroup' of XML schema type 'xs:attributeGroup'
        std::vector<xs__attributeGroup> attributeGroup;
        /// Optional element 'xs:anyAttribute' of XML schema type 'xs:anyAttribute'
        xs__anyAttribute *anyAttribute;
        /// Optional element 'xs:assert' of XML schema type 'xs:assert'
        std::vector<xs__assert> assert;
      private:
        /// Not serialized
        xs__schema *schemaRef;
        /// Not serialized
        std::vector<xs__complexType *> complextype_extensions;
        /// Not serialized
        std::vector<char *> extensions;
        /// Not serialized
        std::vector<char *> restrictions;
        /// Not serialized
        int level;
        /// Not serialized
        bool used;
      public:
        xs__complexType();
        int traverse(xs__schema &_param_1);
        void schemaPtr(xs__schema *_param_1);
        xs__schema *schemaPtr() const;
        int baseLevel();
        void mark();
        bool is_used() const;
        void add_extension(xs__complexType *_param_1, xs__schema &_param_2, char *_param_3);
        void add_restriction(xs__schema &_param_1, char *_param_2);
        const std::vector<char *> &get_extensions() const;
        const std::vector<char *> &get_restrictions() const;
      public:
        /// Return unique type id SOAP_TYPE_xs__complexType
        virtual long soap_type(void) const { return SOAP_TYPE_xs__complexType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xs__complexType, default initialized and not managed by a soap context
        virtual xs__complexType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xs__complexType); }
        virtual ~xs__complexType() { }
        /// Friend allocator used by soap_new_xs__complexType(struct soap*, int)
        friend SOAP_FMAC1 xs__complexType * SOAP_FMAC2 wsdl_instantiate_xs__complexType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* schema.h:503 */
#ifndef SOAP_TYPE_xs__import
#define SOAP_TYPE_xs__import (200)
/* complex XML schema type 'xs:import': */
class SOAP_CMAC xs__import {
      public:
        /// Optional attribute 'namespace' of XML schema type 'xsd:anyURI'
        char *namespace_;
        /// Optional attribute 'schemaLocation' of XML schema type 'xsd:anyURI'
        char *schemaLocation;
        /// Optional attribute 'location' of XML schema type 'xsd:anyURI'
        char *location;
      private:
        /// Not serialized
        xs__schema *schemaRef;
      public:
        xs__import();
        int preprocess(xs__schema &_param_1);
        int traverse(xs__schema &_param_1);
        void schemaPtr(xs__schema *_param_1);
        xs__schema *schemaPtr() const;
        void mark();
      public:
        /// Return unique type id SOAP_TYPE_xs__import
        virtual long soap_type(void) const { return SOAP_TYPE_xs__import; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xs__import, default initialized and not managed by a soap context
        virtual xs__import *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xs__import); }
        virtual ~xs__import() { }
        /// Friend allocator used by soap_new_xs__import(struct soap*, int)
        friend SOAP_FMAC1 xs__import * SOAP_FMAC2 wsdl_instantiate_xs__import(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* schema.h:520 */
#ifndef SOAP_TYPE_xs__include
#define SOAP_TYPE_xs__include (207)
/* complex XML schema type 'xs:include': */
class SOAP_CMAC xs__include {
      public:
        /// Optional attribute 'schemaLocation' of XML schema type 'xsd:anyURI'
        char *schemaLocation;
      private:
        /// Not serialized
        xs__schema *schemaRef;
      public:
        xs__include();
        int preprocess(xs__schema &_param_1);
        int traverse(xs__schema &_param_1);
        void schemaPtr(xs__schema *_param_1);
        xs__schema *schemaPtr() const;
      public:
        /// Return unique type id SOAP_TYPE_xs__include
        virtual long soap_type(void) const { return SOAP_TYPE_xs__include; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xs__include, default initialized and not managed by a soap context
        virtual xs__include *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xs__include); }
        virtual ~xs__include() { }
        /// Friend allocator used by soap_new_xs__include(struct soap*, int)
        friend SOAP_FMAC1 xs__include * SOAP_FMAC2 wsdl_instantiate_xs__include(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* schema.h:534 */
#ifndef SOAP_TYPE_xs__override
#define SOAP_TYPE_xs__override (213)
/* complex XML schema type 'xs:override': */
class SOAP_CMAC xs__override {
      public:
        /// Optional attribute 'schemaLocation' of XML schema type 'xsd:anyURI'
        char *schemaLocation;
        /// Optional element 'xs:attribute' of XML schema type 'xs:attribute'
        std::vector<xs__attribute> attribute;
        /// Optional element 'xs:element' of XML schema type 'xs:element'
        std::vector<xs__element> element;
        /// Optional element 'xs:group' of XML schema type 'xs:group'
        std::vector<xs__group> group;
        /// Optional element 'xs:attributeGroup' of XML schema type 'xs:attributeGroup'
        std::vector<xs__attributeGroup> attributeGroup;
        /// Optional element 'xs:simpleType' of XML schema type 'xs:simpleType'
        std::vector<xs__simpleType> simpleType;
        /// Optional element 'xs:complexType' of XML schema type 'xs:complexType'
        std::vector<xs__complexType> complexType;
      private:
        /// Not serialized
        xs__schema *schemaRef;
      public:
        xs__override();
        int preprocess(xs__schema &_param_1);
        int traverse(xs__schema &_param_1);
        void schemaPtr(xs__schema *_param_1);
        xs__schema *schemaPtr() const;
      public:
        /// Return unique type id SOAP_TYPE_xs__override
        virtual long soap_type(void) const { return SOAP_TYPE_xs__override; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xs__override, default initialized and not managed by a soap context
        virtual xs__override *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xs__override); }
        virtual ~xs__override() { }
        /// Friend allocator used by soap_new_xs__override(struct soap*, int)
        friend SOAP_FMAC1 xs__override * SOAP_FMAC2 wsdl_instantiate_xs__override(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* schema.h:554 */
#ifndef SOAP_TYPE_xs__redefine
#define SOAP_TYPE_xs__redefine (221)
/* complex XML schema type 'xs:redefine': */
class SOAP_CMAC xs__redefine {
      public:
        /// Optional attribute 'schemaLocation' of XML schema type 'xsd:anyURI'
        char *schemaLocation;
        /// Optional element 'xs:group' of XML schema type 'xs:group'
        std::vector<xs__group> group;
        /// Optional element 'xs:attributeGroup' of XML schema type 'xs:attributeGroup'
        std::vector<xs__attributeGroup> attributeGroup;
        /// Optional element 'xs:simpleType' of XML schema type 'xs:simpleType'
        std::vector<xs__simpleType> simpleType;
        /// Optional element 'xs:complexType' of XML schema type 'xs:complexType'
        std::vector<xs__complexType> complexType;
      private:
        /// Not serialized
        xs__schema *schemaRef;
      public:
        xs__redefine();
        int preprocess(xs__schema &_param_1);
        int traverse(xs__schema &_param_1);
        void schemaPtr(xs__schema *_param_1);
        xs__schema *schemaPtr() const;
      public:
        /// Return unique type id SOAP_TYPE_xs__redefine
        virtual long soap_type(void) const { return SOAP_TYPE_xs__redefine; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xs__redefine, default initialized and not managed by a soap context
        virtual xs__redefine *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xs__redefine); }
        virtual ~xs__redefine() { }
        /// Friend allocator used by soap_new_xs__redefine(struct soap*, int)
        friend SOAP_FMAC1 xs__redefine * SOAP_FMAC2 wsdl_instantiate_xs__redefine(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* schema.h:45 */
#ifndef SOAP_TYPE_xs__schema
#define SOAP_TYPE_xs__schema (23)
/* Type xs__schema is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'xs:schema': */
class SOAP_CMAC xs__schema {
      public:
        /// Optional attribute 'targetNamespace' of XML schema type 'xsd:anyURI'
        char *targetNamespace;	///< initialized with default value = (char*)""
        /// Optional attribute 'version' of XML schema type 'xsd:string'
        char *version;
        /// Optional attribute 'defaultAttributes' of XML schema type 'xsd:NCName'
        char *defaultAttributes;
        /// Optional attribute 'attributeFormDefault' of XML schema type 'xs:formChoice'
        enum xs__formChoice attributeFormDefault;	///< initialized with default value = (enum xs__formChoice)0
        /// Optional attribute 'elementFormDefault' of XML schema type 'xs:formChoice'
        enum xs__formChoice elementFormDefault;	///< initialized with default value = (enum xs__formChoice)0
        /// Optional element 'xs:annotation' of XML schema type 'xs:annotation'
        xs__annotation *annotation;
        /// Optional element 'xs:include' of XML schema type 'xs:include'
        std::vector<xs__include> include;
        /// Optional element 'xs:override' of XML schema type 'xs:override'
        std::vector<xs__override> override_;
        /// Optional element 'xs:redefine' of XML schema type 'xs:redefine'
        std::vector<xs__redefine> redefine;
        /// Optional element 'xs:import' of XML schema type 'xs:import'
        std::vector<xs__import> import;
        /// Optional element 'xs:attribute' of XML schema type 'xs:attribute'
        std::vector<xs__attribute> attribute;
        /// Optional element 'xs:element' of XML schema type 'xs:element'
        std::vector<xs__element> element;
        /// Optional element 'xs:group' of XML schema type 'xs:group'
        std::vector<xs__group> group;
        /// Optional element 'xs:attributeGroup' of XML schema type 'xs:attributeGroup'
        std::vector<xs__attributeGroup> attributeGroup;
        /// Optional element 'xs:simpleType' of XML schema type 'xs:simpleType'
        std::vector<xs__simpleType> simpleType;
        /// Optional element 'xs:complexType' of XML schema type 'xs:complexType'
        std::vector<xs__complexType> complexType;
        /// Context that manages this object
        struct soap *soap;
      private:
        /// Not serialized
        xs__attributeGroup *attributeGroupRef;
        /// Not serialized
        bool updated;
        /// Not serialized
        char *location;
        /// Not serialized
        int redirs;
        /// Not serialized
        MapOfStringToString builtinTypeMap;
        /// Not serialized
        SetOfString builtinTypeSet;
        /// Not serialized
        SetOfString builtinElementSet;
        /// Not serialized
        SetOfString builtinAttributeSet;
        /// Not serialized
        bool used;
      public:
        xs__schema();
        xs__schema(struct soap *_param_1);
        xs__schema(struct soap *_param_1, const char *_param_2, const char *_param_3, const char *_param_4);
        virtual ~xs__schema();
        int get(struct soap *_param_1);
        int preprocess();
        int insert(xs__schema &_param_1);
        int traverse();
        int read(const char *_param_1, const char *_param_2, const char *_param_3);
        void sourceLocation(const char *_param_1);
        const char *sourceLocation();
        char *absoluteLocation(const char *_param_1) const;
        xs__attributeGroup *attributeGroupPtr() const;
        int error();
        void print_fault();
        void builtinType(const char *_param_1);
        void builtinTypeDerivation(xs__schema &_param_1, const char *_param_2, const char *_param_3);
        void builtinElement(const char *_param_1);
        void builtinAttribute(const char *_param_1);
        const SetOfString &builtinTypes() const;
        const MapOfStringToString &builtinTypeDerivations() const;
        const SetOfString &builtinElements() const;
        const SetOfString &builtinAttributes() const;
        bool empty() const;
        void mark();
        friend std::ostream &operator<<(std::ostream &_param_1, const xs__schema &_param_2);
        friend std::istream &operator>>(std::istream &_param_1, xs__schema &_param_2);
      public:
        /// Return unique type id SOAP_TYPE_xs__schema
        virtual long soap_type(void) const { return SOAP_TYPE_xs__schema; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xs__schema, default initialized and not managed by a soap context
        virtual xs__schema *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xs__schema); }
        /// Friend allocator used by soap_new_xs__schema(struct soap*, int)
        friend SOAP_FMAC1 xs__schema * SOAP_FMAC2 wsdl_instantiate_xs__schema(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wadl.h:50 */
#ifndef SOAP_TYPE_wadl__doc
#define SOAP_TYPE_wadl__doc (276)
/* complex XML schema type 'wadl:doc': */
class SOAP_CMAC wadl__doc {
      public:
        /// Optional attribute 'title' of XML schema type 'xsd:string'
        char *title;
        /// Optional attribute 'xml:lang' of XML schema type 'xsd:string'
        char *xml__lang;
        char *__mixed;
      public:
        /// Return unique type id SOAP_TYPE_wadl__doc
        virtual long soap_type(void) const { return SOAP_TYPE_wadl__doc; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wadl__doc, default initialized and not managed by a soap context
        virtual wadl__doc *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wadl__doc); }
      public:
        /// Constructor with default initializations
        wadl__doc() : title(), xml__lang(), __mixed() { }
        virtual ~wadl__doc() { }
        /// Friend allocator used by soap_new_wadl__doc(struct soap*, int)
        friend SOAP_FMAC1 wadl__doc * SOAP_FMAC2 wsdl_instantiate_wadl__doc(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wadl.h:57 */
#ifndef SOAP_TYPE_wadl__option
#define SOAP_TYPE_wadl__option (277)
/* complex XML schema type 'wadl:option': */
class SOAP_CMAC wadl__option {
      public:
        /// Optional attribute 'value' of XML schema type 'xsd:string'
        char *value;
        /// Optional attribute 'mediaType' of XML schema type 'xsd:string'
        char *mediaType;
        /// Optional element 'wadl:doc' of XML schema type 'wadl:doc'
        std::vector<wadl__doc> doc;
      public:
        /// Return unique type id SOAP_TYPE_wadl__option
        virtual long soap_type(void) const { return SOAP_TYPE_wadl__option; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wadl__option, default initialized and not managed by a soap context
        virtual wadl__option *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wadl__option); }
      public:
        /// Constructor with default initializations
        wadl__option() : value(), mediaType(), doc() { }
        virtual ~wadl__option() { }
        /// Friend allocator used by soap_new_wadl__option(struct soap*, int)
        friend SOAP_FMAC1 wadl__option * SOAP_FMAC2 wsdl_instantiate_wadl__option(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wadl.h:64 */
#ifndef SOAP_TYPE_wadl__link
#define SOAP_TYPE_wadl__link (279)
/* complex XML schema type 'wadl:link': */
class SOAP_CMAC wadl__link {
      public:
        /// Optional attribute 'resource_type' of XML schema type 'xsd:anyURI'
        char *resource_USCOREtype;
        /// Optional attribute 'rel' of XML schema type 'xsd:token'
        char *rel;
        /// Optional attribute 'rev' of XML schema type 'xsd:token'
        char *rev;
        /// Optional element 'wadl:doc' of XML schema type 'wadl:doc'
        std::vector<wadl__doc> doc;
      private:
        /// Not serialized
        wadl__resource_USCOREtype *linkRef;
      public:
        wadl__link();
        int traverse(wsdl__definitions &_param_1);
        void linkPtr(wadl__resource_USCOREtype *_param_1);
        const wadl__resource_USCOREtype *linkPtr() const;
      public:
        /// Return unique type id SOAP_TYPE_wadl__link
        virtual long soap_type(void) const { return SOAP_TYPE_wadl__link; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wadl__link, default initialized and not managed by a soap context
        virtual wadl__link *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wadl__link); }
        virtual ~wadl__link() { }
        /// Friend allocator used by soap_new_wadl__link(struct soap*, int)
        friend SOAP_FMAC1 wadl__link * SOAP_FMAC2 wsdl_instantiate_wadl__link(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wadl.h:79 */
#ifndef SOAP_TYPE_wadl__param
#define SOAP_TYPE_wadl__param (287)
/* Type wadl__param is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'wadl:param': */
class SOAP_CMAC wadl__param {
      public:
        /// Optional attribute 'href' of XML schema type 'xsd:anyURI'
        char *href;
        /// Optional attribute 'name' of XML schema type 'xsd:NMTOKEN'
        char *name;
        /// Optional attribute 'style' of XML schema type 'wadl:ParamStyle'
        enum wadl__ParamStyle *style;
        /// Optional attribute 'id' of XML schema type 'xsd:ID'
        char *id;
        /// Optional attribute 'type' of XML schema type 'xsd:QName'
        char *type;
        /// Optional attribute 'default' of XML schema type 'xsd:string'
        char *default_;
        /// Optional attribute 'required' of XML schema type 'xsd:boolean'
        bool required;	///< initialized with default value = (bool)0
        /// Optional attribute 'repeating' of XML schema type 'xsd:boolean'
        bool repeating;	///< initialized with default value = (bool)0
        /// Optional attribute 'fixed' of XML schema type 'xsd:string'
        char *fixed;
        /// Optional attribute 'path' of XML schema type 'xsd:string'
        char *path;
        /// Optional element 'wadl:doc' of XML schema type 'wadl:doc'
        std::vector<wadl__doc> doc;
        /// Optional element 'wadl:option' of XML schema type 'wadl:option'
        std::vector<wadl__option> option;
        /// Optional element 'wadl:link' of XML schema type 'wadl:link'
        wadl__link *link;
      private:
        /// Not serialized
        wadl__param *paramRef;
        /// Not serialized
        xs__simpleType *simpleTypeRef;
        /// Not serialized
        xs__complexType *complexTypeRef;
      public:
        wadl__param();
        int traverse(wsdl__definitions &_param_1);
        void paramPtr(wadl__param *_param_1);
        const wadl__param *paramPtr() const;
        void simpleTypePtr(xs__simpleType *_param_1);
        xs__simpleType *simpleTypePtr() const;
        void complexTypePtr(xs__complexType *_param_1);
        xs__complexType *complexTypePtr() const;
        void mark();
      public:
        /// Return unique type id SOAP_TYPE_wadl__param
        virtual long soap_type(void) const { return SOAP_TYPE_wadl__param; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wadl__param, default initialized and not managed by a soap context
        virtual wadl__param *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wadl__param); }
        virtual ~wadl__param() { }
        /// Friend allocator used by soap_new_wadl__param(struct soap*, int)
        friend SOAP_FMAC1 wadl__param * SOAP_FMAC2 wsdl_instantiate_wadl__param(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wadl.h:110 */
#ifndef SOAP_TYPE_wadl__include
#define SOAP_TYPE_wadl__include (302)
/* complex XML schema type 'wadl:include': */
class SOAP_CMAC wadl__include {
      public:
        /// Optional attribute 'href' of XML schema type 'xsd:anyURI'
        char *href;
        /// Optional element 'wadl:doc' of XML schema type 'wadl:doc'
        std::vector<wadl__doc> doc;
        int preprocess(wsdl__definitions &_param_1);
      public:
        /// Return unique type id SOAP_TYPE_wadl__include
        virtual long soap_type(void) const { return SOAP_TYPE_wadl__include; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wadl__include, default initialized and not managed by a soap context
        virtual wadl__include *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wadl__include); }
      public:
        /// Constructor with default initializations
        wadl__include() : href(), doc() { }
        virtual ~wadl__include() { }
        /// Friend allocator used by soap_new_wadl__include(struct soap*, int)
        friend SOAP_FMAC1 wadl__include * SOAP_FMAC2 wsdl_instantiate_wadl__include(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wadl.h:118 */
#ifndef SOAP_TYPE_wadl__grammars
#define SOAP_TYPE_wadl__grammars (304)
/* complex XML schema type 'wadl:grammars': */
class SOAP_CMAC wadl__grammars {
      public:
        /// Optional element 'wadl:doc' of XML schema type 'wadl:doc'
        std::vector<wadl__doc> doc;
        /// Optional element 'wadl:include' of XML schema type 'wadl:include'
        std::vector<wadl__include> include;
        int preprocess(wsdl__definitions &_param_1);
      public:
        /// Return unique type id SOAP_TYPE_wadl__grammars
        virtual long soap_type(void) const { return SOAP_TYPE_wadl__grammars; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wadl__grammars, default initialized and not managed by a soap context
        virtual wadl__grammars *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wadl__grammars); }
      public:
        /// Constructor with default initializations
        wadl__grammars() : doc(), include() { }
        virtual ~wadl__grammars() { }
        /// Friend allocator used by soap_new_wadl__grammars(struct soap*, int)
        friend SOAP_FMAC1 wadl__grammars * SOAP_FMAC2 wsdl_instantiate_wadl__grammars(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wadl.h:126 */
#ifndef SOAP_TYPE_wadl__representation
#define SOAP_TYPE_wadl__representation (307)
/* Type wadl__representation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'wadl:representation': */
class SOAP_CMAC wadl__representation {
      public:
        /// Optional attribute 'id' of XML schema type 'xsd:ID'
        char *id;
        /// Optional attribute 'element' of XML schema type 'xsd:QName'
        char *element;
        /// Optional attribute 'mediaType' of XML schema type 'xsd:string'
        char *mediaType;
        /// Optional attribute 'href' of XML schema type 'xsd:anyURI'
        char *href;
        /// Optional attribute 'profile' of XML schema type 'xsd:anyURI'
        char *profile;
        /// Optional element 'wadl:doc' of XML schema type 'wadl:doc'
        std::vector<wadl__doc> doc;
        /// Optional element 'wadl:param' of XML schema type 'wadl:param'
        std::vector<wadl__param> param;
      private:
        /// Not serialized
        wadl__representation *representationRef;
        /// Not serialized
        xs__element *elementRef;
      public:
        wadl__representation();
        int traverse(wsdl__definitions &_param_1);
        void representationPtr(wadl__representation *_param_1);
        const wadl__representation *representationPtr() const;
        void elementPtr(xs__element *_param_1);
        xs__element *elementPtr() const;
        void mark();
      public:
        /// Return unique type id SOAP_TYPE_wadl__representation
        virtual long soap_type(void) const { return SOAP_TYPE_wadl__representation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wadl__representation, default initialized and not managed by a soap context
        virtual wadl__representation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wadl__representation); }
        virtual ~wadl__representation() { }
        /// Friend allocator used by soap_new_wadl__representation(struct soap*, int)
        friend SOAP_FMAC1 wadl__representation * SOAP_FMAC2 wsdl_instantiate_wadl__representation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wadl.h:148 */
#ifndef SOAP_TYPE_wadl__request
#define SOAP_TYPE_wadl__request (318)
/* complex XML schema type 'wadl:request': */
class SOAP_CMAC wadl__request {
      public:
        /// Optional element 'wadl:doc' of XML schema type 'wadl:doc'
        std::vector<wadl__doc> doc;
        /// Optional element 'wadl:param' of XML schema type 'wadl:param'
        std::vector<wadl__param> param;
        /// Optional element 'wadl:representation' of XML schema type 'wadl:representation'
        std::vector<wadl__representation> representation;
        int traverse(wsdl__definitions &_param_1);
        void mark();
      public:
        /// Return unique type id SOAP_TYPE_wadl__request
        virtual long soap_type(void) const { return SOAP_TYPE_wadl__request; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wadl__request, default initialized and not managed by a soap context
        virtual wadl__request *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wadl__request); }
      public:
        /// Constructor with default initializations
        wadl__request() : doc(), param(), representation() { }
        virtual ~wadl__request() { }
        /// Friend allocator used by soap_new_wadl__request(struct soap*, int)
        friend SOAP_FMAC1 wadl__request * SOAP_FMAC2 wsdl_instantiate_wadl__request(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wadl.h:158 */
#ifndef SOAP_TYPE_wadl__response
#define SOAP_TYPE_wadl__response (322)
/* complex XML schema type 'wadl:response': */
class SOAP_CMAC wadl__response : public wadl__request {
      public:
        /// Optional attribute 'status' of XML schema type 'wadl:statusCodeList'
        char *status;
      public:
        /// Return unique type id SOAP_TYPE_wadl__response
        virtual long soap_type(void) const { return SOAP_TYPE_wadl__response; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wadl__response, default initialized and not managed by a soap context
        virtual wadl__response *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wadl__response); }
      public:
        /// Constructor with default initializations
        wadl__response() : status() { }
        virtual ~wadl__response() { }
        /// Friend allocator used by soap_new_wadl__response(struct soap*, int)
        friend SOAP_FMAC1 wadl__response * SOAP_FMAC2 wsdl_instantiate_wadl__response(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wadl.h:163 */
#ifndef SOAP_TYPE_wadl__method
#define SOAP_TYPE_wadl__method (323)
/* Type wadl__method is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'wadl:method': */
class SOAP_CMAC wadl__method {
      public:
        /// Optional attribute 'id' of XML schema type 'xsd:ID'
        char *id;
        /// Optional attribute 'name' of XML schema type 'wadl:HTTPMethods'
        enum wadl__HTTPMethods name;
        /// Optional attribute 'href' of XML schema type 'xsd:anyURI'
        char *href;
        /// Optional element 'wadl:doc' of XML schema type 'wadl:doc'
        std::vector<wadl__doc> doc;
        /// Optional element 'wadl:request' of XML schema type 'wadl:request'
        wadl__request *request;
        /// Optional element 'wadl:response' of XML schema type 'wadl:response'
        std::vector<wadl__response> response;
      private:
        /// Not serialized
        wadl__method *methodRef;
      public:
        wadl__method();
        int traverse(wsdl__definitions &_param_1);
        void methodPtr(wadl__method *_param_1);
        const wadl__method *methodPtr() const;
        void mark();
      public:
        /// Return unique type id SOAP_TYPE_wadl__method
        virtual long soap_type(void) const { return SOAP_TYPE_wadl__method; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wadl__method, default initialized and not managed by a soap context
        virtual wadl__method *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wadl__method); }
        virtual ~wadl__method() { }
        /// Friend allocator used by soap_new_wadl__method(struct soap*, int)
        friend SOAP_FMAC1 wadl__method * SOAP_FMAC2 wsdl_instantiate_wadl__method(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wadl.h:181 */
#ifndef SOAP_TYPE___wadl__method_resource_choice
#define SOAP_TYPE___wadl__method_resource_choice (333)
/* Wrapper: */
class SOAP_CMAC __wadl__method_resource_choice {
      public:
        /// Optional element 'wadl:method' of XML schema type 'wadl:method'
        wadl__method *method;
        /// Optional element 'wadl:resource' of XML schema type 'wadl:resource'
        wadl__resource *resource;
        int traverse(wsdl__definitions &_param_1);
      public:
        /// Return unique type id SOAP_TYPE___wadl__method_resource_choice
        virtual long soap_type(void) const { return SOAP_TYPE___wadl__method_resource_choice; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __wadl__method_resource_choice, default initialized and not managed by a soap context
        virtual __wadl__method_resource_choice *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__wadl__method_resource_choice); }
      public:
        /// Constructor with default initializations
        __wadl__method_resource_choice() : method(), resource() { }
        virtual ~__wadl__method_resource_choice() { }
        /// Friend allocator used by soap_new___wadl__method_resource_choice(struct soap*, int)
        friend SOAP_FMAC1 __wadl__method_resource_choice * SOAP_FMAC2 wsdl_instantiate___wadl__method_resource_choice(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wadl.h:42 */
#ifndef SOAP_TYPE_wadl__resource_USCOREtype
#define SOAP_TYPE_wadl__resource_USCOREtype (272)
/* Type wadl__resource_USCOREtype is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'wadl:resource_type': */
class SOAP_CMAC wadl__resource_USCOREtype {
      public:
        /// Optional attribute 'id' of XML schema type 'xsd:ID'
        char *id;
        /// Optional element 'wadl:doc' of XML schema type 'wadl:doc'
        std::vector<wadl__doc> doc;
        /// Optional element 'wadl:param' of XML schema type 'wadl:param'
        std::vector<wadl__param> param;
        std::vector<__wadl__method_resource_choice> __choice;
        int traverse(wsdl__definitions &_param_1);
      public:
        /// Return unique type id SOAP_TYPE_wadl__resource_USCOREtype
        virtual long soap_type(void) const { return SOAP_TYPE_wadl__resource_USCOREtype; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wadl__resource_USCOREtype, default initialized and not managed by a soap context
        virtual wadl__resource_USCOREtype *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wadl__resource_USCOREtype); }
      public:
        /// Constructor with default initializations
        wadl__resource_USCOREtype() : id(), doc(), param(), __choice() { }
        virtual ~wadl__resource_USCOREtype() { }
        /// Friend allocator used by soap_new_wadl__resource_USCOREtype(struct soap*, int)
        friend SOAP_FMAC1 wadl__resource_USCOREtype * SOAP_FMAC2 wsdl_instantiate_wadl__resource_USCOREtype(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wadl.h:41 */
#ifndef SOAP_TYPE_wadl__resource
#define SOAP_TYPE_wadl__resource (271)
/* Type wadl__resource is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'wadl:resource': */
class SOAP_CMAC wadl__resource : public wadl__resource_USCOREtype {
      public:
        /// Optional attribute 'type' of XML schema type 'xsd:anyURI'
        char *type;
        /// Optional attribute 'queryType' of XML schema type 'xsd:string'
        char *queryType;	///< initialized with default value = (char*)"application/x-www-form-urlencoded"
        /// Optional attribute 'path' of XML schema type 'xsd:string'
        char *path;
      private:
        /// Not serialized
        std::vector<wadl__resource_USCOREtype *> typeRefs;
      public:
        int traverse(wsdl__definitions &_param_1);
        void typePtr(wadl__resource_USCOREtype *_param_1);
        const std::vector<wadl__resource_USCOREtype *> &typePtrs() const;
      public:
        /// Return unique type id SOAP_TYPE_wadl__resource
        virtual long soap_type(void) const { return SOAP_TYPE_wadl__resource; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wadl__resource, default initialized and not managed by a soap context
        virtual wadl__resource *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wadl__resource); }
      public:
        /// Constructor with default initializations
        wadl__resource() : type(), queryType((char*)"application/x-www-form-urlencoded"), path(), typeRefs() { }
        virtual ~wadl__resource() { }
        /// Friend allocator used by soap_new_wadl__resource(struct soap*, int)
        friend SOAP_FMAC1 wadl__resource * SOAP_FMAC2 wsdl_instantiate_wadl__resource(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wadl.h:212 */
#ifndef SOAP_TYPE_wadl__resources
#define SOAP_TYPE_wadl__resources (343)
/* complex XML schema type 'wadl:resources': */
class SOAP_CMAC wadl__resources {
      public:
        /// Optional attribute 'base' of XML schema type 'xsd:anyURI'
        char *base;
        /// Optional element 'wadl:doc' of XML schema type 'wadl:doc'
        std::vector<wadl__doc> doc;
        /// Optional element 'wadl:resource' of XML schema type 'wadl:resource'
        std::vector<wadl__resource> resource;
        int traverse(wsdl__definitions &_param_1);
      public:
        /// Return unique type id SOAP_TYPE_wadl__resources
        virtual long soap_type(void) const { return SOAP_TYPE_wadl__resources; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wadl__resources, default initialized and not managed by a soap context
        virtual wadl__resources *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wadl__resources); }
      public:
        /// Constructor with default initializations
        wadl__resources() : base(), doc(), resource() { }
        virtual ~wadl__resources() { }
        /// Friend allocator used by soap_new_wadl__resources(struct soap*, int)
        friend SOAP_FMAC1 wadl__resources * SOAP_FMAC2 wsdl_instantiate_wadl__resources(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wadl.h:221 */
#ifndef SOAP_TYPE_wadl__application
#define SOAP_TYPE_wadl__application (346)
/* complex XML schema type 'wadl:application': */
class SOAP_CMAC wadl__application {
      public:
        /// Optional element 'wadl:doc' of XML schema type 'wadl:doc'
        std::vector<wadl__doc> doc;
        /// Optional element 'wadl:grammars' of XML schema type 'wadl:grammars'
        wadl__grammars *grammars;
        /// Optional element 'wadl:resources' of XML schema type 'wadl:resources'
        std::vector<wadl__resources> resources;
        /// Optional element 'wadl:resource_type' of XML schema type 'wadl:resource_type'
        std::vector<wadl__resource_USCOREtype> resource_USCOREtype;
        /// Optional element 'wadl:method' of XML schema type 'wadl:method'
        std::vector<wadl__method> method;
        /// Optional element 'wadl:representation' of XML schema type 'wadl:representation'
        std::vector<wadl__representation> representation;
        /// Optional element 'wadl:param' of XML schema type 'wadl:param'
        std::vector<wadl__param> param;
        /// Context that manages this object
        struct soap *soap;
        int preprocess(wsdl__definitions &_param_1);
        int traverse(wsdl__definitions &_param_1);
        void mark();
      public:
        /// Return unique type id SOAP_TYPE_wadl__application
        virtual long soap_type(void) const { return SOAP_TYPE_wadl__application; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wadl__application, default initialized and not managed by a soap context
        virtual wadl__application *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wadl__application); }
      public:
        /// Constructor with default initializations
        wadl__application() : doc(), grammars(), resources(), resource_USCOREtype(), method(), representation(), param(), soap() { }
        virtual ~wadl__application() { }
        /// Friend allocator used by soap_new_wadl__application(struct soap*, int)
        friend SOAP_FMAC1 wadl__application * SOAP_FMAC2 wsdl_instantiate_wadl__application(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap.h:52 */
#ifndef SOAP_TYPE_soap__binding
#define SOAP_TYPE_soap__binding (357)
/* complex XML schema type 'soap:binding': */
class SOAP_CMAC soap__binding {
      public:
        /// Optional attribute 'transport' of XML schema type 'xsd:anyURI'
        char *transport;
        /// Optional attribute 'style' of XML schema type 'soap:styleChoice'
        enum soap__styleChoice *style;
      public:
        /// Return unique type id SOAP_TYPE_soap__binding
        virtual long soap_type(void) const { return SOAP_TYPE_soap__binding; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type soap__binding, default initialized and not managed by a soap context
        virtual soap__binding *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(soap__binding); }
      public:
        /// Constructor with default initializations
        soap__binding() : transport(), style() { }
        virtual ~soap__binding() { }
        /// Friend allocator used by soap_new_soap__binding(struct soap*, int)
        friend SOAP_FMAC1 soap__binding * SOAP_FMAC2 wsdl_instantiate_soap__binding(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap.h:58 */
#ifndef SOAP_TYPE_soap__operation
#define SOAP_TYPE_soap__operation (359)
/* complex XML schema type 'soap:operation': */
class SOAP_CMAC soap__operation {
      public:
        /// Optional attribute 'soapAction' of XML schema type 'xsd:anyURI'
        char *soapAction;
        /// Optional attribute 'soapActionRequired' of XML schema type 'xsd:boolean'
        bool soapActionRequired;	///< initialized with default value = (bool)1
        /// Optional attribute 'style' of XML schema type 'soap:styleChoice'
        enum soap__styleChoice *style;
      public:
        /// Return unique type id SOAP_TYPE_soap__operation
        virtual long soap_type(void) const { return SOAP_TYPE_soap__operation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type soap__operation, default initialized and not managed by a soap context
        virtual soap__operation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(soap__operation); }
      public:
        /// Constructor with default initializations
        soap__operation() : soapAction(), soapActionRequired((bool)1), style() { }
        virtual ~soap__operation() { }
        /// Friend allocator used by soap_new_soap__operation(struct soap*, int)
        friend SOAP_FMAC1 soap__operation * SOAP_FMAC2 wsdl_instantiate_soap__operation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap.h:67 */
#ifndef SOAP_TYPE_soap__body
#define SOAP_TYPE_soap__body (361)
/* complex XML schema type 'soap:body': */
class SOAP_CMAC soap__body {
      public:
        /// Optional attribute 'encodingStyle' of XML schema type 'xsd:anyURI'
        char *encodingStyle;
        /// Optional attribute 'parts' of XML schema type 'xsd:NMTOKENS'
        char *parts;
        /// Optional attribute 'use' of XML schema type 'soap:useChoice'
        enum soap__useChoice use;
        /// Optional attribute 'namespace' of XML schema type 'xsd:anyURI'
        char *namespace_;
      public:
        /// Return unique type id SOAP_TYPE_soap__body
        virtual long soap_type(void) const { return SOAP_TYPE_soap__body; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type soap__body, default initialized and not managed by a soap context
        virtual soap__body *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(soap__body); }
      public:
        /// Constructor with default initializations
        soap__body() : encodingStyle(), parts(), use(), namespace_() { }
        virtual ~soap__body() { }
        /// Friend allocator used by soap_new_soap__body(struct soap*, int)
        friend SOAP_FMAC1 soap__body * SOAP_FMAC2 wsdl_instantiate_soap__body(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap.h:75 */
#ifndef SOAP_TYPE_soap__fault
#define SOAP_TYPE_soap__fault (362)
/* complex XML schema type 'soap:fault': */
class SOAP_CMAC soap__fault {
      public:
        /// Optional attribute 'name' of XML schema type 'xsd:NMTOKEN'
        char *name;
        /// Optional attribute 'encodingStyle' of XML schema type 'xsd:anyURI'
        char *encodingStyle;
        /// Optional attribute 'use' of XML schema type 'soap:useChoice'
        enum soap__useChoice use;
        /// Optional attribute 'namespace' of XML schema type 'xsd:anyURI'
        char *namespace_;
      public:
        /// Return unique type id SOAP_TYPE_soap__fault
        virtual long soap_type(void) const { return SOAP_TYPE_soap__fault; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type soap__fault, default initialized and not managed by a soap context
        virtual soap__fault *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(soap__fault); }
      public:
        /// Constructor with default initializations
        soap__fault() : name(), encodingStyle(), use(), namespace_() { }
        virtual ~soap__fault() { }
        /// Friend allocator used by soap_new_soap__fault(struct soap*, int)
        friend SOAP_FMAC1 soap__fault * SOAP_FMAC2 wsdl_instantiate_soap__fault(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap.h:83 */
#ifndef SOAP_TYPE_soap__headerfault
#define SOAP_TYPE_soap__headerfault (363)
/* complex XML schema type 'soap:headerfault': */
class SOAP_CMAC soap__headerfault {
      public:
        /// Optional attribute 'message' of XML schema type 'xsd:QName'
        char *message;
        /// Optional attribute 'part' of XML schema type 'xsd:NMTOKEN'
        char *part;
        /// Optional attribute 'use' of XML schema type 'soap:useChoice'
        enum soap__useChoice use;
        /// Optional attribute 'encodingStyle' of XML schema type 'xsd:anyURI'
        char *encodingStyle;
        /// Optional attribute 'namespace' of XML schema type 'xsd:anyURI'
        char *namespace_;
      private:
        /// Not serialized
        wsdl__message *messageRef;
        /// Not serialized
        wsdl__part *partRef;
      public:
        int traverse(wsdl__definitions &_param_1);
        void messagePtr(wsdl__message *_param_1);
        void partPtr(wsdl__part *_param_1);
        wsdl__message *messagePtr() const;
        wsdl__part *partPtr() const;
      public:
        /// Return unique type id SOAP_TYPE_soap__headerfault
        virtual long soap_type(void) const { return SOAP_TYPE_soap__headerfault; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type soap__headerfault, default initialized and not managed by a soap context
        virtual soap__headerfault *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(soap__headerfault); }
      public:
        /// Constructor with default initializations
        soap__headerfault() : message(), part(), use(), encodingStyle(), namespace_(), messageRef(), partRef() { }
        virtual ~soap__headerfault() { }
        /// Friend allocator used by soap_new_soap__headerfault(struct soap*, int)
        friend SOAP_FMAC1 soap__headerfault * SOAP_FMAC2 wsdl_instantiate_soap__headerfault(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap.h:101 */
#ifndef SOAP_TYPE_soap__header
#define SOAP_TYPE_soap__header (373)
/* complex XML schema type 'soap:header': */
class SOAP_CMAC soap__header {
      public:
        /// Optional attribute 'message' of XML schema type 'xsd:QName'
        char *message;
        /// Optional attribute 'part' of XML schema type 'xsd:NMTOKEN'
        char *part;
        /// Optional attribute 'use' of XML schema type 'soap:useChoice'
        enum soap__useChoice use;
        /// Optional attribute 'encodingStyle' of XML schema type 'xsd:anyURI'
        char *encodingStyle;
        /// Optional attribute 'namespace' of XML schema type 'xsd:anyURI'
        char *namespace_;
        /// Optional element 'soap:headerfault' of XML schema type 'soap:headerfault'
        std::vector<soap__headerfault> headerfault;
      private:
        /// Not serialized
        wsdl__message *messageRef;
        /// Not serialized
        wsdl__part *partRef;
      public:
        int traverse(wsdl__definitions &_param_1);
        void messagePtr(wsdl__message *_param_1);
        void partPtr(wsdl__part *_param_1);
        wsdl__message *messagePtr() const;
        wsdl__part *partPtr() const;
      public:
        /// Return unique type id SOAP_TYPE_soap__header
        virtual long soap_type(void) const { return SOAP_TYPE_soap__header; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type soap__header, default initialized and not managed by a soap context
        virtual soap__header *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(soap__header); }
      public:
        /// Constructor with default initializations
        soap__header() : message(), part(), use(), encodingStyle(), namespace_(), headerfault(), messageRef(), partRef() { }
        virtual ~soap__header() { }
        /// Friend allocator used by soap_new_soap__header(struct soap*, int)
        friend SOAP_FMAC1 soap__header * SOAP_FMAC2 wsdl_instantiate_soap__header(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap.h:120 */
#ifndef SOAP_TYPE_soap__address
#define SOAP_TYPE_soap__address (380)
/* complex XML schema type 'soap:address': */
class SOAP_CMAC soap__address {
      public:
        /// Optional attribute 'location' of XML schema type 'xsd:anyURI'
        char *location;
      public:
        /// Return unique type id SOAP_TYPE_soap__address
        virtual long soap_type(void) const { return SOAP_TYPE_soap__address; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type soap__address, default initialized and not managed by a soap context
        virtual soap__address *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(soap__address); }
      public:
        /// Constructor with default initializations
        soap__address() : location() { }
        virtual ~soap__address() { }
        /// Friend allocator used by soap_new_soap__address(struct soap*, int)
        friend SOAP_FMAC1 soap__address * SOAP_FMAC2 wsdl_instantiate_soap__address(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap.h:125 */
#ifndef SOAP_TYPE_wsoap__module
#define SOAP_TYPE_wsoap__module (381)
/* complex XML schema type 'wsoap:module': */
class SOAP_CMAC wsoap__module {
      public:
        /// Optional attribute 'ref' of XML schema type 'xsd:anyURI'
        char *ref;
        /// Optional attribute 'required' of XML schema type 'xsd:boolean'
        bool required;	///< initialized with default value = (bool)0
      public:
        /// Return unique type id SOAP_TYPE_wsoap__module
        virtual long soap_type(void) const { return SOAP_TYPE_wsoap__module; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsoap__module, default initialized and not managed by a soap context
        virtual wsoap__module *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsoap__module); }
      public:
        /// Constructor with default initializations
        wsoap__module() : ref(), required((bool)0) { }
        virtual ~wsoap__module() { }
        /// Friend allocator used by soap_new_wsoap__module(struct soap*, int)
        friend SOAP_FMAC1 wsoap__module * SOAP_FMAC2 wsdl_instantiate_wsoap__module(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap.h:131 */
#ifndef SOAP_TYPE_wsoap__header
#define SOAP_TYPE_wsoap__header (382)
/* complex XML schema type 'wsoap:header': */
class SOAP_CMAC wsoap__header {
      public:
        /// Optional attribute 'element' of XML schema type 'xsd:QName'
        char *element;
        /// Optional attribute 'mustUnderstand' of XML schema type 'xsd:boolean'
        bool mustUnderstand_;	///< initialized with default value = (bool)0
        /// Optional attribute 'required' of XML schema type 'xsd:boolean'
        bool required;	///< initialized with default value = (bool)0
      private:
        /// Not serialized
        xs__element *elementRef;
      public:
        int traverse(wsdl__definitions &_param_1);
        void elementPtr(xs__element *_param_1);
        xs__element *elementPtr() const;
        void mark();
      public:
        /// Return unique type id SOAP_TYPE_wsoap__header
        virtual long soap_type(void) const { return SOAP_TYPE_wsoap__header; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsoap__header, default initialized and not managed by a soap context
        virtual wsoap__header *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsoap__header); }
      public:
        /// Constructor with default initializations
        wsoap__header() : element(), mustUnderstand_((bool)0), required((bool)0), elementRef() { }
        virtual ~wsoap__header() { }
        /// Friend allocator used by soap_new_wsoap__header(struct soap*, int)
        friend SOAP_FMAC1 wsoap__header * SOAP_FMAC2 wsdl_instantiate_wsoap__header(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mime.h:46 */
#ifndef SOAP_TYPE_mime__content
#define SOAP_TYPE_mime__content (387)
/* complex XML schema type 'mime:content': */
class SOAP_CMAC mime__content {
      public:
        /// Optional attribute 'part' of XML schema type 'xsd:NMTOKEN'
        char *part;
        /// Optional attribute 'type' of XML schema type 'xsd:string'
        char *type;
      public:
        /// Return unique type id SOAP_TYPE_mime__content
        virtual long soap_type(void) const { return SOAP_TYPE_mime__content; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type mime__content, default initialized and not managed by a soap context
        virtual mime__content *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(mime__content); }
      public:
        /// Constructor with default initializations
        mime__content() : part(), type() { }
        virtual ~mime__content() { }
        /// Friend allocator used by soap_new_mime__content(struct soap*, int)
        friend SOAP_FMAC1 mime__content * SOAP_FMAC2 wsdl_instantiate_mime__content(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mime.h:52 */
#ifndef SOAP_TYPE_mime__part
#define SOAP_TYPE_mime__part (388)
/* complex XML schema type 'mime:part': */
class SOAP_CMAC mime__part {
      public:
        /// Optional element 'soap:body' of XML schema type 'soap:body'
        soap__body *soap__body_;
        /// Optional element 'soap:header' of XML schema type 'soap:header'
        std::vector<soap__header> soap__header_;
        /// Optional element 'mime:content' of XML schema type 'mime:content'
        std::vector<mime__content> content;
        int traverse(wsdl__definitions &_param_1);
      public:
        /// Return unique type id SOAP_TYPE_mime__part
        virtual long soap_type(void) const { return SOAP_TYPE_mime__part; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type mime__part, default initialized and not managed by a soap context
        virtual mime__part *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(mime__part); }
      public:
        /// Constructor with default initializations
        mime__part() : soap__body_(), soap__header_(), content() { }
        virtual ~mime__part() { }
        /// Friend allocator used by soap_new_mime__part(struct soap*, int)
        friend SOAP_FMAC1 mime__part * SOAP_FMAC2 wsdl_instantiate_mime__part(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mime.h:61 */
#ifndef SOAP_TYPE_mime__multipartRelated
#define SOAP_TYPE_mime__multipartRelated (393)
/* complex XML schema type 'mime:multipartRelated': */
class SOAP_CMAC mime__multipartRelated {
      public:
        /// Optional element 'mime:part' of XML schema type 'mime:part'
        std::vector<mime__part> part;
        int traverse(wsdl__definitions &_param_1);
      public:
        /// Return unique type id SOAP_TYPE_mime__multipartRelated
        virtual long soap_type(void) const { return SOAP_TYPE_mime__multipartRelated; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type mime__multipartRelated, default initialized and not managed by a soap context
        virtual mime__multipartRelated *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(mime__multipartRelated); }
      public:
        /// Constructor with default initializations
        mime__multipartRelated() : part() { }
        virtual ~mime__multipartRelated() { }
        /// Friend allocator used by soap_new_mime__multipartRelated(struct soap*, int)
        friend SOAP_FMAC1 mime__multipartRelated * SOAP_FMAC2 wsdl_instantiate_mime__multipartRelated(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* mime.h:68 */
#ifndef SOAP_TYPE_mime__mimeXml
#define SOAP_TYPE_mime__mimeXml (396)
/* complex XML schema type 'mime:mimeXml': */
class SOAP_CMAC mime__mimeXml {
      public:
        /// Optional attribute 'part' of XML schema type 'xsd:NMTOKEN'
        char *part;
      public:
        /// Return unique type id SOAP_TYPE_mime__mimeXml
        virtual long soap_type(void) const { return SOAP_TYPE_mime__mimeXml; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type mime__mimeXml, default initialized and not managed by a soap context
        virtual mime__mimeXml *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(mime__mimeXml); }
      public:
        /// Constructor with default initializations
        mime__mimeXml() : part() { }
        virtual ~mime__mimeXml() { }
        /// Friend allocator used by soap_new_mime__mimeXml(struct soap*, int)
        friend SOAP_FMAC1 mime__mimeXml * SOAP_FMAC2 wsdl_instantiate_mime__mimeXml(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* dime.h:40 */
#ifndef SOAP_TYPE_dime__message
#define SOAP_TYPE_dime__message (397)
/* complex XML schema type 'dime:message': */
class SOAP_CMAC dime__message {
      public:
        /// Optional attribute 'layout' of XML schema type 'xsd:anyURI'
        char *layout;
      public:
        /// Return unique type id SOAP_TYPE_dime__message
        virtual long soap_type(void) const { return SOAP_TYPE_dime__message; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type dime__message, default initialized and not managed by a soap context
        virtual dime__message *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(dime__message); }
      public:
        /// Constructor with default initializations
        dime__message() : layout() { }
        virtual ~dime__message() { }
        /// Friend allocator used by soap_new_dime__message(struct soap*, int)
        friend SOAP_FMAC1 dime__message * SOAP_FMAC2 wsdl_instantiate_dime__message(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* http.h:46 */
#ifndef SOAP_TYPE_http__address
#define SOAP_TYPE_http__address (398)
/* complex XML schema type 'http:address': */
class SOAP_CMAC http__address {
      public:
        /// Optional attribute 'location' of XML schema type 'xsd:anyURI'
        char *location;
      public:
        /// Return unique type id SOAP_TYPE_http__address
        virtual long soap_type(void) const { return SOAP_TYPE_http__address; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type http__address, default initialized and not managed by a soap context
        virtual http__address *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(http__address); }
      public:
        /// Constructor with default initializations
        http__address() : location() { }
        virtual ~http__address() { }
        /// Friend allocator used by soap_new_http__address(struct soap*, int)
        friend SOAP_FMAC1 http__address * SOAP_FMAC2 wsdl_instantiate_http__address(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* http.h:51 */
#ifndef SOAP_TYPE_http__binding
#define SOAP_TYPE_http__binding (399)
/* complex XML schema type 'http:binding': */
class SOAP_CMAC http__binding {
      public:
        /// Optional attribute 'verb' of XML schema type 'xsd:NMTOKEN'
        char *verb;
      public:
        /// Return unique type id SOAP_TYPE_http__binding
        virtual long soap_type(void) const { return SOAP_TYPE_http__binding; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type http__binding, default initialized and not managed by a soap context
        virtual http__binding *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(http__binding); }
      public:
        /// Constructor with default initializations
        http__binding() : verb() { }
        virtual ~http__binding() { }
        /// Friend allocator used by soap_new_http__binding(struct soap*, int)
        friend SOAP_FMAC1 http__binding * SOAP_FMAC2 wsdl_instantiate_http__binding(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* http.h:56 */
#ifndef SOAP_TYPE_http__operation
#define SOAP_TYPE_http__operation (400)
/* complex XML schema type 'http:operation': */
class SOAP_CMAC http__operation {
      public:
        /// Optional attribute 'location' of XML schema type 'xsd:anyURI'
        char *location;
      public:
        /// Return unique type id SOAP_TYPE_http__operation
        virtual long soap_type(void) const { return SOAP_TYPE_http__operation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type http__operation, default initialized and not managed by a soap context
        virtual http__operation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(http__operation); }
      public:
        /// Constructor with default initializations
        http__operation() : location() { }
        virtual ~http__operation() { }
        /// Friend allocator used by soap_new_http__operation(struct soap*, int)
        friend SOAP_FMAC1 http__operation * SOAP_FMAC2 wsdl_instantiate_http__operation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* http.h:61 */
#ifndef SOAP_TYPE_whttp__header
#define SOAP_TYPE_whttp__header (401)
/* complex XML schema type 'whttp:header': */
class SOAP_CMAC whttp__header {
      public:
        /// Optional attribute 'name' of XML schema type 'xsd:string'
        char *name;
        /// Optional attribute 'type' of XML schema type 'xsd:QName'
        char *type;
        /// Optional attribute 'required' of XML schema type 'xsd:boolean'
        bool required;	///< initialized with default value = (bool)0
      public:
        /// Return unique type id SOAP_TYPE_whttp__header
        virtual long soap_type(void) const { return SOAP_TYPE_whttp__header; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type whttp__header, default initialized and not managed by a soap context
        virtual whttp__header *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(whttp__header); }
      public:
        /// Constructor with default initializations
        whttp__header() : name(), type(), required((bool)0) { }
        virtual ~whttp__header() { }
        /// Friend allocator used by soap_new_whttp__header(struct soap*, int)
        friend SOAP_FMAC1 whttp__header * SOAP_FMAC2 wsdl_instantiate_whttp__header(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* gwsdl.h:45 */
#ifndef SOAP_TYPE_sd__serviceData
#define SOAP_TYPE_sd__serviceData (404)
/* complex XML schema type 'sd:serviceData': */
class SOAP_CMAC sd__serviceData {
      public:
        /// Optional attribute 'name' of XML schema type 'xsd:NMTOKEN'
        char *name;
        /// Optional attribute 'type' of XML schema type 'xsd:QName'
        char *type;
        /// Optional attribute 'nillable' of XML schema type 'xsd:boolean'
        bool nillable;	///< initialized with default value = (bool)0
        /// Optional attribute 'minOccurs' of XML schema type 'xsd:string'
        char *minOccurs;
        /// Optional attribute 'maxOccurs' of XML schema type 'xsd:string'
        char *maxOccurs;
        /// Optional attribute 'mutability' of XML schema type 'sd:mutability'
        enum sd__mutability mutability;	///< initialized with default value = (enum sd__mutability)2
        /// Optional attribute 'modifiable' of XML schema type 'xsd:boolean'
        bool modifiable;	///< initialized with default value = (bool)0
      public:
        /// Return unique type id SOAP_TYPE_sd__serviceData
        virtual long soap_type(void) const { return SOAP_TYPE_sd__serviceData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type sd__serviceData, default initialized and not managed by a soap context
        virtual sd__serviceData *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(sd__serviceData); }
      public:
        /// Constructor with default initializations
        sd__serviceData() : name(), type(), nillable((bool)0), minOccurs(), maxOccurs(), mutability((enum sd__mutability)2), modifiable((bool)0) { }
        virtual ~sd__serviceData() { }
        /// Friend allocator used by soap_new_sd__serviceData(struct soap*, int)
        friend SOAP_FMAC1 sd__serviceData * SOAP_FMAC2 wsdl_instantiate_sd__serviceData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* gwsdl.h:58 */
#ifndef SOAP_TYPE_sd__staticServiceDataValues
#define SOAP_TYPE_sd__staticServiceDataValues (405)
/* complex XML schema type 'sd:staticServiceDataValues': */
class SOAP_CMAC sd__staticServiceDataValues {
      public:
        /// Any type of element 'any' assigned to _any with its SOAP_TYPE_<typename> assigned to __type
        /// Do not create a cyclic data structure through this member unless SOAP encoding or SOAP_XML_GRAPH are used for id-ref serialization
        int __type;
        void *_any;
      public:
        /// Return unique type id SOAP_TYPE_sd__staticServiceDataValues
        virtual long soap_type(void) const { return SOAP_TYPE_sd__staticServiceDataValues; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type sd__staticServiceDataValues, default initialized and not managed by a soap context
        virtual sd__staticServiceDataValues *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(sd__staticServiceDataValues); }
      public:
        /// Constructor with default initializations
        sd__staticServiceDataValues() : __type(), _any() { }
        virtual ~sd__staticServiceDataValues() { }
        /// Friend allocator used by soap_new_sd__staticServiceDataValues(struct soap*, int)
        friend SOAP_FMAC1 sd__staticServiceDataValues * SOAP_FMAC2 wsdl_instantiate_sd__staticServiceDataValues(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* gwsdl.h:64 */
#ifndef SOAP_TYPE_gwsdl__portType
#define SOAP_TYPE_gwsdl__portType (407)
/* complex XML schema type 'gwsdl:portType': */
class SOAP_CMAC gwsdl__portType {
      public:
        /// Optional attribute 'name' of XML schema type 'xsd:NMTOKEN'
        char *name;
        /// Optional attribute 'extends' of XML schema type 'xsd:QName'
        char *extends;
        /// Optional element 'documentation' of XML schema type 'xsd:string'
        char *documentation;
        /// Optional element 'operation' of XML schema type 'wsdl:operation'
        std::vector<wsdl__operation *> operation;
        /// Optional element 'sd:serviceData' of XML schema type 'sd:serviceData'
        std::vector<sd__serviceData> sd__serviceData_;
        /// Optional element 'sd:staticServiceDataValues' of XML schema type 'sd:staticServiceDataValues'
        sd__staticServiceDataValues *sd__staticServiceDataValues_;
      public:
        /// Return unique type id SOAP_TYPE_gwsdl__portType
        virtual long soap_type(void) const { return SOAP_TYPE_gwsdl__portType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gwsdl__portType, default initialized and not managed by a soap context
        virtual gwsdl__portType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(gwsdl__portType); }
      public:
        /// Constructor with default initializations
        gwsdl__portType() : name(), extends(), documentation(), operation(), sd__serviceData_(), sd__staticServiceDataValues_() { }
        virtual ~gwsdl__portType() { }
        /// Friend allocator used by soap_new_gwsdl__portType(struct soap*, int)
        friend SOAP_FMAC1 gwsdl__portType * SOAP_FMAC2 wsdl_instantiate_gwsdl__portType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsam.h:49 */
#ifndef SOAP_TYPE_wsa__EndpointReferenceType
#define SOAP_TYPE_wsa__EndpointReferenceType (412)
/* complex XML schema type 'wsa:EndpointReferenceType': */
class SOAP_CMAC wsa__EndpointReferenceType {
      public:
        /// Optional element 'wsa:Address' of XML schema type 'xsd:anyURI'
        char *Address;
        char *__any;
      public:
        /// Return unique type id SOAP_TYPE_wsa__EndpointReferenceType
        virtual long soap_type(void) const { return SOAP_TYPE_wsa__EndpointReferenceType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsa__EndpointReferenceType, default initialized and not managed by a soap context
        virtual wsa__EndpointReferenceType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsa__EndpointReferenceType); }
      public:
        /// Constructor with default initializations
        wsa__EndpointReferenceType() : Address(), __any() { }
        virtual ~wsa__EndpointReferenceType() { }
        /// Friend allocator used by soap_new_wsa__EndpointReferenceType(struct soap*, int)
        friend SOAP_FMAC1 wsa__EndpointReferenceType * SOAP_FMAC2 wsdl_instantiate_wsa__EndpointReferenceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsp.h:50 */
#ifndef SOAP_TYPE_wsp__PolicyReference
#define SOAP_TYPE_wsp__PolicyReference (417)
/* complex XML schema type 'wsp:PolicyReference': */
class SOAP_CMAC wsp__PolicyReference {
      public:
        /// Optional attribute 'URI' of XML schema type 'xsd:anyURI'
        char *URI;
        /// Optional attribute 'Digest' of XML schema type 'xsd:string'
        char *Digest;
        /// Optional attribute 'DigestAlgorithm' of XML schema type 'xsd:anyURI'
        char *DigestAlgorithm;
      private:
        /// Not serialized
        wsp__Policy *policyRef;
      public:
        int traverse(wsdl__definitions &_param_1);
        void policyPtr(wsp__Policy *_param_1);
        wsp__Policy *policyPtr() const;
      public:
        /// Return unique type id SOAP_TYPE_wsp__PolicyReference
        virtual long soap_type(void) const { return SOAP_TYPE_wsp__PolicyReference; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsp__PolicyReference, default initialized and not managed by a soap context
        virtual wsp__PolicyReference *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsp__PolicyReference); }
      public:
        /// Constructor with default initializations
        wsp__PolicyReference() : URI(), Digest(), DigestAlgorithm(), policyRef() { }
        virtual ~wsp__PolicyReference() { }
        /// Friend allocator used by soap_new_wsp__PolicyReference(struct soap*, int)
        friend SOAP_FMAC1 wsp__PolicyReference * SOAP_FMAC2 wsdl_instantiate_wsp__PolicyReference(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsp.h:63 */
#ifndef SOAP_TYPE_wsp__Assertion
#define SOAP_TYPE_wsp__Assertion (423)
/* complex XML schema type 'wsp:Assertion': */
class SOAP_CMAC wsp__Assertion {
      public:
        /// Optional attribute 'Optional' of XML schema type 'xsd:boolean'
        bool Optional;	///< initialized with default value = (bool)0
        /// Optional attribute 'Ignorable' of XML schema type 'xsd:boolean'
        bool Ignorable;	///< initialized with default value = (bool)0
        /// Optional element 'wsp:Policy' of XML schema type 'wsp:Content'
        wsp__Content *Policy;
      public:
        /// Return unique type id SOAP_TYPE_wsp__Assertion
        virtual long soap_type(void) const { return SOAP_TYPE_wsp__Assertion; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsp__Assertion, default initialized and not managed by a soap context
        virtual wsp__Assertion *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsp__Assertion); }
      public:
        /// Constructor with default initializations
        wsp__Assertion() : Optional((bool)0), Ignorable((bool)0), Policy() { }
        virtual ~wsp__Assertion() { }
        /// Friend allocator used by soap_new_wsp__Assertion(struct soap*, int)
        friend SOAP_FMAC1 wsp__Assertion * SOAP_FMAC2 wsdl_instantiate_wsp__Assertion(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wst.h:39 */
#ifndef SOAP_TYPE_wst__Claims
#define SOAP_TYPE_wst__Claims (425)
/* simple XML schema type 'wst:Claims': */
class SOAP_CMAC wst__Claims {
      public:
        /// Optional attribute 'Dialect' of XML schema type 'xsd:string'
        char *Dialect;
        /// Simple content of XML schema type 'xsd:string' wrapped by this struct
        char *__item;
      public:
        /// Return unique type id SOAP_TYPE_wst__Claims
        virtual long soap_type(void) const { return SOAP_TYPE_wst__Claims; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wst__Claims, default initialized and not managed by a soap context
        virtual wst__Claims *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wst__Claims); }
      public:
        /// Constructor with default initializations
        wst__Claims() : Dialect(), __item() { }
        virtual ~wst__Claims() { }
        /// Friend allocator used by soap_new_wst__Claims(struct soap*, int)
        friend SOAP_FMAC1 wst__Claims * SOAP_FMAC2 wsdl_instantiate_wst__Claims(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sp.h:45 */
#ifndef SOAP_TYPE_sp__Header
#define SOAP_TYPE_sp__Header (426)
/* complex XML schema type 'sp:Header': */
class SOAP_CMAC sp__Header {
      public:
        /// Optional attribute 'Name' of XML schema type 'xsd:NCName'
        char *Name;
        /// Optional attribute 'Namespace' of XML schema type 'xsd:anyURI'
        char *Namespace;
      public:
        /// Return unique type id SOAP_TYPE_sp__Header
        virtual long soap_type(void) const { return SOAP_TYPE_sp__Header; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type sp__Header, default initialized and not managed by a soap context
        virtual sp__Header *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(sp__Header); }
      public:
        /// Constructor with default initializations
        sp__Header() : Name(), Namespace() { }
        virtual ~sp__Header() { }
        /// Friend allocator used by soap_new_sp__Header(struct soap*, int)
        friend SOAP_FMAC1 sp__Header * SOAP_FMAC2 wsdl_instantiate_sp__Header(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sp.h:51 */
#ifndef SOAP_TYPE_sp__Parts
#define SOAP_TYPE_sp__Parts (427)
/* complex XML schema type 'sp:Parts': */
class SOAP_CMAC sp__Parts {
      public:
        /// Optional element 'sp:Body' of XML schema type 'xsd:string'
        char *Body;
        /// Optional element 'sp:Header' of XML schema type 'sp:Header'
        std::vector<sp__Header> Header;
        /// Optional element 'sp:Attachments' of XML schema type 'xsd:string'
        char *Attachments;
      public:
        /// Return unique type id SOAP_TYPE_sp__Parts
        virtual long soap_type(void) const { return SOAP_TYPE_sp__Parts; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type sp__Parts, default initialized and not managed by a soap context
        virtual sp__Parts *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(sp__Parts); }
      public:
        /// Constructor with default initializations
        sp__Parts() : Body(), Header(), Attachments() { }
        virtual ~sp__Parts() { }
        /// Friend allocator used by soap_new_sp__Parts(struct soap*, int)
        friend SOAP_FMAC1 sp__Parts * SOAP_FMAC2 wsdl_instantiate_sp__Parts(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sp.h:58 */
#ifndef SOAP_TYPE_sp__Elements
#define SOAP_TYPE_sp__Elements (429)
/* complex XML schema type 'sp:Elements': */
class SOAP_CMAC sp__Elements {
      public:
        /// Optional attribute 'XPathVersion' of XML schema type 'xsd:anyURI'
        char *XPathVersion;
        /// Optional element 'sp:XPath' of XML schema type 'xsd:string'
        std::vector<char *> XPath;
      public:
        /// Return unique type id SOAP_TYPE_sp__Elements
        virtual long soap_type(void) const { return SOAP_TYPE_sp__Elements; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type sp__Elements, default initialized and not managed by a soap context
        virtual sp__Elements *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(sp__Elements); }
      public:
        /// Constructor with default initializations
        sp__Elements() : XPathVersion(), XPath() { }
        virtual ~sp__Elements() { }
        /// Friend allocator used by soap_new_sp__Elements(struct soap*, int)
        friend SOAP_FMAC1 sp__Elements * SOAP_FMAC2 wsdl_instantiate_sp__Elements(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sp.h:64 */
#ifndef SOAP_TYPE_sp__Token
#define SOAP_TYPE_sp__Token (431)
/* complex XML schema type 'sp:Token': */
class SOAP_CMAC sp__Token : public wsp__Assertion {
      public:
        /// Optional attribute 'IncludeToken' of XML schema type 'xsd:anyURI'
        char *IncludeToken;
        /// Optional element 'sp:Issuer' of XML schema type 'wsa:EndpointReferenceType'
        wsa__EndpointReferenceType *Issuer;
        /// Optional element 'sp:IssuerName' of XML schema type 'xsd:anyURI'
        char *IssuerName;
        /// Optional element 'wst:Claims' of XML schema type 'wst:Claims'
        wst__Claims *wst__Claims_;
      public:
        /// Return unique type id SOAP_TYPE_sp__Token
        virtual long soap_type(void) const { return SOAP_TYPE_sp__Token; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type sp__Token, default initialized and not managed by a soap context
        virtual sp__Token *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(sp__Token); }
      public:
        /// Constructor with default initializations
        sp__Token() : IncludeToken(), Issuer(), IssuerName(), wst__Claims_() { }
        virtual ~sp__Token() { }
        /// Friend allocator used by soap_new_sp__Token(struct soap*, int)
        friend SOAP_FMAC1 sp__Token * SOAP_FMAC2 wsdl_instantiate_sp__Token(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsrmp.h:47 */
#ifndef SOAP_TYPE_wsrmp__Timeout
#define SOAP_TYPE_wsrmp__Timeout (434)
/* complex XML schema type 'wsrmp:Timeout': */
class SOAP_CMAC wsrmp__Timeout {
      public:
        /// Optional attribute 'Milliseconds' of XML schema type 'xsd:string'
        char *Milliseconds;
      public:
        /// Return unique type id SOAP_TYPE_wsrmp__Timeout
        virtual long soap_type(void) const { return SOAP_TYPE_wsrmp__Timeout; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsrmp__Timeout, default initialized and not managed by a soap context
        virtual wsrmp__Timeout *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsrmp__Timeout); }
      public:
        /// Constructor with default initializations
        wsrmp__Timeout() : Milliseconds() { }
        virtual ~wsrmp__Timeout() { }
        /// Friend allocator used by soap_new_wsrmp__Timeout(struct soap*, int)
        friend SOAP_FMAC1 wsrmp__Timeout * SOAP_FMAC2 wsdl_instantiate_wsrmp__Timeout(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsrmp.h:52 */
#ifndef SOAP_TYPE_wsrmp__RMAssertion
#define SOAP_TYPE_wsrmp__RMAssertion (435)
/* complex XML schema type 'wsrmp:RMAssertion': */
class SOAP_CMAC wsrmp__RMAssertion : public wsp__Assertion {
      public:
        /// Optional element 'wsrmp:InactivityTimeout' of XML schema type 'wsrmp:Timeout'
        wsrmp__Timeout *InactivityTimeout;
        /// Optional element 'wsrmp:BaseRetransmissionInterval' of XML schema type 'wsrmp:Timeout'
        wsrmp__Timeout *BaseRetransmissionInterval;
        /// Optional element 'wsrmp:AcknowledgementInterval' of XML schema type 'wsrmp:Timeout'
        wsrmp__Timeout *AcknowledgementInterval;
        /// Optional element 'wsrmp:ExponentialBackoff' of XML schema type 'xsd:string'
        char *ExponentialBackoff;
      public:
        /// Return unique type id SOAP_TYPE_wsrmp__RMAssertion
        virtual long soap_type(void) const { return SOAP_TYPE_wsrmp__RMAssertion; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsrmp__RMAssertion, default initialized and not managed by a soap context
        virtual wsrmp__RMAssertion *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsrmp__RMAssertion); }
      public:
        /// Constructor with default initializations
        wsrmp__RMAssertion() : InactivityTimeout(), BaseRetransmissionInterval(), AcknowledgementInterval(), ExponentialBackoff() { }
        virtual ~wsrmp__RMAssertion() { }
        /// Friend allocator used by soap_new_wsrmp__RMAssertion(struct soap*, int)
        friend SOAP_FMAC1 wsrmp__RMAssertion * SOAP_FMAC2 wsdl_instantiate_wsrmp__RMAssertion(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsrmp.h:61 */
#ifndef SOAP_TYPE_wsrmp5__Timeout
#define SOAP_TYPE_wsrmp5__Timeout (437)
/* complex XML schema type 'wsrmp5:Timeout': */
class SOAP_CMAC wsrmp5__Timeout {
      public:
        /// Optional attribute 'Milliseconds' of XML schema type 'xsd:string'
        char *Milliseconds;
      public:
        /// Return unique type id SOAP_TYPE_wsrmp5__Timeout
        virtual long soap_type(void) const { return SOAP_TYPE_wsrmp5__Timeout; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsrmp5__Timeout, default initialized and not managed by a soap context
        virtual wsrmp5__Timeout *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsrmp5__Timeout); }
      public:
        /// Constructor with default initializations
        wsrmp5__Timeout() : Milliseconds() { }
        virtual ~wsrmp5__Timeout() { }
        /// Friend allocator used by soap_new_wsrmp5__Timeout(struct soap*, int)
        friend SOAP_FMAC1 wsrmp5__Timeout * SOAP_FMAC2 wsdl_instantiate_wsrmp5__Timeout(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsrmp.h:66 */
#ifndef SOAP_TYPE_wsrmp5__RMAssertion
#define SOAP_TYPE_wsrmp5__RMAssertion (438)
/* complex XML schema type 'wsrmp5:RMAssertion': */
class SOAP_CMAC wsrmp5__RMAssertion : public wsp__Assertion {
      public:
        /// Optional element 'wsrmp5:InactivityTimeout' of XML schema type 'wsrmp5:Timeout'
        wsrmp5__Timeout *InactivityTimeout;
        /// Optional element 'wsrmp5:BaseRetransmissionInterval' of XML schema type 'wsrmp5:Timeout'
        wsrmp5__Timeout *BaseRetransmissionInterval;
        /// Optional element 'wsrmp5:AcknowledgementInterval' of XML schema type 'wsrmp5:Timeout'
        wsrmp5__Timeout *AcknowledgementInterval;
        /// Optional element 'wsrmp5:ExponentialBackoff' of XML schema type 'xsd:string'
        char *ExponentialBackoff;
      public:
        /// Return unique type id SOAP_TYPE_wsrmp5__RMAssertion
        virtual long soap_type(void) const { return SOAP_TYPE_wsrmp5__RMAssertion; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsrmp5__RMAssertion, default initialized and not managed by a soap context
        virtual wsrmp5__RMAssertion *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsrmp5__RMAssertion); }
      public:
        /// Constructor with default initializations
        wsrmp5__RMAssertion() : InactivityTimeout(), BaseRetransmissionInterval(), AcknowledgementInterval(), ExponentialBackoff() { }
        virtual ~wsrmp5__RMAssertion() { }
        /// Friend allocator used by soap_new_wsrmp5__RMAssertion(struct soap*, int)
        friend SOAP_FMAC1 wsrmp5__RMAssertion * SOAP_FMAC2 wsdl_instantiate_wsrmp5__RMAssertion(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsp.h:45 */
#ifndef SOAP_TYPE_wsp__Content
#define SOAP_TYPE_wsp__Content (414)
/* Type wsp__Content is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'wsp:Content': */
class SOAP_CMAC wsp__Content {
      public:
        /// Optional element 'wsp:Policy' of XML schema type 'wsp:Policy'
        wsp__Policy *Policy;
        /// Optional element 'wsp:PolicyReference' of XML schema type 'wsp:PolicyReference'
        wsp__PolicyReference *PolicyReference;
        /// Optional element 'wsp:All' of XML schema type 'wsp:Content'
        std::vector<wsp__Content *> All;
        /// Optional element 'wsp:ExactlyOne' of XML schema type 'wsp:Content'
        std::vector<wsp__Content *> ExactlyOne;
        /// Optional element 'sp:SignedParts' of XML schema type 'sp:Parts'
        std::vector<sp__Parts> sp__SignedParts;
        /// Optional element 'sp:EncryptedParts' of XML schema type 'sp:Parts'
        std::vector<sp__Parts> sp__EncryptedParts;
        /// Optional element 'sp:RequiredParts' of XML schema type 'sp:Parts'
        std::vector<sp__Parts> sp__RequiredParts;
        /// Optional element 'sp:SignedElements' of XML schema type 'sp:Elements'
        sp__Elements *sp__SignedElements;
        /// Optional element 'sp:EncryptedElements' of XML schema type 'sp:Elements'
        sp__Elements *sp__EncryptedElements;
        /// Optional element 'sp:ContentEncryptedElements' of XML schema type 'sp:Elements'
        sp__Elements *sp__ContentEncryptedElements;
        /// Optional element 'sp:RequiredElements' of XML schema type 'sp:Elements'
        sp__Elements *sp__RequiredElements;
        /// Optional element 'sp:UsernameToken' of XML schema type 'sp:Token'
        sp__Token *sp__UsernameToken;
        /// Optional element 'sp:IssuedToken' of XML schema type 'sp:Token'
        sp__Token *sp__IssuedToken;
        /// Optional element 'sp:X509Token' of XML schema type 'sp:Token'
        sp__Token *sp__X509Token;
        /// Optional element 'sp:KerberosToken' of XML schema type 'sp:Token'
        sp__Token *sp__KerberosToken;
        /// Optional element 'sp:SpnegoContextToken' of XML schema type 'sp:Token'
        sp__Token *sp__SpnegoContextToken;
        /// Optional element 'sp:SecurityContextToken' of XML schema type 'sp:Token'
        sp__Token *sp__SecurityContextToken;
        /// Optional element 'sp:SecureConversationToken' of XML schema type 'sp:Token'
        sp__Token *sp__SecureConversationToken;
        /// Optional element 'sp:SamlToken' of XML schema type 'sp:Token'
        sp__Token *sp__SamlToken;
        /// Optional element 'sp:RelToken' of XML schema type 'sp:Token'
        sp__Token *sp__RelToken;
        /// Optional element 'sp:HttpsToken' of XML schema type 'sp:Token'
        sp__Token *sp__HttpsToken;
        /// Optional element 'sp:KeyValueToken' of XML schema type 'sp:Token'
        sp__Token *sp__KeyValueToken;
        /// Optional element 'sp:TransportBinding' of XML schema type 'wsp:Assertion'
        wsp__Assertion *sp__TransportBinding;
        /// Optional element 'sp:TransportToken' of XML schema type 'wsp:Assertion'
        wsp__Assertion *sp__TransportToken;
        /// Optional element 'sp:AlgorithmSuite' of XML schema type 'wsp:Assertion'
        wsp__Assertion *sp__AlgorithmSuite;
        /// Optional element 'sp:Layout' of XML schema type 'wsp:Assertion'
        wsp__Assertion *sp__Layout;
        /// Optional element 'sp:SymmetricBinding' of XML schema type 'wsp:Assertion'
        wsp__Assertion *sp__SymmetricBinding;
        /// Optional element 'sp:AsymmetricBinding' of XML schema type 'wsp:Assertion'
        wsp__Assertion *sp__AsymmetricBinding;
        /// Optional element 'sp:ProtectionToken' of XML schema type 'wsp:Assertion'
        wsp__Assertion *sp__ProtectionToken;
        /// Optional element 'sp:InitiatorToken' of XML schema type 'wsp:Assertion'
        wsp__Assertion *sp__InitiatorToken;
        /// Optional element 'sp:InitiatorSignatureToken' of XML schema type 'wsp:Assertion'
        wsp__Assertion *sp__InitiatorSignatureToken;
        /// Optional element 'sp:InitiatorEncryptionToken' of XML schema type 'wsp:Assertion'
        wsp__Assertion *sp__InitiatorEncryptionToken;
        /// Optional element 'sp:RecipientToken' of XML schema type 'wsp:Assertion'
        wsp__Assertion *sp__RecipientToken;
        /// Optional element 'sp:SupportingTokens' of XML schema type 'wsp:Assertion'
        wsp__Assertion *sp__SupportingTokens;
        /// Optional element 'sp:SignedSupportingTokens' of XML schema type 'wsp:Assertion'
        wsp__Assertion *sp__SignedSupportingTokens;
        /// Optional element 'sp:EndorsingSupportingTokens' of XML schema type 'wsp:Assertion'
        wsp__Assertion *sp__EndorsingSupportingTokens;
        /// Optional element 'sp:SignedEndorsingSupportingTokens' of XML schema type 'wsp:Assertion'
        wsp__Assertion *sp__SignedEndorsingSupportingTokens;
        /// Optional element 'sp:SignedEncryptedSupportingTokens' of XML schema type 'wsp:Assertion'
        wsp__Assertion *sp__SignedEncryptedSupportingTokens;
        /// Optional element 'sp:EncryptedSupportingTokens' of XML schema type 'wsp:Assertion'
        wsp__Assertion *sp__EncryptedSupportingTokens;
        /// Optional element 'sp:EndorsingEncryptedSupportingTokens' of XML schema type 'wsp:Assertion'
        wsp__Assertion *sp__EndorsingEncryptedSupportingTokens;
        /// Optional element 'sp:SignedEndorsingEncryptedSupportingTokens' of XML schema type 'wsp:Assertion'
        wsp__Assertion *sp__SignedEndorsingEncryptedSupportingTokens;
        /// Optional element 'sp:Wss10' of XML schema type 'wsp:Assertion'
        wsp__Assertion *sp__Wss10;
        /// Optional element 'sp:Wss11' of XML schema type 'wsp:Assertion'
        wsp__Assertion *sp__Wss11;
        /// Optional element 'sp:Trust10' of XML schema type 'wsp:Assertion'
        wsp__Assertion *sp__Trust10;
        /// Optional element 'sp:Trust13' of XML schema type 'wsp:Assertion'
        wsp__Assertion *sp__Trust13;
        /// Optional element 'sp:BootstrapPolicy' of XML schema type 'wsp:Content'
        wsp__Content *sp__BootstrapPolicy;
        /// Optional element 'wsaw:UsingAddressing' of XML schema type 'xsd:string'
        char *wsaw__UsingAddressing;
        /// Optional element 'wsam:Addressing' of XML schema type 'wsp:Assertion'
        wsp__Assertion *wsam__Addressing;
        /// Optional element 'wsrmp:RMAssertion' of XML schema type 'wsrmp:RMAssertion'
        wsrmp__RMAssertion *wsrmp__RMAssertion_;
        /// Optional element 'wsrmp:DeliveryAssurance' of XML schema type 'wsrmp:RMAssertion'
        wsrmp__RMAssertion *wsrmp__DeliveryAssurance;
        /// Optional element 'wsrmp:AtLeastOnce' of XML schema type 'xsd:string'
        char *wsrmp__AtLeastOnce;
        /// Optional element 'wsrmp:AtMostOnce' of XML schema type 'xsd:string'
        char *wsrmp__AtMostOnce;
        /// Optional element 'wsrmp:ExactlyOnce' of XML schema type 'xsd:string'
        char *wsrmp__ExactlyOnce;
        /// Optional element 'wsrmp:InOrder' of XML schema type 'xsd:string'
        char *wsrmp__InOrder;
        /// Optional element 'wsrmp5:RMAssertion' of XML schema type 'wsrmp5:RMAssertion'
        wsrmp5__RMAssertion *wsrmp5__RMAssertion_;
        /// Optional element 'wsrmp5:DeliveryAssurance' of XML schema type 'wsrmp5:RMAssertion'
        wsrmp5__RMAssertion *wsrmp5__DeliveryAssurance;
        /// Optional element 'wsrmp5:AtLeastOnce' of XML schema type 'xsd:string'
        char *wsrmp5__AtLeastOnce;
        /// Optional element 'wsrmp5:AtMostOnce' of XML schema type 'xsd:string'
        char *wsrmp5__AtMostOnce;
        /// Optional element 'wsrmp5:ExactlyOnce' of XML schema type 'xsd:string'
        char *wsrmp5__ExactlyOnce;
        /// Optional element 'wsrmp5:InOrder' of XML schema type 'xsd:string'
        char *wsrmp5__InOrder;
        /// Optional element 'sp:NoPassword' of XML schema type 'wsp:Assertion'
        wsp__Assertion *sp__NoPassword;
        /// Optional element 'sp:HashPassword' of XML schema type 'wsp:Assertion'
        wsp__Assertion *sp__HashPassword;
        /// Optional element 'sp:IncludeTimestamp' of XML schema type 'wsp:Assertion'
        wsp__Assertion *sp__IncludeTimestamp;
        /// Optional element 'sp:EncryptBeforeSigning' of XML schema type 'wsp:Assertion'
        wsp__Assertion *sp__EncryptBeforeSigning;
        /// Optional element 'sp:EncryptSignature' of XML schema type 'wsp:Assertion'
        wsp__Assertion *sp__EncryptSignature;
        /// Optional element 'sp:ProtectTokens' of XML schema type 'wsp:Assertion'
        wsp__Assertion *sp__ProtectTokens;
        /// Optional element 'sp:OnlySignEntireHeadersAndBody' of XML schema type 'wsp:Assertion'
        wsp__Assertion *sp__OnlySignEntireHeadersAndBody;
        /// Optional element 'sp:RequireDerivedKeys' of XML schema type 'xsd:string'
        char *sp__RequireDerivedKeys;
        /// Optional element 'sp:RequireImpliedDerivedKeys' of XML schema type 'xsd:string'
        char *sp__RequireImpliedDerivedKeys;
        /// Optional element 'sp:RequireExplicitDerivedKeys' of XML schema type 'xsd:string'
        char *sp__RequireExplicitDerivedKeys;
        /// Optional element 'sp:WssUsernameToken10' of XML schema type 'xsd:string'
        char *sp__WssUsernameToken10;
        /// Optional element 'sp:WssUsernameToken11' of XML schema type 'xsd:string'
        char *sp__WssUsernameToken11;
        /// Optional element 'sp:RequireExternalReference' of XML schema type 'xsd:string'
        char *sp__RequireExternalReference;
        /// Optional element 'sp:RequireInternalReference' of XML schema type 'xsd:string'
        char *sp__RequireInternalReference;
        /// Optional element 'sp:RequireKeyIdentifierReference' of XML schema type 'xsd:string'
        char *sp__RequireKeyIdentifierReference;
        /// Optional element 'sp:RequireIssuerSerialReference' of XML schema type 'xsd:string'
        char *sp__RequireIssuerSerialReference;
        /// Optional element 'sp:RequireEmbeddedTokenReference' of XML schema type 'xsd:string'
        char *sp__RequireEmbeddedTokenReference;
        /// Optional element 'sp:RequireThumbprintReference' of XML schema type 'xsd:string'
        char *sp__RequireThumbprintReference;
        /// Optional element 'sp:WssX509V3Token10' of XML schema type 'xsd:string'
        char *sp__WssX509V3Token10;
        /// Optional element 'sp:WssX509Pkcs7Token10' of XML schema type 'xsd:string'
        char *sp__WssX509Pkcs7Token10;
        /// Optional element 'sp:WssX509PkiPathV1Token10' of XML schema type 'xsd:string'
        char *sp__WssX509PkiPathV1Token10;
        /// Optional element 'sp:WssX509V1Token11' of XML schema type 'xsd:string'
        char *sp__WssX509V1Token11;
        /// Optional element 'sp:WssX509V3Token11' of XML schema type 'xsd:string'
        char *sp__WssX509V3Token11;
        /// Optional element 'sp:WssX509Pkcs7Token11' of XML schema type 'xsd:string'
        char *sp__WssX509Pkcs7Token11;
        /// Optional element 'sp:WssX509PkiPathV1Token11' of XML schema type 'xsd:string'
        char *sp__WssX509PkiPathV1Token11;
        /// Optional element 'sp:WssKerberosV5ApReqToken11' of XML schema type 'xsd:string'
        char *sp__WssKerberosV5ApReqToken11;
        /// Optional element 'sp:WssGssKerberosV5ApReqToken11' of XML schema type 'xsd:string'
        char *sp__WssGssKerberosV5ApReqToken11;
        /// Optional element 'sp:WssRelV10Token10' of XML schema type 'xsd:string'
        char *sp__WssRelV10Token10;
        /// Optional element 'sp:WssRelV20Token10' of XML schema type 'xsd:string'
        char *sp__WssRelV20Token10;
        /// Optional element 'sp:WssRelV10Token11' of XML schema type 'xsd:string'
        char *sp__WssRelV10Token11;
        /// Optional element 'sp:WssRelV20Token11' of XML schema type 'xsd:string'
        char *sp__WssRelV20Token11;
        /// Optional element 'sp:MustNotSendCancel' of XML schema type 'xsd:string'
        char *sp__MustNotSendCancel;
        /// Optional element 'sp:MustNotSendAmend' of XML schema type 'xsd:string'
        char *sp__MustNotSendAmend;
        /// Optional element 'sp:MustNotSendRenew' of XML schema type 'xsd:string'
        char *sp__MustNotSendRenew;
        /// Optional element 'sp:MustSupportRefKeyIdentifier' of XML schema type 'xsd:string'
        char *sp__MustSupportRefKeyIdentifier;
        /// Optional element 'sp:MustSupportRefIssuerSerial' of XML schema type 'xsd:string'
        char *sp__MustSupportRefIssuerSerial;
        /// Optional element 'sp:MustSupportRefExternalURI' of XML schema type 'xsd:string'
        char *sp__MustSupportRefExternalURI;
        /// Optional element 'sp:MustSupportRefEmbeddedToken' of XML schema type 'xsd:string'
        char *sp__MustSupportRefEmbeddedToken;
        /// Optional element 'sp:MustSupportRefThumbprint' of XML schema type 'xsd:string'
        char *sp__MustSupportRefThumbprint;
        /// Optional element 'sp:MustSupportRefEncryptedKey' of XML schema type 'xsd:string'
        char *sp__MustSupportRefEncryptedKey;
        /// Optional element 'sp:RequireSignatureConfirmation' of XML schema type 'xsd:string'
        char *sp__RequireSignatureConfirmation;
        /// Optional element 'sp:MustSupportClientChallenge' of XML schema type 'xsd:string'
        char *sp__MustSupportClientChallenge;
        /// Optional element 'sp:MustSupportServerChallenge' of XML schema type 'xsd:string'
        char *sp__MustSupportServerChallenge;
        /// Optional element 'sp:RequireClientEntropy' of XML schema type 'xsd:string'
        char *sp__RequireClientEntropy;
        /// Optional element 'sp:RequireServerEntropy' of XML schema type 'xsd:string'
        char *sp__RequireServerEntropy;
        /// Optional element 'sp:MustSupportIssuedTokens' of XML schema type 'xsd:string'
        char *sp__MustSupportIssuedTokens;
        /// Optional element 'sp:RequireRequestSecurityTokenCollection' of XML schema type 'xsd:string'
        char *sp__RequireRequestSecurityTokenCollection;
        /// Optional element 'sp:RequireAppliesTo' of XML schema type 'xsd:string'
        char *sp__RequireAppliesTo;
        /// Optional element 'sp:RequireExternalUriReference' of XML schema type 'xsd:string'
        char *sp__RequireExternalUriReference;
        /// Optional element 'sp:SC13SecurityContextToken' of XML schema type 'xsd:string'
        char *sp__SC13SecurityContextToken;
        /// Optional element 'sp:Strict' of XML schema type 'xsd:string'
        char *sp__Strict;
        /// Optional element 'sp:Lax' of XML schema type 'xsd:string'
        char *sp__Lax;
        /// Optional element 'sp:LaxTsFirst' of XML schema type 'xsd:string'
        char *sp__LaxTsFirst;
        /// Optional element 'sp:LaxTsLast' of XML schema type 'xsd:string'
        char *sp__LaxTsLast;
        /// Optional element 'sp:HttpBasicAuthentication' of XML schema type 'xsd:string'
        char *sp__HttpBasicAuthentication;
        /// Optional element 'sp:HttpDigestAuthentication' of XML schema type 'xsd:string'
        char *sp__HttpDigestAuthentication;
        /// Optional element 'sp:RequireClientCertificate' of XML schema type 'xsd:string'
        char *sp__RequireClientCertificate;
        /// Optional element 'sp:Basic256' of XML schema type 'xsd:string'
        char *sp__Basic256;
        /// Optional element 'sp:Basic192' of XML schema type 'xsd:string'
        char *sp__Basic192;
        /// Optional element 'sp:Basic128' of XML schema type 'xsd:string'
        char *sp__Basic128;
        /// Optional element 'sp:TripleDes' of XML schema type 'xsd:string'
        char *sp__TripleDes;
        /// Optional element 'sp:Basic256Rsa15' of XML schema type 'xsd:string'
        char *sp__Basic256Rsa15;
        /// Optional element 'sp:Basic192Rsa15' of XML schema type 'xsd:string'
        char *sp__Basic192Rsa15;
        /// Optional element 'sp:Basic128Rsa15' of XML schema type 'xsd:string'
        char *sp__Basic128Rsa15;
        /// Optional element 'sp:TripleDesRsa15' of XML schema type 'xsd:string'
        char *sp__TripleDesRsa15;
        /// Optional element 'sp:Basic256Sha256' of XML schema type 'xsd:string'
        char *sp__Basic256Sha256;
        /// Optional element 'sp:Basic192Sha256' of XML schema type 'xsd:string'
        char *sp__Basic192Sha256;
        /// Optional element 'sp:Basic128Sha256' of XML schema type 'xsd:string'
        char *sp__Basic128Sha256;
        /// Optional element 'sp:TripleDesSha256' of XML schema type 'xsd:string'
        char *sp__TripleDesSha256;
        /// Optional element 'sp:Basic256Sha256Rsa15' of XML schema type 'xsd:string'
        char *sp__Basic256Sha256Rsa15;
        /// Optional element 'sp:Basic192Sha256Rsa15' of XML schema type 'xsd:string'
        char *sp__Basic192Sha256Rsa15;
        /// Optional element 'sp:Basic128Sha256Rsa15' of XML schema type 'xsd:string'
        char *sp__Basic128Sha256Rsa15;
        /// Optional element 'sp:TripleDesSha256Rsa15' of XML schema type 'xsd:string'
        char *sp__TripleDesSha256Rsa15;
        /// Optional element 'sp:InclusiveC14N' of XML schema type 'xsd:string'
        char *sp__InclusiveC14N;
        /// Optional element 'sp:SOAPNormalization10' of XML schema type 'xsd:string'
        char *sp__SOAPNormalization10;
        /// Optional element 'sp:STRTransform10' of XML schema type 'xsd:string'
        char *sp__STRTransform10;
        /// Optional element 'sp:Path10' of XML schema type 'xsd:string'
        char *sp__Path10;
        /// Optional element 'sp:XPathFilter20' of XML schema type 'xsd:string'
        char *sp__XPathFilter20;
        /// Optional element 'sp:AbsXPath' of XML schema type 'xsd:string'
        char *sp__AbsXPath;
        /// Optional element 'wsam:AnonymousResponses' of XML schema type 'xsd:string'
        char *wsam__AnonymousResponses;
        /// Optional element 'wsam:NonAnonymousResponses' of XML schema type 'xsd:string'
        char *wsam__NonAnonymousResponses;
        std::vector<char *> __any;
        int traverse(wsdl__definitions &_param_1);
        void generate(Service &service, Types &types, int indent) const;
      public:
        /// Return unique type id SOAP_TYPE_wsp__Content
        virtual long soap_type(void) const { return SOAP_TYPE_wsp__Content; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsp__Content, default initialized and not managed by a soap context
        virtual wsp__Content *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsp__Content); }
      public:
        /// Constructor with default initializations
        wsp__Content() : Policy(), PolicyReference(), All(), ExactlyOne(), sp__SignedParts(), sp__EncryptedParts(), sp__RequiredParts(), sp__SignedElements(), sp__EncryptedElements(), sp__ContentEncryptedElements(), sp__RequiredElements(), sp__UsernameToken(), sp__IssuedToken(), sp__X509Token(), sp__KerberosToken(), sp__SpnegoContextToken(), sp__SecurityContextToken(), sp__SecureConversationToken(), sp__SamlToken(), sp__RelToken(), sp__HttpsToken(), sp__KeyValueToken(), sp__TransportBinding(), sp__TransportToken(), sp__AlgorithmSuite(), sp__Layout(), sp__SymmetricBinding(), sp__AsymmetricBinding(), sp__ProtectionToken(), sp__InitiatorToken(), sp__InitiatorSignatureToken(), sp__InitiatorEncryptionToken(), sp__RecipientToken(), sp__SupportingTokens(), sp__SignedSupportingTokens(), sp__EndorsingSupportingTokens(), sp__SignedEndorsingSupportingTokens(), sp__SignedEncryptedSupportingTokens(), sp__EncryptedSupportingTokens(), sp__EndorsingEncryptedSupportingTokens(), sp__SignedEndorsingEncryptedSupportingTokens(), sp__Wss10(), sp__Wss11(), sp__Trust10(), sp__Trust13(), sp__BootstrapPolicy(), wsaw__UsingAddressing(), wsam__Addressing(), wsrmp__RMAssertion_(), wsrmp__DeliveryAssurance(), wsrmp__AtLeastOnce(), wsrmp__AtMostOnce(), wsrmp__ExactlyOnce(), wsrmp__InOrder(), wsrmp5__RMAssertion_(), wsrmp5__DeliveryAssurance(), wsrmp5__AtLeastOnce(), wsrmp5__AtMostOnce(), wsrmp5__ExactlyOnce(), wsrmp5__InOrder(), sp__NoPassword(), sp__HashPassword(), sp__IncludeTimestamp(), sp__EncryptBeforeSigning(), sp__EncryptSignature(), sp__ProtectTokens(), sp__OnlySignEntireHeadersAndBody(), sp__RequireDerivedKeys(), sp__RequireImpliedDerivedKeys(), sp__RequireExplicitDerivedKeys(), sp__WssUsernameToken10(), sp__WssUsernameToken11(), sp__RequireExternalReference(), sp__RequireInternalReference(), sp__RequireKeyIdentifierReference(), sp__RequireIssuerSerialReference(), sp__RequireEmbeddedTokenReference(), sp__RequireThumbprintReference(), sp__WssX509V3Token10(), sp__WssX509Pkcs7Token10(), sp__WssX509PkiPathV1Token10(), sp__WssX509V1Token11(), sp__WssX509V3Token11(), sp__WssX509Pkcs7Token11(), sp__WssX509PkiPathV1Token11(), sp__WssKerberosV5ApReqToken11(), sp__WssGssKerberosV5ApReqToken11(), sp__WssRelV10Token10(), sp__WssRelV20Token10(), sp__WssRelV10Token11(), sp__WssRelV20Token11(), sp__MustNotSendCancel(), sp__MustNotSendAmend(), sp__MustNotSendRenew(), sp__MustSupportRefKeyIdentifier(), sp__MustSupportRefIssuerSerial(), sp__MustSupportRefExternalURI(), sp__MustSupportRefEmbeddedToken(), sp__MustSupportRefThumbprint(), sp__MustSupportRefEncryptedKey(), sp__RequireSignatureConfirmation(), sp__MustSupportClientChallenge(), sp__MustSupportServerChallenge(), sp__RequireClientEntropy(), sp__RequireServerEntropy(), sp__MustSupportIssuedTokens(), sp__RequireRequestSecurityTokenCollection(), sp__RequireAppliesTo(), sp__RequireExternalUriReference(), sp__SC13SecurityContextToken(), sp__Strict(), sp__Lax(), sp__LaxTsFirst(), sp__LaxTsLast(), sp__HttpBasicAuthentication(), sp__HttpDigestAuthentication(), sp__RequireClientCertificate(), sp__Basic256(), sp__Basic192(), sp__Basic128(), sp__TripleDes(), sp__Basic256Rsa15(), sp__Basic192Rsa15(), sp__Basic128Rsa15(), sp__TripleDesRsa15(), sp__Basic256Sha256(), sp__Basic192Sha256(), sp__Basic128Sha256(), sp__TripleDesSha256(), sp__Basic256Sha256Rsa15(), sp__Basic192Sha256Rsa15(), sp__Basic128Sha256Rsa15(), sp__TripleDesSha256Rsa15(), sp__InclusiveC14N(), sp__SOAPNormalization10(), sp__STRTransform10(), sp__Path10(), sp__XPathFilter20(), sp__AbsXPath(), wsam__AnonymousResponses(), wsam__NonAnonymousResponses(), __any() { }
        virtual ~wsp__Content() { }
        /// Friend allocator used by soap_new_wsp__Content(struct soap*, int)
        friend SOAP_FMAC1 wsp__Content * SOAP_FMAC2 wsdl_instantiate_wsp__Content(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsp.h:44 */
#ifndef SOAP_TYPE_wsp__Policy
#define SOAP_TYPE_wsp__Policy (413)
/* Type wsp__Policy is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'wsp:Policy': */
class SOAP_CMAC wsp__Policy : public wsp__Content {
      public:
        /// Optional attribute 'xml:base' of XML schema type 'xsd:anyURI'
        char *xml__base;
        /// Optional attribute 'wsu:Id' of XML schema type 'xsd:string'
        char *wsu__Id;
        /// Optional attribute 'TargetNamespace' of XML schema type 'xsd:anyURI'
        char *TargetNamespace;
      public:
        /// Return unique type id SOAP_TYPE_wsp__Policy
        virtual long soap_type(void) const { return SOAP_TYPE_wsp__Policy; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsp__Policy, default initialized and not managed by a soap context
        virtual wsp__Policy *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsp__Policy); }
      public:
        /// Constructor with default initializations
        wsp__Policy() : xml__base(), wsu__Id(), TargetNamespace() { }
        virtual ~wsp__Policy() { }
        /// Friend allocator used by soap_new_wsp__Policy(struct soap*, int)
        friend SOAP_FMAC1 wsp__Policy * SOAP_FMAC2 wsdl_instantiate_wsp__Policy(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsp.h:260 */
#ifndef SOAP_TYPE_wsp__Attachment
#define SOAP_TYPE_wsp__Attachment (453)
/* complex XML schema type 'wsp:Attachment': */
class SOAP_CMAC wsp__Attachment {
      public:
        /// Optional element 'wsp:Policy' of XML schema type 'wsp:Policy'
        wsp__Policy *Policy;
        /// Optional element 'wsp:PolicyReference' of XML schema type 'wsp:PolicyReference'
        wsp__PolicyReference *PolicyReference;
      public:
        /// Return unique type id SOAP_TYPE_wsp__Attachment
        virtual long soap_type(void) const { return SOAP_TYPE_wsp__Attachment; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsp__Attachment, default initialized and not managed by a soap context
        virtual wsp__Attachment *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsp__Attachment); }
      public:
        /// Constructor with default initializations
        wsp__Attachment() : Policy(), PolicyReference() { }
        virtual ~wsp__Attachment() { }
        /// Friend allocator used by soap_new_wsp__Attachment(struct soap*, int)
        friend SOAP_FMAC1 wsp__Attachment * SOAP_FMAC2 wsdl_instantiate_wsp__Attachment(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsp.h:266 */
#ifndef SOAP_TYPE_wsp__AppliesTo
#define SOAP_TYPE_wsp__AppliesTo (454)
/* complex XML schema type 'wsp:AppliesTo': */
class SOAP_CMAC wsp__AppliesTo {
      public:
        char *__any;
      public:
        /// Return unique type id SOAP_TYPE_wsp__AppliesTo
        virtual long soap_type(void) const { return SOAP_TYPE_wsp__AppliesTo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsp__AppliesTo, default initialized and not managed by a soap context
        virtual wsp__AppliesTo *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsp__AppliesTo); }
      public:
        /// Constructor with default initializations
        wsp__AppliesTo() : __any() { }
        virtual ~wsp__AppliesTo() { }
        /// Friend allocator used by soap_new_wsp__AppliesTo(struct soap*, int)
        friend SOAP_FMAC1 wsp__AppliesTo * SOAP_FMAC2 wsdl_instantiate_wsp__AppliesTo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsp.h:271 */
#ifndef SOAP_TYPE_wsp__PolicyAttachment
#define SOAP_TYPE_wsp__PolicyAttachment (455)
/* complex XML schema type 'wsp:PolicyAttachment': */
class SOAP_CMAC wsp__PolicyAttachment {
      public:
        /// Optional element 'wsp:AppliesTo' of XML schema type 'wsp:AppliesTo'
        wsp__AppliesTo *AppliesTo;
        /// Optional element 'wsp:Attachment' of XML schema type 'wsp:Attachment'
        std::vector<wsp__Attachment> Attachment;
      public:
        /// Return unique type id SOAP_TYPE_wsp__PolicyAttachment
        virtual long soap_type(void) const { return SOAP_TYPE_wsp__PolicyAttachment; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsp__PolicyAttachment, default initialized and not managed by a soap context
        virtual wsp__PolicyAttachment *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsp__PolicyAttachment); }
      public:
        /// Constructor with default initializations
        wsp__PolicyAttachment() : AppliesTo(), Attachment() { }
        virtual ~wsp__PolicyAttachment() { }
        /// Friend allocator used by soap_new_wsp__PolicyAttachment(struct soap*, int)
        friend SOAP_FMAC1 wsp__PolicyAttachment * SOAP_FMAC2 wsdl_instantiate_wsp__PolicyAttachment(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bpel.h:50 */
#ifndef SOAP_TYPE_plnk__tRole
#define SOAP_TYPE_plnk__tRole (460)
/* complex XML schema type 'plnk:tRole': */
class SOAP_CMAC plnk__tRole {
      public:
        /// Optional attribute 'name' of XML schema type 'xsd:NCName'
        char *name;
        /// Optional attribute 'portType' of XML schema type 'xsd:QName'
        char *portType;
        /// Optional element 'plnk:documentation' of XML schema type 'xsd:string'
        char *documentation;
      private:
        /// Not serialized
        wsdl__portType *portTypeRef;
        /// Not serialized
        plnk__tPartnerLinkType *plnkRef;
      public:
        plnk__tRole();
        int traverse(wsdl__definitions &_param_1);
        wsdl__portType *portTypePtr() const;
        void plnkPtr(plnk__tPartnerLinkType *_param_1);
        plnk__tPartnerLinkType *plnkPtr() const;
      public:
        /// Return unique type id SOAP_TYPE_plnk__tRole
        virtual long soap_type(void) const { return SOAP_TYPE_plnk__tRole; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type plnk__tRole, default initialized and not managed by a soap context
        virtual plnk__tRole *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(plnk__tRole); }
        virtual ~plnk__tRole() { }
        /// Friend allocator used by soap_new_plnk__tRole(struct soap*, int)
        friend SOAP_FMAC1 plnk__tRole * SOAP_FMAC2 wsdl_instantiate_plnk__tRole(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bpel.h:48 */
#ifndef SOAP_TYPE_plnk__tPartnerLinkType
#define SOAP_TYPE_plnk__tPartnerLinkType (459)
/* Type plnk__tPartnerLinkType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'plnk:tPartnerLinkType': */
class SOAP_CMAC plnk__tPartnerLinkType {
      public:
        /// Optional attribute 'name' of XML schema type 'xsd:NCName'
        char *name;
        /// Optional element 'plnk:role' of XML schema type 'plnk:tRole'
        std::vector<plnk__tRole> role;
        /// Optional element 'plnk:documentation' of XML schema type 'xsd:string'
        char *documentation;
        int traverse(wsdl__definitions &_param_1);
      public:
        /// Return unique type id SOAP_TYPE_plnk__tPartnerLinkType
        virtual long soap_type(void) const { return SOAP_TYPE_plnk__tPartnerLinkType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type plnk__tPartnerLinkType, default initialized and not managed by a soap context
        virtual plnk__tPartnerLinkType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(plnk__tPartnerLinkType); }
      public:
        /// Constructor with default initializations
        plnk__tPartnerLinkType() : name(), role(), documentation() { }
        virtual ~plnk__tPartnerLinkType() { }
        /// Friend allocator used by soap_new_plnk__tPartnerLinkType(struct soap*, int)
        friend SOAP_FMAC1 plnk__tPartnerLinkType * SOAP_FMAC2 wsdl_instantiate_plnk__tPartnerLinkType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bpel.h:75 */
#ifndef SOAP_TYPE_vprop__tQuery
#define SOAP_TYPE_vprop__tQuery (471)
/* complex XML schema type 'vprop:tQuery': */
class SOAP_CMAC vprop__tQuery {
      public:
        /// Optional attribute 'queryLanguage' of XML schema type 'xsd:anyURI'
        char *queryLanguage;	///< initialized with default value = (char*)"urn:oasis:names:tc:wsbpel:2.0:sublang:xpath1.0"
        char *__mixed;
      public:
        /// Return unique type id SOAP_TYPE_vprop__tQuery
        virtual long soap_type(void) const { return SOAP_TYPE_vprop__tQuery; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type vprop__tQuery, default initialized and not managed by a soap context
        virtual vprop__tQuery *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(vprop__tQuery); }
      public:
        /// Constructor with default initializations
        vprop__tQuery() : queryLanguage((char*)"urn:oasis:names:tc:wsbpel:2.0:sublang:xpath1.0"), __mixed() { }
        virtual ~vprop__tQuery() { }
        /// Friend allocator used by soap_new_vprop__tQuery(struct soap*, int)
        friend SOAP_FMAC1 vprop__tQuery * SOAP_FMAC2 wsdl_instantiate_vprop__tQuery(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bpel.h:81 */
#ifndef SOAP_TYPE_vprop__tProperty
#define SOAP_TYPE_vprop__tProperty (472)
/* complex XML schema type 'vprop:tProperty': */
class SOAP_CMAC vprop__tProperty {
      public:
        /// Optional attribute 'name' of XML schema type 'xsd:NCName'
        char *name;
        /// Optional attribute 'type' of XML schema type 'xsd:QName'
        char *type;
        /// Optional attribute 'element' of XML schema type 'xsd:QName'
        char *element;
        /// Optional element 'vprop:documentation' of XML schema type 'xsd:string'
        char *documentation;
        int traverse(wsdl__definitions &_param_1);
      public:
        /// Return unique type id SOAP_TYPE_vprop__tProperty
        virtual long soap_type(void) const { return SOAP_TYPE_vprop__tProperty; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type vprop__tProperty, default initialized and not managed by a soap context
        virtual vprop__tProperty *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(vprop__tProperty); }
      public:
        /// Constructor with default initializations
        vprop__tProperty() : name(), type(), element(), documentation() { }
        virtual ~vprop__tProperty() { }
        /// Friend allocator used by soap_new_vprop__tProperty(struct soap*, int)
        friend SOAP_FMAC1 vprop__tProperty * SOAP_FMAC2 wsdl_instantiate_vprop__tProperty(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bpel.h:91 */
#ifndef SOAP_TYPE_vprop__tPropertyAlias
#define SOAP_TYPE_vprop__tPropertyAlias (474)
/* complex XML schema type 'vprop:tPropertyAlias': */
class SOAP_CMAC vprop__tPropertyAlias {
      public:
        /// Optional element 'vprop:query' of XML schema type 'vprop:tQuery'
        vprop__tQuery *query;
        /// Optional attribute 'propertyName' of XML schema type 'xsd:QName'
        char *propertyName;
        /// Optional attribute 'messageType' of XML schema type 'xsd:QName'
        char *messageType;
        /// Optional attribute 'part' of XML schema type 'xsd:NCName'
        char *part;
        /// Optional attribute 'type' of XML schema type 'xsd:QName'
        char *type;
        /// Optional attribute 'element' of XML schema type 'xsd:QName'
        char *element;
        /// Optional element 'vprop:documentation' of XML schema type 'xsd:string'
        char *documentation;
      private:
        /// Not serialized
        vprop__tProperty *vpropRef;
      public:
        int traverse(wsdl__definitions &_param_1);
        vprop__tProperty *vpropPtr() const;
      public:
        /// Return unique type id SOAP_TYPE_vprop__tPropertyAlias
        virtual long soap_type(void) const { return SOAP_TYPE_vprop__tPropertyAlias; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type vprop__tPropertyAlias, default initialized and not managed by a soap context
        virtual vprop__tPropertyAlias *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(vprop__tPropertyAlias); }
      public:
        /// Constructor with default initializations
        vprop__tPropertyAlias() : query(), propertyName(), messageType(), part(), type(), element(), documentation(), vpropRef() { }
        virtual ~vprop__tPropertyAlias() { }
        /// Friend allocator used by soap_new_vprop__tPropertyAlias(struct soap*, int)
        friend SOAP_FMAC1 vprop__tPropertyAlias * SOAP_FMAC2 wsdl_instantiate_vprop__tPropertyAlias(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../gsoap/wsdl/wsdl.h:56 */
#ifndef SOAP_TYPE_wsdl__import
#define SOAP_TYPE_wsdl__import (479)
/* complex XML schema type 'wsdl:import': */
class SOAP_CMAC wsdl__import {
      public:
        /// Optional attribute 'namespace' of XML schema type 'xsd:anyURI'
        char *namespace_;
        /// Optional attribute 'location' of XML schema type 'xsd:anyURI'
        char *location;
      private:
        /// Not serialized
        wsdl__definitions *definitionsRef;
      public:
        wsdl__import();
        int preprocess(wsdl__definitions &_param_1);
        int traverse(wsdl__definitions &_param_1);
        void definitionsPtr(wsdl__definitions *_param_1);
        wsdl__definitions *definitionsPtr() const;
        void mark();
      public:
        /// Return unique type id SOAP_TYPE_wsdl__import
        virtual long soap_type(void) const { return SOAP_TYPE_wsdl__import; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsdl__import, default initialized and not managed by a soap context
        virtual wsdl__import *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsdl__import); }
        virtual ~wsdl__import() { }
        /// Friend allocator used by soap_new_wsdl__import(struct soap*, int)
        friend SOAP_FMAC1 wsdl__import * SOAP_FMAC2 wsdl_instantiate_wsdl__import(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../gsoap/wsdl/wsdl.h:71 */
#ifndef SOAP_TYPE_wsdl__types
#define SOAP_TYPE_wsdl__types (488)
/* Type wsdl__types is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'wsdl:types': */
class SOAP_CMAC wsdl__types : public xs__schema {
      public:
        /// Optional element 'wsdl:documentation' of XML schema type 'xsd:string'
        char *documentation;
        /// Optional element 'xs:schema' of XML schema type 'xs:schema'
        std::vector<xs__schema *> xs__schema_;
        int preprocess(wsdl__definitions &_param_1);
        int traverse(wsdl__definitions &_param_1);
        void mark();
      public:
        /// Return unique type id SOAP_TYPE_wsdl__types
        virtual long soap_type(void) const { return SOAP_TYPE_wsdl__types; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsdl__types, default initialized and not managed by a soap context
        virtual wsdl__types *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsdl__types); }
      public:
        /// Constructor with default initializations
        wsdl__types() : documentation(), xs__schema_() { }
        /// Friend allocator used by soap_new_wsdl__types(struct soap*, int)
        friend SOAP_FMAC1 wsdl__types * SOAP_FMAC2 wsdl_instantiate_wsdl__types(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap.h:48 */
#ifndef SOAP_TYPE_wsdl__part
#define SOAP_TYPE_wsdl__part (355)
/* complex XML schema type 'wsdl:part': */
class SOAP_CMAC wsdl__part {
      public:
        /// Optional attribute 'name' of XML schema type 'xsd:NMTOKEN'
        char *name;
        /// Optional attribute 'element' of XML schema type 'xsd:QName'
        char *element;
        /// Optional attribute 'type' of XML schema type 'xsd:QName'
        char *type;
        /// Optional element 'wsdl:documentation' of XML schema type 'xsd:string'
        char *documentation;
      private:
        /// Not serialized
        bool optional;
        /// Not serialized
        bool repeating;
        /// Not serialized
        bool fixed;
        /// Not serialized
        char *default_;
        /// Not serialized
        std::vector<char *> option;
        /// Not serialized
        xs__element *elementRef;
        /// Not serialized
        xs__simpleType *simpleTypeRef;
        /// Not serialized
        xs__complexType *complexTypeRef;
      public:
        wsdl__part();
        int traverse(wsdl__definitions &_param_1);
        void elementPtr(xs__element *_param_1);
        void simpleTypePtr(xs__simpleType *_param_1);
        void complexTypePtr(xs__complexType *_param_1);
        xs__element *elementPtr() const;
        xs__simpleType *simpleTypePtr() const;
        xs__complexType *complexTypePtr() const;
        void set_optional(bool _param_1);
        void set_fixed(bool _param_1);
        void set_repeating(bool _param_1);
        void set_default(char *_param_1);
        void set_option(char *_param_1);
        bool is_optional() const;
        bool is_fixed() const;
        bool is_repeating() const;
        const char *get_default() const;
        const std::vector<char *> &options() const;
        void mark();
      public:
        /// Return unique type id SOAP_TYPE_wsdl__part
        virtual long soap_type(void) const { return SOAP_TYPE_wsdl__part; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsdl__part, default initialized and not managed by a soap context
        virtual wsdl__part *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsdl__part); }
        virtual ~wsdl__part() { }
        /// Friend allocator used by soap_new_wsdl__part(struct soap*, int)
        friend SOAP_FMAC1 wsdl__part * SOAP_FMAC2 wsdl_instantiate_wsdl__part(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* soap.h:47 */
#ifndef SOAP_TYPE_wsdl__message
#define SOAP_TYPE_wsdl__message (354)
/* complex XML schema type 'wsdl:message': */
class SOAP_CMAC wsdl__message {
      public:
        /// Optional attribute 'name' of XML schema type 'xsd:NMTOKEN'
        char *name;
        /// Optional element 'wsdl:documentation' of XML schema type 'xsd:string'
        char *documentation;
        /// Optional element 'wsp:Policy' of XML schema type 'wsp:Policy'
        std::vector<wsp__Policy> wsp__Policy_;
        /// Optional element 'wsp:PolicyReference' of XML schema type 'wsp:PolicyReference'
        std::vector<wsp__PolicyReference> wsp__PolicyReference_;
        /// Optional element 'wsdl:part' of XML schema type 'wsdl:part'
        std::vector<wsdl__part> part;
        int traverse(wsdl__definitions &_param_1);
        void mark();
      public:
        /// Return unique type id SOAP_TYPE_wsdl__message
        virtual long soap_type(void) const { return SOAP_TYPE_wsdl__message; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsdl__message, default initialized and not managed by a soap context
        virtual wsdl__message *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsdl__message); }
      public:
        /// Constructor with default initializations
        wsdl__message() : name(), documentation(), wsp__Policy_(), wsp__PolicyReference_(), part() { }
        virtual ~wsdl__message() { }
        /// Friend allocator used by soap_new_wsdl__message(struct soap*, int)
        friend SOAP_FMAC1 wsdl__message * SOAP_FMAC2 wsdl_instantiate_wsdl__message(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../gsoap/wsdl/wsdl.h:130 */
#ifndef SOAP_TYPE_wsdl__ioput
#define SOAP_TYPE_wsdl__ioput (519)
/* complex XML schema type 'wsdl:ioput': */
class SOAP_CMAC wsdl__ioput {
      public:
        /// Optional attribute 'name' of XML schema type 'xsd:NMTOKEN'
        char *name;
        /// Optional attribute 'message' of XML schema type 'xsd:QName'
        char *message;
        /// Optional attribute 'messageLabel' of XML schema type 'xsd:NMTOKEN'
        char *messageLabel;
        /// Optional attribute 'element' of XML schema type 'xsd:QName'
        char *element;
        /// Optional attribute 'wsa:Action' of XML schema type 'xsd:anyURI'
        char *wsa__Action;
        /// Optional attribute 'wsam:Action' of XML schema type 'xsd:anyURI'
        char *wsam__Action;
        /// Optional attribute 'wsaw:Action' of XML schema type 'xsd:anyURI'
        char *wsaw__Action;
        /// Optional element 'wsdl:documentation' of XML schema type 'xsd:string'
        char *documentation;
        /// Optional element 'wsp:Policy' of XML schema type 'wsp:Policy'
        wsp__Policy *wsp__Policy_;
        /// Optional element 'wsp:PolicyReference' of XML schema type 'wsp:PolicyReference'
        wsp__PolicyReference *wsp__PolicyReference_;
      private:
        /// Not serialized
        wsdl__message *messageRef;
        /// Not serialized
        xs__element *elementRef;
      public:
        wsdl__ioput();
        int traverse(wsdl__definitions &_param_1);
        void messagePtr(wsdl__message *_param_1);
        wsdl__message *messagePtr() const;
        void elementPtr(xs__element *_param_1);
        xs__element *elementPtr() const;
        void mark();
      public:
        /// Return unique type id SOAP_TYPE_wsdl__ioput
        virtual long soap_type(void) const { return SOAP_TYPE_wsdl__ioput; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsdl__ioput, default initialized and not managed by a soap context
        virtual wsdl__ioput *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsdl__ioput); }
        virtual ~wsdl__ioput() { }
        /// Friend allocator used by soap_new_wsdl__ioput(struct soap*, int)
        friend SOAP_FMAC1 wsdl__ioput * SOAP_FMAC2 wsdl_instantiate_wsdl__ioput(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../gsoap/wsdl/wsdl.h:155 */
#ifndef SOAP_TYPE_wsdl__fault
#define SOAP_TYPE_wsdl__fault (527)
/* complex XML schema type 'wsdl:fault': */
class SOAP_CMAC wsdl__fault {
      public:
        /// Optional attribute 'name' of XML schema type 'xsd:NMTOKEN'
        char *name;
        /// Optional attribute 'message' of XML schema type 'xsd:QName'
        char *message;
        /// Optional attribute 'ref' of XML schema type 'xsd:QName'
        char *ref;
        /// Optional attribute 'messageLabel' of XML schema type 'xsd:NMTOKEN'
        char *messageLabel;
        /// Optional attribute 'element' of XML schema type 'xsd:QName'
        char *element;
        /// Optional attribute 'wsa:Action' of XML schema type 'xsd:anyURI'
        char *wsa__Action;
        /// Optional attribute 'wsam:Action' of XML schema type 'xsd:anyURI'
        char *wsam__Action;
        /// Optional attribute 'wsaw:Action' of XML schema type 'xsd:anyURI'
        char *wsaw__Action;
        /// Optional element 'wsdl:documentation' of XML schema type 'xsd:string'
        char *documentation;
        /// Optional element 'wsp:Policy' of XML schema type 'wsp:Policy'
        wsp__Policy *wsp__Policy_;
        /// Optional element 'wsp:PolicyReference' of XML schema type 'wsp:PolicyReference'
        wsp__PolicyReference *wsp__PolicyReference_;
      private:
        /// Not serialized
        wsdl__message *messageRef;
        /// Not serialized
        xs__element *elementRef;
      public:
        wsdl__fault();
        int traverse(wsdl__definitions &_param_1);
        void messagePtr(wsdl__message *_param_1);
        wsdl__message *messagePtr() const;
        void elementPtr(xs__element *_param_1);
        xs__element *elementPtr() const;
        void mark();
      public:
        /// Return unique type id SOAP_TYPE_wsdl__fault
        virtual long soap_type(void) const { return SOAP_TYPE_wsdl__fault; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsdl__fault, default initialized and not managed by a soap context
        virtual wsdl__fault *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsdl__fault); }
        virtual ~wsdl__fault() { }
        /// Friend allocator used by soap_new_wsdl__fault(struct soap*, int)
        friend SOAP_FMAC1 wsdl__fault * SOAP_FMAC2 wsdl_instantiate_wsdl__fault(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../gsoap/wsdl/wsdl.h:193 */
#ifndef SOAP_TYPE_wsdl__union_ioput
#define SOAP_TYPE_wsdl__union_ioput (535)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union wsdl__union_ioput
{
        #define SOAP_UNION_wsdl__union_ioput_input	(1)	/**< union variant selector value for member input */
        wsdl__ioput *input;
        #define SOAP_UNION_wsdl__union_ioput_output	(2)	/**< union variant selector value for member output */
        wsdl__ioput *output;
};
#endif

/* gwsdl.h:41 */
#ifndef SOAP_TYPE_wsdl__operation
#define SOAP_TYPE_wsdl__operation (402)
/* complex XML schema type 'wsdl:operation': */
class SOAP_CMAC wsdl__operation {
      public:
        /// Optional attribute 'name' of XML schema type 'xsd:NMTOKEN'
        char *name;
        /// Optional attribute 'pattern' of XML schema type 'xsd:anyURI'
        char *pattern;
        /// Optional attribute 'style' of XML schema type 'xsd:anyURI'
        char *style;
        /// Optional attribute 'wrpc:signature' of XML schema type 'xsd:string'
        char *wrpc__signature;
        /// Optional attribute 'parameterOrder' of XML schema type 'xsd:string'
        char *parameterOrder;
        /// Optional element 'wsdl:documentation' of XML schema type 'xsd:string'
        char *documentation;
        /// Optional element 'wsp:Policy' of XML schema type 'wsp:Policy'
        wsp__Policy *wsp__Policy_;
        /// Optional element 'wsp:PolicyReference' of XML schema type 'wsp:PolicyReference'
        wsp__PolicyReference *wsp__PolicyReference_;
        /// Union with union wsdl__union_ioput variant selector __union1 set to one of: SOAP_UNION_wsdl__union_ioput_input SOAP_UNION_wsdl__union_ioput_output
        int __union1;
        union wsdl__union_ioput __ioput1;
        /// Union with union wsdl__union_ioput variant selector __union2 set to one of: SOAP_UNION_wsdl__union_ioput_input SOAP_UNION_wsdl__union_ioput_output
        int __union2;
        union wsdl__union_ioput __ioput2;
        /// Optional element 'wsdl:fault' of XML schema type 'wsdl:fault'
        std::vector<wsdl__fault> fault;
        /// Optional element 'wsdl:infault' of XML schema type 'wsdl:fault'
        std::vector<wsdl__fault> infault;
        /// Optional element 'wsdl:outfault' of XML schema type 'wsdl:fault'
        std::vector<wsdl__fault> outfault;
        int traverse(wsdl__definitions &_param_1);
        void mark();
      public:
        /// Return unique type id SOAP_TYPE_wsdl__operation
        virtual long soap_type(void) const { return SOAP_TYPE_wsdl__operation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsdl__operation, default initialized and not managed by a soap context
        virtual wsdl__operation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsdl__operation); }
      public:
        /// Constructor with default initializations
        wsdl__operation() : name(), pattern(), style(), wrpc__signature(), parameterOrder(), documentation(), wsp__Policy_(), wsp__PolicyReference_(), __union1(), __union2(), fault(), infault(), outfault() { }
        virtual ~wsdl__operation() { }
        /// Friend allocator used by soap_new_wsdl__operation(struct soap*, int)
        friend SOAP_FMAC1 wsdl__operation * SOAP_FMAC2 wsdl_instantiate_wsdl__operation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bpel.h:47 */
#ifndef SOAP_TYPE_wsdl__portType
#define SOAP_TYPE_wsdl__portType (458)
/* Type wsdl__portType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'wsdl:portType': */
class SOAP_CMAC wsdl__portType {
      public:
        /// Optional attribute 'name' of XML schema type 'xsd:NMTOKEN'
        char *name;
        /// Optional attribute 'extends' of XML schema type 'xsd:QName'
        char *extends;
        /// Optional attribute 'styleDefault' of XML schema type 'xsd:anyURI'
        char *styleDefault;
        /// Optional element 'wsdl:documentation' of XML schema type 'xsd:string'
        char *documentation;
        /// Optional element 'wsp:Policy' of XML schema type 'wsp:Policy'
        wsp__Policy *wsp__Policy_;
        /// Optional element 'wsp:PolicyReference' of XML schema type 'wsp:PolicyReference'
        wsp__PolicyReference *wsp__PolicyReference_;
        /// Optional element 'wsdl:fault' of XML schema type 'wsdl:fault'
        std::vector<wsdl__fault> fault;
        /// Optional element 'wsdl:operation' of XML schema type 'wsdl:operation'
        std::vector<wsdl__operation> operation;
      private:
        /// Not serialized
        wsdl__definitions *definitionsRef;
      public:
        wsdl__portType();
        int traverse(wsdl__definitions &_param_1);
        void definitionsPtr(wsdl__definitions *_param_1);
        wsdl__definitions *definitionsPtr() const;
        void mark();
      public:
        /// Return unique type id SOAP_TYPE_wsdl__portType
        virtual long soap_type(void) const { return SOAP_TYPE_wsdl__portType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsdl__portType, default initialized and not managed by a soap context
        virtual wsdl__portType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsdl__portType); }
        virtual ~wsdl__portType() { }
        /// Friend allocator used by soap_new_wsdl__portType(struct soap*, int)
        friend SOAP_FMAC1 wsdl__portType * SOAP_FMAC2 wsdl_instantiate_wsdl__portType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../gsoap/wsdl/wsdl.h:226 */
#ifndef SOAP_TYPE_wsdl__ext_ioput
#define SOAP_TYPE_wsdl__ext_ioput (546)
/* complex XML schema type 'wsdl:ext-ioput': */
class SOAP_CMAC wsdl__ext_ioput {
      public:
        /// Optional attribute 'name' of XML schema type 'xsd:NMTOKEN'
        char *name;
        /// Optional attribute 'messageLabel' of XML schema type 'xsd:NMTOKEN'
        char *messageLabel;
        /// Optional element 'wsdl:documentation' of XML schema type 'xsd:string'
        char *documentation;
        /// Optional element 'wsp:Policy' of XML schema type 'wsp:Policy'
        wsp__Policy *wsp__Policy_;
        /// Optional element 'wsp:PolicyReference' of XML schema type 'wsp:PolicyReference'
        wsp__PolicyReference *wsp__PolicyReference_;
        /// Optional element 'dime:message' of XML schema type 'dime:message'
        dime__message *dime__message_;
        /// Optional element 'soap:body' of XML schema type 'soap:body'
        soap__body *soap__body_;
        /// Optional element 'http:urlEncoded' of XML schema type 'xsd:string'
        char *http__urlEncoded;
        /// Optional element 'mime:multipartRelated' of XML schema type 'mime:multipartRelated'
        mime__multipartRelated *mime__multipartRelated_;
        /// Optional element 'mime:content' of XML schema type 'mime:content'
        mime__content *mime__content_;
        /// Optional element 'mime:mimeXml' of XML schema type 'mime:mimeXml'
        mime__mimeXml *mime__mimeXml_;
        /// Optional element 'soap:header' of XML schema type 'soap:header'
        std::vector<soap__header> soap__header_;
        /// Optional element 'wsoap:module' of XML schema type 'wsoap:module'
        std::vector<wsoap__module> wsoap__module_;
        /// Optional element 'wsoap:header' of XML schema type 'wsoap:header'
        std::vector<wsoap__header> wsoap__header_;
        /// Optional element 'whttp:header' of XML schema type 'whttp:header'
        std::vector<whttp__header> whttp__header_;
        int traverse(wsdl__definitions &_param_1);
        void mark();
      public:
        /// Return unique type id SOAP_TYPE_wsdl__ext_ioput
        virtual long soap_type(void) const { return SOAP_TYPE_wsdl__ext_ioput; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsdl__ext_ioput, default initialized and not managed by a soap context
        virtual wsdl__ext_ioput *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsdl__ext_ioput); }
      public:
        /// Constructor with default initializations
        wsdl__ext_ioput() : name(), messageLabel(), documentation(), wsp__Policy_(), wsp__PolicyReference_(), dime__message_(), soap__body_(), http__urlEncoded(), mime__multipartRelated_(), mime__content_(), mime__mimeXml_(), soap__header_(), wsoap__module_(), wsoap__header_(), whttp__header_() { }
        virtual ~wsdl__ext_ioput() { }
        /// Friend allocator used by soap_new_wsdl__ext_ioput(struct soap*, int)
        friend SOAP_FMAC1 wsdl__ext_ioput * SOAP_FMAC2 wsdl_instantiate_wsdl__ext_ioput(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../gsoap/wsdl/wsdl.h:248 */
#ifndef SOAP_TYPE_wsdl__ext_fault
#define SOAP_TYPE_wsdl__ext_fault (556)
/* complex XML schema type 'wsdl:ext-fault': */
class SOAP_CMAC wsdl__ext_fault {
      public:
        /// Optional attribute 'name' of XML schema type 'xsd:NMTOKEN'
        char *name;
        /// Optional attribute 'ref' of XML schema type 'xsd:QName'
        char *ref;
        /// Optional attribute 'messageLabel' of XML schema type 'xsd:NMTOKEN'
        char *messageLabel;
        /// Optional attribute 'wsoap:code' of XML schema type 'xsd:QName'
        char *wsoap__code;
        /// Optional attribute 'wsoap:subcodes' of XML schema type 'xsd:QName'
        char *wsoap__subcodes;
        /// Optional element 'wsdl:documentation' of XML schema type 'xsd:string'
        char *documentation;
        /// Optional element 'wsp:Policy' of XML schema type 'wsp:Policy'
        wsp__Policy *wsp__Policy_;
        /// Optional element 'wsp:PolicyReference' of XML schema type 'wsp:PolicyReference'
        wsp__PolicyReference *wsp__PolicyReference_;
        /// Optional element 'soap:fault' of XML schema type 'soap:fault'
        soap__fault *soap__fault_;
        /// Optional element 'wsoap:module' of XML schema type 'wsoap:module'
        std::vector<wsoap__module> wsoap__module_;
      private:
        /// Not serialized
        wsdl__fault *faultRef;
      public:
        wsdl__ext_fault();
        int traverse(wsdl__definitions &_param_1, wsdl__portType *_param_2);
        void faultPtr(wsdl__fault *_param_1);
        wsdl__fault *faultPtr() const;
      public:
        /// Return unique type id SOAP_TYPE_wsdl__ext_fault
        virtual long soap_type(void) const { return SOAP_TYPE_wsdl__ext_fault; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsdl__ext_fault, default initialized and not managed by a soap context
        virtual wsdl__ext_fault *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsdl__ext_fault); }
        virtual ~wsdl__ext_fault() { }
        /// Friend allocator used by soap_new_wsdl__ext_fault(struct soap*, int)
        friend SOAP_FMAC1 wsdl__ext_fault * SOAP_FMAC2 wsdl_instantiate_wsdl__ext_fault(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../gsoap/wsdl/wsdl.h:269 */
#ifndef SOAP_TYPE_wsdl__ext_operation
#define SOAP_TYPE_wsdl__ext_operation (565)
/* complex XML schema type 'wsdl:ext-operation': */
class SOAP_CMAC wsdl__ext_operation {
      public:
        /// Optional attribute 'name' of XML schema type 'xsd:NMTOKEN'
        char *name;
        /// Optional attribute 'ref' of XML schema type 'xsd:QName'
        char *ref;
        /// Optional attribute 'wsoap:mep' of XML schema type 'xsd:anyURI'
        char *wsoap__mep;
        /// Optional attribute 'wsoap:action' of XML schema type 'xsd:anyURI'
        char *wsoap__action;
        /// Optional attribute 'whttp:method' of XML schema type 'xsd:string'
        char *whttp__method;
        /// Optional attribute 'whttp:location' of XML schema type 'xsd:string'
        char *whttp__location;
        /// Optional element 'wsdl:documentation' of XML schema type 'xsd:string'
        char *documentation;
        /// Optional element 'wsp:Policy' of XML schema type 'wsp:Policy'
        wsp__Policy *wsp__Policy_;
        /// Optional element 'wsp:PolicyReference' of XML schema type 'wsp:PolicyReference'
        wsp__PolicyReference *wsp__PolicyReference_;
        /// Optional element 'soap:operation' of XML schema type 'soap:operation'
        soap__operation *soap__operation_;
        /// Optional element 'http:operation' of XML schema type 'http:operation'
        http__operation *http__operation_;
        /// Optional element 'wsdl:input' of XML schema type 'wsdl:ext-ioput'
        wsdl__ext_ioput *input;
        /// Optional element 'wsdl:output' of XML schema type 'wsdl:ext-ioput'
        wsdl__ext_ioput *output;
        /// Optional element 'wsdl:fault' of XML schema type 'wsdl:ext-fault'
        std::vector<wsdl__ext_fault> fault;
        /// Optional element 'wsdl:infault' of XML schema type 'wsdl:ext-fault'
        std::vector<wsdl__ext_fault> infault;
        /// Optional element 'wsdl:outfault' of XML schema type 'wsdl:ext-fault'
        std::vector<wsdl__ext_fault> outfault;
      private:
        /// Not serialized
        wsdl__operation *operationRef;
      public:
        wsdl__ext_operation();
        int traverse(wsdl__definitions &_param_1, wsdl__portType *_param_2);
        void operationPtr(wsdl__operation *_param_1);
        wsdl__operation *operationPtr() const;
        void mark();
      public:
        /// Return unique type id SOAP_TYPE_wsdl__ext_operation
        virtual long soap_type(void) const { return SOAP_TYPE_wsdl__ext_operation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsdl__ext_operation, default initialized and not managed by a soap context
        virtual wsdl__ext_operation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsdl__ext_operation); }
        virtual ~wsdl__ext_operation() { }
        /// Friend allocator used by soap_new_wsdl__ext_operation(struct soap*, int)
        friend SOAP_FMAC1 wsdl__ext_operation * SOAP_FMAC2 wsdl_instantiate_wsdl__ext_operation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../gsoap/wsdl/wsdl.h:297 */
#ifndef SOAP_TYPE_wsdl__binding
#define SOAP_TYPE_wsdl__binding (576)
/* Type wsdl__binding is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'wsdl:binding': */
class SOAP_CMAC wsdl__binding {
      public:
        /// Optional attribute 'name' of XML schema type 'xsd:NMTOKEN'
        char *name;
        /// Optional attribute 'type' of XML schema type 'xsd:QName'
        char *type;
        /// Optional attribute 'type' of XML schema type 'xsd:anyURI'
        char *type_;
        /// Optional attribute 'interface' of XML schema type 'xsd:QName'
        char *interface_;
        /// Optional attribute 'whttp:cookies' of XML schema type 'xsd:boolean'
        bool whttp__cookies;	///< initialized with default value = (bool)0
        /// Optional attribute 'wsoap:version' of XML schema type 'xsd:string'
        char *wsoap__version;
        /// Optional attribute 'wsoap:protocol' of XML schema type 'xsd:anyURI'
        char *wsoap__protocol;
        /// Optional attribute 'wsoap:mepDefault' of XML schema type 'xsd:anyURI'
        char *wsoap__mepDefault;
        /// Optional attribute 'whttp:methodDefault' of XML schema type 'xsd:string'
        char *whttp__methodDefault;
        /// Optional element 'wsdl:documentation' of XML schema type 'xsd:string'
        char *documentation;
        /// Optional element 'wsp:Policy' of XML schema type 'wsp:Policy'
        std::vector<wsp__Policy> wsp__Policy_;
        /// Optional element 'wsp:PolicyReference' of XML schema type 'wsp:PolicyReference'
        std::vector<wsp__PolicyReference> wsp__PolicyReference_;
        /// Optional element 'soap:binding' of XML schema type 'soap:binding'
        soap__binding *soap__binding_;
        /// Optional element 'http:binding' of XML schema type 'http:binding'
        http__binding *http__binding_;
        /// Optional element 'wsaw:UsingAddressing' of XML schema type 'xsd:string'
        char **wsaw__UsingAddressing;
        /// Optional element 'wsoap:module' of XML schema type 'wsoap:module'
        std::vector<wsoap__module> wsoap__module_;
        /// Optional element 'wsdl:fault' of XML schema type 'wsdl:ext-fault'
        std::vector<wsdl__ext_fault> fault;
        /// Optional element 'wsdl:operation' of XML schema type 'wsdl:ext-operation'
        std::vector<wsdl__ext_operation> operation;
      private:
        /// Not serialized
        wsdl__portType *portTypeRef;
      public:
        wsdl__binding();
        int traverse(wsdl__definitions &_param_1);
        void portTypePtr(wsdl__portType *_param_1);
        wsdl__portType *portTypePtr() const;
        void mark();
      public:
        /// Return unique type id SOAP_TYPE_wsdl__binding
        virtual long soap_type(void) const { return SOAP_TYPE_wsdl__binding; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsdl__binding, default initialized and not managed by a soap context
        virtual wsdl__binding *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsdl__binding); }
        virtual ~wsdl__binding() { }
        /// Friend allocator used by soap_new_wsdl__binding(struct soap*, int)
        friend SOAP_FMAC1 wsdl__binding * SOAP_FMAC2 wsdl_instantiate_wsdl__binding(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../gsoap/wsdl/wsdl.h:327 */
#ifndef SOAP_TYPE_wsdl__port
#define SOAP_TYPE_wsdl__port (586)
/* complex XML schema type 'wsdl:port': */
class SOAP_CMAC wsdl__port {
      public:
        /// Optional attribute 'name' of XML schema type 'xsd:NMTOKEN'
        char *name;
        /// Optional attribute 'binding' of XML schema type 'xsd:QName'
        char *binding;
        /// Optional attribute 'address' of XML schema type 'xsd:anyURI'
        char *address;
        /// Optional attribute 'whttp:authenticationScheme' of XML schema type 'xsd:NMTOKEN'
        char *whttp__authenticationScheme;
        /// Optional attribute 'whttp:authenticationRealm' of XML schema type 'xsd:NMTOKEN'
        char *whttp__authenticationRealm;
        /// Optional element 'wsdl:documentation' of XML schema type 'xsd:string'
        char *documentation;
        /// Optional element 'wsp:Policy' of XML schema type 'wsp:Policy'
        wsp__Policy *wsp__Policy_;
        /// Optional element 'wsp:PolicyReference' of XML schema type 'wsp:PolicyReference'
        wsp__PolicyReference *wsp__PolicyReference_;
        /// Optional element 'wsa:EndpointReference' of XML schema type 'wsa:EndpointReferenceType'
        wsa__EndpointReferenceType *wsa__EndpointReference;
        /// Optional element 'wsaw:UsingAddressing' of XML schema type 'xsd:string'
        char **wsaw__UsingAddressing;
        /// Optional element 'soap:address' of XML schema type 'soap:address'
        soap__address *soap__address_;
        /// Optional element 'http:address' of XML schema type 'http:address'
        http__address *http__address_;
      private:
        /// Not serialized
        wsdl__binding *bindingRef;
      public:
        wsdl__port();
        int traverse(wsdl__definitions &_param_1);
        void bindingPtr(wsdl__binding *_param_1);
        wsdl__binding *bindingPtr() const;
      public:
        /// Return unique type id SOAP_TYPE_wsdl__port
        virtual long soap_type(void) const { return SOAP_TYPE_wsdl__port; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsdl__port, default initialized and not managed by a soap context
        virtual wsdl__port *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsdl__port); }
        virtual ~wsdl__port() { }
        /// Friend allocator used by soap_new_wsdl__port(struct soap*, int)
        friend SOAP_FMAC1 wsdl__port * SOAP_FMAC2 wsdl_instantiate_wsdl__port(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../gsoap/wsdl/wsdl.h:350 */
#ifndef SOAP_TYPE_wsdl__service
#define SOAP_TYPE_wsdl__service (595)
/* Type wsdl__service is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'wsdl:service': */
class SOAP_CMAC wsdl__service {
      public:
        /// Optional attribute 'name' of XML schema type 'xsd:NMTOKEN'
        char *name;
        /// Optional attribute 'interface' of XML schema type 'xsd:QName'
        char *interface_;
        /// Optional element 'wsdl:documentation' of XML schema type 'xsd:string'
        char *documentation;
        /// Optional element 'wsp:Policy' of XML schema type 'wsp:Policy'
        std::vector<wsp__Policy> wsp__Policy_;
        /// Optional element 'wsp:PolicyReference' of XML schema type 'wsp:PolicyReference'
        std::vector<wsp__PolicyReference> wsp__PolicyReference_;
        /// Optional element 'wsdl:port' of XML schema type 'wsdl:port'
        std::vector<wsdl__port> port;
        /// Optional element 'wsdl:endpoint' of XML schema type 'wsdl:port'
        std::vector<wsdl__port> endpoint;
        int traverse(wsdl__definitions &_param_1);
      public:
        /// Return unique type id SOAP_TYPE_wsdl__service
        virtual long soap_type(void) const { return SOAP_TYPE_wsdl__service; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsdl__service, default initialized and not managed by a soap context
        virtual wsdl__service *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsdl__service); }
      public:
        /// Constructor with default initializations
        wsdl__service() : name(), interface_(), documentation(), wsp__Policy_(), wsp__PolicyReference_(), port(), endpoint() { }
        virtual ~wsdl__service() { }
        /// Friend allocator used by soap_new_wsdl__service(struct soap*, int)
        friend SOAP_FMAC1 wsdl__service * SOAP_FMAC2 wsdl_instantiate_wsdl__service(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../gsoap/wsdl/wsdl.h:42 */
#ifndef SOAP_TYPE_wsdl__definitions
#define SOAP_TYPE_wsdl__definitions (7)
/* Type wsdl__definitions is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'wsdl:definitions': */
class SOAP_CMAC wsdl__definitions {
      public:
        /// Optional attribute 'name' of XML schema type 'xsd:NMTOKEN'
        char *name;
        /// Optional attribute 'targetNamespace' of XML schema type 'xsd:anyURI'
        char *targetNamespace;	///< initialized with default value = (char*)""
        /// Optional attribute 'version' of XML schema type 'xsd:NMTOKEN'
        char *version;
        /// Optional element 'wsdl:import' of XML schema type 'wsdl:import'
        std::vector<wsdl__import> import;
        /// Optional element 'wsdl:documentation' of XML schema type 'xsd:string'
        char *documentation;
        /// Optional element 'wsdl:types' of XML schema type 'wsdl:types'
        wsdl__types *types;
        /// Optional element 'wsdl:message' of XML schema type 'wsdl:message'
        std::vector<wsdl__message> message;
        /// Optional element 'wsdl:portType' of XML schema type 'wsdl:portType'
        std::vector<wsdl__portType> portType;
        /// Optional element 'wsdl:interface' of XML schema type 'wsdl:portType'
        std::vector<wsdl__portType> interface_;
        /// Optional element 'wsdl:binding' of XML schema type 'wsdl:binding'
        std::vector<wsdl__binding> binding;
        /// Optional element 'wsdl:service' of XML schema type 'wsdl:service'
        std::vector<wsdl__service> service;
        /// Optional element 'wsp:UsingPolicy' of XML schema type 'xsd:string'
        char *wsp__UsingPolicy;
        /// Optional element 'wsp:Policy' of XML schema type 'wsp:Policy'
        std::vector<wsp__Policy> wsp__Policy_;
        /// Optional element 'plnk:partnerLinkType' of XML schema type 'plnk:tPartnerLinkType'
        std::vector<plnk__tPartnerLinkType> plnk__partnerLinkType;
        /// Optional element 'vprop:property' of XML schema type 'vprop:tProperty'
        std::vector<vprop__tProperty> vprop__property;
        /// Optional element 'vprop:propertyAlias' of XML schema type 'vprop:tPropertyAlias'
        std::vector<vprop__tPropertyAlias> vprop__propertyAlias;
        /// Optional element 'gwsdl:portType' of XML schema type 'gwsdl:portType'
        std::vector<gwsdl__portType> gwsdl__portType_;
        /// Context that manages this object
        struct soap *soap;
      private:
        /// Not serialized
        bool soap12;
        /// Not serialized
        bool updated;
        /// Not serialized
        char *location;
        /// Not serialized
        int redirs;
        /// Not serialized
        MapOfStringToString builtinTypeMap;
        /// Not serialized
        SetOfString builtinTypeSet;
        /// Not serialized
        SetOfString builtinElementSet;
        /// Not serialized
        SetOfString builtinAttributeSet;
        /// Not serialized
        wadl__application *appRef;
        /// Not serialized
        bool used;
      public:
        wsdl__definitions();
        wsdl__definitions(struct soap *_param_1);
        wsdl__definitions(struct soap *_param_1, const char *_param_2, const char *_param_3, const char *_param_4);
        virtual ~wsdl__definitions();
        int get(struct soap *_param_1);
        int preprocess();
        int traverse();
        int read(int _param_1, char **_param_2);
        int read(const char *_param_1, const char *_param_2, const char *_param_3);
        const char *sourceLocation();
        char *absoluteLocation(const char *loc) const;
        int error();
        bool is_updated();
        void print_fault();
        void builtinType(const char *_param_1);
        void builtinTypes(const SetOfString &_param_1);
        void builtinTypeDerivation(xs__schema &_param_1, const char *_param_2, const char *_param_3);
        void builtinTypeDerivations(const MapOfStringToString &_param_1);
        void builtinElement(const char *_param_1);
        void builtinElements(const SetOfString &_param_1);
        void builtinAttribute(const char *_param_1);
        void builtinAttributes(const SetOfString &_param_1);
        const SetOfString &builtinTypes() const;
        const MapOfStringToString &builtinTypeDerivations() const;
        const SetOfString &builtinElements() const;
        const SetOfString &builtinAttributes() const;
        void appPtr(wadl__application *_param_1);
        wadl__application *appPtr() const;
        void mark();
        friend std::ostream &operator<<(std::ostream &_param_1, const wsdl__definitions &_param_2);
        friend std::istream &operator>>(std::istream &_param_1, wsdl__definitions &_param_2);
      public:
        /// Return unique type id SOAP_TYPE_wsdl__definitions
        virtual long soap_type(void) const { return SOAP_TYPE_wsdl__definitions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsdl__definitions, default initialized and not managed by a soap context
        virtual wsdl__definitions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsdl__definitions); }
        /// Friend allocator used by soap_new_wsdl__definitions(struct soap*, int)
        friend SOAP_FMAC1 wsdl__definitions * SOAP_FMAC2 wsdl_instantiate_wsdl__definitions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ../../gsoap/wsdl/wsdl.h:432 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (647)
/* SOAP_ENV__Header: */
struct SOAP_CMAC SOAP_ENV__Header {
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Header */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Header; }
        /** Constructor with member initializations */
        SOAP_ENV__Header() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Header * SOAP_FMAC2 wsdl_instantiate_SOAP_ENV__Header(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* ../../gsoap/wsdl/wsdl.h:432 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (648)
/* Type SOAP_ENV__Code is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* SOAP_ENV__Code: */
struct SOAP_CMAC SOAP_ENV__Code {
      public:
        /** Optional element 'SOAP-ENV:Value' of XML schema type 'xsd:QName' */
        char *SOAP_ENV__Value;
        /** Optional element 'SOAP-ENV:Subcode' of XML schema type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Subcode;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Code */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Code; }
        /** Constructor with member initializations */
        SOAP_ENV__Code() : SOAP_ENV__Value(), SOAP_ENV__Subcode() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Code * SOAP_FMAC2 wsdl_instantiate_SOAP_ENV__Code(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* ../../gsoap/wsdl/wsdl.h:432 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (650)
/* SOAP_ENV__Detail: */
struct SOAP_CMAC SOAP_ENV__Detail {
      public:
        char *__any;
        /** Any type of element 'fault' assigned to fault with its SOAP_TYPE_<typename> assigned to __type */
        /** Do not create a cyclic data structure through this member unless SOAP encoding or SOAP_XML_GRAPH are used for id-ref serialization */
        int __type;
        void *fault;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Detail */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Detail; }
        /** Constructor with member initializations */
        SOAP_ENV__Detail() : __any(), __type(), fault() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Detail * SOAP_FMAC2 wsdl_instantiate_SOAP_ENV__Detail(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* ../../gsoap/wsdl/wsdl.h:432 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (651)
/* SOAP_ENV__Reason: */
struct SOAP_CMAC SOAP_ENV__Reason {
      public:
        /** Optional element 'SOAP-ENV:Text' of XML schema type 'xsd:string' */
        char *SOAP_ENV__Text;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Reason */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Reason; }
        /** Constructor with member initializations */
        SOAP_ENV__Reason() : SOAP_ENV__Text() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Reason * SOAP_FMAC2 wsdl_instantiate_SOAP_ENV__Reason(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* ../../gsoap/wsdl/wsdl.h:432 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (652)
/* SOAP_ENV__Fault: */
struct SOAP_CMAC SOAP_ENV__Fault {
      public:
        /** Optional element 'faultcode' of XML schema type 'xsd:QName' */
        char *faultcode;
        /** Optional element 'faultstring' of XML schema type 'xsd:string' */
        char *faultstring;
        /** Optional element 'faultactor' of XML schema type 'xsd:string' */
        char *faultactor;
        /** Optional element 'detail' of XML schema type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *detail;
        /** Optional element 'SOAP-ENV:Code' of XML schema type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Code;
        /** Optional element 'SOAP-ENV:Reason' of XML schema type 'SOAP-ENV:Reason' */
        struct SOAP_ENV__Reason *SOAP_ENV__Reason;
        /** Optional element 'SOAP-ENV:Node' of XML schema type 'xsd:string' */
        char *SOAP_ENV__Node;
        /** Optional element 'SOAP-ENV:Role' of XML schema type 'xsd:string' */
        char *SOAP_ENV__Role;
        /** Optional element 'SOAP-ENV:Detail' of XML schema type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *SOAP_ENV__Detail;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Fault */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Fault; }
        /** Constructor with member initializations */
        SOAP_ENV__Fault() : faultcode(), faultstring(), faultactor(), detail(), SOAP_ENV__Code(), SOAP_ENV__Reason(), SOAP_ENV__Node(), SOAP_ENV__Role(), SOAP_ENV__Detail() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Fault * SOAP_FMAC2 wsdl_instantiate_SOAP_ENV__Fault(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/


/* (built-in):0 */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (5)
typedef char *_XML;
#endif

/* (built-in):0 */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (6)
typedef char *_QName;
#endif

/* imports.h:37 */
#ifndef SOAP_TYPE_xsd__anyURI
#define SOAP_TYPE_xsd__anyURI (9)
typedef char *xsd__anyURI;
#endif

/* imports.h:38 */
#ifndef SOAP_TYPE_xsd__ID
#define SOAP_TYPE_xsd__ID (10)
typedef char *xsd__ID;
#endif

/* imports.h:39 */
#ifndef SOAP_TYPE_xsd__NCName
#define SOAP_TYPE_xsd__NCName (11)
typedef char *xsd__NCName;
#endif

/* imports.h:40 */
#ifndef SOAP_TYPE_xsd__NMTOKEN
#define SOAP_TYPE_xsd__NMTOKEN (12)
typedef char *xsd__NMTOKEN;
#endif

/* imports.h:41 */
#ifndef SOAP_TYPE_xsd__NMTOKENS
#define SOAP_TYPE_xsd__NMTOKENS (13)
typedef char *xsd__NMTOKENS;
#endif

/* imports.h:42 */
#ifndef SOAP_TYPE_xsd__QName
#define SOAP_TYPE_xsd__QName (14)
typedef char *xsd__QName;
#endif

/* imports.h:43 */
#ifndef SOAP_TYPE_xsd__token
#define SOAP_TYPE_xsd__token (15)
typedef char *xsd__token;
#endif

/* imports.h:44 */
#ifndef SOAP_TYPE_xsd__string
#define SOAP_TYPE_xsd__string (16)
typedef char *xsd__string;
#endif

/* imports.h:45 */
#ifndef SOAP_TYPE_xsd__boolean
#define SOAP_TYPE_xsd__boolean (18)
typedef bool xsd__boolean;
#endif

/* schema.h:174 */
#ifndef SOAP_TYPE_xs__namespaceList
#define SOAP_TYPE_xs__namespaceList (87)
typedef char *xs__namespaceList;
#endif

/* wadl.h:44 */
#ifndef SOAP_TYPE_wadl__statusCodeList
#define SOAP_TYPE_wadl__statusCodeList (273)
typedef xsd__string wadl__statusCodeList;
#endif

/******************************************************************************\
 *                                                                            *
 * Serializable Types                                                         *
 *                                                                            *
\******************************************************************************/


/* char has binding name 'byte' for type 'xsd:byte' */
#ifndef SOAP_TYPE_byte
#define SOAP_TYPE_byte (3)
#endif

/* int has binding name 'int' for type 'xsd:int' */
#ifndef SOAP_TYPE_int
#define SOAP_TYPE_int (1)
#endif

/* enum sd__mutability has binding name 'sd__mutability' for type 'sd:mutability' */
#ifndef SOAP_TYPE_sd__mutability
#define SOAP_TYPE_sd__mutability (403)
#endif

/* enum soap__useChoice has binding name 'soap__useChoice' for type 'soap:useChoice' */
#ifndef SOAP_TYPE_soap__useChoice
#define SOAP_TYPE_soap__useChoice (360)
#endif

/* enum soap__styleChoice has binding name 'soap__styleChoice' for type 'soap:styleChoice' */
#ifndef SOAP_TYPE_soap__styleChoice
#define SOAP_TYPE_soap__styleChoice (356)
#endif

/* enum wadl__ParamStyle has binding name 'wadl__ParamStyle' for type 'wadl:ParamStyle' */
#ifndef SOAP_TYPE_wadl__ParamStyle
#define SOAP_TYPE_wadl__ParamStyle (275)
#endif

/* enum wadl__HTTPMethods has binding name 'wadl__HTTPMethods' for type 'wadl:HTTPMethods' */
#ifndef SOAP_TYPE_wadl__HTTPMethods
#define SOAP_TYPE_wadl__HTTPMethods (274)
#endif

/* enum xs__processContents has binding name 'xs__processContents' for type 'xs:processContents' */
#ifndef SOAP_TYPE_xs__processContents
#define SOAP_TYPE_xs__processContents (86)
#endif

/* enum xs__attribute_use has binding name 'xs__attribute_use' for type 'xs:attribute-use' */
#ifndef SOAP_TYPE_xs__attribute_use
#define SOAP_TYPE_xs__attribute_use (68)
#endif

/* enum xs__formChoice has binding name 'xs__formChoice' for type 'xs:formChoice' */
#ifndef SOAP_TYPE_xs__formChoice
#define SOAP_TYPE_xs__formChoice (37)
#endif

/* xsd__boolean has binding name 'xsd__boolean' for type 'xsd:boolean' */
#ifndef SOAP_TYPE_xsd__boolean
#define SOAP_TYPE_xsd__boolean (18)
#endif

/* bool has binding name 'bool' for type 'xsd:boolean' */
#ifndef SOAP_TYPE_bool
#define SOAP_TYPE_bool (17)
#endif

/* wsdl__service has binding name 'wsdl__service' for type 'wsdl:service' */
#ifndef SOAP_TYPE_wsdl__service
#define SOAP_TYPE_wsdl__service (595)
#endif

/* wsdl__port has binding name 'wsdl__port' for type 'wsdl:port' */
#ifndef SOAP_TYPE_wsdl__port
#define SOAP_TYPE_wsdl__port (586)
#endif

/* wsdl__binding has binding name 'wsdl__binding' for type 'wsdl:binding' */
#ifndef SOAP_TYPE_wsdl__binding
#define SOAP_TYPE_wsdl__binding (576)
#endif

/* wsdl__ext_operation has binding name 'wsdl__ext_operation' for type 'wsdl:ext-operation' */
#ifndef SOAP_TYPE_wsdl__ext_operation
#define SOAP_TYPE_wsdl__ext_operation (565)
#endif

/* wsdl__ext_fault has binding name 'wsdl__ext_fault' for type 'wsdl:ext-fault' */
#ifndef SOAP_TYPE_wsdl__ext_fault
#define SOAP_TYPE_wsdl__ext_fault (556)
#endif

/* wsdl__ext_ioput has binding name 'wsdl__ext_ioput' for type 'wsdl:ext-ioput' */
#ifndef SOAP_TYPE_wsdl__ext_ioput
#define SOAP_TYPE_wsdl__ext_ioput (546)
#endif

/* wsdl__fault has binding name 'wsdl__fault' for type 'wsdl:fault' */
#ifndef SOAP_TYPE_wsdl__fault
#define SOAP_TYPE_wsdl__fault (527)
#endif

/* wsdl__ioput has binding name 'wsdl__ioput' for type 'wsdl:ioput' */
#ifndef SOAP_TYPE_wsdl__ioput
#define SOAP_TYPE_wsdl__ioput (519)
#endif

/* wsdl__types has binding name 'wsdl__types' for type 'wsdl:types' */
#ifndef SOAP_TYPE_wsdl__types
#define SOAP_TYPE_wsdl__types (488)
#endif

/* wsdl__import has binding name 'wsdl__import' for type 'wsdl:import' */
#ifndef SOAP_TYPE_wsdl__import
#define SOAP_TYPE_wsdl__import (479)
#endif

/* vprop__tPropertyAlias has binding name 'vprop__tPropertyAlias' for type 'vprop:tPropertyAlias' */
#ifndef SOAP_TYPE_vprop__tPropertyAlias
#define SOAP_TYPE_vprop__tPropertyAlias (474)
#endif

/* vprop__tProperty has binding name 'vprop__tProperty' for type 'vprop:tProperty' */
#ifndef SOAP_TYPE_vprop__tProperty
#define SOAP_TYPE_vprop__tProperty (472)
#endif

/* vprop__tQuery has binding name 'vprop__tQuery' for type 'vprop:tQuery' */
#ifndef SOAP_TYPE_vprop__tQuery
#define SOAP_TYPE_vprop__tQuery (471)
#endif

/* plnk__tRole has binding name 'plnk__tRole' for type 'plnk:tRole' */
#ifndef SOAP_TYPE_plnk__tRole
#define SOAP_TYPE_plnk__tRole (460)
#endif

/* plnk__tPartnerLinkType has binding name 'plnk__tPartnerLinkType' for type 'plnk:tPartnerLinkType' */
#ifndef SOAP_TYPE_plnk__tPartnerLinkType
#define SOAP_TYPE_plnk__tPartnerLinkType (459)
#endif

/* wsdl__portType has binding name 'wsdl__portType' for type 'wsdl:portType' */
#ifndef SOAP_TYPE_wsdl__portType
#define SOAP_TYPE_wsdl__portType (458)
#endif

/* wsp__PolicyAttachment has binding name 'wsp__PolicyAttachment' for type 'wsp:PolicyAttachment' */
#ifndef SOAP_TYPE_wsp__PolicyAttachment
#define SOAP_TYPE_wsp__PolicyAttachment (455)
#endif

/* wsp__AppliesTo has binding name 'wsp__AppliesTo' for type 'wsp:AppliesTo' */
#ifndef SOAP_TYPE_wsp__AppliesTo
#define SOAP_TYPE_wsp__AppliesTo (454)
#endif

/* wsp__Attachment has binding name 'wsp__Attachment' for type 'wsp:Attachment' */
#ifndef SOAP_TYPE_wsp__Attachment
#define SOAP_TYPE_wsp__Attachment (453)
#endif

/* wsrmp5__RMAssertion has binding name 'wsrmp5__RMAssertion' for type 'wsrmp5:RMAssertion' */
#ifndef SOAP_TYPE_wsrmp5__RMAssertion
#define SOAP_TYPE_wsrmp5__RMAssertion (438)
#endif

/* wsrmp5__Timeout has binding name 'wsrmp5__Timeout' for type 'wsrmp5:Timeout' */
#ifndef SOAP_TYPE_wsrmp5__Timeout
#define SOAP_TYPE_wsrmp5__Timeout (437)
#endif

/* wsrmp__RMAssertion has binding name 'wsrmp__RMAssertion' for type 'wsrmp:RMAssertion' */
#ifndef SOAP_TYPE_wsrmp__RMAssertion
#define SOAP_TYPE_wsrmp__RMAssertion (435)
#endif

/* wsrmp__Timeout has binding name 'wsrmp__Timeout' for type 'wsrmp:Timeout' */
#ifndef SOAP_TYPE_wsrmp__Timeout
#define SOAP_TYPE_wsrmp__Timeout (434)
#endif

/* sp__Token has binding name 'sp__Token' for type 'sp:Token' */
#ifndef SOAP_TYPE_sp__Token
#define SOAP_TYPE_sp__Token (431)
#endif

/* sp__Elements has binding name 'sp__Elements' for type 'sp:Elements' */
#ifndef SOAP_TYPE_sp__Elements
#define SOAP_TYPE_sp__Elements (429)
#endif

/* sp__Parts has binding name 'sp__Parts' for type 'sp:Parts' */
#ifndef SOAP_TYPE_sp__Parts
#define SOAP_TYPE_sp__Parts (427)
#endif

/* sp__Header has binding name 'sp__Header' for type 'sp:Header' */
#ifndef SOAP_TYPE_sp__Header
#define SOAP_TYPE_sp__Header (426)
#endif

/* wst__Claims has binding name 'wst__Claims' for type 'wst:Claims' */
#ifndef SOAP_TYPE_wst__Claims
#define SOAP_TYPE_wst__Claims (425)
#endif

/* wsp__Assertion has binding name 'wsp__Assertion' for type 'wsp:Assertion' */
#ifndef SOAP_TYPE_wsp__Assertion
#define SOAP_TYPE_wsp__Assertion (423)
#endif

/* wsp__PolicyReference has binding name 'wsp__PolicyReference' for type 'wsp:PolicyReference' */
#ifndef SOAP_TYPE_wsp__PolicyReference
#define SOAP_TYPE_wsp__PolicyReference (417)
#endif

/* wsp__Content has binding name 'wsp__Content' for type 'wsp:Content' */
#ifndef SOAP_TYPE_wsp__Content
#define SOAP_TYPE_wsp__Content (414)
#endif

/* wsp__Policy has binding name 'wsp__Policy' for type 'wsp:Policy' */
#ifndef SOAP_TYPE_wsp__Policy
#define SOAP_TYPE_wsp__Policy (413)
#endif

/* wsa__EndpointReferenceType has binding name 'wsa__EndpointReferenceType' for type 'wsa:EndpointReferenceType' */
#ifndef SOAP_TYPE_wsa__EndpointReferenceType
#define SOAP_TYPE_wsa__EndpointReferenceType (412)
#endif

/* gwsdl__portType has binding name 'gwsdl__portType' for type 'gwsdl:portType' */
#ifndef SOAP_TYPE_gwsdl__portType
#define SOAP_TYPE_gwsdl__portType (407)
#endif

/* sd__staticServiceDataValues has binding name 'sd__staticServiceDataValues' for type 'sd:staticServiceDataValues' */
#ifndef SOAP_TYPE_sd__staticServiceDataValues
#define SOAP_TYPE_sd__staticServiceDataValues (405)
#endif

/* sd__serviceData has binding name 'sd__serviceData' for type 'sd:serviceData' */
#ifndef SOAP_TYPE_sd__serviceData
#define SOAP_TYPE_sd__serviceData (404)
#endif

/* wsdl__operation has binding name 'wsdl__operation' for type 'wsdl:operation' */
#ifndef SOAP_TYPE_wsdl__operation
#define SOAP_TYPE_wsdl__operation (402)
#endif

/* whttp__header has binding name 'whttp__header' for type 'whttp:header' */
#ifndef SOAP_TYPE_whttp__header
#define SOAP_TYPE_whttp__header (401)
#endif

/* http__operation has binding name 'http__operation' for type 'http:operation' */
#ifndef SOAP_TYPE_http__operation
#define SOAP_TYPE_http__operation (400)
#endif

/* http__binding has binding name 'http__binding' for type 'http:binding' */
#ifndef SOAP_TYPE_http__binding
#define SOAP_TYPE_http__binding (399)
#endif

/* http__address has binding name 'http__address' for type 'http:address' */
#ifndef SOAP_TYPE_http__address
#define SOAP_TYPE_http__address (398)
#endif

/* dime__message has binding name 'dime__message' for type 'dime:message' */
#ifndef SOAP_TYPE_dime__message
#define SOAP_TYPE_dime__message (397)
#endif

/* mime__mimeXml has binding name 'mime__mimeXml' for type 'mime:mimeXml' */
#ifndef SOAP_TYPE_mime__mimeXml
#define SOAP_TYPE_mime__mimeXml (396)
#endif

/* mime__multipartRelated has binding name 'mime__multipartRelated' for type 'mime:multipartRelated' */
#ifndef SOAP_TYPE_mime__multipartRelated
#define SOAP_TYPE_mime__multipartRelated (393)
#endif

/* mime__part has binding name 'mime__part' for type 'mime:part' */
#ifndef SOAP_TYPE_mime__part
#define SOAP_TYPE_mime__part (388)
#endif

/* mime__content has binding name 'mime__content' for type 'mime:content' */
#ifndef SOAP_TYPE_mime__content
#define SOAP_TYPE_mime__content (387)
#endif

/* wsoap__header has binding name 'wsoap__header' for type 'wsoap:header' */
#ifndef SOAP_TYPE_wsoap__header
#define SOAP_TYPE_wsoap__header (382)
#endif

/* wsoap__module has binding name 'wsoap__module' for type 'wsoap:module' */
#ifndef SOAP_TYPE_wsoap__module
#define SOAP_TYPE_wsoap__module (381)
#endif

/* soap__address has binding name 'soap__address' for type 'soap:address' */
#ifndef SOAP_TYPE_soap__address
#define SOAP_TYPE_soap__address (380)
#endif

/* soap__header has binding name 'soap__header' for type 'soap:header' */
#ifndef SOAP_TYPE_soap__header
#define SOAP_TYPE_soap__header (373)
#endif

/* soap__headerfault has binding name 'soap__headerfault' for type 'soap:headerfault' */
#ifndef SOAP_TYPE_soap__headerfault
#define SOAP_TYPE_soap__headerfault (363)
#endif

/* soap__fault has binding name 'soap__fault' for type 'soap:fault' */
#ifndef SOAP_TYPE_soap__fault
#define SOAP_TYPE_soap__fault (362)
#endif

/* soap__body has binding name 'soap__body' for type 'soap:body' */
#ifndef SOAP_TYPE_soap__body
#define SOAP_TYPE_soap__body (361)
#endif

/* soap__operation has binding name 'soap__operation' for type 'soap:operation' */
#ifndef SOAP_TYPE_soap__operation
#define SOAP_TYPE_soap__operation (359)
#endif

/* soap__binding has binding name 'soap__binding' for type 'soap:binding' */
#ifndef SOAP_TYPE_soap__binding
#define SOAP_TYPE_soap__binding (357)
#endif

/* wsdl__part has binding name 'wsdl__part' for type 'wsdl:part' */
#ifndef SOAP_TYPE_wsdl__part
#define SOAP_TYPE_wsdl__part (355)
#endif

/* wsdl__message has binding name 'wsdl__message' for type 'wsdl:message' */
#ifndef SOAP_TYPE_wsdl__message
#define SOAP_TYPE_wsdl__message (354)
#endif

/* wadl__application has binding name 'wadl__application' for type 'wadl:application' */
#ifndef SOAP_TYPE_wadl__application
#define SOAP_TYPE_wadl__application (346)
#endif

/* wadl__resources has binding name 'wadl__resources' for type 'wadl:resources' */
#ifndef SOAP_TYPE_wadl__resources
#define SOAP_TYPE_wadl__resources (343)
#endif

/* wadl__method has binding name 'wadl__method' for type 'wadl:method' */
#ifndef SOAP_TYPE_wadl__method
#define SOAP_TYPE_wadl__method (323)
#endif

/* wadl__response has binding name 'wadl__response' for type 'wadl:response' */
#ifndef SOAP_TYPE_wadl__response
#define SOAP_TYPE_wadl__response (322)
#endif

/* wadl__request has binding name 'wadl__request' for type 'wadl:request' */
#ifndef SOAP_TYPE_wadl__request
#define SOAP_TYPE_wadl__request (318)
#endif

/* wadl__representation has binding name 'wadl__representation' for type 'wadl:representation' */
#ifndef SOAP_TYPE_wadl__representation
#define SOAP_TYPE_wadl__representation (307)
#endif

/* wadl__grammars has binding name 'wadl__grammars' for type 'wadl:grammars' */
#ifndef SOAP_TYPE_wadl__grammars
#define SOAP_TYPE_wadl__grammars (304)
#endif

/* wadl__include has binding name 'wadl__include' for type 'wadl:include' */
#ifndef SOAP_TYPE_wadl__include
#define SOAP_TYPE_wadl__include (302)
#endif

/* wadl__param has binding name 'wadl__param' for type 'wadl:param' */
#ifndef SOAP_TYPE_wadl__param
#define SOAP_TYPE_wadl__param (287)
#endif

/* wadl__link has binding name 'wadl__link' for type 'wadl:link' */
#ifndef SOAP_TYPE_wadl__link
#define SOAP_TYPE_wadl__link (279)
#endif

/* wadl__option has binding name 'wadl__option' for type 'wadl:option' */
#ifndef SOAP_TYPE_wadl__option
#define SOAP_TYPE_wadl__option (277)
#endif

/* wadl__doc has binding name 'wadl__doc' for type 'wadl:doc' */
#ifndef SOAP_TYPE_wadl__doc
#define SOAP_TYPE_wadl__doc (276)
#endif

/* wadl__resource_USCOREtype has binding name 'wadl__resource_USCOREtype' for type 'wadl:resource_type' */
#ifndef SOAP_TYPE_wadl__resource_USCOREtype
#define SOAP_TYPE_wadl__resource_USCOREtype (272)
#endif

/* wadl__resource has binding name 'wadl__resource' for type 'wadl:resource' */
#ifndef SOAP_TYPE_wadl__resource
#define SOAP_TYPE_wadl__resource (271)
#endif

/* xs__redefine has binding name 'xs__redefine' for type 'xs:redefine' */
#ifndef SOAP_TYPE_xs__redefine
#define SOAP_TYPE_xs__redefine (221)
#endif

/* xs__override has binding name 'xs__override' for type 'xs:override' */
#ifndef SOAP_TYPE_xs__override
#define SOAP_TYPE_xs__override (213)
#endif

/* xs__include has binding name 'xs__include' for type 'xs:include' */
#ifndef SOAP_TYPE_xs__include
#define SOAP_TYPE_xs__include (207)
#endif

/* xs__import has binding name 'xs__import' for type 'xs:import' */
#ifndef SOAP_TYPE_xs__import
#define SOAP_TYPE_xs__import (200)
#endif

/* xs__complexContent has binding name 'xs__complexContent' for type 'xs:complexContent' */
#ifndef SOAP_TYPE_xs__complexContent
#define SOAP_TYPE_xs__complexContent (184)
#endif

/* xs__whiteSpace has binding name 'xs__whiteSpace' for type 'xs:whiteSpace' */
#ifndef SOAP_TYPE_xs__whiteSpace
#define SOAP_TYPE_xs__whiteSpace (161)
#endif

/* xs__length has binding name 'xs__length' for type 'xs:length' */
#ifndef SOAP_TYPE_xs__length
#define SOAP_TYPE_xs__length (160)
#endif

/* xs__simpleContent has binding name 'xs__simpleContent' for type 'xs:simpleContent' */
#ifndef SOAP_TYPE_xs__simpleContent
#define SOAP_TYPE_xs__simpleContent (131)
#endif

/* xs__pattern has binding name 'xs__pattern' for type 'xs:pattern' */
#ifndef SOAP_TYPE_xs__pattern
#define SOAP_TYPE_xs__pattern (129)
#endif

/* xs__enumeration has binding name 'xs__enumeration' for type 'xs:enumeration' */
#ifndef SOAP_TYPE_xs__enumeration
#define SOAP_TYPE_xs__enumeration (127)
#endif

/* xs__attributeGroup has binding name 'xs__attributeGroup' for type 'xs:attributeGroup' */
#ifndef SOAP_TYPE_xs__attributeGroup
#define SOAP_TYPE_xs__attributeGroup (114)
#endif

/* xs__anyAttribute has binding name 'xs__anyAttribute' for type 'xs:anyAttribute' */
#ifndef SOAP_TYPE_xs__anyAttribute
#define SOAP_TYPE_xs__anyAttribute (113)
#endif

/* xs__contents has binding name 'xs__contents' for type 'xs:contents' */
#ifndef SOAP_TYPE_xs__contents
#define SOAP_TYPE_xs__contents (91)
#endif

/* xs__any has binding name 'xs__any' for type 'xs:any' */
#ifndef SOAP_TYPE_xs__any
#define SOAP_TYPE_xs__any (88)
#endif

/* xs__all has binding name 'xs__all' for type 'xs:all' */
#ifndef SOAP_TYPE_xs__all
#define SOAP_TYPE_xs__all (82)
#endif

/* xs__attribute has binding name 'xs__attribute' for type 'xs:attribute' */
#ifndef SOAP_TYPE_xs__attribute
#define SOAP_TYPE_xs__attribute (69)
#endif

/* xs__element has binding name 'xs__element' for type 'xs:element' */
#ifndef SOAP_TYPE_xs__element
#define SOAP_TYPE_xs__element (38)
#endif

/* xs__alternative has binding name 'xs__alternative' for type 'xs:alternative' */
#ifndef SOAP_TYPE_xs__alternative
#define SOAP_TYPE_xs__alternative (36)
#endif

/* xs__assert has binding name 'xs__assert' for type 'xs:assert' */
#ifndef SOAP_TYPE_xs__assert
#define SOAP_TYPE_xs__assert (34)
#endif

/* xs__annotation has binding name 'xs__annotation' for type 'xs:annotation' */
#ifndef SOAP_TYPE_xs__annotation
#define SOAP_TYPE_xs__annotation (32)
#endif

/* xs__union has binding name 'xs__union' for type 'xs:union' */
#ifndef SOAP_TYPE_xs__union
#define SOAP_TYPE_xs__union (31)
#endif

/* xs__list has binding name 'xs__list' for type 'xs:list' */
#ifndef SOAP_TYPE_xs__list
#define SOAP_TYPE_xs__list (30)
#endif

/* xs__group has binding name 'xs__group' for type 'xs:group' */
#ifndef SOAP_TYPE_xs__group
#define SOAP_TYPE_xs__group (29)
#endif

/* xs__seqchoice has binding name 'xs__seqchoice' for type 'xs:seqchoice' */
#ifndef SOAP_TYPE_xs__seqchoice
#define SOAP_TYPE_xs__seqchoice (28)
#endif

/* xs__restriction has binding name 'xs__restriction' for type 'xs:restriction' */
#ifndef SOAP_TYPE_xs__restriction
#define SOAP_TYPE_xs__restriction (27)
#endif

/* xs__extension has binding name 'xs__extension' for type 'xs:extension' */
#ifndef SOAP_TYPE_xs__extension
#define SOAP_TYPE_xs__extension (26)
#endif

/* xs__complexType has binding name 'xs__complexType' for type 'xs:complexType' */
#ifndef SOAP_TYPE_xs__complexType
#define SOAP_TYPE_xs__complexType (25)
#endif

/* xs__simpleType has binding name 'xs__simpleType' for type 'xs:simpleType' */
#ifndef SOAP_TYPE_xs__simpleType
#define SOAP_TYPE_xs__simpleType (24)
#endif

/* xs__schema has binding name 'xs__schema' for type 'xs:schema' */
#ifndef SOAP_TYPE_xs__schema
#define SOAP_TYPE_xs__schema (23)
#endif

/* wsdl__definitions has binding name 'wsdl__definitions' for type 'wsdl:definitions' */
#ifndef SOAP_TYPE_wsdl__definitions
#define SOAP_TYPE_wsdl__definitions (7)
#endif

/* struct SOAP_ENV__Fault has binding name 'SOAP_ENV__Fault' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (652)
#endif

/* struct SOAP_ENV__Reason has binding name 'SOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (651)
#endif

/* struct SOAP_ENV__Detail has binding name 'SOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (650)
#endif

/* struct SOAP_ENV__Code has binding name 'SOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (648)
#endif

/* struct SOAP_ENV__Header has binding name 'SOAP_ENV__Header' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (647)
#endif

/* struct SOAP_ENV__Reason * has binding name 'PointerToSOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Reason
#define SOAP_TYPE_PointerToSOAP_ENV__Reason (654)
#endif

/* struct SOAP_ENV__Detail * has binding name 'PointerToSOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Detail
#define SOAP_TYPE_PointerToSOAP_ENV__Detail (653)
#endif

/* struct SOAP_ENV__Code * has binding name 'PointerToSOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Code
#define SOAP_TYPE_PointerToSOAP_ENV__Code (649)
#endif

/* wadl__application * has binding name 'PointerTowadl__application' for type 'wadl:application' */
#ifndef SOAP_TYPE_PointerTowadl__application
#define SOAP_TYPE_PointerTowadl__application (608)
#endif

/* wsdl__types * has binding name 'PointerTowsdl__types' for type 'wsdl:types' */
#ifndef SOAP_TYPE_PointerTowsdl__types
#define SOAP_TYPE_PointerTowsdl__types (599)
#endif

/* wsdl__binding * has binding name 'PointerTowsdl__binding' for type 'wsdl:binding' */
#ifndef SOAP_TYPE_PointerTowsdl__binding
#define SOAP_TYPE_PointerTowsdl__binding (589)
#endif

/* http__address * has binding name 'PointerTohttp__address' for type 'http:address' */
#ifndef SOAP_TYPE_PointerTohttp__address
#define SOAP_TYPE_PointerTohttp__address (588)
#endif

/* soap__address * has binding name 'PointerTosoap__address' for type 'soap:address' */
#ifndef SOAP_TYPE_PointerTosoap__address
#define SOAP_TYPE_PointerTosoap__address (587)
#endif

/* char ** has binding name 'PointerToxsd__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_PointerToxsd__string
#define SOAP_TYPE_PointerToxsd__string (579)
#endif

/* http__binding * has binding name 'PointerTohttp__binding' for type 'http:binding' */
#ifndef SOAP_TYPE_PointerTohttp__binding
#define SOAP_TYPE_PointerTohttp__binding (578)
#endif

/* soap__binding * has binding name 'PointerTosoap__binding' for type 'soap:binding' */
#ifndef SOAP_TYPE_PointerTosoap__binding
#define SOAP_TYPE_PointerTosoap__binding (577)
#endif

/* wsdl__ext_ioput * has binding name 'PointerTowsdl__ext_ioput' for type 'wsdl:ext-ioput' */
#ifndef SOAP_TYPE_PointerTowsdl__ext_ioput
#define SOAP_TYPE_PointerTowsdl__ext_ioput (568)
#endif

/* http__operation * has binding name 'PointerTohttp__operation' for type 'http:operation' */
#ifndef SOAP_TYPE_PointerTohttp__operation
#define SOAP_TYPE_PointerTohttp__operation (567)
#endif

/* soap__operation * has binding name 'PointerTosoap__operation' for type 'soap:operation' */
#ifndef SOAP_TYPE_PointerTosoap__operation
#define SOAP_TYPE_PointerTosoap__operation (566)
#endif

/* wsdl__fault * has binding name 'PointerTowsdl__fault' for type 'wsdl:fault' */
#ifndef SOAP_TYPE_PointerTowsdl__fault
#define SOAP_TYPE_PointerTowsdl__fault (558)
#endif

/* soap__fault * has binding name 'PointerTosoap__fault' for type 'soap:fault' */
#ifndef SOAP_TYPE_PointerTosoap__fault
#define SOAP_TYPE_PointerTosoap__fault (557)
#endif

/* mime__mimeXml * has binding name 'PointerTomime__mimeXml' for type 'mime:mimeXml' */
#ifndef SOAP_TYPE_PointerTomime__mimeXml
#define SOAP_TYPE_PointerTomime__mimeXml (550)
#endif

/* mime__content * has binding name 'PointerTomime__content' for type 'mime:content' */
#ifndef SOAP_TYPE_PointerTomime__content
#define SOAP_TYPE_PointerTomime__content (549)
#endif

/* mime__multipartRelated * has binding name 'PointerTomime__multipartRelated' for type 'mime:multipartRelated' */
#ifndef SOAP_TYPE_PointerTomime__multipartRelated
#define SOAP_TYPE_PointerTomime__multipartRelated (548)
#endif

/* dime__message * has binding name 'PointerTodime__message' for type 'dime:message' */
#ifndef SOAP_TYPE_PointerTodime__message
#define SOAP_TYPE_PointerTodime__message (547)
#endif

/* wsdl__ioput * has binding name 'PointerTowsdl__ioput' for type 'wsdl:ioput' */
#ifndef SOAP_TYPE_PointerTowsdl__ioput
#define SOAP_TYPE_PointerTowsdl__ioput (536)
#endif

/* wsdl__definitions * has binding name 'PointerTowsdl__definitions' for type 'wsdl:definitions' */
#ifndef SOAP_TYPE_PointerTowsdl__definitions
#define SOAP_TYPE_PointerTowsdl__definitions (480)
#endif

/* vprop__tProperty * has binding name 'PointerTovprop__tProperty' for type 'vprop:tProperty' */
#ifndef SOAP_TYPE_PointerTovprop__tProperty
#define SOAP_TYPE_PointerTovprop__tProperty (476)
#endif

/* vprop__tQuery * has binding name 'PointerTovprop__tQuery' for type 'vprop:tQuery' */
#ifndef SOAP_TYPE_PointerTovprop__tQuery
#define SOAP_TYPE_PointerTovprop__tQuery (475)
#endif

/* plnk__tPartnerLinkType * has binding name 'PointerToplnk__tPartnerLinkType' for type 'plnk:tPartnerLinkType' */
#ifndef SOAP_TYPE_PointerToplnk__tPartnerLinkType
#define SOAP_TYPE_PointerToplnk__tPartnerLinkType (462)
#endif

/* wsdl__portType * has binding name 'PointerTowsdl__portType' for type 'wsdl:portType' */
#ifndef SOAP_TYPE_PointerTowsdl__portType
#define SOAP_TYPE_PointerTowsdl__portType (461)
#endif

/* wsp__AppliesTo * has binding name 'PointerTowsp__AppliesTo' for type 'wsp:AppliesTo' */
#ifndef SOAP_TYPE_PointerTowsp__AppliesTo
#define SOAP_TYPE_PointerTowsp__AppliesTo (456)
#endif

/* wsrmp5__RMAssertion * has binding name 'PointerTowsrmp5__RMAssertion' for type 'wsrmp5:RMAssertion' */
#ifndef SOAP_TYPE_PointerTowsrmp5__RMAssertion
#define SOAP_TYPE_PointerTowsrmp5__RMAssertion (447)
#endif

/* wsrmp__RMAssertion * has binding name 'PointerTowsrmp__RMAssertion' for type 'wsrmp:RMAssertion' */
#ifndef SOAP_TYPE_PointerTowsrmp__RMAssertion
#define SOAP_TYPE_PointerTowsrmp__RMAssertion (446)
#endif

/* wsp__Assertion * has binding name 'PointerTowsp__Assertion' for type 'wsp:Assertion' */
#ifndef SOAP_TYPE_PointerTowsp__Assertion
#define SOAP_TYPE_PointerTowsp__Assertion (445)
#endif

/* sp__Token * has binding name 'PointerTosp__Token' for type 'sp:Token' */
#ifndef SOAP_TYPE_PointerTosp__Token
#define SOAP_TYPE_PointerTosp__Token (444)
#endif

/* sp__Elements * has binding name 'PointerTosp__Elements' for type 'sp:Elements' */
#ifndef SOAP_TYPE_PointerTosp__Elements
#define SOAP_TYPE_PointerTosp__Elements (443)
#endif

/* wsp__PolicyReference * has binding name 'PointerTowsp__PolicyReference' for type 'wsp:PolicyReference' */
#ifndef SOAP_TYPE_PointerTowsp__PolicyReference
#define SOAP_TYPE_PointerTowsp__PolicyReference (440)
#endif

/* wsrmp5__Timeout * has binding name 'PointerTowsrmp5__Timeout' for type 'wsrmp5:Timeout' */
#ifndef SOAP_TYPE_PointerTowsrmp5__Timeout
#define SOAP_TYPE_PointerTowsrmp5__Timeout (439)
#endif

/* wsrmp__Timeout * has binding name 'PointerTowsrmp__Timeout' for type 'wsrmp:Timeout' */
#ifndef SOAP_TYPE_PointerTowsrmp__Timeout
#define SOAP_TYPE_PointerTowsrmp__Timeout (436)
#endif

/* wst__Claims * has binding name 'PointerTowst__Claims' for type 'wst:Claims' */
#ifndef SOAP_TYPE_PointerTowst__Claims
#define SOAP_TYPE_PointerTowst__Claims (433)
#endif

/* wsa__EndpointReferenceType * has binding name 'PointerTowsa__EndpointReferenceType' for type 'wsa:EndpointReferenceType' */
#ifndef SOAP_TYPE_PointerTowsa__EndpointReferenceType
#define SOAP_TYPE_PointerTowsa__EndpointReferenceType (432)
#endif

/* wsp__Content * has binding name 'PointerTowsp__Content' for type 'wsp:Content' */
#ifndef SOAP_TYPE_PointerTowsp__Content
#define SOAP_TYPE_PointerTowsp__Content (424)
#endif

/* wsp__Policy * has binding name 'PointerTowsp__Policy' for type 'wsp:Policy' */
#ifndef SOAP_TYPE_PointerTowsp__Policy
#define SOAP_TYPE_PointerTowsp__Policy (418)
#endif

/* sd__staticServiceDataValues * has binding name 'PointerTosd__staticServiceDataValues' for type 'sd:staticServiceDataValues' */
#ifndef SOAP_TYPE_PointerTosd__staticServiceDataValues
#define SOAP_TYPE_PointerTosd__staticServiceDataValues (411)
#endif

/* wsdl__operation * has binding name 'PointerTowsdl__operation' for type 'wsdl:operation' */
#ifndef SOAP_TYPE_PointerTowsdl__operation
#define SOAP_TYPE_PointerTowsdl__operation (408)
#endif

/* soap__body * has binding name 'PointerTosoap__body' for type 'soap:body' */
#ifndef SOAP_TYPE_PointerTosoap__body
#define SOAP_TYPE_PointerTosoap__body (389)
#endif

/* wsdl__part * has binding name 'PointerTowsdl__part' for type 'wsdl:part' */
#ifndef SOAP_TYPE_PointerTowsdl__part
#define SOAP_TYPE_PointerTowsdl__part (365)
#endif

/* wsdl__message * has binding name 'PointerTowsdl__message' for type 'wsdl:message' */
#ifndef SOAP_TYPE_PointerTowsdl__message
#define SOAP_TYPE_PointerTowsdl__message (364)
#endif

/* enum soap__styleChoice * has binding name 'PointerTosoap__styleChoice' for type 'soap:styleChoice' */
#ifndef SOAP_TYPE_PointerTosoap__styleChoice
#define SOAP_TYPE_PointerTosoap__styleChoice (358)
#endif

/* wadl__grammars * has binding name 'PointerTowadl__grammars' for type 'wadl:grammars' */
#ifndef SOAP_TYPE_PointerTowadl__grammars
#define SOAP_TYPE_PointerTowadl__grammars (347)
#endif

/* wadl__resource * has binding name 'PointerTowadl__resource' for type 'wadl:resource' */
#ifndef SOAP_TYPE_PointerTowadl__resource
#define SOAP_TYPE_PointerTowadl__resource (334)
#endif

/* wadl__method * has binding name 'PointerTowadl__method' for type 'wadl:method' */
#ifndef SOAP_TYPE_PointerTowadl__method
#define SOAP_TYPE_PointerTowadl__method (326)
#endif

/* wadl__request * has binding name 'PointerTowadl__request' for type 'wadl:request' */
#ifndef SOAP_TYPE_PointerTowadl__request
#define SOAP_TYPE_PointerTowadl__request (324)
#endif

/* wadl__representation * has binding name 'PointerTowadl__representation' for type 'wadl:representation' */
#ifndef SOAP_TYPE_PointerTowadl__representation
#define SOAP_TYPE_PointerTowadl__representation (309)
#endif

/* wadl__param * has binding name 'PointerTowadl__param' for type 'wadl:param' */
#ifndef SOAP_TYPE_PointerTowadl__param
#define SOAP_TYPE_PointerTowadl__param (291)
#endif

/* wadl__link * has binding name 'PointerTowadl__link' for type 'wadl:link' */
#ifndef SOAP_TYPE_PointerTowadl__link
#define SOAP_TYPE_PointerTowadl__link (290)
#endif

/* enum wadl__ParamStyle * has binding name 'PointerTowadl__ParamStyle' for type 'wadl:ParamStyle' */
#ifndef SOAP_TYPE_PointerTowadl__ParamStyle
#define SOAP_TYPE_PointerTowadl__ParamStyle (288)
#endif

/* wadl__resource_USCOREtype * has binding name 'PointerTowadl__resource_USCOREtype' for type 'wadl:resource_type' */
#ifndef SOAP_TYPE_PointerTowadl__resource_USCOREtype
#define SOAP_TYPE_PointerTowadl__resource_USCOREtype (280)
#endif

/* wadl__statusCodeList has binding name 'wadl__statusCodeList' for type 'wadl:statusCodeList' */
#ifndef SOAP_TYPE_wadl__statusCodeList
#define SOAP_TYPE_wadl__statusCodeList (273)
#endif

/* xs__complexContent * has binding name 'PointerToxs__complexContent' for type 'xs:complexContent' */
#ifndef SOAP_TYPE_PointerToxs__complexContent
#define SOAP_TYPE_PointerToxs__complexContent (188)
#endif

/* xs__simpleContent * has binding name 'PointerToxs__simpleContent' for type 'xs:simpleContent' */
#ifndef SOAP_TYPE_PointerToxs__simpleContent
#define SOAP_TYPE_PointerToxs__simpleContent (187)
#endif

/* xs__assert * has binding name 'PointerToxs__assert' for type 'xs:assert' */
#ifndef SOAP_TYPE_PointerToxs__assert
#define SOAP_TYPE_PointerToxs__assert (166)
#endif

/* xs__length * has binding name 'PointerToxs__length' for type 'xs:length' */
#ifndef SOAP_TYPE_PointerToxs__length
#define SOAP_TYPE_PointerToxs__length (165)
#endif

/* xs__whiteSpace * has binding name 'PointerToxs__whiteSpace' for type 'xs:whiteSpace' */
#ifndef SOAP_TYPE_PointerToxs__whiteSpace
#define SOAP_TYPE_PointerToxs__whiteSpace (164)
#endif

/* xs__union * has binding name 'PointerToxs__union' for type 'xs:union' */
#ifndef SOAP_TYPE_PointerToxs__union
#define SOAP_TYPE_PointerToxs__union (137)
#endif

/* xs__list * has binding name 'PointerToxs__list' for type 'xs:list' */
#ifndef SOAP_TYPE_PointerToxs__list
#define SOAP_TYPE_PointerToxs__list (136)
#endif

/* xs__restriction * has binding name 'PointerToxs__restriction' for type 'xs:restriction' */
#ifndef SOAP_TYPE_PointerToxs__restriction
#define SOAP_TYPE_PointerToxs__restriction (133)
#endif

/* xs__extension * has binding name 'PointerToxs__extension' for type 'xs:extension' */
#ifndef SOAP_TYPE_PointerToxs__extension
#define SOAP_TYPE_PointerToxs__extension (132)
#endif

/* xs__attributeGroup * has binding name 'PointerToxs__attributeGroup' for type 'xs:attributeGroup' */
#ifndef SOAP_TYPE_PointerToxs__attributeGroup
#define SOAP_TYPE_PointerToxs__attributeGroup (118)
#endif

/* xs__anyAttribute * has binding name 'PointerToxs__anyAttribute' for type 'xs:anyAttribute' */
#ifndef SOAP_TYPE_PointerToxs__anyAttribute
#define SOAP_TYPE_PointerToxs__anyAttribute (117)
#endif

/* xs__all * has binding name 'PointerToxs__all' for type 'xs:all' */
#ifndef SOAP_TYPE_PointerToxs__all
#define SOAP_TYPE_PointerToxs__all (104)
#endif

/* xs__any * has binding name 'PointerToxs__any' for type 'xs:any' */
#ifndef SOAP_TYPE_PointerToxs__any
#define SOAP_TYPE_PointerToxs__any (95)
#endif

/* xs__seqchoice * has binding name 'PointerToxs__seqchoice' for type 'xs:seqchoice' */
#ifndef SOAP_TYPE_PointerToxs__seqchoice
#define SOAP_TYPE_PointerToxs__seqchoice (94)
#endif

/* xs__group * has binding name 'PointerToxs__group' for type 'xs:group' */
#ifndef SOAP_TYPE_PointerToxs__group
#define SOAP_TYPE_PointerToxs__group (93)
#endif

/* xs__namespaceList has binding name 'xs__namespaceList' for type 'xs:namespaceList' */
#ifndef SOAP_TYPE_xs__namespaceList
#define SOAP_TYPE_xs__namespaceList (87)
#endif

/* xs__attribute * has binding name 'PointerToxs__attribute' for type 'xs:attribute' */
#ifndef SOAP_TYPE_PointerToxs__attribute
#define SOAP_TYPE_PointerToxs__attribute (70)
#endif

/* std::vector<xs__element *> * has binding name 'PointerTostd__vectorTemplateOfPointerToxs__element' for type 'xs:element' */
#ifndef SOAP_TYPE_PointerTostd__vectorTemplateOfPointerToxs__element
#define SOAP_TYPE_PointerTostd__vectorTemplateOfPointerToxs__element (64)
#endif

/* xs__element * has binding name 'PointerToxs__element' for type 'xs:element' */
#ifndef SOAP_TYPE_PointerToxs__element
#define SOAP_TYPE_PointerToxs__element (44)
#endif

/* xs__schema * has binding name 'PointerToxs__schema' for type 'xs:schema' */
#ifndef SOAP_TYPE_PointerToxs__schema
#define SOAP_TYPE_PointerToxs__schema (43)
#endif

/* xs__complexType * has binding name 'PointerToxs__complexType' for type 'xs:complexType' */
#ifndef SOAP_TYPE_PointerToxs__complexType
#define SOAP_TYPE_PointerToxs__complexType (41)
#endif

/* xs__simpleType * has binding name 'PointerToxs__simpleType' for type 'xs:simpleType' */
#ifndef SOAP_TYPE_PointerToxs__simpleType
#define SOAP_TYPE_PointerToxs__simpleType (40)
#endif

/* enum xs__formChoice * has binding name 'PointerToxs__formChoice' for type 'xs:formChoice' */
#ifndef SOAP_TYPE_PointerToxs__formChoice
#define SOAP_TYPE_PointerToxs__formChoice (39)
#endif

/* xs__annotation * has binding name 'PointerToxs__annotation' for type 'xs:annotation' */
#ifndef SOAP_TYPE_PointerToxs__annotation
#define SOAP_TYPE_PointerToxs__annotation (35)
#endif

/* xsd__string has binding name 'xsd__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_xsd__string
#define SOAP_TYPE_xsd__string (16)
#endif

/* xsd__token has binding name 'xsd__token' for type 'xsd:token' */
#ifndef SOAP_TYPE_xsd__token
#define SOAP_TYPE_xsd__token (15)
#endif

/* xsd__QName has binding name 'xsd__QName' for type 'xsd:QName' */
#ifndef SOAP_TYPE_xsd__QName
#define SOAP_TYPE_xsd__QName (14)
#endif

/* xsd__NMTOKENS has binding name 'xsd__NMTOKENS' for type 'xsd:NMTOKENS' */
#ifndef SOAP_TYPE_xsd__NMTOKENS
#define SOAP_TYPE_xsd__NMTOKENS (13)
#endif

/* xsd__NMTOKEN has binding name 'xsd__NMTOKEN' for type 'xsd:NMTOKEN' */
#ifndef SOAP_TYPE_xsd__NMTOKEN
#define SOAP_TYPE_xsd__NMTOKEN (12)
#endif

/* xsd__NCName has binding name 'xsd__NCName' for type 'xsd:NCName' */
#ifndef SOAP_TYPE_xsd__NCName
#define SOAP_TYPE_xsd__NCName (11)
#endif

/* xsd__ID has binding name 'xsd__ID' for type 'xsd:ID' */
#ifndef SOAP_TYPE_xsd__ID
#define SOAP_TYPE_xsd__ID (10)
#endif

/* xsd__anyURI has binding name 'xsd__anyURI' for type 'xsd:anyURI' */
#ifndef SOAP_TYPE_xsd__anyURI
#define SOAP_TYPE_xsd__anyURI (9)
#endif

/* _QName has binding name '_QName' for type 'xsd:QName' */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (6)
#endif

/* _XML has binding name '_XML' for type '' */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (5)
#endif

/* char * has binding name 'string' for type 'xsd:string' */
#ifndef SOAP_TYPE_string
#define SOAP_TYPE_string (4)
#endif

/* std::vector<gwsdl__portType>  has binding name 'std__vectorTemplateOfgwsdl__portType' for type 'gwsdl:portType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfgwsdl__portType
#define SOAP_TYPE_std__vectorTemplateOfgwsdl__portType (607)
#endif

/* std::vector<vprop__tPropertyAlias>  has binding name 'std__vectorTemplateOfvprop__tPropertyAlias' for type 'vprop:tPropertyAlias' */
#ifndef SOAP_TYPE_std__vectorTemplateOfvprop__tPropertyAlias
#define SOAP_TYPE_std__vectorTemplateOfvprop__tPropertyAlias (606)
#endif

/* std::vector<vprop__tProperty>  has binding name 'std__vectorTemplateOfvprop__tProperty' for type 'vprop:tProperty' */
#ifndef SOAP_TYPE_std__vectorTemplateOfvprop__tProperty
#define SOAP_TYPE_std__vectorTemplateOfvprop__tProperty (605)
#endif

/* std::vector<plnk__tPartnerLinkType>  has binding name 'std__vectorTemplateOfplnk__tPartnerLinkType' for type 'plnk:tPartnerLinkType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfplnk__tPartnerLinkType
#define SOAP_TYPE_std__vectorTemplateOfplnk__tPartnerLinkType (604)
#endif

/* std::vector<wsdl__service>  has binding name 'std__vectorTemplateOfwsdl__service' for type 'wsdl:service' */
#ifndef SOAP_TYPE_std__vectorTemplateOfwsdl__service
#define SOAP_TYPE_std__vectorTemplateOfwsdl__service (603)
#endif

/* std::vector<wsdl__binding>  has binding name 'std__vectorTemplateOfwsdl__binding' for type 'wsdl:binding' */
#ifndef SOAP_TYPE_std__vectorTemplateOfwsdl__binding
#define SOAP_TYPE_std__vectorTemplateOfwsdl__binding (602)
#endif

/* std::vector<wsdl__portType>  has binding name 'std__vectorTemplateOfwsdl__portType' for type 'wsdl:portType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfwsdl__portType
#define SOAP_TYPE_std__vectorTemplateOfwsdl__portType (601)
#endif

/* std::vector<wsdl__message>  has binding name 'std__vectorTemplateOfwsdl__message' for type 'wsdl:message' */
#ifndef SOAP_TYPE_std__vectorTemplateOfwsdl__message
#define SOAP_TYPE_std__vectorTemplateOfwsdl__message (600)
#endif

/* std::vector<wsdl__import>  has binding name 'std__vectorTemplateOfwsdl__import' for type 'wsdl:import' */
#ifndef SOAP_TYPE_std__vectorTemplateOfwsdl__import
#define SOAP_TYPE_std__vectorTemplateOfwsdl__import (598)
#endif

/* std::vector<wsdl__port>  has binding name 'std__vectorTemplateOfwsdl__port' for type 'wsdl:port' */
#ifndef SOAP_TYPE_std__vectorTemplateOfwsdl__port
#define SOAP_TYPE_std__vectorTemplateOfwsdl__port (596)
#endif

/* std::vector<wsdl__ext_operation>  has binding name 'std__vectorTemplateOfwsdl__ext_operation' for type 'wsdl:ext-operation' */
#ifndef SOAP_TYPE_std__vectorTemplateOfwsdl__ext_operation
#define SOAP_TYPE_std__vectorTemplateOfwsdl__ext_operation (580)
#endif

/* std::vector<wsdl__ext_fault>  has binding name 'std__vectorTemplateOfwsdl__ext_fault' for type 'wsdl:ext-fault' */
#ifndef SOAP_TYPE_std__vectorTemplateOfwsdl__ext_fault
#define SOAP_TYPE_std__vectorTemplateOfwsdl__ext_fault (569)
#endif

/* std::vector<whttp__header>  has binding name 'std__vectorTemplateOfwhttp__header' for type 'whttp:header' */
#ifndef SOAP_TYPE_std__vectorTemplateOfwhttp__header
#define SOAP_TYPE_std__vectorTemplateOfwhttp__header (553)
#endif

/* std::vector<wsoap__header>  has binding name 'std__vectorTemplateOfwsoap__header' for type 'wsoap:header' */
#ifndef SOAP_TYPE_std__vectorTemplateOfwsoap__header
#define SOAP_TYPE_std__vectorTemplateOfwsoap__header (552)
#endif

/* std::vector<wsoap__module>  has binding name 'std__vectorTemplateOfwsoap__module' for type 'wsoap:module' */
#ifndef SOAP_TYPE_std__vectorTemplateOfwsoap__module
#define SOAP_TYPE_std__vectorTemplateOfwsoap__module (551)
#endif

/* std::vector<wsdl__operation>  has binding name 'std__vectorTemplateOfwsdl__operation' for type 'wsdl:operation' */
#ifndef SOAP_TYPE_std__vectorTemplateOfwsdl__operation
#define SOAP_TYPE_std__vectorTemplateOfwsdl__operation (540)
#endif

/* std::vector<wsdl__fault>  has binding name 'std__vectorTemplateOfwsdl__fault' for type 'wsdl:fault' */
#ifndef SOAP_TYPE_std__vectorTemplateOfwsdl__fault
#define SOAP_TYPE_std__vectorTemplateOfwsdl__fault (537)
#endif

/* std::vector<wsdl__part>  has binding name 'std__vectorTemplateOfwsdl__part' for type 'wsdl:part' */
#ifndef SOAP_TYPE_std__vectorTemplateOfwsdl__part
#define SOAP_TYPE_std__vectorTemplateOfwsdl__part (516)
#endif

/* std::vector<wsp__PolicyReference>  has binding name 'std__vectorTemplateOfwsp__PolicyReference' for type 'wsp:PolicyReference' */
#ifndef SOAP_TYPE_std__vectorTemplateOfwsp__PolicyReference
#define SOAP_TYPE_std__vectorTemplateOfwsp__PolicyReference (515)
#endif

/* std::vector<wsp__Policy>  has binding name 'std__vectorTemplateOfwsp__Policy' for type 'wsp:Policy' */
#ifndef SOAP_TYPE_std__vectorTemplateOfwsp__Policy
#define SOAP_TYPE_std__vectorTemplateOfwsp__Policy (514)
#endif

/* std::vector<xs__schema *>  has binding name 'std__vectorTemplateOfPointerToxs__schema' for type 'xs:schema' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerToxs__schema
#define SOAP_TYPE_std__vectorTemplateOfPointerToxs__schema (489)
#endif

/* std::vector<plnk__tRole>  has binding name 'std__vectorTemplateOfplnk__tRole' for type 'plnk:tRole' */
#ifndef SOAP_TYPE_std__vectorTemplateOfplnk__tRole
#define SOAP_TYPE_std__vectorTemplateOfplnk__tRole (469)
#endif

/* std::vector<wsp__Attachment>  has binding name 'std__vectorTemplateOfwsp__Attachment' for type 'wsp:Attachment' */
#ifndef SOAP_TYPE_std__vectorTemplateOfwsp__Attachment
#define SOAP_TYPE_std__vectorTemplateOfwsp__Attachment (457)
#endif

/* std::vector<char *>  has binding name 'std__vectorTemplateOf_XML' for type '' */
#ifndef SOAP_TYPE_std__vectorTemplateOf_XML
#define SOAP_TYPE_std__vectorTemplateOf_XML (448)
#endif

/* std::vector<sp__Parts>  has binding name 'std__vectorTemplateOfsp__Parts' for type 'sp:Parts' */
#ifndef SOAP_TYPE_std__vectorTemplateOfsp__Parts
#define SOAP_TYPE_std__vectorTemplateOfsp__Parts (442)
#endif

/* std::vector<wsp__Content *>  has binding name 'std__vectorTemplateOfPointerTowsp__Content' for type 'wsp:Content' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTowsp__Content
#define SOAP_TYPE_std__vectorTemplateOfPointerTowsp__Content (441)
#endif

/* std::vector<char *>  has binding name 'std__vectorTemplateOfxsd__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_std__vectorTemplateOfxsd__string
#define SOAP_TYPE_std__vectorTemplateOfxsd__string (430)
#endif

/* std::vector<sp__Header>  has binding name 'std__vectorTemplateOfsp__Header' for type 'sp:Header' */
#ifndef SOAP_TYPE_std__vectorTemplateOfsp__Header
#define SOAP_TYPE_std__vectorTemplateOfsp__Header (428)
#endif

/* std::vector<sd__serviceData>  has binding name 'std__vectorTemplateOfsd__serviceData' for type 'sd:serviceData' */
#ifndef SOAP_TYPE_std__vectorTemplateOfsd__serviceData
#define SOAP_TYPE_std__vectorTemplateOfsd__serviceData (410)
#endif

/* std::vector<wsdl__operation *>  has binding name 'std__vectorTemplateOfPointerTowsdl__operation' for type 'wsdl:operation' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTowsdl__operation
#define SOAP_TYPE_std__vectorTemplateOfPointerTowsdl__operation (409)
#endif

/* std::vector<mime__part>  has binding name 'std__vectorTemplateOfmime__part' for type 'mime:part' */
#ifndef SOAP_TYPE_std__vectorTemplateOfmime__part
#define SOAP_TYPE_std__vectorTemplateOfmime__part (394)
#endif

/* std::vector<mime__content>  has binding name 'std__vectorTemplateOfmime__content' for type 'mime:content' */
#ifndef SOAP_TYPE_std__vectorTemplateOfmime__content
#define SOAP_TYPE_std__vectorTemplateOfmime__content (391)
#endif

/* std::vector<soap__header>  has binding name 'std__vectorTemplateOfsoap__header' for type 'soap:header' */
#ifndef SOAP_TYPE_std__vectorTemplateOfsoap__header
#define SOAP_TYPE_std__vectorTemplateOfsoap__header (390)
#endif

/* std::vector<soap__headerfault>  has binding name 'std__vectorTemplateOfsoap__headerfault' for type 'soap:headerfault' */
#ifndef SOAP_TYPE_std__vectorTemplateOfsoap__headerfault
#define SOAP_TYPE_std__vectorTemplateOfsoap__headerfault (374)
#endif

/* std::vector<wadl__method>  has binding name 'std__vectorTemplateOfwadl__method' for type 'wadl:method' */
#ifndef SOAP_TYPE_std__vectorTemplateOfwadl__method
#define SOAP_TYPE_std__vectorTemplateOfwadl__method (350)
#endif

/* std::vector<wadl__resource_USCOREtype>  has binding name 'std__vectorTemplateOfwadl__resource_USCOREtype' for type 'wadl:resource_type' */
#ifndef SOAP_TYPE_std__vectorTemplateOfwadl__resource_USCOREtype
#define SOAP_TYPE_std__vectorTemplateOfwadl__resource_USCOREtype (349)
#endif

/* std::vector<wadl__resources>  has binding name 'std__vectorTemplateOfwadl__resources' for type 'wadl:resources' */
#ifndef SOAP_TYPE_std__vectorTemplateOfwadl__resources
#define SOAP_TYPE_std__vectorTemplateOfwadl__resources (348)
#endif

/* std::vector<wadl__resource>  has binding name 'std__vectorTemplateOfwadl__resource' for type 'wadl:resource' */
#ifndef SOAP_TYPE_std__vectorTemplateOfwadl__resource
#define SOAP_TYPE_std__vectorTemplateOfwadl__resource (344)
#endif

/* std::vector<wadl__resource_USCOREtype *>  has binding name 'std__vectorTemplateOfPointerTowadl__resource_USCOREtype' for type 'wadl:resource_type' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTowadl__resource_USCOREtype
#define SOAP_TYPE_std__vectorTemplateOfPointerTowadl__resource_USCOREtype (338)
#endif

/* std::vector<__wadl__method_resource_choice>  has binding name 'std__vectorTemplateOf__wadl__method_resource_choice' for type '-wadl:method-resource-choice' */
#ifndef SOAP_TYPE_std__vectorTemplateOf__wadl__method_resource_choice
#define SOAP_TYPE_std__vectorTemplateOf__wadl__method_resource_choice (336)
#endif

/* std::vector<wadl__response>  has binding name 'std__vectorTemplateOfwadl__response' for type 'wadl:response' */
#ifndef SOAP_TYPE_std__vectorTemplateOfwadl__response
#define SOAP_TYPE_std__vectorTemplateOfwadl__response (325)
#endif

/* std::vector<wadl__representation>  has binding name 'std__vectorTemplateOfwadl__representation' for type 'wadl:representation' */
#ifndef SOAP_TYPE_std__vectorTemplateOfwadl__representation
#define SOAP_TYPE_std__vectorTemplateOfwadl__representation (319)
#endif

/* std::vector<wadl__param>  has binding name 'std__vectorTemplateOfwadl__param' for type 'wadl:param' */
#ifndef SOAP_TYPE_std__vectorTemplateOfwadl__param
#define SOAP_TYPE_std__vectorTemplateOfwadl__param (308)
#endif

/* std::vector<wadl__include>  has binding name 'std__vectorTemplateOfwadl__include' for type 'wadl:include' */
#ifndef SOAP_TYPE_std__vectorTemplateOfwadl__include
#define SOAP_TYPE_std__vectorTemplateOfwadl__include (305)
#endif

/* std::vector<wadl__option>  has binding name 'std__vectorTemplateOfwadl__option' for type 'wadl:option' */
#ifndef SOAP_TYPE_std__vectorTemplateOfwadl__option
#define SOAP_TYPE_std__vectorTemplateOfwadl__option (289)
#endif

/* std::vector<wadl__doc>  has binding name 'std__vectorTemplateOfwadl__doc' for type 'wadl:doc' */
#ifndef SOAP_TYPE_std__vectorTemplateOfwadl__doc
#define SOAP_TYPE_std__vectorTemplateOfwadl__doc (278)
#endif

/* std::vector<xs__import>  has binding name 'std__vectorTemplateOfxs__import' for type 'xs:import' */
#ifndef SOAP_TYPE_std__vectorTemplateOfxs__import
#define SOAP_TYPE_std__vectorTemplateOfxs__import (230)
#endif

/* std::vector<xs__redefine>  has binding name 'std__vectorTemplateOfxs__redefine' for type 'xs:redefine' */
#ifndef SOAP_TYPE_std__vectorTemplateOfxs__redefine
#define SOAP_TYPE_std__vectorTemplateOfxs__redefine (229)
#endif

/* std::vector<xs__override>  has binding name 'std__vectorTemplateOfxs__override' for type 'xs:override' */
#ifndef SOAP_TYPE_std__vectorTemplateOfxs__override
#define SOAP_TYPE_std__vectorTemplateOfxs__override (228)
#endif

/* std::vector<xs__include>  has binding name 'std__vectorTemplateOfxs__include' for type 'xs:include' */
#ifndef SOAP_TYPE_std__vectorTemplateOfxs__include
#define SOAP_TYPE_std__vectorTemplateOfxs__include (227)
#endif

/* std::vector<xs__complexType>  has binding name 'std__vectorTemplateOfxs__complexType' for type 'xs:complexType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfxs__complexType
#define SOAP_TYPE_std__vectorTemplateOfxs__complexType (215)
#endif

/* std::vector<xs__group>  has binding name 'std__vectorTemplateOfxs__group' for type 'xs:group' */
#ifndef SOAP_TYPE_std__vectorTemplateOfxs__group
#define SOAP_TYPE_std__vectorTemplateOfxs__group (214)
#endif

/* std::vector<xs__simpleType>  has binding name 'std__vectorTemplateOfxs__simpleType' for type 'xs:simpleType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfxs__simpleType
#define SOAP_TYPE_std__vectorTemplateOfxs__simpleType (176)
#endif

/* std::vector<xs__pattern>  has binding name 'std__vectorTemplateOfxs__pattern' for type 'xs:pattern' */
#ifndef SOAP_TYPE_std__vectorTemplateOfxs__pattern
#define SOAP_TYPE_std__vectorTemplateOfxs__pattern (163)
#endif

/* std::vector<xs__enumeration>  has binding name 'std__vectorTemplateOfxs__enumeration' for type 'xs:enumeration' */
#ifndef SOAP_TYPE_std__vectorTemplateOfxs__enumeration
#define SOAP_TYPE_std__vectorTemplateOfxs__enumeration (162)
#endif

/* std::vector<xs__assert>  has binding name 'std__vectorTemplateOfxs__assert' for type 'xs:assert' */
#ifndef SOAP_TYPE_std__vectorTemplateOfxs__assert
#define SOAP_TYPE_std__vectorTemplateOfxs__assert (152)
#endif

/* std::vector<char *>  has binding name 'std__vectorTemplateOfxsd__QName' for type 'xsd:QName' */
#ifndef SOAP_TYPE_std__vectorTemplateOfxsd__QName
#define SOAP_TYPE_std__vectorTemplateOfxsd__QName (139)
#endif

/* std::vector<xs__complexType *>  has binding name 'std__vectorTemplateOfPointerToxs__complexType' for type 'xs:complexType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerToxs__complexType
#define SOAP_TYPE_std__vectorTemplateOfPointerToxs__complexType (138)
#endif

/* std::vector<xs__attributeGroup>  has binding name 'std__vectorTemplateOfxs__attributeGroup' for type 'xs:attributeGroup' */
#ifndef SOAP_TYPE_std__vectorTemplateOfxs__attributeGroup
#define SOAP_TYPE_std__vectorTemplateOfxs__attributeGroup (116)
#endif

/* std::vector<xs__attribute>  has binding name 'std__vectorTemplateOfxs__attribute' for type 'xs:attribute' */
#ifndef SOAP_TYPE_std__vectorTemplateOfxs__attribute
#define SOAP_TYPE_std__vectorTemplateOfxs__attribute (115)
#endif

/* std::vector<xs__contents>  has binding name 'std__vectorTemplateOfxs__contents' for type 'xs:contents' */
#ifndef SOAP_TYPE_std__vectorTemplateOfxs__contents
#define SOAP_TYPE_std__vectorTemplateOfxs__contents (98)
#endif

/* std::vector<xs__element>  has binding name 'std__vectorTemplateOfxs__element' for type 'xs:element' */
#ifndef SOAP_TYPE_std__vectorTemplateOfxs__element
#define SOAP_TYPE_std__vectorTemplateOfxs__element (83)
#endif

/* std::vector<xs__element *>  has binding name 'std__vectorTemplateOfPointerToxs__element' for type 'xs:element' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerToxs__element
#define SOAP_TYPE_std__vectorTemplateOfPointerToxs__element (45)
#endif

/* std::vector<xs__alternative>  has binding name 'std__vectorTemplateOfxs__alternative' for type 'xs:alternative' */
#ifndef SOAP_TYPE_std__vectorTemplateOfxs__alternative
#define SOAP_TYPE_std__vectorTemplateOfxs__alternative (42)
#endif

/* std::vector<char *>  has binding name 'std__vectorTemplateOfstring' for type 'xsd:string' */
#ifndef SOAP_TYPE_std__vectorTemplateOfstring
#define SOAP_TYPE_std__vectorTemplateOfstring (33)
#endif

/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


/* ../../gsoap/wsdl/wsdl.h:430 */
extern std::ostream &operator<<(std::ostream &o, const wsdl__definitions &e);

/* ../../gsoap/wsdl/wsdl.h:431 */
extern std::istream &operator>>(std::istream &i, wsdl__definitions &e);

#endif

/* End of wsdlStub.h */
