/* wsdlH.h
   Generated by gSOAP 2.8.101 for ../../gsoap/wsdl/wsdl.h

gSOAP XML Web services tools
Copyright (C) 2000-2020, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#ifndef wsdlH_H
#define wsdlH_H
#include "wsdlStub.h"
#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap*, const void*, int);

#ifdef __cplusplus
}
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap*);
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap*);
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap*, const char*, int*);
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap*, const void*, const char*, int, int);
SOAP_FMAC3 void * SOAP_FMAC4 soap_dupelement(struct soap*, const void*, int);
SOAP_FMAC3 void SOAP_FMAC4 soap_delelement(const void*, int);

#ifdef __cplusplus
}
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap*);
SOAP_FMAC3 void * SOAP_FMAC4 wsdl_instantiate(struct soap*, int, const char*, const char*, size_t*);
SOAP_FMAC3 int SOAP_FMAC4 wsdl_fdelete(struct soap *soap, struct soap_clist*);
SOAP_FMAC3 int SOAP_FMAC4 wsdl_fbase(int, int);
SOAP_FMAC3 void SOAP_FMAC4 wsdl_finsert(struct soap*, int, int, void*, size_t, const void*, void**);

#ifndef SOAP_TYPE_byte_DEFINED
#define SOAP_TYPE_byte_DEFINED

inline void soap_default_byte(struct soap *soap, char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap*, const char*, int, const char *, const char*);
SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap*, const char*, char *, const char*);

SOAP_FMAC3 char * SOAP_FMAC4 soap_new_byte(struct soap *soap, int n = -1);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap*, const char *, const char*, const char*);

inline int soap_write_byte(struct soap *soap, char const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || ::soap_put_byte(soap, p, "byte", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_byte(struct soap *soap, const char *URL, char const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_byte(soap, p, "byte", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_byte(struct soap *soap, const char *URL, char const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_byte(soap, p, "byte", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_byte(struct soap *soap, const char *URL, char const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_byte(soap, p, "byte", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap*, char *, const char*, const char*);

inline int soap_read_byte(struct soap *soap, char *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || ::soap_get_byte(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_byte(struct soap *soap, const char *URL, char *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_byte(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_byte(struct soap *soap, char *p)
{
	if (::soap_read_byte(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_int_DEFINED
#define SOAP_TYPE_int_DEFINED

inline void soap_default_int(struct soap *soap, int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap*, const char*, int, const int *, const char*);
SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap*, const char*, int *, const char*);

SOAP_FMAC3 int * SOAP_FMAC4 soap_new_int(struct soap *soap, int n = -1);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap*, const int *, const char*, const char*);

inline int soap_write_int(struct soap *soap, int const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || ::soap_put_int(soap, p, "int", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_int(struct soap *soap, const char *URL, int const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_int(soap, p, "int", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_int(struct soap *soap, const char *URL, int const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_int(soap, p, "int", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_int(struct soap *soap, const char *URL, int const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_int(soap, p, "int", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap*, int *, const char*, const char*);

inline int soap_read_int(struct soap *soap, int *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || ::soap_get_int(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_int(struct soap *soap, const char *URL, int *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_int(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_int(struct soap *soap, int *p)
{
	if (::soap_read_int(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_sd__mutability_DEFINED
#define SOAP_TYPE_sd__mutability_DEFINED

inline void soap_default_sd__mutability(struct soap *soap, enum sd__mutability *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_sd__mutability
	*a = SOAP_DEFAULT_sd__mutability;
#else
	*a = (enum sd__mutability)0;
#endif
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_sd__mutability(struct soap*, const char*, int, const enum sd__mutability *, const char*);
SOAP_FMAC3S const char* SOAP_FMAC4S soap_sd__mutability2s(struct soap*, enum sd__mutability);
SOAP_FMAC3 enum sd__mutability * SOAP_FMAC4 soap_in_sd__mutability(struct soap*, const char*, enum sd__mutability *, const char*);
SOAP_FMAC3S int SOAP_FMAC4S soap_s2sd__mutability(struct soap*, const char*, enum sd__mutability *);

SOAP_FMAC3 enum sd__mutability * SOAP_FMAC4 soap_new_sd__mutability(struct soap *soap, int n = -1);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_sd__mutability(struct soap*, const enum sd__mutability *, const char*, const char*);

inline int soap_write_sd__mutability(struct soap *soap, enum sd__mutability const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || ::soap_put_sd__mutability(soap, p, "sd:mutability", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_sd__mutability(struct soap *soap, const char *URL, enum sd__mutability const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_sd__mutability(soap, p, "sd:mutability", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_sd__mutability(struct soap *soap, const char *URL, enum sd__mutability const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_sd__mutability(soap, p, "sd:mutability", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_sd__mutability(struct soap *soap, const char *URL, enum sd__mutability const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_sd__mutability(soap, p, "sd:mutability", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 enum sd__mutability * SOAP_FMAC4 soap_get_sd__mutability(struct soap*, enum sd__mutability *, const char*, const char*);

inline int soap_read_sd__mutability(struct soap *soap, enum sd__mutability *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || ::soap_get_sd__mutability(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_sd__mutability(struct soap *soap, const char *URL, enum sd__mutability *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_sd__mutability(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_sd__mutability(struct soap *soap, enum sd__mutability *p)
{
	if (::soap_read_sd__mutability(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_soap__useChoice_DEFINED
#define SOAP_TYPE_soap__useChoice_DEFINED

inline void soap_default_soap__useChoice(struct soap *soap, enum soap__useChoice *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_soap__useChoice
	*a = SOAP_DEFAULT_soap__useChoice;
#else
	*a = (enum soap__useChoice)0;
#endif
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_soap__useChoice(struct soap*, const char*, int, const enum soap__useChoice *, const char*);
SOAP_FMAC3S const char* SOAP_FMAC4S soap_soap__useChoice2s(struct soap*, enum soap__useChoice);
SOAP_FMAC3 enum soap__useChoice * SOAP_FMAC4 soap_in_soap__useChoice(struct soap*, const char*, enum soap__useChoice *, const char*);
SOAP_FMAC3S int SOAP_FMAC4S soap_s2soap__useChoice(struct soap*, const char*, enum soap__useChoice *);

SOAP_FMAC3 enum soap__useChoice * SOAP_FMAC4 soap_new_soap__useChoice(struct soap *soap, int n = -1);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_soap__useChoice(struct soap*, const enum soap__useChoice *, const char*, const char*);

inline int soap_write_soap__useChoice(struct soap *soap, enum soap__useChoice const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || ::soap_put_soap__useChoice(soap, p, "soap:useChoice", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_soap__useChoice(struct soap *soap, const char *URL, enum soap__useChoice const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_soap__useChoice(soap, p, "soap:useChoice", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_soap__useChoice(struct soap *soap, const char *URL, enum soap__useChoice const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_soap__useChoice(soap, p, "soap:useChoice", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_soap__useChoice(struct soap *soap, const char *URL, enum soap__useChoice const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_soap__useChoice(soap, p, "soap:useChoice", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 enum soap__useChoice * SOAP_FMAC4 soap_get_soap__useChoice(struct soap*, enum soap__useChoice *, const char*, const char*);

inline int soap_read_soap__useChoice(struct soap *soap, enum soap__useChoice *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || ::soap_get_soap__useChoice(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_soap__useChoice(struct soap *soap, const char *URL, enum soap__useChoice *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_soap__useChoice(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_soap__useChoice(struct soap *soap, enum soap__useChoice *p)
{
	if (::soap_read_soap__useChoice(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_soap__styleChoice_DEFINED
#define SOAP_TYPE_soap__styleChoice_DEFINED

inline void soap_default_soap__styleChoice(struct soap *soap, enum soap__styleChoice *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_soap__styleChoice
	*a = SOAP_DEFAULT_soap__styleChoice;
#else
	*a = (enum soap__styleChoice)0;
#endif
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_soap__styleChoice(struct soap*, const char*, int, const enum soap__styleChoice *, const char*);
SOAP_FMAC3S const char* SOAP_FMAC4S soap_soap__styleChoice2s(struct soap*, enum soap__styleChoice);
SOAP_FMAC3 enum soap__styleChoice * SOAP_FMAC4 soap_in_soap__styleChoice(struct soap*, const char*, enum soap__styleChoice *, const char*);
SOAP_FMAC3S int SOAP_FMAC4S soap_s2soap__styleChoice(struct soap*, const char*, enum soap__styleChoice *);

SOAP_FMAC3 enum soap__styleChoice * SOAP_FMAC4 soap_new_soap__styleChoice(struct soap *soap, int n = -1);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_soap__styleChoice(struct soap*, const enum soap__styleChoice *, const char*, const char*);

inline int soap_write_soap__styleChoice(struct soap *soap, enum soap__styleChoice const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || ::soap_put_soap__styleChoice(soap, p, "soap:styleChoice", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_soap__styleChoice(struct soap *soap, const char *URL, enum soap__styleChoice const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_soap__styleChoice(soap, p, "soap:styleChoice", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_soap__styleChoice(struct soap *soap, const char *URL, enum soap__styleChoice const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_soap__styleChoice(soap, p, "soap:styleChoice", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_soap__styleChoice(struct soap *soap, const char *URL, enum soap__styleChoice const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_soap__styleChoice(soap, p, "soap:styleChoice", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 enum soap__styleChoice * SOAP_FMAC4 soap_get_soap__styleChoice(struct soap*, enum soap__styleChoice *, const char*, const char*);

inline int soap_read_soap__styleChoice(struct soap *soap, enum soap__styleChoice *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || ::soap_get_soap__styleChoice(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_soap__styleChoice(struct soap *soap, const char *URL, enum soap__styleChoice *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_soap__styleChoice(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_soap__styleChoice(struct soap *soap, enum soap__styleChoice *p)
{
	if (::soap_read_soap__styleChoice(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_wadl__ParamStyle_DEFINED
#define SOAP_TYPE_wadl__ParamStyle_DEFINED

inline void soap_default_wadl__ParamStyle(struct soap *soap, enum wadl__ParamStyle *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_wadl__ParamStyle
	*a = SOAP_DEFAULT_wadl__ParamStyle;
#else
	*a = (enum wadl__ParamStyle)0;
#endif
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_wadl__ParamStyle(struct soap*, const char*, int, const enum wadl__ParamStyle *, const char*);
SOAP_FMAC3S const char* SOAP_FMAC4S soap_wadl__ParamStyle2s(struct soap*, enum wadl__ParamStyle);
SOAP_FMAC3 enum wadl__ParamStyle * SOAP_FMAC4 soap_in_wadl__ParamStyle(struct soap*, const char*, enum wadl__ParamStyle *, const char*);
SOAP_FMAC3S int SOAP_FMAC4S soap_s2wadl__ParamStyle(struct soap*, const char*, enum wadl__ParamStyle *);

SOAP_FMAC3 enum wadl__ParamStyle * SOAP_FMAC4 soap_new_wadl__ParamStyle(struct soap *soap, int n = -1);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_wadl__ParamStyle(struct soap*, const enum wadl__ParamStyle *, const char*, const char*);

inline int soap_write_wadl__ParamStyle(struct soap *soap, enum wadl__ParamStyle const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || ::soap_put_wadl__ParamStyle(soap, p, "wadl:ParamStyle", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_wadl__ParamStyle(struct soap *soap, const char *URL, enum wadl__ParamStyle const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_wadl__ParamStyle(soap, p, "wadl:ParamStyle", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_wadl__ParamStyle(struct soap *soap, const char *URL, enum wadl__ParamStyle const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_wadl__ParamStyle(soap, p, "wadl:ParamStyle", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_wadl__ParamStyle(struct soap *soap, const char *URL, enum wadl__ParamStyle const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_wadl__ParamStyle(soap, p, "wadl:ParamStyle", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 enum wadl__ParamStyle * SOAP_FMAC4 soap_get_wadl__ParamStyle(struct soap*, enum wadl__ParamStyle *, const char*, const char*);

inline int soap_read_wadl__ParamStyle(struct soap *soap, enum wadl__ParamStyle *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || ::soap_get_wadl__ParamStyle(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_wadl__ParamStyle(struct soap *soap, const char *URL, enum wadl__ParamStyle *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_wadl__ParamStyle(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_wadl__ParamStyle(struct soap *soap, enum wadl__ParamStyle *p)
{
	if (::soap_read_wadl__ParamStyle(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_wadl__HTTPMethods_DEFINED
#define SOAP_TYPE_wadl__HTTPMethods_DEFINED

inline void soap_default_wadl__HTTPMethods(struct soap *soap, enum wadl__HTTPMethods *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_wadl__HTTPMethods
	*a = SOAP_DEFAULT_wadl__HTTPMethods;
#else
	*a = (enum wadl__HTTPMethods)0;
#endif
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_wadl__HTTPMethods(struct soap*, const char*, int, const enum wadl__HTTPMethods *, const char*);
SOAP_FMAC3S const char* SOAP_FMAC4S soap_wadl__HTTPMethods2s(struct soap*, enum wadl__HTTPMethods);
SOAP_FMAC3 enum wadl__HTTPMethods * SOAP_FMAC4 soap_in_wadl__HTTPMethods(struct soap*, const char*, enum wadl__HTTPMethods *, const char*);
SOAP_FMAC3S int SOAP_FMAC4S soap_s2wadl__HTTPMethods(struct soap*, const char*, enum wadl__HTTPMethods *);

SOAP_FMAC3 enum wadl__HTTPMethods * SOAP_FMAC4 soap_new_wadl__HTTPMethods(struct soap *soap, int n = -1);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_wadl__HTTPMethods(struct soap*, const enum wadl__HTTPMethods *, const char*, const char*);

inline int soap_write_wadl__HTTPMethods(struct soap *soap, enum wadl__HTTPMethods const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || ::soap_put_wadl__HTTPMethods(soap, p, "wadl:HTTPMethods", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_wadl__HTTPMethods(struct soap *soap, const char *URL, enum wadl__HTTPMethods const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_wadl__HTTPMethods(soap, p, "wadl:HTTPMethods", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_wadl__HTTPMethods(struct soap *soap, const char *URL, enum wadl__HTTPMethods const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_wadl__HTTPMethods(soap, p, "wadl:HTTPMethods", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_wadl__HTTPMethods(struct soap *soap, const char *URL, enum wadl__HTTPMethods const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_wadl__HTTPMethods(soap, p, "wadl:HTTPMethods", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 enum wadl__HTTPMethods * SOAP_FMAC4 soap_get_wadl__HTTPMethods(struct soap*, enum wadl__HTTPMethods *, const char*, const char*);

inline int soap_read_wadl__HTTPMethods(struct soap *soap, enum wadl__HTTPMethods *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || ::soap_get_wadl__HTTPMethods(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_wadl__HTTPMethods(struct soap *soap, const char *URL, enum wadl__HTTPMethods *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_wadl__HTTPMethods(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_wadl__HTTPMethods(struct soap *soap, enum wadl__HTTPMethods *p)
{
	if (::soap_read_wadl__HTTPMethods(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_xs__processContents_DEFINED
#define SOAP_TYPE_xs__processContents_DEFINED

inline void soap_default_xs__processContents(struct soap *soap, enum xs__processContents *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_xs__processContents
	*a = SOAP_DEFAULT_xs__processContents;
#else
	*a = (enum xs__processContents)0;
#endif
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xs__processContents(struct soap*, const char*, int, const enum xs__processContents *, const char*);
SOAP_FMAC3S const char* SOAP_FMAC4S soap_xs__processContents2s(struct soap*, enum xs__processContents);
SOAP_FMAC3 enum xs__processContents * SOAP_FMAC4 soap_in_xs__processContents(struct soap*, const char*, enum xs__processContents *, const char*);
SOAP_FMAC3S int SOAP_FMAC4S soap_s2xs__processContents(struct soap*, const char*, enum xs__processContents *);

SOAP_FMAC3 enum xs__processContents * SOAP_FMAC4 soap_new_xs__processContents(struct soap *soap, int n = -1);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_xs__processContents(struct soap*, const enum xs__processContents *, const char*, const char*);

inline int soap_write_xs__processContents(struct soap *soap, enum xs__processContents const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || ::soap_put_xs__processContents(soap, p, "xs:processContents", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_xs__processContents(struct soap *soap, const char *URL, enum xs__processContents const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_xs__processContents(soap, p, "xs:processContents", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_xs__processContents(struct soap *soap, const char *URL, enum xs__processContents const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_xs__processContents(soap, p, "xs:processContents", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_xs__processContents(struct soap *soap, const char *URL, enum xs__processContents const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_xs__processContents(soap, p, "xs:processContents", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 enum xs__processContents * SOAP_FMAC4 soap_get_xs__processContents(struct soap*, enum xs__processContents *, const char*, const char*);

inline int soap_read_xs__processContents(struct soap *soap, enum xs__processContents *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || ::soap_get_xs__processContents(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_xs__processContents(struct soap *soap, const char *URL, enum xs__processContents *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_xs__processContents(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_xs__processContents(struct soap *soap, enum xs__processContents *p)
{
	if (::soap_read_xs__processContents(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_xs__attribute_use_DEFINED
#define SOAP_TYPE_xs__attribute_use_DEFINED

inline void soap_default_xs__attribute_use(struct soap *soap, enum xs__attribute_use *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_xs__attribute_use
	*a = SOAP_DEFAULT_xs__attribute_use;
#else
	*a = (enum xs__attribute_use)0;
#endif
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xs__attribute_use(struct soap*, const char*, int, const enum xs__attribute_use *, const char*);
SOAP_FMAC3S const char* SOAP_FMAC4S soap_xs__attribute_use2s(struct soap*, enum xs__attribute_use);
SOAP_FMAC3 enum xs__attribute_use * SOAP_FMAC4 soap_in_xs__attribute_use(struct soap*, const char*, enum xs__attribute_use *, const char*);
SOAP_FMAC3S int SOAP_FMAC4S soap_s2xs__attribute_use(struct soap*, const char*, enum xs__attribute_use *);

SOAP_FMAC3 enum xs__attribute_use * SOAP_FMAC4 soap_new_xs__attribute_use(struct soap *soap, int n = -1);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_xs__attribute_use(struct soap*, const enum xs__attribute_use *, const char*, const char*);

inline int soap_write_xs__attribute_use(struct soap *soap, enum xs__attribute_use const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || ::soap_put_xs__attribute_use(soap, p, "xs:attribute-use", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_xs__attribute_use(struct soap *soap, const char *URL, enum xs__attribute_use const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_xs__attribute_use(soap, p, "xs:attribute-use", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_xs__attribute_use(struct soap *soap, const char *URL, enum xs__attribute_use const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_xs__attribute_use(soap, p, "xs:attribute-use", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_xs__attribute_use(struct soap *soap, const char *URL, enum xs__attribute_use const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_xs__attribute_use(soap, p, "xs:attribute-use", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 enum xs__attribute_use * SOAP_FMAC4 soap_get_xs__attribute_use(struct soap*, enum xs__attribute_use *, const char*, const char*);

inline int soap_read_xs__attribute_use(struct soap *soap, enum xs__attribute_use *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || ::soap_get_xs__attribute_use(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_xs__attribute_use(struct soap *soap, const char *URL, enum xs__attribute_use *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_xs__attribute_use(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_xs__attribute_use(struct soap *soap, enum xs__attribute_use *p)
{
	if (::soap_read_xs__attribute_use(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_xs__formChoice_DEFINED
#define SOAP_TYPE_xs__formChoice_DEFINED

inline void soap_default_xs__formChoice(struct soap *soap, enum xs__formChoice *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_xs__formChoice
	*a = SOAP_DEFAULT_xs__formChoice;
#else
	*a = (enum xs__formChoice)0;
#endif
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xs__formChoice(struct soap*, const char*, int, const enum xs__formChoice *, const char*);
SOAP_FMAC3S const char* SOAP_FMAC4S soap_xs__formChoice2s(struct soap*, enum xs__formChoice);
SOAP_FMAC3 enum xs__formChoice * SOAP_FMAC4 soap_in_xs__formChoice(struct soap*, const char*, enum xs__formChoice *, const char*);
SOAP_FMAC3S int SOAP_FMAC4S soap_s2xs__formChoice(struct soap*, const char*, enum xs__formChoice *);

SOAP_FMAC3 enum xs__formChoice * SOAP_FMAC4 soap_new_xs__formChoice(struct soap *soap, int n = -1);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_xs__formChoice(struct soap*, const enum xs__formChoice *, const char*, const char*);

inline int soap_write_xs__formChoice(struct soap *soap, enum xs__formChoice const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || ::soap_put_xs__formChoice(soap, p, "xs:formChoice", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_xs__formChoice(struct soap *soap, const char *URL, enum xs__formChoice const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_xs__formChoice(soap, p, "xs:formChoice", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_xs__formChoice(struct soap *soap, const char *URL, enum xs__formChoice const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_xs__formChoice(soap, p, "xs:formChoice", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_xs__formChoice(struct soap *soap, const char *URL, enum xs__formChoice const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_xs__formChoice(soap, p, "xs:formChoice", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 enum xs__formChoice * SOAP_FMAC4 soap_get_xs__formChoice(struct soap*, enum xs__formChoice *, const char*, const char*);

inline int soap_read_xs__formChoice(struct soap *soap, enum xs__formChoice *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || ::soap_get_xs__formChoice(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_xs__formChoice(struct soap *soap, const char *URL, enum xs__formChoice *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_xs__formChoice(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_xs__formChoice(struct soap *soap, enum xs__formChoice *p)
{
	if (::soap_read_xs__formChoice(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_xsd__boolean_DEFINED
#define SOAP_TYPE_xsd__boolean_DEFINED

inline void soap_default_xsd__boolean(struct soap *soap, bool *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_xsd__boolean
	*a = SOAP_DEFAULT_xsd__boolean;
#else
	*a = (bool)0;
#endif
}

#define soap_xsd__boolean2s soap_bool2s

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__boolean(struct soap*, const char*, int, const bool *, const char*);

#define soap_s2xsd__boolean soap_s2bool

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_xsd__boolean(struct soap*, const char*, bool *, const char*);

#define wsdl_instantiate_xsd__boolean wsdl_instantiate_bool


#define soap_new_xsd__boolean soap_new_bool

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__boolean(struct soap*, const bool *, const char*, const char*);

inline int soap_write_xsd__boolean(struct soap *soap, bool const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || ::soap_put_xsd__boolean(soap, p, "xsd:boolean", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_xsd__boolean(struct soap *soap, const char *URL, bool const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_xsd__boolean(soap, p, "xsd:boolean", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_xsd__boolean(struct soap *soap, const char *URL, bool const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_xsd__boolean(soap, p, "xsd:boolean", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_xsd__boolean(struct soap *soap, const char *URL, bool const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_xsd__boolean(soap, p, "xsd:boolean", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_xsd__boolean(struct soap*, bool *, const char*, const char*);

inline int soap_read_xsd__boolean(struct soap *soap, bool *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || ::soap_get_xsd__boolean(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_xsd__boolean(struct soap *soap, const char *URL, bool *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_xsd__boolean(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_xsd__boolean(struct soap *soap, bool *p)
{
	if (::soap_read_xsd__boolean(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_bool_DEFINED
#define SOAP_TYPE_bool_DEFINED

inline void soap_default_bool(struct soap *soap, bool *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_bool
	*a = SOAP_DEFAULT_bool;
#else
	*a = (bool)0;
#endif
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap*, const char*, int, const bool *, const char*);
SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap*, bool);
SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap*, const char*, bool *, const char*);
SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap*, const char*, bool *);

SOAP_FMAC3 bool * SOAP_FMAC4 soap_new_bool(struct soap *soap, int n = -1);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap*, const bool *, const char*, const char*);

inline int soap_write_bool(struct soap *soap, bool const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || ::soap_put_bool(soap, p, "boolean", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_bool(struct soap *soap, const char *URL, bool const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_bool(soap, p, "boolean", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_bool(struct soap *soap, const char *URL, bool const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_bool(soap, p, "boolean", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_bool(struct soap *soap, const char *URL, bool const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_bool(soap, p, "boolean", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap*, bool *, const char*, const char*);

inline int soap_read_bool(struct soap *soap, bool *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || ::soap_get_bool(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_bool(struct soap *soap, const char *URL, bool *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_bool(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_bool(struct soap *soap, bool *p)
{
	if (::soap_read_bool(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_wsdl__service_DEFINED
#define SOAP_TYPE_wsdl__service_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdl__service(struct soap*, const char*, int, const wsdl__service *, const char*);
SOAP_FMAC3 wsdl__service * SOAP_FMAC4 soap_in_wsdl__service(struct soap*, const char*, wsdl__service *, const char*);
SOAP_FMAC1 wsdl__service * SOAP_FMAC2 wsdl_instantiate_wsdl__service(struct soap*, int, const char*, const char*, size_t*);

inline wsdl__service * soap_new_wsdl__service(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_wsdl__service(soap, n, NULL, NULL, NULL);
}

inline wsdl__service * soap_new_req_wsdl__service(
	struct soap *soap)
{
	wsdl__service *_p = ::soap_new_wsdl__service(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline wsdl__service * soap_new_set_wsdl__service(
	struct soap *soap,
	char *name,
	char *interface_,
	char *documentation,
	const std::vector<wsp__Policy> & wsp__Policy_,
	const std::vector<wsp__PolicyReference> & wsp__PolicyReference_,
	const std::vector<wsdl__port> & port,
	const std::vector<wsdl__port> & endpoint)
{
	wsdl__service *_p = ::soap_new_wsdl__service(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wsdl__service::name = name;
		_p->wsdl__service::interface_ = interface_;
		_p->wsdl__service::documentation = documentation;
		_p->wsdl__service::wsp__Policy_ = wsp__Policy_;
		_p->wsdl__service::wsp__PolicyReference_ = wsp__PolicyReference_;
		_p->wsdl__service::port = port;
		_p->wsdl__service::endpoint = endpoint;
	}
	return _p;
}

inline int soap_write_wsdl__service(struct soap *soap, wsdl__service const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsdl:service", p->soap_type() == SOAP_TYPE_wsdl__service ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_wsdl__service(struct soap *soap, const char *URL, wsdl__service const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsdl:service", p->soap_type() == SOAP_TYPE_wsdl__service ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_wsdl__service(struct soap *soap, const char *URL, wsdl__service const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsdl:service", p->soap_type() == SOAP_TYPE_wsdl__service ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_wsdl__service(struct soap *soap, const char *URL, wsdl__service const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsdl:service", p->soap_type() == SOAP_TYPE_wsdl__service ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 wsdl__service * SOAP_FMAC4 soap_get_wsdl__service(struct soap*, wsdl__service *, const char*, const char*);

inline int soap_read_wsdl__service(struct soap *soap, wsdl__service *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_wsdl__service(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_wsdl__service(struct soap *soap, const char *URL, wsdl__service *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_wsdl__service(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_wsdl__service(struct soap *soap, wsdl__service *p)
{
	if (::soap_read_wsdl__service(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_wsdl__port_DEFINED
#define SOAP_TYPE_wsdl__port_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdl__port(struct soap*, const char*, int, const wsdl__port *, const char*);
SOAP_FMAC3 wsdl__port * SOAP_FMAC4 soap_in_wsdl__port(struct soap*, const char*, wsdl__port *, const char*);
SOAP_FMAC1 wsdl__port * SOAP_FMAC2 wsdl_instantiate_wsdl__port(struct soap*, int, const char*, const char*, size_t*);

inline wsdl__port * soap_new_wsdl__port(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_wsdl__port(soap, n, NULL, NULL, NULL);
}

inline wsdl__port * soap_new_req_wsdl__port(
	struct soap *soap)
{
	wsdl__port *_p = ::soap_new_wsdl__port(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline wsdl__port * soap_new_set_wsdl__port(
	struct soap *soap,
	char *name,
	char *binding,
	char *address,
	char *whttp__authenticationScheme,
	char *whttp__authenticationRealm,
	char *documentation,
	wsp__Policy *wsp__Policy_,
	wsp__PolicyReference *wsp__PolicyReference_,
	wsa__EndpointReferenceType *wsa__EndpointReference,
	char **wsaw__UsingAddressing,
	soap__address *soap__address_,
	http__address *http__address_)
{
	wsdl__port *_p = ::soap_new_wsdl__port(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wsdl__port::name = name;
		_p->wsdl__port::binding = binding;
		_p->wsdl__port::address = address;
		_p->wsdl__port::whttp__authenticationScheme = whttp__authenticationScheme;
		_p->wsdl__port::whttp__authenticationRealm = whttp__authenticationRealm;
		_p->wsdl__port::documentation = documentation;
		_p->wsdl__port::wsp__Policy_ = wsp__Policy_;
		_p->wsdl__port::wsp__PolicyReference_ = wsp__PolicyReference_;
		_p->wsdl__port::wsa__EndpointReference = wsa__EndpointReference;
		_p->wsdl__port::wsaw__UsingAddressing = wsaw__UsingAddressing;
		_p->wsdl__port::soap__address_ = soap__address_;
		_p->wsdl__port::http__address_ = http__address_;
	}
	return _p;
}

inline int soap_write_wsdl__port(struct soap *soap, wsdl__port const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsdl:port", p->soap_type() == SOAP_TYPE_wsdl__port ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_wsdl__port(struct soap *soap, const char *URL, wsdl__port const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsdl:port", p->soap_type() == SOAP_TYPE_wsdl__port ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_wsdl__port(struct soap *soap, const char *URL, wsdl__port const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsdl:port", p->soap_type() == SOAP_TYPE_wsdl__port ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_wsdl__port(struct soap *soap, const char *URL, wsdl__port const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsdl:port", p->soap_type() == SOAP_TYPE_wsdl__port ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 wsdl__port * SOAP_FMAC4 soap_get_wsdl__port(struct soap*, wsdl__port *, const char*, const char*);

inline int soap_read_wsdl__port(struct soap *soap, wsdl__port *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_wsdl__port(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_wsdl__port(struct soap *soap, const char *URL, wsdl__port *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_wsdl__port(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_wsdl__port(struct soap *soap, wsdl__port *p)
{
	if (::soap_read_wsdl__port(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_wsdl__binding_DEFINED
#define SOAP_TYPE_wsdl__binding_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdl__binding(struct soap*, const char*, int, const wsdl__binding *, const char*);
SOAP_FMAC3 wsdl__binding * SOAP_FMAC4 soap_in_wsdl__binding(struct soap*, const char*, wsdl__binding *, const char*);
SOAP_FMAC1 wsdl__binding * SOAP_FMAC2 wsdl_instantiate_wsdl__binding(struct soap*, int, const char*, const char*, size_t*);

inline wsdl__binding * soap_new_wsdl__binding(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_wsdl__binding(soap, n, NULL, NULL, NULL);
}

inline wsdl__binding * soap_new_req_wsdl__binding(
	struct soap *soap)
{
	wsdl__binding *_p = ::soap_new_wsdl__binding(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline wsdl__binding * soap_new_set_wsdl__binding(
	struct soap *soap,
	char *name,
	char *type,
	char *type_,
	char *interface_,
	bool whttp__cookies,
	char *wsoap__version,
	char *wsoap__protocol,
	char *wsoap__mepDefault,
	char *whttp__methodDefault,
	char *documentation,
	const std::vector<wsp__Policy> & wsp__Policy_,
	const std::vector<wsp__PolicyReference> & wsp__PolicyReference_,
	soap__binding *soap__binding_,
	http__binding *http__binding_,
	char **wsaw__UsingAddressing,
	const std::vector<wsoap__module> & wsoap__module_,
	const std::vector<wsdl__ext_fault> & fault,
	const std::vector<wsdl__ext_operation> & operation)
{
	wsdl__binding *_p = ::soap_new_wsdl__binding(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wsdl__binding::name = name;
		_p->wsdl__binding::type = type;
		_p->wsdl__binding::type_ = type_;
		_p->wsdl__binding::interface_ = interface_;
		_p->wsdl__binding::whttp__cookies = whttp__cookies;
		_p->wsdl__binding::wsoap__version = wsoap__version;
		_p->wsdl__binding::wsoap__protocol = wsoap__protocol;
		_p->wsdl__binding::wsoap__mepDefault = wsoap__mepDefault;
		_p->wsdl__binding::whttp__methodDefault = whttp__methodDefault;
		_p->wsdl__binding::documentation = documentation;
		_p->wsdl__binding::wsp__Policy_ = wsp__Policy_;
		_p->wsdl__binding::wsp__PolicyReference_ = wsp__PolicyReference_;
		_p->wsdl__binding::soap__binding_ = soap__binding_;
		_p->wsdl__binding::http__binding_ = http__binding_;
		_p->wsdl__binding::wsaw__UsingAddressing = wsaw__UsingAddressing;
		_p->wsdl__binding::wsoap__module_ = wsoap__module_;
		_p->wsdl__binding::fault = fault;
		_p->wsdl__binding::operation = operation;
	}
	return _p;
}

inline int soap_write_wsdl__binding(struct soap *soap, wsdl__binding const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsdl:binding", p->soap_type() == SOAP_TYPE_wsdl__binding ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_wsdl__binding(struct soap *soap, const char *URL, wsdl__binding const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsdl:binding", p->soap_type() == SOAP_TYPE_wsdl__binding ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_wsdl__binding(struct soap *soap, const char *URL, wsdl__binding const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsdl:binding", p->soap_type() == SOAP_TYPE_wsdl__binding ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_wsdl__binding(struct soap *soap, const char *URL, wsdl__binding const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsdl:binding", p->soap_type() == SOAP_TYPE_wsdl__binding ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 wsdl__binding * SOAP_FMAC4 soap_get_wsdl__binding(struct soap*, wsdl__binding *, const char*, const char*);

inline int soap_read_wsdl__binding(struct soap *soap, wsdl__binding *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_wsdl__binding(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_wsdl__binding(struct soap *soap, const char *URL, wsdl__binding *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_wsdl__binding(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_wsdl__binding(struct soap *soap, wsdl__binding *p)
{
	if (::soap_read_wsdl__binding(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_wsdl__ext_operation_DEFINED
#define SOAP_TYPE_wsdl__ext_operation_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdl__ext_operation(struct soap*, const char*, int, const wsdl__ext_operation *, const char*);
SOAP_FMAC3 wsdl__ext_operation * SOAP_FMAC4 soap_in_wsdl__ext_operation(struct soap*, const char*, wsdl__ext_operation *, const char*);
SOAP_FMAC1 wsdl__ext_operation * SOAP_FMAC2 wsdl_instantiate_wsdl__ext_operation(struct soap*, int, const char*, const char*, size_t*);

inline wsdl__ext_operation * soap_new_wsdl__ext_operation(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_wsdl__ext_operation(soap, n, NULL, NULL, NULL);
}

inline wsdl__ext_operation * soap_new_req_wsdl__ext_operation(
	struct soap *soap)
{
	wsdl__ext_operation *_p = ::soap_new_wsdl__ext_operation(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline wsdl__ext_operation * soap_new_set_wsdl__ext_operation(
	struct soap *soap,
	char *name,
	char *ref,
	char *wsoap__mep,
	char *wsoap__action,
	char *whttp__method,
	char *whttp__location,
	char *documentation,
	wsp__Policy *wsp__Policy_,
	wsp__PolicyReference *wsp__PolicyReference_,
	soap__operation *soap__operation_,
	http__operation *http__operation_,
	wsdl__ext_ioput *input,
	wsdl__ext_ioput *output,
	const std::vector<wsdl__ext_fault> & fault,
	const std::vector<wsdl__ext_fault> & infault,
	const std::vector<wsdl__ext_fault> & outfault)
{
	wsdl__ext_operation *_p = ::soap_new_wsdl__ext_operation(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wsdl__ext_operation::name = name;
		_p->wsdl__ext_operation::ref = ref;
		_p->wsdl__ext_operation::wsoap__mep = wsoap__mep;
		_p->wsdl__ext_operation::wsoap__action = wsoap__action;
		_p->wsdl__ext_operation::whttp__method = whttp__method;
		_p->wsdl__ext_operation::whttp__location = whttp__location;
		_p->wsdl__ext_operation::documentation = documentation;
		_p->wsdl__ext_operation::wsp__Policy_ = wsp__Policy_;
		_p->wsdl__ext_operation::wsp__PolicyReference_ = wsp__PolicyReference_;
		_p->wsdl__ext_operation::soap__operation_ = soap__operation_;
		_p->wsdl__ext_operation::http__operation_ = http__operation_;
		_p->wsdl__ext_operation::input = input;
		_p->wsdl__ext_operation::output = output;
		_p->wsdl__ext_operation::fault = fault;
		_p->wsdl__ext_operation::infault = infault;
		_p->wsdl__ext_operation::outfault = outfault;
	}
	return _p;
}

inline int soap_write_wsdl__ext_operation(struct soap *soap, wsdl__ext_operation const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsdl:ext-operation", p->soap_type() == SOAP_TYPE_wsdl__ext_operation ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_wsdl__ext_operation(struct soap *soap, const char *URL, wsdl__ext_operation const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsdl:ext-operation", p->soap_type() == SOAP_TYPE_wsdl__ext_operation ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_wsdl__ext_operation(struct soap *soap, const char *URL, wsdl__ext_operation const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsdl:ext-operation", p->soap_type() == SOAP_TYPE_wsdl__ext_operation ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_wsdl__ext_operation(struct soap *soap, const char *URL, wsdl__ext_operation const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsdl:ext-operation", p->soap_type() == SOAP_TYPE_wsdl__ext_operation ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 wsdl__ext_operation * SOAP_FMAC4 soap_get_wsdl__ext_operation(struct soap*, wsdl__ext_operation *, const char*, const char*);

inline int soap_read_wsdl__ext_operation(struct soap *soap, wsdl__ext_operation *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_wsdl__ext_operation(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_wsdl__ext_operation(struct soap *soap, const char *URL, wsdl__ext_operation *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_wsdl__ext_operation(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_wsdl__ext_operation(struct soap *soap, wsdl__ext_operation *p)
{
	if (::soap_read_wsdl__ext_operation(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_wsdl__ext_fault_DEFINED
#define SOAP_TYPE_wsdl__ext_fault_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdl__ext_fault(struct soap*, const char*, int, const wsdl__ext_fault *, const char*);
SOAP_FMAC3 wsdl__ext_fault * SOAP_FMAC4 soap_in_wsdl__ext_fault(struct soap*, const char*, wsdl__ext_fault *, const char*);
SOAP_FMAC1 wsdl__ext_fault * SOAP_FMAC2 wsdl_instantiate_wsdl__ext_fault(struct soap*, int, const char*, const char*, size_t*);

inline wsdl__ext_fault * soap_new_wsdl__ext_fault(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_wsdl__ext_fault(soap, n, NULL, NULL, NULL);
}

inline wsdl__ext_fault * soap_new_req_wsdl__ext_fault(
	struct soap *soap)
{
	wsdl__ext_fault *_p = ::soap_new_wsdl__ext_fault(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline wsdl__ext_fault * soap_new_set_wsdl__ext_fault(
	struct soap *soap,
	char *name,
	char *ref,
	char *messageLabel,
	char *wsoap__code,
	char *wsoap__subcodes,
	char *documentation,
	wsp__Policy *wsp__Policy_,
	wsp__PolicyReference *wsp__PolicyReference_,
	soap__fault *soap__fault_,
	const std::vector<wsoap__module> & wsoap__module_)
{
	wsdl__ext_fault *_p = ::soap_new_wsdl__ext_fault(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wsdl__ext_fault::name = name;
		_p->wsdl__ext_fault::ref = ref;
		_p->wsdl__ext_fault::messageLabel = messageLabel;
		_p->wsdl__ext_fault::wsoap__code = wsoap__code;
		_p->wsdl__ext_fault::wsoap__subcodes = wsoap__subcodes;
		_p->wsdl__ext_fault::documentation = documentation;
		_p->wsdl__ext_fault::wsp__Policy_ = wsp__Policy_;
		_p->wsdl__ext_fault::wsp__PolicyReference_ = wsp__PolicyReference_;
		_p->wsdl__ext_fault::soap__fault_ = soap__fault_;
		_p->wsdl__ext_fault::wsoap__module_ = wsoap__module_;
	}
	return _p;
}

inline int soap_write_wsdl__ext_fault(struct soap *soap, wsdl__ext_fault const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsdl:ext-fault", p->soap_type() == SOAP_TYPE_wsdl__ext_fault ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_wsdl__ext_fault(struct soap *soap, const char *URL, wsdl__ext_fault const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsdl:ext-fault", p->soap_type() == SOAP_TYPE_wsdl__ext_fault ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_wsdl__ext_fault(struct soap *soap, const char *URL, wsdl__ext_fault const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsdl:ext-fault", p->soap_type() == SOAP_TYPE_wsdl__ext_fault ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_wsdl__ext_fault(struct soap *soap, const char *URL, wsdl__ext_fault const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsdl:ext-fault", p->soap_type() == SOAP_TYPE_wsdl__ext_fault ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 wsdl__ext_fault * SOAP_FMAC4 soap_get_wsdl__ext_fault(struct soap*, wsdl__ext_fault *, const char*, const char*);

inline int soap_read_wsdl__ext_fault(struct soap *soap, wsdl__ext_fault *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_wsdl__ext_fault(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_wsdl__ext_fault(struct soap *soap, const char *URL, wsdl__ext_fault *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_wsdl__ext_fault(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_wsdl__ext_fault(struct soap *soap, wsdl__ext_fault *p)
{
	if (::soap_read_wsdl__ext_fault(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_wsdl__ext_ioput_DEFINED
#define SOAP_TYPE_wsdl__ext_ioput_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdl__ext_ioput(struct soap*, const char*, int, const wsdl__ext_ioput *, const char*);
SOAP_FMAC3 wsdl__ext_ioput * SOAP_FMAC4 soap_in_wsdl__ext_ioput(struct soap*, const char*, wsdl__ext_ioput *, const char*);
SOAP_FMAC1 wsdl__ext_ioput * SOAP_FMAC2 wsdl_instantiate_wsdl__ext_ioput(struct soap*, int, const char*, const char*, size_t*);

inline wsdl__ext_ioput * soap_new_wsdl__ext_ioput(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_wsdl__ext_ioput(soap, n, NULL, NULL, NULL);
}

inline wsdl__ext_ioput * soap_new_req_wsdl__ext_ioput(
	struct soap *soap)
{
	wsdl__ext_ioput *_p = ::soap_new_wsdl__ext_ioput(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline wsdl__ext_ioput * soap_new_set_wsdl__ext_ioput(
	struct soap *soap,
	char *name,
	char *messageLabel,
	char *documentation,
	wsp__Policy *wsp__Policy_,
	wsp__PolicyReference *wsp__PolicyReference_,
	dime__message *dime__message_,
	soap__body *soap__body_,
	char *http__urlEncoded,
	mime__multipartRelated *mime__multipartRelated_,
	mime__content *mime__content_,
	mime__mimeXml *mime__mimeXml_,
	const std::vector<soap__header> & soap__header_,
	const std::vector<wsoap__module> & wsoap__module_,
	const std::vector<wsoap__header> & wsoap__header_,
	const std::vector<whttp__header> & whttp__header_)
{
	wsdl__ext_ioput *_p = ::soap_new_wsdl__ext_ioput(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wsdl__ext_ioput::name = name;
		_p->wsdl__ext_ioput::messageLabel = messageLabel;
		_p->wsdl__ext_ioput::documentation = documentation;
		_p->wsdl__ext_ioput::wsp__Policy_ = wsp__Policy_;
		_p->wsdl__ext_ioput::wsp__PolicyReference_ = wsp__PolicyReference_;
		_p->wsdl__ext_ioput::dime__message_ = dime__message_;
		_p->wsdl__ext_ioput::soap__body_ = soap__body_;
		_p->wsdl__ext_ioput::http__urlEncoded = http__urlEncoded;
		_p->wsdl__ext_ioput::mime__multipartRelated_ = mime__multipartRelated_;
		_p->wsdl__ext_ioput::mime__content_ = mime__content_;
		_p->wsdl__ext_ioput::mime__mimeXml_ = mime__mimeXml_;
		_p->wsdl__ext_ioput::soap__header_ = soap__header_;
		_p->wsdl__ext_ioput::wsoap__module_ = wsoap__module_;
		_p->wsdl__ext_ioput::wsoap__header_ = wsoap__header_;
		_p->wsdl__ext_ioput::whttp__header_ = whttp__header_;
	}
	return _p;
}

inline int soap_write_wsdl__ext_ioput(struct soap *soap, wsdl__ext_ioput const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsdl:ext-ioput", p->soap_type() == SOAP_TYPE_wsdl__ext_ioput ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_wsdl__ext_ioput(struct soap *soap, const char *URL, wsdl__ext_ioput const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsdl:ext-ioput", p->soap_type() == SOAP_TYPE_wsdl__ext_ioput ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_wsdl__ext_ioput(struct soap *soap, const char *URL, wsdl__ext_ioput const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsdl:ext-ioput", p->soap_type() == SOAP_TYPE_wsdl__ext_ioput ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_wsdl__ext_ioput(struct soap *soap, const char *URL, wsdl__ext_ioput const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsdl:ext-ioput", p->soap_type() == SOAP_TYPE_wsdl__ext_ioput ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 wsdl__ext_ioput * SOAP_FMAC4 soap_get_wsdl__ext_ioput(struct soap*, wsdl__ext_ioput *, const char*, const char*);

inline int soap_read_wsdl__ext_ioput(struct soap *soap, wsdl__ext_ioput *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_wsdl__ext_ioput(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_wsdl__ext_ioput(struct soap *soap, const char *URL, wsdl__ext_ioput *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_wsdl__ext_ioput(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_wsdl__ext_ioput(struct soap *soap, wsdl__ext_ioput *p)
{
	if (::soap_read_wsdl__ext_ioput(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_wsdl__fault_DEFINED
#define SOAP_TYPE_wsdl__fault_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdl__fault(struct soap*, const char*, int, const wsdl__fault *, const char*);
SOAP_FMAC3 wsdl__fault * SOAP_FMAC4 soap_in_wsdl__fault(struct soap*, const char*, wsdl__fault *, const char*);
SOAP_FMAC1 wsdl__fault * SOAP_FMAC2 wsdl_instantiate_wsdl__fault(struct soap*, int, const char*, const char*, size_t*);

inline wsdl__fault * soap_new_wsdl__fault(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_wsdl__fault(soap, n, NULL, NULL, NULL);
}

inline wsdl__fault * soap_new_req_wsdl__fault(
	struct soap *soap)
{
	wsdl__fault *_p = ::soap_new_wsdl__fault(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline wsdl__fault * soap_new_set_wsdl__fault(
	struct soap *soap,
	char *name,
	char *message,
	char *ref,
	char *messageLabel,
	char *element,
	char *wsa__Action,
	char *wsam__Action,
	char *documentation,
	wsp__Policy *wsp__Policy_,
	wsp__PolicyReference *wsp__PolicyReference_)
{
	wsdl__fault *_p = ::soap_new_wsdl__fault(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wsdl__fault::name = name;
		_p->wsdl__fault::message = message;
		_p->wsdl__fault::ref = ref;
		_p->wsdl__fault::messageLabel = messageLabel;
		_p->wsdl__fault::element = element;
		_p->wsdl__fault::wsa__Action = wsa__Action;
		_p->wsdl__fault::wsam__Action = wsam__Action;
		_p->wsdl__fault::documentation = documentation;
		_p->wsdl__fault::wsp__Policy_ = wsp__Policy_;
		_p->wsdl__fault::wsp__PolicyReference_ = wsp__PolicyReference_;
	}
	return _p;
}

inline int soap_write_wsdl__fault(struct soap *soap, wsdl__fault const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsdl:fault", p->soap_type() == SOAP_TYPE_wsdl__fault ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_wsdl__fault(struct soap *soap, const char *URL, wsdl__fault const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsdl:fault", p->soap_type() == SOAP_TYPE_wsdl__fault ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_wsdl__fault(struct soap *soap, const char *URL, wsdl__fault const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsdl:fault", p->soap_type() == SOAP_TYPE_wsdl__fault ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_wsdl__fault(struct soap *soap, const char *URL, wsdl__fault const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsdl:fault", p->soap_type() == SOAP_TYPE_wsdl__fault ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 wsdl__fault * SOAP_FMAC4 soap_get_wsdl__fault(struct soap*, wsdl__fault *, const char*, const char*);

inline int soap_read_wsdl__fault(struct soap *soap, wsdl__fault *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_wsdl__fault(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_wsdl__fault(struct soap *soap, const char *URL, wsdl__fault *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_wsdl__fault(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_wsdl__fault(struct soap *soap, wsdl__fault *p)
{
	if (::soap_read_wsdl__fault(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_wsdl__ioput_DEFINED
#define SOAP_TYPE_wsdl__ioput_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdl__ioput(struct soap*, const char*, int, const wsdl__ioput *, const char*);
SOAP_FMAC3 wsdl__ioput * SOAP_FMAC4 soap_in_wsdl__ioput(struct soap*, const char*, wsdl__ioput *, const char*);
SOAP_FMAC1 wsdl__ioput * SOAP_FMAC2 wsdl_instantiate_wsdl__ioput(struct soap*, int, const char*, const char*, size_t*);

inline wsdl__ioput * soap_new_wsdl__ioput(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_wsdl__ioput(soap, n, NULL, NULL, NULL);
}

inline wsdl__ioput * soap_new_req_wsdl__ioput(
	struct soap *soap)
{
	wsdl__ioput *_p = ::soap_new_wsdl__ioput(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline wsdl__ioput * soap_new_set_wsdl__ioput(
	struct soap *soap,
	char *name,
	char *message,
	char *messageLabel,
	char *element,
	char *wsa__Action,
	char *wsam__Action,
	char *documentation,
	wsp__Policy *wsp__Policy_,
	wsp__PolicyReference *wsp__PolicyReference_)
{
	wsdl__ioput *_p = ::soap_new_wsdl__ioput(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wsdl__ioput::name = name;
		_p->wsdl__ioput::message = message;
		_p->wsdl__ioput::messageLabel = messageLabel;
		_p->wsdl__ioput::element = element;
		_p->wsdl__ioput::wsa__Action = wsa__Action;
		_p->wsdl__ioput::wsam__Action = wsam__Action;
		_p->wsdl__ioput::documentation = documentation;
		_p->wsdl__ioput::wsp__Policy_ = wsp__Policy_;
		_p->wsdl__ioput::wsp__PolicyReference_ = wsp__PolicyReference_;
	}
	return _p;
}

inline int soap_write_wsdl__ioput(struct soap *soap, wsdl__ioput const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsdl:ioput", p->soap_type() == SOAP_TYPE_wsdl__ioput ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_wsdl__ioput(struct soap *soap, const char *URL, wsdl__ioput const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsdl:ioput", p->soap_type() == SOAP_TYPE_wsdl__ioput ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_wsdl__ioput(struct soap *soap, const char *URL, wsdl__ioput const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsdl:ioput", p->soap_type() == SOAP_TYPE_wsdl__ioput ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_wsdl__ioput(struct soap *soap, const char *URL, wsdl__ioput const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsdl:ioput", p->soap_type() == SOAP_TYPE_wsdl__ioput ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 wsdl__ioput * SOAP_FMAC4 soap_get_wsdl__ioput(struct soap*, wsdl__ioput *, const char*, const char*);

inline int soap_read_wsdl__ioput(struct soap *soap, wsdl__ioput *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_wsdl__ioput(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_wsdl__ioput(struct soap *soap, const char *URL, wsdl__ioput *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_wsdl__ioput(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_wsdl__ioput(struct soap *soap, wsdl__ioput *p)
{
	if (::soap_read_wsdl__ioput(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_wsdl__types_DEFINED
#define SOAP_TYPE_wsdl__types_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdl__types(struct soap*, const char*, int, const wsdl__types *, const char*);
SOAP_FMAC3 wsdl__types * SOAP_FMAC4 soap_in_wsdl__types(struct soap*, const char*, wsdl__types *, const char*);
SOAP_FMAC1 wsdl__types * SOAP_FMAC2 wsdl_instantiate_wsdl__types(struct soap*, int, const char*, const char*, size_t*);

inline wsdl__types * soap_new_wsdl__types(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_wsdl__types(soap, n, NULL, NULL, NULL);
}

inline wsdl__types * soap_new_req_wsdl__types(
	struct soap *soap)
{
	wsdl__types *_p = ::soap_new_wsdl__types(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline wsdl__types * soap_new_set_wsdl__types(
	struct soap *soap,
	char *documentation,
	const std::vector<xs__schema *> & xs__schema_,
	char *targetNamespace__1,
	char *version__1,
	char *defaultAttributes__1,
	enum xs__formChoice attributeFormDefault__1,
	enum xs__formChoice elementFormDefault__1,
	xs__annotation *annotation__1,
	const std::vector<xs__include> & include__1,
	const std::vector<xs__override> & override___1,
	const std::vector<xs__redefine> & redefine__1,
	const std::vector<xs__import> & import__1,
	const std::vector<xs__attribute> & attribute__1,
	const std::vector<xs__element> & element__1,
	const std::vector<xs__group> & group__1,
	const std::vector<xs__attributeGroup> & attributeGroup__1,
	const std::vector<xs__simpleType> & simpleType__1,
	const std::vector<xs__complexType> & complexType__1)
{
	wsdl__types *_p = ::soap_new_wsdl__types(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wsdl__types::documentation = documentation;
		_p->wsdl__types::xs__schema_ = xs__schema_;
		_p->xs__schema::targetNamespace = targetNamespace__1;
		_p->xs__schema::version = version__1;
		_p->xs__schema::defaultAttributes = defaultAttributes__1;
		_p->xs__schema::attributeFormDefault = attributeFormDefault__1;
		_p->xs__schema::elementFormDefault = elementFormDefault__1;
		_p->xs__schema::annotation = annotation__1;
		_p->xs__schema::include = include__1;
		_p->xs__schema::override_ = override___1;
		_p->xs__schema::redefine = redefine__1;
		_p->xs__schema::import = import__1;
		_p->xs__schema::attribute = attribute__1;
		_p->xs__schema::element = element__1;
		_p->xs__schema::group = group__1;
		_p->xs__schema::attributeGroup = attributeGroup__1;
		_p->xs__schema::simpleType = simpleType__1;
		_p->xs__schema::complexType = complexType__1;
	}
	return _p;
}

inline int soap_write_wsdl__types(struct soap *soap, wsdl__types const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsdl:types", p->soap_type() == SOAP_TYPE_wsdl__types ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_wsdl__types(struct soap *soap, const char *URL, wsdl__types const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsdl:types", p->soap_type() == SOAP_TYPE_wsdl__types ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_wsdl__types(struct soap *soap, const char *URL, wsdl__types const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsdl:types", p->soap_type() == SOAP_TYPE_wsdl__types ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_wsdl__types(struct soap *soap, const char *URL, wsdl__types const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsdl:types", p->soap_type() == SOAP_TYPE_wsdl__types ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 wsdl__types * SOAP_FMAC4 soap_get_wsdl__types(struct soap*, wsdl__types *, const char*, const char*);

inline int soap_read_wsdl__types(struct soap *soap, wsdl__types *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_wsdl__types(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_wsdl__types(struct soap *soap, const char *URL, wsdl__types *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_wsdl__types(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_wsdl__types(struct soap *soap, wsdl__types *p)
{
	if (::soap_read_wsdl__types(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_wsdl__import_DEFINED
#define SOAP_TYPE_wsdl__import_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdl__import(struct soap*, const char*, int, const wsdl__import *, const char*);
SOAP_FMAC3 wsdl__import * SOAP_FMAC4 soap_in_wsdl__import(struct soap*, const char*, wsdl__import *, const char*);
SOAP_FMAC1 wsdl__import * SOAP_FMAC2 wsdl_instantiate_wsdl__import(struct soap*, int, const char*, const char*, size_t*);

inline wsdl__import * soap_new_wsdl__import(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_wsdl__import(soap, n, NULL, NULL, NULL);
}

inline wsdl__import * soap_new_req_wsdl__import(
	struct soap *soap)
{
	wsdl__import *_p = ::soap_new_wsdl__import(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline wsdl__import * soap_new_set_wsdl__import(
	struct soap *soap,
	char *namespace_,
	char *location)
{
	wsdl__import *_p = ::soap_new_wsdl__import(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wsdl__import::namespace_ = namespace_;
		_p->wsdl__import::location = location;
	}
	return _p;
}

inline int soap_write_wsdl__import(struct soap *soap, wsdl__import const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsdl:import", p->soap_type() == SOAP_TYPE_wsdl__import ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_wsdl__import(struct soap *soap, const char *URL, wsdl__import const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsdl:import", p->soap_type() == SOAP_TYPE_wsdl__import ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_wsdl__import(struct soap *soap, const char *URL, wsdl__import const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsdl:import", p->soap_type() == SOAP_TYPE_wsdl__import ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_wsdl__import(struct soap *soap, const char *URL, wsdl__import const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsdl:import", p->soap_type() == SOAP_TYPE_wsdl__import ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 wsdl__import * SOAP_FMAC4 soap_get_wsdl__import(struct soap*, wsdl__import *, const char*, const char*);

inline int soap_read_wsdl__import(struct soap *soap, wsdl__import *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_wsdl__import(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_wsdl__import(struct soap *soap, const char *URL, wsdl__import *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_wsdl__import(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_wsdl__import(struct soap *soap, wsdl__import *p)
{
	if (::soap_read_wsdl__import(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_vprop__tPropertyAlias_DEFINED
#define SOAP_TYPE_vprop__tPropertyAlias_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_vprop__tPropertyAlias(struct soap*, const char*, int, const vprop__tPropertyAlias *, const char*);
SOAP_FMAC3 vprop__tPropertyAlias * SOAP_FMAC4 soap_in_vprop__tPropertyAlias(struct soap*, const char*, vprop__tPropertyAlias *, const char*);
SOAP_FMAC1 vprop__tPropertyAlias * SOAP_FMAC2 wsdl_instantiate_vprop__tPropertyAlias(struct soap*, int, const char*, const char*, size_t*);

inline vprop__tPropertyAlias * soap_new_vprop__tPropertyAlias(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_vprop__tPropertyAlias(soap, n, NULL, NULL, NULL);
}

inline vprop__tPropertyAlias * soap_new_req_vprop__tPropertyAlias(
	struct soap *soap)
{
	vprop__tPropertyAlias *_p = ::soap_new_vprop__tPropertyAlias(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline vprop__tPropertyAlias * soap_new_set_vprop__tPropertyAlias(
	struct soap *soap,
	vprop__tQuery *query,
	char *propertyName,
	char *messageType,
	char *part,
	char *type,
	char *element,
	char *documentation)
{
	vprop__tPropertyAlias *_p = ::soap_new_vprop__tPropertyAlias(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->vprop__tPropertyAlias::query = query;
		_p->vprop__tPropertyAlias::propertyName = propertyName;
		_p->vprop__tPropertyAlias::messageType = messageType;
		_p->vprop__tPropertyAlias::part = part;
		_p->vprop__tPropertyAlias::type = type;
		_p->vprop__tPropertyAlias::element = element;
		_p->vprop__tPropertyAlias::documentation = documentation;
	}
	return _p;
}

inline int soap_write_vprop__tPropertyAlias(struct soap *soap, vprop__tPropertyAlias const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "vprop:tPropertyAlias", p->soap_type() == SOAP_TYPE_vprop__tPropertyAlias ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_vprop__tPropertyAlias(struct soap *soap, const char *URL, vprop__tPropertyAlias const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "vprop:tPropertyAlias", p->soap_type() == SOAP_TYPE_vprop__tPropertyAlias ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_vprop__tPropertyAlias(struct soap *soap, const char *URL, vprop__tPropertyAlias const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "vprop:tPropertyAlias", p->soap_type() == SOAP_TYPE_vprop__tPropertyAlias ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_vprop__tPropertyAlias(struct soap *soap, const char *URL, vprop__tPropertyAlias const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "vprop:tPropertyAlias", p->soap_type() == SOAP_TYPE_vprop__tPropertyAlias ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 vprop__tPropertyAlias * SOAP_FMAC4 soap_get_vprop__tPropertyAlias(struct soap*, vprop__tPropertyAlias *, const char*, const char*);

inline int soap_read_vprop__tPropertyAlias(struct soap *soap, vprop__tPropertyAlias *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_vprop__tPropertyAlias(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_vprop__tPropertyAlias(struct soap *soap, const char *URL, vprop__tPropertyAlias *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_vprop__tPropertyAlias(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_vprop__tPropertyAlias(struct soap *soap, vprop__tPropertyAlias *p)
{
	if (::soap_read_vprop__tPropertyAlias(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_vprop__tProperty_DEFINED
#define SOAP_TYPE_vprop__tProperty_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_vprop__tProperty(struct soap*, const char*, int, const vprop__tProperty *, const char*);
SOAP_FMAC3 vprop__tProperty * SOAP_FMAC4 soap_in_vprop__tProperty(struct soap*, const char*, vprop__tProperty *, const char*);
SOAP_FMAC1 vprop__tProperty * SOAP_FMAC2 wsdl_instantiate_vprop__tProperty(struct soap*, int, const char*, const char*, size_t*);

inline vprop__tProperty * soap_new_vprop__tProperty(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_vprop__tProperty(soap, n, NULL, NULL, NULL);
}

inline vprop__tProperty * soap_new_req_vprop__tProperty(
	struct soap *soap)
{
	vprop__tProperty *_p = ::soap_new_vprop__tProperty(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline vprop__tProperty * soap_new_set_vprop__tProperty(
	struct soap *soap,
	char *name,
	char *type,
	char *element,
	char *documentation)
{
	vprop__tProperty *_p = ::soap_new_vprop__tProperty(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->vprop__tProperty::name = name;
		_p->vprop__tProperty::type = type;
		_p->vprop__tProperty::element = element;
		_p->vprop__tProperty::documentation = documentation;
	}
	return _p;
}

inline int soap_write_vprop__tProperty(struct soap *soap, vprop__tProperty const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "vprop:tProperty", p->soap_type() == SOAP_TYPE_vprop__tProperty ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_vprop__tProperty(struct soap *soap, const char *URL, vprop__tProperty const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "vprop:tProperty", p->soap_type() == SOAP_TYPE_vprop__tProperty ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_vprop__tProperty(struct soap *soap, const char *URL, vprop__tProperty const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "vprop:tProperty", p->soap_type() == SOAP_TYPE_vprop__tProperty ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_vprop__tProperty(struct soap *soap, const char *URL, vprop__tProperty const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "vprop:tProperty", p->soap_type() == SOAP_TYPE_vprop__tProperty ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 vprop__tProperty * SOAP_FMAC4 soap_get_vprop__tProperty(struct soap*, vprop__tProperty *, const char*, const char*);

inline int soap_read_vprop__tProperty(struct soap *soap, vprop__tProperty *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_vprop__tProperty(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_vprop__tProperty(struct soap *soap, const char *URL, vprop__tProperty *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_vprop__tProperty(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_vprop__tProperty(struct soap *soap, vprop__tProperty *p)
{
	if (::soap_read_vprop__tProperty(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_vprop__tQuery_DEFINED
#define SOAP_TYPE_vprop__tQuery_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_vprop__tQuery(struct soap*, const char*, int, const vprop__tQuery *, const char*);
SOAP_FMAC3 vprop__tQuery * SOAP_FMAC4 soap_in_vprop__tQuery(struct soap*, const char*, vprop__tQuery *, const char*);
SOAP_FMAC1 vprop__tQuery * SOAP_FMAC2 wsdl_instantiate_vprop__tQuery(struct soap*, int, const char*, const char*, size_t*);

inline vprop__tQuery * soap_new_vprop__tQuery(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_vprop__tQuery(soap, n, NULL, NULL, NULL);
}

inline vprop__tQuery * soap_new_req_vprop__tQuery(
	struct soap *soap)
{
	vprop__tQuery *_p = ::soap_new_vprop__tQuery(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline vprop__tQuery * soap_new_set_vprop__tQuery(
	struct soap *soap,
	char *queryLanguage,
	char *__mixed)
{
	vprop__tQuery *_p = ::soap_new_vprop__tQuery(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->vprop__tQuery::queryLanguage = queryLanguage;
		_p->vprop__tQuery::__mixed = __mixed;
	}
	return _p;
}

inline int soap_write_vprop__tQuery(struct soap *soap, vprop__tQuery const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "vprop:tQuery", p->soap_type() == SOAP_TYPE_vprop__tQuery ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_vprop__tQuery(struct soap *soap, const char *URL, vprop__tQuery const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "vprop:tQuery", p->soap_type() == SOAP_TYPE_vprop__tQuery ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_vprop__tQuery(struct soap *soap, const char *URL, vprop__tQuery const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "vprop:tQuery", p->soap_type() == SOAP_TYPE_vprop__tQuery ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_vprop__tQuery(struct soap *soap, const char *URL, vprop__tQuery const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "vprop:tQuery", p->soap_type() == SOAP_TYPE_vprop__tQuery ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 vprop__tQuery * SOAP_FMAC4 soap_get_vprop__tQuery(struct soap*, vprop__tQuery *, const char*, const char*);

inline int soap_read_vprop__tQuery(struct soap *soap, vprop__tQuery *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_vprop__tQuery(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_vprop__tQuery(struct soap *soap, const char *URL, vprop__tQuery *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_vprop__tQuery(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_vprop__tQuery(struct soap *soap, vprop__tQuery *p)
{
	if (::soap_read_vprop__tQuery(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_plnk__tRole_DEFINED
#define SOAP_TYPE_plnk__tRole_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_plnk__tRole(struct soap*, const char*, int, const plnk__tRole *, const char*);
SOAP_FMAC3 plnk__tRole * SOAP_FMAC4 soap_in_plnk__tRole(struct soap*, const char*, plnk__tRole *, const char*);
SOAP_FMAC1 plnk__tRole * SOAP_FMAC2 wsdl_instantiate_plnk__tRole(struct soap*, int, const char*, const char*, size_t*);

inline plnk__tRole * soap_new_plnk__tRole(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_plnk__tRole(soap, n, NULL, NULL, NULL);
}

inline plnk__tRole * soap_new_req_plnk__tRole(
	struct soap *soap)
{
	plnk__tRole *_p = ::soap_new_plnk__tRole(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline plnk__tRole * soap_new_set_plnk__tRole(
	struct soap *soap,
	char *name,
	char *portType,
	char *documentation)
{
	plnk__tRole *_p = ::soap_new_plnk__tRole(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->plnk__tRole::name = name;
		_p->plnk__tRole::portType = portType;
		_p->plnk__tRole::documentation = documentation;
	}
	return _p;
}

inline int soap_write_plnk__tRole(struct soap *soap, plnk__tRole const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "plnk:tRole", p->soap_type() == SOAP_TYPE_plnk__tRole ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_plnk__tRole(struct soap *soap, const char *URL, plnk__tRole const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "plnk:tRole", p->soap_type() == SOAP_TYPE_plnk__tRole ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_plnk__tRole(struct soap *soap, const char *URL, plnk__tRole const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "plnk:tRole", p->soap_type() == SOAP_TYPE_plnk__tRole ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_plnk__tRole(struct soap *soap, const char *URL, plnk__tRole const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "plnk:tRole", p->soap_type() == SOAP_TYPE_plnk__tRole ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 plnk__tRole * SOAP_FMAC4 soap_get_plnk__tRole(struct soap*, plnk__tRole *, const char*, const char*);

inline int soap_read_plnk__tRole(struct soap *soap, plnk__tRole *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_plnk__tRole(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_plnk__tRole(struct soap *soap, const char *URL, plnk__tRole *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_plnk__tRole(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_plnk__tRole(struct soap *soap, plnk__tRole *p)
{
	if (::soap_read_plnk__tRole(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_plnk__tPartnerLinkType_DEFINED
#define SOAP_TYPE_plnk__tPartnerLinkType_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_plnk__tPartnerLinkType(struct soap*, const char*, int, const plnk__tPartnerLinkType *, const char*);
SOAP_FMAC3 plnk__tPartnerLinkType * SOAP_FMAC4 soap_in_plnk__tPartnerLinkType(struct soap*, const char*, plnk__tPartnerLinkType *, const char*);
SOAP_FMAC1 plnk__tPartnerLinkType * SOAP_FMAC2 wsdl_instantiate_plnk__tPartnerLinkType(struct soap*, int, const char*, const char*, size_t*);

inline plnk__tPartnerLinkType * soap_new_plnk__tPartnerLinkType(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_plnk__tPartnerLinkType(soap, n, NULL, NULL, NULL);
}

inline plnk__tPartnerLinkType * soap_new_req_plnk__tPartnerLinkType(
	struct soap *soap)
{
	plnk__tPartnerLinkType *_p = ::soap_new_plnk__tPartnerLinkType(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline plnk__tPartnerLinkType * soap_new_set_plnk__tPartnerLinkType(
	struct soap *soap,
	char *name,
	const std::vector<plnk__tRole> & role,
	char *documentation)
{
	plnk__tPartnerLinkType *_p = ::soap_new_plnk__tPartnerLinkType(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->plnk__tPartnerLinkType::name = name;
		_p->plnk__tPartnerLinkType::role = role;
		_p->plnk__tPartnerLinkType::documentation = documentation;
	}
	return _p;
}

inline int soap_write_plnk__tPartnerLinkType(struct soap *soap, plnk__tPartnerLinkType const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "plnk:tPartnerLinkType", p->soap_type() == SOAP_TYPE_plnk__tPartnerLinkType ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_plnk__tPartnerLinkType(struct soap *soap, const char *URL, plnk__tPartnerLinkType const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "plnk:tPartnerLinkType", p->soap_type() == SOAP_TYPE_plnk__tPartnerLinkType ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_plnk__tPartnerLinkType(struct soap *soap, const char *URL, plnk__tPartnerLinkType const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "plnk:tPartnerLinkType", p->soap_type() == SOAP_TYPE_plnk__tPartnerLinkType ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_plnk__tPartnerLinkType(struct soap *soap, const char *URL, plnk__tPartnerLinkType const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "plnk:tPartnerLinkType", p->soap_type() == SOAP_TYPE_plnk__tPartnerLinkType ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 plnk__tPartnerLinkType * SOAP_FMAC4 soap_get_plnk__tPartnerLinkType(struct soap*, plnk__tPartnerLinkType *, const char*, const char*);

inline int soap_read_plnk__tPartnerLinkType(struct soap *soap, plnk__tPartnerLinkType *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_plnk__tPartnerLinkType(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_plnk__tPartnerLinkType(struct soap *soap, const char *URL, plnk__tPartnerLinkType *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_plnk__tPartnerLinkType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_plnk__tPartnerLinkType(struct soap *soap, plnk__tPartnerLinkType *p)
{
	if (::soap_read_plnk__tPartnerLinkType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_wsdl__portType_DEFINED
#define SOAP_TYPE_wsdl__portType_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdl__portType(struct soap*, const char*, int, const wsdl__portType *, const char*);
SOAP_FMAC3 wsdl__portType * SOAP_FMAC4 soap_in_wsdl__portType(struct soap*, const char*, wsdl__portType *, const char*);
SOAP_FMAC1 wsdl__portType * SOAP_FMAC2 wsdl_instantiate_wsdl__portType(struct soap*, int, const char*, const char*, size_t*);

inline wsdl__portType * soap_new_wsdl__portType(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_wsdl__portType(soap, n, NULL, NULL, NULL);
}

inline wsdl__portType * soap_new_req_wsdl__portType(
	struct soap *soap)
{
	wsdl__portType *_p = ::soap_new_wsdl__portType(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline wsdl__portType * soap_new_set_wsdl__portType(
	struct soap *soap,
	char *name,
	char *extends,
	char *styleDefault,
	char *documentation,
	wsp__Policy *wsp__Policy_,
	wsp__PolicyReference *wsp__PolicyReference_,
	const std::vector<wsdl__fault> & fault,
	const std::vector<wsdl__operation> & operation)
{
	wsdl__portType *_p = ::soap_new_wsdl__portType(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wsdl__portType::name = name;
		_p->wsdl__portType::extends = extends;
		_p->wsdl__portType::styleDefault = styleDefault;
		_p->wsdl__portType::documentation = documentation;
		_p->wsdl__portType::wsp__Policy_ = wsp__Policy_;
		_p->wsdl__portType::wsp__PolicyReference_ = wsp__PolicyReference_;
		_p->wsdl__portType::fault = fault;
		_p->wsdl__portType::operation = operation;
	}
	return _p;
}

inline int soap_write_wsdl__portType(struct soap *soap, wsdl__portType const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsdl:portType", p->soap_type() == SOAP_TYPE_wsdl__portType ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_wsdl__portType(struct soap *soap, const char *URL, wsdl__portType const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsdl:portType", p->soap_type() == SOAP_TYPE_wsdl__portType ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_wsdl__portType(struct soap *soap, const char *URL, wsdl__portType const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsdl:portType", p->soap_type() == SOAP_TYPE_wsdl__portType ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_wsdl__portType(struct soap *soap, const char *URL, wsdl__portType const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsdl:portType", p->soap_type() == SOAP_TYPE_wsdl__portType ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 wsdl__portType * SOAP_FMAC4 soap_get_wsdl__portType(struct soap*, wsdl__portType *, const char*, const char*);

inline int soap_read_wsdl__portType(struct soap *soap, wsdl__portType *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_wsdl__portType(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_wsdl__portType(struct soap *soap, const char *URL, wsdl__portType *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_wsdl__portType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_wsdl__portType(struct soap *soap, wsdl__portType *p)
{
	if (::soap_read_wsdl__portType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_wsp__PolicyAttachment_DEFINED
#define SOAP_TYPE_wsp__PolicyAttachment_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsp__PolicyAttachment(struct soap*, const char*, int, const wsp__PolicyAttachment *, const char*);
SOAP_FMAC3 wsp__PolicyAttachment * SOAP_FMAC4 soap_in_wsp__PolicyAttachment(struct soap*, const char*, wsp__PolicyAttachment *, const char*);
SOAP_FMAC1 wsp__PolicyAttachment * SOAP_FMAC2 wsdl_instantiate_wsp__PolicyAttachment(struct soap*, int, const char*, const char*, size_t*);

inline wsp__PolicyAttachment * soap_new_wsp__PolicyAttachment(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_wsp__PolicyAttachment(soap, n, NULL, NULL, NULL);
}

inline wsp__PolicyAttachment * soap_new_req_wsp__PolicyAttachment(
	struct soap *soap)
{
	wsp__PolicyAttachment *_p = ::soap_new_wsp__PolicyAttachment(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline wsp__PolicyAttachment * soap_new_set_wsp__PolicyAttachment(
	struct soap *soap,
	wsp__AppliesTo *AppliesTo,
	const std::vector<wsp__Attachment> & Attachment)
{
	wsp__PolicyAttachment *_p = ::soap_new_wsp__PolicyAttachment(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wsp__PolicyAttachment::AppliesTo = AppliesTo;
		_p->wsp__PolicyAttachment::Attachment = Attachment;
	}
	return _p;
}

inline int soap_write_wsp__PolicyAttachment(struct soap *soap, wsp__PolicyAttachment const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsp:PolicyAttachment", p->soap_type() == SOAP_TYPE_wsp__PolicyAttachment ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_wsp__PolicyAttachment(struct soap *soap, const char *URL, wsp__PolicyAttachment const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsp:PolicyAttachment", p->soap_type() == SOAP_TYPE_wsp__PolicyAttachment ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_wsp__PolicyAttachment(struct soap *soap, const char *URL, wsp__PolicyAttachment const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsp:PolicyAttachment", p->soap_type() == SOAP_TYPE_wsp__PolicyAttachment ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_wsp__PolicyAttachment(struct soap *soap, const char *URL, wsp__PolicyAttachment const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsp:PolicyAttachment", p->soap_type() == SOAP_TYPE_wsp__PolicyAttachment ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 wsp__PolicyAttachment * SOAP_FMAC4 soap_get_wsp__PolicyAttachment(struct soap*, wsp__PolicyAttachment *, const char*, const char*);

inline int soap_read_wsp__PolicyAttachment(struct soap *soap, wsp__PolicyAttachment *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_wsp__PolicyAttachment(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_wsp__PolicyAttachment(struct soap *soap, const char *URL, wsp__PolicyAttachment *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_wsp__PolicyAttachment(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_wsp__PolicyAttachment(struct soap *soap, wsp__PolicyAttachment *p)
{
	if (::soap_read_wsp__PolicyAttachment(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_wsp__AppliesTo_DEFINED
#define SOAP_TYPE_wsp__AppliesTo_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsp__AppliesTo(struct soap*, const char*, int, const wsp__AppliesTo *, const char*);
SOAP_FMAC3 wsp__AppliesTo * SOAP_FMAC4 soap_in_wsp__AppliesTo(struct soap*, const char*, wsp__AppliesTo *, const char*);
SOAP_FMAC1 wsp__AppliesTo * SOAP_FMAC2 wsdl_instantiate_wsp__AppliesTo(struct soap*, int, const char*, const char*, size_t*);

inline wsp__AppliesTo * soap_new_wsp__AppliesTo(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_wsp__AppliesTo(soap, n, NULL, NULL, NULL);
}

inline wsp__AppliesTo * soap_new_req_wsp__AppliesTo(
	struct soap *soap)
{
	wsp__AppliesTo *_p = ::soap_new_wsp__AppliesTo(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline wsp__AppliesTo * soap_new_set_wsp__AppliesTo(
	struct soap *soap,
	char *__any)
{
	wsp__AppliesTo *_p = ::soap_new_wsp__AppliesTo(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wsp__AppliesTo::__any = __any;
	}
	return _p;
}

inline int soap_write_wsp__AppliesTo(struct soap *soap, wsp__AppliesTo const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsp:AppliesTo", p->soap_type() == SOAP_TYPE_wsp__AppliesTo ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_wsp__AppliesTo(struct soap *soap, const char *URL, wsp__AppliesTo const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsp:AppliesTo", p->soap_type() == SOAP_TYPE_wsp__AppliesTo ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_wsp__AppliesTo(struct soap *soap, const char *URL, wsp__AppliesTo const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsp:AppliesTo", p->soap_type() == SOAP_TYPE_wsp__AppliesTo ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_wsp__AppliesTo(struct soap *soap, const char *URL, wsp__AppliesTo const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsp:AppliesTo", p->soap_type() == SOAP_TYPE_wsp__AppliesTo ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 wsp__AppliesTo * SOAP_FMAC4 soap_get_wsp__AppliesTo(struct soap*, wsp__AppliesTo *, const char*, const char*);

inline int soap_read_wsp__AppliesTo(struct soap *soap, wsp__AppliesTo *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_wsp__AppliesTo(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_wsp__AppliesTo(struct soap *soap, const char *URL, wsp__AppliesTo *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_wsp__AppliesTo(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_wsp__AppliesTo(struct soap *soap, wsp__AppliesTo *p)
{
	if (::soap_read_wsp__AppliesTo(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_wsp__Attachment_DEFINED
#define SOAP_TYPE_wsp__Attachment_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsp__Attachment(struct soap*, const char*, int, const wsp__Attachment *, const char*);
SOAP_FMAC3 wsp__Attachment * SOAP_FMAC4 soap_in_wsp__Attachment(struct soap*, const char*, wsp__Attachment *, const char*);
SOAP_FMAC1 wsp__Attachment * SOAP_FMAC2 wsdl_instantiate_wsp__Attachment(struct soap*, int, const char*, const char*, size_t*);

inline wsp__Attachment * soap_new_wsp__Attachment(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_wsp__Attachment(soap, n, NULL, NULL, NULL);
}

inline wsp__Attachment * soap_new_req_wsp__Attachment(
	struct soap *soap)
{
	wsp__Attachment *_p = ::soap_new_wsp__Attachment(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline wsp__Attachment * soap_new_set_wsp__Attachment(
	struct soap *soap,
	wsp__Policy *Policy,
	wsp__PolicyReference *PolicyReference)
{
	wsp__Attachment *_p = ::soap_new_wsp__Attachment(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wsp__Attachment::Policy = Policy;
		_p->wsp__Attachment::PolicyReference = PolicyReference;
	}
	return _p;
}

inline int soap_write_wsp__Attachment(struct soap *soap, wsp__Attachment const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsp:Attachment", p->soap_type() == SOAP_TYPE_wsp__Attachment ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_wsp__Attachment(struct soap *soap, const char *URL, wsp__Attachment const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsp:Attachment", p->soap_type() == SOAP_TYPE_wsp__Attachment ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_wsp__Attachment(struct soap *soap, const char *URL, wsp__Attachment const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsp:Attachment", p->soap_type() == SOAP_TYPE_wsp__Attachment ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_wsp__Attachment(struct soap *soap, const char *URL, wsp__Attachment const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsp:Attachment", p->soap_type() == SOAP_TYPE_wsp__Attachment ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 wsp__Attachment * SOAP_FMAC4 soap_get_wsp__Attachment(struct soap*, wsp__Attachment *, const char*, const char*);

inline int soap_read_wsp__Attachment(struct soap *soap, wsp__Attachment *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_wsp__Attachment(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_wsp__Attachment(struct soap *soap, const char *URL, wsp__Attachment *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_wsp__Attachment(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_wsp__Attachment(struct soap *soap, wsp__Attachment *p)
{
	if (::soap_read_wsp__Attachment(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_wsrmp5__RMAssertion_DEFINED
#define SOAP_TYPE_wsrmp5__RMAssertion_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsrmp5__RMAssertion(struct soap*, const char*, int, const wsrmp5__RMAssertion *, const char*);
SOAP_FMAC3 wsrmp5__RMAssertion * SOAP_FMAC4 soap_in_wsrmp5__RMAssertion(struct soap*, const char*, wsrmp5__RMAssertion *, const char*);
SOAP_FMAC1 wsrmp5__RMAssertion * SOAP_FMAC2 wsdl_instantiate_wsrmp5__RMAssertion(struct soap*, int, const char*, const char*, size_t*);

inline wsrmp5__RMAssertion * soap_new_wsrmp5__RMAssertion(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_wsrmp5__RMAssertion(soap, n, NULL, NULL, NULL);
}

inline wsrmp5__RMAssertion * soap_new_req_wsrmp5__RMAssertion(
	struct soap *soap)
{
	wsrmp5__RMAssertion *_p = ::soap_new_wsrmp5__RMAssertion(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline wsrmp5__RMAssertion * soap_new_set_wsrmp5__RMAssertion(
	struct soap *soap,
	wsrmp5__Timeout *InactivityTimeout,
	wsrmp5__Timeout *BaseRetransmissionInterval,
	wsrmp5__Timeout *AcknowledgementInterval,
	char *ExponentialBackoff,
	bool Optional__1,
	bool Ignorable__1,
	wsp__Content *Policy__1)
{
	wsrmp5__RMAssertion *_p = ::soap_new_wsrmp5__RMAssertion(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wsrmp5__RMAssertion::InactivityTimeout = InactivityTimeout;
		_p->wsrmp5__RMAssertion::BaseRetransmissionInterval = BaseRetransmissionInterval;
		_p->wsrmp5__RMAssertion::AcknowledgementInterval = AcknowledgementInterval;
		_p->wsrmp5__RMAssertion::ExponentialBackoff = ExponentialBackoff;
		_p->wsp__Assertion::Optional = Optional__1;
		_p->wsp__Assertion::Ignorable = Ignorable__1;
		_p->wsp__Assertion::Policy = Policy__1;
	}
	return _p;
}

inline int soap_write_wsrmp5__RMAssertion(struct soap *soap, wsrmp5__RMAssertion const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsrmp5:RMAssertion", p->soap_type() == SOAP_TYPE_wsrmp5__RMAssertion ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_wsrmp5__RMAssertion(struct soap *soap, const char *URL, wsrmp5__RMAssertion const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsrmp5:RMAssertion", p->soap_type() == SOAP_TYPE_wsrmp5__RMAssertion ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_wsrmp5__RMAssertion(struct soap *soap, const char *URL, wsrmp5__RMAssertion const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsrmp5:RMAssertion", p->soap_type() == SOAP_TYPE_wsrmp5__RMAssertion ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_wsrmp5__RMAssertion(struct soap *soap, const char *URL, wsrmp5__RMAssertion const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsrmp5:RMAssertion", p->soap_type() == SOAP_TYPE_wsrmp5__RMAssertion ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 wsrmp5__RMAssertion * SOAP_FMAC4 soap_get_wsrmp5__RMAssertion(struct soap*, wsrmp5__RMAssertion *, const char*, const char*);

inline int soap_read_wsrmp5__RMAssertion(struct soap *soap, wsrmp5__RMAssertion *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_wsrmp5__RMAssertion(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_wsrmp5__RMAssertion(struct soap *soap, const char *URL, wsrmp5__RMAssertion *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_wsrmp5__RMAssertion(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_wsrmp5__RMAssertion(struct soap *soap, wsrmp5__RMAssertion *p)
{
	if (::soap_read_wsrmp5__RMAssertion(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_wsrmp5__Timeout_DEFINED
#define SOAP_TYPE_wsrmp5__Timeout_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsrmp5__Timeout(struct soap*, const char*, int, const wsrmp5__Timeout *, const char*);
SOAP_FMAC3 wsrmp5__Timeout * SOAP_FMAC4 soap_in_wsrmp5__Timeout(struct soap*, const char*, wsrmp5__Timeout *, const char*);
SOAP_FMAC1 wsrmp5__Timeout * SOAP_FMAC2 wsdl_instantiate_wsrmp5__Timeout(struct soap*, int, const char*, const char*, size_t*);

inline wsrmp5__Timeout * soap_new_wsrmp5__Timeout(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_wsrmp5__Timeout(soap, n, NULL, NULL, NULL);
}

inline wsrmp5__Timeout * soap_new_req_wsrmp5__Timeout(
	struct soap *soap)
{
	wsrmp5__Timeout *_p = ::soap_new_wsrmp5__Timeout(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline wsrmp5__Timeout * soap_new_set_wsrmp5__Timeout(
	struct soap *soap,
	char *Milliseconds)
{
	wsrmp5__Timeout *_p = ::soap_new_wsrmp5__Timeout(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wsrmp5__Timeout::Milliseconds = Milliseconds;
	}
	return _p;
}

inline int soap_write_wsrmp5__Timeout(struct soap *soap, wsrmp5__Timeout const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsrmp5:Timeout", p->soap_type() == SOAP_TYPE_wsrmp5__Timeout ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_wsrmp5__Timeout(struct soap *soap, const char *URL, wsrmp5__Timeout const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsrmp5:Timeout", p->soap_type() == SOAP_TYPE_wsrmp5__Timeout ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_wsrmp5__Timeout(struct soap *soap, const char *URL, wsrmp5__Timeout const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsrmp5:Timeout", p->soap_type() == SOAP_TYPE_wsrmp5__Timeout ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_wsrmp5__Timeout(struct soap *soap, const char *URL, wsrmp5__Timeout const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsrmp5:Timeout", p->soap_type() == SOAP_TYPE_wsrmp5__Timeout ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 wsrmp5__Timeout * SOAP_FMAC4 soap_get_wsrmp5__Timeout(struct soap*, wsrmp5__Timeout *, const char*, const char*);

inline int soap_read_wsrmp5__Timeout(struct soap *soap, wsrmp5__Timeout *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_wsrmp5__Timeout(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_wsrmp5__Timeout(struct soap *soap, const char *URL, wsrmp5__Timeout *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_wsrmp5__Timeout(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_wsrmp5__Timeout(struct soap *soap, wsrmp5__Timeout *p)
{
	if (::soap_read_wsrmp5__Timeout(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_wsrmp__RMAssertion_DEFINED
#define SOAP_TYPE_wsrmp__RMAssertion_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsrmp__RMAssertion(struct soap*, const char*, int, const wsrmp__RMAssertion *, const char*);
SOAP_FMAC3 wsrmp__RMAssertion * SOAP_FMAC4 soap_in_wsrmp__RMAssertion(struct soap*, const char*, wsrmp__RMAssertion *, const char*);
SOAP_FMAC1 wsrmp__RMAssertion * SOAP_FMAC2 wsdl_instantiate_wsrmp__RMAssertion(struct soap*, int, const char*, const char*, size_t*);

inline wsrmp__RMAssertion * soap_new_wsrmp__RMAssertion(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_wsrmp__RMAssertion(soap, n, NULL, NULL, NULL);
}

inline wsrmp__RMAssertion * soap_new_req_wsrmp__RMAssertion(
	struct soap *soap)
{
	wsrmp__RMAssertion *_p = ::soap_new_wsrmp__RMAssertion(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline wsrmp__RMAssertion * soap_new_set_wsrmp__RMAssertion(
	struct soap *soap,
	wsrmp__Timeout *InactivityTimeout,
	wsrmp__Timeout *BaseRetransmissionInterval,
	wsrmp__Timeout *AcknowledgementInterval,
	char *ExponentialBackoff,
	bool Optional__1,
	bool Ignorable__1,
	wsp__Content *Policy__1)
{
	wsrmp__RMAssertion *_p = ::soap_new_wsrmp__RMAssertion(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wsrmp__RMAssertion::InactivityTimeout = InactivityTimeout;
		_p->wsrmp__RMAssertion::BaseRetransmissionInterval = BaseRetransmissionInterval;
		_p->wsrmp__RMAssertion::AcknowledgementInterval = AcknowledgementInterval;
		_p->wsrmp__RMAssertion::ExponentialBackoff = ExponentialBackoff;
		_p->wsp__Assertion::Optional = Optional__1;
		_p->wsp__Assertion::Ignorable = Ignorable__1;
		_p->wsp__Assertion::Policy = Policy__1;
	}
	return _p;
}

inline int soap_write_wsrmp__RMAssertion(struct soap *soap, wsrmp__RMAssertion const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsrmp:RMAssertion", p->soap_type() == SOAP_TYPE_wsrmp__RMAssertion ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_wsrmp__RMAssertion(struct soap *soap, const char *URL, wsrmp__RMAssertion const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsrmp:RMAssertion", p->soap_type() == SOAP_TYPE_wsrmp__RMAssertion ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_wsrmp__RMAssertion(struct soap *soap, const char *URL, wsrmp__RMAssertion const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsrmp:RMAssertion", p->soap_type() == SOAP_TYPE_wsrmp__RMAssertion ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_wsrmp__RMAssertion(struct soap *soap, const char *URL, wsrmp__RMAssertion const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsrmp:RMAssertion", p->soap_type() == SOAP_TYPE_wsrmp__RMAssertion ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 wsrmp__RMAssertion * SOAP_FMAC4 soap_get_wsrmp__RMAssertion(struct soap*, wsrmp__RMAssertion *, const char*, const char*);

inline int soap_read_wsrmp__RMAssertion(struct soap *soap, wsrmp__RMAssertion *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_wsrmp__RMAssertion(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_wsrmp__RMAssertion(struct soap *soap, const char *URL, wsrmp__RMAssertion *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_wsrmp__RMAssertion(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_wsrmp__RMAssertion(struct soap *soap, wsrmp__RMAssertion *p)
{
	if (::soap_read_wsrmp__RMAssertion(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_wsrmp__Timeout_DEFINED
#define SOAP_TYPE_wsrmp__Timeout_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsrmp__Timeout(struct soap*, const char*, int, const wsrmp__Timeout *, const char*);
SOAP_FMAC3 wsrmp__Timeout * SOAP_FMAC4 soap_in_wsrmp__Timeout(struct soap*, const char*, wsrmp__Timeout *, const char*);
SOAP_FMAC1 wsrmp__Timeout * SOAP_FMAC2 wsdl_instantiate_wsrmp__Timeout(struct soap*, int, const char*, const char*, size_t*);

inline wsrmp__Timeout * soap_new_wsrmp__Timeout(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_wsrmp__Timeout(soap, n, NULL, NULL, NULL);
}

inline wsrmp__Timeout * soap_new_req_wsrmp__Timeout(
	struct soap *soap)
{
	wsrmp__Timeout *_p = ::soap_new_wsrmp__Timeout(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline wsrmp__Timeout * soap_new_set_wsrmp__Timeout(
	struct soap *soap,
	char *Milliseconds)
{
	wsrmp__Timeout *_p = ::soap_new_wsrmp__Timeout(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wsrmp__Timeout::Milliseconds = Milliseconds;
	}
	return _p;
}

inline int soap_write_wsrmp__Timeout(struct soap *soap, wsrmp__Timeout const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsrmp:Timeout", p->soap_type() == SOAP_TYPE_wsrmp__Timeout ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_wsrmp__Timeout(struct soap *soap, const char *URL, wsrmp__Timeout const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsrmp:Timeout", p->soap_type() == SOAP_TYPE_wsrmp__Timeout ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_wsrmp__Timeout(struct soap *soap, const char *URL, wsrmp__Timeout const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsrmp:Timeout", p->soap_type() == SOAP_TYPE_wsrmp__Timeout ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_wsrmp__Timeout(struct soap *soap, const char *URL, wsrmp__Timeout const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsrmp:Timeout", p->soap_type() == SOAP_TYPE_wsrmp__Timeout ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 wsrmp__Timeout * SOAP_FMAC4 soap_get_wsrmp__Timeout(struct soap*, wsrmp__Timeout *, const char*, const char*);

inline int soap_read_wsrmp__Timeout(struct soap *soap, wsrmp__Timeout *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_wsrmp__Timeout(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_wsrmp__Timeout(struct soap *soap, const char *URL, wsrmp__Timeout *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_wsrmp__Timeout(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_wsrmp__Timeout(struct soap *soap, wsrmp__Timeout *p)
{
	if (::soap_read_wsrmp__Timeout(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_sp__Token_DEFINED
#define SOAP_TYPE_sp__Token_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_sp__Token(struct soap*, const char*, int, const sp__Token *, const char*);
SOAP_FMAC3 sp__Token * SOAP_FMAC4 soap_in_sp__Token(struct soap*, const char*, sp__Token *, const char*);
SOAP_FMAC1 sp__Token * SOAP_FMAC2 wsdl_instantiate_sp__Token(struct soap*, int, const char*, const char*, size_t*);

inline sp__Token * soap_new_sp__Token(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_sp__Token(soap, n, NULL, NULL, NULL);
}

inline sp__Token * soap_new_req_sp__Token(
	struct soap *soap)
{
	sp__Token *_p = ::soap_new_sp__Token(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline sp__Token * soap_new_set_sp__Token(
	struct soap *soap,
	char *IncludeToken,
	wsa__EndpointReferenceType *Issuer,
	char *IssuerName,
	wst__Claims *wst__Claims_,
	bool Optional__1,
	bool Ignorable__1,
	wsp__Content *Policy__1)
{
	sp__Token *_p = ::soap_new_sp__Token(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->sp__Token::IncludeToken = IncludeToken;
		_p->sp__Token::Issuer = Issuer;
		_p->sp__Token::IssuerName = IssuerName;
		_p->sp__Token::wst__Claims_ = wst__Claims_;
		_p->wsp__Assertion::Optional = Optional__1;
		_p->wsp__Assertion::Ignorable = Ignorable__1;
		_p->wsp__Assertion::Policy = Policy__1;
	}
	return _p;
}

inline int soap_write_sp__Token(struct soap *soap, sp__Token const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "sp:Token", p->soap_type() == SOAP_TYPE_sp__Token ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_sp__Token(struct soap *soap, const char *URL, sp__Token const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "sp:Token", p->soap_type() == SOAP_TYPE_sp__Token ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_sp__Token(struct soap *soap, const char *URL, sp__Token const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "sp:Token", p->soap_type() == SOAP_TYPE_sp__Token ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_sp__Token(struct soap *soap, const char *URL, sp__Token const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "sp:Token", p->soap_type() == SOAP_TYPE_sp__Token ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 sp__Token * SOAP_FMAC4 soap_get_sp__Token(struct soap*, sp__Token *, const char*, const char*);

inline int soap_read_sp__Token(struct soap *soap, sp__Token *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_sp__Token(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_sp__Token(struct soap *soap, const char *URL, sp__Token *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_sp__Token(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_sp__Token(struct soap *soap, sp__Token *p)
{
	if (::soap_read_sp__Token(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_sp__Elements_DEFINED
#define SOAP_TYPE_sp__Elements_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_sp__Elements(struct soap*, const char*, int, const sp__Elements *, const char*);
SOAP_FMAC3 sp__Elements * SOAP_FMAC4 soap_in_sp__Elements(struct soap*, const char*, sp__Elements *, const char*);
SOAP_FMAC1 sp__Elements * SOAP_FMAC2 wsdl_instantiate_sp__Elements(struct soap*, int, const char*, const char*, size_t*);

inline sp__Elements * soap_new_sp__Elements(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_sp__Elements(soap, n, NULL, NULL, NULL);
}

inline sp__Elements * soap_new_req_sp__Elements(
	struct soap *soap)
{
	sp__Elements *_p = ::soap_new_sp__Elements(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline sp__Elements * soap_new_set_sp__Elements(
	struct soap *soap,
	char *XPathVersion,
	const std::vector<char *> & XPath)
{
	sp__Elements *_p = ::soap_new_sp__Elements(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->sp__Elements::XPathVersion = XPathVersion;
		_p->sp__Elements::XPath = XPath;
	}
	return _p;
}

inline int soap_write_sp__Elements(struct soap *soap, sp__Elements const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "sp:Elements", p->soap_type() == SOAP_TYPE_sp__Elements ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_sp__Elements(struct soap *soap, const char *URL, sp__Elements const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "sp:Elements", p->soap_type() == SOAP_TYPE_sp__Elements ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_sp__Elements(struct soap *soap, const char *URL, sp__Elements const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "sp:Elements", p->soap_type() == SOAP_TYPE_sp__Elements ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_sp__Elements(struct soap *soap, const char *URL, sp__Elements const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "sp:Elements", p->soap_type() == SOAP_TYPE_sp__Elements ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 sp__Elements * SOAP_FMAC4 soap_get_sp__Elements(struct soap*, sp__Elements *, const char*, const char*);

inline int soap_read_sp__Elements(struct soap *soap, sp__Elements *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_sp__Elements(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_sp__Elements(struct soap *soap, const char *URL, sp__Elements *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_sp__Elements(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_sp__Elements(struct soap *soap, sp__Elements *p)
{
	if (::soap_read_sp__Elements(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_sp__Parts_DEFINED
#define SOAP_TYPE_sp__Parts_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_sp__Parts(struct soap*, const char*, int, const sp__Parts *, const char*);
SOAP_FMAC3 sp__Parts * SOAP_FMAC4 soap_in_sp__Parts(struct soap*, const char*, sp__Parts *, const char*);
SOAP_FMAC1 sp__Parts * SOAP_FMAC2 wsdl_instantiate_sp__Parts(struct soap*, int, const char*, const char*, size_t*);

inline sp__Parts * soap_new_sp__Parts(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_sp__Parts(soap, n, NULL, NULL, NULL);
}

inline sp__Parts * soap_new_req_sp__Parts(
	struct soap *soap)
{
	sp__Parts *_p = ::soap_new_sp__Parts(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline sp__Parts * soap_new_set_sp__Parts(
	struct soap *soap,
	char *Body,
	const std::vector<sp__Header> & Header,
	char *Attachments)
{
	sp__Parts *_p = ::soap_new_sp__Parts(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->sp__Parts::Body = Body;
		_p->sp__Parts::Header = Header;
		_p->sp__Parts::Attachments = Attachments;
	}
	return _p;
}

inline int soap_write_sp__Parts(struct soap *soap, sp__Parts const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "sp:Parts", p->soap_type() == SOAP_TYPE_sp__Parts ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_sp__Parts(struct soap *soap, const char *URL, sp__Parts const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "sp:Parts", p->soap_type() == SOAP_TYPE_sp__Parts ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_sp__Parts(struct soap *soap, const char *URL, sp__Parts const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "sp:Parts", p->soap_type() == SOAP_TYPE_sp__Parts ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_sp__Parts(struct soap *soap, const char *URL, sp__Parts const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "sp:Parts", p->soap_type() == SOAP_TYPE_sp__Parts ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 sp__Parts * SOAP_FMAC4 soap_get_sp__Parts(struct soap*, sp__Parts *, const char*, const char*);

inline int soap_read_sp__Parts(struct soap *soap, sp__Parts *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_sp__Parts(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_sp__Parts(struct soap *soap, const char *URL, sp__Parts *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_sp__Parts(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_sp__Parts(struct soap *soap, sp__Parts *p)
{
	if (::soap_read_sp__Parts(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_sp__Header_DEFINED
#define SOAP_TYPE_sp__Header_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_sp__Header(struct soap*, const char*, int, const sp__Header *, const char*);
SOAP_FMAC3 sp__Header * SOAP_FMAC4 soap_in_sp__Header(struct soap*, const char*, sp__Header *, const char*);
SOAP_FMAC1 sp__Header * SOAP_FMAC2 wsdl_instantiate_sp__Header(struct soap*, int, const char*, const char*, size_t*);

inline sp__Header * soap_new_sp__Header(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_sp__Header(soap, n, NULL, NULL, NULL);
}

inline sp__Header * soap_new_req_sp__Header(
	struct soap *soap)
{
	sp__Header *_p = ::soap_new_sp__Header(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline sp__Header * soap_new_set_sp__Header(
	struct soap *soap,
	char *Name,
	char *Namespace)
{
	sp__Header *_p = ::soap_new_sp__Header(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->sp__Header::Name = Name;
		_p->sp__Header::Namespace = Namespace;
	}
	return _p;
}

inline int soap_write_sp__Header(struct soap *soap, sp__Header const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "sp:Header", p->soap_type() == SOAP_TYPE_sp__Header ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_sp__Header(struct soap *soap, const char *URL, sp__Header const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "sp:Header", p->soap_type() == SOAP_TYPE_sp__Header ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_sp__Header(struct soap *soap, const char *URL, sp__Header const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "sp:Header", p->soap_type() == SOAP_TYPE_sp__Header ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_sp__Header(struct soap *soap, const char *URL, sp__Header const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "sp:Header", p->soap_type() == SOAP_TYPE_sp__Header ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 sp__Header * SOAP_FMAC4 soap_get_sp__Header(struct soap*, sp__Header *, const char*, const char*);

inline int soap_read_sp__Header(struct soap *soap, sp__Header *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_sp__Header(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_sp__Header(struct soap *soap, const char *URL, sp__Header *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_sp__Header(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_sp__Header(struct soap *soap, sp__Header *p)
{
	if (::soap_read_sp__Header(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_wst__Claims_DEFINED
#define SOAP_TYPE_wst__Claims_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_wst__Claims(struct soap*, const char*, int, const wst__Claims *, const char*);
SOAP_FMAC3 wst__Claims * SOAP_FMAC4 soap_in_wst__Claims(struct soap*, const char*, wst__Claims *, const char*);
SOAP_FMAC1 wst__Claims * SOAP_FMAC2 wsdl_instantiate_wst__Claims(struct soap*, int, const char*, const char*, size_t*);

inline wst__Claims * soap_new_wst__Claims(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_wst__Claims(soap, n, NULL, NULL, NULL);
}

inline wst__Claims * soap_new_req_wst__Claims(
	struct soap *soap)
{
	wst__Claims *_p = ::soap_new_wst__Claims(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline wst__Claims * soap_new_set_wst__Claims(
	struct soap *soap,
	char *Dialect,
	char *__item)
{
	wst__Claims *_p = ::soap_new_wst__Claims(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wst__Claims::Dialect = Dialect;
		_p->wst__Claims::__item = __item;
	}
	return _p;
}

inline int soap_write_wst__Claims(struct soap *soap, wst__Claims const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wst:Claims", p->soap_type() == SOAP_TYPE_wst__Claims ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_wst__Claims(struct soap *soap, const char *URL, wst__Claims const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wst:Claims", p->soap_type() == SOAP_TYPE_wst__Claims ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_wst__Claims(struct soap *soap, const char *URL, wst__Claims const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wst:Claims", p->soap_type() == SOAP_TYPE_wst__Claims ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_wst__Claims(struct soap *soap, const char *URL, wst__Claims const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wst:Claims", p->soap_type() == SOAP_TYPE_wst__Claims ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 wst__Claims * SOAP_FMAC4 soap_get_wst__Claims(struct soap*, wst__Claims *, const char*, const char*);

inline int soap_read_wst__Claims(struct soap *soap, wst__Claims *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_wst__Claims(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_wst__Claims(struct soap *soap, const char *URL, wst__Claims *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_wst__Claims(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_wst__Claims(struct soap *soap, wst__Claims *p)
{
	if (::soap_read_wst__Claims(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_wsp__Assertion_DEFINED
#define SOAP_TYPE_wsp__Assertion_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsp__Assertion(struct soap*, const char*, int, const wsp__Assertion *, const char*);
SOAP_FMAC3 wsp__Assertion * SOAP_FMAC4 soap_in_wsp__Assertion(struct soap*, const char*, wsp__Assertion *, const char*);
SOAP_FMAC1 wsp__Assertion * SOAP_FMAC2 wsdl_instantiate_wsp__Assertion(struct soap*, int, const char*, const char*, size_t*);

inline wsp__Assertion * soap_new_wsp__Assertion(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_wsp__Assertion(soap, n, NULL, NULL, NULL);
}

inline wsp__Assertion * soap_new_req_wsp__Assertion(
	struct soap *soap)
{
	wsp__Assertion *_p = ::soap_new_wsp__Assertion(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline wsp__Assertion * soap_new_set_wsp__Assertion(
	struct soap *soap,
	bool Optional,
	bool Ignorable,
	wsp__Content *Policy)
{
	wsp__Assertion *_p = ::soap_new_wsp__Assertion(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wsp__Assertion::Optional = Optional;
		_p->wsp__Assertion::Ignorable = Ignorable;
		_p->wsp__Assertion::Policy = Policy;
	}
	return _p;
}

inline int soap_write_wsp__Assertion(struct soap *soap, wsp__Assertion const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsp:Assertion", p->soap_type() == SOAP_TYPE_wsp__Assertion ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_wsp__Assertion(struct soap *soap, const char *URL, wsp__Assertion const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsp:Assertion", p->soap_type() == SOAP_TYPE_wsp__Assertion ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_wsp__Assertion(struct soap *soap, const char *URL, wsp__Assertion const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsp:Assertion", p->soap_type() == SOAP_TYPE_wsp__Assertion ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_wsp__Assertion(struct soap *soap, const char *URL, wsp__Assertion const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsp:Assertion", p->soap_type() == SOAP_TYPE_wsp__Assertion ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 wsp__Assertion * SOAP_FMAC4 soap_get_wsp__Assertion(struct soap*, wsp__Assertion *, const char*, const char*);

inline int soap_read_wsp__Assertion(struct soap *soap, wsp__Assertion *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_wsp__Assertion(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_wsp__Assertion(struct soap *soap, const char *URL, wsp__Assertion *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_wsp__Assertion(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_wsp__Assertion(struct soap *soap, wsp__Assertion *p)
{
	if (::soap_read_wsp__Assertion(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_wsp__PolicyReference_DEFINED
#define SOAP_TYPE_wsp__PolicyReference_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsp__PolicyReference(struct soap*, const char*, int, const wsp__PolicyReference *, const char*);
SOAP_FMAC3 wsp__PolicyReference * SOAP_FMAC4 soap_in_wsp__PolicyReference(struct soap*, const char*, wsp__PolicyReference *, const char*);
SOAP_FMAC1 wsp__PolicyReference * SOAP_FMAC2 wsdl_instantiate_wsp__PolicyReference(struct soap*, int, const char*, const char*, size_t*);

inline wsp__PolicyReference * soap_new_wsp__PolicyReference(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_wsp__PolicyReference(soap, n, NULL, NULL, NULL);
}

inline wsp__PolicyReference * soap_new_req_wsp__PolicyReference(
	struct soap *soap)
{
	wsp__PolicyReference *_p = ::soap_new_wsp__PolicyReference(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline wsp__PolicyReference * soap_new_set_wsp__PolicyReference(
	struct soap *soap,
	char *URI,
	char *Digest,
	char *DigestAlgorithm)
{
	wsp__PolicyReference *_p = ::soap_new_wsp__PolicyReference(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wsp__PolicyReference::URI = URI;
		_p->wsp__PolicyReference::Digest = Digest;
		_p->wsp__PolicyReference::DigestAlgorithm = DigestAlgorithm;
	}
	return _p;
}

inline int soap_write_wsp__PolicyReference(struct soap *soap, wsp__PolicyReference const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsp:PolicyReference", p->soap_type() == SOAP_TYPE_wsp__PolicyReference ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_wsp__PolicyReference(struct soap *soap, const char *URL, wsp__PolicyReference const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsp:PolicyReference", p->soap_type() == SOAP_TYPE_wsp__PolicyReference ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_wsp__PolicyReference(struct soap *soap, const char *URL, wsp__PolicyReference const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsp:PolicyReference", p->soap_type() == SOAP_TYPE_wsp__PolicyReference ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_wsp__PolicyReference(struct soap *soap, const char *URL, wsp__PolicyReference const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsp:PolicyReference", p->soap_type() == SOAP_TYPE_wsp__PolicyReference ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 wsp__PolicyReference * SOAP_FMAC4 soap_get_wsp__PolicyReference(struct soap*, wsp__PolicyReference *, const char*, const char*);

inline int soap_read_wsp__PolicyReference(struct soap *soap, wsp__PolicyReference *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_wsp__PolicyReference(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_wsp__PolicyReference(struct soap *soap, const char *URL, wsp__PolicyReference *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_wsp__PolicyReference(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_wsp__PolicyReference(struct soap *soap, wsp__PolicyReference *p)
{
	if (::soap_read_wsp__PolicyReference(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_wsp__Content_DEFINED
#define SOAP_TYPE_wsp__Content_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsp__Content(struct soap*, const char*, int, const wsp__Content *, const char*);
SOAP_FMAC3 wsp__Content * SOAP_FMAC4 soap_in_wsp__Content(struct soap*, const char*, wsp__Content *, const char*);
SOAP_FMAC1 wsp__Content * SOAP_FMAC2 wsdl_instantiate_wsp__Content(struct soap*, int, const char*, const char*, size_t*);

inline wsp__Content * soap_new_wsp__Content(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_wsp__Content(soap, n, NULL, NULL, NULL);
}

inline wsp__Content * soap_new_req_wsp__Content(
	struct soap *soap)
{
	wsp__Content *_p = ::soap_new_wsp__Content(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline wsp__Content * soap_new_set_wsp__Content(
	struct soap *soap,
	wsp__Policy *Policy,
	wsp__PolicyReference *PolicyReference,
	const std::vector<wsp__Content *> & All,
	const std::vector<wsp__Content *> & ExactlyOne,
	const std::vector<sp__Parts> & sp__SignedParts,
	const std::vector<sp__Parts> & sp__EncryptedParts,
	const std::vector<sp__Parts> & sp__RequiredParts,
	sp__Elements *sp__SignedElements,
	sp__Elements *sp__EncryptedElements,
	sp__Elements *sp__ContentEncryptedElements,
	sp__Elements *sp__RequiredElements,
	sp__Token *sp__UsernameToken,
	sp__Token *sp__IssuedToken,
	sp__Token *sp__X509Token,
	sp__Token *sp__KerberosToken,
	sp__Token *sp__SpnegoContextToken,
	sp__Token *sp__SecurityContextToken,
	sp__Token *sp__SecureConversationToken,
	sp__Token *sp__SamlToken,
	sp__Token *sp__RelToken,
	sp__Token *sp__HttpsToken,
	sp__Token *sp__KeyValueToken,
	wsp__Assertion *sp__TransportBinding,
	wsp__Assertion *sp__TransportToken,
	wsp__Assertion *sp__AlgorithmSuite,
	wsp__Assertion *sp__Layout,
	wsp__Assertion *sp__SymmetricBinding,
	wsp__Assertion *sp__AsymmetricBinding,
	wsp__Assertion *sp__ProtectionToken,
	wsp__Assertion *sp__InitiatorToken,
	wsp__Assertion *sp__InitiatorSignatureToken,
	wsp__Assertion *sp__InitiatorEncryptionToken,
	wsp__Assertion *sp__RecipientToken,
	wsp__Assertion *sp__SupportingTokens,
	wsp__Assertion *sp__SignedSupportingTokens,
	wsp__Assertion *sp__EndorsingSupportingTokens,
	wsp__Assertion *sp__SignedEndorsingSupportingTokens,
	wsp__Assertion *sp__SignedEncryptedSupportingTokens,
	wsp__Assertion *sp__EncryptedSupportingTokens,
	wsp__Assertion *sp__EndorsingEncryptedSupportingTokens,
	wsp__Assertion *sp__SignedEndorsingEncryptedSupportingTokens,
	wsp__Assertion *sp__Wss10,
	wsp__Assertion *sp__Wss11,
	wsp__Assertion *sp__Trust10,
	wsp__Assertion *sp__Trust13,
	wsp__Content *sp__BootstrapPolicy,
	char *wsaw__UsingAddressing,
	wsp__Assertion *wsam__Addressing,
	wsrmp__RMAssertion *wsrmp__RMAssertion_,
	wsrmp__RMAssertion *wsrmp__DeliveryAssurance,
	char *wsrmp__AtLeastOnce,
	char *wsrmp__AtMostOnce,
	char *wsrmp__ExactlyOnce,
	char *wsrmp__InOrder,
	wsrmp5__RMAssertion *wsrmp5__RMAssertion_,
	wsrmp5__RMAssertion *wsrmp5__DeliveryAssurance,
	char *wsrmp5__AtLeastOnce,
	char *wsrmp5__AtMostOnce,
	char *wsrmp5__ExactlyOnce,
	char *wsrmp5__InOrder,
	wsp__Assertion *sp__NoPassword,
	wsp__Assertion *sp__HashPassword,
	wsp__Assertion *sp__IncludeTimestamp,
	wsp__Assertion *sp__EncryptBeforeSigning,
	wsp__Assertion *sp__EncryptSignature,
	wsp__Assertion *sp__ProtectTokens,
	wsp__Assertion *sp__OnlySignEntireHeadersAndBody,
	char *sp__RequireDerivedKeys,
	char *sp__RequireImpliedDerivedKeys,
	char *sp__RequireExplicitDerivedKeys,
	char *sp__WssUsernameToken10,
	char *sp__WssUsernameToken11,
	char *sp__RequireExternalReference,
	char *sp__RequireInternalReference,
	char *sp__RequireKeyIdentifierReference,
	char *sp__RequireIssuerSerialReference,
	char *sp__RequireEmbeddedTokenReference,
	char *sp__RequireThumbprintReference,
	char *sp__WssX509V3Token10,
	char *sp__WssX509Pkcs7Token10,
	char *sp__WssX509PkiPathV1Token10,
	char *sp__WssX509V1Token11,
	char *sp__WssX509V3Token11,
	char *sp__WssX509Pkcs7Token11,
	char *sp__WssX509PkiPathV1Token11,
	char *sp__WssKerberosV5ApReqToken11,
	char *sp__WssGssKerberosV5ApReqToken11,
	char *sp__WssRelV10Token10,
	char *sp__WssRelV20Token10,
	char *sp__WssRelV10Token11,
	char *sp__WssRelV20Token11,
	char *sp__MustNotSendCancel,
	char *sp__MustNotSendAmend,
	char *sp__MustNotSendRenew,
	char *sp__MustSupportRefKeyIdentifier,
	char *sp__MustSupportRefIssuerSerial,
	char *sp__MustSupportRefExternalURI,
	char *sp__MustSupportRefEmbeddedToken,
	char *sp__MustSupportRefThumbprint,
	char *sp__MustSupportRefEncryptedKey,
	char *sp__RequireSignatureConfirmation,
	char *sp__MustSupportClientChallenge,
	char *sp__MustSupportServerChallenge,
	char *sp__RequireClientEntropy,
	char *sp__RequireServerEntropy,
	char *sp__MustSupportIssuedTokens,
	char *sp__RequireRequestSecurityTokenCollection,
	char *sp__RequireAppliesTo,
	char *sp__RequireExternalUriReference,
	char *sp__SC13SecurityContextToken,
	char *sp__Strict,
	char *sp__Lax,
	char *sp__LaxTsFirst,
	char *sp__LaxTsLast,
	char *sp__HttpBasicAuthentication,
	char *sp__HttpDigestAuthentication,
	char *sp__RequireClientCertificate,
	char *sp__Basic256,
	char *sp__Basic192,
	char *sp__Basic128,
	char *sp__TripleDes,
	char *sp__Basic256Rsa15,
	char *sp__Basic192Rsa15,
	char *sp__Basic128Rsa15,
	char *sp__TripleDesRsa15,
	char *sp__Basic256Sha256,
	char *sp__Basic192Sha256,
	char *sp__Basic128Sha256,
	char *sp__TripleDesSha256,
	char *sp__Basic256Sha256Rsa15,
	char *sp__Basic192Sha256Rsa15,
	char *sp__Basic128Sha256Rsa15,
	char *sp__TripleDesSha256Rsa15,
	char *sp__InclusiveC14N,
	char *sp__SOAPNormalization10,
	char *sp__STRTransform10,
	char *sp__Path10,
	char *sp__XPathFilter20,
	char *sp__AbsXPath,
	char *wsam__AnonymousResponses,
	char *wsam__NonAnonymousResponses,
	const std::vector<char *> & __any)
{
	wsp__Content *_p = ::soap_new_wsp__Content(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wsp__Content::Policy = Policy;
		_p->wsp__Content::PolicyReference = PolicyReference;
		_p->wsp__Content::All = All;
		_p->wsp__Content::ExactlyOne = ExactlyOne;
		_p->wsp__Content::sp__SignedParts = sp__SignedParts;
		_p->wsp__Content::sp__EncryptedParts = sp__EncryptedParts;
		_p->wsp__Content::sp__RequiredParts = sp__RequiredParts;
		_p->wsp__Content::sp__SignedElements = sp__SignedElements;
		_p->wsp__Content::sp__EncryptedElements = sp__EncryptedElements;
		_p->wsp__Content::sp__ContentEncryptedElements = sp__ContentEncryptedElements;
		_p->wsp__Content::sp__RequiredElements = sp__RequiredElements;
		_p->wsp__Content::sp__UsernameToken = sp__UsernameToken;
		_p->wsp__Content::sp__IssuedToken = sp__IssuedToken;
		_p->wsp__Content::sp__X509Token = sp__X509Token;
		_p->wsp__Content::sp__KerberosToken = sp__KerberosToken;
		_p->wsp__Content::sp__SpnegoContextToken = sp__SpnegoContextToken;
		_p->wsp__Content::sp__SecurityContextToken = sp__SecurityContextToken;
		_p->wsp__Content::sp__SecureConversationToken = sp__SecureConversationToken;
		_p->wsp__Content::sp__SamlToken = sp__SamlToken;
		_p->wsp__Content::sp__RelToken = sp__RelToken;
		_p->wsp__Content::sp__HttpsToken = sp__HttpsToken;
		_p->wsp__Content::sp__KeyValueToken = sp__KeyValueToken;
		_p->wsp__Content::sp__TransportBinding = sp__TransportBinding;
		_p->wsp__Content::sp__TransportToken = sp__TransportToken;
		_p->wsp__Content::sp__AlgorithmSuite = sp__AlgorithmSuite;
		_p->wsp__Content::sp__Layout = sp__Layout;
		_p->wsp__Content::sp__SymmetricBinding = sp__SymmetricBinding;
		_p->wsp__Content::sp__AsymmetricBinding = sp__AsymmetricBinding;
		_p->wsp__Content::sp__ProtectionToken = sp__ProtectionToken;
		_p->wsp__Content::sp__InitiatorToken = sp__InitiatorToken;
		_p->wsp__Content::sp__InitiatorSignatureToken = sp__InitiatorSignatureToken;
		_p->wsp__Content::sp__InitiatorEncryptionToken = sp__InitiatorEncryptionToken;
		_p->wsp__Content::sp__RecipientToken = sp__RecipientToken;
		_p->wsp__Content::sp__SupportingTokens = sp__SupportingTokens;
		_p->wsp__Content::sp__SignedSupportingTokens = sp__SignedSupportingTokens;
		_p->wsp__Content::sp__EndorsingSupportingTokens = sp__EndorsingSupportingTokens;
		_p->wsp__Content::sp__SignedEndorsingSupportingTokens = sp__SignedEndorsingSupportingTokens;
		_p->wsp__Content::sp__SignedEncryptedSupportingTokens = sp__SignedEncryptedSupportingTokens;
		_p->wsp__Content::sp__EncryptedSupportingTokens = sp__EncryptedSupportingTokens;
		_p->wsp__Content::sp__EndorsingEncryptedSupportingTokens = sp__EndorsingEncryptedSupportingTokens;
		_p->wsp__Content::sp__SignedEndorsingEncryptedSupportingTokens = sp__SignedEndorsingEncryptedSupportingTokens;
		_p->wsp__Content::sp__Wss10 = sp__Wss10;
		_p->wsp__Content::sp__Wss11 = sp__Wss11;
		_p->wsp__Content::sp__Trust10 = sp__Trust10;
		_p->wsp__Content::sp__Trust13 = sp__Trust13;
		_p->wsp__Content::sp__BootstrapPolicy = sp__BootstrapPolicy;
		_p->wsp__Content::wsaw__UsingAddressing = wsaw__UsingAddressing;
		_p->wsp__Content::wsam__Addressing = wsam__Addressing;
		_p->wsp__Content::wsrmp__RMAssertion_ = wsrmp__RMAssertion_;
		_p->wsp__Content::wsrmp__DeliveryAssurance = wsrmp__DeliveryAssurance;
		_p->wsp__Content::wsrmp__AtLeastOnce = wsrmp__AtLeastOnce;
		_p->wsp__Content::wsrmp__AtMostOnce = wsrmp__AtMostOnce;
		_p->wsp__Content::wsrmp__ExactlyOnce = wsrmp__ExactlyOnce;
		_p->wsp__Content::wsrmp__InOrder = wsrmp__InOrder;
		_p->wsp__Content::wsrmp5__RMAssertion_ = wsrmp5__RMAssertion_;
		_p->wsp__Content::wsrmp5__DeliveryAssurance = wsrmp5__DeliveryAssurance;
		_p->wsp__Content::wsrmp5__AtLeastOnce = wsrmp5__AtLeastOnce;
		_p->wsp__Content::wsrmp5__AtMostOnce = wsrmp5__AtMostOnce;
		_p->wsp__Content::wsrmp5__ExactlyOnce = wsrmp5__ExactlyOnce;
		_p->wsp__Content::wsrmp5__InOrder = wsrmp5__InOrder;
		_p->wsp__Content::sp__NoPassword = sp__NoPassword;
		_p->wsp__Content::sp__HashPassword = sp__HashPassword;
		_p->wsp__Content::sp__IncludeTimestamp = sp__IncludeTimestamp;
		_p->wsp__Content::sp__EncryptBeforeSigning = sp__EncryptBeforeSigning;
		_p->wsp__Content::sp__EncryptSignature = sp__EncryptSignature;
		_p->wsp__Content::sp__ProtectTokens = sp__ProtectTokens;
		_p->wsp__Content::sp__OnlySignEntireHeadersAndBody = sp__OnlySignEntireHeadersAndBody;
		_p->wsp__Content::sp__RequireDerivedKeys = sp__RequireDerivedKeys;
		_p->wsp__Content::sp__RequireImpliedDerivedKeys = sp__RequireImpliedDerivedKeys;
		_p->wsp__Content::sp__RequireExplicitDerivedKeys = sp__RequireExplicitDerivedKeys;
		_p->wsp__Content::sp__WssUsernameToken10 = sp__WssUsernameToken10;
		_p->wsp__Content::sp__WssUsernameToken11 = sp__WssUsernameToken11;
		_p->wsp__Content::sp__RequireExternalReference = sp__RequireExternalReference;
		_p->wsp__Content::sp__RequireInternalReference = sp__RequireInternalReference;
		_p->wsp__Content::sp__RequireKeyIdentifierReference = sp__RequireKeyIdentifierReference;
		_p->wsp__Content::sp__RequireIssuerSerialReference = sp__RequireIssuerSerialReference;
		_p->wsp__Content::sp__RequireEmbeddedTokenReference = sp__RequireEmbeddedTokenReference;
		_p->wsp__Content::sp__RequireThumbprintReference = sp__RequireThumbprintReference;
		_p->wsp__Content::sp__WssX509V3Token10 = sp__WssX509V3Token10;
		_p->wsp__Content::sp__WssX509Pkcs7Token10 = sp__WssX509Pkcs7Token10;
		_p->wsp__Content::sp__WssX509PkiPathV1Token10 = sp__WssX509PkiPathV1Token10;
		_p->wsp__Content::sp__WssX509V1Token11 = sp__WssX509V1Token11;
		_p->wsp__Content::sp__WssX509V3Token11 = sp__WssX509V3Token11;
		_p->wsp__Content::sp__WssX509Pkcs7Token11 = sp__WssX509Pkcs7Token11;
		_p->wsp__Content::sp__WssX509PkiPathV1Token11 = sp__WssX509PkiPathV1Token11;
		_p->wsp__Content::sp__WssKerberosV5ApReqToken11 = sp__WssKerberosV5ApReqToken11;
		_p->wsp__Content::sp__WssGssKerberosV5ApReqToken11 = sp__WssGssKerberosV5ApReqToken11;
		_p->wsp__Content::sp__WssRelV10Token10 = sp__WssRelV10Token10;
		_p->wsp__Content::sp__WssRelV20Token10 = sp__WssRelV20Token10;
		_p->wsp__Content::sp__WssRelV10Token11 = sp__WssRelV10Token11;
		_p->wsp__Content::sp__WssRelV20Token11 = sp__WssRelV20Token11;
		_p->wsp__Content::sp__MustNotSendCancel = sp__MustNotSendCancel;
		_p->wsp__Content::sp__MustNotSendAmend = sp__MustNotSendAmend;
		_p->wsp__Content::sp__MustNotSendRenew = sp__MustNotSendRenew;
		_p->wsp__Content::sp__MustSupportRefKeyIdentifier = sp__MustSupportRefKeyIdentifier;
		_p->wsp__Content::sp__MustSupportRefIssuerSerial = sp__MustSupportRefIssuerSerial;
		_p->wsp__Content::sp__MustSupportRefExternalURI = sp__MustSupportRefExternalURI;
		_p->wsp__Content::sp__MustSupportRefEmbeddedToken = sp__MustSupportRefEmbeddedToken;
		_p->wsp__Content::sp__MustSupportRefThumbprint = sp__MustSupportRefThumbprint;
		_p->wsp__Content::sp__MustSupportRefEncryptedKey = sp__MustSupportRefEncryptedKey;
		_p->wsp__Content::sp__RequireSignatureConfirmation = sp__RequireSignatureConfirmation;
		_p->wsp__Content::sp__MustSupportClientChallenge = sp__MustSupportClientChallenge;
		_p->wsp__Content::sp__MustSupportServerChallenge = sp__MustSupportServerChallenge;
		_p->wsp__Content::sp__RequireClientEntropy = sp__RequireClientEntropy;
		_p->wsp__Content::sp__RequireServerEntropy = sp__RequireServerEntropy;
		_p->wsp__Content::sp__MustSupportIssuedTokens = sp__MustSupportIssuedTokens;
		_p->wsp__Content::sp__RequireRequestSecurityTokenCollection = sp__RequireRequestSecurityTokenCollection;
		_p->wsp__Content::sp__RequireAppliesTo = sp__RequireAppliesTo;
		_p->wsp__Content::sp__RequireExternalUriReference = sp__RequireExternalUriReference;
		_p->wsp__Content::sp__SC13SecurityContextToken = sp__SC13SecurityContextToken;
		_p->wsp__Content::sp__Strict = sp__Strict;
		_p->wsp__Content::sp__Lax = sp__Lax;
		_p->wsp__Content::sp__LaxTsFirst = sp__LaxTsFirst;
		_p->wsp__Content::sp__LaxTsLast = sp__LaxTsLast;
		_p->wsp__Content::sp__HttpBasicAuthentication = sp__HttpBasicAuthentication;
		_p->wsp__Content::sp__HttpDigestAuthentication = sp__HttpDigestAuthentication;
		_p->wsp__Content::sp__RequireClientCertificate = sp__RequireClientCertificate;
		_p->wsp__Content::sp__Basic256 = sp__Basic256;
		_p->wsp__Content::sp__Basic192 = sp__Basic192;
		_p->wsp__Content::sp__Basic128 = sp__Basic128;
		_p->wsp__Content::sp__TripleDes = sp__TripleDes;
		_p->wsp__Content::sp__Basic256Rsa15 = sp__Basic256Rsa15;
		_p->wsp__Content::sp__Basic192Rsa15 = sp__Basic192Rsa15;
		_p->wsp__Content::sp__Basic128Rsa15 = sp__Basic128Rsa15;
		_p->wsp__Content::sp__TripleDesRsa15 = sp__TripleDesRsa15;
		_p->wsp__Content::sp__Basic256Sha256 = sp__Basic256Sha256;
		_p->wsp__Content::sp__Basic192Sha256 = sp__Basic192Sha256;
		_p->wsp__Content::sp__Basic128Sha256 = sp__Basic128Sha256;
		_p->wsp__Content::sp__TripleDesSha256 = sp__TripleDesSha256;
		_p->wsp__Content::sp__Basic256Sha256Rsa15 = sp__Basic256Sha256Rsa15;
		_p->wsp__Content::sp__Basic192Sha256Rsa15 = sp__Basic192Sha256Rsa15;
		_p->wsp__Content::sp__Basic128Sha256Rsa15 = sp__Basic128Sha256Rsa15;
		_p->wsp__Content::sp__TripleDesSha256Rsa15 = sp__TripleDesSha256Rsa15;
		_p->wsp__Content::sp__InclusiveC14N = sp__InclusiveC14N;
		_p->wsp__Content::sp__SOAPNormalization10 = sp__SOAPNormalization10;
		_p->wsp__Content::sp__STRTransform10 = sp__STRTransform10;
		_p->wsp__Content::sp__Path10 = sp__Path10;
		_p->wsp__Content::sp__XPathFilter20 = sp__XPathFilter20;
		_p->wsp__Content::sp__AbsXPath = sp__AbsXPath;
		_p->wsp__Content::wsam__AnonymousResponses = wsam__AnonymousResponses;
		_p->wsp__Content::wsam__NonAnonymousResponses = wsam__NonAnonymousResponses;
		_p->wsp__Content::__any = __any;
	}
	return _p;
}

inline int soap_write_wsp__Content(struct soap *soap, wsp__Content const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsp:Content", p->soap_type() == SOAP_TYPE_wsp__Content ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_wsp__Content(struct soap *soap, const char *URL, wsp__Content const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsp:Content", p->soap_type() == SOAP_TYPE_wsp__Content ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_wsp__Content(struct soap *soap, const char *URL, wsp__Content const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsp:Content", p->soap_type() == SOAP_TYPE_wsp__Content ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_wsp__Content(struct soap *soap, const char *URL, wsp__Content const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsp:Content", p->soap_type() == SOAP_TYPE_wsp__Content ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 wsp__Content * SOAP_FMAC4 soap_get_wsp__Content(struct soap*, wsp__Content *, const char*, const char*);

inline int soap_read_wsp__Content(struct soap *soap, wsp__Content *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_wsp__Content(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_wsp__Content(struct soap *soap, const char *URL, wsp__Content *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_wsp__Content(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_wsp__Content(struct soap *soap, wsp__Content *p)
{
	if (::soap_read_wsp__Content(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_wsp__Policy_DEFINED
#define SOAP_TYPE_wsp__Policy_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsp__Policy(struct soap*, const char*, int, const wsp__Policy *, const char*);
SOAP_FMAC3 wsp__Policy * SOAP_FMAC4 soap_in_wsp__Policy(struct soap*, const char*, wsp__Policy *, const char*);
SOAP_FMAC1 wsp__Policy * SOAP_FMAC2 wsdl_instantiate_wsp__Policy(struct soap*, int, const char*, const char*, size_t*);

inline wsp__Policy * soap_new_wsp__Policy(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_wsp__Policy(soap, n, NULL, NULL, NULL);
}

inline wsp__Policy * soap_new_req_wsp__Policy(
	struct soap *soap)
{
	wsp__Policy *_p = ::soap_new_wsp__Policy(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline wsp__Policy * soap_new_set_wsp__Policy(
	struct soap *soap,
	char *xml__base,
	char *wsu__Id,
	char *TargetNamespace,
	wsp__Policy *Policy__1,
	wsp__PolicyReference *PolicyReference__1,
	const std::vector<wsp__Content *> & All__1,
	const std::vector<wsp__Content *> & ExactlyOne__1,
	const std::vector<sp__Parts> & sp__SignedParts__1,
	const std::vector<sp__Parts> & sp__EncryptedParts__1,
	const std::vector<sp__Parts> & sp__RequiredParts__1,
	sp__Elements *sp__SignedElements__1,
	sp__Elements *sp__EncryptedElements__1,
	sp__Elements *sp__ContentEncryptedElements__1,
	sp__Elements *sp__RequiredElements__1,
	sp__Token *sp__UsernameToken__1,
	sp__Token *sp__IssuedToken__1,
	sp__Token *sp__X509Token__1,
	sp__Token *sp__KerberosToken__1,
	sp__Token *sp__SpnegoContextToken__1,
	sp__Token *sp__SecurityContextToken__1,
	sp__Token *sp__SecureConversationToken__1,
	sp__Token *sp__SamlToken__1,
	sp__Token *sp__RelToken__1,
	sp__Token *sp__HttpsToken__1,
	sp__Token *sp__KeyValueToken__1,
	wsp__Assertion *sp__TransportBinding__1,
	wsp__Assertion *sp__TransportToken__1,
	wsp__Assertion *sp__AlgorithmSuite__1,
	wsp__Assertion *sp__Layout__1,
	wsp__Assertion *sp__SymmetricBinding__1,
	wsp__Assertion *sp__AsymmetricBinding__1,
	wsp__Assertion *sp__ProtectionToken__1,
	wsp__Assertion *sp__InitiatorToken__1,
	wsp__Assertion *sp__InitiatorSignatureToken__1,
	wsp__Assertion *sp__InitiatorEncryptionToken__1,
	wsp__Assertion *sp__RecipientToken__1,
	wsp__Assertion *sp__SupportingTokens__1,
	wsp__Assertion *sp__SignedSupportingTokens__1,
	wsp__Assertion *sp__EndorsingSupportingTokens__1,
	wsp__Assertion *sp__SignedEndorsingSupportingTokens__1,
	wsp__Assertion *sp__SignedEncryptedSupportingTokens__1,
	wsp__Assertion *sp__EncryptedSupportingTokens__1,
	wsp__Assertion *sp__EndorsingEncryptedSupportingTokens__1,
	wsp__Assertion *sp__SignedEndorsingEncryptedSupportingTokens__1,
	wsp__Assertion *sp__Wss10__1,
	wsp__Assertion *sp__Wss11__1,
	wsp__Assertion *sp__Trust10__1,
	wsp__Assertion *sp__Trust13__1,
	wsp__Content *sp__BootstrapPolicy__1,
	char *wsaw__UsingAddressing__1,
	wsp__Assertion *wsam__Addressing__1,
	wsrmp__RMAssertion *wsrmp__RMAssertion___1,
	wsrmp__RMAssertion *wsrmp__DeliveryAssurance__1,
	char *wsrmp__AtLeastOnce__1,
	char *wsrmp__AtMostOnce__1,
	char *wsrmp__ExactlyOnce__1,
	char *wsrmp__InOrder__1,
	wsrmp5__RMAssertion *wsrmp5__RMAssertion___1,
	wsrmp5__RMAssertion *wsrmp5__DeliveryAssurance__1,
	char *wsrmp5__AtLeastOnce__1,
	char *wsrmp5__AtMostOnce__1,
	char *wsrmp5__ExactlyOnce__1,
	char *wsrmp5__InOrder__1,
	wsp__Assertion *sp__NoPassword__1,
	wsp__Assertion *sp__HashPassword__1,
	wsp__Assertion *sp__IncludeTimestamp__1,
	wsp__Assertion *sp__EncryptBeforeSigning__1,
	wsp__Assertion *sp__EncryptSignature__1,
	wsp__Assertion *sp__ProtectTokens__1,
	wsp__Assertion *sp__OnlySignEntireHeadersAndBody__1,
	char *sp__RequireDerivedKeys__1,
	char *sp__RequireImpliedDerivedKeys__1,
	char *sp__RequireExplicitDerivedKeys__1,
	char *sp__WssUsernameToken10__1,
	char *sp__WssUsernameToken11__1,
	char *sp__RequireExternalReference__1,
	char *sp__RequireInternalReference__1,
	char *sp__RequireKeyIdentifierReference__1,
	char *sp__RequireIssuerSerialReference__1,
	char *sp__RequireEmbeddedTokenReference__1,
	char *sp__RequireThumbprintReference__1,
	char *sp__WssX509V3Token10__1,
	char *sp__WssX509Pkcs7Token10__1,
	char *sp__WssX509PkiPathV1Token10__1,
	char *sp__WssX509V1Token11__1,
	char *sp__WssX509V3Token11__1,
	char *sp__WssX509Pkcs7Token11__1,
	char *sp__WssX509PkiPathV1Token11__1,
	char *sp__WssKerberosV5ApReqToken11__1,
	char *sp__WssGssKerberosV5ApReqToken11__1,
	char *sp__WssRelV10Token10__1,
	char *sp__WssRelV20Token10__1,
	char *sp__WssRelV10Token11__1,
	char *sp__WssRelV20Token11__1,
	char *sp__MustNotSendCancel__1,
	char *sp__MustNotSendAmend__1,
	char *sp__MustNotSendRenew__1,
	char *sp__MustSupportRefKeyIdentifier__1,
	char *sp__MustSupportRefIssuerSerial__1,
	char *sp__MustSupportRefExternalURI__1,
	char *sp__MustSupportRefEmbeddedToken__1,
	char *sp__MustSupportRefThumbprint__1,
	char *sp__MustSupportRefEncryptedKey__1,
	char *sp__RequireSignatureConfirmation__1,
	char *sp__MustSupportClientChallenge__1,
	char *sp__MustSupportServerChallenge__1,
	char *sp__RequireClientEntropy__1,
	char *sp__RequireServerEntropy__1,
	char *sp__MustSupportIssuedTokens__1,
	char *sp__RequireRequestSecurityTokenCollection__1,
	char *sp__RequireAppliesTo__1,
	char *sp__RequireExternalUriReference__1,
	char *sp__SC13SecurityContextToken__1,
	char *sp__Strict__1,
	char *sp__Lax__1,
	char *sp__LaxTsFirst__1,
	char *sp__LaxTsLast__1,
	char *sp__HttpBasicAuthentication__1,
	char *sp__HttpDigestAuthentication__1,
	char *sp__RequireClientCertificate__1,
	char *sp__Basic256__1,
	char *sp__Basic192__1,
	char *sp__Basic128__1,
	char *sp__TripleDes__1,
	char *sp__Basic256Rsa15__1,
	char *sp__Basic192Rsa15__1,
	char *sp__Basic128Rsa15__1,
	char *sp__TripleDesRsa15__1,
	char *sp__Basic256Sha256__1,
	char *sp__Basic192Sha256__1,
	char *sp__Basic128Sha256__1,
	char *sp__TripleDesSha256__1,
	char *sp__Basic256Sha256Rsa15__1,
	char *sp__Basic192Sha256Rsa15__1,
	char *sp__Basic128Sha256Rsa15__1,
	char *sp__TripleDesSha256Rsa15__1,
	char *sp__InclusiveC14N__1,
	char *sp__SOAPNormalization10__1,
	char *sp__STRTransform10__1,
	char *sp__Path10__1,
	char *sp__XPathFilter20__1,
	char *sp__AbsXPath__1,
	char *wsam__AnonymousResponses__1,
	char *wsam__NonAnonymousResponses__1,
	const std::vector<char *> & __any__1)
{
	wsp__Policy *_p = ::soap_new_wsp__Policy(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wsp__Policy::xml__base = xml__base;
		_p->wsp__Policy::wsu__Id = wsu__Id;
		_p->wsp__Policy::TargetNamespace = TargetNamespace;
		_p->wsp__Content::Policy = Policy__1;
		_p->wsp__Content::PolicyReference = PolicyReference__1;
		_p->wsp__Content::All = All__1;
		_p->wsp__Content::ExactlyOne = ExactlyOne__1;
		_p->wsp__Content::sp__SignedParts = sp__SignedParts__1;
		_p->wsp__Content::sp__EncryptedParts = sp__EncryptedParts__1;
		_p->wsp__Content::sp__RequiredParts = sp__RequiredParts__1;
		_p->wsp__Content::sp__SignedElements = sp__SignedElements__1;
		_p->wsp__Content::sp__EncryptedElements = sp__EncryptedElements__1;
		_p->wsp__Content::sp__ContentEncryptedElements = sp__ContentEncryptedElements__1;
		_p->wsp__Content::sp__RequiredElements = sp__RequiredElements__1;
		_p->wsp__Content::sp__UsernameToken = sp__UsernameToken__1;
		_p->wsp__Content::sp__IssuedToken = sp__IssuedToken__1;
		_p->wsp__Content::sp__X509Token = sp__X509Token__1;
		_p->wsp__Content::sp__KerberosToken = sp__KerberosToken__1;
		_p->wsp__Content::sp__SpnegoContextToken = sp__SpnegoContextToken__1;
		_p->wsp__Content::sp__SecurityContextToken = sp__SecurityContextToken__1;
		_p->wsp__Content::sp__SecureConversationToken = sp__SecureConversationToken__1;
		_p->wsp__Content::sp__SamlToken = sp__SamlToken__1;
		_p->wsp__Content::sp__RelToken = sp__RelToken__1;
		_p->wsp__Content::sp__HttpsToken = sp__HttpsToken__1;
		_p->wsp__Content::sp__KeyValueToken = sp__KeyValueToken__1;
		_p->wsp__Content::sp__TransportBinding = sp__TransportBinding__1;
		_p->wsp__Content::sp__TransportToken = sp__TransportToken__1;
		_p->wsp__Content::sp__AlgorithmSuite = sp__AlgorithmSuite__1;
		_p->wsp__Content::sp__Layout = sp__Layout__1;
		_p->wsp__Content::sp__SymmetricBinding = sp__SymmetricBinding__1;
		_p->wsp__Content::sp__AsymmetricBinding = sp__AsymmetricBinding__1;
		_p->wsp__Content::sp__ProtectionToken = sp__ProtectionToken__1;
		_p->wsp__Content::sp__InitiatorToken = sp__InitiatorToken__1;
		_p->wsp__Content::sp__InitiatorSignatureToken = sp__InitiatorSignatureToken__1;
		_p->wsp__Content::sp__InitiatorEncryptionToken = sp__InitiatorEncryptionToken__1;
		_p->wsp__Content::sp__RecipientToken = sp__RecipientToken__1;
		_p->wsp__Content::sp__SupportingTokens = sp__SupportingTokens__1;
		_p->wsp__Content::sp__SignedSupportingTokens = sp__SignedSupportingTokens__1;
		_p->wsp__Content::sp__EndorsingSupportingTokens = sp__EndorsingSupportingTokens__1;
		_p->wsp__Content::sp__SignedEndorsingSupportingTokens = sp__SignedEndorsingSupportingTokens__1;
		_p->wsp__Content::sp__SignedEncryptedSupportingTokens = sp__SignedEncryptedSupportingTokens__1;
		_p->wsp__Content::sp__EncryptedSupportingTokens = sp__EncryptedSupportingTokens__1;
		_p->wsp__Content::sp__EndorsingEncryptedSupportingTokens = sp__EndorsingEncryptedSupportingTokens__1;
		_p->wsp__Content::sp__SignedEndorsingEncryptedSupportingTokens = sp__SignedEndorsingEncryptedSupportingTokens__1;
		_p->wsp__Content::sp__Wss10 = sp__Wss10__1;
		_p->wsp__Content::sp__Wss11 = sp__Wss11__1;
		_p->wsp__Content::sp__Trust10 = sp__Trust10__1;
		_p->wsp__Content::sp__Trust13 = sp__Trust13__1;
		_p->wsp__Content::sp__BootstrapPolicy = sp__BootstrapPolicy__1;
		_p->wsp__Content::wsaw__UsingAddressing = wsaw__UsingAddressing__1;
		_p->wsp__Content::wsam__Addressing = wsam__Addressing__1;
		_p->wsp__Content::wsrmp__RMAssertion_ = wsrmp__RMAssertion___1;
		_p->wsp__Content::wsrmp__DeliveryAssurance = wsrmp__DeliveryAssurance__1;
		_p->wsp__Content::wsrmp__AtLeastOnce = wsrmp__AtLeastOnce__1;
		_p->wsp__Content::wsrmp__AtMostOnce = wsrmp__AtMostOnce__1;
		_p->wsp__Content::wsrmp__ExactlyOnce = wsrmp__ExactlyOnce__1;
		_p->wsp__Content::wsrmp__InOrder = wsrmp__InOrder__1;
		_p->wsp__Content::wsrmp5__RMAssertion_ = wsrmp5__RMAssertion___1;
		_p->wsp__Content::wsrmp5__DeliveryAssurance = wsrmp5__DeliveryAssurance__1;
		_p->wsp__Content::wsrmp5__AtLeastOnce = wsrmp5__AtLeastOnce__1;
		_p->wsp__Content::wsrmp5__AtMostOnce = wsrmp5__AtMostOnce__1;
		_p->wsp__Content::wsrmp5__ExactlyOnce = wsrmp5__ExactlyOnce__1;
		_p->wsp__Content::wsrmp5__InOrder = wsrmp5__InOrder__1;
		_p->wsp__Content::sp__NoPassword = sp__NoPassword__1;
		_p->wsp__Content::sp__HashPassword = sp__HashPassword__1;
		_p->wsp__Content::sp__IncludeTimestamp = sp__IncludeTimestamp__1;
		_p->wsp__Content::sp__EncryptBeforeSigning = sp__EncryptBeforeSigning__1;
		_p->wsp__Content::sp__EncryptSignature = sp__EncryptSignature__1;
		_p->wsp__Content::sp__ProtectTokens = sp__ProtectTokens__1;
		_p->wsp__Content::sp__OnlySignEntireHeadersAndBody = sp__OnlySignEntireHeadersAndBody__1;
		_p->wsp__Content::sp__RequireDerivedKeys = sp__RequireDerivedKeys__1;
		_p->wsp__Content::sp__RequireImpliedDerivedKeys = sp__RequireImpliedDerivedKeys__1;
		_p->wsp__Content::sp__RequireExplicitDerivedKeys = sp__RequireExplicitDerivedKeys__1;
		_p->wsp__Content::sp__WssUsernameToken10 = sp__WssUsernameToken10__1;
		_p->wsp__Content::sp__WssUsernameToken11 = sp__WssUsernameToken11__1;
		_p->wsp__Content::sp__RequireExternalReference = sp__RequireExternalReference__1;
		_p->wsp__Content::sp__RequireInternalReference = sp__RequireInternalReference__1;
		_p->wsp__Content::sp__RequireKeyIdentifierReference = sp__RequireKeyIdentifierReference__1;
		_p->wsp__Content::sp__RequireIssuerSerialReference = sp__RequireIssuerSerialReference__1;
		_p->wsp__Content::sp__RequireEmbeddedTokenReference = sp__RequireEmbeddedTokenReference__1;
		_p->wsp__Content::sp__RequireThumbprintReference = sp__RequireThumbprintReference__1;
		_p->wsp__Content::sp__WssX509V3Token10 = sp__WssX509V3Token10__1;
		_p->wsp__Content::sp__WssX509Pkcs7Token10 = sp__WssX509Pkcs7Token10__1;
		_p->wsp__Content::sp__WssX509PkiPathV1Token10 = sp__WssX509PkiPathV1Token10__1;
		_p->wsp__Content::sp__WssX509V1Token11 = sp__WssX509V1Token11__1;
		_p->wsp__Content::sp__WssX509V3Token11 = sp__WssX509V3Token11__1;
		_p->wsp__Content::sp__WssX509Pkcs7Token11 = sp__WssX509Pkcs7Token11__1;
		_p->wsp__Content::sp__WssX509PkiPathV1Token11 = sp__WssX509PkiPathV1Token11__1;
		_p->wsp__Content::sp__WssKerberosV5ApReqToken11 = sp__WssKerberosV5ApReqToken11__1;
		_p->wsp__Content::sp__WssGssKerberosV5ApReqToken11 = sp__WssGssKerberosV5ApReqToken11__1;
		_p->wsp__Content::sp__WssRelV10Token10 = sp__WssRelV10Token10__1;
		_p->wsp__Content::sp__WssRelV20Token10 = sp__WssRelV20Token10__1;
		_p->wsp__Content::sp__WssRelV10Token11 = sp__WssRelV10Token11__1;
		_p->wsp__Content::sp__WssRelV20Token11 = sp__WssRelV20Token11__1;
		_p->wsp__Content::sp__MustNotSendCancel = sp__MustNotSendCancel__1;
		_p->wsp__Content::sp__MustNotSendAmend = sp__MustNotSendAmend__1;
		_p->wsp__Content::sp__MustNotSendRenew = sp__MustNotSendRenew__1;
		_p->wsp__Content::sp__MustSupportRefKeyIdentifier = sp__MustSupportRefKeyIdentifier__1;
		_p->wsp__Content::sp__MustSupportRefIssuerSerial = sp__MustSupportRefIssuerSerial__1;
		_p->wsp__Content::sp__MustSupportRefExternalURI = sp__MustSupportRefExternalURI__1;
		_p->wsp__Content::sp__MustSupportRefEmbeddedToken = sp__MustSupportRefEmbeddedToken__1;
		_p->wsp__Content::sp__MustSupportRefThumbprint = sp__MustSupportRefThumbprint__1;
		_p->wsp__Content::sp__MustSupportRefEncryptedKey = sp__MustSupportRefEncryptedKey__1;
		_p->wsp__Content::sp__RequireSignatureConfirmation = sp__RequireSignatureConfirmation__1;
		_p->wsp__Content::sp__MustSupportClientChallenge = sp__MustSupportClientChallenge__1;
		_p->wsp__Content::sp__MustSupportServerChallenge = sp__MustSupportServerChallenge__1;
		_p->wsp__Content::sp__RequireClientEntropy = sp__RequireClientEntropy__1;
		_p->wsp__Content::sp__RequireServerEntropy = sp__RequireServerEntropy__1;
		_p->wsp__Content::sp__MustSupportIssuedTokens = sp__MustSupportIssuedTokens__1;
		_p->wsp__Content::sp__RequireRequestSecurityTokenCollection = sp__RequireRequestSecurityTokenCollection__1;
		_p->wsp__Content::sp__RequireAppliesTo = sp__RequireAppliesTo__1;
		_p->wsp__Content::sp__RequireExternalUriReference = sp__RequireExternalUriReference__1;
		_p->wsp__Content::sp__SC13SecurityContextToken = sp__SC13SecurityContextToken__1;
		_p->wsp__Content::sp__Strict = sp__Strict__1;
		_p->wsp__Content::sp__Lax = sp__Lax__1;
		_p->wsp__Content::sp__LaxTsFirst = sp__LaxTsFirst__1;
		_p->wsp__Content::sp__LaxTsLast = sp__LaxTsLast__1;
		_p->wsp__Content::sp__HttpBasicAuthentication = sp__HttpBasicAuthentication__1;
		_p->wsp__Content::sp__HttpDigestAuthentication = sp__HttpDigestAuthentication__1;
		_p->wsp__Content::sp__RequireClientCertificate = sp__RequireClientCertificate__1;
		_p->wsp__Content::sp__Basic256 = sp__Basic256__1;
		_p->wsp__Content::sp__Basic192 = sp__Basic192__1;
		_p->wsp__Content::sp__Basic128 = sp__Basic128__1;
		_p->wsp__Content::sp__TripleDes = sp__TripleDes__1;
		_p->wsp__Content::sp__Basic256Rsa15 = sp__Basic256Rsa15__1;
		_p->wsp__Content::sp__Basic192Rsa15 = sp__Basic192Rsa15__1;
		_p->wsp__Content::sp__Basic128Rsa15 = sp__Basic128Rsa15__1;
		_p->wsp__Content::sp__TripleDesRsa15 = sp__TripleDesRsa15__1;
		_p->wsp__Content::sp__Basic256Sha256 = sp__Basic256Sha256__1;
		_p->wsp__Content::sp__Basic192Sha256 = sp__Basic192Sha256__1;
		_p->wsp__Content::sp__Basic128Sha256 = sp__Basic128Sha256__1;
		_p->wsp__Content::sp__TripleDesSha256 = sp__TripleDesSha256__1;
		_p->wsp__Content::sp__Basic256Sha256Rsa15 = sp__Basic256Sha256Rsa15__1;
		_p->wsp__Content::sp__Basic192Sha256Rsa15 = sp__Basic192Sha256Rsa15__1;
		_p->wsp__Content::sp__Basic128Sha256Rsa15 = sp__Basic128Sha256Rsa15__1;
		_p->wsp__Content::sp__TripleDesSha256Rsa15 = sp__TripleDesSha256Rsa15__1;
		_p->wsp__Content::sp__InclusiveC14N = sp__InclusiveC14N__1;
		_p->wsp__Content::sp__SOAPNormalization10 = sp__SOAPNormalization10__1;
		_p->wsp__Content::sp__STRTransform10 = sp__STRTransform10__1;
		_p->wsp__Content::sp__Path10 = sp__Path10__1;
		_p->wsp__Content::sp__XPathFilter20 = sp__XPathFilter20__1;
		_p->wsp__Content::sp__AbsXPath = sp__AbsXPath__1;
		_p->wsp__Content::wsam__AnonymousResponses = wsam__AnonymousResponses__1;
		_p->wsp__Content::wsam__NonAnonymousResponses = wsam__NonAnonymousResponses__1;
		_p->wsp__Content::__any = __any__1;
	}
	return _p;
}

inline int soap_write_wsp__Policy(struct soap *soap, wsp__Policy const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsp:Policy", p->soap_type() == SOAP_TYPE_wsp__Policy ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_wsp__Policy(struct soap *soap, const char *URL, wsp__Policy const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsp:Policy", p->soap_type() == SOAP_TYPE_wsp__Policy ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_wsp__Policy(struct soap *soap, const char *URL, wsp__Policy const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsp:Policy", p->soap_type() == SOAP_TYPE_wsp__Policy ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_wsp__Policy(struct soap *soap, const char *URL, wsp__Policy const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsp:Policy", p->soap_type() == SOAP_TYPE_wsp__Policy ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 wsp__Policy * SOAP_FMAC4 soap_get_wsp__Policy(struct soap*, wsp__Policy *, const char*, const char*);

inline int soap_read_wsp__Policy(struct soap *soap, wsp__Policy *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_wsp__Policy(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_wsp__Policy(struct soap *soap, const char *URL, wsp__Policy *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_wsp__Policy(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_wsp__Policy(struct soap *soap, wsp__Policy *p)
{
	if (::soap_read_wsp__Policy(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_wsa__EndpointReferenceType_DEFINED
#define SOAP_TYPE_wsa__EndpointReferenceType_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa__EndpointReferenceType(struct soap*, const char*, int, const wsa__EndpointReferenceType *, const char*);
SOAP_FMAC3 wsa__EndpointReferenceType * SOAP_FMAC4 soap_in_wsa__EndpointReferenceType(struct soap*, const char*, wsa__EndpointReferenceType *, const char*);
SOAP_FMAC1 wsa__EndpointReferenceType * SOAP_FMAC2 wsdl_instantiate_wsa__EndpointReferenceType(struct soap*, int, const char*, const char*, size_t*);

inline wsa__EndpointReferenceType * soap_new_wsa__EndpointReferenceType(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_wsa__EndpointReferenceType(soap, n, NULL, NULL, NULL);
}

inline wsa__EndpointReferenceType * soap_new_req_wsa__EndpointReferenceType(
	struct soap *soap)
{
	wsa__EndpointReferenceType *_p = ::soap_new_wsa__EndpointReferenceType(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline wsa__EndpointReferenceType * soap_new_set_wsa__EndpointReferenceType(
	struct soap *soap,
	char *Address,
	char *__any)
{
	wsa__EndpointReferenceType *_p = ::soap_new_wsa__EndpointReferenceType(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wsa__EndpointReferenceType::Address = Address;
		_p->wsa__EndpointReferenceType::__any = __any;
	}
	return _p;
}

inline int soap_write_wsa__EndpointReferenceType(struct soap *soap, wsa__EndpointReferenceType const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsa:EndpointReferenceType", p->soap_type() == SOAP_TYPE_wsa__EndpointReferenceType ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_wsa__EndpointReferenceType(struct soap *soap, const char *URL, wsa__EndpointReferenceType const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsa:EndpointReferenceType", p->soap_type() == SOAP_TYPE_wsa__EndpointReferenceType ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_wsa__EndpointReferenceType(struct soap *soap, const char *URL, wsa__EndpointReferenceType const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsa:EndpointReferenceType", p->soap_type() == SOAP_TYPE_wsa__EndpointReferenceType ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_wsa__EndpointReferenceType(struct soap *soap, const char *URL, wsa__EndpointReferenceType const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsa:EndpointReferenceType", p->soap_type() == SOAP_TYPE_wsa__EndpointReferenceType ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 wsa__EndpointReferenceType * SOAP_FMAC4 soap_get_wsa__EndpointReferenceType(struct soap*, wsa__EndpointReferenceType *, const char*, const char*);

inline int soap_read_wsa__EndpointReferenceType(struct soap *soap, wsa__EndpointReferenceType *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_wsa__EndpointReferenceType(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_wsa__EndpointReferenceType(struct soap *soap, const char *URL, wsa__EndpointReferenceType *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_wsa__EndpointReferenceType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_wsa__EndpointReferenceType(struct soap *soap, wsa__EndpointReferenceType *p)
{
	if (::soap_read_wsa__EndpointReferenceType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_gwsdl__portType_DEFINED
#define SOAP_TYPE_gwsdl__portType_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_gwsdl__portType(struct soap*, const char*, int, const gwsdl__portType *, const char*);
SOAP_FMAC3 gwsdl__portType * SOAP_FMAC4 soap_in_gwsdl__portType(struct soap*, const char*, gwsdl__portType *, const char*);
SOAP_FMAC1 gwsdl__portType * SOAP_FMAC2 wsdl_instantiate_gwsdl__portType(struct soap*, int, const char*, const char*, size_t*);

inline gwsdl__portType * soap_new_gwsdl__portType(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_gwsdl__portType(soap, n, NULL, NULL, NULL);
}

inline gwsdl__portType * soap_new_req_gwsdl__portType(
	struct soap *soap)
{
	gwsdl__portType *_p = ::soap_new_gwsdl__portType(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline gwsdl__portType * soap_new_set_gwsdl__portType(
	struct soap *soap,
	char *name,
	char *extends,
	char *documentation,
	const std::vector<wsdl__operation *> & operation,
	const std::vector<sd__serviceData> & sd__serviceData_,
	sd__staticServiceDataValues *sd__staticServiceDataValues_)
{
	gwsdl__portType *_p = ::soap_new_gwsdl__portType(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->gwsdl__portType::name = name;
		_p->gwsdl__portType::extends = extends;
		_p->gwsdl__portType::documentation = documentation;
		_p->gwsdl__portType::operation = operation;
		_p->gwsdl__portType::sd__serviceData_ = sd__serviceData_;
		_p->gwsdl__portType::sd__staticServiceDataValues_ = sd__staticServiceDataValues_;
	}
	return _p;
}

inline int soap_write_gwsdl__portType(struct soap *soap, gwsdl__portType const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "gwsdl:portType", p->soap_type() == SOAP_TYPE_gwsdl__portType ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_gwsdl__portType(struct soap *soap, const char *URL, gwsdl__portType const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "gwsdl:portType", p->soap_type() == SOAP_TYPE_gwsdl__portType ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_gwsdl__portType(struct soap *soap, const char *URL, gwsdl__portType const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "gwsdl:portType", p->soap_type() == SOAP_TYPE_gwsdl__portType ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_gwsdl__portType(struct soap *soap, const char *URL, gwsdl__portType const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "gwsdl:portType", p->soap_type() == SOAP_TYPE_gwsdl__portType ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 gwsdl__portType * SOAP_FMAC4 soap_get_gwsdl__portType(struct soap*, gwsdl__portType *, const char*, const char*);

inline int soap_read_gwsdl__portType(struct soap *soap, gwsdl__portType *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_gwsdl__portType(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_gwsdl__portType(struct soap *soap, const char *URL, gwsdl__portType *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_gwsdl__portType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_gwsdl__portType(struct soap *soap, gwsdl__portType *p)
{
	if (::soap_read_gwsdl__portType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_sd__staticServiceDataValues_DEFINED
#define SOAP_TYPE_sd__staticServiceDataValues_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_sd__staticServiceDataValues(struct soap*, const char*, int, const sd__staticServiceDataValues *, const char*);
SOAP_FMAC3 sd__staticServiceDataValues * SOAP_FMAC4 soap_in_sd__staticServiceDataValues(struct soap*, const char*, sd__staticServiceDataValues *, const char*);
SOAP_FMAC1 sd__staticServiceDataValues * SOAP_FMAC2 wsdl_instantiate_sd__staticServiceDataValues(struct soap*, int, const char*, const char*, size_t*);

inline sd__staticServiceDataValues * soap_new_sd__staticServiceDataValues(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_sd__staticServiceDataValues(soap, n, NULL, NULL, NULL);
}

inline sd__staticServiceDataValues * soap_new_req_sd__staticServiceDataValues(
	struct soap *soap,
	int __type,
	void *_any)
{
	sd__staticServiceDataValues *_p = ::soap_new_sd__staticServiceDataValues(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->sd__staticServiceDataValues::__type = __type;
		_p->sd__staticServiceDataValues::_any = _any;
	}
	return _p;
}

inline sd__staticServiceDataValues * soap_new_set_sd__staticServiceDataValues(
	struct soap *soap,
	int __type,
	void *_any)
{
	sd__staticServiceDataValues *_p = ::soap_new_sd__staticServiceDataValues(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->sd__staticServiceDataValues::__type = __type;
		_p->sd__staticServiceDataValues::_any = _any;
	}
	return _p;
}

inline int soap_write_sd__staticServiceDataValues(struct soap *soap, sd__staticServiceDataValues const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "sd:staticServiceDataValues", p->soap_type() == SOAP_TYPE_sd__staticServiceDataValues ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_sd__staticServiceDataValues(struct soap *soap, const char *URL, sd__staticServiceDataValues const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "sd:staticServiceDataValues", p->soap_type() == SOAP_TYPE_sd__staticServiceDataValues ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_sd__staticServiceDataValues(struct soap *soap, const char *URL, sd__staticServiceDataValues const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "sd:staticServiceDataValues", p->soap_type() == SOAP_TYPE_sd__staticServiceDataValues ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_sd__staticServiceDataValues(struct soap *soap, const char *URL, sd__staticServiceDataValues const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "sd:staticServiceDataValues", p->soap_type() == SOAP_TYPE_sd__staticServiceDataValues ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 sd__staticServiceDataValues * SOAP_FMAC4 soap_get_sd__staticServiceDataValues(struct soap*, sd__staticServiceDataValues *, const char*, const char*);

inline int soap_read_sd__staticServiceDataValues(struct soap *soap, sd__staticServiceDataValues *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_sd__staticServiceDataValues(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_sd__staticServiceDataValues(struct soap *soap, const char *URL, sd__staticServiceDataValues *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_sd__staticServiceDataValues(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_sd__staticServiceDataValues(struct soap *soap, sd__staticServiceDataValues *p)
{
	if (::soap_read_sd__staticServiceDataValues(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_sd__serviceData_DEFINED
#define SOAP_TYPE_sd__serviceData_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_sd__serviceData(struct soap*, const char*, int, const sd__serviceData *, const char*);
SOAP_FMAC3 sd__serviceData * SOAP_FMAC4 soap_in_sd__serviceData(struct soap*, const char*, sd__serviceData *, const char*);
SOAP_FMAC1 sd__serviceData * SOAP_FMAC2 wsdl_instantiate_sd__serviceData(struct soap*, int, const char*, const char*, size_t*);

inline sd__serviceData * soap_new_sd__serviceData(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_sd__serviceData(soap, n, NULL, NULL, NULL);
}

inline sd__serviceData * soap_new_req_sd__serviceData(
	struct soap *soap)
{
	sd__serviceData *_p = ::soap_new_sd__serviceData(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline sd__serviceData * soap_new_set_sd__serviceData(
	struct soap *soap,
	char *name,
	char *type,
	bool nillable,
	char *minOccurs,
	char *maxOccurs,
	enum sd__mutability mutability,
	bool modifiable)
{
	sd__serviceData *_p = ::soap_new_sd__serviceData(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->sd__serviceData::name = name;
		_p->sd__serviceData::type = type;
		_p->sd__serviceData::nillable = nillable;
		_p->sd__serviceData::minOccurs = minOccurs;
		_p->sd__serviceData::maxOccurs = maxOccurs;
		_p->sd__serviceData::mutability = mutability;
		_p->sd__serviceData::modifiable = modifiable;
	}
	return _p;
}

inline int soap_write_sd__serviceData(struct soap *soap, sd__serviceData const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "sd:serviceData", p->soap_type() == SOAP_TYPE_sd__serviceData ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_sd__serviceData(struct soap *soap, const char *URL, sd__serviceData const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "sd:serviceData", p->soap_type() == SOAP_TYPE_sd__serviceData ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_sd__serviceData(struct soap *soap, const char *URL, sd__serviceData const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "sd:serviceData", p->soap_type() == SOAP_TYPE_sd__serviceData ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_sd__serviceData(struct soap *soap, const char *URL, sd__serviceData const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "sd:serviceData", p->soap_type() == SOAP_TYPE_sd__serviceData ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 sd__serviceData * SOAP_FMAC4 soap_get_sd__serviceData(struct soap*, sd__serviceData *, const char*, const char*);

inline int soap_read_sd__serviceData(struct soap *soap, sd__serviceData *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_sd__serviceData(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_sd__serviceData(struct soap *soap, const char *URL, sd__serviceData *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_sd__serviceData(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_sd__serviceData(struct soap *soap, sd__serviceData *p)
{
	if (::soap_read_sd__serviceData(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_wsdl__operation_DEFINED
#define SOAP_TYPE_wsdl__operation_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdl__operation(struct soap*, const char*, int, const wsdl__operation *, const char*);
SOAP_FMAC3 wsdl__operation * SOAP_FMAC4 soap_in_wsdl__operation(struct soap*, const char*, wsdl__operation *, const char*);
SOAP_FMAC1 wsdl__operation * SOAP_FMAC2 wsdl_instantiate_wsdl__operation(struct soap*, int, const char*, const char*, size_t*);

inline wsdl__operation * soap_new_wsdl__operation(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_wsdl__operation(soap, n, NULL, NULL, NULL);
}

inline wsdl__operation * soap_new_req_wsdl__operation(
	struct soap *soap,
	const union wsdl__union_ioput& __ioput1,
	const union wsdl__union_ioput& __ioput2)
{
	wsdl__operation *_p = ::soap_new_wsdl__operation(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wsdl__operation::__ioput1 = __ioput1;
		_p->wsdl__operation::__ioput2 = __ioput2;
	}
	return _p;
}

inline wsdl__operation * soap_new_set_wsdl__operation(
	struct soap *soap,
	char *name,
	char *pattern,
	char *style,
	char *wrpc__signature,
	char *parameterOrder,
	char *documentation,
	wsp__Policy *wsp__Policy_,
	wsp__PolicyReference *wsp__PolicyReference_,
	int __union1,
	const union wsdl__union_ioput& __ioput1,
	int __union2,
	const union wsdl__union_ioput& __ioput2,
	const std::vector<wsdl__fault> & fault,
	const std::vector<wsdl__fault> & infault,
	const std::vector<wsdl__fault> & outfault)
{
	wsdl__operation *_p = ::soap_new_wsdl__operation(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wsdl__operation::name = name;
		_p->wsdl__operation::pattern = pattern;
		_p->wsdl__operation::style = style;
		_p->wsdl__operation::wrpc__signature = wrpc__signature;
		_p->wsdl__operation::parameterOrder = parameterOrder;
		_p->wsdl__operation::documentation = documentation;
		_p->wsdl__operation::wsp__Policy_ = wsp__Policy_;
		_p->wsdl__operation::wsp__PolicyReference_ = wsp__PolicyReference_;
		_p->wsdl__operation::__union1 = __union1;
		_p->wsdl__operation::__ioput1 = __ioput1;
		_p->wsdl__operation::__union2 = __union2;
		_p->wsdl__operation::__ioput2 = __ioput2;
		_p->wsdl__operation::fault = fault;
		_p->wsdl__operation::infault = infault;
		_p->wsdl__operation::outfault = outfault;
	}
	return _p;
}

inline int soap_write_wsdl__operation(struct soap *soap, wsdl__operation const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsdl:operation", p->soap_type() == SOAP_TYPE_wsdl__operation ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_wsdl__operation(struct soap *soap, const char *URL, wsdl__operation const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsdl:operation", p->soap_type() == SOAP_TYPE_wsdl__operation ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_wsdl__operation(struct soap *soap, const char *URL, wsdl__operation const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsdl:operation", p->soap_type() == SOAP_TYPE_wsdl__operation ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_wsdl__operation(struct soap *soap, const char *URL, wsdl__operation const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsdl:operation", p->soap_type() == SOAP_TYPE_wsdl__operation ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 wsdl__operation * SOAP_FMAC4 soap_get_wsdl__operation(struct soap*, wsdl__operation *, const char*, const char*);

inline int soap_read_wsdl__operation(struct soap *soap, wsdl__operation *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_wsdl__operation(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_wsdl__operation(struct soap *soap, const char *URL, wsdl__operation *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_wsdl__operation(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_wsdl__operation(struct soap *soap, wsdl__operation *p)
{
	if (::soap_read_wsdl__operation(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_whttp__header_DEFINED
#define SOAP_TYPE_whttp__header_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_whttp__header(struct soap*, const char*, int, const whttp__header *, const char*);
SOAP_FMAC3 whttp__header * SOAP_FMAC4 soap_in_whttp__header(struct soap*, const char*, whttp__header *, const char*);
SOAP_FMAC1 whttp__header * SOAP_FMAC2 wsdl_instantiate_whttp__header(struct soap*, int, const char*, const char*, size_t*);

inline whttp__header * soap_new_whttp__header(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_whttp__header(soap, n, NULL, NULL, NULL);
}

inline whttp__header * soap_new_req_whttp__header(
	struct soap *soap)
{
	whttp__header *_p = ::soap_new_whttp__header(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline whttp__header * soap_new_set_whttp__header(
	struct soap *soap,
	char *name,
	char *type,
	bool required)
{
	whttp__header *_p = ::soap_new_whttp__header(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->whttp__header::name = name;
		_p->whttp__header::type = type;
		_p->whttp__header::required = required;
	}
	return _p;
}

inline int soap_write_whttp__header(struct soap *soap, whttp__header const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "whttp:header", p->soap_type() == SOAP_TYPE_whttp__header ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_whttp__header(struct soap *soap, const char *URL, whttp__header const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "whttp:header", p->soap_type() == SOAP_TYPE_whttp__header ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_whttp__header(struct soap *soap, const char *URL, whttp__header const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "whttp:header", p->soap_type() == SOAP_TYPE_whttp__header ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_whttp__header(struct soap *soap, const char *URL, whttp__header const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "whttp:header", p->soap_type() == SOAP_TYPE_whttp__header ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 whttp__header * SOAP_FMAC4 soap_get_whttp__header(struct soap*, whttp__header *, const char*, const char*);

inline int soap_read_whttp__header(struct soap *soap, whttp__header *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_whttp__header(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_whttp__header(struct soap *soap, const char *URL, whttp__header *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_whttp__header(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_whttp__header(struct soap *soap, whttp__header *p)
{
	if (::soap_read_whttp__header(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_http__operation_DEFINED
#define SOAP_TYPE_http__operation_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_http__operation(struct soap*, const char*, int, const http__operation *, const char*);
SOAP_FMAC3 http__operation * SOAP_FMAC4 soap_in_http__operation(struct soap*, const char*, http__operation *, const char*);
SOAP_FMAC1 http__operation * SOAP_FMAC2 wsdl_instantiate_http__operation(struct soap*, int, const char*, const char*, size_t*);

inline http__operation * soap_new_http__operation(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_http__operation(soap, n, NULL, NULL, NULL);
}

inline http__operation * soap_new_req_http__operation(
	struct soap *soap)
{
	http__operation *_p = ::soap_new_http__operation(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline http__operation * soap_new_set_http__operation(
	struct soap *soap,
	char *location)
{
	http__operation *_p = ::soap_new_http__operation(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->http__operation::location = location;
	}
	return _p;
}

inline int soap_write_http__operation(struct soap *soap, http__operation const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "http:operation", p->soap_type() == SOAP_TYPE_http__operation ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_http__operation(struct soap *soap, const char *URL, http__operation const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "http:operation", p->soap_type() == SOAP_TYPE_http__operation ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_http__operation(struct soap *soap, const char *URL, http__operation const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "http:operation", p->soap_type() == SOAP_TYPE_http__operation ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_http__operation(struct soap *soap, const char *URL, http__operation const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "http:operation", p->soap_type() == SOAP_TYPE_http__operation ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 http__operation * SOAP_FMAC4 soap_get_http__operation(struct soap*, http__operation *, const char*, const char*);

inline int soap_read_http__operation(struct soap *soap, http__operation *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_http__operation(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_http__operation(struct soap *soap, const char *URL, http__operation *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_http__operation(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_http__operation(struct soap *soap, http__operation *p)
{
	if (::soap_read_http__operation(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_http__binding_DEFINED
#define SOAP_TYPE_http__binding_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_http__binding(struct soap*, const char*, int, const http__binding *, const char*);
SOAP_FMAC3 http__binding * SOAP_FMAC4 soap_in_http__binding(struct soap*, const char*, http__binding *, const char*);
SOAP_FMAC1 http__binding * SOAP_FMAC2 wsdl_instantiate_http__binding(struct soap*, int, const char*, const char*, size_t*);

inline http__binding * soap_new_http__binding(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_http__binding(soap, n, NULL, NULL, NULL);
}

inline http__binding * soap_new_req_http__binding(
	struct soap *soap)
{
	http__binding *_p = ::soap_new_http__binding(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline http__binding * soap_new_set_http__binding(
	struct soap *soap,
	char *verb)
{
	http__binding *_p = ::soap_new_http__binding(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->http__binding::verb = verb;
	}
	return _p;
}

inline int soap_write_http__binding(struct soap *soap, http__binding const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "http:binding", p->soap_type() == SOAP_TYPE_http__binding ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_http__binding(struct soap *soap, const char *URL, http__binding const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "http:binding", p->soap_type() == SOAP_TYPE_http__binding ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_http__binding(struct soap *soap, const char *URL, http__binding const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "http:binding", p->soap_type() == SOAP_TYPE_http__binding ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_http__binding(struct soap *soap, const char *URL, http__binding const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "http:binding", p->soap_type() == SOAP_TYPE_http__binding ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 http__binding * SOAP_FMAC4 soap_get_http__binding(struct soap*, http__binding *, const char*, const char*);

inline int soap_read_http__binding(struct soap *soap, http__binding *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_http__binding(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_http__binding(struct soap *soap, const char *URL, http__binding *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_http__binding(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_http__binding(struct soap *soap, http__binding *p)
{
	if (::soap_read_http__binding(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_http__address_DEFINED
#define SOAP_TYPE_http__address_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_http__address(struct soap*, const char*, int, const http__address *, const char*);
SOAP_FMAC3 http__address * SOAP_FMAC4 soap_in_http__address(struct soap*, const char*, http__address *, const char*);
SOAP_FMAC1 http__address * SOAP_FMAC2 wsdl_instantiate_http__address(struct soap*, int, const char*, const char*, size_t*);

inline http__address * soap_new_http__address(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_http__address(soap, n, NULL, NULL, NULL);
}

inline http__address * soap_new_req_http__address(
	struct soap *soap)
{
	http__address *_p = ::soap_new_http__address(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline http__address * soap_new_set_http__address(
	struct soap *soap,
	char *location)
{
	http__address *_p = ::soap_new_http__address(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->http__address::location = location;
	}
	return _p;
}

inline int soap_write_http__address(struct soap *soap, http__address const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "http:address", p->soap_type() == SOAP_TYPE_http__address ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_http__address(struct soap *soap, const char *URL, http__address const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "http:address", p->soap_type() == SOAP_TYPE_http__address ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_http__address(struct soap *soap, const char *URL, http__address const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "http:address", p->soap_type() == SOAP_TYPE_http__address ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_http__address(struct soap *soap, const char *URL, http__address const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "http:address", p->soap_type() == SOAP_TYPE_http__address ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 http__address * SOAP_FMAC4 soap_get_http__address(struct soap*, http__address *, const char*, const char*);

inline int soap_read_http__address(struct soap *soap, http__address *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_http__address(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_http__address(struct soap *soap, const char *URL, http__address *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_http__address(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_http__address(struct soap *soap, http__address *p)
{
	if (::soap_read_http__address(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_dime__message_DEFINED
#define SOAP_TYPE_dime__message_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_dime__message(struct soap*, const char*, int, const dime__message *, const char*);
SOAP_FMAC3 dime__message * SOAP_FMAC4 soap_in_dime__message(struct soap*, const char*, dime__message *, const char*);
SOAP_FMAC1 dime__message * SOAP_FMAC2 wsdl_instantiate_dime__message(struct soap*, int, const char*, const char*, size_t*);

inline dime__message * soap_new_dime__message(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_dime__message(soap, n, NULL, NULL, NULL);
}

inline dime__message * soap_new_req_dime__message(
	struct soap *soap)
{
	dime__message *_p = ::soap_new_dime__message(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline dime__message * soap_new_set_dime__message(
	struct soap *soap,
	char *layout)
{
	dime__message *_p = ::soap_new_dime__message(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->dime__message::layout = layout;
	}
	return _p;
}

inline int soap_write_dime__message(struct soap *soap, dime__message const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "dime:message", p->soap_type() == SOAP_TYPE_dime__message ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_dime__message(struct soap *soap, const char *URL, dime__message const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "dime:message", p->soap_type() == SOAP_TYPE_dime__message ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_dime__message(struct soap *soap, const char *URL, dime__message const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "dime:message", p->soap_type() == SOAP_TYPE_dime__message ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_dime__message(struct soap *soap, const char *URL, dime__message const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "dime:message", p->soap_type() == SOAP_TYPE_dime__message ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 dime__message * SOAP_FMAC4 soap_get_dime__message(struct soap*, dime__message *, const char*, const char*);

inline int soap_read_dime__message(struct soap *soap, dime__message *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_dime__message(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_dime__message(struct soap *soap, const char *URL, dime__message *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_dime__message(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_dime__message(struct soap *soap, dime__message *p)
{
	if (::soap_read_dime__message(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_mime__mimeXml_DEFINED
#define SOAP_TYPE_mime__mimeXml_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_mime__mimeXml(struct soap*, const char*, int, const mime__mimeXml *, const char*);
SOAP_FMAC3 mime__mimeXml * SOAP_FMAC4 soap_in_mime__mimeXml(struct soap*, const char*, mime__mimeXml *, const char*);
SOAP_FMAC1 mime__mimeXml * SOAP_FMAC2 wsdl_instantiate_mime__mimeXml(struct soap*, int, const char*, const char*, size_t*);

inline mime__mimeXml * soap_new_mime__mimeXml(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_mime__mimeXml(soap, n, NULL, NULL, NULL);
}

inline mime__mimeXml * soap_new_req_mime__mimeXml(
	struct soap *soap)
{
	mime__mimeXml *_p = ::soap_new_mime__mimeXml(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline mime__mimeXml * soap_new_set_mime__mimeXml(
	struct soap *soap,
	char *part)
{
	mime__mimeXml *_p = ::soap_new_mime__mimeXml(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->mime__mimeXml::part = part;
	}
	return _p;
}

inline int soap_write_mime__mimeXml(struct soap *soap, mime__mimeXml const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "mime:mimeXml", p->soap_type() == SOAP_TYPE_mime__mimeXml ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_mime__mimeXml(struct soap *soap, const char *URL, mime__mimeXml const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "mime:mimeXml", p->soap_type() == SOAP_TYPE_mime__mimeXml ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_mime__mimeXml(struct soap *soap, const char *URL, mime__mimeXml const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "mime:mimeXml", p->soap_type() == SOAP_TYPE_mime__mimeXml ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_mime__mimeXml(struct soap *soap, const char *URL, mime__mimeXml const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "mime:mimeXml", p->soap_type() == SOAP_TYPE_mime__mimeXml ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 mime__mimeXml * SOAP_FMAC4 soap_get_mime__mimeXml(struct soap*, mime__mimeXml *, const char*, const char*);

inline int soap_read_mime__mimeXml(struct soap *soap, mime__mimeXml *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_mime__mimeXml(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_mime__mimeXml(struct soap *soap, const char *URL, mime__mimeXml *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_mime__mimeXml(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_mime__mimeXml(struct soap *soap, mime__mimeXml *p)
{
	if (::soap_read_mime__mimeXml(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_mime__multipartRelated_DEFINED
#define SOAP_TYPE_mime__multipartRelated_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_mime__multipartRelated(struct soap*, const char*, int, const mime__multipartRelated *, const char*);
SOAP_FMAC3 mime__multipartRelated * SOAP_FMAC4 soap_in_mime__multipartRelated(struct soap*, const char*, mime__multipartRelated *, const char*);
SOAP_FMAC1 mime__multipartRelated * SOAP_FMAC2 wsdl_instantiate_mime__multipartRelated(struct soap*, int, const char*, const char*, size_t*);

inline mime__multipartRelated * soap_new_mime__multipartRelated(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_mime__multipartRelated(soap, n, NULL, NULL, NULL);
}

inline mime__multipartRelated * soap_new_req_mime__multipartRelated(
	struct soap *soap)
{
	mime__multipartRelated *_p = ::soap_new_mime__multipartRelated(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline mime__multipartRelated * soap_new_set_mime__multipartRelated(
	struct soap *soap,
	const std::vector<mime__part> & part)
{
	mime__multipartRelated *_p = ::soap_new_mime__multipartRelated(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->mime__multipartRelated::part = part;
	}
	return _p;
}

inline int soap_write_mime__multipartRelated(struct soap *soap, mime__multipartRelated const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "mime:multipartRelated", p->soap_type() == SOAP_TYPE_mime__multipartRelated ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_mime__multipartRelated(struct soap *soap, const char *URL, mime__multipartRelated const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "mime:multipartRelated", p->soap_type() == SOAP_TYPE_mime__multipartRelated ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_mime__multipartRelated(struct soap *soap, const char *URL, mime__multipartRelated const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "mime:multipartRelated", p->soap_type() == SOAP_TYPE_mime__multipartRelated ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_mime__multipartRelated(struct soap *soap, const char *URL, mime__multipartRelated const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "mime:multipartRelated", p->soap_type() == SOAP_TYPE_mime__multipartRelated ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 mime__multipartRelated * SOAP_FMAC4 soap_get_mime__multipartRelated(struct soap*, mime__multipartRelated *, const char*, const char*);

inline int soap_read_mime__multipartRelated(struct soap *soap, mime__multipartRelated *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_mime__multipartRelated(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_mime__multipartRelated(struct soap *soap, const char *URL, mime__multipartRelated *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_mime__multipartRelated(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_mime__multipartRelated(struct soap *soap, mime__multipartRelated *p)
{
	if (::soap_read_mime__multipartRelated(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_mime__part_DEFINED
#define SOAP_TYPE_mime__part_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_mime__part(struct soap*, const char*, int, const mime__part *, const char*);
SOAP_FMAC3 mime__part * SOAP_FMAC4 soap_in_mime__part(struct soap*, const char*, mime__part *, const char*);
SOAP_FMAC1 mime__part * SOAP_FMAC2 wsdl_instantiate_mime__part(struct soap*, int, const char*, const char*, size_t*);

inline mime__part * soap_new_mime__part(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_mime__part(soap, n, NULL, NULL, NULL);
}

inline mime__part * soap_new_req_mime__part(
	struct soap *soap)
{
	mime__part *_p = ::soap_new_mime__part(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline mime__part * soap_new_set_mime__part(
	struct soap *soap,
	soap__body *soap__body_,
	const std::vector<soap__header> & soap__header_,
	const std::vector<mime__content> & content)
{
	mime__part *_p = ::soap_new_mime__part(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->mime__part::soap__body_ = soap__body_;
		_p->mime__part::soap__header_ = soap__header_;
		_p->mime__part::content = content;
	}
	return _p;
}

inline int soap_write_mime__part(struct soap *soap, mime__part const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "mime:part", p->soap_type() == SOAP_TYPE_mime__part ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_mime__part(struct soap *soap, const char *URL, mime__part const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "mime:part", p->soap_type() == SOAP_TYPE_mime__part ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_mime__part(struct soap *soap, const char *URL, mime__part const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "mime:part", p->soap_type() == SOAP_TYPE_mime__part ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_mime__part(struct soap *soap, const char *URL, mime__part const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "mime:part", p->soap_type() == SOAP_TYPE_mime__part ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 mime__part * SOAP_FMAC4 soap_get_mime__part(struct soap*, mime__part *, const char*, const char*);

inline int soap_read_mime__part(struct soap *soap, mime__part *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_mime__part(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_mime__part(struct soap *soap, const char *URL, mime__part *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_mime__part(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_mime__part(struct soap *soap, mime__part *p)
{
	if (::soap_read_mime__part(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_mime__content_DEFINED
#define SOAP_TYPE_mime__content_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_mime__content(struct soap*, const char*, int, const mime__content *, const char*);
SOAP_FMAC3 mime__content * SOAP_FMAC4 soap_in_mime__content(struct soap*, const char*, mime__content *, const char*);
SOAP_FMAC1 mime__content * SOAP_FMAC2 wsdl_instantiate_mime__content(struct soap*, int, const char*, const char*, size_t*);

inline mime__content * soap_new_mime__content(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_mime__content(soap, n, NULL, NULL, NULL);
}

inline mime__content * soap_new_req_mime__content(
	struct soap *soap)
{
	mime__content *_p = ::soap_new_mime__content(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline mime__content * soap_new_set_mime__content(
	struct soap *soap,
	char *part,
	char *type)
{
	mime__content *_p = ::soap_new_mime__content(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->mime__content::part = part;
		_p->mime__content::type = type;
	}
	return _p;
}

inline int soap_write_mime__content(struct soap *soap, mime__content const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "mime:content", p->soap_type() == SOAP_TYPE_mime__content ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_mime__content(struct soap *soap, const char *URL, mime__content const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "mime:content", p->soap_type() == SOAP_TYPE_mime__content ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_mime__content(struct soap *soap, const char *URL, mime__content const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "mime:content", p->soap_type() == SOAP_TYPE_mime__content ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_mime__content(struct soap *soap, const char *URL, mime__content const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "mime:content", p->soap_type() == SOAP_TYPE_mime__content ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 mime__content * SOAP_FMAC4 soap_get_mime__content(struct soap*, mime__content *, const char*, const char*);

inline int soap_read_mime__content(struct soap *soap, mime__content *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_mime__content(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_mime__content(struct soap *soap, const char *URL, mime__content *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_mime__content(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_mime__content(struct soap *soap, mime__content *p)
{
	if (::soap_read_mime__content(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_wsoap__header_DEFINED
#define SOAP_TYPE_wsoap__header_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsoap__header(struct soap*, const char*, int, const wsoap__header *, const char*);
SOAP_FMAC3 wsoap__header * SOAP_FMAC4 soap_in_wsoap__header(struct soap*, const char*, wsoap__header *, const char*);
SOAP_FMAC1 wsoap__header * SOAP_FMAC2 wsdl_instantiate_wsoap__header(struct soap*, int, const char*, const char*, size_t*);

inline wsoap__header * soap_new_wsoap__header(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_wsoap__header(soap, n, NULL, NULL, NULL);
}

inline wsoap__header * soap_new_req_wsoap__header(
	struct soap *soap)
{
	wsoap__header *_p = ::soap_new_wsoap__header(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline wsoap__header * soap_new_set_wsoap__header(
	struct soap *soap,
	char *element,
	bool mustUnderstand_,
	bool required)
{
	wsoap__header *_p = ::soap_new_wsoap__header(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wsoap__header::element = element;
		_p->wsoap__header::mustUnderstand_ = mustUnderstand_;
		_p->wsoap__header::required = required;
	}
	return _p;
}

inline int soap_write_wsoap__header(struct soap *soap, wsoap__header const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsoap:header", p->soap_type() == SOAP_TYPE_wsoap__header ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_wsoap__header(struct soap *soap, const char *URL, wsoap__header const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsoap:header", p->soap_type() == SOAP_TYPE_wsoap__header ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_wsoap__header(struct soap *soap, const char *URL, wsoap__header const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsoap:header", p->soap_type() == SOAP_TYPE_wsoap__header ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_wsoap__header(struct soap *soap, const char *URL, wsoap__header const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsoap:header", p->soap_type() == SOAP_TYPE_wsoap__header ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 wsoap__header * SOAP_FMAC4 soap_get_wsoap__header(struct soap*, wsoap__header *, const char*, const char*);

inline int soap_read_wsoap__header(struct soap *soap, wsoap__header *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_wsoap__header(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_wsoap__header(struct soap *soap, const char *URL, wsoap__header *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_wsoap__header(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_wsoap__header(struct soap *soap, wsoap__header *p)
{
	if (::soap_read_wsoap__header(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_wsoap__module_DEFINED
#define SOAP_TYPE_wsoap__module_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsoap__module(struct soap*, const char*, int, const wsoap__module *, const char*);
SOAP_FMAC3 wsoap__module * SOAP_FMAC4 soap_in_wsoap__module(struct soap*, const char*, wsoap__module *, const char*);
SOAP_FMAC1 wsoap__module * SOAP_FMAC2 wsdl_instantiate_wsoap__module(struct soap*, int, const char*, const char*, size_t*);

inline wsoap__module * soap_new_wsoap__module(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_wsoap__module(soap, n, NULL, NULL, NULL);
}

inline wsoap__module * soap_new_req_wsoap__module(
	struct soap *soap)
{
	wsoap__module *_p = ::soap_new_wsoap__module(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline wsoap__module * soap_new_set_wsoap__module(
	struct soap *soap,
	char *ref,
	bool required)
{
	wsoap__module *_p = ::soap_new_wsoap__module(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wsoap__module::ref = ref;
		_p->wsoap__module::required = required;
	}
	return _p;
}

inline int soap_write_wsoap__module(struct soap *soap, wsoap__module const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsoap:module", p->soap_type() == SOAP_TYPE_wsoap__module ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_wsoap__module(struct soap *soap, const char *URL, wsoap__module const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsoap:module", p->soap_type() == SOAP_TYPE_wsoap__module ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_wsoap__module(struct soap *soap, const char *URL, wsoap__module const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsoap:module", p->soap_type() == SOAP_TYPE_wsoap__module ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_wsoap__module(struct soap *soap, const char *URL, wsoap__module const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsoap:module", p->soap_type() == SOAP_TYPE_wsoap__module ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 wsoap__module * SOAP_FMAC4 soap_get_wsoap__module(struct soap*, wsoap__module *, const char*, const char*);

inline int soap_read_wsoap__module(struct soap *soap, wsoap__module *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_wsoap__module(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_wsoap__module(struct soap *soap, const char *URL, wsoap__module *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_wsoap__module(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_wsoap__module(struct soap *soap, wsoap__module *p)
{
	if (::soap_read_wsoap__module(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_soap__address_DEFINED
#define SOAP_TYPE_soap__address_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_soap__address(struct soap*, const char*, int, const soap__address *, const char*);
SOAP_FMAC3 soap__address * SOAP_FMAC4 soap_in_soap__address(struct soap*, const char*, soap__address *, const char*);
SOAP_FMAC1 soap__address * SOAP_FMAC2 wsdl_instantiate_soap__address(struct soap*, int, const char*, const char*, size_t*);

inline soap__address * soap_new_soap__address(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_soap__address(soap, n, NULL, NULL, NULL);
}

inline soap__address * soap_new_req_soap__address(
	struct soap *soap)
{
	soap__address *_p = ::soap_new_soap__address(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline soap__address * soap_new_set_soap__address(
	struct soap *soap,
	char *location)
{
	soap__address *_p = ::soap_new_soap__address(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->soap__address::location = location;
	}
	return _p;
}

inline int soap_write_soap__address(struct soap *soap, soap__address const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "soap:address", p->soap_type() == SOAP_TYPE_soap__address ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_soap__address(struct soap *soap, const char *URL, soap__address const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "soap:address", p->soap_type() == SOAP_TYPE_soap__address ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_soap__address(struct soap *soap, const char *URL, soap__address const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "soap:address", p->soap_type() == SOAP_TYPE_soap__address ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_soap__address(struct soap *soap, const char *URL, soap__address const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "soap:address", p->soap_type() == SOAP_TYPE_soap__address ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 soap__address * SOAP_FMAC4 soap_get_soap__address(struct soap*, soap__address *, const char*, const char*);

inline int soap_read_soap__address(struct soap *soap, soap__address *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_soap__address(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_soap__address(struct soap *soap, const char *URL, soap__address *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_soap__address(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_soap__address(struct soap *soap, soap__address *p)
{
	if (::soap_read_soap__address(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_soap__header_DEFINED
#define SOAP_TYPE_soap__header_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_soap__header(struct soap*, const char*, int, const soap__header *, const char*);
SOAP_FMAC3 soap__header * SOAP_FMAC4 soap_in_soap__header(struct soap*, const char*, soap__header *, const char*);
SOAP_FMAC1 soap__header * SOAP_FMAC2 wsdl_instantiate_soap__header(struct soap*, int, const char*, const char*, size_t*);

inline soap__header * soap_new_soap__header(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_soap__header(soap, n, NULL, NULL, NULL);
}

inline soap__header * soap_new_req_soap__header(
	struct soap *soap)
{
	soap__header *_p = ::soap_new_soap__header(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline soap__header * soap_new_set_soap__header(
	struct soap *soap,
	char *message,
	char *part,
	enum soap__useChoice use,
	char *encodingStyle,
	char *namespace_,
	const std::vector<soap__headerfault> & headerfault)
{
	soap__header *_p = ::soap_new_soap__header(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->soap__header::message = message;
		_p->soap__header::part = part;
		_p->soap__header::use = use;
		_p->soap__header::encodingStyle = encodingStyle;
		_p->soap__header::namespace_ = namespace_;
		_p->soap__header::headerfault = headerfault;
	}
	return _p;
}

inline int soap_write_soap__header(struct soap *soap, soap__header const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "soap:header", p->soap_type() == SOAP_TYPE_soap__header ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_soap__header(struct soap *soap, const char *URL, soap__header const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "soap:header", p->soap_type() == SOAP_TYPE_soap__header ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_soap__header(struct soap *soap, const char *URL, soap__header const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "soap:header", p->soap_type() == SOAP_TYPE_soap__header ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_soap__header(struct soap *soap, const char *URL, soap__header const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "soap:header", p->soap_type() == SOAP_TYPE_soap__header ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 soap__header * SOAP_FMAC4 soap_get_soap__header(struct soap*, soap__header *, const char*, const char*);

inline int soap_read_soap__header(struct soap *soap, soap__header *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_soap__header(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_soap__header(struct soap *soap, const char *URL, soap__header *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_soap__header(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_soap__header(struct soap *soap, soap__header *p)
{
	if (::soap_read_soap__header(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_soap__headerfault_DEFINED
#define SOAP_TYPE_soap__headerfault_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_soap__headerfault(struct soap*, const char*, int, const soap__headerfault *, const char*);
SOAP_FMAC3 soap__headerfault * SOAP_FMAC4 soap_in_soap__headerfault(struct soap*, const char*, soap__headerfault *, const char*);
SOAP_FMAC1 soap__headerfault * SOAP_FMAC2 wsdl_instantiate_soap__headerfault(struct soap*, int, const char*, const char*, size_t*);

inline soap__headerfault * soap_new_soap__headerfault(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_soap__headerfault(soap, n, NULL, NULL, NULL);
}

inline soap__headerfault * soap_new_req_soap__headerfault(
	struct soap *soap)
{
	soap__headerfault *_p = ::soap_new_soap__headerfault(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline soap__headerfault * soap_new_set_soap__headerfault(
	struct soap *soap,
	char *message,
	char *part,
	enum soap__useChoice use,
	char *encodingStyle,
	char *namespace_)
{
	soap__headerfault *_p = ::soap_new_soap__headerfault(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->soap__headerfault::message = message;
		_p->soap__headerfault::part = part;
		_p->soap__headerfault::use = use;
		_p->soap__headerfault::encodingStyle = encodingStyle;
		_p->soap__headerfault::namespace_ = namespace_;
	}
	return _p;
}

inline int soap_write_soap__headerfault(struct soap *soap, soap__headerfault const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "soap:headerfault", p->soap_type() == SOAP_TYPE_soap__headerfault ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_soap__headerfault(struct soap *soap, const char *URL, soap__headerfault const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "soap:headerfault", p->soap_type() == SOAP_TYPE_soap__headerfault ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_soap__headerfault(struct soap *soap, const char *URL, soap__headerfault const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "soap:headerfault", p->soap_type() == SOAP_TYPE_soap__headerfault ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_soap__headerfault(struct soap *soap, const char *URL, soap__headerfault const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "soap:headerfault", p->soap_type() == SOAP_TYPE_soap__headerfault ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 soap__headerfault * SOAP_FMAC4 soap_get_soap__headerfault(struct soap*, soap__headerfault *, const char*, const char*);

inline int soap_read_soap__headerfault(struct soap *soap, soap__headerfault *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_soap__headerfault(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_soap__headerfault(struct soap *soap, const char *URL, soap__headerfault *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_soap__headerfault(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_soap__headerfault(struct soap *soap, soap__headerfault *p)
{
	if (::soap_read_soap__headerfault(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_soap__fault_DEFINED
#define SOAP_TYPE_soap__fault_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_soap__fault(struct soap*, const char*, int, const soap__fault *, const char*);
SOAP_FMAC3 soap__fault * SOAP_FMAC4 soap_in_soap__fault(struct soap*, const char*, soap__fault *, const char*);
SOAP_FMAC1 soap__fault * SOAP_FMAC2 wsdl_instantiate_soap__fault(struct soap*, int, const char*, const char*, size_t*);

inline soap__fault * soap_new_soap__fault(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_soap__fault(soap, n, NULL, NULL, NULL);
}

inline soap__fault * soap_new_req_soap__fault(
	struct soap *soap)
{
	soap__fault *_p = ::soap_new_soap__fault(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline soap__fault * soap_new_set_soap__fault(
	struct soap *soap,
	char *name,
	char *encodingStyle,
	enum soap__useChoice use,
	char *namespace_)
{
	soap__fault *_p = ::soap_new_soap__fault(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->soap__fault::name = name;
		_p->soap__fault::encodingStyle = encodingStyle;
		_p->soap__fault::use = use;
		_p->soap__fault::namespace_ = namespace_;
	}
	return _p;
}

inline int soap_write_soap__fault(struct soap *soap, soap__fault const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "soap:fault", p->soap_type() == SOAP_TYPE_soap__fault ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_soap__fault(struct soap *soap, const char *URL, soap__fault const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "soap:fault", p->soap_type() == SOAP_TYPE_soap__fault ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_soap__fault(struct soap *soap, const char *URL, soap__fault const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "soap:fault", p->soap_type() == SOAP_TYPE_soap__fault ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_soap__fault(struct soap *soap, const char *URL, soap__fault const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "soap:fault", p->soap_type() == SOAP_TYPE_soap__fault ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 soap__fault * SOAP_FMAC4 soap_get_soap__fault(struct soap*, soap__fault *, const char*, const char*);

inline int soap_read_soap__fault(struct soap *soap, soap__fault *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_soap__fault(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_soap__fault(struct soap *soap, const char *URL, soap__fault *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_soap__fault(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_soap__fault(struct soap *soap, soap__fault *p)
{
	if (::soap_read_soap__fault(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_soap__body_DEFINED
#define SOAP_TYPE_soap__body_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_soap__body(struct soap*, const char*, int, const soap__body *, const char*);
SOAP_FMAC3 soap__body * SOAP_FMAC4 soap_in_soap__body(struct soap*, const char*, soap__body *, const char*);
SOAP_FMAC1 soap__body * SOAP_FMAC2 wsdl_instantiate_soap__body(struct soap*, int, const char*, const char*, size_t*);

inline soap__body * soap_new_soap__body(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_soap__body(soap, n, NULL, NULL, NULL);
}

inline soap__body * soap_new_req_soap__body(
	struct soap *soap)
{
	soap__body *_p = ::soap_new_soap__body(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline soap__body * soap_new_set_soap__body(
	struct soap *soap,
	char *encodingStyle,
	char *parts,
	enum soap__useChoice use,
	char *namespace_)
{
	soap__body *_p = ::soap_new_soap__body(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->soap__body::encodingStyle = encodingStyle;
		_p->soap__body::parts = parts;
		_p->soap__body::use = use;
		_p->soap__body::namespace_ = namespace_;
	}
	return _p;
}

inline int soap_write_soap__body(struct soap *soap, soap__body const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "soap:body", p->soap_type() == SOAP_TYPE_soap__body ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_soap__body(struct soap *soap, const char *URL, soap__body const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "soap:body", p->soap_type() == SOAP_TYPE_soap__body ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_soap__body(struct soap *soap, const char *URL, soap__body const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "soap:body", p->soap_type() == SOAP_TYPE_soap__body ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_soap__body(struct soap *soap, const char *URL, soap__body const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "soap:body", p->soap_type() == SOAP_TYPE_soap__body ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 soap__body * SOAP_FMAC4 soap_get_soap__body(struct soap*, soap__body *, const char*, const char*);

inline int soap_read_soap__body(struct soap *soap, soap__body *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_soap__body(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_soap__body(struct soap *soap, const char *URL, soap__body *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_soap__body(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_soap__body(struct soap *soap, soap__body *p)
{
	if (::soap_read_soap__body(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_soap__operation_DEFINED
#define SOAP_TYPE_soap__operation_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_soap__operation(struct soap*, const char*, int, const soap__operation *, const char*);
SOAP_FMAC3 soap__operation * SOAP_FMAC4 soap_in_soap__operation(struct soap*, const char*, soap__operation *, const char*);
SOAP_FMAC1 soap__operation * SOAP_FMAC2 wsdl_instantiate_soap__operation(struct soap*, int, const char*, const char*, size_t*);

inline soap__operation * soap_new_soap__operation(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_soap__operation(soap, n, NULL, NULL, NULL);
}

inline soap__operation * soap_new_req_soap__operation(
	struct soap *soap)
{
	soap__operation *_p = ::soap_new_soap__operation(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline soap__operation * soap_new_set_soap__operation(
	struct soap *soap,
	char *soapAction,
	bool soapActionRequired,
	enum soap__styleChoice *style)
{
	soap__operation *_p = ::soap_new_soap__operation(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->soap__operation::soapAction = soapAction;
		_p->soap__operation::soapActionRequired = soapActionRequired;
		_p->soap__operation::style = style;
	}
	return _p;
}

inline int soap_write_soap__operation(struct soap *soap, soap__operation const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "soap:operation", p->soap_type() == SOAP_TYPE_soap__operation ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_soap__operation(struct soap *soap, const char *URL, soap__operation const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "soap:operation", p->soap_type() == SOAP_TYPE_soap__operation ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_soap__operation(struct soap *soap, const char *URL, soap__operation const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "soap:operation", p->soap_type() == SOAP_TYPE_soap__operation ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_soap__operation(struct soap *soap, const char *URL, soap__operation const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "soap:operation", p->soap_type() == SOAP_TYPE_soap__operation ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 soap__operation * SOAP_FMAC4 soap_get_soap__operation(struct soap*, soap__operation *, const char*, const char*);

inline int soap_read_soap__operation(struct soap *soap, soap__operation *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_soap__operation(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_soap__operation(struct soap *soap, const char *URL, soap__operation *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_soap__operation(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_soap__operation(struct soap *soap, soap__operation *p)
{
	if (::soap_read_soap__operation(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_soap__binding_DEFINED
#define SOAP_TYPE_soap__binding_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_soap__binding(struct soap*, const char*, int, const soap__binding *, const char*);
SOAP_FMAC3 soap__binding * SOAP_FMAC4 soap_in_soap__binding(struct soap*, const char*, soap__binding *, const char*);
SOAP_FMAC1 soap__binding * SOAP_FMAC2 wsdl_instantiate_soap__binding(struct soap*, int, const char*, const char*, size_t*);

inline soap__binding * soap_new_soap__binding(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_soap__binding(soap, n, NULL, NULL, NULL);
}

inline soap__binding * soap_new_req_soap__binding(
	struct soap *soap)
{
	soap__binding *_p = ::soap_new_soap__binding(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline soap__binding * soap_new_set_soap__binding(
	struct soap *soap,
	char *transport,
	enum soap__styleChoice *style)
{
	soap__binding *_p = ::soap_new_soap__binding(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->soap__binding::transport = transport;
		_p->soap__binding::style = style;
	}
	return _p;
}

inline int soap_write_soap__binding(struct soap *soap, soap__binding const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "soap:binding", p->soap_type() == SOAP_TYPE_soap__binding ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_soap__binding(struct soap *soap, const char *URL, soap__binding const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "soap:binding", p->soap_type() == SOAP_TYPE_soap__binding ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_soap__binding(struct soap *soap, const char *URL, soap__binding const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "soap:binding", p->soap_type() == SOAP_TYPE_soap__binding ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_soap__binding(struct soap *soap, const char *URL, soap__binding const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "soap:binding", p->soap_type() == SOAP_TYPE_soap__binding ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 soap__binding * SOAP_FMAC4 soap_get_soap__binding(struct soap*, soap__binding *, const char*, const char*);

inline int soap_read_soap__binding(struct soap *soap, soap__binding *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_soap__binding(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_soap__binding(struct soap *soap, const char *URL, soap__binding *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_soap__binding(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_soap__binding(struct soap *soap, soap__binding *p)
{
	if (::soap_read_soap__binding(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_wsdl__part_DEFINED
#define SOAP_TYPE_wsdl__part_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdl__part(struct soap*, const char*, int, const wsdl__part *, const char*);
SOAP_FMAC3 wsdl__part * SOAP_FMAC4 soap_in_wsdl__part(struct soap*, const char*, wsdl__part *, const char*);
SOAP_FMAC1 wsdl__part * SOAP_FMAC2 wsdl_instantiate_wsdl__part(struct soap*, int, const char*, const char*, size_t*);

inline wsdl__part * soap_new_wsdl__part(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_wsdl__part(soap, n, NULL, NULL, NULL);
}

inline wsdl__part * soap_new_req_wsdl__part(
	struct soap *soap)
{
	wsdl__part *_p = ::soap_new_wsdl__part(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline wsdl__part * soap_new_set_wsdl__part(
	struct soap *soap,
	char *name,
	char *element,
	char *type,
	char *documentation)
{
	wsdl__part *_p = ::soap_new_wsdl__part(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wsdl__part::name = name;
		_p->wsdl__part::element = element;
		_p->wsdl__part::type = type;
		_p->wsdl__part::documentation = documentation;
	}
	return _p;
}

inline int soap_write_wsdl__part(struct soap *soap, wsdl__part const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsdl:part", p->soap_type() == SOAP_TYPE_wsdl__part ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_wsdl__part(struct soap *soap, const char *URL, wsdl__part const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsdl:part", p->soap_type() == SOAP_TYPE_wsdl__part ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_wsdl__part(struct soap *soap, const char *URL, wsdl__part const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsdl:part", p->soap_type() == SOAP_TYPE_wsdl__part ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_wsdl__part(struct soap *soap, const char *URL, wsdl__part const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsdl:part", p->soap_type() == SOAP_TYPE_wsdl__part ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 wsdl__part * SOAP_FMAC4 soap_get_wsdl__part(struct soap*, wsdl__part *, const char*, const char*);

inline int soap_read_wsdl__part(struct soap *soap, wsdl__part *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_wsdl__part(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_wsdl__part(struct soap *soap, const char *URL, wsdl__part *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_wsdl__part(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_wsdl__part(struct soap *soap, wsdl__part *p)
{
	if (::soap_read_wsdl__part(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_wsdl__message_DEFINED
#define SOAP_TYPE_wsdl__message_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdl__message(struct soap*, const char*, int, const wsdl__message *, const char*);
SOAP_FMAC3 wsdl__message * SOAP_FMAC4 soap_in_wsdl__message(struct soap*, const char*, wsdl__message *, const char*);
SOAP_FMAC1 wsdl__message * SOAP_FMAC2 wsdl_instantiate_wsdl__message(struct soap*, int, const char*, const char*, size_t*);

inline wsdl__message * soap_new_wsdl__message(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_wsdl__message(soap, n, NULL, NULL, NULL);
}

inline wsdl__message * soap_new_req_wsdl__message(
	struct soap *soap)
{
	wsdl__message *_p = ::soap_new_wsdl__message(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline wsdl__message * soap_new_set_wsdl__message(
	struct soap *soap,
	char *name,
	char *documentation,
	const std::vector<wsp__Policy> & wsp__Policy_,
	const std::vector<wsp__PolicyReference> & wsp__PolicyReference_,
	const std::vector<wsdl__part> & part)
{
	wsdl__message *_p = ::soap_new_wsdl__message(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wsdl__message::name = name;
		_p->wsdl__message::documentation = documentation;
		_p->wsdl__message::wsp__Policy_ = wsp__Policy_;
		_p->wsdl__message::wsp__PolicyReference_ = wsp__PolicyReference_;
		_p->wsdl__message::part = part;
	}
	return _p;
}

inline int soap_write_wsdl__message(struct soap *soap, wsdl__message const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsdl:message", p->soap_type() == SOAP_TYPE_wsdl__message ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_wsdl__message(struct soap *soap, const char *URL, wsdl__message const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsdl:message", p->soap_type() == SOAP_TYPE_wsdl__message ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_wsdl__message(struct soap *soap, const char *URL, wsdl__message const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsdl:message", p->soap_type() == SOAP_TYPE_wsdl__message ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_wsdl__message(struct soap *soap, const char *URL, wsdl__message const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsdl:message", p->soap_type() == SOAP_TYPE_wsdl__message ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 wsdl__message * SOAP_FMAC4 soap_get_wsdl__message(struct soap*, wsdl__message *, const char*, const char*);

inline int soap_read_wsdl__message(struct soap *soap, wsdl__message *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_wsdl__message(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_wsdl__message(struct soap *soap, const char *URL, wsdl__message *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_wsdl__message(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_wsdl__message(struct soap *soap, wsdl__message *p)
{
	if (::soap_read_wsdl__message(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_wadl__application_DEFINED
#define SOAP_TYPE_wadl__application_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_wadl__application(struct soap*, const char*, int, const wadl__application *, const char*);
SOAP_FMAC3 wadl__application * SOAP_FMAC4 soap_in_wadl__application(struct soap*, const char*, wadl__application *, const char*);
SOAP_FMAC1 wadl__application * SOAP_FMAC2 wsdl_instantiate_wadl__application(struct soap*, int, const char*, const char*, size_t*);

inline wadl__application * soap_new_wadl__application(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_wadl__application(soap, n, NULL, NULL, NULL);
}

inline wadl__application * soap_new_req_wadl__application(
	struct soap *soap)
{
	wadl__application *_p = ::soap_new_wadl__application(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline wadl__application * soap_new_set_wadl__application(
	struct soap *soap,
	const std::vector<wadl__doc> & doc,
	wadl__grammars *grammars,
	const std::vector<wadl__resources> & resources,
	const std::vector<wadl__resource_USCOREtype> & resource_USCOREtype,
	const std::vector<wadl__method> & method,
	const std::vector<wadl__representation> & representation,
	const std::vector<wadl__param> & param)
{
	wadl__application *_p = ::soap_new_wadl__application(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wadl__application::doc = doc;
		_p->wadl__application::grammars = grammars;
		_p->wadl__application::resources = resources;
		_p->wadl__application::resource_USCOREtype = resource_USCOREtype;
		_p->wadl__application::method = method;
		_p->wadl__application::representation = representation;
		_p->wadl__application::param = param;
	}
	return _p;
}

inline int soap_write_wadl__application(struct soap *soap, wadl__application const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wadl:application", p->soap_type() == SOAP_TYPE_wadl__application ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_wadl__application(struct soap *soap, const char *URL, wadl__application const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wadl:application", p->soap_type() == SOAP_TYPE_wadl__application ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_wadl__application(struct soap *soap, const char *URL, wadl__application const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wadl:application", p->soap_type() == SOAP_TYPE_wadl__application ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_wadl__application(struct soap *soap, const char *URL, wadl__application const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wadl:application", p->soap_type() == SOAP_TYPE_wadl__application ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 wadl__application * SOAP_FMAC4 soap_get_wadl__application(struct soap*, wadl__application *, const char*, const char*);

inline int soap_read_wadl__application(struct soap *soap, wadl__application *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_wadl__application(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_wadl__application(struct soap *soap, const char *URL, wadl__application *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_wadl__application(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_wadl__application(struct soap *soap, wadl__application *p)
{
	if (::soap_read_wadl__application(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_wadl__resources_DEFINED
#define SOAP_TYPE_wadl__resources_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_wadl__resources(struct soap*, const char*, int, const wadl__resources *, const char*);
SOAP_FMAC3 wadl__resources * SOAP_FMAC4 soap_in_wadl__resources(struct soap*, const char*, wadl__resources *, const char*);
SOAP_FMAC1 wadl__resources * SOAP_FMAC2 wsdl_instantiate_wadl__resources(struct soap*, int, const char*, const char*, size_t*);

inline wadl__resources * soap_new_wadl__resources(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_wadl__resources(soap, n, NULL, NULL, NULL);
}

inline wadl__resources * soap_new_req_wadl__resources(
	struct soap *soap)
{
	wadl__resources *_p = ::soap_new_wadl__resources(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline wadl__resources * soap_new_set_wadl__resources(
	struct soap *soap,
	char *base,
	const std::vector<wadl__doc> & doc,
	const std::vector<wadl__resource> & resource)
{
	wadl__resources *_p = ::soap_new_wadl__resources(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wadl__resources::base = base;
		_p->wadl__resources::doc = doc;
		_p->wadl__resources::resource = resource;
	}
	return _p;
}

inline int soap_write_wadl__resources(struct soap *soap, wadl__resources const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wadl:resources", p->soap_type() == SOAP_TYPE_wadl__resources ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_wadl__resources(struct soap *soap, const char *URL, wadl__resources const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wadl:resources", p->soap_type() == SOAP_TYPE_wadl__resources ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_wadl__resources(struct soap *soap, const char *URL, wadl__resources const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wadl:resources", p->soap_type() == SOAP_TYPE_wadl__resources ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_wadl__resources(struct soap *soap, const char *URL, wadl__resources const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wadl:resources", p->soap_type() == SOAP_TYPE_wadl__resources ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 wadl__resources * SOAP_FMAC4 soap_get_wadl__resources(struct soap*, wadl__resources *, const char*, const char*);

inline int soap_read_wadl__resources(struct soap *soap, wadl__resources *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_wadl__resources(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_wadl__resources(struct soap *soap, const char *URL, wadl__resources *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_wadl__resources(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_wadl__resources(struct soap *soap, wadl__resources *p)
{
	if (::soap_read_wadl__resources(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE___wadl__method_resource_choice_DEFINED
#define SOAP_TYPE___wadl__method_resource_choice_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out___wadl__method_resource_choice(struct soap*, const char*, int, const __wadl__method_resource_choice *, const char*);
SOAP_FMAC3 __wadl__method_resource_choice * SOAP_FMAC4 soap_in___wadl__method_resource_choice(struct soap*, const char*, __wadl__method_resource_choice *, const char*);
SOAP_FMAC1 __wadl__method_resource_choice * SOAP_FMAC2 wsdl_instantiate___wadl__method_resource_choice(struct soap*, int, const char*, const char*, size_t*);

inline __wadl__method_resource_choice * soap_new___wadl__method_resource_choice(struct soap *soap, int n = -1)
{
	return wsdl_instantiate___wadl__method_resource_choice(soap, n, NULL, NULL, NULL);
}

inline __wadl__method_resource_choice * soap_new_req___wadl__method_resource_choice(
	struct soap *soap)
{
	__wadl__method_resource_choice *_p = ::soap_new___wadl__method_resource_choice(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline __wadl__method_resource_choice * soap_new_set___wadl__method_resource_choice(
	struct soap *soap,
	wadl__method *method,
	wadl__resource *resource)
{
	__wadl__method_resource_choice *_p = ::soap_new___wadl__method_resource_choice(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->__wadl__method_resource_choice::method = method;
		_p->__wadl__method_resource_choice::resource = resource;
	}
	return _p;
}

inline int soap_write___wadl__method_resource_choice(struct soap *soap, __wadl__method_resource_choice const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "-wadl:method-resource-choice", p->soap_type() == SOAP_TYPE___wadl__method_resource_choice ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT___wadl__method_resource_choice(struct soap *soap, const char *URL, __wadl__method_resource_choice const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "-wadl:method-resource-choice", p->soap_type() == SOAP_TYPE___wadl__method_resource_choice ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH___wadl__method_resource_choice(struct soap *soap, const char *URL, __wadl__method_resource_choice const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "-wadl:method-resource-choice", p->soap_type() == SOAP_TYPE___wadl__method_resource_choice ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send___wadl__method_resource_choice(struct soap *soap, const char *URL, __wadl__method_resource_choice const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "-wadl:method-resource-choice", p->soap_type() == SOAP_TYPE___wadl__method_resource_choice ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 __wadl__method_resource_choice * SOAP_FMAC4 soap_get___wadl__method_resource_choice(struct soap*, __wadl__method_resource_choice *, const char*, const char*);

inline int soap_read___wadl__method_resource_choice(struct soap *soap, __wadl__method_resource_choice *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get___wadl__method_resource_choice(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET___wadl__method_resource_choice(struct soap *soap, const char *URL, __wadl__method_resource_choice *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read___wadl__method_resource_choice(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv___wadl__method_resource_choice(struct soap *soap, __wadl__method_resource_choice *p)
{
	if (::soap_read___wadl__method_resource_choice(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_wadl__method_DEFINED
#define SOAP_TYPE_wadl__method_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_wadl__method(struct soap*, const char*, int, const wadl__method *, const char*);
SOAP_FMAC3 wadl__method * SOAP_FMAC4 soap_in_wadl__method(struct soap*, const char*, wadl__method *, const char*);
SOAP_FMAC1 wadl__method * SOAP_FMAC2 wsdl_instantiate_wadl__method(struct soap*, int, const char*, const char*, size_t*);

inline wadl__method * soap_new_wadl__method(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_wadl__method(soap, n, NULL, NULL, NULL);
}

inline wadl__method * soap_new_req_wadl__method(
	struct soap *soap)
{
	wadl__method *_p = ::soap_new_wadl__method(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline wadl__method * soap_new_set_wadl__method(
	struct soap *soap,
	char *id,
	enum wadl__HTTPMethods name,
	char *href,
	const std::vector<wadl__doc> & doc,
	wadl__request *request,
	const std::vector<wadl__response> & response)
{
	wadl__method *_p = ::soap_new_wadl__method(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wadl__method::id = id;
		_p->wadl__method::name = name;
		_p->wadl__method::href = href;
		_p->wadl__method::doc = doc;
		_p->wadl__method::request = request;
		_p->wadl__method::response = response;
	}
	return _p;
}

inline int soap_write_wadl__method(struct soap *soap, wadl__method const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wadl:method", p->soap_type() == SOAP_TYPE_wadl__method ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_wadl__method(struct soap *soap, const char *URL, wadl__method const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wadl:method", p->soap_type() == SOAP_TYPE_wadl__method ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_wadl__method(struct soap *soap, const char *URL, wadl__method const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wadl:method", p->soap_type() == SOAP_TYPE_wadl__method ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_wadl__method(struct soap *soap, const char *URL, wadl__method const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wadl:method", p->soap_type() == SOAP_TYPE_wadl__method ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 wadl__method * SOAP_FMAC4 soap_get_wadl__method(struct soap*, wadl__method *, const char*, const char*);

inline int soap_read_wadl__method(struct soap *soap, wadl__method *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_wadl__method(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_wadl__method(struct soap *soap, const char *URL, wadl__method *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_wadl__method(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_wadl__method(struct soap *soap, wadl__method *p)
{
	if (::soap_read_wadl__method(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_wadl__response_DEFINED
#define SOAP_TYPE_wadl__response_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_wadl__response(struct soap*, const char*, int, const wadl__response *, const char*);
SOAP_FMAC3 wadl__response * SOAP_FMAC4 soap_in_wadl__response(struct soap*, const char*, wadl__response *, const char*);
SOAP_FMAC1 wadl__response * SOAP_FMAC2 wsdl_instantiate_wadl__response(struct soap*, int, const char*, const char*, size_t*);

inline wadl__response * soap_new_wadl__response(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_wadl__response(soap, n, NULL, NULL, NULL);
}

inline wadl__response * soap_new_req_wadl__response(
	struct soap *soap)
{
	wadl__response *_p = ::soap_new_wadl__response(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline wadl__response * soap_new_set_wadl__response(
	struct soap *soap,
	char *status,
	const std::vector<wadl__doc> & doc__1,
	const std::vector<wadl__param> & param__1,
	const std::vector<wadl__representation> & representation__1)
{
	wadl__response *_p = ::soap_new_wadl__response(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wadl__response::status = status;
		_p->wadl__request::doc = doc__1;
		_p->wadl__request::param = param__1;
		_p->wadl__request::representation = representation__1;
	}
	return _p;
}

inline int soap_write_wadl__response(struct soap *soap, wadl__response const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wadl:response", p->soap_type() == SOAP_TYPE_wadl__response ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_wadl__response(struct soap *soap, const char *URL, wadl__response const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wadl:response", p->soap_type() == SOAP_TYPE_wadl__response ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_wadl__response(struct soap *soap, const char *URL, wadl__response const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wadl:response", p->soap_type() == SOAP_TYPE_wadl__response ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_wadl__response(struct soap *soap, const char *URL, wadl__response const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wadl:response", p->soap_type() == SOAP_TYPE_wadl__response ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 wadl__response * SOAP_FMAC4 soap_get_wadl__response(struct soap*, wadl__response *, const char*, const char*);

inline int soap_read_wadl__response(struct soap *soap, wadl__response *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_wadl__response(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_wadl__response(struct soap *soap, const char *URL, wadl__response *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_wadl__response(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_wadl__response(struct soap *soap, wadl__response *p)
{
	if (::soap_read_wadl__response(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_wadl__request_DEFINED
#define SOAP_TYPE_wadl__request_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_wadl__request(struct soap*, const char*, int, const wadl__request *, const char*);
SOAP_FMAC3 wadl__request * SOAP_FMAC4 soap_in_wadl__request(struct soap*, const char*, wadl__request *, const char*);
SOAP_FMAC1 wadl__request * SOAP_FMAC2 wsdl_instantiate_wadl__request(struct soap*, int, const char*, const char*, size_t*);

inline wadl__request * soap_new_wadl__request(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_wadl__request(soap, n, NULL, NULL, NULL);
}

inline wadl__request * soap_new_req_wadl__request(
	struct soap *soap)
{
	wadl__request *_p = ::soap_new_wadl__request(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline wadl__request * soap_new_set_wadl__request(
	struct soap *soap,
	const std::vector<wadl__doc> & doc,
	const std::vector<wadl__param> & param,
	const std::vector<wadl__representation> & representation)
{
	wadl__request *_p = ::soap_new_wadl__request(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wadl__request::doc = doc;
		_p->wadl__request::param = param;
		_p->wadl__request::representation = representation;
	}
	return _p;
}

inline int soap_write_wadl__request(struct soap *soap, wadl__request const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wadl:request", p->soap_type() == SOAP_TYPE_wadl__request ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_wadl__request(struct soap *soap, const char *URL, wadl__request const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wadl:request", p->soap_type() == SOAP_TYPE_wadl__request ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_wadl__request(struct soap *soap, const char *URL, wadl__request const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wadl:request", p->soap_type() == SOAP_TYPE_wadl__request ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_wadl__request(struct soap *soap, const char *URL, wadl__request const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wadl:request", p->soap_type() == SOAP_TYPE_wadl__request ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 wadl__request * SOAP_FMAC4 soap_get_wadl__request(struct soap*, wadl__request *, const char*, const char*);

inline int soap_read_wadl__request(struct soap *soap, wadl__request *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_wadl__request(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_wadl__request(struct soap *soap, const char *URL, wadl__request *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_wadl__request(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_wadl__request(struct soap *soap, wadl__request *p)
{
	if (::soap_read_wadl__request(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_wadl__representation_DEFINED
#define SOAP_TYPE_wadl__representation_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_wadl__representation(struct soap*, const char*, int, const wadl__representation *, const char*);
SOAP_FMAC3 wadl__representation * SOAP_FMAC4 soap_in_wadl__representation(struct soap*, const char*, wadl__representation *, const char*);
SOAP_FMAC1 wadl__representation * SOAP_FMAC2 wsdl_instantiate_wadl__representation(struct soap*, int, const char*, const char*, size_t*);

inline wadl__representation * soap_new_wadl__representation(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_wadl__representation(soap, n, NULL, NULL, NULL);
}

inline wadl__representation * soap_new_req_wadl__representation(
	struct soap *soap)
{
	wadl__representation *_p = ::soap_new_wadl__representation(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline wadl__representation * soap_new_set_wadl__representation(
	struct soap *soap,
	char *id,
	char *element,
	char *mediaType,
	char *href,
	char *profile,
	const std::vector<wadl__doc> & doc,
	const std::vector<wadl__param> & param)
{
	wadl__representation *_p = ::soap_new_wadl__representation(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wadl__representation::id = id;
		_p->wadl__representation::element = element;
		_p->wadl__representation::mediaType = mediaType;
		_p->wadl__representation::href = href;
		_p->wadl__representation::profile = profile;
		_p->wadl__representation::doc = doc;
		_p->wadl__representation::param = param;
	}
	return _p;
}

inline int soap_write_wadl__representation(struct soap *soap, wadl__representation const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wadl:representation", p->soap_type() == SOAP_TYPE_wadl__representation ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_wadl__representation(struct soap *soap, const char *URL, wadl__representation const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wadl:representation", p->soap_type() == SOAP_TYPE_wadl__representation ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_wadl__representation(struct soap *soap, const char *URL, wadl__representation const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wadl:representation", p->soap_type() == SOAP_TYPE_wadl__representation ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_wadl__representation(struct soap *soap, const char *URL, wadl__representation const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wadl:representation", p->soap_type() == SOAP_TYPE_wadl__representation ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 wadl__representation * SOAP_FMAC4 soap_get_wadl__representation(struct soap*, wadl__representation *, const char*, const char*);

inline int soap_read_wadl__representation(struct soap *soap, wadl__representation *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_wadl__representation(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_wadl__representation(struct soap *soap, const char *URL, wadl__representation *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_wadl__representation(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_wadl__representation(struct soap *soap, wadl__representation *p)
{
	if (::soap_read_wadl__representation(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_wadl__grammars_DEFINED
#define SOAP_TYPE_wadl__grammars_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_wadl__grammars(struct soap*, const char*, int, const wadl__grammars *, const char*);
SOAP_FMAC3 wadl__grammars * SOAP_FMAC4 soap_in_wadl__grammars(struct soap*, const char*, wadl__grammars *, const char*);
SOAP_FMAC1 wadl__grammars * SOAP_FMAC2 wsdl_instantiate_wadl__grammars(struct soap*, int, const char*, const char*, size_t*);

inline wadl__grammars * soap_new_wadl__grammars(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_wadl__grammars(soap, n, NULL, NULL, NULL);
}

inline wadl__grammars * soap_new_req_wadl__grammars(
	struct soap *soap)
{
	wadl__grammars *_p = ::soap_new_wadl__grammars(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline wadl__grammars * soap_new_set_wadl__grammars(
	struct soap *soap,
	const std::vector<wadl__doc> & doc,
	const std::vector<wadl__include> & include)
{
	wadl__grammars *_p = ::soap_new_wadl__grammars(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wadl__grammars::doc = doc;
		_p->wadl__grammars::include = include;
	}
	return _p;
}

inline int soap_write_wadl__grammars(struct soap *soap, wadl__grammars const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wadl:grammars", p->soap_type() == SOAP_TYPE_wadl__grammars ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_wadl__grammars(struct soap *soap, const char *URL, wadl__grammars const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wadl:grammars", p->soap_type() == SOAP_TYPE_wadl__grammars ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_wadl__grammars(struct soap *soap, const char *URL, wadl__grammars const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wadl:grammars", p->soap_type() == SOAP_TYPE_wadl__grammars ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_wadl__grammars(struct soap *soap, const char *URL, wadl__grammars const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wadl:grammars", p->soap_type() == SOAP_TYPE_wadl__grammars ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 wadl__grammars * SOAP_FMAC4 soap_get_wadl__grammars(struct soap*, wadl__grammars *, const char*, const char*);

inline int soap_read_wadl__grammars(struct soap *soap, wadl__grammars *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_wadl__grammars(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_wadl__grammars(struct soap *soap, const char *URL, wadl__grammars *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_wadl__grammars(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_wadl__grammars(struct soap *soap, wadl__grammars *p)
{
	if (::soap_read_wadl__grammars(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_wadl__include_DEFINED
#define SOAP_TYPE_wadl__include_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_wadl__include(struct soap*, const char*, int, const wadl__include *, const char*);
SOAP_FMAC3 wadl__include * SOAP_FMAC4 soap_in_wadl__include(struct soap*, const char*, wadl__include *, const char*);
SOAP_FMAC1 wadl__include * SOAP_FMAC2 wsdl_instantiate_wadl__include(struct soap*, int, const char*, const char*, size_t*);

inline wadl__include * soap_new_wadl__include(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_wadl__include(soap, n, NULL, NULL, NULL);
}

inline wadl__include * soap_new_req_wadl__include(
	struct soap *soap)
{
	wadl__include *_p = ::soap_new_wadl__include(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline wadl__include * soap_new_set_wadl__include(
	struct soap *soap,
	char *href,
	const std::vector<wadl__doc> & doc)
{
	wadl__include *_p = ::soap_new_wadl__include(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wadl__include::href = href;
		_p->wadl__include::doc = doc;
	}
	return _p;
}

inline int soap_write_wadl__include(struct soap *soap, wadl__include const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wadl:include", p->soap_type() == SOAP_TYPE_wadl__include ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_wadl__include(struct soap *soap, const char *URL, wadl__include const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wadl:include", p->soap_type() == SOAP_TYPE_wadl__include ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_wadl__include(struct soap *soap, const char *URL, wadl__include const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wadl:include", p->soap_type() == SOAP_TYPE_wadl__include ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_wadl__include(struct soap *soap, const char *URL, wadl__include const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wadl:include", p->soap_type() == SOAP_TYPE_wadl__include ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 wadl__include * SOAP_FMAC4 soap_get_wadl__include(struct soap*, wadl__include *, const char*, const char*);

inline int soap_read_wadl__include(struct soap *soap, wadl__include *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_wadl__include(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_wadl__include(struct soap *soap, const char *URL, wadl__include *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_wadl__include(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_wadl__include(struct soap *soap, wadl__include *p)
{
	if (::soap_read_wadl__include(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_wadl__param_DEFINED
#define SOAP_TYPE_wadl__param_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_wadl__param(struct soap*, const char*, int, const wadl__param *, const char*);
SOAP_FMAC3 wadl__param * SOAP_FMAC4 soap_in_wadl__param(struct soap*, const char*, wadl__param *, const char*);
SOAP_FMAC1 wadl__param * SOAP_FMAC2 wsdl_instantiate_wadl__param(struct soap*, int, const char*, const char*, size_t*);

inline wadl__param * soap_new_wadl__param(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_wadl__param(soap, n, NULL, NULL, NULL);
}

inline wadl__param * soap_new_req_wadl__param(
	struct soap *soap)
{
	wadl__param *_p = ::soap_new_wadl__param(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline wadl__param * soap_new_set_wadl__param(
	struct soap *soap,
	char *href,
	char *name,
	enum wadl__ParamStyle *style,
	char *id,
	char *type,
	char *default_,
	bool required,
	bool repeating,
	char *fixed,
	char *path,
	const std::vector<wadl__doc> & doc,
	const std::vector<wadl__option> & option,
	wadl__link *link)
{
	wadl__param *_p = ::soap_new_wadl__param(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wadl__param::href = href;
		_p->wadl__param::name = name;
		_p->wadl__param::style = style;
		_p->wadl__param::id = id;
		_p->wadl__param::type = type;
		_p->wadl__param::default_ = default_;
		_p->wadl__param::required = required;
		_p->wadl__param::repeating = repeating;
		_p->wadl__param::fixed = fixed;
		_p->wadl__param::path = path;
		_p->wadl__param::doc = doc;
		_p->wadl__param::option = option;
		_p->wadl__param::link = link;
	}
	return _p;
}

inline int soap_write_wadl__param(struct soap *soap, wadl__param const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wadl:param", p->soap_type() == SOAP_TYPE_wadl__param ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_wadl__param(struct soap *soap, const char *URL, wadl__param const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wadl:param", p->soap_type() == SOAP_TYPE_wadl__param ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_wadl__param(struct soap *soap, const char *URL, wadl__param const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wadl:param", p->soap_type() == SOAP_TYPE_wadl__param ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_wadl__param(struct soap *soap, const char *URL, wadl__param const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wadl:param", p->soap_type() == SOAP_TYPE_wadl__param ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 wadl__param * SOAP_FMAC4 soap_get_wadl__param(struct soap*, wadl__param *, const char*, const char*);

inline int soap_read_wadl__param(struct soap *soap, wadl__param *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_wadl__param(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_wadl__param(struct soap *soap, const char *URL, wadl__param *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_wadl__param(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_wadl__param(struct soap *soap, wadl__param *p)
{
	if (::soap_read_wadl__param(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_wadl__link_DEFINED
#define SOAP_TYPE_wadl__link_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_wadl__link(struct soap*, const char*, int, const wadl__link *, const char*);
SOAP_FMAC3 wadl__link * SOAP_FMAC4 soap_in_wadl__link(struct soap*, const char*, wadl__link *, const char*);
SOAP_FMAC1 wadl__link * SOAP_FMAC2 wsdl_instantiate_wadl__link(struct soap*, int, const char*, const char*, size_t*);

inline wadl__link * soap_new_wadl__link(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_wadl__link(soap, n, NULL, NULL, NULL);
}

inline wadl__link * soap_new_req_wadl__link(
	struct soap *soap)
{
	wadl__link *_p = ::soap_new_wadl__link(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline wadl__link * soap_new_set_wadl__link(
	struct soap *soap,
	char *resource_USCOREtype,
	char *rel,
	char *rev,
	const std::vector<wadl__doc> & doc)
{
	wadl__link *_p = ::soap_new_wadl__link(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wadl__link::resource_USCOREtype = resource_USCOREtype;
		_p->wadl__link::rel = rel;
		_p->wadl__link::rev = rev;
		_p->wadl__link::doc = doc;
	}
	return _p;
}

inline int soap_write_wadl__link(struct soap *soap, wadl__link const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wadl:link", p->soap_type() == SOAP_TYPE_wadl__link ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_wadl__link(struct soap *soap, const char *URL, wadl__link const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wadl:link", p->soap_type() == SOAP_TYPE_wadl__link ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_wadl__link(struct soap *soap, const char *URL, wadl__link const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wadl:link", p->soap_type() == SOAP_TYPE_wadl__link ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_wadl__link(struct soap *soap, const char *URL, wadl__link const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wadl:link", p->soap_type() == SOAP_TYPE_wadl__link ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 wadl__link * SOAP_FMAC4 soap_get_wadl__link(struct soap*, wadl__link *, const char*, const char*);

inline int soap_read_wadl__link(struct soap *soap, wadl__link *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_wadl__link(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_wadl__link(struct soap *soap, const char *URL, wadl__link *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_wadl__link(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_wadl__link(struct soap *soap, wadl__link *p)
{
	if (::soap_read_wadl__link(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_wadl__option_DEFINED
#define SOAP_TYPE_wadl__option_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_wadl__option(struct soap*, const char*, int, const wadl__option *, const char*);
SOAP_FMAC3 wadl__option * SOAP_FMAC4 soap_in_wadl__option(struct soap*, const char*, wadl__option *, const char*);
SOAP_FMAC1 wadl__option * SOAP_FMAC2 wsdl_instantiate_wadl__option(struct soap*, int, const char*, const char*, size_t*);

inline wadl__option * soap_new_wadl__option(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_wadl__option(soap, n, NULL, NULL, NULL);
}

inline wadl__option * soap_new_req_wadl__option(
	struct soap *soap)
{
	wadl__option *_p = ::soap_new_wadl__option(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline wadl__option * soap_new_set_wadl__option(
	struct soap *soap,
	char *value,
	char *mediaType,
	const std::vector<wadl__doc> & doc)
{
	wadl__option *_p = ::soap_new_wadl__option(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wadl__option::value = value;
		_p->wadl__option::mediaType = mediaType;
		_p->wadl__option::doc = doc;
	}
	return _p;
}

inline int soap_write_wadl__option(struct soap *soap, wadl__option const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wadl:option", p->soap_type() == SOAP_TYPE_wadl__option ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_wadl__option(struct soap *soap, const char *URL, wadl__option const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wadl:option", p->soap_type() == SOAP_TYPE_wadl__option ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_wadl__option(struct soap *soap, const char *URL, wadl__option const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wadl:option", p->soap_type() == SOAP_TYPE_wadl__option ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_wadl__option(struct soap *soap, const char *URL, wadl__option const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wadl:option", p->soap_type() == SOAP_TYPE_wadl__option ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 wadl__option * SOAP_FMAC4 soap_get_wadl__option(struct soap*, wadl__option *, const char*, const char*);

inline int soap_read_wadl__option(struct soap *soap, wadl__option *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_wadl__option(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_wadl__option(struct soap *soap, const char *URL, wadl__option *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_wadl__option(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_wadl__option(struct soap *soap, wadl__option *p)
{
	if (::soap_read_wadl__option(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_wadl__doc_DEFINED
#define SOAP_TYPE_wadl__doc_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_wadl__doc(struct soap*, const char*, int, const wadl__doc *, const char*);
SOAP_FMAC3 wadl__doc * SOAP_FMAC4 soap_in_wadl__doc(struct soap*, const char*, wadl__doc *, const char*);
SOAP_FMAC1 wadl__doc * SOAP_FMAC2 wsdl_instantiate_wadl__doc(struct soap*, int, const char*, const char*, size_t*);

inline wadl__doc * soap_new_wadl__doc(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_wadl__doc(soap, n, NULL, NULL, NULL);
}

inline wadl__doc * soap_new_req_wadl__doc(
	struct soap *soap)
{
	wadl__doc *_p = ::soap_new_wadl__doc(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline wadl__doc * soap_new_set_wadl__doc(
	struct soap *soap,
	char *title,
	char *xml__lang,
	char *__mixed)
{
	wadl__doc *_p = ::soap_new_wadl__doc(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wadl__doc::title = title;
		_p->wadl__doc::xml__lang = xml__lang;
		_p->wadl__doc::__mixed = __mixed;
	}
	return _p;
}

inline int soap_write_wadl__doc(struct soap *soap, wadl__doc const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wadl:doc", p->soap_type() == SOAP_TYPE_wadl__doc ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_wadl__doc(struct soap *soap, const char *URL, wadl__doc const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wadl:doc", p->soap_type() == SOAP_TYPE_wadl__doc ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_wadl__doc(struct soap *soap, const char *URL, wadl__doc const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wadl:doc", p->soap_type() == SOAP_TYPE_wadl__doc ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_wadl__doc(struct soap *soap, const char *URL, wadl__doc const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wadl:doc", p->soap_type() == SOAP_TYPE_wadl__doc ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 wadl__doc * SOAP_FMAC4 soap_get_wadl__doc(struct soap*, wadl__doc *, const char*, const char*);

inline int soap_read_wadl__doc(struct soap *soap, wadl__doc *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_wadl__doc(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_wadl__doc(struct soap *soap, const char *URL, wadl__doc *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_wadl__doc(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_wadl__doc(struct soap *soap, wadl__doc *p)
{
	if (::soap_read_wadl__doc(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_wadl__resource_USCOREtype_DEFINED
#define SOAP_TYPE_wadl__resource_USCOREtype_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_wadl__resource_USCOREtype(struct soap*, const char*, int, const wadl__resource_USCOREtype *, const char*);
SOAP_FMAC3 wadl__resource_USCOREtype * SOAP_FMAC4 soap_in_wadl__resource_USCOREtype(struct soap*, const char*, wadl__resource_USCOREtype *, const char*);
SOAP_FMAC1 wadl__resource_USCOREtype * SOAP_FMAC2 wsdl_instantiate_wadl__resource_USCOREtype(struct soap*, int, const char*, const char*, size_t*);

inline wadl__resource_USCOREtype * soap_new_wadl__resource_USCOREtype(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_wadl__resource_USCOREtype(soap, n, NULL, NULL, NULL);
}

inline wadl__resource_USCOREtype * soap_new_req_wadl__resource_USCOREtype(
	struct soap *soap)
{
	wadl__resource_USCOREtype *_p = ::soap_new_wadl__resource_USCOREtype(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline wadl__resource_USCOREtype * soap_new_set_wadl__resource_USCOREtype(
	struct soap *soap,
	char *id,
	const std::vector<wadl__doc> & doc,
	const std::vector<wadl__param> & param,
	const std::vector<__wadl__method_resource_choice> & __choice)
{
	wadl__resource_USCOREtype *_p = ::soap_new_wadl__resource_USCOREtype(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wadl__resource_USCOREtype::id = id;
		_p->wadl__resource_USCOREtype::doc = doc;
		_p->wadl__resource_USCOREtype::param = param;
		_p->wadl__resource_USCOREtype::__choice = __choice;
	}
	return _p;
}

inline int soap_write_wadl__resource_USCOREtype(struct soap *soap, wadl__resource_USCOREtype const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wadl:resource_type", p->soap_type() == SOAP_TYPE_wadl__resource_USCOREtype ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_wadl__resource_USCOREtype(struct soap *soap, const char *URL, wadl__resource_USCOREtype const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wadl:resource_type", p->soap_type() == SOAP_TYPE_wadl__resource_USCOREtype ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_wadl__resource_USCOREtype(struct soap *soap, const char *URL, wadl__resource_USCOREtype const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wadl:resource_type", p->soap_type() == SOAP_TYPE_wadl__resource_USCOREtype ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_wadl__resource_USCOREtype(struct soap *soap, const char *URL, wadl__resource_USCOREtype const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wadl:resource_type", p->soap_type() == SOAP_TYPE_wadl__resource_USCOREtype ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 wadl__resource_USCOREtype * SOAP_FMAC4 soap_get_wadl__resource_USCOREtype(struct soap*, wadl__resource_USCOREtype *, const char*, const char*);

inline int soap_read_wadl__resource_USCOREtype(struct soap *soap, wadl__resource_USCOREtype *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_wadl__resource_USCOREtype(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_wadl__resource_USCOREtype(struct soap *soap, const char *URL, wadl__resource_USCOREtype *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_wadl__resource_USCOREtype(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_wadl__resource_USCOREtype(struct soap *soap, wadl__resource_USCOREtype *p)
{
	if (::soap_read_wadl__resource_USCOREtype(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_wadl__resource_DEFINED
#define SOAP_TYPE_wadl__resource_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_wadl__resource(struct soap*, const char*, int, const wadl__resource *, const char*);
SOAP_FMAC3 wadl__resource * SOAP_FMAC4 soap_in_wadl__resource(struct soap*, const char*, wadl__resource *, const char*);
SOAP_FMAC1 wadl__resource * SOAP_FMAC2 wsdl_instantiate_wadl__resource(struct soap*, int, const char*, const char*, size_t*);

inline wadl__resource * soap_new_wadl__resource(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_wadl__resource(soap, n, NULL, NULL, NULL);
}

inline wadl__resource * soap_new_req_wadl__resource(
	struct soap *soap)
{
	wadl__resource *_p = ::soap_new_wadl__resource(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline wadl__resource * soap_new_set_wadl__resource(
	struct soap *soap,
	char *type,
	char *queryType,
	char *path,
	char *id__1,
	const std::vector<wadl__doc> & doc__1,
	const std::vector<wadl__param> & param__1,
	const std::vector<__wadl__method_resource_choice> & __choice__1)
{
	wadl__resource *_p = ::soap_new_wadl__resource(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wadl__resource::type = type;
		_p->wadl__resource::queryType = queryType;
		_p->wadl__resource::path = path;
		_p->wadl__resource_USCOREtype::id = id__1;
		_p->wadl__resource_USCOREtype::doc = doc__1;
		_p->wadl__resource_USCOREtype::param = param__1;
		_p->wadl__resource_USCOREtype::__choice = __choice__1;
	}
	return _p;
}

inline int soap_write_wadl__resource(struct soap *soap, wadl__resource const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wadl:resource", p->soap_type() == SOAP_TYPE_wadl__resource ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_wadl__resource(struct soap *soap, const char *URL, wadl__resource const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wadl:resource", p->soap_type() == SOAP_TYPE_wadl__resource ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_wadl__resource(struct soap *soap, const char *URL, wadl__resource const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wadl:resource", p->soap_type() == SOAP_TYPE_wadl__resource ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_wadl__resource(struct soap *soap, const char *URL, wadl__resource const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wadl:resource", p->soap_type() == SOAP_TYPE_wadl__resource ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 wadl__resource * SOAP_FMAC4 soap_get_wadl__resource(struct soap*, wadl__resource *, const char*, const char*);

inline int soap_read_wadl__resource(struct soap *soap, wadl__resource *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_wadl__resource(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_wadl__resource(struct soap *soap, const char *URL, wadl__resource *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_wadl__resource(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_wadl__resource(struct soap *soap, wadl__resource *p)
{
	if (::soap_read_wadl__resource(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_xs__redefine_DEFINED
#define SOAP_TYPE_xs__redefine_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xs__redefine(struct soap*, const char*, int, const xs__redefine *, const char*);
SOAP_FMAC3 xs__redefine * SOAP_FMAC4 soap_in_xs__redefine(struct soap*, const char*, xs__redefine *, const char*);
SOAP_FMAC1 xs__redefine * SOAP_FMAC2 wsdl_instantiate_xs__redefine(struct soap*, int, const char*, const char*, size_t*);

inline xs__redefine * soap_new_xs__redefine(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_xs__redefine(soap, n, NULL, NULL, NULL);
}

inline xs__redefine * soap_new_req_xs__redefine(
	struct soap *soap)
{
	xs__redefine *_p = ::soap_new_xs__redefine(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline xs__redefine * soap_new_set_xs__redefine(
	struct soap *soap,
	char *schemaLocation,
	const std::vector<xs__group> & group,
	const std::vector<xs__attributeGroup> & attributeGroup,
	const std::vector<xs__simpleType> & simpleType,
	const std::vector<xs__complexType> & complexType)
{
	xs__redefine *_p = ::soap_new_xs__redefine(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->xs__redefine::schemaLocation = schemaLocation;
		_p->xs__redefine::group = group;
		_p->xs__redefine::attributeGroup = attributeGroup;
		_p->xs__redefine::simpleType = simpleType;
		_p->xs__redefine::complexType = complexType;
	}
	return _p;
}

inline int soap_write_xs__redefine(struct soap *soap, xs__redefine const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:redefine", p->soap_type() == SOAP_TYPE_xs__redefine ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_xs__redefine(struct soap *soap, const char *URL, xs__redefine const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:redefine", p->soap_type() == SOAP_TYPE_xs__redefine ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_xs__redefine(struct soap *soap, const char *URL, xs__redefine const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:redefine", p->soap_type() == SOAP_TYPE_xs__redefine ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_xs__redefine(struct soap *soap, const char *URL, xs__redefine const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:redefine", p->soap_type() == SOAP_TYPE_xs__redefine ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 xs__redefine * SOAP_FMAC4 soap_get_xs__redefine(struct soap*, xs__redefine *, const char*, const char*);

inline int soap_read_xs__redefine(struct soap *soap, xs__redefine *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_xs__redefine(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_xs__redefine(struct soap *soap, const char *URL, xs__redefine *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_xs__redefine(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_xs__redefine(struct soap *soap, xs__redefine *p)
{
	if (::soap_read_xs__redefine(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_xs__override_DEFINED
#define SOAP_TYPE_xs__override_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xs__override(struct soap*, const char*, int, const xs__override *, const char*);
SOAP_FMAC3 xs__override * SOAP_FMAC4 soap_in_xs__override(struct soap*, const char*, xs__override *, const char*);
SOAP_FMAC1 xs__override * SOAP_FMAC2 wsdl_instantiate_xs__override(struct soap*, int, const char*, const char*, size_t*);

inline xs__override * soap_new_xs__override(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_xs__override(soap, n, NULL, NULL, NULL);
}

inline xs__override * soap_new_req_xs__override(
	struct soap *soap)
{
	xs__override *_p = ::soap_new_xs__override(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline xs__override * soap_new_set_xs__override(
	struct soap *soap,
	char *schemaLocation,
	const std::vector<xs__attribute> & attribute,
	const std::vector<xs__element> & element,
	const std::vector<xs__group> & group,
	const std::vector<xs__attributeGroup> & attributeGroup,
	const std::vector<xs__simpleType> & simpleType,
	const std::vector<xs__complexType> & complexType)
{
	xs__override *_p = ::soap_new_xs__override(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->xs__override::schemaLocation = schemaLocation;
		_p->xs__override::attribute = attribute;
		_p->xs__override::element = element;
		_p->xs__override::group = group;
		_p->xs__override::attributeGroup = attributeGroup;
		_p->xs__override::simpleType = simpleType;
		_p->xs__override::complexType = complexType;
	}
	return _p;
}

inline int soap_write_xs__override(struct soap *soap, xs__override const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:override", p->soap_type() == SOAP_TYPE_xs__override ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_xs__override(struct soap *soap, const char *URL, xs__override const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:override", p->soap_type() == SOAP_TYPE_xs__override ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_xs__override(struct soap *soap, const char *URL, xs__override const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:override", p->soap_type() == SOAP_TYPE_xs__override ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_xs__override(struct soap *soap, const char *URL, xs__override const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:override", p->soap_type() == SOAP_TYPE_xs__override ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 xs__override * SOAP_FMAC4 soap_get_xs__override(struct soap*, xs__override *, const char*, const char*);

inline int soap_read_xs__override(struct soap *soap, xs__override *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_xs__override(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_xs__override(struct soap *soap, const char *URL, xs__override *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_xs__override(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_xs__override(struct soap *soap, xs__override *p)
{
	if (::soap_read_xs__override(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_xs__include_DEFINED
#define SOAP_TYPE_xs__include_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xs__include(struct soap*, const char*, int, const xs__include *, const char*);
SOAP_FMAC3 xs__include * SOAP_FMAC4 soap_in_xs__include(struct soap*, const char*, xs__include *, const char*);
SOAP_FMAC1 xs__include * SOAP_FMAC2 wsdl_instantiate_xs__include(struct soap*, int, const char*, const char*, size_t*);

inline xs__include * soap_new_xs__include(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_xs__include(soap, n, NULL, NULL, NULL);
}

inline xs__include * soap_new_req_xs__include(
	struct soap *soap)
{
	xs__include *_p = ::soap_new_xs__include(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline xs__include * soap_new_set_xs__include(
	struct soap *soap,
	char *schemaLocation)
{
	xs__include *_p = ::soap_new_xs__include(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->xs__include::schemaLocation = schemaLocation;
	}
	return _p;
}

inline int soap_write_xs__include(struct soap *soap, xs__include const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:include", p->soap_type() == SOAP_TYPE_xs__include ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_xs__include(struct soap *soap, const char *URL, xs__include const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:include", p->soap_type() == SOAP_TYPE_xs__include ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_xs__include(struct soap *soap, const char *URL, xs__include const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:include", p->soap_type() == SOAP_TYPE_xs__include ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_xs__include(struct soap *soap, const char *URL, xs__include const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:include", p->soap_type() == SOAP_TYPE_xs__include ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 xs__include * SOAP_FMAC4 soap_get_xs__include(struct soap*, xs__include *, const char*, const char*);

inline int soap_read_xs__include(struct soap *soap, xs__include *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_xs__include(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_xs__include(struct soap *soap, const char *URL, xs__include *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_xs__include(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_xs__include(struct soap *soap, xs__include *p)
{
	if (::soap_read_xs__include(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_xs__import_DEFINED
#define SOAP_TYPE_xs__import_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xs__import(struct soap*, const char*, int, const xs__import *, const char*);
SOAP_FMAC3 xs__import * SOAP_FMAC4 soap_in_xs__import(struct soap*, const char*, xs__import *, const char*);
SOAP_FMAC1 xs__import * SOAP_FMAC2 wsdl_instantiate_xs__import(struct soap*, int, const char*, const char*, size_t*);

inline xs__import * soap_new_xs__import(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_xs__import(soap, n, NULL, NULL, NULL);
}

inline xs__import * soap_new_req_xs__import(
	struct soap *soap)
{
	xs__import *_p = ::soap_new_xs__import(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline xs__import * soap_new_set_xs__import(
	struct soap *soap,
	char *namespace_,
	char *schemaLocation,
	char *location)
{
	xs__import *_p = ::soap_new_xs__import(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->xs__import::namespace_ = namespace_;
		_p->xs__import::schemaLocation = schemaLocation;
		_p->xs__import::location = location;
	}
	return _p;
}

inline int soap_write_xs__import(struct soap *soap, xs__import const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:import", p->soap_type() == SOAP_TYPE_xs__import ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_xs__import(struct soap *soap, const char *URL, xs__import const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:import", p->soap_type() == SOAP_TYPE_xs__import ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_xs__import(struct soap *soap, const char *URL, xs__import const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:import", p->soap_type() == SOAP_TYPE_xs__import ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_xs__import(struct soap *soap, const char *URL, xs__import const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:import", p->soap_type() == SOAP_TYPE_xs__import ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 xs__import * SOAP_FMAC4 soap_get_xs__import(struct soap*, xs__import *, const char*, const char*);

inline int soap_read_xs__import(struct soap *soap, xs__import *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_xs__import(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_xs__import(struct soap *soap, const char *URL, xs__import *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_xs__import(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_xs__import(struct soap *soap, xs__import *p)
{
	if (::soap_read_xs__import(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_xs__complexContent_DEFINED
#define SOAP_TYPE_xs__complexContent_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xs__complexContent(struct soap*, const char*, int, const xs__complexContent *, const char*);
SOAP_FMAC3 xs__complexContent * SOAP_FMAC4 soap_in_xs__complexContent(struct soap*, const char*, xs__complexContent *, const char*);
SOAP_FMAC1 xs__complexContent * SOAP_FMAC2 wsdl_instantiate_xs__complexContent(struct soap*, int, const char*, const char*, size_t*);

inline xs__complexContent * soap_new_xs__complexContent(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_xs__complexContent(soap, n, NULL, NULL, NULL);
}

inline xs__complexContent * soap_new_req_xs__complexContent(
	struct soap *soap)
{
	xs__complexContent *_p = ::soap_new_xs__complexContent(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline xs__complexContent * soap_new_set_xs__complexContent(
	struct soap *soap,
	bool mixed,
	xs__extension *extension,
	xs__restriction *restriction,
	xs__annotation *annotation)
{
	xs__complexContent *_p = ::soap_new_xs__complexContent(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->xs__complexContent::mixed = mixed;
		_p->xs__complexContent::extension = extension;
		_p->xs__complexContent::restriction = restriction;
		_p->xs__complexContent::annotation = annotation;
	}
	return _p;
}

inline int soap_write_xs__complexContent(struct soap *soap, xs__complexContent const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:complexContent", p->soap_type() == SOAP_TYPE_xs__complexContent ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_xs__complexContent(struct soap *soap, const char *URL, xs__complexContent const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:complexContent", p->soap_type() == SOAP_TYPE_xs__complexContent ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_xs__complexContent(struct soap *soap, const char *URL, xs__complexContent const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:complexContent", p->soap_type() == SOAP_TYPE_xs__complexContent ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_xs__complexContent(struct soap *soap, const char *URL, xs__complexContent const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:complexContent", p->soap_type() == SOAP_TYPE_xs__complexContent ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 xs__complexContent * SOAP_FMAC4 soap_get_xs__complexContent(struct soap*, xs__complexContent *, const char*, const char*);

inline int soap_read_xs__complexContent(struct soap *soap, xs__complexContent *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_xs__complexContent(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_xs__complexContent(struct soap *soap, const char *URL, xs__complexContent *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_xs__complexContent(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_xs__complexContent(struct soap *soap, xs__complexContent *p)
{
	if (::soap_read_xs__complexContent(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_xs__whiteSpace_DEFINED
#define SOAP_TYPE_xs__whiteSpace_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xs__whiteSpace(struct soap*, const char*, int, const xs__whiteSpace *, const char*);
SOAP_FMAC3 xs__whiteSpace * SOAP_FMAC4 soap_in_xs__whiteSpace(struct soap*, const char*, xs__whiteSpace *, const char*);
SOAP_FMAC1 xs__whiteSpace * SOAP_FMAC2 wsdl_instantiate_xs__whiteSpace(struct soap*, int, const char*, const char*, size_t*);

inline xs__whiteSpace * soap_new_xs__whiteSpace(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_xs__whiteSpace(soap, n, NULL, NULL, NULL);
}

inline xs__whiteSpace * soap_new_req_xs__whiteSpace(
	struct soap *soap)
{
	xs__whiteSpace *_p = ::soap_new_xs__whiteSpace(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline xs__whiteSpace * soap_new_set_xs__whiteSpace(
	struct soap *soap,
	char *value)
{
	xs__whiteSpace *_p = ::soap_new_xs__whiteSpace(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->xs__whiteSpace::value = value;
	}
	return _p;
}

inline int soap_write_xs__whiteSpace(struct soap *soap, xs__whiteSpace const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:whiteSpace", p->soap_type() == SOAP_TYPE_xs__whiteSpace ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_xs__whiteSpace(struct soap *soap, const char *URL, xs__whiteSpace const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:whiteSpace", p->soap_type() == SOAP_TYPE_xs__whiteSpace ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_xs__whiteSpace(struct soap *soap, const char *URL, xs__whiteSpace const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:whiteSpace", p->soap_type() == SOAP_TYPE_xs__whiteSpace ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_xs__whiteSpace(struct soap *soap, const char *URL, xs__whiteSpace const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:whiteSpace", p->soap_type() == SOAP_TYPE_xs__whiteSpace ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 xs__whiteSpace * SOAP_FMAC4 soap_get_xs__whiteSpace(struct soap*, xs__whiteSpace *, const char*, const char*);

inline int soap_read_xs__whiteSpace(struct soap *soap, xs__whiteSpace *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_xs__whiteSpace(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_xs__whiteSpace(struct soap *soap, const char *URL, xs__whiteSpace *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_xs__whiteSpace(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_xs__whiteSpace(struct soap *soap, xs__whiteSpace *p)
{
	if (::soap_read_xs__whiteSpace(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_xs__length_DEFINED
#define SOAP_TYPE_xs__length_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xs__length(struct soap*, const char*, int, const xs__length *, const char*);
SOAP_FMAC3 xs__length * SOAP_FMAC4 soap_in_xs__length(struct soap*, const char*, xs__length *, const char*);
SOAP_FMAC1 xs__length * SOAP_FMAC2 wsdl_instantiate_xs__length(struct soap*, int, const char*, const char*, size_t*);

inline xs__length * soap_new_xs__length(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_xs__length(soap, n, NULL, NULL, NULL);
}

inline xs__length * soap_new_req_xs__length(
	struct soap *soap)
{
	xs__length *_p = ::soap_new_xs__length(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline xs__length * soap_new_set_xs__length(
	struct soap *soap,
	char *value,
	bool fixed,
	xs__annotation *annotation)
{
	xs__length *_p = ::soap_new_xs__length(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->xs__length::value = value;
		_p->xs__length::fixed = fixed;
		_p->xs__length::annotation = annotation;
	}
	return _p;
}

inline int soap_write_xs__length(struct soap *soap, xs__length const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:length", p->soap_type() == SOAP_TYPE_xs__length ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_xs__length(struct soap *soap, const char *URL, xs__length const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:length", p->soap_type() == SOAP_TYPE_xs__length ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_xs__length(struct soap *soap, const char *URL, xs__length const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:length", p->soap_type() == SOAP_TYPE_xs__length ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_xs__length(struct soap *soap, const char *URL, xs__length const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:length", p->soap_type() == SOAP_TYPE_xs__length ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 xs__length * SOAP_FMAC4 soap_get_xs__length(struct soap*, xs__length *, const char*, const char*);

inline int soap_read_xs__length(struct soap *soap, xs__length *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_xs__length(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_xs__length(struct soap *soap, const char *URL, xs__length *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_xs__length(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_xs__length(struct soap *soap, xs__length *p)
{
	if (::soap_read_xs__length(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_xs__simpleContent_DEFINED
#define SOAP_TYPE_xs__simpleContent_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xs__simpleContent(struct soap*, const char*, int, const xs__simpleContent *, const char*);
SOAP_FMAC3 xs__simpleContent * SOAP_FMAC4 soap_in_xs__simpleContent(struct soap*, const char*, xs__simpleContent *, const char*);
SOAP_FMAC1 xs__simpleContent * SOAP_FMAC2 wsdl_instantiate_xs__simpleContent(struct soap*, int, const char*, const char*, size_t*);

inline xs__simpleContent * soap_new_xs__simpleContent(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_xs__simpleContent(soap, n, NULL, NULL, NULL);
}

inline xs__simpleContent * soap_new_req_xs__simpleContent(
	struct soap *soap)
{
	xs__simpleContent *_p = ::soap_new_xs__simpleContent(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline xs__simpleContent * soap_new_set_xs__simpleContent(
	struct soap *soap,
	xs__extension *extension,
	xs__restriction *restriction)
{
	xs__simpleContent *_p = ::soap_new_xs__simpleContent(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->xs__simpleContent::extension = extension;
		_p->xs__simpleContent::restriction = restriction;
	}
	return _p;
}

inline int soap_write_xs__simpleContent(struct soap *soap, xs__simpleContent const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:simpleContent", p->soap_type() == SOAP_TYPE_xs__simpleContent ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_xs__simpleContent(struct soap *soap, const char *URL, xs__simpleContent const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:simpleContent", p->soap_type() == SOAP_TYPE_xs__simpleContent ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_xs__simpleContent(struct soap *soap, const char *URL, xs__simpleContent const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:simpleContent", p->soap_type() == SOAP_TYPE_xs__simpleContent ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_xs__simpleContent(struct soap *soap, const char *URL, xs__simpleContent const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:simpleContent", p->soap_type() == SOAP_TYPE_xs__simpleContent ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 xs__simpleContent * SOAP_FMAC4 soap_get_xs__simpleContent(struct soap*, xs__simpleContent *, const char*, const char*);

inline int soap_read_xs__simpleContent(struct soap *soap, xs__simpleContent *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_xs__simpleContent(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_xs__simpleContent(struct soap *soap, const char *URL, xs__simpleContent *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_xs__simpleContent(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_xs__simpleContent(struct soap *soap, xs__simpleContent *p)
{
	if (::soap_read_xs__simpleContent(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_xs__pattern_DEFINED
#define SOAP_TYPE_xs__pattern_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xs__pattern(struct soap*, const char*, int, const xs__pattern *, const char*);
SOAP_FMAC3 xs__pattern * SOAP_FMAC4 soap_in_xs__pattern(struct soap*, const char*, xs__pattern *, const char*);
SOAP_FMAC1 xs__pattern * SOAP_FMAC2 wsdl_instantiate_xs__pattern(struct soap*, int, const char*, const char*, size_t*);

inline xs__pattern * soap_new_xs__pattern(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_xs__pattern(soap, n, NULL, NULL, NULL);
}

inline xs__pattern * soap_new_req_xs__pattern(
	struct soap *soap)
{
	xs__pattern *_p = ::soap_new_xs__pattern(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline xs__pattern * soap_new_set_xs__pattern(
	struct soap *soap,
	char *value)
{
	xs__pattern *_p = ::soap_new_xs__pattern(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->xs__pattern::value = value;
	}
	return _p;
}

inline int soap_write_xs__pattern(struct soap *soap, xs__pattern const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:pattern", p->soap_type() == SOAP_TYPE_xs__pattern ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_xs__pattern(struct soap *soap, const char *URL, xs__pattern const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:pattern", p->soap_type() == SOAP_TYPE_xs__pattern ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_xs__pattern(struct soap *soap, const char *URL, xs__pattern const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:pattern", p->soap_type() == SOAP_TYPE_xs__pattern ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_xs__pattern(struct soap *soap, const char *URL, xs__pattern const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:pattern", p->soap_type() == SOAP_TYPE_xs__pattern ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 xs__pattern * SOAP_FMAC4 soap_get_xs__pattern(struct soap*, xs__pattern *, const char*, const char*);

inline int soap_read_xs__pattern(struct soap *soap, xs__pattern *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_xs__pattern(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_xs__pattern(struct soap *soap, const char *URL, xs__pattern *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_xs__pattern(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_xs__pattern(struct soap *soap, xs__pattern *p)
{
	if (::soap_read_xs__pattern(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_xs__enumeration_DEFINED
#define SOAP_TYPE_xs__enumeration_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xs__enumeration(struct soap*, const char*, int, const xs__enumeration *, const char*);
SOAP_FMAC3 xs__enumeration * SOAP_FMAC4 soap_in_xs__enumeration(struct soap*, const char*, xs__enumeration *, const char*);
SOAP_FMAC1 xs__enumeration * SOAP_FMAC2 wsdl_instantiate_xs__enumeration(struct soap*, int, const char*, const char*, size_t*);

inline xs__enumeration * soap_new_xs__enumeration(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_xs__enumeration(soap, n, NULL, NULL, NULL);
}

inline xs__enumeration * soap_new_req_xs__enumeration(
	struct soap *soap)
{
	xs__enumeration *_p = ::soap_new_xs__enumeration(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline xs__enumeration * soap_new_set_xs__enumeration(
	struct soap *soap,
	char *value,
	char *value_,
	xs__annotation *annotation)
{
	xs__enumeration *_p = ::soap_new_xs__enumeration(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->xs__enumeration::value = value;
		_p->xs__enumeration::value_ = value_;
		_p->xs__enumeration::annotation = annotation;
	}
	return _p;
}

inline int soap_write_xs__enumeration(struct soap *soap, xs__enumeration const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:enumeration", p->soap_type() == SOAP_TYPE_xs__enumeration ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_xs__enumeration(struct soap *soap, const char *URL, xs__enumeration const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:enumeration", p->soap_type() == SOAP_TYPE_xs__enumeration ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_xs__enumeration(struct soap *soap, const char *URL, xs__enumeration const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:enumeration", p->soap_type() == SOAP_TYPE_xs__enumeration ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_xs__enumeration(struct soap *soap, const char *URL, xs__enumeration const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:enumeration", p->soap_type() == SOAP_TYPE_xs__enumeration ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 xs__enumeration * SOAP_FMAC4 soap_get_xs__enumeration(struct soap*, xs__enumeration *, const char*, const char*);

inline int soap_read_xs__enumeration(struct soap *soap, xs__enumeration *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_xs__enumeration(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_xs__enumeration(struct soap *soap, const char *URL, xs__enumeration *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_xs__enumeration(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_xs__enumeration(struct soap *soap, xs__enumeration *p)
{
	if (::soap_read_xs__enumeration(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_xs__attributeGroup_DEFINED
#define SOAP_TYPE_xs__attributeGroup_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xs__attributeGroup(struct soap*, const char*, int, const xs__attributeGroup *, const char*);
SOAP_FMAC3 xs__attributeGroup * SOAP_FMAC4 soap_in_xs__attributeGroup(struct soap*, const char*, xs__attributeGroup *, const char*);
SOAP_FMAC1 xs__attributeGroup * SOAP_FMAC2 wsdl_instantiate_xs__attributeGroup(struct soap*, int, const char*, const char*, size_t*);

inline xs__attributeGroup * soap_new_xs__attributeGroup(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_xs__attributeGroup(soap, n, NULL, NULL, NULL);
}

inline xs__attributeGroup * soap_new_req_xs__attributeGroup(
	struct soap *soap)
{
	xs__attributeGroup *_p = ::soap_new_xs__attributeGroup(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline xs__attributeGroup * soap_new_set_xs__attributeGroup(
	struct soap *soap,
	char *name,
	char *ref,
	xs__annotation *annotation,
	const std::vector<xs__attribute> & attribute,
	const std::vector<xs__attributeGroup> & attributeGroup,
	xs__anyAttribute *anyAttribute)
{
	xs__attributeGroup *_p = ::soap_new_xs__attributeGroup(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->xs__attributeGroup::name = name;
		_p->xs__attributeGroup::ref = ref;
		_p->xs__attributeGroup::annotation = annotation;
		_p->xs__attributeGroup::attribute = attribute;
		_p->xs__attributeGroup::attributeGroup = attributeGroup;
		_p->xs__attributeGroup::anyAttribute = anyAttribute;
	}
	return _p;
}

inline int soap_write_xs__attributeGroup(struct soap *soap, xs__attributeGroup const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:attributeGroup", p->soap_type() == SOAP_TYPE_xs__attributeGroup ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_xs__attributeGroup(struct soap *soap, const char *URL, xs__attributeGroup const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:attributeGroup", p->soap_type() == SOAP_TYPE_xs__attributeGroup ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_xs__attributeGroup(struct soap *soap, const char *URL, xs__attributeGroup const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:attributeGroup", p->soap_type() == SOAP_TYPE_xs__attributeGroup ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_xs__attributeGroup(struct soap *soap, const char *URL, xs__attributeGroup const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:attributeGroup", p->soap_type() == SOAP_TYPE_xs__attributeGroup ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 xs__attributeGroup * SOAP_FMAC4 soap_get_xs__attributeGroup(struct soap*, xs__attributeGroup *, const char*, const char*);

inline int soap_read_xs__attributeGroup(struct soap *soap, xs__attributeGroup *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_xs__attributeGroup(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_xs__attributeGroup(struct soap *soap, const char *URL, xs__attributeGroup *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_xs__attributeGroup(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_xs__attributeGroup(struct soap *soap, xs__attributeGroup *p)
{
	if (::soap_read_xs__attributeGroup(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_xs__anyAttribute_DEFINED
#define SOAP_TYPE_xs__anyAttribute_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xs__anyAttribute(struct soap*, const char*, int, const xs__anyAttribute *, const char*);
SOAP_FMAC3 xs__anyAttribute * SOAP_FMAC4 soap_in_xs__anyAttribute(struct soap*, const char*, xs__anyAttribute *, const char*);
SOAP_FMAC1 xs__anyAttribute * SOAP_FMAC2 wsdl_instantiate_xs__anyAttribute(struct soap*, int, const char*, const char*, size_t*);

inline xs__anyAttribute * soap_new_xs__anyAttribute(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_xs__anyAttribute(soap, n, NULL, NULL, NULL);
}

inline xs__anyAttribute * soap_new_req_xs__anyAttribute(
	struct soap *soap)
{
	xs__anyAttribute *_p = ::soap_new_xs__anyAttribute(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline xs__anyAttribute * soap_new_set_xs__anyAttribute(
	struct soap *soap,
	char *namespace_,
	enum xs__processContents processContents)
{
	xs__anyAttribute *_p = ::soap_new_xs__anyAttribute(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->xs__anyAttribute::namespace_ = namespace_;
		_p->xs__anyAttribute::processContents = processContents;
	}
	return _p;
}

inline int soap_write_xs__anyAttribute(struct soap *soap, xs__anyAttribute const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:anyAttribute", p->soap_type() == SOAP_TYPE_xs__anyAttribute ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_xs__anyAttribute(struct soap *soap, const char *URL, xs__anyAttribute const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:anyAttribute", p->soap_type() == SOAP_TYPE_xs__anyAttribute ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_xs__anyAttribute(struct soap *soap, const char *URL, xs__anyAttribute const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:anyAttribute", p->soap_type() == SOAP_TYPE_xs__anyAttribute ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_xs__anyAttribute(struct soap *soap, const char *URL, xs__anyAttribute const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:anyAttribute", p->soap_type() == SOAP_TYPE_xs__anyAttribute ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 xs__anyAttribute * SOAP_FMAC4 soap_get_xs__anyAttribute(struct soap*, xs__anyAttribute *, const char*, const char*);

inline int soap_read_xs__anyAttribute(struct soap *soap, xs__anyAttribute *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_xs__anyAttribute(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_xs__anyAttribute(struct soap *soap, const char *URL, xs__anyAttribute *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_xs__anyAttribute(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_xs__anyAttribute(struct soap *soap, xs__anyAttribute *p)
{
	if (::soap_read_xs__anyAttribute(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_xs__contents_DEFINED
#define SOAP_TYPE_xs__contents_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xs__contents(struct soap*, const char*, int, const xs__contents *, const char*);
SOAP_FMAC3 xs__contents * SOAP_FMAC4 soap_in_xs__contents(struct soap*, const char*, xs__contents *, const char*);
SOAP_FMAC1 xs__contents * SOAP_FMAC2 wsdl_instantiate_xs__contents(struct soap*, int, const char*, const char*, size_t*);

inline xs__contents * soap_new_xs__contents(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_xs__contents(soap, n, NULL, NULL, NULL);
}

inline xs__contents * soap_new_req_xs__contents(
	struct soap *soap,
	const union xs__union_content& __content)
{
	xs__contents *_p = ::soap_new_xs__contents(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->xs__contents::__content = __content;
	}
	return _p;
}

inline xs__contents * soap_new_set_xs__contents(
	struct soap *soap,
	int __union,
	const union xs__union_content& __content)
{
	xs__contents *_p = ::soap_new_xs__contents(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->xs__contents::__union = __union;
		_p->xs__contents::__content = __content;
	}
	return _p;
}

inline int soap_write_xs__contents(struct soap *soap, xs__contents const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:contents", p->soap_type() == SOAP_TYPE_xs__contents ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_xs__contents(struct soap *soap, const char *URL, xs__contents const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:contents", p->soap_type() == SOAP_TYPE_xs__contents ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_xs__contents(struct soap *soap, const char *URL, xs__contents const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:contents", p->soap_type() == SOAP_TYPE_xs__contents ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_xs__contents(struct soap *soap, const char *URL, xs__contents const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:contents", p->soap_type() == SOAP_TYPE_xs__contents ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 xs__contents * SOAP_FMAC4 soap_get_xs__contents(struct soap*, xs__contents *, const char*, const char*);

inline int soap_read_xs__contents(struct soap *soap, xs__contents *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_xs__contents(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_xs__contents(struct soap *soap, const char *URL, xs__contents *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_xs__contents(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_xs__contents(struct soap *soap, xs__contents *p)
{
	if (::soap_read_xs__contents(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_xs__any_DEFINED
#define SOAP_TYPE_xs__any_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xs__any(struct soap*, const char*, int, const xs__any *, const char*);
SOAP_FMAC3 xs__any * SOAP_FMAC4 soap_in_xs__any(struct soap*, const char*, xs__any *, const char*);
SOAP_FMAC1 xs__any * SOAP_FMAC2 wsdl_instantiate_xs__any(struct soap*, int, const char*, const char*, size_t*);

inline xs__any * soap_new_xs__any(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_xs__any(soap, n, NULL, NULL, NULL);
}

inline xs__any * soap_new_req_xs__any(
	struct soap *soap)
{
	xs__any *_p = ::soap_new_xs__any(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline xs__any * soap_new_set_xs__any(
	struct soap *soap,
	char *namespace_,
	enum xs__processContents processContents,
	char *minOccurs,
	char *maxOccurs,
	const std::vector<xs__element> & element)
{
	xs__any *_p = ::soap_new_xs__any(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->xs__any::namespace_ = namespace_;
		_p->xs__any::processContents = processContents;
		_p->xs__any::minOccurs = minOccurs;
		_p->xs__any::maxOccurs = maxOccurs;
		_p->xs__any::element = element;
	}
	return _p;
}

inline int soap_write_xs__any(struct soap *soap, xs__any const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:any", p->soap_type() == SOAP_TYPE_xs__any ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_xs__any(struct soap *soap, const char *URL, xs__any const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:any", p->soap_type() == SOAP_TYPE_xs__any ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_xs__any(struct soap *soap, const char *URL, xs__any const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:any", p->soap_type() == SOAP_TYPE_xs__any ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_xs__any(struct soap *soap, const char *URL, xs__any const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:any", p->soap_type() == SOAP_TYPE_xs__any ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 xs__any * SOAP_FMAC4 soap_get_xs__any(struct soap*, xs__any *, const char*, const char*);

inline int soap_read_xs__any(struct soap *soap, xs__any *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_xs__any(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_xs__any(struct soap *soap, const char *URL, xs__any *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_xs__any(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_xs__any(struct soap *soap, xs__any *p)
{
	if (::soap_read_xs__any(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_xs__all_DEFINED
#define SOAP_TYPE_xs__all_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xs__all(struct soap*, const char*, int, const xs__all *, const char*);
SOAP_FMAC3 xs__all * SOAP_FMAC4 soap_in_xs__all(struct soap*, const char*, xs__all *, const char*);
SOAP_FMAC1 xs__all * SOAP_FMAC2 wsdl_instantiate_xs__all(struct soap*, int, const char*, const char*, size_t*);

inline xs__all * soap_new_xs__all(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_xs__all(soap, n, NULL, NULL, NULL);
}

inline xs__all * soap_new_req_xs__all(
	struct soap *soap)
{
	xs__all *_p = ::soap_new_xs__all(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline xs__all * soap_new_set_xs__all(
	struct soap *soap,
	const std::vector<xs__element> & element)
{
	xs__all *_p = ::soap_new_xs__all(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->xs__all::element = element;
	}
	return _p;
}

inline int soap_write_xs__all(struct soap *soap, xs__all const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:all", p->soap_type() == SOAP_TYPE_xs__all ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_xs__all(struct soap *soap, const char *URL, xs__all const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:all", p->soap_type() == SOAP_TYPE_xs__all ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_xs__all(struct soap *soap, const char *URL, xs__all const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:all", p->soap_type() == SOAP_TYPE_xs__all ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_xs__all(struct soap *soap, const char *URL, xs__all const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:all", p->soap_type() == SOAP_TYPE_xs__all ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 xs__all * SOAP_FMAC4 soap_get_xs__all(struct soap*, xs__all *, const char*, const char*);

inline int soap_read_xs__all(struct soap *soap, xs__all *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_xs__all(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_xs__all(struct soap *soap, const char *URL, xs__all *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_xs__all(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_xs__all(struct soap *soap, xs__all *p)
{
	if (::soap_read_xs__all(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_xs__attribute_DEFINED
#define SOAP_TYPE_xs__attribute_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xs__attribute(struct soap*, const char*, int, const xs__attribute *, const char*);
SOAP_FMAC3 xs__attribute * SOAP_FMAC4 soap_in_xs__attribute(struct soap*, const char*, xs__attribute *, const char*);
SOAP_FMAC1 xs__attribute * SOAP_FMAC2 wsdl_instantiate_xs__attribute(struct soap*, int, const char*, const char*, size_t*);

inline xs__attribute * soap_new_xs__attribute(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_xs__attribute(soap, n, NULL, NULL, NULL);
}

inline xs__attribute * soap_new_req_xs__attribute(
	struct soap *soap)
{
	xs__attribute *_p = ::soap_new_xs__attribute(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline xs__attribute * soap_new_set_xs__attribute(
	struct soap *soap,
	char *name,
	char *ref,
	char *type,
	enum xs__attribute_use use,
	char *default_,
	char *default__,
	char *fixed,
	char *fixed_,
	enum xs__formChoice *form,
	bool inheritable,
	char *targetNamespace,
	char *wsdl__arrayType,
	xs__annotation *annotation,
	xs__simpleType *simpleType)
{
	xs__attribute *_p = ::soap_new_xs__attribute(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->xs__attribute::name = name;
		_p->xs__attribute::ref = ref;
		_p->xs__attribute::type = type;
		_p->xs__attribute::use = use;
		_p->xs__attribute::default_ = default_;
		_p->xs__attribute::default__ = default__;
		_p->xs__attribute::fixed = fixed;
		_p->xs__attribute::fixed_ = fixed_;
		_p->xs__attribute::form = form;
		_p->xs__attribute::inheritable = inheritable;
		_p->xs__attribute::targetNamespace = targetNamespace;
		_p->xs__attribute::wsdl__arrayType = wsdl__arrayType;
		_p->xs__attribute::annotation = annotation;
		_p->xs__attribute::simpleType = simpleType;
	}
	return _p;
}

inline int soap_write_xs__attribute(struct soap *soap, xs__attribute const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:attribute", p->soap_type() == SOAP_TYPE_xs__attribute ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_xs__attribute(struct soap *soap, const char *URL, xs__attribute const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:attribute", p->soap_type() == SOAP_TYPE_xs__attribute ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_xs__attribute(struct soap *soap, const char *URL, xs__attribute const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:attribute", p->soap_type() == SOAP_TYPE_xs__attribute ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_xs__attribute(struct soap *soap, const char *URL, xs__attribute const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:attribute", p->soap_type() == SOAP_TYPE_xs__attribute ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 xs__attribute * SOAP_FMAC4 soap_get_xs__attribute(struct soap*, xs__attribute *, const char*, const char*);

inline int soap_read_xs__attribute(struct soap *soap, xs__attribute *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_xs__attribute(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_xs__attribute(struct soap *soap, const char *URL, xs__attribute *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_xs__attribute(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_xs__attribute(struct soap *soap, xs__attribute *p)
{
	if (::soap_read_xs__attribute(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_xs__element_DEFINED
#define SOAP_TYPE_xs__element_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xs__element(struct soap*, const char*, int, const xs__element *, const char*);
SOAP_FMAC3 xs__element * SOAP_FMAC4 soap_in_xs__element(struct soap*, const char*, xs__element *, const char*);
SOAP_FMAC1 xs__element * SOAP_FMAC2 wsdl_instantiate_xs__element(struct soap*, int, const char*, const char*, size_t*);

inline xs__element * soap_new_xs__element(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_xs__element(soap, n, NULL, NULL, NULL);
}

inline xs__element * soap_new_req_xs__element(
	struct soap *soap)
{
	xs__element *_p = ::soap_new_xs__element(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline xs__element * soap_new_set_xs__element(
	struct soap *soap,
	char *name,
	char *ref,
	char *type,
	char *default_,
	char *default__,
	char *fixed,
	char *fixed_,
	enum xs__formChoice *form,
	bool nillable,
	bool abstract,
	char *substitutionGroup,
	char *minOccurs,
	char *maxOccurs,
	char *targetNamespace,
	char *xmime__expectedContentTypes,
	xs__annotation *annotation,
	xs__simpleType *simpleType,
	xs__complexType *complexType,
	const std::vector<xs__alternative> & alternative,
	char *unique)
{
	xs__element *_p = ::soap_new_xs__element(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->xs__element::name = name;
		_p->xs__element::ref = ref;
		_p->xs__element::type = type;
		_p->xs__element::default_ = default_;
		_p->xs__element::default__ = default__;
		_p->xs__element::fixed = fixed;
		_p->xs__element::fixed_ = fixed_;
		_p->xs__element::form = form;
		_p->xs__element::nillable = nillable;
		_p->xs__element::abstract = abstract;
		_p->xs__element::substitutionGroup = substitutionGroup;
		_p->xs__element::minOccurs = minOccurs;
		_p->xs__element::maxOccurs = maxOccurs;
		_p->xs__element::targetNamespace = targetNamespace;
		_p->xs__element::xmime__expectedContentTypes = xmime__expectedContentTypes;
		_p->xs__element::annotation = annotation;
		_p->xs__element::simpleType = simpleType;
		_p->xs__element::complexType = complexType;
		_p->xs__element::alternative = alternative;
		_p->xs__element::unique = unique;
	}
	return _p;
}

inline int soap_write_xs__element(struct soap *soap, xs__element const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:element", p->soap_type() == SOAP_TYPE_xs__element ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_xs__element(struct soap *soap, const char *URL, xs__element const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:element", p->soap_type() == SOAP_TYPE_xs__element ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_xs__element(struct soap *soap, const char *URL, xs__element const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:element", p->soap_type() == SOAP_TYPE_xs__element ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_xs__element(struct soap *soap, const char *URL, xs__element const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:element", p->soap_type() == SOAP_TYPE_xs__element ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 xs__element * SOAP_FMAC4 soap_get_xs__element(struct soap*, xs__element *, const char*, const char*);

inline int soap_read_xs__element(struct soap *soap, xs__element *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_xs__element(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_xs__element(struct soap *soap, const char *URL, xs__element *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_xs__element(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_xs__element(struct soap *soap, xs__element *p)
{
	if (::soap_read_xs__element(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_xs__alternative_DEFINED
#define SOAP_TYPE_xs__alternative_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xs__alternative(struct soap*, const char*, int, const xs__alternative *, const char*);
SOAP_FMAC3 xs__alternative * SOAP_FMAC4 soap_in_xs__alternative(struct soap*, const char*, xs__alternative *, const char*);
SOAP_FMAC1 xs__alternative * SOAP_FMAC2 wsdl_instantiate_xs__alternative(struct soap*, int, const char*, const char*, size_t*);

inline xs__alternative * soap_new_xs__alternative(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_xs__alternative(soap, n, NULL, NULL, NULL);
}

inline xs__alternative * soap_new_req_xs__alternative(
	struct soap *soap)
{
	xs__alternative *_p = ::soap_new_xs__alternative(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline xs__alternative * soap_new_set_xs__alternative(
	struct soap *soap,
	char *test,
	char *type,
	char *xpathDefaultNamespace,
	xs__annotation *annotation)
{
	xs__alternative *_p = ::soap_new_xs__alternative(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->xs__alternative::test = test;
		_p->xs__alternative::type = type;
		_p->xs__alternative::xpathDefaultNamespace = xpathDefaultNamespace;
		_p->xs__alternative::annotation = annotation;
	}
	return _p;
}

inline int soap_write_xs__alternative(struct soap *soap, xs__alternative const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:alternative", p->soap_type() == SOAP_TYPE_xs__alternative ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_xs__alternative(struct soap *soap, const char *URL, xs__alternative const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:alternative", p->soap_type() == SOAP_TYPE_xs__alternative ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_xs__alternative(struct soap *soap, const char *URL, xs__alternative const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:alternative", p->soap_type() == SOAP_TYPE_xs__alternative ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_xs__alternative(struct soap *soap, const char *URL, xs__alternative const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:alternative", p->soap_type() == SOAP_TYPE_xs__alternative ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 xs__alternative * SOAP_FMAC4 soap_get_xs__alternative(struct soap*, xs__alternative *, const char*, const char*);

inline int soap_read_xs__alternative(struct soap *soap, xs__alternative *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_xs__alternative(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_xs__alternative(struct soap *soap, const char *URL, xs__alternative *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_xs__alternative(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_xs__alternative(struct soap *soap, xs__alternative *p)
{
	if (::soap_read_xs__alternative(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_xs__assert_DEFINED
#define SOAP_TYPE_xs__assert_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xs__assert(struct soap*, const char*, int, const xs__assert *, const char*);
SOAP_FMAC3 xs__assert * SOAP_FMAC4 soap_in_xs__assert(struct soap*, const char*, xs__assert *, const char*);
SOAP_FMAC1 xs__assert * SOAP_FMAC2 wsdl_instantiate_xs__assert(struct soap*, int, const char*, const char*, size_t*);

inline xs__assert * soap_new_xs__assert(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_xs__assert(soap, n, NULL, NULL, NULL);
}

inline xs__assert * soap_new_req_xs__assert(
	struct soap *soap)
{
	xs__assert *_p = ::soap_new_xs__assert(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline xs__assert * soap_new_set_xs__assert(
	struct soap *soap,
	char *test,
	char *xpathDefaultNamespace,
	xs__annotation *annotation)
{
	xs__assert *_p = ::soap_new_xs__assert(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->xs__assert::test = test;
		_p->xs__assert::xpathDefaultNamespace = xpathDefaultNamespace;
		_p->xs__assert::annotation = annotation;
	}
	return _p;
}

inline int soap_write_xs__assert(struct soap *soap, xs__assert const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:assert", p->soap_type() == SOAP_TYPE_xs__assert ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_xs__assert(struct soap *soap, const char *URL, xs__assert const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:assert", p->soap_type() == SOAP_TYPE_xs__assert ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_xs__assert(struct soap *soap, const char *URL, xs__assert const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:assert", p->soap_type() == SOAP_TYPE_xs__assert ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_xs__assert(struct soap *soap, const char *URL, xs__assert const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:assert", p->soap_type() == SOAP_TYPE_xs__assert ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 xs__assert * SOAP_FMAC4 soap_get_xs__assert(struct soap*, xs__assert *, const char*, const char*);

inline int soap_read_xs__assert(struct soap *soap, xs__assert *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_xs__assert(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_xs__assert(struct soap *soap, const char *URL, xs__assert *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_xs__assert(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_xs__assert(struct soap *soap, xs__assert *p)
{
	if (::soap_read_xs__assert(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_xs__annotation_DEFINED
#define SOAP_TYPE_xs__annotation_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xs__annotation(struct soap*, const char*, int, const xs__annotation *, const char*);
SOAP_FMAC3 xs__annotation * SOAP_FMAC4 soap_in_xs__annotation(struct soap*, const char*, xs__annotation *, const char*);
SOAP_FMAC1 xs__annotation * SOAP_FMAC2 wsdl_instantiate_xs__annotation(struct soap*, int, const char*, const char*, size_t*);

inline xs__annotation * soap_new_xs__annotation(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_xs__annotation(soap, n, NULL, NULL, NULL);
}

inline xs__annotation * soap_new_req_xs__annotation(
	struct soap *soap)
{
	xs__annotation *_p = ::soap_new_xs__annotation(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline xs__annotation * soap_new_set_xs__annotation(
	struct soap *soap,
	const std::vector<char *> & documentation)
{
	xs__annotation *_p = ::soap_new_xs__annotation(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->xs__annotation::documentation = documentation;
	}
	return _p;
}

inline int soap_write_xs__annotation(struct soap *soap, xs__annotation const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:annotation", p->soap_type() == SOAP_TYPE_xs__annotation ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_xs__annotation(struct soap *soap, const char *URL, xs__annotation const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:annotation", p->soap_type() == SOAP_TYPE_xs__annotation ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_xs__annotation(struct soap *soap, const char *URL, xs__annotation const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:annotation", p->soap_type() == SOAP_TYPE_xs__annotation ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_xs__annotation(struct soap *soap, const char *URL, xs__annotation const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:annotation", p->soap_type() == SOAP_TYPE_xs__annotation ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 xs__annotation * SOAP_FMAC4 soap_get_xs__annotation(struct soap*, xs__annotation *, const char*, const char*);

inline int soap_read_xs__annotation(struct soap *soap, xs__annotation *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_xs__annotation(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_xs__annotation(struct soap *soap, const char *URL, xs__annotation *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_xs__annotation(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_xs__annotation(struct soap *soap, xs__annotation *p)
{
	if (::soap_read_xs__annotation(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_xs__union_DEFINED
#define SOAP_TYPE_xs__union_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xs__union(struct soap*, const char*, int, const xs__union *, const char*);
SOAP_FMAC3 xs__union * SOAP_FMAC4 soap_in_xs__union(struct soap*, const char*, xs__union *, const char*);
SOAP_FMAC1 xs__union * SOAP_FMAC2 wsdl_instantiate_xs__union(struct soap*, int, const char*, const char*, size_t*);

inline xs__union * soap_new_xs__union(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_xs__union(soap, n, NULL, NULL, NULL);
}

inline xs__union * soap_new_req_xs__union(
	struct soap *soap)
{
	xs__union *_p = ::soap_new_xs__union(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline xs__union * soap_new_set_xs__union(
	struct soap *soap,
	char *memberTypes,
	const std::vector<xs__simpleType> & simpleType)
{
	xs__union *_p = ::soap_new_xs__union(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->xs__union::memberTypes = memberTypes;
		_p->xs__union::simpleType = simpleType;
	}
	return _p;
}

inline int soap_write_xs__union(struct soap *soap, xs__union const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:union", p->soap_type() == SOAP_TYPE_xs__union ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_xs__union(struct soap *soap, const char *URL, xs__union const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:union", p->soap_type() == SOAP_TYPE_xs__union ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_xs__union(struct soap *soap, const char *URL, xs__union const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:union", p->soap_type() == SOAP_TYPE_xs__union ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_xs__union(struct soap *soap, const char *URL, xs__union const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:union", p->soap_type() == SOAP_TYPE_xs__union ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 xs__union * SOAP_FMAC4 soap_get_xs__union(struct soap*, xs__union *, const char*, const char*);

inline int soap_read_xs__union(struct soap *soap, xs__union *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_xs__union(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_xs__union(struct soap *soap, const char *URL, xs__union *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_xs__union(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_xs__union(struct soap *soap, xs__union *p)
{
	if (::soap_read_xs__union(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_xs__list_DEFINED
#define SOAP_TYPE_xs__list_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xs__list(struct soap*, const char*, int, const xs__list *, const char*);
SOAP_FMAC3 xs__list * SOAP_FMAC4 soap_in_xs__list(struct soap*, const char*, xs__list *, const char*);
SOAP_FMAC1 xs__list * SOAP_FMAC2 wsdl_instantiate_xs__list(struct soap*, int, const char*, const char*, size_t*);

inline xs__list * soap_new_xs__list(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_xs__list(soap, n, NULL, NULL, NULL);
}

inline xs__list * soap_new_req_xs__list(
	struct soap *soap)
{
	xs__list *_p = ::soap_new_xs__list(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline xs__list * soap_new_set_xs__list(
	struct soap *soap,
	char *itemType,
	xs__restriction *restriction,
	const std::vector<xs__simpleType> & simpleType)
{
	xs__list *_p = ::soap_new_xs__list(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->xs__list::itemType = itemType;
		_p->xs__list::restriction = restriction;
		_p->xs__list::simpleType = simpleType;
	}
	return _p;
}

inline int soap_write_xs__list(struct soap *soap, xs__list const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:list", p->soap_type() == SOAP_TYPE_xs__list ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_xs__list(struct soap *soap, const char *URL, xs__list const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:list", p->soap_type() == SOAP_TYPE_xs__list ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_xs__list(struct soap *soap, const char *URL, xs__list const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:list", p->soap_type() == SOAP_TYPE_xs__list ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_xs__list(struct soap *soap, const char *URL, xs__list const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:list", p->soap_type() == SOAP_TYPE_xs__list ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 xs__list * SOAP_FMAC4 soap_get_xs__list(struct soap*, xs__list *, const char*, const char*);

inline int soap_read_xs__list(struct soap *soap, xs__list *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_xs__list(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_xs__list(struct soap *soap, const char *URL, xs__list *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_xs__list(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_xs__list(struct soap *soap, xs__list *p)
{
	if (::soap_read_xs__list(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_xs__group_DEFINED
#define SOAP_TYPE_xs__group_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xs__group(struct soap*, const char*, int, const xs__group *, const char*);
SOAP_FMAC3 xs__group * SOAP_FMAC4 soap_in_xs__group(struct soap*, const char*, xs__group *, const char*);
SOAP_FMAC1 xs__group * SOAP_FMAC2 wsdl_instantiate_xs__group(struct soap*, int, const char*, const char*, size_t*);

inline xs__group * soap_new_xs__group(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_xs__group(soap, n, NULL, NULL, NULL);
}

inline xs__group * soap_new_req_xs__group(
	struct soap *soap)
{
	xs__group *_p = ::soap_new_xs__group(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline xs__group * soap_new_set_xs__group(
	struct soap *soap,
	char *name,
	char *ref,
	char *minOccurs,
	char *maxOccurs,
	xs__annotation *annotation,
	xs__all *all,
	xs__seqchoice *choice,
	xs__seqchoice *sequence)
{
	xs__group *_p = ::soap_new_xs__group(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->xs__group::name = name;
		_p->xs__group::ref = ref;
		_p->xs__group::minOccurs = minOccurs;
		_p->xs__group::maxOccurs = maxOccurs;
		_p->xs__group::annotation = annotation;
		_p->xs__group::all = all;
		_p->xs__group::choice = choice;
		_p->xs__group::sequence = sequence;
	}
	return _p;
}

inline int soap_write_xs__group(struct soap *soap, xs__group const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:group", p->soap_type() == SOAP_TYPE_xs__group ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_xs__group(struct soap *soap, const char *URL, xs__group const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:group", p->soap_type() == SOAP_TYPE_xs__group ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_xs__group(struct soap *soap, const char *URL, xs__group const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:group", p->soap_type() == SOAP_TYPE_xs__group ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_xs__group(struct soap *soap, const char *URL, xs__group const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:group", p->soap_type() == SOAP_TYPE_xs__group ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 xs__group * SOAP_FMAC4 soap_get_xs__group(struct soap*, xs__group *, const char*, const char*);

inline int soap_read_xs__group(struct soap *soap, xs__group *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_xs__group(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_xs__group(struct soap *soap, const char *URL, xs__group *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_xs__group(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_xs__group(struct soap *soap, xs__group *p)
{
	if (::soap_read_xs__group(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_xs__seqchoice_DEFINED
#define SOAP_TYPE_xs__seqchoice_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xs__seqchoice(struct soap*, const char*, int, const xs__seqchoice *, const char*);
SOAP_FMAC3 xs__seqchoice * SOAP_FMAC4 soap_in_xs__seqchoice(struct soap*, const char*, xs__seqchoice *, const char*);
SOAP_FMAC1 xs__seqchoice * SOAP_FMAC2 wsdl_instantiate_xs__seqchoice(struct soap*, int, const char*, const char*, size_t*);

inline xs__seqchoice * soap_new_xs__seqchoice(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_xs__seqchoice(soap, n, NULL, NULL, NULL);
}

inline xs__seqchoice * soap_new_req_xs__seqchoice(
	struct soap *soap)
{
	xs__seqchoice *_p = ::soap_new_xs__seqchoice(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline xs__seqchoice * soap_new_set_xs__seqchoice(
	struct soap *soap,
	char *minOccurs,
	char *maxOccurs,
	xs__annotation *annotation,
	const std::vector<xs__contents> & __contents)
{
	xs__seqchoice *_p = ::soap_new_xs__seqchoice(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->xs__seqchoice::minOccurs = minOccurs;
		_p->xs__seqchoice::maxOccurs = maxOccurs;
		_p->xs__seqchoice::annotation = annotation;
		_p->xs__seqchoice::__contents = __contents;
	}
	return _p;
}

inline int soap_write_xs__seqchoice(struct soap *soap, xs__seqchoice const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:seqchoice", p->soap_type() == SOAP_TYPE_xs__seqchoice ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_xs__seqchoice(struct soap *soap, const char *URL, xs__seqchoice const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:seqchoice", p->soap_type() == SOAP_TYPE_xs__seqchoice ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_xs__seqchoice(struct soap *soap, const char *URL, xs__seqchoice const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:seqchoice", p->soap_type() == SOAP_TYPE_xs__seqchoice ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_xs__seqchoice(struct soap *soap, const char *URL, xs__seqchoice const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:seqchoice", p->soap_type() == SOAP_TYPE_xs__seqchoice ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 xs__seqchoice * SOAP_FMAC4 soap_get_xs__seqchoice(struct soap*, xs__seqchoice *, const char*, const char*);

inline int soap_read_xs__seqchoice(struct soap *soap, xs__seqchoice *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_xs__seqchoice(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_xs__seqchoice(struct soap *soap, const char *URL, xs__seqchoice *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_xs__seqchoice(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_xs__seqchoice(struct soap *soap, xs__seqchoice *p)
{
	if (::soap_read_xs__seqchoice(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_xs__restriction_DEFINED
#define SOAP_TYPE_xs__restriction_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xs__restriction(struct soap*, const char*, int, const xs__restriction *, const char*);
SOAP_FMAC3 xs__restriction * SOAP_FMAC4 soap_in_xs__restriction(struct soap*, const char*, xs__restriction *, const char*);
SOAP_FMAC1 xs__restriction * SOAP_FMAC2 wsdl_instantiate_xs__restriction(struct soap*, int, const char*, const char*, size_t*);

inline xs__restriction * soap_new_xs__restriction(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_xs__restriction(soap, n, NULL, NULL, NULL);
}

inline xs__restriction * soap_new_req_xs__restriction(
	struct soap *soap)
{
	xs__restriction *_p = ::soap_new_xs__restriction(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline xs__restriction * soap_new_set_xs__restriction(
	struct soap *soap,
	char *base,
	xs__simpleType *simpleType,
	xs__attributeGroup *attributeGroup,
	xs__group *group,
	xs__all *all,
	xs__seqchoice *choice,
	xs__seqchoice *sequence,
	const std::vector<xs__attribute> & attribute,
	xs__anyAttribute *anyAttribute,
	const std::vector<xs__enumeration> & enumeration,
	const std::vector<xs__pattern> & pattern,
	xs__whiteSpace *whiteSpace,
	xs__length *length,
	xs__length *minLength,
	xs__length *maxLength,
	xs__length *precision,
	xs__length *scale,
	xs__length *totalDigits,
	xs__length *fractionDigits,
	xs__length *minInclusive,
	xs__length *maxInclusive,
	xs__length *minExclusive,
	xs__length *maxExclusive,
	xs__annotation *annotation,
	const std::vector<xs__assert> & assert,
	xs__assert *assertion)
{
	xs__restriction *_p = ::soap_new_xs__restriction(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->xs__restriction::base = base;
		_p->xs__restriction::simpleType = simpleType;
		_p->xs__restriction::attributeGroup = attributeGroup;
		_p->xs__restriction::group = group;
		_p->xs__restriction::all = all;
		_p->xs__restriction::choice = choice;
		_p->xs__restriction::sequence = sequence;
		_p->xs__restriction::attribute = attribute;
		_p->xs__restriction::anyAttribute = anyAttribute;
		_p->xs__restriction::enumeration = enumeration;
		_p->xs__restriction::pattern = pattern;
		_p->xs__restriction::whiteSpace = whiteSpace;
		_p->xs__restriction::length = length;
		_p->xs__restriction::minLength = minLength;
		_p->xs__restriction::maxLength = maxLength;
		_p->xs__restriction::precision = precision;
		_p->xs__restriction::scale = scale;
		_p->xs__restriction::totalDigits = totalDigits;
		_p->xs__restriction::fractionDigits = fractionDigits;
		_p->xs__restriction::minInclusive = minInclusive;
		_p->xs__restriction::maxInclusive = maxInclusive;
		_p->xs__restriction::minExclusive = minExclusive;
		_p->xs__restriction::maxExclusive = maxExclusive;
		_p->xs__restriction::annotation = annotation;
		_p->xs__restriction::assert = assert;
		_p->xs__restriction::assertion = assertion;
	}
	return _p;
}

inline int soap_write_xs__restriction(struct soap *soap, xs__restriction const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:restriction", p->soap_type() == SOAP_TYPE_xs__restriction ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_xs__restriction(struct soap *soap, const char *URL, xs__restriction const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:restriction", p->soap_type() == SOAP_TYPE_xs__restriction ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_xs__restriction(struct soap *soap, const char *URL, xs__restriction const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:restriction", p->soap_type() == SOAP_TYPE_xs__restriction ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_xs__restriction(struct soap *soap, const char *URL, xs__restriction const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:restriction", p->soap_type() == SOAP_TYPE_xs__restriction ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 xs__restriction * SOAP_FMAC4 soap_get_xs__restriction(struct soap*, xs__restriction *, const char*, const char*);

inline int soap_read_xs__restriction(struct soap *soap, xs__restriction *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_xs__restriction(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_xs__restriction(struct soap *soap, const char *URL, xs__restriction *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_xs__restriction(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_xs__restriction(struct soap *soap, xs__restriction *p)
{
	if (::soap_read_xs__restriction(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_xs__extension_DEFINED
#define SOAP_TYPE_xs__extension_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xs__extension(struct soap*, const char*, int, const xs__extension *, const char*);
SOAP_FMAC3 xs__extension * SOAP_FMAC4 soap_in_xs__extension(struct soap*, const char*, xs__extension *, const char*);
SOAP_FMAC1 xs__extension * SOAP_FMAC2 wsdl_instantiate_xs__extension(struct soap*, int, const char*, const char*, size_t*);

inline xs__extension * soap_new_xs__extension(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_xs__extension(soap, n, NULL, NULL, NULL);
}

inline xs__extension * soap_new_req_xs__extension(
	struct soap *soap)
{
	xs__extension *_p = ::soap_new_xs__extension(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline xs__extension * soap_new_set_xs__extension(
	struct soap *soap,
	char *base,
	xs__group *group,
	xs__all *all,
	xs__seqchoice *choice,
	xs__seqchoice *sequence,
	const std::vector<xs__attribute> & attribute,
	const std::vector<xs__attributeGroup> & attributeGroup,
	xs__anyAttribute *anyAttribute,
	xs__annotation *annotation,
	const std::vector<xs__assert> & assert)
{
	xs__extension *_p = ::soap_new_xs__extension(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->xs__extension::base = base;
		_p->xs__extension::group = group;
		_p->xs__extension::all = all;
		_p->xs__extension::choice = choice;
		_p->xs__extension::sequence = sequence;
		_p->xs__extension::attribute = attribute;
		_p->xs__extension::attributeGroup = attributeGroup;
		_p->xs__extension::anyAttribute = anyAttribute;
		_p->xs__extension::annotation = annotation;
		_p->xs__extension::assert = assert;
	}
	return _p;
}

inline int soap_write_xs__extension(struct soap *soap, xs__extension const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:extension", p->soap_type() == SOAP_TYPE_xs__extension ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_xs__extension(struct soap *soap, const char *URL, xs__extension const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:extension", p->soap_type() == SOAP_TYPE_xs__extension ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_xs__extension(struct soap *soap, const char *URL, xs__extension const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:extension", p->soap_type() == SOAP_TYPE_xs__extension ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_xs__extension(struct soap *soap, const char *URL, xs__extension const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:extension", p->soap_type() == SOAP_TYPE_xs__extension ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 xs__extension * SOAP_FMAC4 soap_get_xs__extension(struct soap*, xs__extension *, const char*, const char*);

inline int soap_read_xs__extension(struct soap *soap, xs__extension *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_xs__extension(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_xs__extension(struct soap *soap, const char *URL, xs__extension *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_xs__extension(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_xs__extension(struct soap *soap, xs__extension *p)
{
	if (::soap_read_xs__extension(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_xs__complexType_DEFINED
#define SOAP_TYPE_xs__complexType_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xs__complexType(struct soap*, const char*, int, const xs__complexType *, const char*);
SOAP_FMAC3 xs__complexType * SOAP_FMAC4 soap_in_xs__complexType(struct soap*, const char*, xs__complexType *, const char*);
SOAP_FMAC1 xs__complexType * SOAP_FMAC2 wsdl_instantiate_xs__complexType(struct soap*, int, const char*, const char*, size_t*);

inline xs__complexType * soap_new_xs__complexType(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_xs__complexType(soap, n, NULL, NULL, NULL);
}

inline xs__complexType * soap_new_req_xs__complexType(
	struct soap *soap)
{
	xs__complexType *_p = ::soap_new_xs__complexType(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline xs__complexType * soap_new_set_xs__complexType(
	struct soap *soap,
	char *name,
	bool abstract,
	bool mixed,
	bool defaultAttributesApply,
	char *vc__minVersion,
	char *vc__maxVersion,
	xs__annotation *annotation,
	xs__simpleContent *simpleContent,
	xs__complexContent *complexContent,
	xs__all *all,
	xs__seqchoice *choice,
	xs__seqchoice *sequence,
	xs__group *group,
	xs__any *any,
	const std::vector<xs__attribute> & attribute,
	const std::vector<xs__attributeGroup> & attributeGroup,
	xs__anyAttribute *anyAttribute,
	const std::vector<xs__assert> & assert)
{
	xs__complexType *_p = ::soap_new_xs__complexType(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->xs__complexType::name = name;
		_p->xs__complexType::abstract = abstract;
		_p->xs__complexType::mixed = mixed;
		_p->xs__complexType::defaultAttributesApply = defaultAttributesApply;
		_p->xs__complexType::vc__minVersion = vc__minVersion;
		_p->xs__complexType::vc__maxVersion = vc__maxVersion;
		_p->xs__complexType::annotation = annotation;
		_p->xs__complexType::simpleContent = simpleContent;
		_p->xs__complexType::complexContent = complexContent;
		_p->xs__complexType::all = all;
		_p->xs__complexType::choice = choice;
		_p->xs__complexType::sequence = sequence;
		_p->xs__complexType::group = group;
		_p->xs__complexType::any = any;
		_p->xs__complexType::attribute = attribute;
		_p->xs__complexType::attributeGroup = attributeGroup;
		_p->xs__complexType::anyAttribute = anyAttribute;
		_p->xs__complexType::assert = assert;
	}
	return _p;
}

inline int soap_write_xs__complexType(struct soap *soap, xs__complexType const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:complexType", p->soap_type() == SOAP_TYPE_xs__complexType ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_xs__complexType(struct soap *soap, const char *URL, xs__complexType const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:complexType", p->soap_type() == SOAP_TYPE_xs__complexType ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_xs__complexType(struct soap *soap, const char *URL, xs__complexType const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:complexType", p->soap_type() == SOAP_TYPE_xs__complexType ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_xs__complexType(struct soap *soap, const char *URL, xs__complexType const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:complexType", p->soap_type() == SOAP_TYPE_xs__complexType ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 xs__complexType * SOAP_FMAC4 soap_get_xs__complexType(struct soap*, xs__complexType *, const char*, const char*);

inline int soap_read_xs__complexType(struct soap *soap, xs__complexType *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_xs__complexType(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_xs__complexType(struct soap *soap, const char *URL, xs__complexType *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_xs__complexType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_xs__complexType(struct soap *soap, xs__complexType *p)
{
	if (::soap_read_xs__complexType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_xs__simpleType_DEFINED
#define SOAP_TYPE_xs__simpleType_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xs__simpleType(struct soap*, const char*, int, const xs__simpleType *, const char*);
SOAP_FMAC3 xs__simpleType * SOAP_FMAC4 soap_in_xs__simpleType(struct soap*, const char*, xs__simpleType *, const char*);
SOAP_FMAC1 xs__simpleType * SOAP_FMAC2 wsdl_instantiate_xs__simpleType(struct soap*, int, const char*, const char*, size_t*);

inline xs__simpleType * soap_new_xs__simpleType(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_xs__simpleType(soap, n, NULL, NULL, NULL);
}

inline xs__simpleType * soap_new_req_xs__simpleType(
	struct soap *soap)
{
	xs__simpleType *_p = ::soap_new_xs__simpleType(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline xs__simpleType * soap_new_set_xs__simpleType(
	struct soap *soap,
	char *name,
	char *vc__minVersion,
	char *vc__maxVersion,
	xs__annotation *annotation,
	xs__restriction *restriction,
	xs__list *list,
	xs__union *union_)
{
	xs__simpleType *_p = ::soap_new_xs__simpleType(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->xs__simpleType::name = name;
		_p->xs__simpleType::vc__minVersion = vc__minVersion;
		_p->xs__simpleType::vc__maxVersion = vc__maxVersion;
		_p->xs__simpleType::annotation = annotation;
		_p->xs__simpleType::restriction = restriction;
		_p->xs__simpleType::list = list;
		_p->xs__simpleType::union_ = union_;
	}
	return _p;
}

inline int soap_write_xs__simpleType(struct soap *soap, xs__simpleType const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:simpleType", p->soap_type() == SOAP_TYPE_xs__simpleType ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_xs__simpleType(struct soap *soap, const char *URL, xs__simpleType const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:simpleType", p->soap_type() == SOAP_TYPE_xs__simpleType ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_xs__simpleType(struct soap *soap, const char *URL, xs__simpleType const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:simpleType", p->soap_type() == SOAP_TYPE_xs__simpleType ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_xs__simpleType(struct soap *soap, const char *URL, xs__simpleType const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:simpleType", p->soap_type() == SOAP_TYPE_xs__simpleType ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 xs__simpleType * SOAP_FMAC4 soap_get_xs__simpleType(struct soap*, xs__simpleType *, const char*, const char*);

inline int soap_read_xs__simpleType(struct soap *soap, xs__simpleType *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_xs__simpleType(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_xs__simpleType(struct soap *soap, const char *URL, xs__simpleType *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_xs__simpleType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_xs__simpleType(struct soap *soap, xs__simpleType *p)
{
	if (::soap_read_xs__simpleType(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_xs__schema_DEFINED
#define SOAP_TYPE_xs__schema_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xs__schema(struct soap*, const char*, int, const xs__schema *, const char*);
SOAP_FMAC3 xs__schema * SOAP_FMAC4 soap_in_xs__schema(struct soap*, const char*, xs__schema *, const char*);
SOAP_FMAC1 xs__schema * SOAP_FMAC2 wsdl_instantiate_xs__schema(struct soap*, int, const char*, const char*, size_t*);

inline xs__schema * soap_new_xs__schema(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_xs__schema(soap, n, NULL, NULL, NULL);
}

inline xs__schema * soap_new_req_xs__schema(
	struct soap *soap)
{
	xs__schema *_p = ::soap_new_xs__schema(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline xs__schema * soap_new_set_xs__schema(
	struct soap *soap,
	char *targetNamespace,
	char *version,
	char *defaultAttributes,
	enum xs__formChoice attributeFormDefault,
	enum xs__formChoice elementFormDefault,
	xs__annotation *annotation,
	const std::vector<xs__include> & include,
	const std::vector<xs__override> & override_,
	const std::vector<xs__redefine> & redefine,
	const std::vector<xs__import> & import,
	const std::vector<xs__attribute> & attribute,
	const std::vector<xs__element> & element,
	const std::vector<xs__group> & group,
	const std::vector<xs__attributeGroup> & attributeGroup,
	const std::vector<xs__simpleType> & simpleType,
	const std::vector<xs__complexType> & complexType)
{
	xs__schema *_p = ::soap_new_xs__schema(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->xs__schema::targetNamespace = targetNamespace;
		_p->xs__schema::version = version;
		_p->xs__schema::defaultAttributes = defaultAttributes;
		_p->xs__schema::attributeFormDefault = attributeFormDefault;
		_p->xs__schema::elementFormDefault = elementFormDefault;
		_p->xs__schema::annotation = annotation;
		_p->xs__schema::include = include;
		_p->xs__schema::override_ = override_;
		_p->xs__schema::redefine = redefine;
		_p->xs__schema::import = import;
		_p->xs__schema::attribute = attribute;
		_p->xs__schema::element = element;
		_p->xs__schema::group = group;
		_p->xs__schema::attributeGroup = attributeGroup;
		_p->xs__schema::simpleType = simpleType;
		_p->xs__schema::complexType = complexType;
	}
	return _p;
}

inline int soap_write_xs__schema(struct soap *soap, xs__schema const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:schema", p->soap_type() == SOAP_TYPE_xs__schema ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_xs__schema(struct soap *soap, const char *URL, xs__schema const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:schema", p->soap_type() == SOAP_TYPE_xs__schema ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_xs__schema(struct soap *soap, const char *URL, xs__schema const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:schema", p->soap_type() == SOAP_TYPE_xs__schema ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_xs__schema(struct soap *soap, const char *URL, xs__schema const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "xs:schema", p->soap_type() == SOAP_TYPE_xs__schema ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 xs__schema * SOAP_FMAC4 soap_get_xs__schema(struct soap*, xs__schema *, const char*, const char*);

inline int soap_read_xs__schema(struct soap *soap, xs__schema *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_xs__schema(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_xs__schema(struct soap *soap, const char *URL, xs__schema *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_xs__schema(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_xs__schema(struct soap *soap, xs__schema *p)
{
	if (::soap_read_xs__schema(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_wsdl__definitions_DEFINED
#define SOAP_TYPE_wsdl__definitions_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdl__definitions(struct soap*, const char*, int, const wsdl__definitions *, const char*);
SOAP_FMAC3 wsdl__definitions * SOAP_FMAC4 soap_in_wsdl__definitions(struct soap*, const char*, wsdl__definitions *, const char*);
SOAP_FMAC1 wsdl__definitions * SOAP_FMAC2 wsdl_instantiate_wsdl__definitions(struct soap*, int, const char*, const char*, size_t*);

inline wsdl__definitions * soap_new_wsdl__definitions(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_wsdl__definitions(soap, n, NULL, NULL, NULL);
}

inline wsdl__definitions * soap_new_req_wsdl__definitions(
	struct soap *soap)
{
	wsdl__definitions *_p = ::soap_new_wsdl__definitions(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline wsdl__definitions * soap_new_set_wsdl__definitions(
	struct soap *soap,
	char *name,
	char *targetNamespace,
	char *version,
	const std::vector<wsdl__import> & import,
	char *documentation,
	wsdl__types *types,
	const std::vector<wsdl__message> & message,
	const std::vector<wsdl__portType> & portType,
	const std::vector<wsdl__portType> & interface_,
	const std::vector<wsdl__binding> & binding,
	const std::vector<wsdl__service> & service,
	char *wsp__UsingPolicy,
	const std::vector<wsp__Policy> & wsp__Policy_,
	const std::vector<plnk__tPartnerLinkType> & plnk__partnerLinkType,
	const std::vector<vprop__tProperty> & vprop__property,
	const std::vector<vprop__tPropertyAlias> & vprop__propertyAlias,
	const std::vector<gwsdl__portType> & gwsdl__portType_)
{
	wsdl__definitions *_p = ::soap_new_wsdl__definitions(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->wsdl__definitions::name = name;
		_p->wsdl__definitions::targetNamespace = targetNamespace;
		_p->wsdl__definitions::version = version;
		_p->wsdl__definitions::import = import;
		_p->wsdl__definitions::documentation = documentation;
		_p->wsdl__definitions::types = types;
		_p->wsdl__definitions::message = message;
		_p->wsdl__definitions::portType = portType;
		_p->wsdl__definitions::interface_ = interface_;
		_p->wsdl__definitions::binding = binding;
		_p->wsdl__definitions::service = service;
		_p->wsdl__definitions::wsp__UsingPolicy = wsp__UsingPolicy;
		_p->wsdl__definitions::wsp__Policy_ = wsp__Policy_;
		_p->wsdl__definitions::plnk__partnerLinkType = plnk__partnerLinkType;
		_p->wsdl__definitions::vprop__property = vprop__property;
		_p->wsdl__definitions::vprop__propertyAlias = vprop__propertyAlias;
		_p->wsdl__definitions::gwsdl__portType_ = gwsdl__portType_;
	}
	return _p;
}

inline int soap_write_wsdl__definitions(struct soap *soap, wsdl__definitions const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsdl:definitions", p->soap_type() == SOAP_TYPE_wsdl__definitions ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_wsdl__definitions(struct soap *soap, const char *URL, wsdl__definitions const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsdl:definitions", p->soap_type() == SOAP_TYPE_wsdl__definitions ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_wsdl__definitions(struct soap *soap, const char *URL, wsdl__definitions const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsdl:definitions", p->soap_type() == SOAP_TYPE_wsdl__definitions ? "" : NULL) || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_wsdl__definitions(struct soap *soap, const char *URL, wsdl__definitions const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (p->soap_serialize(soap), 0) || p->soap_put(soap, "wsdl:definitions", p->soap_type() == SOAP_TYPE_wsdl__definitions ? "" : NULL) || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 wsdl__definitions * SOAP_FMAC4 soap_get_wsdl__definitions(struct soap*, wsdl__definitions *, const char*, const char*);

inline int soap_read_wsdl__definitions(struct soap *soap, wsdl__definitions *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || ::soap_get_wsdl__definitions(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_wsdl__definitions(struct soap *soap, const char *URL, wsdl__definitions *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_wsdl__definitions(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_wsdl__definitions(struct soap *soap, wsdl__definitions *p)
{
	if (::soap_read_wsdl__definitions(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Fault_DEFINED
#define SOAP_TYPE_SOAP_ENV__Fault_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap*, struct SOAP_ENV__Fault *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap*, const struct SOAP_ENV__Fault *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap*, const char*, int, const struct SOAP_ENV__Fault *, const char*);
SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap*, const char*, struct SOAP_ENV__Fault *, const char*);
SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 wsdl_instantiate_SOAP_ENV__Fault(struct soap*, int, const char*, const char*, size_t*);

inline struct SOAP_ENV__Fault * soap_new_SOAP_ENV__Fault(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_SOAP_ENV__Fault(soap, n, NULL, NULL, NULL);
}

inline struct SOAP_ENV__Fault * soap_new_req_SOAP_ENV__Fault(
	struct soap *soap)
{
	struct SOAP_ENV__Fault *_p = ::soap_new_SOAP_ENV__Fault(soap);
	if (_p)
	{	::soap_default_SOAP_ENV__Fault(soap, _p);
	}
	return _p;
}

inline struct SOAP_ENV__Fault * soap_new_set_SOAP_ENV__Fault(
	struct soap *soap,
	char *faultcode,
	char *faultstring,
	char *faultactor,
	struct SOAP_ENV__Detail *detail,
	struct SOAP_ENV__Code *SOAP_ENV__Code,
	struct SOAP_ENV__Reason *SOAP_ENV__Reason,
	char *SOAP_ENV__Node,
	char *SOAP_ENV__Role,
	struct SOAP_ENV__Detail *SOAP_ENV__Detail)
{
	struct SOAP_ENV__Fault *_p = ::soap_new_SOAP_ENV__Fault(soap);
	if (_p)
	{	::soap_default_SOAP_ENV__Fault(soap, _p);
		_p->faultcode = faultcode;
		_p->faultstring = faultstring;
		_p->faultactor = faultactor;
		_p->detail = detail;
		_p->SOAP_ENV__Code = SOAP_ENV__Code;
		_p->SOAP_ENV__Reason = SOAP_ENV__Reason;
		_p->SOAP_ENV__Node = SOAP_ENV__Node;
		_p->SOAP_ENV__Role = SOAP_ENV__Role;
		_p->SOAP_ENV__Detail = SOAP_ENV__Detail;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap*, const struct SOAP_ENV__Fault *, const char*, const char*);

inline int soap_write_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (::soap_serialize_SOAP_ENV__Fault(soap, p), 0) || ::soap_put_SOAP_ENV__Fault(soap, p, "SOAP-ENV:Fault", "") || soap_end_send(soap))
			return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_SOAP_ENV__Fault(struct soap *soap, const char *URL, struct SOAP_ENV__Fault const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize_SOAP_ENV__Fault(soap, p), 0) || ::soap_put_SOAP_ENV__Fault(soap, p, "SOAP-ENV:Fault", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_SOAP_ENV__Fault(struct soap *soap, const char *URL, struct SOAP_ENV__Fault const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize_SOAP_ENV__Fault(soap, p), 0) || ::soap_put_SOAP_ENV__Fault(soap, p, "SOAP-ENV:Fault", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_SOAP_ENV__Fault(struct soap *soap, const char *URL, struct SOAP_ENV__Fault const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize_SOAP_ENV__Fault(soap, p), 0) || ::soap_put_SOAP_ENV__Fault(soap, p, "SOAP-ENV:Fault", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap*, struct SOAP_ENV__Fault *, const char*, const char*);

inline int soap_read_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p)
{
	if (p)
	{	::soap_default_SOAP_ENV__Fault(soap, p);
		if (soap_begin_recv(soap) || ::soap_get_SOAP_ENV__Fault(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_SOAP_ENV__Fault(struct soap *soap, const char *URL, struct SOAP_ENV__Fault *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_SOAP_ENV__Fault(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p)
{
	if (::soap_read_SOAP_ENV__Fault(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Reason_DEFINED
#define SOAP_TYPE_SOAP_ENV__Reason_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap*, struct SOAP_ENV__Reason *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap*, const struct SOAP_ENV__Reason *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap*, const char*, int, const struct SOAP_ENV__Reason *, const char*);
SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap*, const char*, struct SOAP_ENV__Reason *, const char*);
SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 wsdl_instantiate_SOAP_ENV__Reason(struct soap*, int, const char*, const char*, size_t*);

inline struct SOAP_ENV__Reason * soap_new_SOAP_ENV__Reason(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_SOAP_ENV__Reason(soap, n, NULL, NULL, NULL);
}

inline struct SOAP_ENV__Reason * soap_new_req_SOAP_ENV__Reason(
	struct soap *soap)
{
	struct SOAP_ENV__Reason *_p = ::soap_new_SOAP_ENV__Reason(soap);
	if (_p)
	{	::soap_default_SOAP_ENV__Reason(soap, _p);
	}
	return _p;
}

inline struct SOAP_ENV__Reason * soap_new_set_SOAP_ENV__Reason(
	struct soap *soap,
	char *SOAP_ENV__Text)
{
	struct SOAP_ENV__Reason *_p = ::soap_new_SOAP_ENV__Reason(soap);
	if (_p)
	{	::soap_default_SOAP_ENV__Reason(soap, _p);
		_p->SOAP_ENV__Text = SOAP_ENV__Text;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap*, const struct SOAP_ENV__Reason *, const char*, const char*);

inline int soap_write_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (::soap_serialize_SOAP_ENV__Reason(soap, p), 0) || ::soap_put_SOAP_ENV__Reason(soap, p, "SOAP-ENV:Reason", "") || soap_end_send(soap))
			return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_SOAP_ENV__Reason(struct soap *soap, const char *URL, struct SOAP_ENV__Reason const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize_SOAP_ENV__Reason(soap, p), 0) || ::soap_put_SOAP_ENV__Reason(soap, p, "SOAP-ENV:Reason", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_SOAP_ENV__Reason(struct soap *soap, const char *URL, struct SOAP_ENV__Reason const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize_SOAP_ENV__Reason(soap, p), 0) || ::soap_put_SOAP_ENV__Reason(soap, p, "SOAP-ENV:Reason", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_SOAP_ENV__Reason(struct soap *soap, const char *URL, struct SOAP_ENV__Reason const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize_SOAP_ENV__Reason(soap, p), 0) || ::soap_put_SOAP_ENV__Reason(soap, p, "SOAP-ENV:Reason", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap*, struct SOAP_ENV__Reason *, const char*, const char*);

inline int soap_read_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p)
{
	if (p)
	{	::soap_default_SOAP_ENV__Reason(soap, p);
		if (soap_begin_recv(soap) || ::soap_get_SOAP_ENV__Reason(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_SOAP_ENV__Reason(struct soap *soap, const char *URL, struct SOAP_ENV__Reason *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_SOAP_ENV__Reason(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p)
{
	if (::soap_read_SOAP_ENV__Reason(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Detail_DEFINED
#define SOAP_TYPE_SOAP_ENV__Detail_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap*, struct SOAP_ENV__Detail *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap*, const struct SOAP_ENV__Detail *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap*, const char*, int, const struct SOAP_ENV__Detail *, const char*);
SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap*, const char*, struct SOAP_ENV__Detail *, const char*);
SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 wsdl_instantiate_SOAP_ENV__Detail(struct soap*, int, const char*, const char*, size_t*);

inline struct SOAP_ENV__Detail * soap_new_SOAP_ENV__Detail(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_SOAP_ENV__Detail(soap, n, NULL, NULL, NULL);
}

inline struct SOAP_ENV__Detail * soap_new_req_SOAP_ENV__Detail(
	struct soap *soap,
	int __type,
	void *fault)
{
	struct SOAP_ENV__Detail *_p = ::soap_new_SOAP_ENV__Detail(soap);
	if (_p)
	{	::soap_default_SOAP_ENV__Detail(soap, _p);
		_p->__type = __type;
		_p->fault = fault;
	}
	return _p;
}

inline struct SOAP_ENV__Detail * soap_new_set_SOAP_ENV__Detail(
	struct soap *soap,
	char *__any,
	int __type,
	void *fault)
{
	struct SOAP_ENV__Detail *_p = ::soap_new_SOAP_ENV__Detail(soap);
	if (_p)
	{	::soap_default_SOAP_ENV__Detail(soap, _p);
		_p->__any = __any;
		_p->__type = __type;
		_p->fault = fault;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap*, const struct SOAP_ENV__Detail *, const char*, const char*);

inline int soap_write_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (::soap_serialize_SOAP_ENV__Detail(soap, p), 0) || ::soap_put_SOAP_ENV__Detail(soap, p, "SOAP-ENV:Detail", "") || soap_end_send(soap))
			return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_SOAP_ENV__Detail(struct soap *soap, const char *URL, struct SOAP_ENV__Detail const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize_SOAP_ENV__Detail(soap, p), 0) || ::soap_put_SOAP_ENV__Detail(soap, p, "SOAP-ENV:Detail", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_SOAP_ENV__Detail(struct soap *soap, const char *URL, struct SOAP_ENV__Detail const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize_SOAP_ENV__Detail(soap, p), 0) || ::soap_put_SOAP_ENV__Detail(soap, p, "SOAP-ENV:Detail", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_SOAP_ENV__Detail(struct soap *soap, const char *URL, struct SOAP_ENV__Detail const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize_SOAP_ENV__Detail(soap, p), 0) || ::soap_put_SOAP_ENV__Detail(soap, p, "SOAP-ENV:Detail", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap*, struct SOAP_ENV__Detail *, const char*, const char*);

inline int soap_read_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p)
{
	if (p)
	{	::soap_default_SOAP_ENV__Detail(soap, p);
		if (soap_begin_recv(soap) || ::soap_get_SOAP_ENV__Detail(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_SOAP_ENV__Detail(struct soap *soap, const char *URL, struct SOAP_ENV__Detail *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_SOAP_ENV__Detail(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p)
{
	if (::soap_read_SOAP_ENV__Detail(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Code_DEFINED
#define SOAP_TYPE_SOAP_ENV__Code_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap*, struct SOAP_ENV__Code *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap*, const struct SOAP_ENV__Code *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap*, const char*, int, const struct SOAP_ENV__Code *, const char*);
SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap*, const char*, struct SOAP_ENV__Code *, const char*);
SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 wsdl_instantiate_SOAP_ENV__Code(struct soap*, int, const char*, const char*, size_t*);

inline struct SOAP_ENV__Code * soap_new_SOAP_ENV__Code(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_SOAP_ENV__Code(soap, n, NULL, NULL, NULL);
}

inline struct SOAP_ENV__Code * soap_new_req_SOAP_ENV__Code(
	struct soap *soap)
{
	struct SOAP_ENV__Code *_p = ::soap_new_SOAP_ENV__Code(soap);
	if (_p)
	{	::soap_default_SOAP_ENV__Code(soap, _p);
	}
	return _p;
}

inline struct SOAP_ENV__Code * soap_new_set_SOAP_ENV__Code(
	struct soap *soap,
	char *SOAP_ENV__Value,
	struct SOAP_ENV__Code *SOAP_ENV__Subcode)
{
	struct SOAP_ENV__Code *_p = ::soap_new_SOAP_ENV__Code(soap);
	if (_p)
	{	::soap_default_SOAP_ENV__Code(soap, _p);
		_p->SOAP_ENV__Value = SOAP_ENV__Value;
		_p->SOAP_ENV__Subcode = SOAP_ENV__Subcode;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap*, const struct SOAP_ENV__Code *, const char*, const char*);

inline int soap_write_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (::soap_serialize_SOAP_ENV__Code(soap, p), 0) || ::soap_put_SOAP_ENV__Code(soap, p, "SOAP-ENV:Code", "") || soap_end_send(soap))
			return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_SOAP_ENV__Code(struct soap *soap, const char *URL, struct SOAP_ENV__Code const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize_SOAP_ENV__Code(soap, p), 0) || ::soap_put_SOAP_ENV__Code(soap, p, "SOAP-ENV:Code", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_SOAP_ENV__Code(struct soap *soap, const char *URL, struct SOAP_ENV__Code const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize_SOAP_ENV__Code(soap, p), 0) || ::soap_put_SOAP_ENV__Code(soap, p, "SOAP-ENV:Code", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_SOAP_ENV__Code(struct soap *soap, const char *URL, struct SOAP_ENV__Code const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize_SOAP_ENV__Code(soap, p), 0) || ::soap_put_SOAP_ENV__Code(soap, p, "SOAP-ENV:Code", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap*, struct SOAP_ENV__Code *, const char*, const char*);

inline int soap_read_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p)
{
	if (p)
	{	::soap_default_SOAP_ENV__Code(soap, p);
		if (soap_begin_recv(soap) || ::soap_get_SOAP_ENV__Code(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_SOAP_ENV__Code(struct soap *soap, const char *URL, struct SOAP_ENV__Code *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_SOAP_ENV__Code(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p)
{
	if (::soap_read_SOAP_ENV__Code(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Header_DEFINED
#define SOAP_TYPE_SOAP_ENV__Header_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap*, struct SOAP_ENV__Header *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap*, const struct SOAP_ENV__Header *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap*, const char*, int, const struct SOAP_ENV__Header *, const char*);
SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap*, const char*, struct SOAP_ENV__Header *, const char*);
SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 wsdl_instantiate_SOAP_ENV__Header(struct soap*, int, const char*, const char*, size_t*);

inline struct SOAP_ENV__Header * soap_new_SOAP_ENV__Header(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_SOAP_ENV__Header(soap, n, NULL, NULL, NULL);
}

inline struct SOAP_ENV__Header * soap_new_req_SOAP_ENV__Header(
	struct soap *soap)
{
	struct SOAP_ENV__Header *_p = ::soap_new_SOAP_ENV__Header(soap);
	if (_p)
	{	::soap_default_SOAP_ENV__Header(soap, _p);
	}
	return _p;
}

inline struct SOAP_ENV__Header * soap_new_set_SOAP_ENV__Header(
	struct soap *soap)
{
	struct SOAP_ENV__Header *_p = ::soap_new_SOAP_ENV__Header(soap);
	if (_p)
	{	::soap_default_SOAP_ENV__Header(soap, _p);
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap*, const struct SOAP_ENV__Header *, const char*, const char*);

inline int soap_write_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (::soap_serialize_SOAP_ENV__Header(soap, p), 0) || ::soap_put_SOAP_ENV__Header(soap, p, "SOAP-ENV:Header", "") || soap_end_send(soap))
			return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_SOAP_ENV__Header(struct soap *soap, const char *URL, struct SOAP_ENV__Header const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize_SOAP_ENV__Header(soap, p), 0) || ::soap_put_SOAP_ENV__Header(soap, p, "SOAP-ENV:Header", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_SOAP_ENV__Header(struct soap *soap, const char *URL, struct SOAP_ENV__Header const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize_SOAP_ENV__Header(soap, p), 0) || ::soap_put_SOAP_ENV__Header(soap, p, "SOAP-ENV:Header", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_SOAP_ENV__Header(struct soap *soap, const char *URL, struct SOAP_ENV__Header const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || (::soap_serialize_SOAP_ENV__Header(soap, p), 0) || ::soap_put_SOAP_ENV__Header(soap, p, "SOAP-ENV:Header", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap*, struct SOAP_ENV__Header *, const char*, const char*);

inline int soap_read_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p)
{
	if (p)
	{	::soap_default_SOAP_ENV__Header(soap, p);
		if (soap_begin_recv(soap) || ::soap_get_SOAP_ENV__Header(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_SOAP_ENV__Header(struct soap *soap, const char *URL, struct SOAP_ENV__Header *p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_SOAP_ENV__Header(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p)
{
	if (::soap_read_SOAP_ENV__Header(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#endif

#ifndef SOAP_TYPE_wsdl__union_ioput_DEFINED
#define SOAP_TYPE_wsdl__union_ioput_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsdl__union_ioput(struct soap*, int, const union wsdl__union_ioput *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdl__union_ioput(struct soap*, int, const union wsdl__union_ioput *);
SOAP_FMAC3 union wsdl__union_ioput * SOAP_FMAC4 soap_in_wsdl__union_ioput(struct soap*, int*, union wsdl__union_ioput *);
#endif

#ifndef SOAP_TYPE_xs__union_content_DEFINED
#define SOAP_TYPE_xs__union_content_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xs__union_content(struct soap*, int, const union xs__union_content *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xs__union_content(struct soap*, int, const union xs__union_content *);
SOAP_FMAC3 union xs__union_content * SOAP_FMAC4 soap_in_xs__union_content(struct soap*, int*, union xs__union_content *);
#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_PointerToSOAP_ENV__Reason_DEFINED
#define SOAP_TYPE_PointerToSOAP_ENV__Reason_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap*, struct SOAP_ENV__Reason *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap*, const char *, int, struct SOAP_ENV__Reason *const*, const char *);
SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap*, const char*, struct SOAP_ENV__Reason **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap*, struct SOAP_ENV__Reason *const*, const char*, const char*);
SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap*, struct SOAP_ENV__Reason **, const char*, const char*);
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_PointerToSOAP_ENV__Detail_DEFINED
#define SOAP_TYPE_PointerToSOAP_ENV__Detail_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap*, struct SOAP_ENV__Detail *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap*, const char *, int, struct SOAP_ENV__Detail *const*, const char *);
SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap*, const char*, struct SOAP_ENV__Detail **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap*, struct SOAP_ENV__Detail *const*, const char*, const char*);
SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap*, struct SOAP_ENV__Detail **, const char*, const char*);
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_PointerToSOAP_ENV__Code_DEFINED
#define SOAP_TYPE_PointerToSOAP_ENV__Code_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap*, struct SOAP_ENV__Code *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap*, const char *, int, struct SOAP_ENV__Code *const*, const char *);
SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap*, const char*, struct SOAP_ENV__Code **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap*, struct SOAP_ENV__Code *const*, const char*, const char*);
SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap*, struct SOAP_ENV__Code **, const char*, const char*);
#endif

#endif

#ifndef SOAP_TYPE_PointerTowadl__application_DEFINED
#define SOAP_TYPE_PointerTowadl__application_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowadl__application(struct soap*, wadl__application *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowadl__application(struct soap*, const char *, int, wadl__application *const*, const char *);
SOAP_FMAC3 wadl__application ** SOAP_FMAC4 soap_in_PointerTowadl__application(struct soap*, const char*, wadl__application **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowadl__application(struct soap*, wadl__application *const*, const char*, const char*);
SOAP_FMAC3 wadl__application ** SOAP_FMAC4 soap_get_PointerTowadl__application(struct soap*, wadl__application **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTowsdl__types_DEFINED
#define SOAP_TYPE_PointerTowsdl__types_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsdl__types(struct soap*, wsdl__types *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsdl__types(struct soap*, const char *, int, wsdl__types *const*, const char *);
SOAP_FMAC3 wsdl__types ** SOAP_FMAC4 soap_in_PointerTowsdl__types(struct soap*, const char*, wsdl__types **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsdl__types(struct soap*, wsdl__types *const*, const char*, const char*);
SOAP_FMAC3 wsdl__types ** SOAP_FMAC4 soap_get_PointerTowsdl__types(struct soap*, wsdl__types **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTowsdl__binding_DEFINED
#define SOAP_TYPE_PointerTowsdl__binding_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsdl__binding(struct soap*, wsdl__binding *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsdl__binding(struct soap*, const char *, int, wsdl__binding *const*, const char *);
SOAP_FMAC3 wsdl__binding ** SOAP_FMAC4 soap_in_PointerTowsdl__binding(struct soap*, const char*, wsdl__binding **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsdl__binding(struct soap*, wsdl__binding *const*, const char*, const char*);
SOAP_FMAC3 wsdl__binding ** SOAP_FMAC4 soap_get_PointerTowsdl__binding(struct soap*, wsdl__binding **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTohttp__address_DEFINED
#define SOAP_TYPE_PointerTohttp__address_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTohttp__address(struct soap*, http__address *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTohttp__address(struct soap*, const char *, int, http__address *const*, const char *);
SOAP_FMAC3 http__address ** SOAP_FMAC4 soap_in_PointerTohttp__address(struct soap*, const char*, http__address **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTohttp__address(struct soap*, http__address *const*, const char*, const char*);
SOAP_FMAC3 http__address ** SOAP_FMAC4 soap_get_PointerTohttp__address(struct soap*, http__address **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTosoap__address_DEFINED
#define SOAP_TYPE_PointerTosoap__address_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosoap__address(struct soap*, soap__address *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosoap__address(struct soap*, const char *, int, soap__address *const*, const char *);
SOAP_FMAC3 soap__address ** SOAP_FMAC4 soap_in_PointerTosoap__address(struct soap*, const char*, soap__address **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosoap__address(struct soap*, soap__address *const*, const char*, const char*);
SOAP_FMAC3 soap__address ** SOAP_FMAC4 soap_get_PointerTosoap__address(struct soap*, soap__address **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerToxsd__string_DEFINED
#define SOAP_TYPE_PointerToxsd__string_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__string(struct soap*, char **const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__string(struct soap*, const char *, int, char **const*, const char *);
SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerToxsd__string(struct soap*, const char*, char ***, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__string(struct soap*, char **const*, const char*, const char*);
SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerToxsd__string(struct soap*, char ***, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTohttp__binding_DEFINED
#define SOAP_TYPE_PointerTohttp__binding_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTohttp__binding(struct soap*, http__binding *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTohttp__binding(struct soap*, const char *, int, http__binding *const*, const char *);
SOAP_FMAC3 http__binding ** SOAP_FMAC4 soap_in_PointerTohttp__binding(struct soap*, const char*, http__binding **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTohttp__binding(struct soap*, http__binding *const*, const char*, const char*);
SOAP_FMAC3 http__binding ** SOAP_FMAC4 soap_get_PointerTohttp__binding(struct soap*, http__binding **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTosoap__binding_DEFINED
#define SOAP_TYPE_PointerTosoap__binding_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosoap__binding(struct soap*, soap__binding *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosoap__binding(struct soap*, const char *, int, soap__binding *const*, const char *);
SOAP_FMAC3 soap__binding ** SOAP_FMAC4 soap_in_PointerTosoap__binding(struct soap*, const char*, soap__binding **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosoap__binding(struct soap*, soap__binding *const*, const char*, const char*);
SOAP_FMAC3 soap__binding ** SOAP_FMAC4 soap_get_PointerTosoap__binding(struct soap*, soap__binding **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTowsdl__ext_ioput_DEFINED
#define SOAP_TYPE_PointerTowsdl__ext_ioput_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsdl__ext_ioput(struct soap*, wsdl__ext_ioput *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsdl__ext_ioput(struct soap*, const char *, int, wsdl__ext_ioput *const*, const char *);
SOAP_FMAC3 wsdl__ext_ioput ** SOAP_FMAC4 soap_in_PointerTowsdl__ext_ioput(struct soap*, const char*, wsdl__ext_ioput **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsdl__ext_ioput(struct soap*, wsdl__ext_ioput *const*, const char*, const char*);
SOAP_FMAC3 wsdl__ext_ioput ** SOAP_FMAC4 soap_get_PointerTowsdl__ext_ioput(struct soap*, wsdl__ext_ioput **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTohttp__operation_DEFINED
#define SOAP_TYPE_PointerTohttp__operation_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTohttp__operation(struct soap*, http__operation *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTohttp__operation(struct soap*, const char *, int, http__operation *const*, const char *);
SOAP_FMAC3 http__operation ** SOAP_FMAC4 soap_in_PointerTohttp__operation(struct soap*, const char*, http__operation **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTohttp__operation(struct soap*, http__operation *const*, const char*, const char*);
SOAP_FMAC3 http__operation ** SOAP_FMAC4 soap_get_PointerTohttp__operation(struct soap*, http__operation **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTosoap__operation_DEFINED
#define SOAP_TYPE_PointerTosoap__operation_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosoap__operation(struct soap*, soap__operation *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosoap__operation(struct soap*, const char *, int, soap__operation *const*, const char *);
SOAP_FMAC3 soap__operation ** SOAP_FMAC4 soap_in_PointerTosoap__operation(struct soap*, const char*, soap__operation **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosoap__operation(struct soap*, soap__operation *const*, const char*, const char*);
SOAP_FMAC3 soap__operation ** SOAP_FMAC4 soap_get_PointerTosoap__operation(struct soap*, soap__operation **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTowsdl__fault_DEFINED
#define SOAP_TYPE_PointerTowsdl__fault_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsdl__fault(struct soap*, wsdl__fault *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsdl__fault(struct soap*, const char *, int, wsdl__fault *const*, const char *);
SOAP_FMAC3 wsdl__fault ** SOAP_FMAC4 soap_in_PointerTowsdl__fault(struct soap*, const char*, wsdl__fault **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsdl__fault(struct soap*, wsdl__fault *const*, const char*, const char*);
SOAP_FMAC3 wsdl__fault ** SOAP_FMAC4 soap_get_PointerTowsdl__fault(struct soap*, wsdl__fault **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTosoap__fault_DEFINED
#define SOAP_TYPE_PointerTosoap__fault_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosoap__fault(struct soap*, soap__fault *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosoap__fault(struct soap*, const char *, int, soap__fault *const*, const char *);
SOAP_FMAC3 soap__fault ** SOAP_FMAC4 soap_in_PointerTosoap__fault(struct soap*, const char*, soap__fault **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosoap__fault(struct soap*, soap__fault *const*, const char*, const char*);
SOAP_FMAC3 soap__fault ** SOAP_FMAC4 soap_get_PointerTosoap__fault(struct soap*, soap__fault **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTomime__mimeXml_DEFINED
#define SOAP_TYPE_PointerTomime__mimeXml_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTomime__mimeXml(struct soap*, mime__mimeXml *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTomime__mimeXml(struct soap*, const char *, int, mime__mimeXml *const*, const char *);
SOAP_FMAC3 mime__mimeXml ** SOAP_FMAC4 soap_in_PointerTomime__mimeXml(struct soap*, const char*, mime__mimeXml **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTomime__mimeXml(struct soap*, mime__mimeXml *const*, const char*, const char*);
SOAP_FMAC3 mime__mimeXml ** SOAP_FMAC4 soap_get_PointerTomime__mimeXml(struct soap*, mime__mimeXml **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTomime__content_DEFINED
#define SOAP_TYPE_PointerTomime__content_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTomime__content(struct soap*, mime__content *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTomime__content(struct soap*, const char *, int, mime__content *const*, const char *);
SOAP_FMAC3 mime__content ** SOAP_FMAC4 soap_in_PointerTomime__content(struct soap*, const char*, mime__content **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTomime__content(struct soap*, mime__content *const*, const char*, const char*);
SOAP_FMAC3 mime__content ** SOAP_FMAC4 soap_get_PointerTomime__content(struct soap*, mime__content **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTomime__multipartRelated_DEFINED
#define SOAP_TYPE_PointerTomime__multipartRelated_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTomime__multipartRelated(struct soap*, mime__multipartRelated *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTomime__multipartRelated(struct soap*, const char *, int, mime__multipartRelated *const*, const char *);
SOAP_FMAC3 mime__multipartRelated ** SOAP_FMAC4 soap_in_PointerTomime__multipartRelated(struct soap*, const char*, mime__multipartRelated **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTomime__multipartRelated(struct soap*, mime__multipartRelated *const*, const char*, const char*);
SOAP_FMAC3 mime__multipartRelated ** SOAP_FMAC4 soap_get_PointerTomime__multipartRelated(struct soap*, mime__multipartRelated **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTodime__message_DEFINED
#define SOAP_TYPE_PointerTodime__message_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodime__message(struct soap*, dime__message *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTodime__message(struct soap*, const char *, int, dime__message *const*, const char *);
SOAP_FMAC3 dime__message ** SOAP_FMAC4 soap_in_PointerTodime__message(struct soap*, const char*, dime__message **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodime__message(struct soap*, dime__message *const*, const char*, const char*);
SOAP_FMAC3 dime__message ** SOAP_FMAC4 soap_get_PointerTodime__message(struct soap*, dime__message **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTowsdl__ioput_DEFINED
#define SOAP_TYPE_PointerTowsdl__ioput_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsdl__ioput(struct soap*, wsdl__ioput *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsdl__ioput(struct soap*, const char *, int, wsdl__ioput *const*, const char *);
SOAP_FMAC3 wsdl__ioput ** SOAP_FMAC4 soap_in_PointerTowsdl__ioput(struct soap*, const char*, wsdl__ioput **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsdl__ioput(struct soap*, wsdl__ioput *const*, const char*, const char*);
SOAP_FMAC3 wsdl__ioput ** SOAP_FMAC4 soap_get_PointerTowsdl__ioput(struct soap*, wsdl__ioput **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTowsdl__definitions_DEFINED
#define SOAP_TYPE_PointerTowsdl__definitions_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsdl__definitions(struct soap*, wsdl__definitions *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsdl__definitions(struct soap*, const char *, int, wsdl__definitions *const*, const char *);
SOAP_FMAC3 wsdl__definitions ** SOAP_FMAC4 soap_in_PointerTowsdl__definitions(struct soap*, const char*, wsdl__definitions **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsdl__definitions(struct soap*, wsdl__definitions *const*, const char*, const char*);
SOAP_FMAC3 wsdl__definitions ** SOAP_FMAC4 soap_get_PointerTowsdl__definitions(struct soap*, wsdl__definitions **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTovprop__tProperty_DEFINED
#define SOAP_TYPE_PointerTovprop__tProperty_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovprop__tProperty(struct soap*, vprop__tProperty *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTovprop__tProperty(struct soap*, const char *, int, vprop__tProperty *const*, const char *);
SOAP_FMAC3 vprop__tProperty ** SOAP_FMAC4 soap_in_PointerTovprop__tProperty(struct soap*, const char*, vprop__tProperty **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovprop__tProperty(struct soap*, vprop__tProperty *const*, const char*, const char*);
SOAP_FMAC3 vprop__tProperty ** SOAP_FMAC4 soap_get_PointerTovprop__tProperty(struct soap*, vprop__tProperty **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTovprop__tQuery_DEFINED
#define SOAP_TYPE_PointerTovprop__tQuery_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovprop__tQuery(struct soap*, vprop__tQuery *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTovprop__tQuery(struct soap*, const char *, int, vprop__tQuery *const*, const char *);
SOAP_FMAC3 vprop__tQuery ** SOAP_FMAC4 soap_in_PointerTovprop__tQuery(struct soap*, const char*, vprop__tQuery **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovprop__tQuery(struct soap*, vprop__tQuery *const*, const char*, const char*);
SOAP_FMAC3 vprop__tQuery ** SOAP_FMAC4 soap_get_PointerTovprop__tQuery(struct soap*, vprop__tQuery **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerToplnk__tPartnerLinkType_DEFINED
#define SOAP_TYPE_PointerToplnk__tPartnerLinkType_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToplnk__tPartnerLinkType(struct soap*, plnk__tPartnerLinkType *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToplnk__tPartnerLinkType(struct soap*, const char *, int, plnk__tPartnerLinkType *const*, const char *);
SOAP_FMAC3 plnk__tPartnerLinkType ** SOAP_FMAC4 soap_in_PointerToplnk__tPartnerLinkType(struct soap*, const char*, plnk__tPartnerLinkType **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToplnk__tPartnerLinkType(struct soap*, plnk__tPartnerLinkType *const*, const char*, const char*);
SOAP_FMAC3 plnk__tPartnerLinkType ** SOAP_FMAC4 soap_get_PointerToplnk__tPartnerLinkType(struct soap*, plnk__tPartnerLinkType **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTowsdl__portType_DEFINED
#define SOAP_TYPE_PointerTowsdl__portType_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsdl__portType(struct soap*, wsdl__portType *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsdl__portType(struct soap*, const char *, int, wsdl__portType *const*, const char *);
SOAP_FMAC3 wsdl__portType ** SOAP_FMAC4 soap_in_PointerTowsdl__portType(struct soap*, const char*, wsdl__portType **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsdl__portType(struct soap*, wsdl__portType *const*, const char*, const char*);
SOAP_FMAC3 wsdl__portType ** SOAP_FMAC4 soap_get_PointerTowsdl__portType(struct soap*, wsdl__portType **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTowsp__AppliesTo_DEFINED
#define SOAP_TYPE_PointerTowsp__AppliesTo_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsp__AppliesTo(struct soap*, wsp__AppliesTo *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsp__AppliesTo(struct soap*, const char *, int, wsp__AppliesTo *const*, const char *);
SOAP_FMAC3 wsp__AppliesTo ** SOAP_FMAC4 soap_in_PointerTowsp__AppliesTo(struct soap*, const char*, wsp__AppliesTo **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsp__AppliesTo(struct soap*, wsp__AppliesTo *const*, const char*, const char*);
SOAP_FMAC3 wsp__AppliesTo ** SOAP_FMAC4 soap_get_PointerTowsp__AppliesTo(struct soap*, wsp__AppliesTo **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTowsrmp5__RMAssertion_DEFINED
#define SOAP_TYPE_PointerTowsrmp5__RMAssertion_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsrmp5__RMAssertion(struct soap*, wsrmp5__RMAssertion *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsrmp5__RMAssertion(struct soap*, const char *, int, wsrmp5__RMAssertion *const*, const char *);
SOAP_FMAC3 wsrmp5__RMAssertion ** SOAP_FMAC4 soap_in_PointerTowsrmp5__RMAssertion(struct soap*, const char*, wsrmp5__RMAssertion **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsrmp5__RMAssertion(struct soap*, wsrmp5__RMAssertion *const*, const char*, const char*);
SOAP_FMAC3 wsrmp5__RMAssertion ** SOAP_FMAC4 soap_get_PointerTowsrmp5__RMAssertion(struct soap*, wsrmp5__RMAssertion **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTowsrmp__RMAssertion_DEFINED
#define SOAP_TYPE_PointerTowsrmp__RMAssertion_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsrmp__RMAssertion(struct soap*, wsrmp__RMAssertion *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsrmp__RMAssertion(struct soap*, const char *, int, wsrmp__RMAssertion *const*, const char *);
SOAP_FMAC3 wsrmp__RMAssertion ** SOAP_FMAC4 soap_in_PointerTowsrmp__RMAssertion(struct soap*, const char*, wsrmp__RMAssertion **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsrmp__RMAssertion(struct soap*, wsrmp__RMAssertion *const*, const char*, const char*);
SOAP_FMAC3 wsrmp__RMAssertion ** SOAP_FMAC4 soap_get_PointerTowsrmp__RMAssertion(struct soap*, wsrmp__RMAssertion **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTowsp__Assertion_DEFINED
#define SOAP_TYPE_PointerTowsp__Assertion_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsp__Assertion(struct soap*, wsp__Assertion *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsp__Assertion(struct soap*, const char *, int, wsp__Assertion *const*, const char *);
SOAP_FMAC3 wsp__Assertion ** SOAP_FMAC4 soap_in_PointerTowsp__Assertion(struct soap*, const char*, wsp__Assertion **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsp__Assertion(struct soap*, wsp__Assertion *const*, const char*, const char*);
SOAP_FMAC3 wsp__Assertion ** SOAP_FMAC4 soap_get_PointerTowsp__Assertion(struct soap*, wsp__Assertion **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTosp__Token_DEFINED
#define SOAP_TYPE_PointerTosp__Token_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosp__Token(struct soap*, sp__Token *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosp__Token(struct soap*, const char *, int, sp__Token *const*, const char *);
SOAP_FMAC3 sp__Token ** SOAP_FMAC4 soap_in_PointerTosp__Token(struct soap*, const char*, sp__Token **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosp__Token(struct soap*, sp__Token *const*, const char*, const char*);
SOAP_FMAC3 sp__Token ** SOAP_FMAC4 soap_get_PointerTosp__Token(struct soap*, sp__Token **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTosp__Elements_DEFINED
#define SOAP_TYPE_PointerTosp__Elements_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosp__Elements(struct soap*, sp__Elements *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosp__Elements(struct soap*, const char *, int, sp__Elements *const*, const char *);
SOAP_FMAC3 sp__Elements ** SOAP_FMAC4 soap_in_PointerTosp__Elements(struct soap*, const char*, sp__Elements **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosp__Elements(struct soap*, sp__Elements *const*, const char*, const char*);
SOAP_FMAC3 sp__Elements ** SOAP_FMAC4 soap_get_PointerTosp__Elements(struct soap*, sp__Elements **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTowsp__PolicyReference_DEFINED
#define SOAP_TYPE_PointerTowsp__PolicyReference_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsp__PolicyReference(struct soap*, wsp__PolicyReference *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsp__PolicyReference(struct soap*, const char *, int, wsp__PolicyReference *const*, const char *);
SOAP_FMAC3 wsp__PolicyReference ** SOAP_FMAC4 soap_in_PointerTowsp__PolicyReference(struct soap*, const char*, wsp__PolicyReference **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsp__PolicyReference(struct soap*, wsp__PolicyReference *const*, const char*, const char*);
SOAP_FMAC3 wsp__PolicyReference ** SOAP_FMAC4 soap_get_PointerTowsp__PolicyReference(struct soap*, wsp__PolicyReference **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTowsrmp5__Timeout_DEFINED
#define SOAP_TYPE_PointerTowsrmp5__Timeout_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsrmp5__Timeout(struct soap*, wsrmp5__Timeout *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsrmp5__Timeout(struct soap*, const char *, int, wsrmp5__Timeout *const*, const char *);
SOAP_FMAC3 wsrmp5__Timeout ** SOAP_FMAC4 soap_in_PointerTowsrmp5__Timeout(struct soap*, const char*, wsrmp5__Timeout **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsrmp5__Timeout(struct soap*, wsrmp5__Timeout *const*, const char*, const char*);
SOAP_FMAC3 wsrmp5__Timeout ** SOAP_FMAC4 soap_get_PointerTowsrmp5__Timeout(struct soap*, wsrmp5__Timeout **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTowsrmp__Timeout_DEFINED
#define SOAP_TYPE_PointerTowsrmp__Timeout_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsrmp__Timeout(struct soap*, wsrmp__Timeout *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsrmp__Timeout(struct soap*, const char *, int, wsrmp__Timeout *const*, const char *);
SOAP_FMAC3 wsrmp__Timeout ** SOAP_FMAC4 soap_in_PointerTowsrmp__Timeout(struct soap*, const char*, wsrmp__Timeout **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsrmp__Timeout(struct soap*, wsrmp__Timeout *const*, const char*, const char*);
SOAP_FMAC3 wsrmp__Timeout ** SOAP_FMAC4 soap_get_PointerTowsrmp__Timeout(struct soap*, wsrmp__Timeout **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTowst__Claims_DEFINED
#define SOAP_TYPE_PointerTowst__Claims_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowst__Claims(struct soap*, wst__Claims *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowst__Claims(struct soap*, const char *, int, wst__Claims *const*, const char *);
SOAP_FMAC3 wst__Claims ** SOAP_FMAC4 soap_in_PointerTowst__Claims(struct soap*, const char*, wst__Claims **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowst__Claims(struct soap*, wst__Claims *const*, const char*, const char*);
SOAP_FMAC3 wst__Claims ** SOAP_FMAC4 soap_get_PointerTowst__Claims(struct soap*, wst__Claims **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTowsa__EndpointReferenceType_DEFINED
#define SOAP_TYPE_PointerTowsa__EndpointReferenceType_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsa__EndpointReferenceType(struct soap*, wsa__EndpointReferenceType *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsa__EndpointReferenceType(struct soap*, const char *, int, wsa__EndpointReferenceType *const*, const char *);
SOAP_FMAC3 wsa__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTowsa__EndpointReferenceType(struct soap*, const char*, wsa__EndpointReferenceType **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsa__EndpointReferenceType(struct soap*, wsa__EndpointReferenceType *const*, const char*, const char*);
SOAP_FMAC3 wsa__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTowsa__EndpointReferenceType(struct soap*, wsa__EndpointReferenceType **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTowsp__Content_DEFINED
#define SOAP_TYPE_PointerTowsp__Content_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsp__Content(struct soap*, wsp__Content *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsp__Content(struct soap*, const char *, int, wsp__Content *const*, const char *);
SOAP_FMAC3 wsp__Content ** SOAP_FMAC4 soap_in_PointerTowsp__Content(struct soap*, const char*, wsp__Content **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsp__Content(struct soap*, wsp__Content *const*, const char*, const char*);
SOAP_FMAC3 wsp__Content ** SOAP_FMAC4 soap_get_PointerTowsp__Content(struct soap*, wsp__Content **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTowsp__Policy_DEFINED
#define SOAP_TYPE_PointerTowsp__Policy_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsp__Policy(struct soap*, wsp__Policy *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsp__Policy(struct soap*, const char *, int, wsp__Policy *const*, const char *);
SOAP_FMAC3 wsp__Policy ** SOAP_FMAC4 soap_in_PointerTowsp__Policy(struct soap*, const char*, wsp__Policy **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsp__Policy(struct soap*, wsp__Policy *const*, const char*, const char*);
SOAP_FMAC3 wsp__Policy ** SOAP_FMAC4 soap_get_PointerTowsp__Policy(struct soap*, wsp__Policy **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTosd__staticServiceDataValues_DEFINED
#define SOAP_TYPE_PointerTosd__staticServiceDataValues_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosd__staticServiceDataValues(struct soap*, sd__staticServiceDataValues *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosd__staticServiceDataValues(struct soap*, const char *, int, sd__staticServiceDataValues *const*, const char *);
SOAP_FMAC3 sd__staticServiceDataValues ** SOAP_FMAC4 soap_in_PointerTosd__staticServiceDataValues(struct soap*, const char*, sd__staticServiceDataValues **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosd__staticServiceDataValues(struct soap*, sd__staticServiceDataValues *const*, const char*, const char*);
SOAP_FMAC3 sd__staticServiceDataValues ** SOAP_FMAC4 soap_get_PointerTosd__staticServiceDataValues(struct soap*, sd__staticServiceDataValues **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTowsdl__operation_DEFINED
#define SOAP_TYPE_PointerTowsdl__operation_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsdl__operation(struct soap*, wsdl__operation *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsdl__operation(struct soap*, const char *, int, wsdl__operation *const*, const char *);
SOAP_FMAC3 wsdl__operation ** SOAP_FMAC4 soap_in_PointerTowsdl__operation(struct soap*, const char*, wsdl__operation **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsdl__operation(struct soap*, wsdl__operation *const*, const char*, const char*);
SOAP_FMAC3 wsdl__operation ** SOAP_FMAC4 soap_get_PointerTowsdl__operation(struct soap*, wsdl__operation **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTosoap__body_DEFINED
#define SOAP_TYPE_PointerTosoap__body_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosoap__body(struct soap*, soap__body *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosoap__body(struct soap*, const char *, int, soap__body *const*, const char *);
SOAP_FMAC3 soap__body ** SOAP_FMAC4 soap_in_PointerTosoap__body(struct soap*, const char*, soap__body **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosoap__body(struct soap*, soap__body *const*, const char*, const char*);
SOAP_FMAC3 soap__body ** SOAP_FMAC4 soap_get_PointerTosoap__body(struct soap*, soap__body **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTowsdl__part_DEFINED
#define SOAP_TYPE_PointerTowsdl__part_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsdl__part(struct soap*, wsdl__part *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsdl__part(struct soap*, const char *, int, wsdl__part *const*, const char *);
SOAP_FMAC3 wsdl__part ** SOAP_FMAC4 soap_in_PointerTowsdl__part(struct soap*, const char*, wsdl__part **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsdl__part(struct soap*, wsdl__part *const*, const char*, const char*);
SOAP_FMAC3 wsdl__part ** SOAP_FMAC4 soap_get_PointerTowsdl__part(struct soap*, wsdl__part **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTowsdl__message_DEFINED
#define SOAP_TYPE_PointerTowsdl__message_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsdl__message(struct soap*, wsdl__message *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsdl__message(struct soap*, const char *, int, wsdl__message *const*, const char *);
SOAP_FMAC3 wsdl__message ** SOAP_FMAC4 soap_in_PointerTowsdl__message(struct soap*, const char*, wsdl__message **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsdl__message(struct soap*, wsdl__message *const*, const char*, const char*);
SOAP_FMAC3 wsdl__message ** SOAP_FMAC4 soap_get_PointerTowsdl__message(struct soap*, wsdl__message **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTosoap__styleChoice_DEFINED
#define SOAP_TYPE_PointerTosoap__styleChoice_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosoap__styleChoice(struct soap*, enum soap__styleChoice *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosoap__styleChoice(struct soap*, const char *, int, enum soap__styleChoice *const*, const char *);
SOAP_FMAC3 enum soap__styleChoice ** SOAP_FMAC4 soap_in_PointerTosoap__styleChoice(struct soap*, const char*, enum soap__styleChoice **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosoap__styleChoice(struct soap*, enum soap__styleChoice *const*, const char*, const char*);
SOAP_FMAC3 enum soap__styleChoice ** SOAP_FMAC4 soap_get_PointerTosoap__styleChoice(struct soap*, enum soap__styleChoice **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTowadl__grammars_DEFINED
#define SOAP_TYPE_PointerTowadl__grammars_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowadl__grammars(struct soap*, wadl__grammars *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowadl__grammars(struct soap*, const char *, int, wadl__grammars *const*, const char *);
SOAP_FMAC3 wadl__grammars ** SOAP_FMAC4 soap_in_PointerTowadl__grammars(struct soap*, const char*, wadl__grammars **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowadl__grammars(struct soap*, wadl__grammars *const*, const char*, const char*);
SOAP_FMAC3 wadl__grammars ** SOAP_FMAC4 soap_get_PointerTowadl__grammars(struct soap*, wadl__grammars **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTowadl__resource_DEFINED
#define SOAP_TYPE_PointerTowadl__resource_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowadl__resource(struct soap*, wadl__resource *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowadl__resource(struct soap*, const char *, int, wadl__resource *const*, const char *);
SOAP_FMAC3 wadl__resource ** SOAP_FMAC4 soap_in_PointerTowadl__resource(struct soap*, const char*, wadl__resource **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowadl__resource(struct soap*, wadl__resource *const*, const char*, const char*);
SOAP_FMAC3 wadl__resource ** SOAP_FMAC4 soap_get_PointerTowadl__resource(struct soap*, wadl__resource **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTowadl__method_DEFINED
#define SOAP_TYPE_PointerTowadl__method_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowadl__method(struct soap*, wadl__method *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowadl__method(struct soap*, const char *, int, wadl__method *const*, const char *);
SOAP_FMAC3 wadl__method ** SOAP_FMAC4 soap_in_PointerTowadl__method(struct soap*, const char*, wadl__method **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowadl__method(struct soap*, wadl__method *const*, const char*, const char*);
SOAP_FMAC3 wadl__method ** SOAP_FMAC4 soap_get_PointerTowadl__method(struct soap*, wadl__method **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTowadl__request_DEFINED
#define SOAP_TYPE_PointerTowadl__request_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowadl__request(struct soap*, wadl__request *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowadl__request(struct soap*, const char *, int, wadl__request *const*, const char *);
SOAP_FMAC3 wadl__request ** SOAP_FMAC4 soap_in_PointerTowadl__request(struct soap*, const char*, wadl__request **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowadl__request(struct soap*, wadl__request *const*, const char*, const char*);
SOAP_FMAC3 wadl__request ** SOAP_FMAC4 soap_get_PointerTowadl__request(struct soap*, wadl__request **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTowadl__representation_DEFINED
#define SOAP_TYPE_PointerTowadl__representation_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowadl__representation(struct soap*, wadl__representation *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowadl__representation(struct soap*, const char *, int, wadl__representation *const*, const char *);
SOAP_FMAC3 wadl__representation ** SOAP_FMAC4 soap_in_PointerTowadl__representation(struct soap*, const char*, wadl__representation **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowadl__representation(struct soap*, wadl__representation *const*, const char*, const char*);
SOAP_FMAC3 wadl__representation ** SOAP_FMAC4 soap_get_PointerTowadl__representation(struct soap*, wadl__representation **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTowadl__param_DEFINED
#define SOAP_TYPE_PointerTowadl__param_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowadl__param(struct soap*, wadl__param *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowadl__param(struct soap*, const char *, int, wadl__param *const*, const char *);
SOAP_FMAC3 wadl__param ** SOAP_FMAC4 soap_in_PointerTowadl__param(struct soap*, const char*, wadl__param **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowadl__param(struct soap*, wadl__param *const*, const char*, const char*);
SOAP_FMAC3 wadl__param ** SOAP_FMAC4 soap_get_PointerTowadl__param(struct soap*, wadl__param **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTowadl__link_DEFINED
#define SOAP_TYPE_PointerTowadl__link_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowadl__link(struct soap*, wadl__link *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowadl__link(struct soap*, const char *, int, wadl__link *const*, const char *);
SOAP_FMAC3 wadl__link ** SOAP_FMAC4 soap_in_PointerTowadl__link(struct soap*, const char*, wadl__link **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowadl__link(struct soap*, wadl__link *const*, const char*, const char*);
SOAP_FMAC3 wadl__link ** SOAP_FMAC4 soap_get_PointerTowadl__link(struct soap*, wadl__link **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTowadl__ParamStyle_DEFINED
#define SOAP_TYPE_PointerTowadl__ParamStyle_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowadl__ParamStyle(struct soap*, enum wadl__ParamStyle *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowadl__ParamStyle(struct soap*, const char *, int, enum wadl__ParamStyle *const*, const char *);
SOAP_FMAC3 enum wadl__ParamStyle ** SOAP_FMAC4 soap_in_PointerTowadl__ParamStyle(struct soap*, const char*, enum wadl__ParamStyle **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowadl__ParamStyle(struct soap*, enum wadl__ParamStyle *const*, const char*, const char*);
SOAP_FMAC3 enum wadl__ParamStyle ** SOAP_FMAC4 soap_get_PointerTowadl__ParamStyle(struct soap*, enum wadl__ParamStyle **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTowadl__resource_USCOREtype_DEFINED
#define SOAP_TYPE_PointerTowadl__resource_USCOREtype_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowadl__resource_USCOREtype(struct soap*, wadl__resource_USCOREtype *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowadl__resource_USCOREtype(struct soap*, const char *, int, wadl__resource_USCOREtype *const*, const char *);
SOAP_FMAC3 wadl__resource_USCOREtype ** SOAP_FMAC4 soap_in_PointerTowadl__resource_USCOREtype(struct soap*, const char*, wadl__resource_USCOREtype **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowadl__resource_USCOREtype(struct soap*, wadl__resource_USCOREtype *const*, const char*, const char*);
SOAP_FMAC3 wadl__resource_USCOREtype ** SOAP_FMAC4 soap_get_PointerTowadl__resource_USCOREtype(struct soap*, wadl__resource_USCOREtype **, const char*, const char*);
#endif
/* wadl__statusCodeList is a typedef synonym of xsd__string */

#ifndef SOAP_TYPE_wadl__statusCodeList_DEFINED
#define SOAP_TYPE_wadl__statusCodeList_DEFINED

#define soap_default_wadl__statusCodeList soap_default_xsd__string


#define soap_serialize_wadl__statusCodeList soap_serialize_xsd__string


#define soap_wadl__statusCodeList2s(soap, a) (a)

#define soap_out_wadl__statusCodeList soap_out_xsd__string


#define soap_s2wadl__statusCodeList(soap, s, a) soap_s2char((soap), (s), (char**)(a), 1, 0, -1, NULL)

#define soap_in_wadl__statusCodeList soap_in_xsd__string


#define wsdl_instantiate_wadl__statusCodeList wsdl_instantiate_xsd__string


#define soap_new_wadl__statusCodeList soap_new_xsd__string


#define soap_put_wadl__statusCodeList soap_put_xsd__string


#define soap_write_wadl__statusCodeList soap_write_xsd__string


#define soap_PUT_wadl__statusCodeList soap_PUT_xsd__string


#define soap_PATCH_wadl__statusCodeList soap_PATCH_xsd__string


#define soap_POST_send_wadl__statusCodeList soap_POST_send_xsd__string


#define soap_get_wadl__statusCodeList soap_get_xsd__string


#define soap_read_wadl__statusCodeList soap_read_xsd__string


#define soap_GET_wadl__statusCodeList soap_GET_xsd__string


#define soap_POST_recv_wadl__statusCodeList soap_POST_recv_xsd__string

#endif

#ifndef SOAP_TYPE_PointerToxs__complexContent_DEFINED
#define SOAP_TYPE_PointerToxs__complexContent_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxs__complexContent(struct soap*, xs__complexContent *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxs__complexContent(struct soap*, const char *, int, xs__complexContent *const*, const char *);
SOAP_FMAC3 xs__complexContent ** SOAP_FMAC4 soap_in_PointerToxs__complexContent(struct soap*, const char*, xs__complexContent **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxs__complexContent(struct soap*, xs__complexContent *const*, const char*, const char*);
SOAP_FMAC3 xs__complexContent ** SOAP_FMAC4 soap_get_PointerToxs__complexContent(struct soap*, xs__complexContent **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerToxs__simpleContent_DEFINED
#define SOAP_TYPE_PointerToxs__simpleContent_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxs__simpleContent(struct soap*, xs__simpleContent *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxs__simpleContent(struct soap*, const char *, int, xs__simpleContent *const*, const char *);
SOAP_FMAC3 xs__simpleContent ** SOAP_FMAC4 soap_in_PointerToxs__simpleContent(struct soap*, const char*, xs__simpleContent **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxs__simpleContent(struct soap*, xs__simpleContent *const*, const char*, const char*);
SOAP_FMAC3 xs__simpleContent ** SOAP_FMAC4 soap_get_PointerToxs__simpleContent(struct soap*, xs__simpleContent **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerToxs__assert_DEFINED
#define SOAP_TYPE_PointerToxs__assert_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxs__assert(struct soap*, xs__assert *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxs__assert(struct soap*, const char *, int, xs__assert *const*, const char *);
SOAP_FMAC3 xs__assert ** SOAP_FMAC4 soap_in_PointerToxs__assert(struct soap*, const char*, xs__assert **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxs__assert(struct soap*, xs__assert *const*, const char*, const char*);
SOAP_FMAC3 xs__assert ** SOAP_FMAC4 soap_get_PointerToxs__assert(struct soap*, xs__assert **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerToxs__length_DEFINED
#define SOAP_TYPE_PointerToxs__length_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxs__length(struct soap*, xs__length *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxs__length(struct soap*, const char *, int, xs__length *const*, const char *);
SOAP_FMAC3 xs__length ** SOAP_FMAC4 soap_in_PointerToxs__length(struct soap*, const char*, xs__length **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxs__length(struct soap*, xs__length *const*, const char*, const char*);
SOAP_FMAC3 xs__length ** SOAP_FMAC4 soap_get_PointerToxs__length(struct soap*, xs__length **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerToxs__whiteSpace_DEFINED
#define SOAP_TYPE_PointerToxs__whiteSpace_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxs__whiteSpace(struct soap*, xs__whiteSpace *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxs__whiteSpace(struct soap*, const char *, int, xs__whiteSpace *const*, const char *);
SOAP_FMAC3 xs__whiteSpace ** SOAP_FMAC4 soap_in_PointerToxs__whiteSpace(struct soap*, const char*, xs__whiteSpace **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxs__whiteSpace(struct soap*, xs__whiteSpace *const*, const char*, const char*);
SOAP_FMAC3 xs__whiteSpace ** SOAP_FMAC4 soap_get_PointerToxs__whiteSpace(struct soap*, xs__whiteSpace **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerToxs__union_DEFINED
#define SOAP_TYPE_PointerToxs__union_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxs__union(struct soap*, xs__union *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxs__union(struct soap*, const char *, int, xs__union *const*, const char *);
SOAP_FMAC3 xs__union ** SOAP_FMAC4 soap_in_PointerToxs__union(struct soap*, const char*, xs__union **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxs__union(struct soap*, xs__union *const*, const char*, const char*);
SOAP_FMAC3 xs__union ** SOAP_FMAC4 soap_get_PointerToxs__union(struct soap*, xs__union **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerToxs__list_DEFINED
#define SOAP_TYPE_PointerToxs__list_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxs__list(struct soap*, xs__list *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxs__list(struct soap*, const char *, int, xs__list *const*, const char *);
SOAP_FMAC3 xs__list ** SOAP_FMAC4 soap_in_PointerToxs__list(struct soap*, const char*, xs__list **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxs__list(struct soap*, xs__list *const*, const char*, const char*);
SOAP_FMAC3 xs__list ** SOAP_FMAC4 soap_get_PointerToxs__list(struct soap*, xs__list **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerToxs__restriction_DEFINED
#define SOAP_TYPE_PointerToxs__restriction_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxs__restriction(struct soap*, xs__restriction *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxs__restriction(struct soap*, const char *, int, xs__restriction *const*, const char *);
SOAP_FMAC3 xs__restriction ** SOAP_FMAC4 soap_in_PointerToxs__restriction(struct soap*, const char*, xs__restriction **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxs__restriction(struct soap*, xs__restriction *const*, const char*, const char*);
SOAP_FMAC3 xs__restriction ** SOAP_FMAC4 soap_get_PointerToxs__restriction(struct soap*, xs__restriction **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerToxs__extension_DEFINED
#define SOAP_TYPE_PointerToxs__extension_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxs__extension(struct soap*, xs__extension *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxs__extension(struct soap*, const char *, int, xs__extension *const*, const char *);
SOAP_FMAC3 xs__extension ** SOAP_FMAC4 soap_in_PointerToxs__extension(struct soap*, const char*, xs__extension **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxs__extension(struct soap*, xs__extension *const*, const char*, const char*);
SOAP_FMAC3 xs__extension ** SOAP_FMAC4 soap_get_PointerToxs__extension(struct soap*, xs__extension **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerToxs__attributeGroup_DEFINED
#define SOAP_TYPE_PointerToxs__attributeGroup_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxs__attributeGroup(struct soap*, xs__attributeGroup *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxs__attributeGroup(struct soap*, const char *, int, xs__attributeGroup *const*, const char *);
SOAP_FMAC3 xs__attributeGroup ** SOAP_FMAC4 soap_in_PointerToxs__attributeGroup(struct soap*, const char*, xs__attributeGroup **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxs__attributeGroup(struct soap*, xs__attributeGroup *const*, const char*, const char*);
SOAP_FMAC3 xs__attributeGroup ** SOAP_FMAC4 soap_get_PointerToxs__attributeGroup(struct soap*, xs__attributeGroup **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerToxs__anyAttribute_DEFINED
#define SOAP_TYPE_PointerToxs__anyAttribute_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxs__anyAttribute(struct soap*, xs__anyAttribute *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxs__anyAttribute(struct soap*, const char *, int, xs__anyAttribute *const*, const char *);
SOAP_FMAC3 xs__anyAttribute ** SOAP_FMAC4 soap_in_PointerToxs__anyAttribute(struct soap*, const char*, xs__anyAttribute **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxs__anyAttribute(struct soap*, xs__anyAttribute *const*, const char*, const char*);
SOAP_FMAC3 xs__anyAttribute ** SOAP_FMAC4 soap_get_PointerToxs__anyAttribute(struct soap*, xs__anyAttribute **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerToxs__all_DEFINED
#define SOAP_TYPE_PointerToxs__all_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxs__all(struct soap*, xs__all *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxs__all(struct soap*, const char *, int, xs__all *const*, const char *);
SOAP_FMAC3 xs__all ** SOAP_FMAC4 soap_in_PointerToxs__all(struct soap*, const char*, xs__all **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxs__all(struct soap*, xs__all *const*, const char*, const char*);
SOAP_FMAC3 xs__all ** SOAP_FMAC4 soap_get_PointerToxs__all(struct soap*, xs__all **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerToxs__any_DEFINED
#define SOAP_TYPE_PointerToxs__any_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxs__any(struct soap*, xs__any *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxs__any(struct soap*, const char *, int, xs__any *const*, const char *);
SOAP_FMAC3 xs__any ** SOAP_FMAC4 soap_in_PointerToxs__any(struct soap*, const char*, xs__any **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxs__any(struct soap*, xs__any *const*, const char*, const char*);
SOAP_FMAC3 xs__any ** SOAP_FMAC4 soap_get_PointerToxs__any(struct soap*, xs__any **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerToxs__seqchoice_DEFINED
#define SOAP_TYPE_PointerToxs__seqchoice_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxs__seqchoice(struct soap*, xs__seqchoice *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxs__seqchoice(struct soap*, const char *, int, xs__seqchoice *const*, const char *);
SOAP_FMAC3 xs__seqchoice ** SOAP_FMAC4 soap_in_PointerToxs__seqchoice(struct soap*, const char*, xs__seqchoice **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxs__seqchoice(struct soap*, xs__seqchoice *const*, const char*, const char*);
SOAP_FMAC3 xs__seqchoice ** SOAP_FMAC4 soap_get_PointerToxs__seqchoice(struct soap*, xs__seqchoice **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerToxs__group_DEFINED
#define SOAP_TYPE_PointerToxs__group_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxs__group(struct soap*, xs__group *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxs__group(struct soap*, const char *, int, xs__group *const*, const char *);
SOAP_FMAC3 xs__group ** SOAP_FMAC4 soap_in_PointerToxs__group(struct soap*, const char*, xs__group **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxs__group(struct soap*, xs__group *const*, const char*, const char*);
SOAP_FMAC3 xs__group ** SOAP_FMAC4 soap_get_PointerToxs__group(struct soap*, xs__group **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_xs__namespaceList_DEFINED
#define SOAP_TYPE_xs__namespaceList_DEFINED

inline void soap_default_xs__namespaceList(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_xs__namespaceList
	*a = SOAP_DEFAULT_xs__namespaceList;
#else
	*a = (char *)0;
#endif
}
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xs__namespaceList(struct soap*, char *const*);

#define soap_xs__namespaceList2s(soap, a) (a)
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xs__namespaceList(struct soap*, const char*, int, char*const*, const char*);

#define soap_s2xs__namespaceList(soap, s, a) soap_s2char((soap), (s), (char**)(a), 1, 0, -1, NULL)
SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xs__namespaceList(struct soap*, const char*, char **, const char*);

#define wsdl_instantiate_xs__namespaceList wsdl_instantiate_string


#define soap_new_xs__namespaceList soap_new_string

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xs__namespaceList(struct soap*, char *const*, const char*, const char*);

inline int soap_write_xs__namespaceList(struct soap *soap, char *const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || ::soap_put_xs__namespaceList(soap, p, "xs:namespaceList", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_xs__namespaceList(struct soap *soap, const char *URL, char *const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_xs__namespaceList(soap, p, "xs:namespaceList", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_xs__namespaceList(struct soap *soap, const char *URL, char *const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_xs__namespaceList(soap, p, "xs:namespaceList", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_xs__namespaceList(struct soap *soap, const char *URL, char *const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_xs__namespaceList(soap, p, "xs:namespaceList", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xs__namespaceList(struct soap*, char **, const char*, const char*);

inline int soap_read_xs__namespaceList(struct soap *soap, char **p)
{
	if (p)
	{	if (soap_begin_recv(soap) || ::soap_get_xs__namespaceList(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_xs__namespaceList(struct soap *soap, const char *URL, char **p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_xs__namespaceList(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_xs__namespaceList(struct soap *soap, char **p)
{
	if (::soap_read_xs__namespaceList(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_PointerToxs__attribute_DEFINED
#define SOAP_TYPE_PointerToxs__attribute_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxs__attribute(struct soap*, xs__attribute *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxs__attribute(struct soap*, const char *, int, xs__attribute *const*, const char *);
SOAP_FMAC3 xs__attribute ** SOAP_FMAC4 soap_in_PointerToxs__attribute(struct soap*, const char*, xs__attribute **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxs__attribute(struct soap*, xs__attribute *const*, const char*, const char*);
SOAP_FMAC3 xs__attribute ** SOAP_FMAC4 soap_get_PointerToxs__attribute(struct soap*, xs__attribute **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTostd__vectorTemplateOfPointerToxs__element_DEFINED
#define SOAP_TYPE_PointerTostd__vectorTemplateOfPointerToxs__element_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__vectorTemplateOfPointerToxs__element(struct soap*, std::vector<xs__element *> *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__vectorTemplateOfPointerToxs__element(struct soap*, const char *, int, std::vector<xs__element *> *const*, const char *);
SOAP_FMAC3 std::vector<xs__element *> ** SOAP_FMAC4 soap_in_PointerTostd__vectorTemplateOfPointerToxs__element(struct soap*, const char*, std::vector<xs__element *> **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__vectorTemplateOfPointerToxs__element(struct soap*, std::vector<xs__element *> *const*, const char*, const char*);
SOAP_FMAC3 std::vector<xs__element *> ** SOAP_FMAC4 soap_get_PointerTostd__vectorTemplateOfPointerToxs__element(struct soap*, std::vector<xs__element *> **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerToxs__element_DEFINED
#define SOAP_TYPE_PointerToxs__element_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxs__element(struct soap*, xs__element *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxs__element(struct soap*, const char *, int, xs__element *const*, const char *);
SOAP_FMAC3 xs__element ** SOAP_FMAC4 soap_in_PointerToxs__element(struct soap*, const char*, xs__element **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxs__element(struct soap*, xs__element *const*, const char*, const char*);
SOAP_FMAC3 xs__element ** SOAP_FMAC4 soap_get_PointerToxs__element(struct soap*, xs__element **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerToxs__schema_DEFINED
#define SOAP_TYPE_PointerToxs__schema_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxs__schema(struct soap*, xs__schema *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxs__schema(struct soap*, const char *, int, xs__schema *const*, const char *);
SOAP_FMAC3 xs__schema ** SOAP_FMAC4 soap_in_PointerToxs__schema(struct soap*, const char*, xs__schema **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxs__schema(struct soap*, xs__schema *const*, const char*, const char*);
SOAP_FMAC3 xs__schema ** SOAP_FMAC4 soap_get_PointerToxs__schema(struct soap*, xs__schema **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerToxs__complexType_DEFINED
#define SOAP_TYPE_PointerToxs__complexType_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxs__complexType(struct soap*, xs__complexType *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxs__complexType(struct soap*, const char *, int, xs__complexType *const*, const char *);
SOAP_FMAC3 xs__complexType ** SOAP_FMAC4 soap_in_PointerToxs__complexType(struct soap*, const char*, xs__complexType **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxs__complexType(struct soap*, xs__complexType *const*, const char*, const char*);
SOAP_FMAC3 xs__complexType ** SOAP_FMAC4 soap_get_PointerToxs__complexType(struct soap*, xs__complexType **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerToxs__simpleType_DEFINED
#define SOAP_TYPE_PointerToxs__simpleType_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxs__simpleType(struct soap*, xs__simpleType *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxs__simpleType(struct soap*, const char *, int, xs__simpleType *const*, const char *);
SOAP_FMAC3 xs__simpleType ** SOAP_FMAC4 soap_in_PointerToxs__simpleType(struct soap*, const char*, xs__simpleType **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxs__simpleType(struct soap*, xs__simpleType *const*, const char*, const char*);
SOAP_FMAC3 xs__simpleType ** SOAP_FMAC4 soap_get_PointerToxs__simpleType(struct soap*, xs__simpleType **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerToxs__formChoice_DEFINED
#define SOAP_TYPE_PointerToxs__formChoice_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxs__formChoice(struct soap*, enum xs__formChoice *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxs__formChoice(struct soap*, const char *, int, enum xs__formChoice *const*, const char *);
SOAP_FMAC3 enum xs__formChoice ** SOAP_FMAC4 soap_in_PointerToxs__formChoice(struct soap*, const char*, enum xs__formChoice **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxs__formChoice(struct soap*, enum xs__formChoice *const*, const char*, const char*);
SOAP_FMAC3 enum xs__formChoice ** SOAP_FMAC4 soap_get_PointerToxs__formChoice(struct soap*, enum xs__formChoice **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerToxs__annotation_DEFINED
#define SOAP_TYPE_PointerToxs__annotation_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxs__annotation(struct soap*, xs__annotation *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxs__annotation(struct soap*, const char *, int, xs__annotation *const*, const char *);
SOAP_FMAC3 xs__annotation ** SOAP_FMAC4 soap_in_PointerToxs__annotation(struct soap*, const char*, xs__annotation **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxs__annotation(struct soap*, xs__annotation *const*, const char*, const char*);
SOAP_FMAC3 xs__annotation ** SOAP_FMAC4 soap_get_PointerToxs__annotation(struct soap*, xs__annotation **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_xsd__string_DEFINED
#define SOAP_TYPE_xsd__string_DEFINED

inline void soap_default_xsd__string(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_xsd__string
	*a = SOAP_DEFAULT_xsd__string;
#else
	*a = (char *)0;
#endif
}
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__string(struct soap*, char *const*);

#define soap_xsd__string2s(soap, a) (a)
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__string(struct soap*, const char*, int, char*const*, const char*);

#define soap_s2xsd__string(soap, s, a) soap_s2char((soap), (s), (char**)(a), 1, 0, -1, NULL)
SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__string(struct soap*, const char*, char **, const char*);

#define wsdl_instantiate_xsd__string wsdl_instantiate_string


#define soap_new_xsd__string soap_new_string

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__string(struct soap*, char *const*, const char*, const char*);

inline int soap_write_xsd__string(struct soap *soap, char *const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || ::soap_put_xsd__string(soap, p, "xsd:string", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_xsd__string(struct soap *soap, const char *URL, char *const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_xsd__string(soap, p, "xsd:string", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_xsd__string(struct soap *soap, const char *URL, char *const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_xsd__string(soap, p, "xsd:string", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_xsd__string(struct soap *soap, const char *URL, char *const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_xsd__string(soap, p, "xsd:string", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__string(struct soap*, char **, const char*, const char*);

inline int soap_read_xsd__string(struct soap *soap, char **p)
{
	if (p)
	{	if (soap_begin_recv(soap) || ::soap_get_xsd__string(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_xsd__string(struct soap *soap, const char *URL, char **p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_xsd__string(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_xsd__string(struct soap *soap, char **p)
{
	if (::soap_read_xsd__string(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_xsd__token_DEFINED
#define SOAP_TYPE_xsd__token_DEFINED

inline void soap_default_xsd__token(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_xsd__token
	*a = SOAP_DEFAULT_xsd__token;
#else
	*a = (char *)0;
#endif
}
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__token(struct soap*, char *const*);

#define soap_xsd__token2s(soap, a) (a)
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__token(struct soap*, const char*, int, char*const*, const char*);

#define soap_s2xsd__token(soap, s, a) soap_s2char((soap), (s), (char**)(a), 5, 0, -1, NULL)
SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__token(struct soap*, const char*, char **, const char*);

#define wsdl_instantiate_xsd__token wsdl_instantiate_string


#define soap_new_xsd__token soap_new_string

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__token(struct soap*, char *const*, const char*, const char*);

inline int soap_write_xsd__token(struct soap *soap, char *const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || ::soap_put_xsd__token(soap, p, "xsd:token", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_xsd__token(struct soap *soap, const char *URL, char *const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_xsd__token(soap, p, "xsd:token", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_xsd__token(struct soap *soap, const char *URL, char *const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_xsd__token(soap, p, "xsd:token", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_xsd__token(struct soap *soap, const char *URL, char *const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_xsd__token(soap, p, "xsd:token", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__token(struct soap*, char **, const char*, const char*);

inline int soap_read_xsd__token(struct soap *soap, char **p)
{
	if (p)
	{	if (soap_begin_recv(soap) || ::soap_get_xsd__token(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_xsd__token(struct soap *soap, const char *URL, char **p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_xsd__token(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_xsd__token(struct soap *soap, char **p)
{
	if (::soap_read_xsd__token(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_xsd__QName_DEFINED
#define SOAP_TYPE_xsd__QName_DEFINED

inline void soap_default_xsd__QName(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_xsd__QName
	*a = SOAP_DEFAULT_xsd__QName;
#else
	*a = (char *)0;
#endif
}
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__QName(struct soap*, char *const*);

#define soap_xsd__QName2s(soap, a) soap_QName2s(soap, (a))
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__QName(struct soap*, const char*, int, char*const*, const char*);

#define soap_s2xsd__QName(soap, s, a) soap_s2QName((soap), (s), (char**)(a), 0, -1, NULL)
SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__QName(struct soap*, const char*, char **, const char*);

#define wsdl_instantiate_xsd__QName wsdl_instantiate_string


#define soap_new_xsd__QName soap_new_string

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__QName(struct soap*, char *const*, const char*, const char*);

inline int soap_write_xsd__QName(struct soap *soap, char *const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || ::soap_put_xsd__QName(soap, p, "xsd:QName", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_xsd__QName(struct soap *soap, const char *URL, char *const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_xsd__QName(soap, p, "xsd:QName", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_xsd__QName(struct soap *soap, const char *URL, char *const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_xsd__QName(soap, p, "xsd:QName", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_xsd__QName(struct soap *soap, const char *URL, char *const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_xsd__QName(soap, p, "xsd:QName", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__QName(struct soap*, char **, const char*, const char*);

inline int soap_read_xsd__QName(struct soap *soap, char **p)
{
	if (p)
	{	if (soap_begin_recv(soap) || ::soap_get_xsd__QName(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_xsd__QName(struct soap *soap, const char *URL, char **p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_xsd__QName(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_xsd__QName(struct soap *soap, char **p)
{
	if (::soap_read_xsd__QName(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_xsd__NMTOKENS_DEFINED
#define SOAP_TYPE_xsd__NMTOKENS_DEFINED

inline void soap_default_xsd__NMTOKENS(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_xsd__NMTOKENS
	*a = SOAP_DEFAULT_xsd__NMTOKENS;
#else
	*a = (char *)0;
#endif
}
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__NMTOKENS(struct soap*, char *const*);

#define soap_xsd__NMTOKENS2s(soap, a) (a)
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__NMTOKENS(struct soap*, const char*, int, char*const*, const char*);

#define soap_s2xsd__NMTOKENS(soap, s, a) soap_s2char((soap), (s), (char**)(a), 5, 0, -1, "(\\c+[ ])*\\c+")
SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__NMTOKENS(struct soap*, const char*, char **, const char*);

#define wsdl_instantiate_xsd__NMTOKENS wsdl_instantiate_string


#define soap_new_xsd__NMTOKENS soap_new_string

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__NMTOKENS(struct soap*, char *const*, const char*, const char*);

inline int soap_write_xsd__NMTOKENS(struct soap *soap, char *const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || ::soap_put_xsd__NMTOKENS(soap, p, "xsd:NMTOKENS", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_xsd__NMTOKENS(struct soap *soap, const char *URL, char *const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_xsd__NMTOKENS(soap, p, "xsd:NMTOKENS", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_xsd__NMTOKENS(struct soap *soap, const char *URL, char *const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_xsd__NMTOKENS(soap, p, "xsd:NMTOKENS", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_xsd__NMTOKENS(struct soap *soap, const char *URL, char *const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_xsd__NMTOKENS(soap, p, "xsd:NMTOKENS", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__NMTOKENS(struct soap*, char **, const char*, const char*);

inline int soap_read_xsd__NMTOKENS(struct soap *soap, char **p)
{
	if (p)
	{	if (soap_begin_recv(soap) || ::soap_get_xsd__NMTOKENS(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_xsd__NMTOKENS(struct soap *soap, const char *URL, char **p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_xsd__NMTOKENS(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_xsd__NMTOKENS(struct soap *soap, char **p)
{
	if (::soap_read_xsd__NMTOKENS(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_xsd__NMTOKEN_DEFINED
#define SOAP_TYPE_xsd__NMTOKEN_DEFINED

inline void soap_default_xsd__NMTOKEN(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_xsd__NMTOKEN
	*a = SOAP_DEFAULT_xsd__NMTOKEN;
#else
	*a = (char *)0;
#endif
}
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__NMTOKEN(struct soap*, char *const*);

#define soap_xsd__NMTOKEN2s(soap, a) (a)
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__NMTOKEN(struct soap*, const char*, int, char*const*, const char*);

#define soap_s2xsd__NMTOKEN(soap, s, a) soap_s2char((soap), (s), (char**)(a), 5, 0, -1, "\\c+")
SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__NMTOKEN(struct soap*, const char*, char **, const char*);

#define wsdl_instantiate_xsd__NMTOKEN wsdl_instantiate_string


#define soap_new_xsd__NMTOKEN soap_new_string

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__NMTOKEN(struct soap*, char *const*, const char*, const char*);

inline int soap_write_xsd__NMTOKEN(struct soap *soap, char *const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || ::soap_put_xsd__NMTOKEN(soap, p, "xsd:NMTOKEN", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_xsd__NMTOKEN(struct soap *soap, const char *URL, char *const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_xsd__NMTOKEN(soap, p, "xsd:NMTOKEN", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_xsd__NMTOKEN(struct soap *soap, const char *URL, char *const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_xsd__NMTOKEN(soap, p, "xsd:NMTOKEN", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_xsd__NMTOKEN(struct soap *soap, const char *URL, char *const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_xsd__NMTOKEN(soap, p, "xsd:NMTOKEN", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__NMTOKEN(struct soap*, char **, const char*, const char*);

inline int soap_read_xsd__NMTOKEN(struct soap *soap, char **p)
{
	if (p)
	{	if (soap_begin_recv(soap) || ::soap_get_xsd__NMTOKEN(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_xsd__NMTOKEN(struct soap *soap, const char *URL, char **p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_xsd__NMTOKEN(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_xsd__NMTOKEN(struct soap *soap, char **p)
{
	if (::soap_read_xsd__NMTOKEN(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_xsd__NCName_DEFINED
#define SOAP_TYPE_xsd__NCName_DEFINED

inline void soap_default_xsd__NCName(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_xsd__NCName
	*a = SOAP_DEFAULT_xsd__NCName;
#else
	*a = (char *)0;
#endif
}
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__NCName(struct soap*, char *const*);

#define soap_xsd__NCName2s(soap, a) (a)
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__NCName(struct soap*, const char*, int, char*const*, const char*);

#define soap_s2xsd__NCName(soap, s, a) soap_s2char((soap), (s), (char**)(a), 5, 0, -1, "[\\i-[:]][\\c-[:]]*")
SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__NCName(struct soap*, const char*, char **, const char*);

#define wsdl_instantiate_xsd__NCName wsdl_instantiate_string


#define soap_new_xsd__NCName soap_new_string

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__NCName(struct soap*, char *const*, const char*, const char*);

inline int soap_write_xsd__NCName(struct soap *soap, char *const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || ::soap_put_xsd__NCName(soap, p, "xsd:NCName", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_xsd__NCName(struct soap *soap, const char *URL, char *const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_xsd__NCName(soap, p, "xsd:NCName", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_xsd__NCName(struct soap *soap, const char *URL, char *const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_xsd__NCName(soap, p, "xsd:NCName", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_xsd__NCName(struct soap *soap, const char *URL, char *const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_xsd__NCName(soap, p, "xsd:NCName", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__NCName(struct soap*, char **, const char*, const char*);

inline int soap_read_xsd__NCName(struct soap *soap, char **p)
{
	if (p)
	{	if (soap_begin_recv(soap) || ::soap_get_xsd__NCName(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_xsd__NCName(struct soap *soap, const char *URL, char **p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_xsd__NCName(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_xsd__NCName(struct soap *soap, char **p)
{
	if (::soap_read_xsd__NCName(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_xsd__ID_DEFINED
#define SOAP_TYPE_xsd__ID_DEFINED

inline void soap_default_xsd__ID(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_xsd__ID
	*a = SOAP_DEFAULT_xsd__ID;
#else
	*a = (char *)0;
#endif
}
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__ID(struct soap*, char *const*);

#define soap_xsd__ID2s(soap, a) (a)
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__ID(struct soap*, const char*, int, char*const*, const char*);

#define soap_s2xsd__ID(soap, s, a) soap_s2char((soap), (s), (char**)(a), 5, 0, -1, "[\\i-[:]][\\c-[:]]*")
SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__ID(struct soap*, const char*, char **, const char*);

#define wsdl_instantiate_xsd__ID wsdl_instantiate_string


#define soap_new_xsd__ID soap_new_string

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__ID(struct soap*, char *const*, const char*, const char*);

inline int soap_write_xsd__ID(struct soap *soap, char *const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || ::soap_put_xsd__ID(soap, p, "xsd:ID", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_xsd__ID(struct soap *soap, const char *URL, char *const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_xsd__ID(soap, p, "xsd:ID", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_xsd__ID(struct soap *soap, const char *URL, char *const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_xsd__ID(soap, p, "xsd:ID", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_xsd__ID(struct soap *soap, const char *URL, char *const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_xsd__ID(soap, p, "xsd:ID", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__ID(struct soap*, char **, const char*, const char*);

inline int soap_read_xsd__ID(struct soap *soap, char **p)
{
	if (p)
	{	if (soap_begin_recv(soap) || ::soap_get_xsd__ID(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_xsd__ID(struct soap *soap, const char *URL, char **p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_xsd__ID(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_xsd__ID(struct soap *soap, char **p)
{
	if (::soap_read_xsd__ID(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_xsd__anyURI_DEFINED
#define SOAP_TYPE_xsd__anyURI_DEFINED

inline void soap_default_xsd__anyURI(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_xsd__anyURI
	*a = SOAP_DEFAULT_xsd__anyURI;
#else
	*a = (char *)0;
#endif
}
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__anyURI(struct soap*, char *const*);

#define soap_xsd__anyURI2s(soap, a) (a)
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anyURI(struct soap*, const char*, int, char*const*, const char*);

#define soap_s2xsd__anyURI(soap, s, a) soap_s2char((soap), (s), (char**)(a), 4, 0, -1, NULL)
SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__anyURI(struct soap*, const char*, char **, const char*);

#define wsdl_instantiate_xsd__anyURI wsdl_instantiate_string


#define soap_new_xsd__anyURI soap_new_string

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__anyURI(struct soap*, char *const*, const char*, const char*);

inline int soap_write_xsd__anyURI(struct soap *soap, char *const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || ::soap_put_xsd__anyURI(soap, p, "xsd:anyURI", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_xsd__anyURI(struct soap *soap, const char *URL, char *const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_xsd__anyURI(soap, p, "xsd:anyURI", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_xsd__anyURI(struct soap *soap, const char *URL, char *const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_xsd__anyURI(soap, p, "xsd:anyURI", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_xsd__anyURI(struct soap *soap, const char *URL, char *const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_xsd__anyURI(soap, p, "xsd:anyURI", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__anyURI(struct soap*, char **, const char*, const char*);

inline int soap_read_xsd__anyURI(struct soap *soap, char **p)
{
	if (p)
	{	if (soap_begin_recv(soap) || ::soap_get_xsd__anyURI(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_xsd__anyURI(struct soap *soap, const char *URL, char **p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_xsd__anyURI(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_xsd__anyURI(struct soap *soap, char **p)
{
	if (::soap_read_xsd__anyURI(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE__QName_DEFINED
#define SOAP_TYPE__QName_DEFINED

inline void soap_default__QName(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT__QName
	*a = SOAP_DEFAULT__QName;
#else
	*a = (char *)0;
#endif
}
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap*, char *const*);

#define soap__QName2s(soap, a) soap_QName2s(soap, (a))
SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap*, const char*, int, char*const*, const char*);

#define soap_s2_QName(soap, s, a) soap_s2QName((soap), (s), (char**)(a), 0, -1, NULL)
SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap*, const char*, char **, const char*);

#define wsdl_instantiate__QName wsdl_instantiate_string


#define soap_new__QName soap_new_string

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap*, char *const*, const char*, const char*);

inline int soap_write__QName(struct soap *soap, char *const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || ::soap_put__QName(soap, p, "QName", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT__QName(struct soap *soap, const char *URL, char *const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put__QName(soap, p, "QName", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH__QName(struct soap *soap, const char *URL, char *const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put__QName(soap, p, "QName", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send__QName(struct soap *soap, const char *URL, char *const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put__QName(soap, p, "QName", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap*, char **, const char*, const char*);

inline int soap_read__QName(struct soap *soap, char **p)
{
	if (p)
	{	if (soap_begin_recv(soap) || ::soap_get__QName(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET__QName(struct soap *soap, const char *URL, char **p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read__QName(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv__QName(struct soap *soap, char **p)
{
	if (::soap_read__QName(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE__XML_DEFINED
#define SOAP_TYPE__XML_DEFINED
#endif

#ifndef SOAP_TYPE_string_DEFINED
#define SOAP_TYPE_string_DEFINED

inline void soap_default_string(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap*, char *const*);

#define soap_string2s(soap, a) (a)
SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap*, const char*, int, char*const*, const char*);

#define soap_s2string(soap, s, a) soap_s2char((soap), (s), (char**)(a), 1, 0, -1, NULL)
SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap*, const char*, char **, const char*);

SOAP_FMAC3 char * * SOAP_FMAC4 soap_new_string(struct soap *soap, int n = -1);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap*, char *const*, const char*, const char*);

inline int soap_write_string(struct soap *soap, char *const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || ::soap_put_string(soap, p, "string", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_string(struct soap *soap, const char *URL, char *const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_string(soap, p, "string", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_PATCH_string(struct soap *soap, const char *URL, char *const*p)
{
	soap_free_temp(soap);
	if (soap_PATCH(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_string(soap, p, "string", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

inline int soap_POST_send_string(struct soap *soap, const char *URL, char *const*p)
{
	soap_free_temp(soap);
	if (soap_POST(soap, URL, NULL, "text/xml; charset=utf-8") || ::soap_put_string(soap, p, "string", "") || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}
SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap*, char **, const char*, const char*);

inline int soap_read_string(struct soap *soap, char **p)
{
	if (p)
	{	if (soap_begin_recv(soap) || ::soap_get_string(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_string(struct soap *soap, const char *URL, char **p)
{
	if (soap_GET(soap, URL, NULL) || ::soap_read_string(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

inline int soap_POST_recv_string(struct soap *soap, char **p)
{
	if (::soap_read_string(soap, p))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOfgwsdl__portType_DEFINED
#define SOAP_TYPE_std__vectorTemplateOfgwsdl__portType_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfgwsdl__portType(struct soap*, std::vector<gwsdl__portType> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfgwsdl__portType(struct soap*, const std::vector<gwsdl__portType> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfgwsdl__portType(struct soap*, const char*, int, const std::vector<gwsdl__portType> *, const char*);
SOAP_FMAC3 std::vector<gwsdl__portType> * SOAP_FMAC4 soap_in_std__vectorTemplateOfgwsdl__portType(struct soap*, const char*, std::vector<gwsdl__portType> *, const char*);
SOAP_FMAC1 std::vector<gwsdl__portType>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfgwsdl__portType(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<gwsdl__portType>  * soap_new_std__vectorTemplateOfgwsdl__portType(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_std__vectorTemplateOfgwsdl__portType(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOfvprop__tPropertyAlias_DEFINED
#define SOAP_TYPE_std__vectorTemplateOfvprop__tPropertyAlias_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfvprop__tPropertyAlias(struct soap*, std::vector<vprop__tPropertyAlias> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfvprop__tPropertyAlias(struct soap*, const std::vector<vprop__tPropertyAlias> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfvprop__tPropertyAlias(struct soap*, const char*, int, const std::vector<vprop__tPropertyAlias> *, const char*);
SOAP_FMAC3 std::vector<vprop__tPropertyAlias> * SOAP_FMAC4 soap_in_std__vectorTemplateOfvprop__tPropertyAlias(struct soap*, const char*, std::vector<vprop__tPropertyAlias> *, const char*);
SOAP_FMAC1 std::vector<vprop__tPropertyAlias>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfvprop__tPropertyAlias(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<vprop__tPropertyAlias>  * soap_new_std__vectorTemplateOfvprop__tPropertyAlias(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_std__vectorTemplateOfvprop__tPropertyAlias(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOfvprop__tProperty_DEFINED
#define SOAP_TYPE_std__vectorTemplateOfvprop__tProperty_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfvprop__tProperty(struct soap*, std::vector<vprop__tProperty> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfvprop__tProperty(struct soap*, const std::vector<vprop__tProperty> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfvprop__tProperty(struct soap*, const char*, int, const std::vector<vprop__tProperty> *, const char*);
SOAP_FMAC3 std::vector<vprop__tProperty> * SOAP_FMAC4 soap_in_std__vectorTemplateOfvprop__tProperty(struct soap*, const char*, std::vector<vprop__tProperty> *, const char*);
SOAP_FMAC1 std::vector<vprop__tProperty>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfvprop__tProperty(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<vprop__tProperty>  * soap_new_std__vectorTemplateOfvprop__tProperty(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_std__vectorTemplateOfvprop__tProperty(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOfplnk__tPartnerLinkType_DEFINED
#define SOAP_TYPE_std__vectorTemplateOfplnk__tPartnerLinkType_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfplnk__tPartnerLinkType(struct soap*, std::vector<plnk__tPartnerLinkType> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfplnk__tPartnerLinkType(struct soap*, const std::vector<plnk__tPartnerLinkType> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfplnk__tPartnerLinkType(struct soap*, const char*, int, const std::vector<plnk__tPartnerLinkType> *, const char*);
SOAP_FMAC3 std::vector<plnk__tPartnerLinkType> * SOAP_FMAC4 soap_in_std__vectorTemplateOfplnk__tPartnerLinkType(struct soap*, const char*, std::vector<plnk__tPartnerLinkType> *, const char*);
SOAP_FMAC1 std::vector<plnk__tPartnerLinkType>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfplnk__tPartnerLinkType(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<plnk__tPartnerLinkType>  * soap_new_std__vectorTemplateOfplnk__tPartnerLinkType(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_std__vectorTemplateOfplnk__tPartnerLinkType(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOfwsdl__service_DEFINED
#define SOAP_TYPE_std__vectorTemplateOfwsdl__service_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfwsdl__service(struct soap*, std::vector<wsdl__service> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfwsdl__service(struct soap*, const std::vector<wsdl__service> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfwsdl__service(struct soap*, const char*, int, const std::vector<wsdl__service> *, const char*);
SOAP_FMAC3 std::vector<wsdl__service> * SOAP_FMAC4 soap_in_std__vectorTemplateOfwsdl__service(struct soap*, const char*, std::vector<wsdl__service> *, const char*);
SOAP_FMAC1 std::vector<wsdl__service>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfwsdl__service(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<wsdl__service>  * soap_new_std__vectorTemplateOfwsdl__service(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_std__vectorTemplateOfwsdl__service(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOfwsdl__binding_DEFINED
#define SOAP_TYPE_std__vectorTemplateOfwsdl__binding_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfwsdl__binding(struct soap*, std::vector<wsdl__binding> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfwsdl__binding(struct soap*, const std::vector<wsdl__binding> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfwsdl__binding(struct soap*, const char*, int, const std::vector<wsdl__binding> *, const char*);
SOAP_FMAC3 std::vector<wsdl__binding> * SOAP_FMAC4 soap_in_std__vectorTemplateOfwsdl__binding(struct soap*, const char*, std::vector<wsdl__binding> *, const char*);
SOAP_FMAC1 std::vector<wsdl__binding>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfwsdl__binding(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<wsdl__binding>  * soap_new_std__vectorTemplateOfwsdl__binding(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_std__vectorTemplateOfwsdl__binding(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOfwsdl__portType_DEFINED
#define SOAP_TYPE_std__vectorTemplateOfwsdl__portType_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfwsdl__portType(struct soap*, std::vector<wsdl__portType> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfwsdl__portType(struct soap*, const std::vector<wsdl__portType> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfwsdl__portType(struct soap*, const char*, int, const std::vector<wsdl__portType> *, const char*);
SOAP_FMAC3 std::vector<wsdl__portType> * SOAP_FMAC4 soap_in_std__vectorTemplateOfwsdl__portType(struct soap*, const char*, std::vector<wsdl__portType> *, const char*);
SOAP_FMAC1 std::vector<wsdl__portType>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfwsdl__portType(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<wsdl__portType>  * soap_new_std__vectorTemplateOfwsdl__portType(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_std__vectorTemplateOfwsdl__portType(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOfwsdl__message_DEFINED
#define SOAP_TYPE_std__vectorTemplateOfwsdl__message_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfwsdl__message(struct soap*, std::vector<wsdl__message> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfwsdl__message(struct soap*, const std::vector<wsdl__message> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfwsdl__message(struct soap*, const char*, int, const std::vector<wsdl__message> *, const char*);
SOAP_FMAC3 std::vector<wsdl__message> * SOAP_FMAC4 soap_in_std__vectorTemplateOfwsdl__message(struct soap*, const char*, std::vector<wsdl__message> *, const char*);
SOAP_FMAC1 std::vector<wsdl__message>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfwsdl__message(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<wsdl__message>  * soap_new_std__vectorTemplateOfwsdl__message(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_std__vectorTemplateOfwsdl__message(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOfwsdl__import_DEFINED
#define SOAP_TYPE_std__vectorTemplateOfwsdl__import_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfwsdl__import(struct soap*, std::vector<wsdl__import> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfwsdl__import(struct soap*, const std::vector<wsdl__import> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfwsdl__import(struct soap*, const char*, int, const std::vector<wsdl__import> *, const char*);
SOAP_FMAC3 std::vector<wsdl__import> * SOAP_FMAC4 soap_in_std__vectorTemplateOfwsdl__import(struct soap*, const char*, std::vector<wsdl__import> *, const char*);
SOAP_FMAC1 std::vector<wsdl__import>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfwsdl__import(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<wsdl__import>  * soap_new_std__vectorTemplateOfwsdl__import(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_std__vectorTemplateOfwsdl__import(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOfwsdl__port_DEFINED
#define SOAP_TYPE_std__vectorTemplateOfwsdl__port_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfwsdl__port(struct soap*, std::vector<wsdl__port> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfwsdl__port(struct soap*, const std::vector<wsdl__port> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfwsdl__port(struct soap*, const char*, int, const std::vector<wsdl__port> *, const char*);
SOAP_FMAC3 std::vector<wsdl__port> * SOAP_FMAC4 soap_in_std__vectorTemplateOfwsdl__port(struct soap*, const char*, std::vector<wsdl__port> *, const char*);
SOAP_FMAC1 std::vector<wsdl__port>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfwsdl__port(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<wsdl__port>  * soap_new_std__vectorTemplateOfwsdl__port(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_std__vectorTemplateOfwsdl__port(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOfwsdl__ext_operation_DEFINED
#define SOAP_TYPE_std__vectorTemplateOfwsdl__ext_operation_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfwsdl__ext_operation(struct soap*, std::vector<wsdl__ext_operation> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfwsdl__ext_operation(struct soap*, const std::vector<wsdl__ext_operation> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfwsdl__ext_operation(struct soap*, const char*, int, const std::vector<wsdl__ext_operation> *, const char*);
SOAP_FMAC3 std::vector<wsdl__ext_operation> * SOAP_FMAC4 soap_in_std__vectorTemplateOfwsdl__ext_operation(struct soap*, const char*, std::vector<wsdl__ext_operation> *, const char*);
SOAP_FMAC1 std::vector<wsdl__ext_operation>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfwsdl__ext_operation(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<wsdl__ext_operation>  * soap_new_std__vectorTemplateOfwsdl__ext_operation(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_std__vectorTemplateOfwsdl__ext_operation(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOfwsdl__ext_fault_DEFINED
#define SOAP_TYPE_std__vectorTemplateOfwsdl__ext_fault_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfwsdl__ext_fault(struct soap*, std::vector<wsdl__ext_fault> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfwsdl__ext_fault(struct soap*, const std::vector<wsdl__ext_fault> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfwsdl__ext_fault(struct soap*, const char*, int, const std::vector<wsdl__ext_fault> *, const char*);
SOAP_FMAC3 std::vector<wsdl__ext_fault> * SOAP_FMAC4 soap_in_std__vectorTemplateOfwsdl__ext_fault(struct soap*, const char*, std::vector<wsdl__ext_fault> *, const char*);
SOAP_FMAC1 std::vector<wsdl__ext_fault>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfwsdl__ext_fault(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<wsdl__ext_fault>  * soap_new_std__vectorTemplateOfwsdl__ext_fault(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_std__vectorTemplateOfwsdl__ext_fault(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOfwhttp__header_DEFINED
#define SOAP_TYPE_std__vectorTemplateOfwhttp__header_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfwhttp__header(struct soap*, std::vector<whttp__header> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfwhttp__header(struct soap*, const std::vector<whttp__header> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfwhttp__header(struct soap*, const char*, int, const std::vector<whttp__header> *, const char*);
SOAP_FMAC3 std::vector<whttp__header> * SOAP_FMAC4 soap_in_std__vectorTemplateOfwhttp__header(struct soap*, const char*, std::vector<whttp__header> *, const char*);
SOAP_FMAC1 std::vector<whttp__header>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfwhttp__header(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<whttp__header>  * soap_new_std__vectorTemplateOfwhttp__header(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_std__vectorTemplateOfwhttp__header(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOfwsoap__header_DEFINED
#define SOAP_TYPE_std__vectorTemplateOfwsoap__header_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfwsoap__header(struct soap*, std::vector<wsoap__header> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfwsoap__header(struct soap*, const std::vector<wsoap__header> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfwsoap__header(struct soap*, const char*, int, const std::vector<wsoap__header> *, const char*);
SOAP_FMAC3 std::vector<wsoap__header> * SOAP_FMAC4 soap_in_std__vectorTemplateOfwsoap__header(struct soap*, const char*, std::vector<wsoap__header> *, const char*);
SOAP_FMAC1 std::vector<wsoap__header>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfwsoap__header(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<wsoap__header>  * soap_new_std__vectorTemplateOfwsoap__header(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_std__vectorTemplateOfwsoap__header(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOfwsoap__module_DEFINED
#define SOAP_TYPE_std__vectorTemplateOfwsoap__module_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfwsoap__module(struct soap*, std::vector<wsoap__module> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfwsoap__module(struct soap*, const std::vector<wsoap__module> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfwsoap__module(struct soap*, const char*, int, const std::vector<wsoap__module> *, const char*);
SOAP_FMAC3 std::vector<wsoap__module> * SOAP_FMAC4 soap_in_std__vectorTemplateOfwsoap__module(struct soap*, const char*, std::vector<wsoap__module> *, const char*);
SOAP_FMAC1 std::vector<wsoap__module>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfwsoap__module(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<wsoap__module>  * soap_new_std__vectorTemplateOfwsoap__module(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_std__vectorTemplateOfwsoap__module(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOfwsdl__operation_DEFINED
#define SOAP_TYPE_std__vectorTemplateOfwsdl__operation_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfwsdl__operation(struct soap*, std::vector<wsdl__operation> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfwsdl__operation(struct soap*, const std::vector<wsdl__operation> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfwsdl__operation(struct soap*, const char*, int, const std::vector<wsdl__operation> *, const char*);
SOAP_FMAC3 std::vector<wsdl__operation> * SOAP_FMAC4 soap_in_std__vectorTemplateOfwsdl__operation(struct soap*, const char*, std::vector<wsdl__operation> *, const char*);
SOAP_FMAC1 std::vector<wsdl__operation>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfwsdl__operation(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<wsdl__operation>  * soap_new_std__vectorTemplateOfwsdl__operation(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_std__vectorTemplateOfwsdl__operation(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOfwsdl__fault_DEFINED
#define SOAP_TYPE_std__vectorTemplateOfwsdl__fault_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfwsdl__fault(struct soap*, std::vector<wsdl__fault> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfwsdl__fault(struct soap*, const std::vector<wsdl__fault> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfwsdl__fault(struct soap*, const char*, int, const std::vector<wsdl__fault> *, const char*);
SOAP_FMAC3 std::vector<wsdl__fault> * SOAP_FMAC4 soap_in_std__vectorTemplateOfwsdl__fault(struct soap*, const char*, std::vector<wsdl__fault> *, const char*);
SOAP_FMAC1 std::vector<wsdl__fault>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfwsdl__fault(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<wsdl__fault>  * soap_new_std__vectorTemplateOfwsdl__fault(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_std__vectorTemplateOfwsdl__fault(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOfwsdl__part_DEFINED
#define SOAP_TYPE_std__vectorTemplateOfwsdl__part_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfwsdl__part(struct soap*, std::vector<wsdl__part> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfwsdl__part(struct soap*, const std::vector<wsdl__part> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfwsdl__part(struct soap*, const char*, int, const std::vector<wsdl__part> *, const char*);
SOAP_FMAC3 std::vector<wsdl__part> * SOAP_FMAC4 soap_in_std__vectorTemplateOfwsdl__part(struct soap*, const char*, std::vector<wsdl__part> *, const char*);
SOAP_FMAC1 std::vector<wsdl__part>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfwsdl__part(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<wsdl__part>  * soap_new_std__vectorTemplateOfwsdl__part(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_std__vectorTemplateOfwsdl__part(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOfwsp__PolicyReference_DEFINED
#define SOAP_TYPE_std__vectorTemplateOfwsp__PolicyReference_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfwsp__PolicyReference(struct soap*, std::vector<wsp__PolicyReference> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfwsp__PolicyReference(struct soap*, const std::vector<wsp__PolicyReference> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfwsp__PolicyReference(struct soap*, const char*, int, const std::vector<wsp__PolicyReference> *, const char*);
SOAP_FMAC3 std::vector<wsp__PolicyReference> * SOAP_FMAC4 soap_in_std__vectorTemplateOfwsp__PolicyReference(struct soap*, const char*, std::vector<wsp__PolicyReference> *, const char*);
SOAP_FMAC1 std::vector<wsp__PolicyReference>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfwsp__PolicyReference(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<wsp__PolicyReference>  * soap_new_std__vectorTemplateOfwsp__PolicyReference(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_std__vectorTemplateOfwsp__PolicyReference(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOfwsp__Policy_DEFINED
#define SOAP_TYPE_std__vectorTemplateOfwsp__Policy_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfwsp__Policy(struct soap*, std::vector<wsp__Policy> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfwsp__Policy(struct soap*, const std::vector<wsp__Policy> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfwsp__Policy(struct soap*, const char*, int, const std::vector<wsp__Policy> *, const char*);
SOAP_FMAC3 std::vector<wsp__Policy> * SOAP_FMAC4 soap_in_std__vectorTemplateOfwsp__Policy(struct soap*, const char*, std::vector<wsp__Policy> *, const char*);
SOAP_FMAC1 std::vector<wsp__Policy>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfwsp__Policy(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<wsp__Policy>  * soap_new_std__vectorTemplateOfwsp__Policy(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_std__vectorTemplateOfwsp__Policy(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOfPointerToxs__schema_DEFINED
#define SOAP_TYPE_std__vectorTemplateOfPointerToxs__schema_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerToxs__schema(struct soap*, std::vector<xs__schema *> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerToxs__schema(struct soap*, const std::vector<xs__schema *> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerToxs__schema(struct soap*, const char*, int, const std::vector<xs__schema *> *, const char*);
SOAP_FMAC3 std::vector<xs__schema *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerToxs__schema(struct soap*, const char*, std::vector<xs__schema *> *, const char*);
SOAP_FMAC1 std::vector<xs__schema *>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfPointerToxs__schema(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<xs__schema *>  * soap_new_std__vectorTemplateOfPointerToxs__schema(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_std__vectorTemplateOfPointerToxs__schema(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOfplnk__tRole_DEFINED
#define SOAP_TYPE_std__vectorTemplateOfplnk__tRole_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfplnk__tRole(struct soap*, std::vector<plnk__tRole> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfplnk__tRole(struct soap*, const std::vector<plnk__tRole> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfplnk__tRole(struct soap*, const char*, int, const std::vector<plnk__tRole> *, const char*);
SOAP_FMAC3 std::vector<plnk__tRole> * SOAP_FMAC4 soap_in_std__vectorTemplateOfplnk__tRole(struct soap*, const char*, std::vector<plnk__tRole> *, const char*);
SOAP_FMAC1 std::vector<plnk__tRole>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfplnk__tRole(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<plnk__tRole>  * soap_new_std__vectorTemplateOfplnk__tRole(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_std__vectorTemplateOfplnk__tRole(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOfwsp__Attachment_DEFINED
#define SOAP_TYPE_std__vectorTemplateOfwsp__Attachment_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfwsp__Attachment(struct soap*, std::vector<wsp__Attachment> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfwsp__Attachment(struct soap*, const std::vector<wsp__Attachment> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfwsp__Attachment(struct soap*, const char*, int, const std::vector<wsp__Attachment> *, const char*);
SOAP_FMAC3 std::vector<wsp__Attachment> * SOAP_FMAC4 soap_in_std__vectorTemplateOfwsp__Attachment(struct soap*, const char*, std::vector<wsp__Attachment> *, const char*);
SOAP_FMAC1 std::vector<wsp__Attachment>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfwsp__Attachment(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<wsp__Attachment>  * soap_new_std__vectorTemplateOfwsp__Attachment(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_std__vectorTemplateOfwsp__Attachment(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOf_XML_DEFINED
#define SOAP_TYPE_std__vectorTemplateOf_XML_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf_XML(struct soap*, std::vector<char *> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf_XML(struct soap*, const std::vector<char *> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf_XML(struct soap*, const char*, int, const std::vector<char *> *, const char*);
SOAP_FMAC3 std::vector<char *> * SOAP_FMAC4 soap_in_std__vectorTemplateOf_XML(struct soap*, const char*, std::vector<char *> *, const char*);
SOAP_FMAC1 std::vector<char *>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOf_XML(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<char *>  * soap_new_std__vectorTemplateOf_XML(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_std__vectorTemplateOf_XML(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOfsp__Parts_DEFINED
#define SOAP_TYPE_std__vectorTemplateOfsp__Parts_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfsp__Parts(struct soap*, std::vector<sp__Parts> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfsp__Parts(struct soap*, const std::vector<sp__Parts> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfsp__Parts(struct soap*, const char*, int, const std::vector<sp__Parts> *, const char*);
SOAP_FMAC3 std::vector<sp__Parts> * SOAP_FMAC4 soap_in_std__vectorTemplateOfsp__Parts(struct soap*, const char*, std::vector<sp__Parts> *, const char*);
SOAP_FMAC1 std::vector<sp__Parts>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfsp__Parts(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<sp__Parts>  * soap_new_std__vectorTemplateOfsp__Parts(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_std__vectorTemplateOfsp__Parts(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTowsp__Content_DEFINED
#define SOAP_TYPE_std__vectorTemplateOfPointerTowsp__Content_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTowsp__Content(struct soap*, std::vector<wsp__Content *> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTowsp__Content(struct soap*, const std::vector<wsp__Content *> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTowsp__Content(struct soap*, const char*, int, const std::vector<wsp__Content *> *, const char*);
SOAP_FMAC3 std::vector<wsp__Content *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTowsp__Content(struct soap*, const char*, std::vector<wsp__Content *> *, const char*);
SOAP_FMAC1 std::vector<wsp__Content *>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfPointerTowsp__Content(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<wsp__Content *>  * soap_new_std__vectorTemplateOfPointerTowsp__Content(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_std__vectorTemplateOfPointerTowsp__Content(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOfxsd__string_DEFINED
#define SOAP_TYPE_std__vectorTemplateOfxsd__string_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfxsd__string(struct soap*, std::vector<char *> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfxsd__string(struct soap*, const std::vector<char *> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfxsd__string(struct soap*, const char*, int, const std::vector<char *> *, const char*);
SOAP_FMAC3 std::vector<char *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfxsd__string(struct soap*, const char*, std::vector<char *> *, const char*);
SOAP_FMAC1 std::vector<char *>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfxsd__string(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<char *>  * soap_new_std__vectorTemplateOfxsd__string(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_std__vectorTemplateOfxsd__string(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOfsp__Header_DEFINED
#define SOAP_TYPE_std__vectorTemplateOfsp__Header_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfsp__Header(struct soap*, std::vector<sp__Header> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfsp__Header(struct soap*, const std::vector<sp__Header> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfsp__Header(struct soap*, const char*, int, const std::vector<sp__Header> *, const char*);
SOAP_FMAC3 std::vector<sp__Header> * SOAP_FMAC4 soap_in_std__vectorTemplateOfsp__Header(struct soap*, const char*, std::vector<sp__Header> *, const char*);
SOAP_FMAC1 std::vector<sp__Header>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfsp__Header(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<sp__Header>  * soap_new_std__vectorTemplateOfsp__Header(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_std__vectorTemplateOfsp__Header(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOfsd__serviceData_DEFINED
#define SOAP_TYPE_std__vectorTemplateOfsd__serviceData_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfsd__serviceData(struct soap*, std::vector<sd__serviceData> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfsd__serviceData(struct soap*, const std::vector<sd__serviceData> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfsd__serviceData(struct soap*, const char*, int, const std::vector<sd__serviceData> *, const char*);
SOAP_FMAC3 std::vector<sd__serviceData> * SOAP_FMAC4 soap_in_std__vectorTemplateOfsd__serviceData(struct soap*, const char*, std::vector<sd__serviceData> *, const char*);
SOAP_FMAC1 std::vector<sd__serviceData>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfsd__serviceData(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<sd__serviceData>  * soap_new_std__vectorTemplateOfsd__serviceData(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_std__vectorTemplateOfsd__serviceData(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTowsdl__operation_DEFINED
#define SOAP_TYPE_std__vectorTemplateOfPointerTowsdl__operation_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTowsdl__operation(struct soap*, std::vector<wsdl__operation *> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTowsdl__operation(struct soap*, const std::vector<wsdl__operation *> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTowsdl__operation(struct soap*, const char*, int, const std::vector<wsdl__operation *> *, const char*);
SOAP_FMAC3 std::vector<wsdl__operation *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTowsdl__operation(struct soap*, const char*, std::vector<wsdl__operation *> *, const char*);
SOAP_FMAC1 std::vector<wsdl__operation *>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfPointerTowsdl__operation(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<wsdl__operation *>  * soap_new_std__vectorTemplateOfPointerTowsdl__operation(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_std__vectorTemplateOfPointerTowsdl__operation(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOfmime__part_DEFINED
#define SOAP_TYPE_std__vectorTemplateOfmime__part_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfmime__part(struct soap*, std::vector<mime__part> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfmime__part(struct soap*, const std::vector<mime__part> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfmime__part(struct soap*, const char*, int, const std::vector<mime__part> *, const char*);
SOAP_FMAC3 std::vector<mime__part> * SOAP_FMAC4 soap_in_std__vectorTemplateOfmime__part(struct soap*, const char*, std::vector<mime__part> *, const char*);
SOAP_FMAC1 std::vector<mime__part>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfmime__part(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<mime__part>  * soap_new_std__vectorTemplateOfmime__part(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_std__vectorTemplateOfmime__part(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOfmime__content_DEFINED
#define SOAP_TYPE_std__vectorTemplateOfmime__content_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfmime__content(struct soap*, std::vector<mime__content> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfmime__content(struct soap*, const std::vector<mime__content> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfmime__content(struct soap*, const char*, int, const std::vector<mime__content> *, const char*);
SOAP_FMAC3 std::vector<mime__content> * SOAP_FMAC4 soap_in_std__vectorTemplateOfmime__content(struct soap*, const char*, std::vector<mime__content> *, const char*);
SOAP_FMAC1 std::vector<mime__content>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfmime__content(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<mime__content>  * soap_new_std__vectorTemplateOfmime__content(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_std__vectorTemplateOfmime__content(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOfsoap__header_DEFINED
#define SOAP_TYPE_std__vectorTemplateOfsoap__header_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfsoap__header(struct soap*, std::vector<soap__header> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfsoap__header(struct soap*, const std::vector<soap__header> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfsoap__header(struct soap*, const char*, int, const std::vector<soap__header> *, const char*);
SOAP_FMAC3 std::vector<soap__header> * SOAP_FMAC4 soap_in_std__vectorTemplateOfsoap__header(struct soap*, const char*, std::vector<soap__header> *, const char*);
SOAP_FMAC1 std::vector<soap__header>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfsoap__header(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<soap__header>  * soap_new_std__vectorTemplateOfsoap__header(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_std__vectorTemplateOfsoap__header(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOfsoap__headerfault_DEFINED
#define SOAP_TYPE_std__vectorTemplateOfsoap__headerfault_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfsoap__headerfault(struct soap*, std::vector<soap__headerfault> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfsoap__headerfault(struct soap*, const std::vector<soap__headerfault> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfsoap__headerfault(struct soap*, const char*, int, const std::vector<soap__headerfault> *, const char*);
SOAP_FMAC3 std::vector<soap__headerfault> * SOAP_FMAC4 soap_in_std__vectorTemplateOfsoap__headerfault(struct soap*, const char*, std::vector<soap__headerfault> *, const char*);
SOAP_FMAC1 std::vector<soap__headerfault>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfsoap__headerfault(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<soap__headerfault>  * soap_new_std__vectorTemplateOfsoap__headerfault(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_std__vectorTemplateOfsoap__headerfault(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOfwadl__method_DEFINED
#define SOAP_TYPE_std__vectorTemplateOfwadl__method_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfwadl__method(struct soap*, std::vector<wadl__method> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfwadl__method(struct soap*, const std::vector<wadl__method> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfwadl__method(struct soap*, const char*, int, const std::vector<wadl__method> *, const char*);
SOAP_FMAC3 std::vector<wadl__method> * SOAP_FMAC4 soap_in_std__vectorTemplateOfwadl__method(struct soap*, const char*, std::vector<wadl__method> *, const char*);
SOAP_FMAC1 std::vector<wadl__method>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfwadl__method(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<wadl__method>  * soap_new_std__vectorTemplateOfwadl__method(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_std__vectorTemplateOfwadl__method(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOfwadl__resource_USCOREtype_DEFINED
#define SOAP_TYPE_std__vectorTemplateOfwadl__resource_USCOREtype_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfwadl__resource_USCOREtype(struct soap*, std::vector<wadl__resource_USCOREtype> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfwadl__resource_USCOREtype(struct soap*, const std::vector<wadl__resource_USCOREtype> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfwadl__resource_USCOREtype(struct soap*, const char*, int, const std::vector<wadl__resource_USCOREtype> *, const char*);
SOAP_FMAC3 std::vector<wadl__resource_USCOREtype> * SOAP_FMAC4 soap_in_std__vectorTemplateOfwadl__resource_USCOREtype(struct soap*, const char*, std::vector<wadl__resource_USCOREtype> *, const char*);
SOAP_FMAC1 std::vector<wadl__resource_USCOREtype>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfwadl__resource_USCOREtype(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<wadl__resource_USCOREtype>  * soap_new_std__vectorTemplateOfwadl__resource_USCOREtype(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_std__vectorTemplateOfwadl__resource_USCOREtype(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOfwadl__resources_DEFINED
#define SOAP_TYPE_std__vectorTemplateOfwadl__resources_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfwadl__resources(struct soap*, std::vector<wadl__resources> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfwadl__resources(struct soap*, const std::vector<wadl__resources> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfwadl__resources(struct soap*, const char*, int, const std::vector<wadl__resources> *, const char*);
SOAP_FMAC3 std::vector<wadl__resources> * SOAP_FMAC4 soap_in_std__vectorTemplateOfwadl__resources(struct soap*, const char*, std::vector<wadl__resources> *, const char*);
SOAP_FMAC1 std::vector<wadl__resources>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfwadl__resources(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<wadl__resources>  * soap_new_std__vectorTemplateOfwadl__resources(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_std__vectorTemplateOfwadl__resources(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOfwadl__resource_DEFINED
#define SOAP_TYPE_std__vectorTemplateOfwadl__resource_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfwadl__resource(struct soap*, std::vector<wadl__resource> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfwadl__resource(struct soap*, const std::vector<wadl__resource> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfwadl__resource(struct soap*, const char*, int, const std::vector<wadl__resource> *, const char*);
SOAP_FMAC3 std::vector<wadl__resource> * SOAP_FMAC4 soap_in_std__vectorTemplateOfwadl__resource(struct soap*, const char*, std::vector<wadl__resource> *, const char*);
SOAP_FMAC1 std::vector<wadl__resource>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfwadl__resource(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<wadl__resource>  * soap_new_std__vectorTemplateOfwadl__resource(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_std__vectorTemplateOfwadl__resource(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTowadl__resource_USCOREtype_DEFINED
#define SOAP_TYPE_std__vectorTemplateOfPointerTowadl__resource_USCOREtype_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTowadl__resource_USCOREtype(struct soap*, std::vector<wadl__resource_USCOREtype *> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTowadl__resource_USCOREtype(struct soap*, const std::vector<wadl__resource_USCOREtype *> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTowadl__resource_USCOREtype(struct soap*, const char*, int, const std::vector<wadl__resource_USCOREtype *> *, const char*);
SOAP_FMAC3 std::vector<wadl__resource_USCOREtype *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTowadl__resource_USCOREtype(struct soap*, const char*, std::vector<wadl__resource_USCOREtype *> *, const char*);
SOAP_FMAC1 std::vector<wadl__resource_USCOREtype *>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfPointerTowadl__resource_USCOREtype(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<wadl__resource_USCOREtype *>  * soap_new_std__vectorTemplateOfPointerTowadl__resource_USCOREtype(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_std__vectorTemplateOfPointerTowadl__resource_USCOREtype(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOf__wadl__method_resource_choice_DEFINED
#define SOAP_TYPE_std__vectorTemplateOf__wadl__method_resource_choice_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf__wadl__method_resource_choice(struct soap*, std::vector<__wadl__method_resource_choice> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf__wadl__method_resource_choice(struct soap*, const std::vector<__wadl__method_resource_choice> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf__wadl__method_resource_choice(struct soap*, const char*, int, const std::vector<__wadl__method_resource_choice> *, const char*);
SOAP_FMAC3 std::vector<__wadl__method_resource_choice> * SOAP_FMAC4 soap_in_std__vectorTemplateOf__wadl__method_resource_choice(struct soap*, const char*, std::vector<__wadl__method_resource_choice> *, const char*);
SOAP_FMAC1 std::vector<__wadl__method_resource_choice>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOf__wadl__method_resource_choice(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<__wadl__method_resource_choice>  * soap_new_std__vectorTemplateOf__wadl__method_resource_choice(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_std__vectorTemplateOf__wadl__method_resource_choice(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOfwadl__response_DEFINED
#define SOAP_TYPE_std__vectorTemplateOfwadl__response_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfwadl__response(struct soap*, std::vector<wadl__response> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfwadl__response(struct soap*, const std::vector<wadl__response> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfwadl__response(struct soap*, const char*, int, const std::vector<wadl__response> *, const char*);
SOAP_FMAC3 std::vector<wadl__response> * SOAP_FMAC4 soap_in_std__vectorTemplateOfwadl__response(struct soap*, const char*, std::vector<wadl__response> *, const char*);
SOAP_FMAC1 std::vector<wadl__response>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfwadl__response(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<wadl__response>  * soap_new_std__vectorTemplateOfwadl__response(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_std__vectorTemplateOfwadl__response(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOfwadl__representation_DEFINED
#define SOAP_TYPE_std__vectorTemplateOfwadl__representation_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfwadl__representation(struct soap*, std::vector<wadl__representation> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfwadl__representation(struct soap*, const std::vector<wadl__representation> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfwadl__representation(struct soap*, const char*, int, const std::vector<wadl__representation> *, const char*);
SOAP_FMAC3 std::vector<wadl__representation> * SOAP_FMAC4 soap_in_std__vectorTemplateOfwadl__representation(struct soap*, const char*, std::vector<wadl__representation> *, const char*);
SOAP_FMAC1 std::vector<wadl__representation>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfwadl__representation(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<wadl__representation>  * soap_new_std__vectorTemplateOfwadl__representation(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_std__vectorTemplateOfwadl__representation(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOfwadl__param_DEFINED
#define SOAP_TYPE_std__vectorTemplateOfwadl__param_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfwadl__param(struct soap*, std::vector<wadl__param> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfwadl__param(struct soap*, const std::vector<wadl__param> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfwadl__param(struct soap*, const char*, int, const std::vector<wadl__param> *, const char*);
SOAP_FMAC3 std::vector<wadl__param> * SOAP_FMAC4 soap_in_std__vectorTemplateOfwadl__param(struct soap*, const char*, std::vector<wadl__param> *, const char*);
SOAP_FMAC1 std::vector<wadl__param>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfwadl__param(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<wadl__param>  * soap_new_std__vectorTemplateOfwadl__param(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_std__vectorTemplateOfwadl__param(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOfwadl__include_DEFINED
#define SOAP_TYPE_std__vectorTemplateOfwadl__include_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfwadl__include(struct soap*, std::vector<wadl__include> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfwadl__include(struct soap*, const std::vector<wadl__include> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfwadl__include(struct soap*, const char*, int, const std::vector<wadl__include> *, const char*);
SOAP_FMAC3 std::vector<wadl__include> * SOAP_FMAC4 soap_in_std__vectorTemplateOfwadl__include(struct soap*, const char*, std::vector<wadl__include> *, const char*);
SOAP_FMAC1 std::vector<wadl__include>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfwadl__include(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<wadl__include>  * soap_new_std__vectorTemplateOfwadl__include(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_std__vectorTemplateOfwadl__include(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOfwadl__option_DEFINED
#define SOAP_TYPE_std__vectorTemplateOfwadl__option_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfwadl__option(struct soap*, std::vector<wadl__option> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfwadl__option(struct soap*, const std::vector<wadl__option> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfwadl__option(struct soap*, const char*, int, const std::vector<wadl__option> *, const char*);
SOAP_FMAC3 std::vector<wadl__option> * SOAP_FMAC4 soap_in_std__vectorTemplateOfwadl__option(struct soap*, const char*, std::vector<wadl__option> *, const char*);
SOAP_FMAC1 std::vector<wadl__option>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfwadl__option(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<wadl__option>  * soap_new_std__vectorTemplateOfwadl__option(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_std__vectorTemplateOfwadl__option(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOfwadl__doc_DEFINED
#define SOAP_TYPE_std__vectorTemplateOfwadl__doc_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfwadl__doc(struct soap*, std::vector<wadl__doc> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfwadl__doc(struct soap*, const std::vector<wadl__doc> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfwadl__doc(struct soap*, const char*, int, const std::vector<wadl__doc> *, const char*);
SOAP_FMAC3 std::vector<wadl__doc> * SOAP_FMAC4 soap_in_std__vectorTemplateOfwadl__doc(struct soap*, const char*, std::vector<wadl__doc> *, const char*);
SOAP_FMAC1 std::vector<wadl__doc>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfwadl__doc(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<wadl__doc>  * soap_new_std__vectorTemplateOfwadl__doc(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_std__vectorTemplateOfwadl__doc(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOfxs__import_DEFINED
#define SOAP_TYPE_std__vectorTemplateOfxs__import_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfxs__import(struct soap*, std::vector<xs__import> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfxs__import(struct soap*, const std::vector<xs__import> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfxs__import(struct soap*, const char*, int, const std::vector<xs__import> *, const char*);
SOAP_FMAC3 std::vector<xs__import> * SOAP_FMAC4 soap_in_std__vectorTemplateOfxs__import(struct soap*, const char*, std::vector<xs__import> *, const char*);
SOAP_FMAC1 std::vector<xs__import>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfxs__import(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<xs__import>  * soap_new_std__vectorTemplateOfxs__import(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_std__vectorTemplateOfxs__import(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOfxs__redefine_DEFINED
#define SOAP_TYPE_std__vectorTemplateOfxs__redefine_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfxs__redefine(struct soap*, std::vector<xs__redefine> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfxs__redefine(struct soap*, const std::vector<xs__redefine> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfxs__redefine(struct soap*, const char*, int, const std::vector<xs__redefine> *, const char*);
SOAP_FMAC3 std::vector<xs__redefine> * SOAP_FMAC4 soap_in_std__vectorTemplateOfxs__redefine(struct soap*, const char*, std::vector<xs__redefine> *, const char*);
SOAP_FMAC1 std::vector<xs__redefine>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfxs__redefine(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<xs__redefine>  * soap_new_std__vectorTemplateOfxs__redefine(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_std__vectorTemplateOfxs__redefine(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOfxs__override_DEFINED
#define SOAP_TYPE_std__vectorTemplateOfxs__override_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfxs__override(struct soap*, std::vector<xs__override> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfxs__override(struct soap*, const std::vector<xs__override> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfxs__override(struct soap*, const char*, int, const std::vector<xs__override> *, const char*);
SOAP_FMAC3 std::vector<xs__override> * SOAP_FMAC4 soap_in_std__vectorTemplateOfxs__override(struct soap*, const char*, std::vector<xs__override> *, const char*);
SOAP_FMAC1 std::vector<xs__override>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfxs__override(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<xs__override>  * soap_new_std__vectorTemplateOfxs__override(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_std__vectorTemplateOfxs__override(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOfxs__include_DEFINED
#define SOAP_TYPE_std__vectorTemplateOfxs__include_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfxs__include(struct soap*, std::vector<xs__include> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfxs__include(struct soap*, const std::vector<xs__include> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfxs__include(struct soap*, const char*, int, const std::vector<xs__include> *, const char*);
SOAP_FMAC3 std::vector<xs__include> * SOAP_FMAC4 soap_in_std__vectorTemplateOfxs__include(struct soap*, const char*, std::vector<xs__include> *, const char*);
SOAP_FMAC1 std::vector<xs__include>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfxs__include(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<xs__include>  * soap_new_std__vectorTemplateOfxs__include(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_std__vectorTemplateOfxs__include(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOfxs__complexType_DEFINED
#define SOAP_TYPE_std__vectorTemplateOfxs__complexType_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfxs__complexType(struct soap*, std::vector<xs__complexType> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfxs__complexType(struct soap*, const std::vector<xs__complexType> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfxs__complexType(struct soap*, const char*, int, const std::vector<xs__complexType> *, const char*);
SOAP_FMAC3 std::vector<xs__complexType> * SOAP_FMAC4 soap_in_std__vectorTemplateOfxs__complexType(struct soap*, const char*, std::vector<xs__complexType> *, const char*);
SOAP_FMAC1 std::vector<xs__complexType>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfxs__complexType(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<xs__complexType>  * soap_new_std__vectorTemplateOfxs__complexType(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_std__vectorTemplateOfxs__complexType(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOfxs__group_DEFINED
#define SOAP_TYPE_std__vectorTemplateOfxs__group_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfxs__group(struct soap*, std::vector<xs__group> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfxs__group(struct soap*, const std::vector<xs__group> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfxs__group(struct soap*, const char*, int, const std::vector<xs__group> *, const char*);
SOAP_FMAC3 std::vector<xs__group> * SOAP_FMAC4 soap_in_std__vectorTemplateOfxs__group(struct soap*, const char*, std::vector<xs__group> *, const char*);
SOAP_FMAC1 std::vector<xs__group>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfxs__group(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<xs__group>  * soap_new_std__vectorTemplateOfxs__group(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_std__vectorTemplateOfxs__group(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOfxs__simpleType_DEFINED
#define SOAP_TYPE_std__vectorTemplateOfxs__simpleType_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfxs__simpleType(struct soap*, std::vector<xs__simpleType> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfxs__simpleType(struct soap*, const std::vector<xs__simpleType> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfxs__simpleType(struct soap*, const char*, int, const std::vector<xs__simpleType> *, const char*);
SOAP_FMAC3 std::vector<xs__simpleType> * SOAP_FMAC4 soap_in_std__vectorTemplateOfxs__simpleType(struct soap*, const char*, std::vector<xs__simpleType> *, const char*);
SOAP_FMAC1 std::vector<xs__simpleType>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfxs__simpleType(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<xs__simpleType>  * soap_new_std__vectorTemplateOfxs__simpleType(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_std__vectorTemplateOfxs__simpleType(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOfxs__pattern_DEFINED
#define SOAP_TYPE_std__vectorTemplateOfxs__pattern_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfxs__pattern(struct soap*, std::vector<xs__pattern> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfxs__pattern(struct soap*, const std::vector<xs__pattern> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfxs__pattern(struct soap*, const char*, int, const std::vector<xs__pattern> *, const char*);
SOAP_FMAC3 std::vector<xs__pattern> * SOAP_FMAC4 soap_in_std__vectorTemplateOfxs__pattern(struct soap*, const char*, std::vector<xs__pattern> *, const char*);
SOAP_FMAC1 std::vector<xs__pattern>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfxs__pattern(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<xs__pattern>  * soap_new_std__vectorTemplateOfxs__pattern(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_std__vectorTemplateOfxs__pattern(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOfxs__enumeration_DEFINED
#define SOAP_TYPE_std__vectorTemplateOfxs__enumeration_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfxs__enumeration(struct soap*, std::vector<xs__enumeration> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfxs__enumeration(struct soap*, const std::vector<xs__enumeration> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfxs__enumeration(struct soap*, const char*, int, const std::vector<xs__enumeration> *, const char*);
SOAP_FMAC3 std::vector<xs__enumeration> * SOAP_FMAC4 soap_in_std__vectorTemplateOfxs__enumeration(struct soap*, const char*, std::vector<xs__enumeration> *, const char*);
SOAP_FMAC1 std::vector<xs__enumeration>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfxs__enumeration(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<xs__enumeration>  * soap_new_std__vectorTemplateOfxs__enumeration(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_std__vectorTemplateOfxs__enumeration(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOfxs__assert_DEFINED
#define SOAP_TYPE_std__vectorTemplateOfxs__assert_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfxs__assert(struct soap*, std::vector<xs__assert> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfxs__assert(struct soap*, const std::vector<xs__assert> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfxs__assert(struct soap*, const char*, int, const std::vector<xs__assert> *, const char*);
SOAP_FMAC3 std::vector<xs__assert> * SOAP_FMAC4 soap_in_std__vectorTemplateOfxs__assert(struct soap*, const char*, std::vector<xs__assert> *, const char*);
SOAP_FMAC1 std::vector<xs__assert>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfxs__assert(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<xs__assert>  * soap_new_std__vectorTemplateOfxs__assert(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_std__vectorTemplateOfxs__assert(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOfxsd__QName_DEFINED
#define SOAP_TYPE_std__vectorTemplateOfxsd__QName_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfxsd__QName(struct soap*, std::vector<char *> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfxsd__QName(struct soap*, const std::vector<char *> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfxsd__QName(struct soap*, const char*, int, const std::vector<char *> *, const char*);
SOAP_FMAC3 std::vector<char *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfxsd__QName(struct soap*, const char*, std::vector<char *> *, const char*);
SOAP_FMAC1 std::vector<char *>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfxsd__QName(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<char *>  * soap_new_std__vectorTemplateOfxsd__QName(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_std__vectorTemplateOfxsd__QName(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOfPointerToxs__complexType_DEFINED
#define SOAP_TYPE_std__vectorTemplateOfPointerToxs__complexType_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerToxs__complexType(struct soap*, std::vector<xs__complexType *> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerToxs__complexType(struct soap*, const std::vector<xs__complexType *> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerToxs__complexType(struct soap*, const char*, int, const std::vector<xs__complexType *> *, const char*);
SOAP_FMAC3 std::vector<xs__complexType *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerToxs__complexType(struct soap*, const char*, std::vector<xs__complexType *> *, const char*);
SOAP_FMAC1 std::vector<xs__complexType *>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfPointerToxs__complexType(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<xs__complexType *>  * soap_new_std__vectorTemplateOfPointerToxs__complexType(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_std__vectorTemplateOfPointerToxs__complexType(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOfxs__attributeGroup_DEFINED
#define SOAP_TYPE_std__vectorTemplateOfxs__attributeGroup_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfxs__attributeGroup(struct soap*, std::vector<xs__attributeGroup> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfxs__attributeGroup(struct soap*, const std::vector<xs__attributeGroup> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfxs__attributeGroup(struct soap*, const char*, int, const std::vector<xs__attributeGroup> *, const char*);
SOAP_FMAC3 std::vector<xs__attributeGroup> * SOAP_FMAC4 soap_in_std__vectorTemplateOfxs__attributeGroup(struct soap*, const char*, std::vector<xs__attributeGroup> *, const char*);
SOAP_FMAC1 std::vector<xs__attributeGroup>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfxs__attributeGroup(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<xs__attributeGroup>  * soap_new_std__vectorTemplateOfxs__attributeGroup(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_std__vectorTemplateOfxs__attributeGroup(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOfxs__attribute_DEFINED
#define SOAP_TYPE_std__vectorTemplateOfxs__attribute_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfxs__attribute(struct soap*, std::vector<xs__attribute> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfxs__attribute(struct soap*, const std::vector<xs__attribute> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfxs__attribute(struct soap*, const char*, int, const std::vector<xs__attribute> *, const char*);
SOAP_FMAC3 std::vector<xs__attribute> * SOAP_FMAC4 soap_in_std__vectorTemplateOfxs__attribute(struct soap*, const char*, std::vector<xs__attribute> *, const char*);
SOAP_FMAC1 std::vector<xs__attribute>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfxs__attribute(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<xs__attribute>  * soap_new_std__vectorTemplateOfxs__attribute(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_std__vectorTemplateOfxs__attribute(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOfxs__contents_DEFINED
#define SOAP_TYPE_std__vectorTemplateOfxs__contents_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfxs__contents(struct soap*, std::vector<xs__contents> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfxs__contents(struct soap*, const std::vector<xs__contents> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfxs__contents(struct soap*, const char*, int, const std::vector<xs__contents> *, const char*);
SOAP_FMAC3 std::vector<xs__contents> * SOAP_FMAC4 soap_in_std__vectorTemplateOfxs__contents(struct soap*, const char*, std::vector<xs__contents> *, const char*);
SOAP_FMAC1 std::vector<xs__contents>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfxs__contents(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<xs__contents>  * soap_new_std__vectorTemplateOfxs__contents(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_std__vectorTemplateOfxs__contents(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOfxs__element_DEFINED
#define SOAP_TYPE_std__vectorTemplateOfxs__element_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfxs__element(struct soap*, std::vector<xs__element> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfxs__element(struct soap*, const std::vector<xs__element> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfxs__element(struct soap*, const char*, int, const std::vector<xs__element> *, const char*);
SOAP_FMAC3 std::vector<xs__element> * SOAP_FMAC4 soap_in_std__vectorTemplateOfxs__element(struct soap*, const char*, std::vector<xs__element> *, const char*);
SOAP_FMAC1 std::vector<xs__element>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfxs__element(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<xs__element>  * soap_new_std__vectorTemplateOfxs__element(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_std__vectorTemplateOfxs__element(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOfPointerToxs__element_DEFINED
#define SOAP_TYPE_std__vectorTemplateOfPointerToxs__element_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerToxs__element(struct soap*, std::vector<xs__element *> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerToxs__element(struct soap*, const std::vector<xs__element *> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerToxs__element(struct soap*, const char*, int, const std::vector<xs__element *> *, const char*);
SOAP_FMAC3 std::vector<xs__element *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerToxs__element(struct soap*, const char*, std::vector<xs__element *> *, const char*);
SOAP_FMAC1 std::vector<xs__element *>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfPointerToxs__element(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<xs__element *>  * soap_new_std__vectorTemplateOfPointerToxs__element(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_std__vectorTemplateOfPointerToxs__element(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOfxs__alternative_DEFINED
#define SOAP_TYPE_std__vectorTemplateOfxs__alternative_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfxs__alternative(struct soap*, std::vector<xs__alternative> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfxs__alternative(struct soap*, const std::vector<xs__alternative> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfxs__alternative(struct soap*, const char*, int, const std::vector<xs__alternative> *, const char*);
SOAP_FMAC3 std::vector<xs__alternative> * SOAP_FMAC4 soap_in_std__vectorTemplateOfxs__alternative(struct soap*, const char*, std::vector<xs__alternative> *, const char*);
SOAP_FMAC1 std::vector<xs__alternative>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfxs__alternative(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<xs__alternative>  * soap_new_std__vectorTemplateOfxs__alternative(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_std__vectorTemplateOfxs__alternative(soap, n, NULL, NULL, NULL);
}
#endif

#ifndef SOAP_TYPE_std__vectorTemplateOfstring_DEFINED
#define SOAP_TYPE_std__vectorTemplateOfstring_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfstring(struct soap*, std::vector<char *> *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfstring(struct soap*, const std::vector<char *> *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfstring(struct soap*, const char*, int, const std::vector<char *> *, const char*);
SOAP_FMAC3 std::vector<char *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfstring(struct soap*, const char*, std::vector<char *> *, const char*);
SOAP_FMAC1 std::vector<char *>  * SOAP_FMAC2 wsdl_instantiate_std__vectorTemplateOfstring(struct soap*, int, const char*, const char*, size_t*);

inline std::vector<char *>  * soap_new_std__vectorTemplateOfstring(struct soap *soap, int n = -1)
{
	return wsdl_instantiate_std__vectorTemplateOfstring(soap, n, NULL, NULL, NULL);
}
#endif

#endif

/* End of wsdlH.h */
