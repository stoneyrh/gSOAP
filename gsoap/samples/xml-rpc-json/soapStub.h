/* soapStub.h
   Generated by gSOAP 2.8.26 from xml-rpc.h

gSOAP XML Web services tools
Copyright (C) 2000-2015, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#include "xml-rpc-iters.h"      // deferred for inclusion by C++ compiler

#ifndef soapStub_H
#define soapStub_H
#include "stdsoap2.h"
#if GSOAP_VERSION != 20826
# error "GSOAP VERSION 20826 MISMATCH IN GENERATED CODE VERSUS LIBRARY CODE: PLEASE REINSTALL PACKAGE"
#endif


/******************************************************************************\
 *                                                                            *
 * Enumerations                                                               *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Classes, Structs, and Unions                                               *
 *                                                                            *
\******************************************************************************/

struct _base64;	/* xml-rpc.h:105 */
struct _struct;	/* xml-rpc.h:124 */
struct data;	/* xml-rpc.h:148 */
struct _array;	/* xml-rpc.h:157 */
struct value;	/* xml-rpc.h:41 */
struct member;	/* xml-rpc.h:142 */
struct params;	/* xml-rpc.h:277 */
struct param;	/* xml-rpc.h:294 */
struct methodResponse;	/* xml-rpc.h:308 */
struct methodCall;	/* xml-rpc.h:329 */
struct fault;	/* xml-rpc.h:323 */

/* xml-rpc.h:105 */
#ifndef SOAP_TYPE__base64
#define SOAP_TYPE__base64 (29)
/* base64Binary schema type: */
struct _base64
{
public:
	_base64();	/* transient (not serialized) */
	_base64(struct soap *_param_1);	/* transient (not serialized) */
	_base64(struct soap *_param_2, int _param_3, unsigned char *_param_4);	/* transient (not serialized) */
	int size() const;	/* transient (not serialized) */
	unsigned char *ptr();	/* transient (not serialized) */
	void size(int _param_5);	/* transient (not serialized) */
	void ptr(unsigned char *_param_6);	/* transient (not serialized) */
	unsigned char *__ptr;
	int __size;
public:
	int soap_type() const { return 29; } /* = unique type id SOAP_TYPE__base64 */
	virtual ~_base64() { }
	friend _base64 *soap_instantiate__base64(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xml-rpc.h:124 */
#ifndef SOAP_TYPE__struct
#define SOAP_TYPE__struct (46)
/* struct complex type: */
struct _struct
{
public:
	typedef _struct_iterator iterator;	/* transient (not serialized) */
	typedef _struct_const_iterator const_iterator;	/* transient (not serialized) */
	_struct();	/* transient (not serialized) */
	_struct(struct soap *_param_7);	/* transient (not serialized) */
	_struct(struct soap *_param_8, int _param_9);	/* transient (not serialized) */
	bool empty() const;	/* transient (not serialized) */
	int size() const;	/* transient (not serialized) */
	struct value &operator[](const char *_param_10);	/* transient (not serialized) */
	struct value &operator[](const wchar_t *_param_11);	/* transient (not serialized) */
	_struct_iterator begin() const;	/* transient (not serialized) */
	_struct_iterator end() const;	/* transient (not serialized) */
	int __size;	/* sequence of elements <member> of XSD type member */
	struct member *member;
	struct soap *soap;	/* transient (not serialized) */
public:
	int soap_type() const { return 46; } /* = unique type id SOAP_TYPE__struct */
	virtual ~_struct() { }
	friend _struct *soap_instantiate__struct(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xml-rpc.h:148 */
#ifndef SOAP_TYPE_data
#define SOAP_TYPE_data (63)
/* data complex type: */
struct data
{
public:
	int __size;	/* sequence of elements <value> of XSD type value */
	struct value *value;
public:
	int soap_type() const { return 63; } /* = unique type id SOAP_TYPE_data */
	         data();
	virtual ~data() { }
	friend data *soap_instantiate_data(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xml-rpc.h:157 */
#ifndef SOAP_TYPE__array
#define SOAP_TYPE__array (64)
/* array complex type: */
struct _array
{
public:
	typedef _array_iterator iterator;	/* transient (not serialized) */
	typedef _array_const_iterator const_iterator;	/* transient (not serialized) */
	_array();	/* transient (not serialized) */
	_array(struct soap *_param_12);	/* transient (not serialized) */
	_array(struct soap *_param_13, int _param_14);	/* transient (not serialized) */
	bool empty() const;	/* transient (not serialized) */
	int size() const;	/* transient (not serialized) */
	void size(int n);	/* transient (not serialized) */
	struct value &operator[](int _param_15);	/* transient (not serialized) */
	_array_iterator begin() const;	/* transient (not serialized) */
	_array_iterator end() const;	/* transient (not serialized) */
	struct data data;	/* required element of XSD type data */
	struct soap *soap;	/* transient (not serialized) */
public:
	int soap_type() const { return 64; } /* = unique type id SOAP_TYPE__array */
	virtual ~_array() { }
	friend _array *soap_instantiate__array(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xml-rpc.h:41 */
#ifndef SOAP_TYPE_value
#define SOAP_TYPE_value (7)
/* value complex type: */
struct value
{
public:
	typedef value_iterator iterator;	/* transient (not serialized) */
	typedef value_const_iterator const_iterator;	/* transient (not serialized) */
	value();	/* transient (not serialized) */
	value(struct soap *_param_16);	/* transient (not serialized) */
	value(struct soap *_param_17, struct _array &_param_18);	/* transient (not serialized) */
	value(struct soap *_param_19, struct _base64 &_param_20);	/* transient (not serialized) */
	value(struct soap *_param_21, bool _param_22);
	value(struct soap *_param_23, char *_param_24);	/* transient (not serialized) */
	value(struct soap *_param_25, double _param_26);	/* transient (not serialized) */
	value(struct soap *_param_27, int _param_28);	/* transient (not serialized) */
	value(struct soap *_param_29, LONG64 _param_30);	/* transient (not serialized) */
	value(struct soap *_param_31, time_t _param_32);	/* transient (not serialized) */
	value(struct soap *_param_33, struct _struct &_param_34);	/* transient (not serialized) */
	operator bool() const;	/* transient (not serialized) */
	operator struct _array &();	/* transient (not serialized) */
	operator const struct _array &() const;	/* transient (not serialized) */
	operator struct _base64 &();	/* transient (not serialized) */
	operator const struct _base64 &() const;	/* transient (not serialized) */
	operator char *() const;	/* transient (not serialized) */
	operator std::string() const;	/* transient (not serialized) */
	operator wchar_t *() const;	/* transient (not serialized) */
	operator std::wstring() const;	/* transient (not serialized) */
	operator double() const;	/* transient (not serialized) */
	operator int() const;	/* transient (not serialized) */
	operator LONG64() const;	/* transient (not serialized) */
	operator time_t() const;	/* transient (not serialized) */
	operator struct _struct &();	/* transient (not serialized) */
	operator const struct _struct &() const;	/* transient (not serialized) */
	struct value &operator[](int _param_35);	/* transient (not serialized) */
	struct value &operator[](const char *_param_36);	/* transient (not serialized) */
	struct value &operator[](const std::string &_param_37);	/* transient (not serialized) */
	struct value &operator[](const wchar_t *_param_38);	/* transient (not serialized) */
	struct value &operator[](const std::wstring &_param_39);	/* transient (not serialized) */
	struct _array &operator=(const struct _array &_param_40);	/* transient (not serialized) */
	struct _base64 &operator=(const struct _base64 &_param_41);	/* transient (not serialized) */
	bool operator=(bool _param_42);
	const char *operator=(const char *_param_43);	/* transient (not serialized) */
	char *operator=(char *_param_44);	/* transient (not serialized) */
	char *operator=(const std::string &_param_45);	/* transient (not serialized) */
	const char *operator=(const wchar_t *_param_46);	/* transient (not serialized) */
	char *operator=(wchar_t *_param_47);	/* transient (not serialized) */
	char *operator=(const std::wstring &_param_48);	/* transient (not serialized) */
	double operator=(double _param_49);	/* transient (not serialized) */
	int operator=(int _param_50);	/* transient (not serialized) */
	LONG64 operator=(LONG64 _param_51);	/* transient (not serialized) */
	time_t operator=(time_t _param_52);	/* transient (not serialized) */
	struct _struct &operator=(const struct _struct &_param_53);	/* transient (not serialized) */
	void size(int _param_54);	/* transient (not serialized) */
	int size() const;	/* transient (not serialized) */
	bool empty() const;	/* transient (not serialized) */
	bool is_array() const;	/* transient (not serialized) */
	bool is_base64() const;	/* transient (not serialized) */
	bool is_bool() const;	/* transient (not serialized) */
	bool is_dateTime() const;	/* transient (not serialized) */
	bool is_double() const;	/* transient (not serialized) */
	bool is_false() const;	/* transient (not serialized) */
	bool is_int() const;	/* transient (not serialized) */
	bool is_null() const;	/* transient (not serialized) */
	bool is_string() const;	/* transient (not serialized) */
	bool is_struct() const;	/* transient (not serialized) */
	bool is_true() const;	/* transient (not serialized) */
	value_iterator begin();	/* transient (not serialized) */
	value_iterator end();	/* transient (not serialized) */
	int __type;	/* any type of element <ref> (defined below)
	   WARNING: do not create a cyclic data structure graph throught this element unless SOAP encoding or SOAP_XML_GRAPH are used for id-ref serialization */
	void *ref;	/* transient (not serialized) */
	char *__any;
	struct soap *soap;	/* transient (not serialized) */
public:
	int soap_type() const { return 7; } /* = unique type id SOAP_TYPE_value */
	virtual ~value() { }
	friend value *soap_instantiate_value(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xml-rpc.h:142 */
#ifndef SOAP_TYPE_member
#define SOAP_TYPE_member (61)
/* member complex type: */
struct member
{
public:
	char *name;	/* optional element of XSD type xsd:string */
	struct value value;	/* required element of XSD type value */
public:
	int soap_type() const { return 61; } /* = unique type id SOAP_TYPE_member */
	         member();
	virtual ~member() { }
	friend member *soap_instantiate_member(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xml-rpc.h:277 */
#ifndef SOAP_TYPE_params
#define SOAP_TYPE_params (151)
/* params complex type: */
struct params
{
public:
	typedef params_iterator iterator;	/* transient (not serialized) */
	typedef params_const_iterator const_iterator;	/* transient (not serialized) */
	params();	/* transient (not serialized) */
	params(struct soap *_param_55);	/* transient (not serialized) */
	params(struct soap *_param_56, int _param_57);	/* transient (not serialized) */
	bool empty() const;	/* transient (not serialized) */
	int size() const;	/* transient (not serialized) */
	struct value &operator[](int _param_58);	/* transient (not serialized) */
	params_iterator begin() const;	/* transient (not serialized) */
	params_iterator end() const;	/* transient (not serialized) */
	int __size;	/* sequence of elements <param> of XSD type param */
	struct param *param;
	struct soap *soap;	/* transient (not serialized) */
public:
	int soap_type() const { return 151; } /* = unique type id SOAP_TYPE_params */
	virtual ~params() { }
	friend params *soap_instantiate_params(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xml-rpc.h:294 */
#ifndef SOAP_TYPE_param
#define SOAP_TYPE_param (160)
/* param complex type: */
struct param
{
public:
	struct value value;	/* required element of XSD type value */
public:
	int soap_type() const { return 160; } /* = unique type id SOAP_TYPE_param */
	         param();
	virtual ~param() { }
	friend param *soap_instantiate_param(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xml-rpc.h:308 */
#ifndef SOAP_TYPE_methodResponse
#define SOAP_TYPE_methodResponse (162)
/* methodResponse complex type: */
struct methodResponse
{
public:
	methodResponse();	/* transient (not serialized) */
	methodResponse(struct soap *_param_59);	/* transient (not serialized) */
	struct value &operator[](int _param_60);	/* transient (not serialized) */
	struct value &get_fault(void);	/* transient (not serialized) */
	struct value &set_fault(const char *_param_62);	/* transient (not serialized) */
	struct value &set_fault(struct value &_param_63);	/* transient (not serialized) */
	int recv();	/* transient (not serialized) */
	int send();	/* transient (not serialized) */
	struct params *params;	/* optional element of XSD type params */
	struct fault *fault;	/* optional element of XSD type fault */
	struct soap *soap;	/* transient (not serialized) */
public:
	int soap_type() const { return 162; } /* = unique type id SOAP_TYPE_methodResponse */
	virtual ~methodResponse() { }
	friend methodResponse *soap_instantiate_methodResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xml-rpc.h:329 */
#ifndef SOAP_TYPE_methodCall
#define SOAP_TYPE_methodCall (175)
/* methodCall complex type: */
struct methodCall
{
private:
	char *methodEndpoint;	/* not serialized */
	struct methodResponse *methodResponse;	/* not serialized */
public:
	methodCall();	/* transient (not serialized) */
	methodCall(struct soap *_param_64);	/* transient (not serialized) */
	methodCall(struct soap *_param_65, const char *endpoint, const char *methodname);	/* transient (not serialized) */
	struct value &operator[](int _param_66);	/* transient (not serialized) */
	struct params &operator()();	/* transient (not serialized) */
	struct params &operator()(const struct params &_param_67);	/* transient (not serialized) */
	struct params &response();	/* transient (not serialized) */
	struct value &fault();	/* transient (not serialized) */
	const char *name() const;	/* transient (not serialized) */
	int error() const;	/* transient (not serialized) */
	int recv();	/* transient (not serialized) */
	int send();	/* transient (not serialized) */
	char *methodName;	/* optional element of XSD type xsd:string */
	struct params params;	/* required element of XSD type params */
	struct soap *soap;	/* transient (not serialized) */
public:
	int soap_type() const { return 175; } /* = unique type id SOAP_TYPE_methodCall */
	virtual ~methodCall() { }
	friend methodCall *soap_instantiate_methodCall(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xml-rpc.h:323 */
#ifndef SOAP_TYPE_fault
#define SOAP_TYPE_fault (173)
/* fault complex type: */
struct fault
{
public:
	struct value value;	/* required element of XSD type value */
public:
	int soap_type() const { return 173; } /* = unique type id SOAP_TYPE_fault */
	         fault();
	virtual ~fault() { }
	friend fault *soap_instantiate_fault(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xml-rpc.h:456 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (223)
/* SOAP Header: */
struct SOAP_ENV__Header
{
public:
	int soap_type() const { return 223; } /* = unique type id SOAP_TYPE_SOAP_ENV__Header */
	         SOAP_ENV__Header();
	virtual ~SOAP_ENV__Header() { }
	friend SOAP_ENV__Header *soap_instantiate_SOAP_ENV__Header(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* xml-rpc.h:456 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (224)
/* Type SOAP_ENV__Code is a recursive data type (in)directly referencing itself through its (base) class members */
/* SOAP Fault Code: */
struct SOAP_ENV__Code
{
public:
	char *SOAP_ENV__Value;	/* optional element of XSD type xsd:QName */
	struct SOAP_ENV__Code *SOAP_ENV__Subcode;	/* optional element of XSD type SOAP-ENV:Code */
public:
	int soap_type() const { return 224; } /* = unique type id SOAP_TYPE_SOAP_ENV__Code */
	         SOAP_ENV__Code();
	virtual ~SOAP_ENV__Code() { }
	friend SOAP_ENV__Code *soap_instantiate_SOAP_ENV__Code(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* xml-rpc.h:456 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (226)
/* SOAP-ENV:Detail complex type: */
struct SOAP_ENV__Detail
{
public:
	char *__any;
	int __type;	/* any type of element <fault> (defined below)
	   WARNING: do not create a cyclic data structure graph throught this element unless SOAP encoding or SOAP_XML_GRAPH are used for id-ref serialization */
	void *fault;	/* transient (not serialized) */
public:
	int soap_type() const { return 226; } /* = unique type id SOAP_TYPE_SOAP_ENV__Detail */
	         SOAP_ENV__Detail();
	virtual ~SOAP_ENV__Detail() { }
	friend SOAP_ENV__Detail *soap_instantiate_SOAP_ENV__Detail(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* xml-rpc.h:456 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (227)
/* SOAP-ENV:Reason complex type: */
struct SOAP_ENV__Reason
{
public:
	char *SOAP_ENV__Text;	/* optional element of XSD type xsd:string */
public:
	int soap_type() const { return 227; } /* = unique type id SOAP_TYPE_SOAP_ENV__Reason */
	         SOAP_ENV__Reason();
	virtual ~SOAP_ENV__Reason() { }
	friend SOAP_ENV__Reason *soap_instantiate_SOAP_ENV__Reason(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* xml-rpc.h:456 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (228)
/* SOAP Fault: */
struct SOAP_ENV__Fault
{
public:
	char *faultcode;	/* optional element of XSD type xsd:QName */
	char *faultstring;	/* optional element of XSD type xsd:string */
	char *faultactor;	/* optional element of XSD type xsd:string */
	struct SOAP_ENV__Detail *detail;	/* optional element of XSD type SOAP-ENV:Detail */
	struct SOAP_ENV__Code *SOAP_ENV__Code;	/* optional element of XSD type SOAP-ENV:Code */
	struct SOAP_ENV__Reason *SOAP_ENV__Reason;	/* optional element of XSD type SOAP-ENV:Reason */
	char *SOAP_ENV__Node;	/* optional element of XSD type xsd:string */
	char *SOAP_ENV__Role;	/* optional element of XSD type xsd:string */
	struct SOAP_ENV__Detail *SOAP_ENV__Detail;	/* optional element of XSD type SOAP-ENV:Detail */
public:
	int soap_type() const { return 228; } /* = unique type id SOAP_TYPE_SOAP_ENV__Fault */
	         SOAP_ENV__Fault();
	virtual ~SOAP_ENV__Fault() { }
	friend SOAP_ENV__Fault *soap_instantiate_SOAP_ENV__Fault(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/


/* xml-rpc.h:41 */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
typedef char *_QName;
#endif

/* xml-rpc.h:41 */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (6)
typedef char *_XML;
#endif

/* xml-rpc.h:86 */
#ifndef SOAP_TYPE__boolean
#define SOAP_TYPE__boolean (21)
typedef char _boolean;
#endif

/* xml-rpc.h:89 */
#ifndef SOAP_TYPE__double
#define SOAP_TYPE__double (23)
typedef double _double;
#endif

/* xml-rpc.h:92 */
#ifndef SOAP_TYPE__i4
#define SOAP_TYPE__i4 (24)
typedef int _i4;
#endif

/* xml-rpc.h:95 */
#ifndef SOAP_TYPE__int
#define SOAP_TYPE__int (26)
typedef LONG64 _int;
#endif

/* xml-rpc.h:98 */
#ifndef SOAP_TYPE__string
#define SOAP_TYPE__string (27)
typedef char *_string;
#endif

/* xml-rpc.h:101 */
#ifndef SOAP_TYPE__dateTime_DOTiso8601
#define SOAP_TYPE__dateTime_DOTiso8601 (28)
typedef char *_dateTime_DOTiso8601;
#endif

/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


/* xml-rpc.h:41 */
extern struct value *new_value(struct soap *soap);

/* xml-rpc.h:44 */
extern struct value *init_value(struct soap *soap, struct value *v);

/* xml-rpc.h:374 */
extern char *bool_of(struct value *v);

/* xml-rpc.h:377 */
extern LONG64 *int_of(struct value *v);

/* xml-rpc.h:380 */
extern double *double_of(struct value *v);

/* xml-rpc.h:383 */
extern const char **string_of(struct value *v);

/* xml-rpc.h:386 */
extern const char **dateTime_of(struct value *v);

/* xml-rpc.h:389 */
extern struct _base64 *base64_of(struct value *v);

/* xml-rpc.h:392 */
extern struct value *value_at(struct value *v, const char *s);

/* xml-rpc.h:395 */
extern struct value *value_atw(struct value *v, const wchar_t *s);

/* xml-rpc.h:398 */
extern struct member *nth_member(struct value *v, int n);

/* xml-rpc.h:401 */
extern struct value *nth_value(struct value *v, int n);

/* xml-rpc.h:404 */
extern char is_null(struct value *v);

/* xml-rpc.h:407 */
extern char is_int(struct value *v);

/* xml-rpc.h:410 */
extern char is_double(struct value *v);

/* xml-rpc.h:413 */
extern char is_string(struct value *v);

/* xml-rpc.h:416 */
extern char is_bool(struct value *v);

/* xml-rpc.h:419 */
extern char is_true(struct value *v);

/* xml-rpc.h:422 */
extern char is_false(struct value *v);

/* xml-rpc.h:425 */
extern char is_array(struct value *v);

/* xml-rpc.h:428 */
extern char is_struct(struct value *v);

/* xml-rpc.h:431 */
extern char is_dateTime(struct value *v);

/* xml-rpc.h:434 */
extern char is_base64(struct value *v);

/* xml-rpc.h:437 */
extern int has_size(struct value *v);

/* xml-rpc.h:446 */
extern struct params *new_params(struct soap *soap);

/* xml-rpc.h:449 */
extern struct params *init_params(struct soap *soap, struct params *p);

/* xml-rpc.h:452 */
extern struct value *nth_param(struct params *p, int n);

/* xml-rpc.h:455 */
extern int call_method(struct soap *soap, const char *endpoint, const char *methodName, struct params *p, struct methodResponse *r);

#endif

/* End of soapStub.h */
