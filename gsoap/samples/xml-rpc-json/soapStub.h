/* soapStub.h
   Generated by gSOAP 2.8.29 for xml-rpc.h

gSOAP XML Web services tools
Copyright (C) 2000-2016, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#include "xml-rpc-iters.h"      // deferred for inclusion by C++ compiler

#ifndef soapStub_H
#define soapStub_H
#include "stdsoap2.h"
#if GSOAP_VERSION != 20829
# error "GSOAP VERSION 20829 MISMATCH IN GENERATED CODE VERSUS LIBRARY CODE: PLEASE REINSTALL PACKAGE"
#endif


/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Classes, Structs and Unions                                                *
 *                                                                            *
\******************************************************************************/

struct _base64;	/* xml-rpc.h:105 */
struct _struct;	/* xml-rpc.h:124 */
struct data;	/* xml-rpc.h:149 */
struct _array;	/* xml-rpc.h:158 */
struct value;	/* xml-rpc.h:41 */
struct member;	/* xml-rpc.h:143 */
struct params;	/* xml-rpc.h:287 */
struct param;	/* xml-rpc.h:304 */
struct methodResponse;	/* xml-rpc.h:318 */
struct methodCall;	/* xml-rpc.h:339 */
struct fault;	/* xml-rpc.h:333 */

/* xml-rpc.h:105 */
#ifndef SOAP_TYPE__base64
#define SOAP_TYPE__base64 (29)
/* base64Binary XSD type: */
struct _base64 {
      public:
        _base64();
        _base64(struct soap *_param_1);
        _base64(struct soap *_param_2, int _param_3, unsigned char *_param_4);
        int size() const;
        unsigned char *ptr();
        void size(int _param_5);
        void ptr(unsigned char *_param_6);
        unsigned char *__ptr;
        int __size;
      public:
        /** Return unique type id SOAP_TYPE__base64 */
        int soap_type() const { return SOAP_TYPE__base64; }
        /** Friend allocator used by soap_new__base64(struct soap*, int) */
        friend SOAP_FMAC1 _base64 * SOAP_FMAC2 soap_instantiate__base64(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xml-rpc.h:124 */
#ifndef SOAP_TYPE__struct
#define SOAP_TYPE__struct (46)
/* complex XSD type 'struct': */
struct _struct {
      public:
        typedef _struct_iterator iterator;
        typedef _struct_const_iterator const_iterator;
        _struct();
        _struct(struct soap *_param_7);
        _struct(struct soap *_param_8, int _param_9);
        bool empty() const;
        int size() const;
        struct value &operator[](int _param_10);
        struct value &operator[](const char *_param_11);
        struct value &operator[](const wchar_t *_param_12);
        _struct_iterator begin() const;
        _struct_iterator end() const;
        /** Sequence of elements 'member' of XSD type 'member' stored in dynamic array member of length __size */
        int __size;
        struct member *member;
        /** Context that manages this object */
        struct soap *soap;
      public:
        /** Return unique type id SOAP_TYPE__struct */
        int soap_type() const { return SOAP_TYPE__struct; }
        /** Friend allocator used by soap_new__struct(struct soap*, int) */
        friend SOAP_FMAC1 _struct * SOAP_FMAC2 soap_instantiate__struct(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xml-rpc.h:149 */
#ifndef SOAP_TYPE_data
#define SOAP_TYPE_data (64)
/* complex XSD type 'data': */
struct data {
      public:
        /** Sequence of elements 'value' of XSD type 'value' stored in dynamic array value of length __size */
        int __size;
        struct value *value;
      public:
        /** Return unique type id SOAP_TYPE_data */
        int soap_type() const { return SOAP_TYPE_data; }
        /** Constructor with member initializations */
        data()
        {
          __size = 0;
          value = NULL;
        }
        /** Friend allocator used by soap_new_data(struct soap*, int) */
        friend SOAP_FMAC1 data * SOAP_FMAC2 soap_instantiate_data(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xml-rpc.h:158 */
#ifndef SOAP_TYPE__array
#define SOAP_TYPE__array (65)
/* complex XSD type 'array': */
struct _array {
      public:
        typedef _array_iterator iterator;
        typedef _array_const_iterator const_iterator;
        _array();
        _array(struct soap *_param_13);
        _array(struct soap *_param_14, int _param_15);
        bool empty() const;
        int size() const;
        void size(int _param_16);
        struct value &operator[](int _param_17);
        _array_iterator begin() const;
        _array_iterator end() const;
        /** Required element 'data' of XSD type 'data' */
        struct data data;
        /** Context that manages this object */
        struct soap *soap;
      public:
        /** Return unique type id SOAP_TYPE__array */
        int soap_type() const { return SOAP_TYPE__array; }
        /** Friend allocator used by soap_new__array(struct soap*, int) */
        friend SOAP_FMAC1 _array * SOAP_FMAC2 soap_instantiate__array(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xml-rpc.h:41 */
#ifndef SOAP_TYPE_value
#define SOAP_TYPE_value (7)
/* complex XSD type 'value': */
struct value {
      public:
        typedef value_iterator iterator;
        typedef value_const_iterator const_iterator;
        value();
        value(struct soap *_param_18);
        value(struct soap *_param_19, bool _param_20);
        value(struct soap *_param_21, int _param_22);
        value(struct soap *_param_23, LONG64 _param_24);
        value(struct soap *_param_25, double _param_26);
        value(struct soap *_param_27, const char *_param_28);
        value(struct soap *_param_29, const std::string &_param_30);
        value(struct soap *_param_31, const wchar_t *_param_32);
        value(struct soap *_param_33, const std::wstring &_param_34);
        value(struct soap *_param_35, ULONG64 _param_36);
        value(struct soap *_param_37, const struct _array &_param_38);
        value(struct soap *_param_39, const struct _struct &_param_40);
        value(struct soap *_param_41, const struct _base64 &_param_42);
        operator bool() const;
        operator int() const;
        operator LONG64() const;
        operator double() const;
        operator char *() const;
        operator std::string() const;
        operator wchar_t *() const;
        operator std::wstring() const;
        operator ULONG64() const;
        operator struct _array &();
        operator const struct _array &() const;
        operator struct _struct &();
        operator const struct _struct &() const;
        operator struct _base64 &();
        operator const struct _base64 &() const;
        struct value &operator[](int _param_43);
        struct value &operator[](const char *_param_44);
        struct value &operator[](const std::string &_param_45);
        struct value &operator[](const wchar_t *_param_46);
        struct value &operator[](const std::wstring &_param_47);
        bool operator=(bool _param_48);
        int operator=(int _param_49);
        LONG64 operator=(LONG64 _param_50);
        double operator=(double _param_51);
        ULONG64 operator=(ULONG64 _param_52);
        const char *operator=(const char *_param_53);
        char *operator=(char *_param_54);
        char *operator=(const std::string &_param_55);
        const char *operator=(const wchar_t *_param_56);
        char *operator=(wchar_t *_param_57);
        char *operator=(const std::wstring &_param_58);
        struct _array &operator=(const struct _array &_param_59);
        struct _struct &operator=(const struct _struct &_param_60);
        struct _base64 &operator=(const struct _base64 &_param_61);
        void size(int _param_62);
        int size() const;
        bool empty() const;
        int nth(int _param_63) const;
        int nth(const char *_param_64) const;
        int nth(const wchar_t *_param_65) const;
        bool has(int _param_66) const;
        bool has(const char *_param_67) const;
        bool has(const wchar_t *_param_68) const;
        bool is_null() const;
        bool is_bool() const;
        bool is_false() const;
        bool is_true() const;
        bool is_int() const;
        bool is_double() const;
        bool is_string() const;
        bool is_dateTime() const;
        bool is_array() const;
        bool is_struct() const;
        bool is_base64() const;
        value_iterator begin();
        value_iterator end();
        /** Any type of element 'ref' assigned to ref with its SOAP_TYPE_T assigned to __type */
        /** Do not create a cyclic data structure throught this member unless SOAP encoding or SOAP_XML_GRAPH are used for id-ref serialization */
        int __type;
        void *ref;
        char *__any;
        /** Context that manages this object */
        struct soap *soap;
      public:
        /** Return unique type id SOAP_TYPE_value */
        int soap_type() const { return SOAP_TYPE_value; }
        /** Friend allocator used by soap_new_value(struct soap*, int) */
        friend SOAP_FMAC1 value * SOAP_FMAC2 soap_instantiate_value(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xml-rpc.h:143 */
#ifndef SOAP_TYPE_member
#define SOAP_TYPE_member (62)
/* complex XSD type 'member': */
struct member {
      public:
        /** Optional element 'name' of XSD type 'xsd:string' */
        char *name;
        /** Required element 'value' of XSD type 'value' */
        struct value value;
      public:
        /** Return unique type id SOAP_TYPE_member */
        int soap_type() const { return SOAP_TYPE_member; }
        /** Constructor with member initializations */
        member()
        {
          name = (char *)0;
        }
        /** Friend allocator used by soap_new_member(struct soap*, int) */
        friend SOAP_FMAC1 member * SOAP_FMAC2 soap_instantiate_member(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xml-rpc.h:287 */
#ifndef SOAP_TYPE_params
#define SOAP_TYPE_params (161)
/* complex XSD type 'params': */
struct params {
      public:
        typedef params_iterator iterator;
        typedef params_const_iterator const_iterator;
        params();
        params(struct soap *_param_69);
        params(struct soap *_param_70, int _param_71);
        bool empty() const;
        int size() const;
        struct value &operator[](int _param_72);
        params_iterator begin() const;
        params_iterator end() const;
        /** Sequence of elements 'param' of XSD type 'param' stored in dynamic array param of length __size */
        int __size;
        struct param *param;
        /** Context that manages this object */
        struct soap *soap;
      public:
        /** Return unique type id SOAP_TYPE_params */
        int soap_type() const { return SOAP_TYPE_params; }
        /** Friend allocator used by soap_new_params(struct soap*, int) */
        friend SOAP_FMAC1 params * SOAP_FMAC2 soap_instantiate_params(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xml-rpc.h:304 */
#ifndef SOAP_TYPE_param
#define SOAP_TYPE_param (170)
/* complex XSD type 'param': */
struct param {
      public:
        /** Required element 'value' of XSD type 'value' */
        struct value value;
      public:
        /** Return unique type id SOAP_TYPE_param */
        int soap_type() const { return SOAP_TYPE_param; }
        /** Constructor with member initializations */
        param()
        {
        }
        /** Friend allocator used by soap_new_param(struct soap*, int) */
        friend SOAP_FMAC1 param * SOAP_FMAC2 soap_instantiate_param(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xml-rpc.h:318 */
#ifndef SOAP_TYPE_methodResponse
#define SOAP_TYPE_methodResponse (172)
/* complex XSD type 'methodResponse': */
struct methodResponse {
      public:
        methodResponse();
        methodResponse(struct soap *_param_73);
        struct value &operator[](int _param_74);
        struct value &get_fault(void);
        struct value &set_fault(const char *_param_76);
        struct value &set_fault(struct value &_param_77);
        int recv();
        int send();
        /** Optional element 'params' of XSD type 'params' */
        struct params *params;
        /** Optional element 'fault' of XSD type 'fault' */
        struct fault *fault;
        /** Context that manages this object */
        struct soap *soap;
      public:
        /** Return unique type id SOAP_TYPE_methodResponse */
        int soap_type() const { return SOAP_TYPE_methodResponse; }
        /** Friend allocator used by soap_new_methodResponse(struct soap*, int) */
        friend SOAP_FMAC1 methodResponse * SOAP_FMAC2 soap_instantiate_methodResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xml-rpc.h:339 */
#ifndef SOAP_TYPE_methodCall
#define SOAP_TYPE_methodCall (185)
/* complex XSD type 'methodCall': */
struct methodCall {
      private:
        /** Not serialized */
        char *methodEndpoint;
        /** Not serialized */
        struct methodResponse *methodResponse;
      public:
        methodCall();
        methodCall(struct soap *_param_78);
        methodCall(struct soap *_param_79, const char *endpoint, const char *methodname);
        struct value &operator[](int _param_80);
        struct params &operator()();
        struct params &operator()(const struct params &_param_81);
        struct params &response();
        struct value &fault();
        const char *name() const;
        int error() const;
        int recv();
        int send();
        /** Optional element 'methodName' of XSD type 'xsd:string' */
        char *methodName;
        /** Required element 'params' of XSD type 'params' */
        struct params params;
        /** Context that manages this object */
        struct soap *soap;
      public:
        /** Return unique type id SOAP_TYPE_methodCall */
        int soap_type() const { return SOAP_TYPE_methodCall; }
        /** Friend allocator used by soap_new_methodCall(struct soap*, int) */
        friend SOAP_FMAC1 methodCall * SOAP_FMAC2 soap_instantiate_methodCall(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xml-rpc.h:333 */
#ifndef SOAP_TYPE_fault
#define SOAP_TYPE_fault (183)
/* complex XSD type 'fault': */
struct fault {
      public:
        /** Required element 'value' of XSD type 'value' */
        struct value value;
      public:
        /** Return unique type id SOAP_TYPE_fault */
        int soap_type() const { return SOAP_TYPE_fault; }
        /** Constructor with member initializations */
        fault()
        {
        }
        /** Friend allocator used by soap_new_fault(struct soap*, int) */
        friend SOAP_FMAC1 fault * SOAP_FMAC2 soap_instantiate_fault(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xml-rpc.h:481 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (238)
/* SOAP_ENV__Header: */
struct SOAP_ENV__Header {
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Header */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Header; }
        /** Constructor with member initializations */
        SOAP_ENV__Header()
        {
        }
        /** Friend allocator used by soap_new_SOAP_ENV__Header(struct soap*, int) */
        friend SOAP_FMAC1 SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* xml-rpc.h:481 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (239)
/* Type SOAP_ENV__Code is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* SOAP_ENV__Code: */
struct SOAP_ENV__Code {
      public:
        /** Optional element 'SOAP-ENV:Value' of XSD type 'xsd:QName' */
        char *SOAP_ENV__Value;
        /** Optional element 'SOAP-ENV:Subcode' of XSD type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Subcode;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Code */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Code; }
        /** Constructor with member initializations */
        SOAP_ENV__Code()
        {
          SOAP_ENV__Value = (char *)0;
          SOAP_ENV__Subcode = (struct SOAP_ENV__Code *)0;
        }
        /** Friend allocator used by soap_new_SOAP_ENV__Code(struct soap*, int) */
        friend SOAP_FMAC1 SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* xml-rpc.h:481 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (241)
/* SOAP_ENV__Detail: */
struct SOAP_ENV__Detail {
      public:
        char *__any;
        /** Any type of element 'fault' assigned to fault with its SOAP_TYPE_T assigned to __type */
        /** Do not create a cyclic data structure throught this member unless SOAP encoding or SOAP_XML_GRAPH are used for id-ref serialization */
        int __type;
        void *fault;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Detail */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Detail; }
        /** Constructor with member initializations */
        SOAP_ENV__Detail()
        {
          __any = (char *)0;
          __type = 0;
          fault = NULL;
        }
        /** Friend allocator used by soap_new_SOAP_ENV__Detail(struct soap*, int) */
        friend SOAP_FMAC1 SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* xml-rpc.h:481 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (242)
/* SOAP_ENV__Reason: */
struct SOAP_ENV__Reason {
      public:
        /** Optional element 'SOAP-ENV:Text' of XSD type 'xsd:string' */
        char *SOAP_ENV__Text;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Reason */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Reason; }
        /** Constructor with member initializations */
        SOAP_ENV__Reason()
        {
          SOAP_ENV__Text = (char *)0;
        }
        /** Friend allocator used by soap_new_SOAP_ENV__Reason(struct soap*, int) */
        friend SOAP_FMAC1 SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* xml-rpc.h:481 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (243)
/* SOAP_ENV__Fault: */
struct SOAP_ENV__Fault {
      public:
        /** Optional element 'faultcode' of XSD type 'xsd:QName' */
        char *faultcode;
        /** Optional element 'faultstring' of XSD type 'xsd:string' */
        char *faultstring;
        /** Optional element 'faultactor' of XSD type 'xsd:string' */
        char *faultactor;
        /** Optional element 'detail' of XSD type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *detail;
        /** Optional element 'SOAP-ENV:Code' of XSD type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Code;
        /** Optional element 'SOAP-ENV:Reason' of XSD type 'SOAP-ENV:Reason' */
        struct SOAP_ENV__Reason *SOAP_ENV__Reason;
        /** Optional element 'SOAP-ENV:Node' of XSD type 'xsd:string' */
        char *SOAP_ENV__Node;
        /** Optional element 'SOAP-ENV:Role' of XSD type 'xsd:string' */
        char *SOAP_ENV__Role;
        /** Optional element 'SOAP-ENV:Detail' of XSD type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *SOAP_ENV__Detail;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Fault */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Fault; }
        /** Constructor with member initializations */
        SOAP_ENV__Fault()
        {
          faultcode = (char *)0;
          faultstring = (char *)0;
          faultactor = (char *)0;
          detail = (struct SOAP_ENV__Detail *)0;
          SOAP_ENV__Code = (struct SOAP_ENV__Code *)0;
          SOAP_ENV__Reason = (struct SOAP_ENV__Reason *)0;
          SOAP_ENV__Node = (char *)0;
          SOAP_ENV__Role = (char *)0;
          SOAP_ENV__Detail = (struct SOAP_ENV__Detail *)0;
        }
        /** Friend allocator used by soap_new_SOAP_ENV__Fault(struct soap*, int) */
        friend SOAP_FMAC1 SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/


/* xml-rpc.h:41 */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
typedef char *_QName;
#endif

/* xml-rpc.h:41 */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (6)
typedef char *_XML;
#endif

/* xml-rpc.h:86 */
#ifndef SOAP_TYPE__boolean
#define SOAP_TYPE__boolean (21)
typedef char _boolean;
#endif

/* xml-rpc.h:89 */
#ifndef SOAP_TYPE__double
#define SOAP_TYPE__double (23)
typedef double _double;
#endif

/* xml-rpc.h:92 */
#ifndef SOAP_TYPE__i4
#define SOAP_TYPE__i4 (24)
typedef int _i4;
#endif

/* xml-rpc.h:95 */
#ifndef SOAP_TYPE__int
#define SOAP_TYPE__int (26)
typedef LONG64 _int;
#endif

/* xml-rpc.h:98 */
#ifndef SOAP_TYPE__string
#define SOAP_TYPE__string (27)
typedef char *_string;
#endif

/* xml-rpc.h:101 */
#ifndef SOAP_TYPE__dateTime_DOTiso8601
#define SOAP_TYPE__dateTime_DOTiso8601 (28)
typedef char *_dateTime_DOTiso8601;
#endif

/******************************************************************************\
 *                                                                            *
 * Serializable Types                                                         *
 *                                                                            *
\******************************************************************************/


/* _boolean has binding name '_boolean' for type '' */
#ifndef SOAP_TYPE__boolean
#define SOAP_TYPE__boolean (21)
#endif

/* char has binding name 'byte' for type 'xsd:byte' */
#ifndef SOAP_TYPE_byte
#define SOAP_TYPE_byte (3)
#endif

/* _i4 has binding name '_i4' for type '' */
#ifndef SOAP_TYPE__i4
#define SOAP_TYPE__i4 (24)
#endif

/* int has binding name 'int' for type 'xsd:int' */
#ifndef SOAP_TYPE_int
#define SOAP_TYPE_int (1)
#endif

/* _int has binding name '_int' for type '' */
#ifndef SOAP_TYPE__int
#define SOAP_TYPE__int (26)
#endif

/* LONG64 has binding name 'LONG64' for type 'xsd:long' */
#ifndef SOAP_TYPE_LONG64
#define SOAP_TYPE_LONG64 (25)
#endif

/* _double has binding name '_double' for type '' */
#ifndef SOAP_TYPE__double
#define SOAP_TYPE__double (23)
#endif

/* double has binding name 'double' for type 'xsd:double' */
#ifndef SOAP_TYPE_double
#define SOAP_TYPE_double (22)
#endif

/* unsigned char has binding name 'unsignedByte' for type 'xsd:unsignedByte' */
#ifndef SOAP_TYPE_unsignedByte
#define SOAP_TYPE_unsignedByte (40)
#endif

/* unsigned int has binding name 'unsignedInt' for type 'xsd:unsignedInt' */
#ifndef SOAP_TYPE_unsignedInt
#define SOAP_TYPE_unsignedInt (39)
#endif

/* ULONG64 has binding name 'ULONG64' for type 'xsd:unsignedLong' */
#ifndef SOAP_TYPE_ULONG64
#define SOAP_TYPE_ULONG64 (107)
#endif

/* std::wstring has binding name 'std__wstring' for type 'xsd:string' */
#ifndef SOAP_TYPE_std__wstring
#define SOAP_TYPE_std__wstring (86)
#endif

/* std::string has binding name 'std__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_std__string
#define SOAP_TYPE_std__string (82)
#endif

/* struct SOAP_ENV__Fault has binding name 'SOAP_ENV__Fault' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (243)
#endif

/* struct SOAP_ENV__Reason has binding name 'SOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (242)
#endif

/* struct SOAP_ENV__Detail has binding name 'SOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (241)
#endif

/* struct SOAP_ENV__Code has binding name 'SOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (239)
#endif

/* struct SOAP_ENV__Header has binding name 'SOAP_ENV__Header' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (238)
#endif

/* struct methodCall has binding name 'methodCall' for type 'methodCall' */
#ifndef SOAP_TYPE_methodCall
#define SOAP_TYPE_methodCall (185)
#endif

/* struct fault has binding name 'fault' for type 'fault' */
#ifndef SOAP_TYPE_fault
#define SOAP_TYPE_fault (183)
#endif

/* struct methodResponse has binding name 'methodResponse' for type 'methodResponse' */
#ifndef SOAP_TYPE_methodResponse
#define SOAP_TYPE_methodResponse (172)
#endif

/* struct param has binding name 'param' for type 'param' */
#ifndef SOAP_TYPE_param
#define SOAP_TYPE_param (170)
#endif

/* struct params has binding name 'params' for type 'params' */
#ifndef SOAP_TYPE_params
#define SOAP_TYPE_params (161)
#endif

/* struct _array has binding name '_array' for type '' */
#ifndef SOAP_TYPE__array
#define SOAP_TYPE__array (65)
#endif

/* struct data has binding name 'data' for type 'data' */
#ifndef SOAP_TYPE_data
#define SOAP_TYPE_data (64)
#endif

/* struct member has binding name 'member' for type 'member' */
#ifndef SOAP_TYPE_member
#define SOAP_TYPE_member (62)
#endif

/* struct _struct has binding name '_struct' for type '' */
#ifndef SOAP_TYPE__struct
#define SOAP_TYPE__struct (46)
#endif

/* struct _base64 has binding name '_base64' for type '' */
#ifndef SOAP_TYPE__base64
#define SOAP_TYPE__base64 (29)
#endif

/* struct value has binding name 'value' for type 'value' */
#ifndef SOAP_TYPE_value
#define SOAP_TYPE_value (7)
#endif

/* struct SOAP_ENV__Reason * has binding name 'PointerToSOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Reason
#define SOAP_TYPE_PointerToSOAP_ENV__Reason (245)
#endif

/* struct SOAP_ENV__Detail * has binding name 'PointerToSOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Detail
#define SOAP_TYPE_PointerToSOAP_ENV__Detail (244)
#endif

/* struct SOAP_ENV__Code * has binding name 'PointerToSOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Code
#define SOAP_TYPE_PointerToSOAP_ENV__Code (240)
#endif

/* struct _base64 * has binding name 'PointerTo_base64' for type '' */
#ifndef SOAP_TYPE_PointerTo_base64
#define SOAP_TYPE_PointerTo_base64 (211)
#endif

/* double * has binding name 'PointerTo_double' for type '' */
#ifndef SOAP_TYPE_PointerTo_double
#define SOAP_TYPE_PointerTo_double (205)
#endif

/* LONG64 * has binding name 'PointerTo_int' for type '' */
#ifndef SOAP_TYPE_PointerTo_int
#define SOAP_TYPE_PointerTo_int (203)
#endif

/* char * has binding name 'PointerTo_boolean' for type '' */
#ifndef SOAP_TYPE_PointerTo_boolean
#define SOAP_TYPE_PointerTo_boolean (201)
#endif

/* struct methodResponse * has binding name 'PointerTomethodResponse' for type 'methodResponse' */
#ifndef SOAP_TYPE_PointerTomethodResponse
#define SOAP_TYPE_PointerTomethodResponse (186)
#endif

/* struct fault * has binding name 'PointerTofault' for type 'fault' */
#ifndef SOAP_TYPE_PointerTofault
#define SOAP_TYPE_PointerTofault (184)
#endif

/* struct params * has binding name 'PointerToparams' for type 'params' */
#ifndef SOAP_TYPE_PointerToparams
#define SOAP_TYPE_PointerToparams (182)
#endif

/* struct param * has binding name 'PointerToparam' for type 'param' */
#ifndef SOAP_TYPE_PointerToparam
#define SOAP_TYPE_PointerToparam (171)
#endif

/* wchar_t * has binding name 'wstring' for type 'xsd:string' */
#ifndef SOAP_TYPE_wstring
#define SOAP_TYPE_wstring (104)
#endif

/* struct member * has binding name 'PointerTomember' for type 'member' */
#ifndef SOAP_TYPE_PointerTomember
#define SOAP_TYPE_PointerTomember (63)
#endif

/* unsigned char * has binding name 'PointerTounsignedByte' for type 'xsd:unsignedByte' */
#ifndef SOAP_TYPE_PointerTounsignedByte
#define SOAP_TYPE_PointerTounsignedByte (41)
#endif

/* _dateTime_DOTiso8601 has binding name '_dateTime_DOTiso8601' for type '' */
#ifndef SOAP_TYPE__dateTime_DOTiso8601
#define SOAP_TYPE__dateTime_DOTiso8601 (28)
#endif

/* _string has binding name '_string' for type '' */
#ifndef SOAP_TYPE__string
#define SOAP_TYPE__string (27)
#endif

/* struct value * has binding name 'PointerTovalue' for type 'value' */
#ifndef SOAP_TYPE_PointerTovalue
#define SOAP_TYPE_PointerTovalue (9)
#endif

/* _XML has binding name '_XML' for type '' */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (6)
#endif

/* _QName has binding name '_QName' for type 'xsd:QName' */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
#endif

/* char * has binding name 'string' for type 'xsd:string' */
#ifndef SOAP_TYPE_string
#define SOAP_TYPE_string (4)
#endif

/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


/* xml-rpc.h:41 */
extern struct value *new_value(struct soap *soap);

/* xml-rpc.h:44 */
extern struct value *init_value(struct soap *soap, struct value *v);

/* xml-rpc.h:384 */
extern char *bool_of(struct value *v);

/* xml-rpc.h:387 */
extern LONG64 *int_of(struct value *v);

/* xml-rpc.h:390 */
extern double *double_of(struct value *v);

/* xml-rpc.h:393 */
extern const char **string_of(struct value *v);

/* xml-rpc.h:396 */
extern const char **dateTime_of(struct value *v);

/* xml-rpc.h:399 */
extern struct _base64 *base64_of(struct value *v);

/* xml-rpc.h:402 */
extern struct value *value_at(struct value *v, const char *s);

/* xml-rpc.h:405 */
extern struct value *value_atw(struct value *v, const wchar_t *s);

/* xml-rpc.h:408 */
extern int nth_at(struct value *v, const char *s);

/* xml-rpc.h:411 */
extern int nth_atw(struct value *v, const wchar_t *s);

/* xml-rpc.h:414 */
extern int nth_nth(struct value *v, int n);

/* xml-rpc.h:417 */
extern struct member *nth_member(struct value *v, int n);

/* xml-rpc.h:420 */
extern struct value *nth_value(struct value *v, int n);

/* xml-rpc.h:423 */
extern char is_null(struct value *v);

/* xml-rpc.h:426 */
extern char is_int(struct value *v);

/* xml-rpc.h:429 */
extern char is_double(struct value *v);

/* xml-rpc.h:432 */
extern char is_string(struct value *v);

/* xml-rpc.h:435 */
extern char is_bool(struct value *v);

/* xml-rpc.h:438 */
extern char is_true(struct value *v);

/* xml-rpc.h:441 */
extern char is_false(struct value *v);

/* xml-rpc.h:444 */
extern char is_array(struct value *v);

/* xml-rpc.h:447 */
extern char is_struct(struct value *v);

/* xml-rpc.h:450 */
extern char is_dateTime(struct value *v);

/* xml-rpc.h:453 */
extern char is_base64(struct value *v);

/* xml-rpc.h:456 */
extern void set_struct(struct value *v);

/* xml-rpc.h:459 */
extern void set_size(struct value *v, int n);

/* xml-rpc.h:462 */
extern int has_size(struct value *v);

/* xml-rpc.h:471 */
extern struct params *new_params(struct soap *soap);

/* xml-rpc.h:474 */
extern struct params *init_params(struct soap *soap, struct params *p);

/* xml-rpc.h:477 */
extern struct value *nth_param(struct params *p, int n);

/* xml-rpc.h:480 */
extern int call_method(struct soap *soap, const char *endpoint, const char *methodName, struct params *p, struct methodResponse *r);

#endif

/* End of soapStub.h */
