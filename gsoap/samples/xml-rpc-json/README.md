
XML-RPC and JSON                                                     {#mainpage}
================

[TOC]

Introduction                                                            {#intro}
============

XML-RPC is a simple messaging protocol.  XML-RPC is a generic, self-describing
(and verbose) XML format to compose XML messages for platform-neutral data
exchange.  XML-RPC defines a collection of frequently used XML types with common
programming language equivalents.  XML-RPC does NOT provide a data binding to
XML and does NOT support a validation mechanism to ensure that data content is
validated against a data type or schema.  XML-RPC serialization proceeds by
marshaling parameters in predefined XML elements for each data type.  XML-RPC
has primitive types (bool, int, double, string, dateTime, base64) and two
compound types (structs and arrays).

See <http://www.xmlrpc.com> to read more about XML-RPC.

JSON (JavaScript Object Notation) is an even simpler data format to support
platform-neutral data interchange that is highly compatible across programming
languages by restricting data organization to a set of five common types: bool,
float, string, array, and object. 

See <http://www.json.org> to read more about JSON.

The gSOAP C++ JSON API is compact and lightweight.  It is straightforward to
write JSON REST code:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}
    #include "json.h"
    soap *ctx = soap_new1(SOAP_C_UTFSTRING);  // set up context to manage memory
    value request(ctx), response(ctx);
    request = "getCurrentTime";               // request current time
    if (!json_call(ctx,                       // make a call (POST)
          "http://www.cs.fsu.edu/~engelen/currentTimeJSON.cgi",  // endpoint URL
          request,                            // value with the request string
          response)                           // get response, if call is OK
       )
      cout << "Current time = " << response << endl;    // JSON response to cout
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

To help you to quickly write C/C++ JSON API code, we included a simple code
generator `jsoncpp`.  You can find the `jsoncpp` tool  with the JSON examples in
`gsoap/samples/xml-rpc-json`.  The `jsoncpp` command auto-generates C or C++
code from a JSON fragment.  The generated code creates a JSON node graph for
this fragment, which can be further tweaked as necessary.  For example:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}
    $ cat menu.json
    {
      "menu": {
	"id": "file",
	"value": "File",
	"popup": {
	  "menuitem": [
	    {"value": "New", "onclick": "CreateNewDoc()"},
	    {"value": "Open", "onclick": "OpenDoc()"},
	    {"value": "Close", "onclick": "CloseDoc()"}
	  ]
	}
      }
    }
    $ jsoncpp menu.json
    #include "json.h"
    { // C++ code generated by jsoncpp from menu.json
      soap *ctx = soap_new1(SOAP_C_UTFSTRING | SOAP_XML_INDENT);
      value v(ctx);

      v["menu"]["id"] = "file";
      v["menu"]["value"] = "File";
      v["menu"]["popup"]["menuitem"][0]["value"] = "New";
      v["menu"]["popup"]["menuitem"][0]["onclick"] = "CreateNewDoc()";
      v["menu"]["popup"]["menuitem"][1]["value"] = "Open";
      v["menu"]["popup"]["menuitem"][1]["onclick"] = "OpenDoc()";
      v["menu"]["popup"]["menuitem"][2]["value"] = "Close";
      v["menu"]["popup"]["menuitem"][2]["onclick"] = "CloseDoc()";

      std::cout << v;

      soap_destroy(ctx);
      soap_end(ctx);
      soap_free(ctx);
    }
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

With a few changes this code can also be used as a starting point to read JSON
data stored in a node graph, for example after parsing a JSON document.  We
will present in detail how you can create data, access data, send/recv data via
REST, read/write data to files, streams, and string buffers.


C++ XML-RPC and JSON                                                      {#cpp}
====================

XML-RPC and JSON data is interchangeable in this implementation, with the only
exception that the dateTime and base64 types are handled as strings in JSON.
Also, JSON's only numeric type is floating point.  However, integers are handled
just fine by this JSON implementation as 64 bit (`long long`, `int64_t`,
`LONG64`) without conversion to/from double floating point values.


List of C++ files                                                  {#cpp-files}
-----------------

The following files define XML-RPC operations and data types for C++:

- `xml-rpc-io.h`:       XML-RPC serialization over streams
- `xml-rpc-io.cpp`:     XML-RPC serialization over streams
- `xml-rpc-iters.h`:    iterators for structs, arrays, and XML-RPC parameters
- `xml-rpc.cpp`:        XML-RPC C++ data binding API
- `xml-rpc.h`:          XML-RPC data binding as a gSOAP .h file for soapcpp2
                        (do not #include this file in your project builds)

For JSON we use the following files for C++:

- `json.h`:             JSON C++ API and JSON serialization over streams
- `json.cpp`:           JSON C++ API and JSON serialization over streams
- `xml-rpc.cpp`:        XML-RPC C++ data binding API
- `xml-rpc-iters.h`:    iterators for structs/objects and arrays
- `xml-rpc.h`:          XML-RPC data binding as a gSOAP .h file for soapcpp2
                        (do not #include this file in your project builds)

The gSOAP header file `xml-rpc.h` defines all XML-RPC and JSON types as struct
with C++ member functions to create XML-RPC and JSON data and REST messages.

A note about the following auto-generated files: `soapH.h`, `soapStub.h` and
`soapC.cpp`.  These are required for XML-RPC and JSON.  To auto-generate these
files, execute:

    soapcpp2 -CSL xml-rpc.h

Then compile and link the `.cpp` files listed above for XML-RPC and JSON with
the auto-generted `soapC.cpp` and `stdsoap2.cpp` (or link with `libgsoap++.a`
installed by the gSOAP package).

Because XML namespaces are not used, we can either use `-DWITH_NONAMESPACES` to
compile `stdsoap2.cpp` without complaining about a missing global `Namespace`,
or we can define an empty namespaces table somewhere in our code:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}
    struct Namespace namespaces[] = {{NULL,NULL,NULL,NULL}};
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


C++ XML-RPC and JSON with examples                                     {#cpp-ex}
----------------------------------

An XML-RPC/JSON data value is created in C++ as follows, which requires a
context `ctx` with the engine state (the soap struct).  The context manages the
memory that is internally allocated to hold values.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}
    #include "soapH.h"

    soap *ctx = soap_new1(SOAP_C_UTFSTRING);  // new context

    value v(ctx);

    soap_destroy(ctx);  // delete all values
    soap_end(ctx);      // delete temp data
    soap_free(ctx);     // free context
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Note that `soapH.h` is an auto-generated file (see previous section).  This file
needs to be generated only once and for all.  It also references `stdsoap2.h`
and the auto-generated `soapStub.h`.  Compile and link your code with
`stdsoap2.cpp` and the auto-generated `soapC.cpp` XML-RPC serializers.  Also
compile and link `xml-rpc.cpp`.  For JSON, compile and link `json.cpp`.

We can stack-allocate local values as shown above.  To allocate a value on the
heap that is managed by the engine context, use `new_value(ctx)`:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}
    value *v = new_value(ctx);
    ...
    soap_destroy(ctx);  // delete all values
    soap_end(ctx);      // delete temp data
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

You can use wide strings with Unicode stored in UTF-8-formattted 8-bit `char`
strings.  For compatibility with XML-RPC serialization of UTF-8-encoded strings,
we MUST use the `SOAP_C_UTFSTRING` flag to initialize the context with
`soap_new1(SOAP_C_UTFSTRING)`.  We can optionally use `SOAP_XML_INDENT` to
indent XML and JSON.

The code shown above creates an empty value `v`.  Values can be assigned any one
of the following data types:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}
    v = 12345LL;          // 64 bit int

    v = 12.34;            // double float

    v = "abc";            // string

    v = string("abc");    // std::string

    v = L"xyz";           // wide string (converted to UTF-8)

    v = wstring(L"xyz");  // std::wstring (converted to UTF-8)

    v = false;            // Boolean

    v = time(0);          // time_t value serialized as ISO 8601 date time

    // create an array [24, 99.99, "abc"]
    v[0] = 24;
    v[1] = 99.99;
    v[2] = "abc";

    // create a struct (JSON object) {"name": "gsoap", "major": 2.8, "©": 2015}
    v["name"]  = "gsoap";
    v["major"] = 2.8;
    v[L"©"]    = 2015;    // wide string tags are OK

    // create a base64-encoded image object
    _base64 img(ctx, 100, ptr_to_rawimage100bytes); // block of 100 raw bytes
    v = img;
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

We can combine this syntax in many possible ways to create arrays of arrays,
arrays of structs, and so on.  For example:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}
    v[0]["name"] = "bob";
    v[0]["toys"][0] = "ball";
    v[0]["toys"][1] = "furby";
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

This creates a singleton array containing an object with two members: `name`
set to `"bob"` and `toys` set to an array containing `"ball"` and `"furby"`.
In JSON format this is represented as:

               [ { "name": "bob", "toys": ["ball", "furby"] } ]
               ^ ^ ^              ^
               | | |              |
      an array_/ | |              |
     of 1 struct_/ |              |
    with 2 members_/______________/

When receiving a value in XML-RPC or JSON, we generally want to check its type
to obtain its value.  To check the type of a value, we use `is_Type` methods:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}
    bool value::is_null();     // true if value is not set or assigned (JSON null)
    bool value::is_int();      // true if value is a 32 or a 64 bit int
    bool value::is_double();   // true if value is a 64 bit double floating point
    bool value::is_string();   // true if value is a string or wide string
    bool value::is_bool();     // true if value is a Boolean "true" or "false" value
    bool value::is_true();     // true if value is Boolean "true"
    bool value::is_false();    // true if value is Boolean "false"
    bool value::is_array();    // true if array of values
    bool value::is_struct();   // true if structure, a.k.a. a JSON object
    bool value::is_dateTime(); // true if ISO 8601, always false for received JSON
    bool value::is_base64();   // true if base64, always false for received JSON
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

There are three additional methods that can be used with arrays and structs:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}
    void value::size(int);     // reset array size or pre-allocate space
    int value::size();         // returns array or struct size
    bool value::empty();       // true if array or struct is empty
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

For example, let's take the value `v` that was assigned the array shown above.
We have the following properties of this value:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}
    v.is_null() == false
    v.is_array() == true
    v.size() == 1
    v[0].is_struct() == true
    v[0]["name"].is_string() == true
    v[0]["toys"].is_array() == true
    v[0]["toys"].empty() == false
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

When indexing XML-RPC structs (JSON objects) to access members and values, make
sure to use existing member names only.  Otherwise, a new member is dynamically
added to the structure to accomodate the new named member.  Also arrays are
extended to accommodate the indexed array element.  A negative array index can
be used to access elements offset from the end, with index -1 accessing the
last value.

You may want to use iterators to extract data from structs and arrays (see
further below).

To extract atomic data we can use casts on a value `v` as follows:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}
    (double)v                   // 64 bit double or 0.0 if not numeric
    (int)v                      // 32 bit int or 0 if not numeric
    (LONG64)v                   // 64 bit int or 0 if not numeric
    (char*)v                    // convert to string
    (string)v                   // convert to std::string
    (wchar_t*)v                 // convert to wide string
    (wstring)v                  // convert to std::wstring
    (bool)v                     // same as is_true()
    (time_t)v                   // nonzero if v contains an ISO 8601 date time
    (_base64)v                  // base64 encoding of v
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

It is valid to cast a primitive type to any of the other primitive types shown
above and no runtime error will occur, although you may loose some information
when an atomic value has no representation in the target type's value space.
Casting a number to a string is fine, but casting a string to a number only
gives a nonzero numeric value if the string is numeric.  Casting a value to
base64 produces its base64 encoding.

To access base64 binary raw data of a value `v`, we use the following methods:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}
    _base64& base64 = v;
    unsigned char *raw = base64.ptr();  // point to raw binary data
    int size = base64.size();           // that is of this size
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Arrays and structs are compound types that cannot be cast to or from other
types (but if you do cast, an empty array or struct is created an no runtime
error will occur).  So we should check for array and struct types to obtain
their content.  For example:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}
    if (v.is_array())
    {
      for (int i = 0; i < v.size(); ++i)
      {
        value& array_value = v[i];
        ... // use and/or set array_value
      }
    }
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

We use the iterators `value::iterator` and `value::const_iterator` to loop over
the values in structs and arrays:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}
    if (v.is_struct() || v.is_array())
    {
      for (value::iterator i = v.begin(); i != v.end(); ++i)
      {
        int index = i.index();              // index of element
	const char *name = i.name();        // name() is nonempty for structs
        value& element = *i;
        ... // use index, name, and/or use/set the element value
      }
    }
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The iterator method `value::iterator::index()` returns the integer index of the
struct or array element.  The `value::iterator::name()` method returns the name
of the struct member, or empty `""` if the type is not a struct.  The
`value::const_iterator` does not permit the value referenced by the iterator to
be modified.

There are two lower level iterators for structs and arrays, which are slightly
more efficient to use compared to the `value::iterator`.  These array and
struct iterators have an `index()` method to obtain the index (an int).  Struct
iterators have a `name()` method to obtain a member's name (a string).

For example, to traverse a value `v` that is an array or a struct:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}
    if (v.is_array())
    {
      _array& vec = v;  // cast to _array
      for (_array::iterator i = vec.begin(); i != vec.end(); ++i)
      {
        int array_index = i.index();
        value& array_value = *i;
        ... // use array_index, use and/or set array_value
      }
    }
    else if (v.is_struct())
    {
      _struct& rec = v;  // cast to _struct
      for (_struct::iterator i = rec.begin(); i != rec.end(); ++i)
      {
        const char *member_name = i.name();
        value& member_value = *i;
        ... // use member_name, use and/or set member_value
      }
    }
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

As usual, the `_struct::const_iterator` and `_array::const_iterator` do not
permit the values referenced by the iterator to be modified.

XML-RPC parameter lists are similar to arrays and its values are indexed.  We
can also iterate over response parameters after an XML-RPC REST call:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}
    methodCall rpc(ctx, "endpoint URL", "methodName");
    params request(ctx, 2);
    request[0] = ...;                // first request parameter
    request[1] = ...;                // second request parameter
    params response = rpc(request);  // execute the call
    if (!rpc.error())
    {
      for (params::iterator i = response.begin(); i != response.end(); ++i)
      {
        int index = i.index();
        value& param_value = *i;
        ... // use param_value of response params
      }
    }
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

We should note that JSON REST does not require parameter types, for example:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}
    #include "json.h"
    value request(ctx);
    value response(ctx);
    request[0] = ...;                // first request parameter
    request[1] = ...;                // second request parameter
    if (!json_call(cts, "endpoint URL", request, response))
    {
      ... // use response value
    }
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

There are two additional methods to invoke on parameters:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}
    int params::size();         // get number of parameters
    bool params::empty();       // true if no parameters
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

All dynamically allocated memory that is internally used to store data is
deallocated with:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}
    soap_destroy(ctx);  // delete all values
    soap_end(ctx);      // delete temp data
    soap_free(ctx);     // delete context allocated with soap_new()
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Additional examples are located in `gsoap/samples/xml-rpc-json`:

- `xml-rpc-currentTime.cpp`:            XML-RPC C++ client, also uses JSON
- `xml-rpc-currentTimeServer.cpp`:      XML-RPC C++ server
- `xml-rpc-weblogs.cpp`:                XML-RPC C++ client
- `xml-rpc-json.cpp`:                   XML-RPC to/from JSON example
- `json-currentTime.cpp`:               JSON C++ client
- `json-currentTimeServer.cpp`:         JSON C++ server
- `json-GitHub.cpp`:                    JSON C++ client for GitHub API v3


C++ XML-RPC client example                                             {#cpp-cl}
--------------------------

A typical XML-RPC calling sequence in C++ is:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}
    #include "soapH.h"      // generated by the command: soapcpp2 -CSL xml-rpc.h
    #include "xml-rpc-io.h" // to serialize XML-RPC data to streams
    struct Namespace namespaces[] = {{NULL,NULL,NULL,NULL}}; // no XML namespaces
    // create a context
    soap *ctx = soap_new1(SOAP_C_UTFSTRING); // store Unicode in UTF-8 format
    ctx->send_timeout = 10; // 10 sec, stop if server is not accepting msg
    ctx->recv_timeout = 10; // 10 sec, stop if server does not respond in time
    // create an XML-RPC method call object
    methodCall rpc(ctx, "endpoint URL", "methodName");
    // populate the parameters
    rpc[0] = 123;           // first parameter is an integer
    rpc[1] = "abc";         // second is a string
    rpc[2]["name"] = "joe"; // a record, first member "name"
    rpc[2]["age"] = 23;     // a record, second member "age"
    rpc[3][0] = 456.789;    // an array, first element (a float)
    rpc[3][1] = "widget";   // an array, second element (a string)
    rpc[3][2] = true;       // an array, third element (a bool)
    // make the XML-RPC call and retrieve response
    params response = rpc(request);
    // check result
    if (rpc.error())
      soap_stream_fault(ctx, std::err);
    else if (response.empty())
      std::cout << rpc.fault() << std::endl;
    else if (response.size() > 1)
      std::cout << "More than one response data" << std::endl;
    else if (response[0].is_array() && !response[0].empty())
      for (int i = 0; i < response[0].size(); i++)
        ... = response[0][i];
    else if (response[0].is_struct())
    {
      ... = response[0]["membername1"];
      ... = response[0]["membername2"];
    }
    else if (response[0].is_base64())
    {
      _base64 base64& = response[0];
      unsigned char *raw = base64.ptr();
      int size = base64.size();
      ... // use raw[0..size-1] data
    }
    else if (response[0].is_bool())
    {
      bool flag = response[0];
      ... // use boolean flag
    }
    else if (response[0].is_int())
    {
      LONG64 num = response[0];
      ... // use integer
    }
    else if (response[0].is_double())
    {
      double num = response[0];
      ... // use double float
    }
    else if (response[0].is_string())
    {
      const char *str = response[0];
      // use string, note that also legal is:
      const std::string& st = response[0];
      // and conversion from UTF-8 to wide string unicode:
      const wchar_t *w = response[0];
      const std::string& ws = response[0];
    }
    else if (response[0].is_dateTime())
    {
      time_t t = response[0];
      ... // use time
    }
    // deallocate all
    soap_destroy(ctx);
    soap_end(ctx);
    soap_free(ctx);
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Alternatively, parameters of a methodCall can be passed with the methodCall
itself as follows:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}
    methodCall rpc(ctx, "endpoint URL", "methodName");
    // create 5 parameters
    params request(ctx, 5);
    // populate the parameters
    request[0] = 123;           // first parameter is an integer
    request[1] = "abc";         // second is a string
    request[2]["name"] = "joe"; // a record, first member "name"
    request[2]["age"] = 23;     // a record, second member "age"
    request[3][0] = 456.789;    // an array, first element (a float)
    request[3][1] = "widget";   // an array, second element (a string)
    request[3][2] = true;       // an array, third element (a bool)
    // make the XML-RPC call with request parameters, retrieve response
    params response = rpc(request);
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Note that in the client code, after the response is retrieved, the implicit
type casts done by assignments extract the values.  These casts can be used
anywhere to extract values:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}
    params response = rpc();
    double sum = 0.0;
    for (int i = 0; i < response.size(); i++)
      if (response[i].is_double())    // is this parameter a double float?
        sum += (double)response[i];
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Type casts can also be used to convert data, which means they never produce an
exception.  Casting to string `(const char*)` converts atomic values to strings,
  but does not convert compound types such as arrays and structs.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}
    params response = rpc();
    for (int i = 0; i < response.size(); i++)
      printf("response[%d] = %s\n", i, (const char*)response[i]);
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

which prints a string representation of the int, double, boolean, time, or
base64 values of parameters.  An empty string is printed for arrays and structs.
Use iterators to walk over arrays and structs to print values.  Or use the
JSON API `json.h` and `json.cpp` to print values in JSON format, see further on
JSON below.


C++ XML-RPC server example                                             {#cpp-sr}
--------------------------

A typical C++ XML-RPC server sequence is:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}
    // create an allocation context
    soap *ctx = soap_new1(SOAP_C_UTFSTRING);
    // create an XML-RPC methodCall object
    methodCall rpc(ctx);
    // Option 1: parse and write to/from stdin/out for CGI
    // (no code needed)
    // Option 2: parse and write to/from FILE or socket
    // ctx->recvfd = ...; // set input FD
    // ctx->sendfd = ...; // set output FD
    // Option 3: parse and write to/from IO streams
    // ctx->is = ...; // set input stream
    // ctx->os = ...; // set output stream
    if (rpc.recv() != SOAP_OK)
      soap_print_fault(ctx, stderr);
    else
    {
      // create response
      methodResponse response(ctx);
      // check method name
      if (!strcmp(rpc.name(), "methodName"))
      {
        // method name matches: populate response parameters with values:
        response[0] = ...;
        response[1] = ...;
        ... // add response data 
      }
      else
      {
        // otherwise, set fault
        response.set_fault("Wrong method");
      }
      // send response
      if (response.send() != SOAP_OK)
        soap_print_fault(ctx, stderr);
    }
    // close (but keep-alive setting keeps socket open)
    soap_closesock(ctx);
    // clean up
    soap_destroy(ctx);
    soap_end(ctx);
    soap_free(ctx);
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

With option 1 the server code above uses standard in/out and thus runs over
CGI.  Other possibilities are given by options 2 and 3.

To serve requests at a port, we use the `soap_bind()` and `soap_accept()` calls
to bind the server to a port and accept requests via socket, see also the docs
and examples for these calls (see for example `gsoap/samples/webserver.c`):

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}
    // create an allocation context
    soap *ctx = soap_new1(SOAP_IO_KEEPALIVE | SOAP_C_UTFSTRING);
    // bind to port 8080
    if (!soap_valid_socket(soap_bind(ctx, NULL, 8080, 100)))
      ... // error, stop
    // accept messages in server loop
    for (;;)
    {
      if (!soap_valid_socket(soap_accept(ctx)))
        ... // error, stop
      // create a method object
      methodCall rpc(ctx);
      // parse it from socket
      if (rpc.recv() != SOAP_OK)
        soap_print_fault(ctx, stderr);
      ... // process request, produce result to send as shown above
      // close (but keep-alive setting keeps socket open)
      soap_closesock(ctx);
      // clean up
      soap_destroy(ctx);
      soap_end(ctx);
    }
    // free context
    soap_free(ctx);
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


C++ XML-RPC serialization from/to streams                              {#cpp-io}
-----------------------------------------

To send and receive XML over streams, use `xml-rpc-io.h` and `xml-rpc-io.cpp`.
For example:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}
    #include "xml-rpc-io.h"
    std::cout << response[0] << std::endl;
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

which will display the data in XML-RPC format.  To parse XML-RPC data from a
stream, use:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}
    #include "xml-rpc-io.h"
    value v(ctx);
    std::cin >> v;
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Compile and link together with `soapC.cpp`, `xml-rpc.cpp`, `xml-rpc-io.cpp`,
and `stdsoap2.cpp`.


C++ JSON serialization from/to streams                                 {#cpp-js}
--------------------------------------

To display values in JSON format or to parse JSON data, use the `json.h` and
`json.cpp` JSON serializers in combination with `xml-rpc.cpp` and the
auto-generated `soapH.h` and `soapC.cpp`.  It is also possible to send and
receive JSON data over HTTP as JSON REST operations, but this requires some
more coding (see [JSON over HTTP](#cpp-jr) below).

Because the internal data is the same for XML-RPC and JSON, You can write data
in XML-RPC or in JSON format.  You can also parse XML-RPC data and write to JSON
data and vice versa.

For example, you can parse a JSON-formatted string and use that data to make an
XML-RPC call.  The result of the call is displayed in JSON, nicely indented
using the `SOAP_XML_INDENT` flag (this XML indent flag also works for JSON):

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}
    #include "json.h"
    #include <sstream>
    struct Namespace namespaces[] = {{NULL,NULL,NULL,NULL}}; // no XML namespaces

    // SOAP_C_UTFSTRING: UTF-8 content in char*, SOAP_XML_INDENT: indent JSON
    soap *ctx = soap_new1(SOAP_C_UTFSTRING | SOAP_XML_INDENT);
    value request(ctx);
    istringstream in;
    in.str("[ [1, \"2\", 3.14, true], {\"name\": \"john\", \"age\": 24} ]");
    in >> request;                      // parse JSON, store as XML-PRC data
    params response = rpc(request);     // make the XML-RPC call
    std::cout << response << std::endl; // display result in JSON (indented)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Compile and link together with `soapC.cpp`, `xml-rpc.cpp`, `json.cpp`, and
`stdsoap2.cpp`.

The JSON protocol has fewer data types than XML-RPC, so type information can be
lost when serializing to JSON:

- XML-RPC uses a base64 type to exchange raw binary data.  The base64 data is
  converted to a string with base64 content by the JSON serializer.
  See also [JSON and Base64](#base64).

- XML-RPC has a dateTime type, JSON does not.  The JSON serializer converts the
  dateTime type to a dateTime-formatted string.
  See also [JSON and ISO 8601 DateTime](#dateTime).

See the section on C++ examples on how to populate and extract C++ data.

Strings are stored and exchanged in UTF-8 format in 8-bit strings (`char*` and
`std::string`) by using the `SOAP_C_UTFSTRING` flag.  Without this flag, 8-bit
strings are converted to UTF-8.  We can optionally use `SOAP_XML_INDENT` to
indent XML and JSON.

To force reading and writing JSON in ISO 8859-1 format, use the
`SOAP_ENC_LATIN` flag to set the context.


C++ JSON over HTTP (REST method)                                       {#cpp-jr}
--------------------------------

To use JSON REST on the client side, we use `json_call`:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}
    #include "json.h"            // also compile and link json.cpp
    struct Namespace namespaces[] = {{NULL,NULL,NULL,NULL}}; // no XML namespaces

    // SOAP_C_UTFSTRING: UTF-8 content in char*, SOAP_XML_INDENT: indent JSON
    soap *ctx = soap_new1(SOAP_C_UTFSTRING | SOAP_XML_INDENT);
    value request(ctx), response(ctx);
    ... // now populate the request data to send

    if (json_call(ctx, "URL", &request, &response) != SOAP_OK)) // POST
      ... // error
    else
      ... // use the response data
    ... // make other calls etc.
    soap_destroy(ctx); // delete all values
    soap_end(ctx);
    ... // make other calls etc.
    soap_free(ctx);    // free context
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The `json_call` function takes a context, an endpoint URL (with query string
parameters as needed), and optional `in` and `out` values to send and receive,
respectively.  The function returns `SOAP_OK` (zero) for success or `EOF`,
`SOAP_SYNTAX_ERROR`, or an HTTP error code.

To use the JSON REST POST method, pass both `in` and `out` values to
`json_call`.  For the GET method, pass a NULL to `in`.  For the PUT method, pass
a NULL to `out`.  For the DELETE method, pass both NULL to `in` and `out`.

Besides `json_call`, there are other JSON API functions:

- `int json_call(soap *ctx, const char *URL, value *in, value *out)` makes a
  POST, GET, PUT, DELETE call, returns `SOAP_OK` or error code.
  POST method: pass both `in` and `out`.  GET method: pass a NULL to `in`.  PUT
  method: pass a NULL to `out`.  DELETE method: pass both NULL to `in` and
  `out`.

- `int json_write(soap *ctx, const value *v)` Writes JSON value to current
  file, socket, or stream.  Returns `SOAP_OK` or error.  Set file/socket fd with
  `ctx->sendfd = fd`.  Set output stream with `ctx->os = ostream`.

- `int json_read(soap *ctx, value *v)` Reads JSON value from current file,
  socket, or stream.  Returns `SOAP_OK` or error.  Set file/socket fd with
  `ctx->recvfd = fd`.  Set input stream with `ctx->is = istream`.

The are two other lower-level functions `json_send` and `json_recv` that are
similar to `json_write` and `json_read` but do not initialize the sending and
receiving operations and do not flush after the sending and receiving
operations.

To implement a JSON REST server for CGI (e.g. install in cgi-bin):

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}
    #include "json.h"            // also compile and link json.cpp
    struct Namespace namespaces[] = {{NULL,NULL,NULL,NULL}}; // no XML namespaces

    int main()
    {
      soap *ctx = soap_new1(SOAP_C_UTFSTRING | SOAP_XML_INDENT);
      value request(ctx), response(ctx);
      if (soap_begin_recv(ctx)
       || json_recv(ctx, request)
       || soap_end_recv(ctx))
        soap_send_fault(ctx);
      else
      {
        ... // use the 'request' value
        ... // set the 'response' value
        // set http content type
        ctx->http_content = "application/json; charset=utf-8";
        // send http header and body
        if (soap_response(ctx, SOAP_FILE)
         || json_send(ctx, response)
         || soap_end_send(ctx))
          soap_print_fault(ctx, stdout);
      }
      // dealloc all
      soap_destroy(ctx);
      soap_end(ctx);
      soap_free(ctx);
    }
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Compile and link the code together with `soapC.cpp`, `xml-rpc.cpp`, `json.cpp`,
and `stdsoap2.cpp`.

For client and server examples, please see the gSOAP package content:

- `gsoap/samples/xml-rpc-json/json-currentTime.cpp`
- `gsoap/samples/xml-rpc-json/json-currentTimeServer.cpp`


Moving JSON types into a C++ namespace                                {#json-ns}
--------------------------------------

A C++ namespace is preferred to separate JSON types and operations from other
project-related types and operations.

To put all JSON (and XML-RPC) types and operations in a `json` C++ namespace,
execute the following commands:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    soapcpp2 -qjson -CSL xml-rpc.h
    soapcpp2 -penv -CSL env.h
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

where `env.h` is an empty file.  This generates `jsonStub.h`, `jsonH.h`,
`jsonC.cpp`, and `envC.cpp`.

Then compile the source files together with `xml-rpc.cpp` and `json.cpp` and
set the macro `-DJSON_NAMESPACE`:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    c++ -DJSON_NAMESPACE xml-rpc.cpp json.cpp jsonC.cpp envC.cpp stdsoap2.cpp ...
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Your project should now use the `json` namespace with a `value`, for example:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}
    #include "json.h"
    soap *ctx = soap_new1(SOAP_C_UTFSTRING);
    json::value v(ctx);
    std::cin >> v;        // parse JSON
    std::cout << v;       // output JSON
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


C XML-RPC and JSON                                                          {#c}
==================

With the release of gSOAP 2.8.26, the XML-RPC and JSON C APIs have been greatly
improved.  The material in this section pertains to gSOAP 2.8.26 and later.

The new C API for XML-RPC and JSON makes it much easier to populate and extract
data, but not as simple and easy as the C++ API.


List of C files                                                       {#c-files}
---------------

The following files define XML-RPC operations and data types:

- `xml-rpc.c`:  XML-RPC C API
- `xml-rpc.h`:  XML-RPC data binding as a gSOAP .h file for soapcpp2
                (do not #include this file in your project builds)

In addition to the files above, for JSON we also need the following files:

- `json.h`:     JSON C API and JSON serialization
- `json.c`:     JSON C API and JSON serialization

The gSOAP header file `xml-rpc.h` defines all XML-RPC and JSON types and the C
API functions to create XML-RPC and JSON data for REST messages.

A note about the following auto-generated files: `soapH.h`, `soapStub.h` and
`soapC.c`: these are required for XML-RPC and JSON.  To auto-generate these
files, execute:

    soapcpp2 -c -CSL xml-rpc.h

Then compile and link the `.c` files listed above for XML-RPC and JSON with the
auto-generted `soapC.c` and `stdsoap2.c` (or link with `libgsoap.a` installed
by the gSOAP package).

Because XML namespaces are not used, we can either use `-DWITH_NONAMESPACES` to
compile `stdsoap2.c` without complaining about a missing global `Namespace`,
or we can define an empty namespaces table somewhere in our code:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.c}
    struct Namespace namespaces[] = {{NULL,NULL,NULL,NULL}};
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


C XML-RPC and JSON with examples                                         {#c-ex}
--------------------------------

An XML-RPC/JSON data value is created in C as follows, which requires a context
`ctx` with the engine state (the soap struct).  The context manages the memory
that is internally allocated to hold values.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.c}
    #include "soapH.h"

    struct soap *ctx = soap_new1(SOAP_C_UTFSTRING);  /* new context */

    struct value *v = new_value(ctx);

    soap_end(ctx);      /* delete all values */
    soap_free(ctx);     /* free context */
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Note that `soapH.h` is an auto-generated file (see previous section).  This
file needs to be generated only once and for all.  It also references
`stdsoap2.h` and the auto-generated `soapStub.h`.  Compile and link your code
with `stdsoap2.cpp` and the auto-generated `soapC.cpp` XML-RPC serializers.
Also compile and link `xml-rpc.cpp`.  For JSON, compile and link `json.cpp`.

You can use wide strings with Unicode stored in UTF-8-formattted 8-bit `char`
strings.  For compatibility with XML-RPC serialization of UTF-8-encoded strings,
we MUST use the `SOAP_C_UTFSTRING` flag to initialize the context with
`soap_new1(SOAP_C_UTFSTRING)`.

The code shown above creates an empty value `v`.  Values can be assigned any one
of the following data types:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.c}
    *int_of(v) = 12345LL;    /* 64 bit int */

    *double_of(v) = 12.34;   /* double float */

    *string_of(v) = "abc";   /* string */

    *string_of(v) = soap_wchar2s(ctx, L"xyz");
                             /* wide string (converted to UTF-8) */

    *bool_of(v) = 0;         /* Boolean false (0) or true (1) */

    *dateTime_of(v) = soap_dateTime2s(ctx, time(0));
                             /* time_t value serialized as ISO 8601 date time */

    /* create an array [24, 99.99, "abc"] */
    *int_of(nth_value(v, 0)) = 24;
    *double_of(nth_value(v, 1)) = 99.99;
    *string_of(nth_value(v, 2)) = "abc";

    /* create a struct (JSON object) {"name": "gsoap", "major": 2.8, "©": 2015} */
    *string_of(value_at(v, "name")) = "gsoap";
    *double_of(value_at(v, "major")) = 2.8;
    *int_of(value_atw(v, L"©")) = 2015;  /* wide string tags are OK */

    /* create a base64-encoded image object */
    struct _base64 *img = base64_of(v);
    img->__ptr = ptr_to_rawimage100bytes;  /* block of 100 raw bytes */
    img->__size = 100;
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The functions above return a pointer to a specific type of value and this value
can be assigned as shown above but also read.  So we use these functions also to
extract data, for example after receiving XML-RPC or JSON data.

We can combine this syntax in many possible ways to create arrays of arrays,
arrays of structs, and so on.  For example:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.c}
    *string_of(value_at(nth_value(v, 0), "name")) = "bob";
    *string_of(nth_value(value_at(nth_value(v, 0), "toys"), 0)) = "ball";
    *string_of(nth_value(value_at(nth_value(v, 0), "toys"), 1)) = "furby";
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

This creates a singleton array containing an object with two members: `name`
set to `"bob"` and `toys` set to an array containing `"ball"` and `"furby"`.  In
JSON format this is represented as:

               [ { "name": "bob", "toys": ["ball", "furby"] } ]
               ^ ^ ^              ^
               | | |              |
      an array_/ | |              |
     of 1 struct_/ |              |
    with 2 members_/______________/

Considering that the code verbosity quickly increases when accessing deeper
levels of your structures, you are probably inclined to define your own macros
to create and access deep data more conveniently, such as:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.c}
    #define string_at(v, s) string_of(value_at((v), (s)))
    #define nth_string(v, n) string_of(nth_value((v), (n)))
    #define nth_string_at(v, s, n) string_of(nth_value(value_at((v), (s)), (n)))
    #define string_at_nth(v, n, s) string_of(value_at(nth_value((v), (n)), (s)))
    #define nth_string_at_nth(v, n, s, m) string_of(nth_value(value_at(nth_value((v), (n)), (s)), (m)))
    ... etc ...
    *string_at_nth(v, 0, "name") = "bob";
    *nth_string_at_nth(v, 0, "toys", 0) = "ball";
    *nth_string_at_nth(v, 0, "toys", 1) = "furby";
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

When receiving a value in XML-RPC or JSON, we generally want to check its type
to obtain its value.  To check the type of a value, we use `is_Type` functions:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.c}
    is_null(v);     /* true if value is not set or assigned (JSON null) */
    is_int(v);      /* true if value is a 32 or a 64 bit int */
    is_double(v);   /* true if value is a 64 bit double floating point */
    is_string(v);   /* true if value is a string */
    is_bool(v);     /* true if value is a Boolean "true" or "false" value */
    is_true(v);     /* true if value is Boolean "true" */
    is_false(v);    /* true if value is Boolean "false" */
    is_array(v);    /* true if array of values */
    is_struct(v);   /* true if structure, a.k.a. a JSON object */
    is_dateTime(v); /* true if ISO 8601, always false for received JSON */
    is_base64(v);   /* true if base64, always false for received JSON */
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

There is one additional function that can be used with arrays and structs:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.c}
    has_size(v);    /* returns array or struct size or 0 if not array/struct */
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

For example, let's take the value `v` that was assigned the array shown above.
We have the following properties of this value:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.c}
    is_null(v) == false
    is_array(v) == true
    has_size(v) == 1
    is_struct(nth_value(v, 0)) == true
    is_string(value_at(nth_value(v, 0), "name")) == true
    is_string(nth_value(value_at(nth_value(v, 0), "toys"), 0)) == true
    is_string(nth_value(value_at(nth_value(v, 0), "toys"), 1)) == true
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

When indexing XML-RPC structs (JSON objects) to access members and values, make
sure to use existing member names only.  Otherwise, a new member is dynamically
added to the structure to accomodate the new named member.  Also arrays are
extended to accommodate the indexed array element.  A negative array index can
be used to access elements offset from the end, with index -1 accessing the
last value.

To iterate over array and struct values, we use a loop over `nth_value` and
`nth_member` as follows:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.c}
    if (is_array(v))
    {
      int i;
      for (i = 0; i < has_size(v); i++)
      {
        struct value *array_value = nth_value(v, i);
        ... /* use and/or set array_value */
      }
    }
    else if (is_struct(v))
    {
      int i;
      for (i = 0; i < has_size(v); i++)
      {
        struct member *member = nth_member(v, i);
        const char *member_name = member->name;
        struct value *member_value = &member->value;
        ... /* use member_name and member_value */
      }
    }
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

To access base64 binary raw data of a value `v`, we use the following code:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.c}
    struct _base64 *base64 = base64_of(v);
    unsigned char *raw = base64->__ptr;  /* point to raw binary data */
    int size = base64->__size;           /* that is of this size */
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

XML-RPC parameter lists are similar to arrays and its values are indexed.  We
can also loop over response parameters after an XML-RPC REST call:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}
    struct params *request = new_params(ctx);
    struct methodResponse response;
    *string_of(nth_param(request, 0)) = "hello";
    *string_of(nth_param(request, 1)) = "world";
    if (call_method(ctx, "endpoint URL", "methodName", request, &response) == SOAP_OK)
    {
      int i;
      for (i = 0; i < response.params->__size; i++)
      {
        struct value *param_value = nth_param(response.params, i);
        ... /* use param_value */
      }
    }
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

We should note that JSON REST does not require parameter types, for example:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}
    #include "json.h"
    struct value *request = new_value(ctx);
    struct value *response = new_value(ctx);
    *string_of(nth_value(request, 0)) = "hello";
    *string_of(nth_value(request, 1)) = "world";
    if (json_call(cts, "endpoint URL", request, response) == SOAP_OK)
    {
      ... /* use response value */
    }
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

All dynamically allocated memory that is internally used to store data is
deallocated with:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}
    soap_end(ctx);      /* delete all values */
    soap_free(ctx);     /* delete context allocated with soap_new() */
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Additional examples are located in `gsoap/samples/xml-rpc-json`:

- `xml-rpc-currentTime.c`               XML-RPC C client
- `xml-rpc-weblogs.c`                   XML-RPC C client
- `json-GitHub.c`:                      JSON C client for GitHub API v3


C XML-RPC client example                                                 {#c-cl}
------------------------

An XML-RPC method call in C with the new XML-RPC C API:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.c}
    #include "soapH.h"  /* generated by the command: soapcpp2 -CSL xml-rpc.h */
    struct soap *ctx = soap_new1(SOAP_C_UTFSTRING); /* UTF-8 in char* strings */
    struct params *request = new_params(ctx);
    struct methodResponse response;
    ctx->send_timeout = 10; /* 10 sec, stop if server is not accepting msg */
    ctx->recv_timeout = 10; /* 10 sec, stop if server does not respond in time */
    /* first parameter is an integer */
    *int_of(nth_param(request, 0)) = 123;
    /* second parameter is a string */
    *string_of(nth_param(request, 1)) = "abc";
    /* third parameter is a struct {"name": "joe", "age": 23} */
    *string_of(value_at(nth_param(request, 2), "name")) = "joe";
    *int_of(value_at(nth_param(request, 2), "age")) = 23;
    /* fourth parameter is an array [456.789, "widget", true] */
    *double_of(nth_value(nth_param(request, 3), 0)) = 456.789
    *string_of(nth_value(nth_param(request, 3), 1)) = "widget";
    *bool_of(nth_value(nth_param(request, 3), 2)) = 1;
    /* connect, send request, and receive response */
    if (call_method(ctx, "endpoint UTL", "methodName" request, &response))
    {
      soap_print_fault(ctx, stderr);
    }
    else if (response.fault)
    {
      /* write fault to stdout */
      soap_write_fault(ctx, response.fault);
    }
    else
    {
      /* print response parameters */
      int i;
      for (i = 0; i < response.params->__size; i++)
      {
        printf("Return parameter %d = ", i+1);
        display(nth_param(response.params, i)); /* see below */
        printf("\n");
      }
    }
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The following example shows how to traverse the node graph to display a value:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.c}
    void display(struct value *v)
    {
      if (is_bool(v))
	printf(is_true(v) ? "true" : "false");
      else if (is_int(v))
	printf("%lld", int_of(v));
      else if (is_double(v))
	printf("%g", double_of(v));
      else if (is_string(v))
	printf("\"%s\"", string_of(v));
      else if (is_array(v))
      {
	int i;
	printf("[");
	for (i = 0; i < has_size(v); i++)
	{
	  if (i) printf(",");
          display(nth_value(v, i));
	}
	printf("]");
      }
      else if (is_struct(v))
      {
	int i;
	printf("{");
	for (i = 0; i < has_size(v); i++)
	{
	  if (i) printf(",");
	  printf("\"%s\": ", nth_member(v, i)->name);
          display(&nth_member(v, i)->value);
	}
	printf("}");
      }
      else if (is_dateTime(v))
	printf("\"%s\"", dateTime_of(v));
      else if (is_base64(v))
	printf("(%d bytes of raw data at %p)", base64_of(v)->__size, base64_of(v)->__ptr);
    }
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Compile and link together with `soapC.c`, `xml-rpc.c`, and `stdsoap2.c`.


C JSON serialization                                                     {#c-js}
--------------------

To write values in JSON format or parse JSON data, we use the `json.h` and
`json.c` JSON C API.  It is also possible to send and receive JSON data over
HTTP (JSON REST).

You can also convert XML-RPC data to/from JSON and populate XML-RPC from JSON
data.  For example:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.c}
    #include "json.h" /* also compile and link json.c */
    struct Namespace namespaces[] = {{NULL,NULL,NULL,NULL}}; /* no XML namespaces */

    /* SOAP_C_UTFSTRING: UTF-8 content in char*, SOAP_XML_INDENT: indent JSON */
    struct soap *ctx = soap_new1(SOAP_C_UTFSTRING | SOAP_XML_INDENT);
    struct value *v = new_value(ctx);

    ctx->recvfd = ...;         /* set file descriptor for reading */
    json_read(ctx, v);         /* read JSON into value v */

    ctx->sendfd = ...;         /* set file descriptor for writing */
    json_write(ctx, v);        /* write value v in JSON format (indented) */
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Compile and link together with `soapC.c`, `xml-rpc.c`, `json.c`, and
`stdsoap2.c`.

The JSON protocol has fewer data types than XML-RPC, so type information can be
lost when serializing to JSON:

- XML-RPC uses a base64 type to exchange raw binary data.  The base64 data is
  converted to a string with base64 content by the JSON serializer.
  See also [JSON and Base64](#base64).

- XML-RPC has a dateTime type, JSON does not.  The JSON serializer converts the
  dateTime type to a dateTime-formatted string.
  See also [JSON and ISO 8601 DateTime](#dateTime).

Strings are stored and exchanged in UTF-8 format in 8-bit strings (`char*`)
by using the `SOAP_C_UTFSTRING` flag.  Without this flag, 8-bit strings are
converted to UTF-8.

To force reading and writing JSON in ISO 8859-1 format, use the
`SOAP_ENC_LATIN` flag to set the context.

To read JSON from a string buffer, we suggest to use the gSOAP engine IO
`frecv` callback function as follows:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.c}
    size_t buf_recv(struct soap *ctx, char *buf, size_t len)
    {
      const char *in = (char*)ctx->user;  /* get handle to input string */
      size_t n = strlen(in);
      if (n > len) /* if in[] is larger than buf[] len */
	n = len;   /* then cap length at len */
      memcpy(buf, in, n);
      in += n;
      ctx->user = (void*)in;  /* update the handle */
      return n;
    }
    ...
    value *v = new_value(ctx);
    const char *json_in = "[ [1, \"2\", 3.14, true], {\"name\": \"john\", \"age\": 24} ]": 
    ctx->frecv = buf_recv;
    ctx->user = (void*)json_in;  /* a user handle that is passed to buf_recv */
    soap_read_value(ctx, v);
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

To write JSON to a string buffer, we suggest to use the gSOAP engine IO `fsend`
callback function as follows:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.c}
    #define BUFFER_INCREMENT (1024)
    int buf_send(struct soap *ctx, const char *buf, size_t len)
    {
      char *out = (char*)ctx->user;  /* get handle to current buffer, if any */
      size_t n = out ? strlen(out) : 0;
      size_t k = (n + len + 1)/BUFFER_INCREMENT;
      if (!out)  /* first time around? */
      {
	out = malloc((k + 1) * BUFFER_INCREMENT);
      }
      else if (n/BUFFER_INCREMENT < k)  /* need to increase buffer? */
      {
	char *more = malloc((k + 1) * BUFFER_INCREMENT);
	memcpy(more, out, n);
	free(out);
	out = more;
      }
      memcpy(out + n, buf, len);
      out[n + len] = '\0';
      ctx->user = (void*)out;
      return SOAP_OK;
    }
    ...
    value *v = new_value(ctx);
    const char *json_out;
    ... /* populate value v */
    ctx->fsend = buf_send;
    ctx->user = NULL;
    soap_write_value(ctx, v);
    json_out = (char*)ctx->user;
    if (json_out)
    {
      ... /* use json_out string */
      free(json_out);
      ctx->user = NULL;
    }
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


C JSON over HTTP (REST method)                                           {#c-jr}
------------------------------

To use JSON REST on the client side, we use `json_call`:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.c}
    #include "json.h"             /* also compile and link json.c */
    struct Namespace namespaces[] = {{NULL,NULL,NULL,NULL}}; /* no XML namespaces */

    /* SOAP_C_UTFSTRING: UTF-8 content in char*, SOAP_XML_INDENT: indent JSON */
    struct soap *ctx = soap_new1(SOAP_C_UTFSTRING | SOAP_XML_INDENT);
    struct value *request = new_value(ctx);
    struct value response;
    ... /* here we populate the request data to be send */
    if (json_call(ctx, "endpoint URL", request, response))
      ... /* error */
    ... /* use the response data */
    soap_end(ctx); /* delete all values */
    ... /* here we can make other calls etc. */
    soap_free(ctx); /* delete the context */
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The `json_call` function takes a context, an endpoint URL (with query string
parameters as needed), and optional `in` and `out` values to send and receive,
respectively.  The function returns `SOAP_OK` (zero) for success or `EOF`,
`SOAP_SYNTAX_ERROR`, or an HTTP error code.

To use the JSON REST POST method, pass both `in` and `out` values to
`json_call`.  For the GET method, pass a NULL to `in`.  For the PUT method, pass
a NULL to `out`.  For the DELETE method, pass both NULL to `in` and `out`.

Besides `json_call`, there are other JSON API functions:

- `int json_call(struct soap *ctx, const char *URL, struct value *in, struct
  value *out)` makes a POST, GET, PUT, DELETE call, returns `SOAP_OK` or error
  code.  POST method: pass both `in` and `out`.  GET method: pass a NULL to
  `in`.  PUT method: pass a NULL to `out`.  DELETE method: pass both NULL to `in`
  and `out`.

- `int json_write(struct soap *ctx, const struct value *v)` Writes JSON value
  to current file or socket.  Returns `SOAP_OK` or error.  Set current
  file/socket fd with `ctx->sendfd = fd`.

- `int json_read(struct soap *ctx, struct value *v)` Reads JSON value from
  current file or socket.  Returns `SOAP_OK` or error.  Set current file/socket
  fd with `ctx->recvfd = fd`.

The are two other lower-level functions `json_send` and `json_recv` that are
similar to `json_write` and `json_read` but do not initialize the sending and
receiving operations and do not flush after the sending and receiving
operations.

Compile and link together with `soapC.c`, `xml-rpc.c`, `json.c`, and
`stdsoap2.c`.


Miscellaneous                                                            {#misc}
=============


Floating point format                                                      {#fp}
---------------------

The floating point format used to output values in XML-RPC and JSON is by
default ".17lG' to ensure accuracy up to the last digit.  The format can be set
as follows:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.c}
    struct soap *ctx = soap_new1(SOAP_C_UTFSTRING | SOAP_XML_INDENT);
    ctx->double_format = "%lG";
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


JSON and base64                                                        {#base64}
---------------

JSON has no binary type to transmit binary data.  Sending binary data in JSON
strings as text is not recommended, due to NULs and problems with
Unicode/UTF-8 sequences.

Base64 is a common encoding format for binary data.  A JSON string with base64
content is our recommended option.

To populate JSON data with base64-encoded binary content, you can simply set
the values as described earlier (e.g.  by casting a `_base64` structure to a
value in C++).  Receiving base64-encoded content with JSON is not possible,
because the necessary type information is lost in transit.  The base64 content
will arrive at the receiver simply as a string with base64 content.

You can explicitly decode the base64 string back to binary as shown here for
C++:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}
    if (v.is_string())
    {
      /* assuming base64 content in string value v, decoded it */
      int len;
      unsigned char *ptr = soap_base642s(ctx, (const char*)v, NULL, 0, &len);
      /* ptr points to binary of length len or is NULL when decoding failed */
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

And for C:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.c}
    if (is_string(v))
    {
      /* assuming base64 content in string value v, decoded it */
      int len;
      unsigned char *ptr = soap_base642s(ctx, *string_of(v), NULL, 0, &len);
      /* ptr points to binary of length len or is NULL when decoding failed */
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


JSON and ISO 8601 dateTime                                           {#dateTime}
--------------------------

To populate JSON data with ISO 8601 date time content, you can simply set the
values as described earlier.  Receiving ISO 8601 date time content with JSON is
not possible, because the necessary type information is lost in transit.  The
content will arrive at the receiver simply as a string with a date and time.

You can explicitly convert a string with an ISO 8601 date time to a `time_t`
value as shown here for C++:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}
    if (v.is_string())
    {
      time_t tm;
      if (soap_s2dateTime(ctx, (const char*)v, &tm) == SOAP_OK)
	... // success
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

And for C:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.c}
    if (is_string(v))
    {
      time_t tm;
      if (soap_s2dateTime(ctx, *string_of(v), &tm) == SOAP_OK)
	... // success
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

