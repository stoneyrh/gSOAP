/*
        jsoncpp.cpp
        
	A simple JSON code generator.
	Takes a JSON sample document and renders it in JSON API code.

	Example JSON menu from http://json.org/example.html

	echo '\
	{ "menu": {\
	    "id": "file",\
	    "value": "File",\
	    "popup": {\
	      "menuitem": [\
	        {"value": "New", "onclick": "CreateNewDoc()"},\
	        {"value": "Open", "onclick": "OpenDoc()"},\
	        {"value": "Close", "onclick": "CloseDoc()"}\
	      ]\
	    }\
	  }\
	}' | ./jsoncpp

	#include "json.h"
	{ // C++ code generated by jsoncpp from stdin
	  soap *ctx = soap_new1(SOAP_C_UTFSTRING | SOAP_XML_INDENT);
	  value v(ctx);

	  v["menu"]["id"] = "file";
	  v["menu"]["value"] = "File";
	  v["menu"]["popup"]["menuitem"][0]["value"] = "New";
	  v["menu"]["popup"]["menuitem"][0]["onclick"] = "CreateNewDoc()";
	  v["menu"]["popup"]["menuitem"][1]["value"] = "Open";
	  v["menu"]["popup"]["menuitem"][1]["onclick"] = "OpenDoc()";
	  v["menu"]["popup"]["menuitem"][2]["value"] = "Close";
	  v["menu"]["popup"]["menuitem"][2]["onclick"] = "CloseDoc()";

	  std::cout << v;

	  soap_destroy(ctx);
	  soap_end(ctx);
	  soap_free(ctx);
	}

--------------------------------------------------------------------------------
gSOAP XML Web services tools
Copyright (C) 2000-2015, Robert van Engelen, Genivia, Inc. All Rights Reserved.
This software is released under one of the following two licenses:
GPL or Genivia's license for commercial use.
--------------------------------------------------------------------------------
GPL license.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; either version 2 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA 02111-1307 USA

Author contact information:
engelen@genivia.com / engelen@acm.org
--------------------------------------------------------------------------------
A commercial use license is available from Genivia, Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#include "json.h"
#include <fstream>
#include <iomanip>

static bool coutput = false;		// -c: C output instead of C++
static bool addmain = false;		// -m: add main()
static bool optimize = false;		// -O: optimize
static const char *ifile = NULL;	// [infile]
static const char *ofile = NULL;	// -ofile

static std::ostream& indent(soap*, int);
static void generate_c(soap*, value&, std::string, int);
static void generate_cpp(soap*, value&, std::string, int);

int main(int argc, char **argv)
{
  if (argc >= 2)
  {
    for (int i = 1; i < argc; i++)
    {
      const char *a = argv[i];
      if (*a == '-'
#ifdef WIN32
	|| *a == '/'
#endif
	 )
      {
	bool f = true;
	while (f && *++a)
	{
	  switch (*a)
	  {
	    case 'c':
	      coutput = true;
	      break;
	    case 'm':
	      addmain = true;
	      break;
	    case 'O':
	      optimize = true;
	      break;
	    case 'o':
	      a++;
	      f = false;
	      if (*a)
		ofile = a;
	      else if (i < argc)
		ofile = argv[++i];
	      break;
	    case '?':
	    case 'h':
	      fprintf(stderr,
		  "Usage: jsoncpp [-c] [-m] [-O] [-ofile] [infile]\n\n"
		  "-c      generate C code instead of C++\n"
		  "-m      add main()\n"
		  "-O      optimize code by reducing the operation count\n"
		  "-ofile  save to file\n"
		  "infile  JSON file to parse\n\n");
	      exit(0);
	    default:
	      fprintf(stderr, "jsoncpp: Unknown option %s\n", a);
	      exit(1);
	  }
	}
      }
      else
      {
	ifile = argv[i];
      }
    }
  }

  soap *ctx = soap_new1(SOAP_C_UTFSTRING);

  std::ifstream ifs;

  if (ifile)
  {
    ifs.open(ifile, std::ifstream::in);
    if (!ifs.is_open())
    {
      fprintf(stderr, "Cannot open %s for reading\n", ifile);
      exit(1);
    }
    ctx->is = &ifs;
  }

  std::ofstream ofs;

  if (ofile)
  {
    ofs.open(ofile, std::ofstream::out);
    if (!ofs.is_open())
    {
      fprintf(stderr, "Cannot open %s for writing\n", ofile);
      exit(1);
    }
    ctx->os = &ofs;
  }
  else
  {
    ctx->os = &std::cout;
  }

  value v(ctx);

  if (json_read(ctx, v))
  {
    soap_print_fault(ctx, stderr);
    soap_print_fault_location(ctx, stderr);
    exit(1);
  }

  if (ifile)
    ifs.close();

  *ctx->os << "\n#include \"json.h\"\n";

  if (addmain)
    *ctx->os << "struct Namespace namespaces[] = {{NULL,NULL,NULL,NULL}};\nint main()\n";

  if (coutput)
    *ctx->os <<
      "{ /* C code generated by jsoncpp from " << (ifile ? ifile : "stdin") << " */\n"
      "  struct soap *ctx = soap_new1(SOAP_C_UTFSTRING | SOAP_XML_INDENT);\n"
      "  struct value *v = new_value(ctx);\n\n";
  else
    *ctx->os <<
      "{ // C++ code generated by jsoncpp from " << (ifile ? ifile : "stdin") << "\n"
      "  soap *ctx = soap_new1(SOAP_C_UTFSTRING | SOAP_XML_INDENT);\n"
      "  value v(ctx);\n\n";

  if (optimize)
  {
    if (coutput)
      *ctx->os << "  struct value *r = v;\n";
    else
      *ctx->os << "  value *r = &v;\n";
  }

  if (coutput)
    generate_c(ctx, v, "v", 2);
  else
    generate_cpp(ctx, v, "v", 2);

  if (coutput)
    *ctx->os <<
      "\n"
      "  json_write(ctx, v);\n\n"
      "  soap_end(ctx);\n"
      "  soap_free(ctx);\n"
      << (addmain ? "  return 0;\n" : "") <<
      "}\n"
      "/* Dependencies:\n"
      "     json.h xml-rpc-iters.h soapH.h soapStub.h stdsoap2.h\n"
      "     json.c xml-rpc.c soapC.c stdsoap2.c\n"
      "   Build:\n"
      "     soapcpp2 -c -CSL xml-rpc.h\n"
      "     cc ... json.c xml-rpc.c soapC.c stdsoap2.c ...\n"
      "*/\n\n";
  else
    *ctx->os <<
      "\n"
      "  std::cout << v;\n\n"
      "  soap_destroy(ctx);\n"
      "  soap_end(ctx);\n"
      "  soap_free(ctx);\n"
      << (addmain ? "  return 0;\n" : "") <<
      "}\n"
      "// Dependencies:\n"
      "//   json.h xml-rpc-iters.h soapH.h soapStub.h stdsoap2.h\n"
      "//   json.cpp xml-rpc.cpp soapC.cpp stdsoap2.cpp\n"
      "// Build:\n"
      "//   soapcpp2 -CSL xml-rpc.h\n"
      "//   c++ ... json.cpp xml-rpc.cpp soapC.cpp stdsoap2.cpp ...\n\n";

  if (ofile)
    ofs.close();

  soap_destroy(ctx);
  soap_end(ctx);
  soap_free(ctx);

  return 0;
}

static std::ostream& indent(soap *ctx, int k)
{
  *ctx->os << std::setw(k) << "" << std::setw(0);
  return *ctx->os;
}

static void generate_c(soap *ctx, value& v, std::string lhs, int k)
{
  switch (v.__type)
  {
    case SOAP_TYPE__boolean:
      if (optimize)
      {
	indent(ctx, k) << "/* r = " << lhs << "*/\n";
	indent(ctx, k) << "*bool_of(r) = " << (v.is_true() ? 1 : 0) << ";\n";
      }
      else
      {
	indent(ctx, k) << "*bool_of(" << lhs << ") = " << (v.is_true() ? 1 : 0) << ";\n";
      }
      break;
    case SOAP_TYPE__i4:
    case SOAP_TYPE__int:
      if (optimize)
      {
	indent(ctx, k) << "/* r = " << lhs << " */\n";
	indent(ctx, k) << "*int_of(r) = ";
      }
      else
      {
	indent(ctx, k) << "*int_of(" << lhs << ") = ";
      }
      json_send(ctx, v);
      *ctx->os << ";\n";
      break;
    case SOAP_TYPE__double:
      if (optimize)
      {
	indent(ctx, k) << "/* r = " << lhs << " */\n";
	indent(ctx, k) << "*double_of(r) = ";
      }
      else
      {
	indent(ctx, k) << "*double_of(" << lhs << ") = ";
      }
      json_send(ctx, v);
      *ctx->os << ";\n";
      break;
    case SOAP_TYPE__string:
      if (optimize)
      {
	indent(ctx, k) << "/* r = " << lhs << " */\n";
	indent(ctx, k) << "*string_of(r) = ";
      }
      else
      {
	indent(ctx, k) << "*string_of(" << lhs << ") = ";
      }
      json_send(ctx, v);
      *ctx->os << ";\n";
      break;
    case SOAP_TYPE__struct:
    {
      if (optimize)
      {
	indent(ctx, k) << "{\n";
	k += 2;
        indent(ctx, k) << "struct value *s = r;\n";
      }
      _struct& s = v;
      for (_struct::iterator i = s.begin(); i != s.end(); ++i)
      {
	std::string lhsidx = "value_at(";
	lhsidx.append(lhs).append(", \"").append(i.index()).append("\")"); // TODO later: i.index() name is not formatted
	if (optimize)
	{
	  indent(ctx, k) << "r = value_at(s, ";
	  json_send_string(ctx, i.index());
	  *ctx->os << ");\n";
	}
	generate_c(ctx, *i, lhsidx, k);
      }
      if (optimize)
      {
	indent(ctx, k) << "r = s;\n";
	k -= 2;
	indent(ctx, k) << "}\n";
      }
      break;
    }
    case SOAP_TYPE__array:
    {
      if (optimize)
      {
	indent(ctx, k) << "{\n";
	k += 2;
        indent(ctx, k) << "struct value *a = r;\n";
      }
      _array& a = v;
      for (_array::iterator i = a.begin(); i != a.end(); ++i)
      {
	std::string lhsidx = "nth_value(";
	lhsidx.append(lhs).append(", ").append(soap_int2s(ctx, i.index())).append(")");
	if (optimize)
	  indent(ctx, k) << "r = nth_value(a, " << i.index() << ");\n";
	generate_c(ctx, *i, lhsidx, k);
      }
      if (optimize)
      {
	indent(ctx, k) << "r = a;\n";
	k -= 2;
	indent(ctx, k) << "}\n";
      }
      break;
    }
    default:
      break;
  }
}

static void generate_cpp(soap *ctx, value& v, std::string lhs, int k)
{
  switch (v.__type)
  {
    case SOAP_TYPE__boolean:
    case SOAP_TYPE__i4:
    case SOAP_TYPE__int:
    case SOAP_TYPE__double:
    case SOAP_TYPE__string:
      if (optimize)
      {
	indent(ctx, k) << "/* r = &" << lhs << " */\n";
	indent(ctx, k) << "*r = ";
      }
      else
      {
	indent(ctx, k) << lhs << " = ";
      }
      json_send(ctx, v);
      *ctx->os << ";\n";
      break;
    case SOAP_TYPE__struct:
    {
      if (optimize)
      {
	indent(ctx, k) << "{\n";
	k += 2;
        indent(ctx, k) << "value *s = r;\n";
      }
      _struct& s = v;
      for (_struct::iterator i = s.begin(); i != s.end(); ++i)
      {
	std::string lhsidx = lhs;
	lhsidx.append("[\"").append(i.index()).append("\"]");
	if (optimize)
	{
	  indent(ctx, k) << "r = &(*s)[";
	  json_send_string(ctx, i.index());
	  *ctx->os << "];\n";
	}
	generate_cpp(ctx, *i, lhsidx, k);
      }
      if (optimize)
      {
	indent(ctx, k) << "r = s;\n";
	k -= 2;
	indent(ctx, k) << "}\n";
      }
      break;
    }
    case SOAP_TYPE__array:
    {
      if (optimize)
      {
	indent(ctx, k) << "{\n";
	k += 2;
        indent(ctx, k) << "value *a = r;\n";
      }
      _array& a = v;
      for (_array::iterator i = a.begin(); i != a.end(); ++i)
      {
	std::string lhsidx = lhs;
	lhsidx.append("[").append(soap_int2s(ctx, i.index())).append("]");
	if (optimize)
	  indent(ctx, k) << "r = &(*a)[" << i.index() << "];\n";
	generate_cpp(ctx, *i, lhsidx, k);
      }
      if (optimize)
      {
	indent(ctx, k) << "r = a;\n";
	k -= 2;
	indent(ctx, k) << "}\n";
      }
      break;
    }
    default:
      break;
  }
}

struct Namespace namespaces[] = {{NULL,NULL,NULL,NULL}};
