
Test Messenger                                                       {#mainpage}
==============

[TOC]

Introduction                                                            {#intro}
============

It is important to test Web services and client applications as part of the
quality assurance process.  Furthermore, the functional and non-functional
requirements of an application should be verified and tested.  Testing Web
services with randomized message exchange patterns can help to pinpoint
problems early on, before application are deployed.

The Test Messenger is an application to test Web services by sending
(randomized) XML test messages to services and client applications.  The Test
Messenger application is simply executed from the command line or from a shell
script, such as a script intended to test services and clients.  No coding is
required to use the Test Messenger.

The testmsgr Test Messenger application is located in the gSOAP distribution
package under `gsoap/samples/testmsgr` and is built with:

    cd gsoap/samples/testmsgr
    make

To generate randomized XML messages with the Test Messenger, a SOAP/XML message
template is required.  The Test Messenger populates the template with random
values to send the randomly populated SOAP/XML request message to a service or
return the randomly populated response message to a client.

Options are available to further randomize the messages by randomly removing
attributes and elements at a specific rate of chance, or to add random spacing
to XML attribute and element values, and to continuously test a service until
it fails.

You can create a SOAP/XML message template manually or auto-generate it with
soapcpp2 option `-g`.  For example, to auto-generate XML sample message
templates from an interface header file simply use soapcpp2 with option `-g`:

    soapcpp2 -g file.h

The soapcpp2 tool generates sample messages for the service operations defined
in `file.h`.  Option `-g` changes the sample message to message templates that
contain placeholders of the form `%[...]%`.  A placeholder specifies an
XSD-related type, enumeration, or numeric range.  These placeholders are
populated by the Test Messenger using random values that conform to the
placeholder's specified value type.

Note that `file.h` is usually generated with wsdl2h from a set of WSDL and XSD
files, but it can also be developed manually, for example to define new
services.

While the sample messages generated by soapcpp2 (without option `-g`) can be
used to test clients and services as explained in the gSOAP user guide, the
problem is that the content of the sample messages is always fixed.  This
provides only very limited testing capabilities.  By contrast, the Test
Messenger application generates randomized messages based on SOAP/XML message
templates for enhanced testing of client and service applications.

The Test Messenger is intended to test common messaging scenarios that are
defined by SOAP/XML message templates.  The Test Messenger does not add
(random) XML attributes and elements that are not in the message template.  It
can randomly remove attributes and elements with option `-p`.  Tools that
generate SOAP/XML messages from WSDL/XSD specifications can produce a wider
range of test messages.  The benefit of the Test Messenger is the ability to
create a consistent set of message templates for unit and regression testing,
with specific randomization of attribute and element values, as needed.

To demonstrate the Test Messenger, assume we have the following services
declared in the interface `file.h`:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}
    //gsoap ns service name:      example
    //gsoap ns service namespace: urn:example

    #import "custom/struct_tm.h"        // use struct tm for xsd:dateTime

    typedef std::string xsd__ID;        // declare xsd:ID type (whitespace collapsed)
    typedef std::string xsd__Name;      // declare xsd:Name type (whitespace collapsed)
    typedef xsd__Name ns__name 1:80;    // restrict xsd:Name to a name with 1 to 80 chars
    typedef float ns__miles 0: ;        // restrict xsd:float to non-negative

    enum ns__gender { male, female };

    struct ns__person
    {
      @xsd__ID        id;
      ns__name        firstname;
      ns__name        lastname;
      xsd__dateTime   dob;
      enum ns__gender gender;
      ns__miles       miles;
    };

    int ns__upload(struct ns__person *person, xsd__ID& id);   // upload to DB

    int ns__download(xsd__ID id, struct ns__person& person);  // download from DB
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

We run soapcpp2 on this interface `file.h` with option `-g`:

    soapcpp2 -g file.h

This produces the following SOAP/XML template files among other source code
files:

- `example.upload.req.xml` XML template upload request message
- `example.download.req.xml` XML template download request message
- `example.upload.res.xml` XML template upload response message
- `example.download.res.xml` XML template download response message

The `example.upload.req.xml` file looks like this:

<div class="alt">
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    <?xml version="1.0" encoding="UTF-8"?>
    <SOAP-ENV:Envelope
      xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/"
      xmlns:SOAP-ENC="http://schemas.xmlsoap.org/soap/encoding/"
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xmlns:xsd="http://www.w3.org/2001/XMLSchema"
      xmlns:ns="urn:example">
     <SOAP-ENV:Body>
      <ns:upload>
       <person id="%[[ID]]%">
        <firstname>%[[TEXT[1:80]]]%</firstname>
        <lastname>%[[TEXT[1:80]]]%</lastname>
        <dob>%[[DATETIME]]%</dob>
        <gender>%[[male|female]]%</gender>
        <miles>%[[0.000000E+00:1.797693E+308]]%</miles>
       </person>
      </ns:upload>
     </SOAP-ENV:Body>
    </SOAP-ENV:Envelope>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</div>

Note that XML values in this template are represented by value placeholders of
the form `%[...]%`.  For the full list of placeholders that can be used, see
\ref placeholder.

This message template is read and populated by testmsgr as follows:

    ./testmsgr -r1 -i example.upload.req.xml

<div class="alt">
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    Random seed = 1

    <SOAP-ENV:Envelope xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/" xmlns:SOAP-ENC="http://schemas.xmlsoap.org/soap/encoding/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:ns="urn:example">
     <SOAP-ENV:Body>
      <ns:upload>
       <person id="BAmlkjihg9876543210v.-zyxwvutsrqponmlkjihgfedcbas_qponZYXWVUTSRQPONMLKJIHGFEDCBAmlkjihg9876543210v.-zyxwvutsrqponmlkjihgfedcbas_qponZYXWVUTSRQPONMLKJIHGFEDCBAmlkjihg9876543210v.-zyxwvutsrqponmlkjihgfedcbas_qponZYXWVUTSRQPONMLKJIHGFEDCBAmlkjihg9876543210v.">
        <firstname>ghefklij_spqcdabWXUVnoYZOPMNSTQRGHEFKLIJlmjkCDAB7856hi9gv0</firstname>
        <lastname>QRSTMNOPYZnoUVWXabcdpq_sijklefgh1234</lastname>
        <dob>1969-12-31T23:59:59Z</dob>
        <gender>female</gender>
        <miles>8255613886394.9941</miles>
       </person>
      </ns:upload>
     </SOAP-ENV:Body>
    </SOAP-ENV:Envelope>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</div>

This produces a randomized SOAP/XML message to standard output.  Option `-r1`
sets the random seed to `1`.  Any seed value between 1 and 2147483647 can be
used.  Option `-i` displays the randomized XML with indentation.

To send the randomized SOAP/XML message to a service endpoint, pass the
endpoint URL as the last argument to the testmsgr command:

    ./testmsgr -r1 -i example.upload.req.xml http://www.example.com/service

For example, we can let soapcpp2 generate a simple test service to which we can
send test messages, as explained in the following steps.

First we invoke soapcpp2 to generate the server-side code we need:

    soapcpp2 -g -SL -T file.h

This generates the SOAP/XML message templates and the following source code
files:

- `soapStub.h` annotated copy of the source interface file
- `soapH.h` serialization functions
- `soapC.cpp` serialization functions
- `soapServer.cpp` service request dispatcher
- `soapTester.cpp` auto-test echo server

Next, compile these files together with the gSOAP library and the custom
serializer for `struct tm` to build a simple echo server:

    c++ -I. -o echoserver soapTester.cpp soapServer.cpp soapC.cpp stdsoap2.cpp custom/struct_tm.c

Now run the server.  For example on port 8080, with 8192 to set the
`SOAP_XML_INDENT` engine context flag:

    ./echoserver 8192 8080

Finally, let's fire a randomized message to the service, using the
auto-generated `example.upload.req.xml` message template:

    ./testmsgr -r1 example.upload.req.xml http://localhost:8080

<div class="alt">
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    Random seed = 1
    Server response:

    ---- begin ----
    <?xml version="1.0" encoding="UTF-8"?>
    <SOAP-ENV:Envelope xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/" xmlns:SOAP-ENC="http://schemas.xmlsoap.org/soap/encoding/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:ns="urn:example">
            <SOAP-ENV:Body>
                    <ns:uploadResponse>
                            <id></id>
                    </ns:uploadResponse>
            </SOAP-ENV:Body>
    </SOAP-ENV:Envelope>

    ---- end ----
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</div>

The testmsgr displays the response received from the server, which for the
simple echo service upload request is the upload response with an id element.

To send a continuous stream of randomized message to the server, use option
`-c`:

    ./testmsgr -c -r1 example.upload.req.xml http://localhost:8080

This continous until the service fails.  A test is reproduced by using its
random seed.  So if the service fails you can replicate the message with the
random seed and option `-r` with this seed value.

The Test Messenger application can also send pruned XML messages with option
`-p`.  Pruning means that attributes and elements are randomly omitted, which
allows for testing the robustness of the service against incomplete and
malformed SOAP/XML content:

    ./testmsgr -c -p100 -r1 example.upload.req.xml http://localhost:8080

Option `-p100` means a one in 100 change that an attribute or element is
omitted from the SOAP/XML template `example.upload.req.xml`.

When testing the auto-test echo service, the echo service displays failed
requests and is silent for successful requests.

For the full list of testmsgr options, see \ref options.

Using testmsgr                                                          {#using}
==============

The testmsgr command takes a set of options, a SOAP/XML message file or a
message template file (i.e. to randomize with option `-r`), and an optional
service endpoint URL.

Installing testmsgr                                                     {#build}
-------------------

To build testmsgr, [install gSOAP](http://www.genivia.com/downloads.html) and
build testmsgr as follows:

    cd gsoap/samples/testmsgr
    make testmsgr

This builds the command-line tool testmsgr in `gsoap/samples/testmsgr` from where you
can use it and/or copy it for use with your projects.

If you do not have the samples built, you can use soapcpp2 (or soapcpp2.exe
in `gsoap/bin/win32`) from the command line to generate the C++ code required
for testmsgr:

    cd gsoap/samples/testmsgr
    soapcpp2 -CSL ../../import/dom.h
    c++ -I../.. -o testmsgr testmsgr.cpp soapC.cpp ../../dom.cpp ../../stdsoap2.cpp

This builds the testmsgr command-line tool.

Server-side testing                                                    {#server}
-------------------

To test services, run testmsgr against the service endpoint URL, for example
when the service runs on the localhost on port 8080:

    ./testmsgr -r99 example.upload.req.xml http://localhost:8080

When using https endpoints, you must build testmsgr with compile-time flag
`WITH_OPENSSL` and link OpenSSL as follows:

    soapcpp2 -CSL ../../import/dom.h
    c++ -DWITH_OPENSSL -o testmsgr testmsgr.cpp soapC.cpp ../../dom.cpp ../../stdsoap2.cpp -lssl -lcrypto

For CGI-based services that read SOAP/XML requests from standard input you can
redirect the (randomized) message to the CGI-based service.  For example:

    ./testmsgr -r99 example.upload.req.xml | ./echoserver

where echoserver is a CGI-based service (the echoserver built in the \ref intro
uses CGI by default).

Client-side testing                                                    {#client}
-------------------

To test clients, run testmsgr as a stand-alone server by specifying a port
number instead of a service endpoint URL:

    ./testmsgr -r1 example.download.res.xml 8080

This runs the Test Messenger on port 8080.  The Test Messenger discards request
messages sent by clients and returns randomized responses using the SOAP/XML
`example.download.res.xml` response message template.

You can also use file redirection to test clients when your client uses the
"http://" endpoint URL without a domain.  By using this URL your client writes
HTTP messages to standard output and reads HTTP responses from standard input.
For example:

    ./testmsgr -r1 example.download.res.xml > response.xml
    ./client < response.xml > /dev/null

Options                                                               {#options}
-------

    testmsgr [-aact] [-b] [-c] [-h] [-i] [-j] [-mmax] [-nlen] [-pnum] [-rseed] [-ssec] [-v] [infile|-] [URL|port]

where the testmsgr command-line options are:

| Option   | Description                                                     |
| -------- | --------------------------------------------------------------- |
| `-aact`  | use HTTP SOAP Action header value `"act"`                       |
| `-b`     | add random spacing to randomized values when using option `-r`  |
| `-c`     | continue testing until the service endpoint fails               |
| `-h`     | display help message                                            |
| `-i`     | indent XML with spaces when using option `-r`                   |
| `-j`     | indent XML with tabs when using option `-r`                     |
| `-mmax`  | max length of randomized text values generated (default is 255) |
| `-nlen`  | display the server response up to len bytes                     |
| `-pnum`  | prune XML randomly with 1:num chance when using option `-r`     |
| `-rseed` | randomize XML message templates (use soapcpp2 `-g`)             |
| `-ssec`  | socket idle timeout seconds (default is one second)             |
| `-v`     | verbose mode                                                    |
| `infile` | XML message template                                            |
| `-`      | read XML from standard input                                    |
| `URL`    | endpoint URL of service to test                                 |
| `port`   | stand-alone server port for clients to test                     |

More specifically, `infile` is an SOAP/XML message file (or message template
file), `-` specifies that the message should be read from standard input, and
`URL` is the optional service endpoint to send (randomized) messages to.  When
a `port` number is specified instead of a URL, testmsgr runs as a stand-alone
application to test clients that connect to it.  A client application receives
the (randomized) message generated by testmsgr from the specified SOAP/XML
message file (or message template file).

### `-aact`

Use HTTP SOAP Action header value `"act"` with the SOAP request messages sent.
This option is required for services that require a SOAP Action header.

### `-b`

Add random blank spacing to randomized values when using option `-r`.

### `-c`

Continue testing of a service until the service fails, i.e. until the server at
the specified endpoint URL becomes unresposive.

### `-h`

Display help message.

### `-i`

Indent XML with spaces when using option `-r`.

### `-j`

Indent XML with tabs when using option `-r`.

### `-mmax`

Specifies the max length of randomized text values generated when using option
`-r`.  The default is 255.  The maximum value that can be specified is
18446744073709551615.

### `-nlen`

Display the server response up to `len` bytes.  `-n0` removes the server
responses.  Omitting this option displays the full response.

### `-pnum`

Prune XML randomly when using option `-r`.  XML attributes and elements are
removed with a one in `num` chance.  For example, if a message has 100 XML
elements then `-p100` likely removes one or more of these elements.

### `-rseed`

Randomize the SOAP/XML message template given as the `infile` argument.
SOAP/XML message templates can be auto-generated with soapcpp2 option `-g`.
The `seed` value is required and is used to reproduce test messages. Any
positive seed value can be specified, from 1 up to 2147483647.

### `-ssec`

Specify a socket idle timeout in seconds.  The default is one second.  A
service is considered unresponsive when a socket timeout occurs while messages
are exchanged.

### `-v`

Enable verbose mode.

Template placeholder values                                       {#placeholder}
---------------------------

A SOAP/XML message template file is required when sending randomized messages
with testmsgr option `-r`.  The SOAP/XML message template file can be
auto-generated with soapcpp2 option `-g` on a interface file.  This interface
file is usually generated with wsdl2h from a (set of) WSDL and XSD file(s).
Note that option `-g` does not produce SOAP/XML message templates if the
interface file does not declare any service operations.

### Enumeration templates

`%[[A][B][C]]%` specifies a choice of values `A`, `B` or `C`.  The values can be
anything but should not contain `][` or `]]%`.

### Numeric range templates

A numeric range is integer-valued when the lower bound `N` and upper bound `M`
are integer.  Otherwise, the numeric range values are floating point.  For
example, `%[[0:10]]%` speficies a range of integer values whereas
`%[[0.0:10.0]]%` specifies a range of floating point values.  The bounds of a
numeric range can be made exlusive by using `(` and `)` instead of `[` and `]`.

`%[[N:M]]%` specifies a range of integer or float values between `N` and `M`.

`%[[N:M)]%` specifies a range of integer or float values between `N` and `M` (exclusive).

`%[(N:M]]%` specifies a range of integer or float values between `N` (exclusive) and `M`.

`%[(N:M)]%` specifies a range of integer or float values between `N` (exclusive) and `M` (exclusive).

### Primitive XSD type templates

`%[[BASE64]]%` and length-restricted `%[[BASE64[N:M]]]%` specify
xsd:base64Binary XSD values.  The length restriction `N:M` specifies the range
of base64-encoded bytes.

`%[[BOOL]]%` specifies xsd:boolean XSD values.

`%[[DATE]]%` specifies xsd:date XSD values.

`%[[DATETIME]]%` specifies xsd:dateTime XSD values.

`%[[DOUBLE]]%` specifies xsd:double XSD values.

`%[[DURATION]]%` specifies xsd:duration XSD values.

`%[[HEX]]%` and length-restricted `%[[HEX[N:M]]]%` specify xsd:hexBinary XSD
values.  The length restriction `N:M` specifies the range of encoded bytes, not
the number of hexadecimal characters.

`%[[ENTITY]]%` and length-restricted `%[[ENTITY[N:M]]]%` specify xsd:ENTITY XSD
values.  The range `N:M` specifies the number of characters.

`%[[ID]]%` and length-restricted `%[[ID[N:M]]]%` specify xsd:ID XSD values.
The range `N:M` specifies the number of characters.

`%[[IDREF]]%` and length-restricted `%[[IDREF[N:M]]]%` specify xsd:IDREF XSD
values.  The range `N:M` specifies the number of characters.

`%[[FLOAT]]%` specifies xsd:float XSD values.

`%[[INT8]]%` and `%[[BYTE]]%` specify xsd:byte XSD values.

`%[[INT16]]%` and `%[[SHORT]]%` specify xsd:short XSD values.

`%[[INT32]]%` and `%[[INT]]%` specify xsd:int XSD values.

`%[[INT64]]%` and `%[[LONG]]%` specify xsd:long XSD values.

`%[[LANG]]%` specifies xsd:language XSD values.

`%[[NAME]]%` and length-restricted `%[[NAME[N:M]]]%` specify xsd:Name XSD
values.  The range `N:M` specifies the number of characters.

`%[[NCNAME]]%` and length-restricted `%[[NCNAME[N:M]]]%` specify xsd:NCName XSD
values.  The range `N:M` specifies the number of characters.

`%[[NMTOKEN]]%` and length-restricted `%[[NMTOKEN[N:M]]]%` specify xsd:NMTOKEN
XSD values.  The range `N:M` specifies the number of characters.

`%[[TEXT]]%` and length-restricted `%[[TEXT[N:M]]]%` specify xsd:string,
xsd:normalizedString, xsd:anyURI, xsd:NOTATION, and xsd:token XSD values.  The
range `N:M` specifies the number of characters.

`%[[TIME]]%` specifies xsd:time XSD values.

`%[[QNAME]]%` specifies xsd:QName XSD values.

`%[[UINT8]]%` and `%[[UBYTE]]%` specify xsd:unsignedByte XSD values.

`%[[UINT16]]%` and `%[[USHORT]]%` specify xsd:unsignedShort XSD values.

`%[[UINT32]]%` and `%[[UINT]]%` specify xsd:unsignedInt XSD values.

`%[[UINT64]]%` and `%[[ULONG]]%` specify xsd:unsignedLong XSD values.

Copyright                                                           {#copyright}
=========

Copyright (c) 2017, Robert van Engelen, Genivia Inc. All rights reserved.
