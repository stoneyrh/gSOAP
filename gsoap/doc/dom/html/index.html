<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3"/>
<title>gSOAP level-2 DOM: The gSOAP level-2 DOM parser</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">gSOAP level-2 DOM
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">The gSOAP level-2 DOM parser </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The gSOAP level-2 DOM parser features "smart" XML namespace handling and can be used to mix gSOAP XML serializers with plain XML parsing. The DOM parser is also an essential component of the wsse plugin to verify digital signatures.</p>
<p>The DOM parser is not a stand-alone application. The DOM parser is integrated with the SOAP engine to populate a node set and to render a node set in XML.</p>
<p>Two files are needed to work with DOM node sets:</p>
<ul>
<li><a class="el" href="dom_8h.html">dom.h</a> to use a DOM node set in a gSOAP header file with service definitions.</li>
<li>dom.cpp (or dom.c) to be linked with your application code.</li>
</ul>
<h1><a class="anchor" id="dom_1"></a>
Declaring DOM Node Sets in a gSOAP Header File</h1>
<p>To use the DOM node set with the data structures defined in a gSOAP header file, import the <a class="el" href="dom_8h.html">dom.h</a> file into your header file:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#import &quot;<a class="code" href="dom_8h.html">dom.h</a>&quot;</span></div>
</div><!-- fragment --><p>By importing <a class="el" href="dom_8h.html">dom.h</a> two special data types <a class="el" href="dom_8h.html#a7c2d9a8469bd81160806057f9cecd3f4">xsd__anyType</a> and <a class="el" href="dom_8h.html#a93b1eb303f736722858eb0d30c9b5dd1">xsd__anyAttribute</a> are available representing a hierarchical DOM node set of elements and attributes, respectively. The DOM node element and attribute data structures can be used within structs, classes, STL containers, and as arguments of service operations. For example:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#import &quot;<a class="code" href="dom_8h.html">dom.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#import &quot;wsu.h&quot;</span></div>
<div class="line"><span class="keyword">class </span>ns__myProduct</div>
<div class="line">{ <span class="keyword">public</span>:</div>
<div class="line">    @<span class="keywordtype">char</span>*               wsu__Id;</div>
<div class="line">    @<a class="code" href="dom_8h.html#a93b1eb303f736722858eb0d30c9b5dd1" title="The custom serializer for DOM attribute nodes is represented by xsd__anyAttribute.">xsd__anyAttribute</a>   atts;</div>
<div class="line">    _wsu__Timestamp*     wsu__Timestamp;</div>
<div class="line">    <span class="keywordtype">char</span>*                name;</div>
<div class="line">    <span class="keywordtype">int</span>                  SKU;</div>
<div class="line">    <span class="keywordtype">double</span>               price;</div>
<div class="line">    <a class="code" href="dom_8h.html#a7c2d9a8469bd81160806057f9cecd3f4" title="The custom serializer for DOM element nodes is represented by xsd__anyType.">xsd__anyType</a>*        elts;</div>
<div class="line">                         ns__myProduct();</div>
<div class="line">                         ~ns__myProduct();</div>
<div class="line">};</div>
</div><!-- fragment --><p>It is important to declare the <a class="el" href="dom_8h.html#a7c2d9a8469bd81160806057f9cecd3f4">xsd__anyType</a> at the end of the struct or class, since the DOM parser consumes any XML element (the field name, 'elts' in this case, is irrelavant). Thus, the other fields must be defined first to ensure they are populated first before the DOM node set is populated with any non-previously matched XML element. Likewise, the <a class="el" href="dom_8h.html#a93b1eb303f736722858eb0d30c9b5dd1">xsd__anyAttribute</a> member should be placed after the other attributes.</p>
<p>Note that we also imported wsu.h as an example to show how to add a wsu:Id attribute to a struct or class if we want to digitally sign instances, and how to add a standardized wsu:Timestamp element to record creation and expiration times.</p>
<p>To compile, run soapcpp2 (with -Iimport) and compile your code by linking dom.cpp (or dom.c for C). Note that the DOM data structures are declared in stdsoap2.h, while the DOM operations are defined in dom.cpp (or dom.c for C).</p>
<p>Methods to populate and traverse DOM node sets will be explained later. First, let's take a look at parsing and generating XML documents.</p>
<h1><a class="anchor" id="dom_2"></a>
Parsing and Generating XML</h1>
<p>The following examples assume that the soapcpp2 compiler was used on a header file (just the <a class="el" href="dom_8h.html">dom.h</a> file will do) and the generated soapC.cpp or (soapC.c for C) code was compiled and linked with dom.cpp (or dom.c for C), stdsoap2.cpp (or stdsoap2.c) and the example application code. The generated namespace table should also be used, since the namespace bindings are relevant for consuming and producing XML for DOM node sets. Therefore, each of the example codes in this documentation is assumed to start with the following two includes:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;soapH.h&quot;</span>  <span class="comment">// generated by soapcpp2</span></div>
<div class="line"><span class="preprocessor">#include &quot;ns.nsmap&quot;</span> <span class="comment">// a namespace table with the XML namespace used</span></div>
</div><!-- fragment --><p>The C++ std::iostream operators are overloaded to parse XML octet streams into node sets and to emit XML from node sets:</p>
<div class="fragment"><div class="line">soap_dom_element dom;</div>
<div class="line">dom.soap = soap_new1(SOAP_DOM_TREE | SOAP_C_UTFSTRING);</div>
<div class="line">cin &gt;&gt; dom; <span class="comment">// parse XML</span></div>
<div class="line"><span class="keywordflow">if</span> (dom.soap-&gt;error)</div>
<div class="line">  ... <span class="comment">// parse error</span></div>
<div class="line">cout &lt;&lt; dom; <span class="comment">// display XML</span></div>
<div class="line"><span class="keywordflow">if</span> (dom.soap-&gt;error)</div>
<div class="line">  ... <span class="comment">// output error</span></div>
<div class="line">soap_destroy(dom.soap);</div>
<div class="line">soap_end(dom.soap);</div>
<div class="line">soap_done(dom.soap);</div>
<div class="line">free(dom.soap);</div>
</div><!-- fragment --><p>In the example above we copied an XML document from stdin to stdout.</p>
<p>In C we use the DOM "serializers" to accomplish this as follows:</p>
<div class="fragment"><div class="line">soap_dom_element dom;</div>
<div class="line">dom.soap = soap_new1(SOAP_DOM_TREE | SOAP_C_UTFSTRING);</div>
<div class="line">dom.soap-&gt;recvfd = stdin;</div>
<div class="line"><span class="keywordflow">if</span> (soap_begin_recv(dom.soap)</div>
<div class="line"> || NULL != soap_in_xsd__anyType(dom.soap, NULL, &amp;dom, NULL)</div>
<div class="line"> || soap_end_recv(dom.soap))</div>
<div class="line">  ... <span class="comment">// parse error</span></div>
<div class="line">dom.soap-&gt;sendfd = stdout;</div>
<div class="line"><span class="keywordflow">if</span> (soap_begin_send(dom.soap))</div>
<div class="line">  ... <span class="comment">// output error</span></div>
<div class="line">dom.soap-&gt;ns = 2; <span class="comment">// note: must use this to omit namespaces table dumping</span></div>
<div class="line"><span class="keywordflow">if</span> (soap_out_xsd__anyType(dom.soap, NULL, 0, &amp;dom, NULL)</div>
<div class="line"> || soap_end_send(dom.soap))</div>
<div class="line">  ... <span class="comment">// output error</span></div>
<div class="line">soap_end(dom.soap);</div>
<div class="line">soap_done(dom.soap);</div>
<div class="line">free(dom.soap);</div>
</div><!-- fragment --><p>The SOAP_DOM_NODE flag is used to instruct the parser to populate a DOM node set with deserialized C and C++ data structures using the data type's deserializers that were generated with soapcpp2 from a header file with the data type declarations. Suppose for example that the following header file was used (in fact, this declaration appears in wsu.h):</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>_wsu__Timestamp</div>
<div class="line">{   @<span class="keywordtype">char</span>*  wsu__Id;</div>
<div class="line">    <span class="keywordtype">char</span>*   Created;</div>
<div class="line">    xpires;</div>
<div class="line">} _wsu__Timestamp;</div>
</div><!-- fragment --><p>Note that the leading underscore of the type name indicates an XML element definition (rather than a complexType definition), so the name of the data type is relevant when comparing XML element tags to C/C++ data types by the deserializers.</p>
<p>When an XML document is parsed with one or more &lt;wsu:Timestamp&gt; elements, the DOM will be automatically populated with the _wsu__Timestamp objects. Suppose the XML document root is a &lt;wsu:Timestamp&gt;, then the root node of the DOM is a _wsu__Timestamp object:</p>
<div class="fragment"><div class="line">soap_dom_element dom;</div>
<div class="line">dom.soap = soap_new1(SOAP_DOM_NODE);</div>
<div class="line">cin &gt;&gt; dom; <span class="comment">// parse XML</span></div>
<div class="line"><span class="keywordflow">if</span> (dom.soap-&gt;error)</div>
<div class="line">  ... <span class="comment">// parse error</span></div>
<div class="line"><span class="keywordflow">if</span> (dom.type == SOAP_TYPE__wsu__Timestamp)</div>
<div class="line">{ _wsu__Timestamp *t = (_wsu__Timestamp*)dom.node;</div>
<div class="line">  cout &lt;&lt; <span class="stringliteral">&quot;Start &quot;</span> &lt;&lt; (t-&gt;Created ? t-&gt;Created : <span class="stringliteral">&quot;&quot;</span>)</div>
<div class="line">       &lt;&lt; <span class="stringliteral">&quot; till &quot;</span> &lt;&lt; (t-&gt;Expires ? t-&gt;Expires : <span class="stringliteral">&quot;&quot;</span>) &lt;&lt; endl;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Note that the soapcpp2 compiler generates a unique type identification constant SOAP_TYPE_X for each data type X, which is used to determine the node's type in the example above.</p>
<p>When objects occur deeper within the DOM node set then the DOM tree should be traversed. This subject will be discussed next.</p>
<h1><a class="anchor" id="dom_3"></a>
Traversing a DOM Node Set</h1>
<p>The DOM node set is traversed with a C++ iterator or with the C functions soap_dom_next_element and soap_dom_next_attribute. For example, to walk the node set visiting nodes in the same order as they appeared in the document, use:</p>
<div class="fragment"><div class="line">soap_dom_element dom;</div>
<div class="line">dom.soap = soap_new1(SOAP_DOM_TREE | SOAP_C_UTFSTRING);</div>
<div class="line">...</div>
<div class="line">for (soap_dom_element::iterator iter = dom.begin(); iter != dom.end(); ++iter)</div>
<div class="line">  <span class="keywordflow">for</span> (soap_dom_attribute::iterator attr = (*iter).atts.begin(); attr != (*iter).atts.end(); ++attr)</div>
<div class="line">    ...</div>
</div><!-- fragment --><p>In C code, use:</p>
<div class="fragment"><div class="line">soap_dom_element dom, *iter;</div>
<div class="line">soap_dom_attribute *attr;</div>
<div class="line">dom.soap = soap_new1(SOAP_DOM_TREE | SOAP_C_UTFSTRING);</div>
<div class="line">...</div>
<div class="line">for (iter = &amp;dom; iter; iter = soap_dom_next_element(iter))</div>
<div class="line">  <span class="keywordflow">for</span> (attr = iter-&gt;atts; attr; attr = soap_dom_next_attribute(attr))</div>
<div class="line">     ...</div>
</div><!-- fragment --><p>The soap_dom_element and soap_dom_attribute structs form essentially linked lists, so it would not be too difficult to write your own tree walkers:</p>
<ul>
<li>soap_dom_element::prnt points to the parent soap_dom_element node.</li>
<li>soap_dom_element::elts points to the linked list of child element nodes.</li>
<li>soap_dom_element::atts points to the linked list of attribute nodes.</li>
</ul>
<p>The linked lists of sibling elements nodes and attribute nodes are respectively:</p>
<ul>
<li>soap_dom_element::next points to the next sibling element node.</li>
<li>soap_dom_attribute::next points to the next attribute in the attribute list of an element node.</li>
</ul>
<p>Note that for a root node, the soap_dom_element::prnt and soap_dom_element::next are both NULL.</p>
<p>Tag names of elements and attributes are stored in soap_dom_element::name and soap_dom_attribute::name strings, respectively. The names are UTF-8 encoded.</p>
<p>XML namespace bindings are explicitly propagated throughout the DOM node set for those elements and attributes that are namespace qualified (either with a namespace prefix or when they occur in a xmlns default namespace scope). The namespaces are stored in the soap_dom_element::nstr and soap_dom_attribute::nstr strings. The following example shows how to traverse a DOM node set and print the elements with their namespace URIs when present:</p>
<div class="fragment"><div class="line">soap_dom_element dom;</div>
<div class="line">dom.soap = soap_new1(SOAP_DOM_TREE | SOAP_C_UTFSTRING);</div>
<div class="line">cin &gt;&gt; dom;</div>
<div class="line"><span class="keywordflow">for</span> (soap_dom_element::iterator iter = dom.begin(); iter != dom.end(); ++iter)</div>
<div class="line">{ cout &lt;&lt; <span class="stringliteral">&quot;Element &quot;</span> &lt;&lt; (*iter).name;</div>
<div class="line">  <span class="keywordflow">if</span> ((*iter).nstr)</div>
<div class="line">    cout &lt;&lt; <span class="stringliteral">&quot; has namespace &quot;</span> &lt;&lt; (*iter).nstr;</div>
<div class="line">  cout &lt;&lt; endl;</div>
<div class="line">}</div>
<div class="line">soap_destroy(dom.soap);</div>
<div class="line">soap_end(dom.soap);</div>
<div class="line">soap_done(dom.soap);</div>
<div class="line">free(dom.soap);</div>
</div><!-- fragment --><p>Text content of a node is stored in the soap_dom_element::data string in UTF-8 format. This string is populated if the SOAP_C_UTFSTRING flag was set. Otherwise the data content will be stored in the soap_dom_element::wide wide-character string.</p>
<p>The following example prints those element nodes that have text content (in UTF-8 format):</p>
<div class="fragment"><div class="line">soap_dom_element dom;</div>
<div class="line">...</div>
<div class="line">for (soap_dom_element::iterator iter = dom.begin(); iter != dom.end(); ++iter)</div>
<div class="line">{ cout &lt;&lt; <span class="stringliteral">&quot;Element &quot;</span> &lt;&lt; (*iter).name;</div>
<div class="line">  <span class="keywordflow">if</span> ((*iter).data)</div>
<div class="line">    cout &lt;&lt; <span class="stringliteral">&quot; = &quot;</span> &lt;&lt; (*iter).data;</div>
<div class="line">  cout &lt;&lt; endl;</div>
<div class="line">}</div>
<div class="line">...</div>
</div><!-- fragment --><p>When a DOM node set contains deserialized objects (enabled with the SOAP_DOM_NODE flag), the soap_dom_element::type and soap_dom_element::node values are set:</p>
<div class="fragment"><div class="line">soap_dom_element dom;</div>
<div class="line">...</div>
<div class="line">for (soap_dom_element::iterator iter = dom.begin(); iter != dom.end(); ++iter)</div>
<div class="line">{ cout &lt;&lt; <span class="stringliteral">&quot;Element &quot;</span> &lt;&lt; (*iter).name;</div>
<div class="line">  <span class="keywordflow">if</span> ((*iter).type)</div>
<div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;Element &quot;</span> &lt;&lt; (*iter).name &lt;&lt; <span class="stringliteral">&quot; contains a deserialized object&quot;</span> &lt;&lt; endl;</div>
<div class="line">  cout &lt;&lt; endl;</div>
<div class="line">}</div>
<div class="line">...</div>
</div><!-- fragment --><p>The soap_dom_element::type is 0 or a SOAP_TYPE_X constant, where X is the name of the deserialized type. The soap_dom_element::node points to the deserialized object. If this is a char* string, it points directly to the character sequence.</p>
<p>Note: the SOAP_DOM_TREE flag restricts the parser to DOM content only, so deserializers is not used. When the SOAP_DOM_TREE flag is not used, an appropriate deserializer MAY be used by gSOAP when an element contains an id attribute and gSOAP can determine the type from the id attribute reference and/or the xsi:type attribute of an element.</p>
<h1><a class="anchor" id="dom_4"></a>
Searching</h1>
<p>Common operations on DOM node sets in level-2 DOM parsers are searching and filtering.</p>
<p>For C++ code, the built-in soap_dom_element::iterator can be used to search for matching element nodes. C programmers are out of luck as they should write looping code to search for nodes explicitly.</p>
<p>The soap_dom_element::find method returns a search iterator. The method takes an optional namespace URI and element name to match elements in the DOM node set. For example, to iterate over all "product" elements:</p>
<div class="fragment"><div class="line">soap_dom_element dom;</div>
<div class="line">...</div>
<div class="line">for (soap_dom_element::iterator iter = dom.find(NULL, <span class="stringliteral">&quot;product&quot;</span>); iter != dom.end(); ++iter)</div>
<div class="line">  cout &lt;&lt; <span class="stringliteral">&quot;Element &quot;</span> &lt;&lt; (*iter).name &lt;&lt; endl;</div>
<div class="line">...</div>
</div><!-- fragment --><p>To iterate over all elements in a particular namespace:</p>
<div class="fragment"><div class="line">soap_dom_element dom;</div>
<div class="line">...</div>
<div class="line">for (soap_dom_element::iterator iter = dom.find(<span class="stringliteral">&quot;http://www.w3.org/2001/XMLSchema&quot;</span>, NULL); iter != dom.end(); ++iter)</div>
<div class="line">  cout &lt;&lt; <span class="stringliteral">&quot;Element &quot;</span> &lt;&lt; (*iter).name &lt;&lt; endl;</div>
<div class="line">...</div>
</div><!-- fragment --><p>Since namespaces may have different version, a '*' wildcard can be used with the namespace string. Likewise, tag names may be namespace qualified with prefixes that are not relevant to the search:</p>
<div class="fragment"><div class="line">soap_dom_element dom;</div>
<div class="line">...</div>
<div class="line">for (soap_dom_element::iterator iter = dom.find(<span class="stringliteral">&quot;http://www.w3.org/*XMLSchema&quot;</span>, <span class="stringliteral">&quot;*:schema&quot;</span>); iter != dom.end(); ++iter)</div>
<div class="line">  cout &lt;&lt; <span class="stringliteral">&quot;Element &quot;</span> &lt;&lt; (*iter).name &lt;&lt; endl;</div>
<div class="line">...</div>
</div><!-- fragment --><p>This searches for qualified elements in one of the XSD namespaces.</p>
<h1><a class="anchor" id="dom_5"></a>
Constructing DOM Node Sets</h1>
<p>The soap_dom_element::set and soap_dom_element::add methods are used to decorate a DOM node set with child element nodes and attribute nodes. Application data with serializers can be incorporated in the node set as well.</p>
<p>The following examples are shown in C++. C programmers can use the soap_dom_element:elts list and soap_dom_elements::atts list to add child nodes and attribute nodes, respectively.</p>
<div class="fragment"><div class="line">soap_dom_element dom;</div>
<div class="line">dom.soap = soap_new1(SOAP_C_UTFSTRING | SOAP_XML_INDENT);</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> *myURI = <span class="stringliteral">&quot;http://www.mydomain.com/myproducts&quot;</span>;</div>
<div class="line">ns__myProduct product();</div>
<div class="line">product.soap_default(dom.soap); <span class="comment">// method generated by soapcpp2</span></div>
<div class="line">product.name = <span class="stringliteral">&quot;Ernie&quot;</span>;</div>
<div class="line">product.SKU = 123;</div>
<div class="line">product.price = 9.95;</div>
<div class="line">dom.set(myURI, <span class="stringliteral">&quot;list&quot;</span>);</div>
<div class="line">dom.add(soap_dom_attribute(dom.soap, myURI, <span class="stringliteral">&quot;version&quot;</span>, <span class="stringliteral">&quot;0.9&quot;</span>));</div>
<div class="line">dom.add(soap_dom_element(dom.soap, myURI, <span class="stringliteral">&quot;documentation&quot;</span>, <span class="stringliteral">&quot;List of products&quot;</span>));</div>
<div class="line">dom.add(soap_dom_element(dom.soap, myURI, <span class="stringliteral">&quot;product&quot;</span>, &amp;product, SOAP_TYPE_ns__myProduct);</div>
<div class="line">cout &lt;&lt; dom;</div>
<div class="line">...</div>
</div><!-- fragment --><p>Assuming that myURI is associated with namespace prefix "ns" in the namespace table, the rendition is</p>
<div class="fragment"><div class="line">&lt;?xml version=<span class="stringliteral">&quot;1.0&quot;</span> encoding=<span class="stringliteral">&quot;UTF-8&quot;</span>?&gt;</div>
<div class="line">&lt;ns:list</div>
<div class="line">  xmlns:SOAP-ENV=<span class="stringliteral">&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;</span></div>
<div class="line">  xmlns:SOAP-ENC=<span class="stringliteral">&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;</span></div>
<div class="line">  xmlns:xsi=<span class="stringliteral">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></div>
<div class="line">  xmlns:xsd=<span class="stringliteral">&quot;http://www.w3.org/2001/XMLSchema&quot;</span></div>
<div class="line">  xmlns:ns=<span class="stringliteral">&quot;http://domain/schemas/product.xsd&quot;</span></div>
<div class="line">  version=<span class="stringliteral">&quot;0.9&quot;</span> &gt;</div>
<div class="line">        &lt;ns:documentation&gt;List of products&lt;/ns:documentation&gt;</div>
<div class="line">        &lt;ns:product&gt;</div>
<div class="line">                &lt;name&gt;Ernie&lt;/name&gt;</div>
<div class="line">                &lt;SKU&gt;123&lt;/SKU&gt;</div>
<div class="line">                &lt;price&gt;9.95&lt;/price&gt;</div>
<div class="line">        &lt;/ns:product&gt;</div>
<div class="line">&lt;/ns:list&gt;</div>
</div><!-- fragment --><p>Note that the namespace table content is "dumped" into the XML rendition.</p>
<p>The global namespace mapping table "namespaces[]" contains the namespace bindings that should be meaningful to the application. The soap context can be set to a new table as follows:</p>
<div class="fragment"><div class="line">Namespace myNamespaces[] = { { <span class="stringliteral">&quot;ns&quot;</span>, <span class="stringliteral">&quot;...&quot;</span> }, ... , { NULL } };</div>
<div class="line">soap_dom_element dom;</div>
<div class="line">dom.soap = soap_new1(SOAP_C_UTFSTRING | SOAP_XML_INDENT);</div>
<div class="line">dom.soap-&gt;namespaces = myNamespaces;</div>
</div><!-- fragment --><p>To produce cleaner XML, use the SOAP_XML_CANONICAL flag to initiate the soap context:</p>
<div class="fragment"><div class="line">&lt;ns:list xmlns:ns=<span class="stringliteral">&quot;http://domain/schemas/product.xsd&quot;</span> version=<span class="stringliteral">&quot;0.9&quot;</span> &gt;</div>
<div class="line">        &lt;ns:documentation&gt;List of products&lt;/ns:documentation&gt;</div>
<div class="line">        &lt;ns:product&gt;</div>
<div class="line">                &lt;name&gt;Ernie&lt;/name&gt;</div>
<div class="line">                &lt;SKU&gt;123&lt;/SKU&gt;</div>
<div class="line">                &lt;price&gt;9.95&lt;/price&gt;</div>
<div class="line">        &lt;/ns:product&gt;</div>
<div class="line">&lt;/ns:list&gt;</div>
</div><!-- fragment --><p>Note that the xmlns bindings are rendered automatically. When parsing an XML document, xmlns bindings are not added to the attribute node set. The soap_dom_element::nstr and soap_dom_attribute::nstr namespace strings are set to retain namespace URIs. The XML rendering algorithm uses the namespace strings to add xmlns bindings that are not already in the namespace table.</p>
<p>When it is desirable to render XML exactly as represented in the DOM node set, e.g. when xmlns bindings are explicitly included in the attribute node set, use the SOAP_DOM_ASIS flag:</p>
<div class="fragment"><div class="line">soap_dom_element dom;</div>
<div class="line">dom.soap = soap_new1(SOAP_C_UTFSTRING | SOAP_DOM_ASIS);</div>
</div><!-- fragment --><h1><a class="anchor" id="dom_6"></a>
Example</h1>
<p>The gSOAP header file below imports DOM and declares xsd:float to enable serializing floats embedded within DOM node sets and deserializing floats to populate DOM node sets:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#import &quot;<a class="code" href="dom_8h.html">dom.h</a>&quot;</span></div>
<div class="line"><span class="keyword">typedef</span> <span class="keywordtype">float</span> xsd__float;</div>
</div><!-- fragment --><p>Consider invoking the XMethods delayed stock quote service to obtain a stock quote. The float deserializer is used to store the floating-point value of a stock given that the &lt;Result&gt; element has an xsi:type="xsd:float" attribute.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>soap *soap = soap_new1(SOAP_C_UTFSTRING | SOAP_DOM_NODE);</div>
<div class="line">soap_dom_element envelope(soap, <span class="stringliteral">&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;</span>, <span class="stringliteral">&quot;Envelope&quot;</span>);</div>
<div class="line">soap_dom_element body(soap, <span class="stringliteral">&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;</span>, <span class="stringliteral">&quot;Body&quot;</span>);</div>
<div class="line">soap_dom_attribute encodingStyle(soap, <span class="stringliteral">&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;</span>, <span class="stringliteral">&quot;encodingStyle&quot;</span>, <span class="stringliteral">&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;</span>);</div>
<div class="line">soap_dom_element request(soap, <span class="stringliteral">&quot;urn:xmethods-delayed-quotes&quot;</span>, <span class="stringliteral">&quot;getQuote&quot;</span>);</div>
<div class="line">soap_dom_element symbol(soap, NULL, <span class="stringliteral">&quot;symbol&quot;</span>, <span class="stringliteral">&quot;IBM&quot;</span>);</div>
<div class="line">soap_dom_element response(soap);</div>
<div class="line">envelope.add(body);</div>
<div class="line">body.add(encodingStyle);</div>
<div class="line">body.add(request);</div>
<div class="line">request.add(symbol);</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Request message:&quot;</span> &lt;&lt; endl &lt;&lt; envelope &lt;&lt; endl;</div>
<div class="line"><span class="keywordflow">if</span> (soap_connect(soap, <span class="stringliteral">&quot;http://services.xmethods.net/soap&quot;</span>, <span class="stringliteral">&quot;&quot;</span>)</div>
<div class="line"> || soap_out_xsd__anyType(soap, NULL, 0, &amp;envelope, NULL)</div>
<div class="line"> || soap_end_send(soap)</div>
<div class="line"> || soap_begin_recv(soap)</div>
<div class="line"> || NULL != soap_in_xsd__anyType(soap, NULL, &amp;response, NULL)</div>
<div class="line"> || soap_end_recv(soap)</div>
<div class="line"> || soap_closesock(soap))</div>
<div class="line">{ soap_print_fault(soap, stderr);</div>
<div class="line">  soap_print_fault_location(soap, stderr);</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">{ cout &lt;&lt; <span class="stringliteral">&quot;Response message:&quot;</span> &lt;&lt; endl &lt;&lt; response &lt;&lt; endl;</div>
<div class="line">  <span class="keywordflow">for</span> (soap_dom_element::iterator walker = response.find(SOAP_TYPE_xsd__float); walker != response.end(); ++walker)</div>
<div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;Quote = &quot;</span> &lt;&lt; *(xsd__float*)(*walker).node &lt;&lt; endl;</div>
<div class="line">}</div>
<div class="line">soap_destroy(soap);</div>
<div class="line">soap_end(soap);</div>
<div class="line">soap_done(soap);</div>
<div class="line">free(soap);</div>
</div><!-- fragment --><h1><a class="anchor" id="dom_7"></a>
Summary</h1>
<p>The DOM parser needs a soap context to allocate nodes:</p>
<div class="fragment"><div class="line">soap_dom_element dom;</div>
<div class="line">dom.soap = soap_new1(... flags ...);</div>
<div class="line">...</div>
<div class="line">soap_destroy(dom.soap);</div>
<div class="line">soap_end(dom.soap);</div>
<div class="line">soap_done(dom.soap);</div>
<div class="line">soap_free(dom.soap);</div>
</div><!-- fragment --><p>The nodes are removed with soap_destroy (for C++) and soap_end. The soap_done function should only be used before the soap context is deallocated.</p>
<p>The soap context flags that control the parsing and rendition of XML are:</p>
<ul>
<li>(no flag): only elements with an id attribute are deserialized as C/C++ data types (when a deserializer is available). XML elements with character data are deserialized into the soap_dom_element::wide field.</li>
<li>SOAP_C_UTFSTRING: store character data in UTF-8 format in soap_dom_element::data.</li>
<li>SOAP_C_MBSTRING: store character data in multi-byte format in soap_dom_element::data, where the decoding depends on the current localication. The platform must support MB strings (HAVE_MBTOWC).</li>
<li>SOAP_DOM_TREE: prevents deserialization of C/C++ data structures into the DOM.</li>
<li>SOAP_DOM_NODE: attempt to deserialize C/C++ data structures when a deserializer is available. A deserializer is selected based on the element name or the xsi:type attribute.</li>
<li>SOAP_DOM_ASIS: render XML "as is", i.e. do not insert xmlns bindings for URIs stored in nstr. Assumes the DOM is self-contained.</li>
<li>SOAP_XML_INDENT: render XML with indent.</li>
<li>SOAP_XML_CANONICAL: render XML in exc-c14n form.</li>
</ul>
<p>The DOM traversal operations:</p>
<ul>
<li>soap_dom_next_element returns the next element in an in-order traversal.</li>
<li>soap_dom_next_attribute returns the next attribute of a node.</li>
</ul>
<p>The soap_dom_element fields:</p>
<ul>
<li>soap_dom_element::next pointer to next sibling in list.</li>
<li>soap_dom_element::prnt pointer to parent node.</li>
<li>soap_dom_element::elts pointer to list of child element nodes.</li>
<li>soap_dom_element::atts pointer to list of attribute nodes.</li>
<li>soap_dom_element::nstr optional namespace string of this node.</li>
<li>soap_dom_element::name the name of the element node (with optional prefix).</li>
<li>soap_dom_element::data optional character data in UTF-8 format.</li>
<li>soap_dom_element::wide optional character data in wide string format.</li>
<li>soap_dom_element::type optional SOAP_TYPE_X type of a C/C++ data structure stored with this node.</li>
<li>soap_dom_element::node optional pointer to the C/C++ data structure stored with this node.</li>
<li>soap_dom_element::head optional leading whitespace to the start tag.</li>
<li>soap_dom_element::tail optional leading whitespace to the end tag.</li>
<li>soap_dom_element::soap the soap context that manages this node.</li>
</ul>
<p>The soap_dom_element types:</p>
<ul>
<li>soap_dom_element::iterator</li>
</ul>
<p>The soap_dom_element methods:</p>
<ul>
<li>soap_dom_element::set(nstr, name);</li>
<li>soap_dom_element::set(data);</li>
<li>soap_dom_element::set(node, type);</li>
<li>soap_dom_element::add(soap_dom_element);</li>
<li>soap_dom_element::add(soap_dom_attribute);</li>
<li>soap_dom_element::begin();</li>
<li>soap_dom_element::end();</li>
<li>soap_dom_element::find(nstr, name);</li>
<li>soap_dom_element::find(type);</li>
<li>soap_dom_element::unlink();</li>
</ul>
<p>The soap_dom_element constructors:</p>
<ul>
<li>soap_dom_element();</li>
<li>soap_dom_element(soap);</li>
<li>soap_dom_element(soap, nstr, name);</li>
<li>soap_dom_element(soap, nstr, name, data);</li>
<li>soap_dom_element(soap, nstr, name, node, type);</li>
</ul>
<p>The soap_dom_attribute fields:</p>
<ul>
<li>soap_dom_attribute::next pointer to next attribute node in list.</li>
<li>soap_dom_attribute::nstr optional namespace string of this node.</li>
<li>soap_dom_attribute::name the name of the attribute (with optional prefix).</li>
<li>soap_dom_attribute::data optional character data in UTF-8 format.</li>
<li>soap_dom_attribute::soap the soap context that manages this node.</li>
</ul>
<p>The soap_dom_attribute types:</p>
<ul>
<li>soap_dom_attribute::iterator</li>
</ul>
<p>The soap_dom_attribute methods:</p>
<ul>
<li>soap_dom_attribute::set(nstr, name);</li>
<li>soap_dom_attribute::set(data);</li>
<li>soap_dom_attribute::begin();</li>
<li>soap_dom_attribute::end();</li>
<li>soap_dom_attribute::find(nstr, name);</li>
<li>soap_dom_attribute::unlink();</li>
</ul>
<p>The soap_dom_attribute constructors:</p>
<ul>
<li>soap_dom_attribute();</li>
<li>soap_dom_attribute(soap);</li>
<li>soap_dom_attribute(soap, nstr, name, data); </li>
</ul>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Aug 18 2014 13:23:25 for gSOAP level-2 DOM by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.3
</small></address>
</body>
</html>
