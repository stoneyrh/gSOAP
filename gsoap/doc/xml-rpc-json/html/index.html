<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Genivia - XML-RPC and JSON</title>
<link href="genivia_tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<div id="top">
<div id="titlearea">
<table height="72px" width="100%" cellspacing="0" cellpadding="0">
 <tbody>
  <tr>
   <td width="10%">&nbsp;</td>
   <td width="175px"><a href="http://www.genivia.com"><img alt="Genivia" src="GeniviaLogo2_trans_noslogan.png"/></a></td>
   <td class="tab_home"><a href="http://www.genivia.com">Home</a></td>
   <td class="tab_home"><a href="http://www.genivia.com/dev.html">Developer Center</a></td>
   <td>
    <div style="float: right;"><h1>XML-RPC &amp; JSON</h1></div>
   </td>
   <td width="10%">&nbsp;</td>
  </tr>
 </tbody>
</table>
</div>
<!-- Generated by Doxygen 1.8.3 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">XML-RPC and JSON </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#cpp">C++ XML-RPC and JSON                                                      </a><ul><li class="level2"><a href="#files">List of C++ Files                                                       </a></li>
<li class="level2"><a href="#cpp-ex">C++ XML-RPC and JSON with Examples                                     </a></li>
<li class="level2"><a href="#cpp-cl">C++ XML-RPC Client Example                                             </a></li>
<li class="level2"><a href="#cpp-sr">C++ XML-RPC Server Example                                             </a></li>
<li class="level2"><a href="#cpp-io">C++ XML-RPC Data Serialization from/to Streams                         </a></li>
<li class="level2"><a href="#cpp-js">C++ JSON Serialization from/to Streams                                 </a></li>
<li class="level2"><a href="#cpp-jr">C++ JSON-RPC over HTTP (REST method)                                   </a></li>
<li class="level2"><a href="#json-ns">Moving JSON Types into a C++ Namespace                                </a></li>
</ul>
</li>
<li class="level1"><a href="#c">C XML-RPC and JSON                                                          </a><ul><li class="level2"><a href="#c-ex">C Examples                                                               </a></li>
<li class="level2"><a href="#c-cl">C XML-RPC Client Example                                                 </a></li>
<li class="level2"><a href="#c-js">C JSON Serialization                                                     </a></li>
<li class="level2"><a href="#c-jr">C JSON-RPC over HTTP (REST method)                                       </a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p>XML-RPC is a simple messaging protocol. XML-RPC is a generic, self-describing (verbose) XML format to compose XML messages for platform-neutral data exchange. XML-RPC defines a collection of frequently used XML types with common programming language equivalents. XML-RPC does NOT provide a data binding to XML and does NOT support a validation mechanism to ensure that data content is validated against a data type or schema. XML-RPC serialization proceeds by marshaling parameters in predefined XML elements for each data type. XML-RPC has primitive types (bool, int, double, string, dateTime, base64) and two compound types (structs and arrays).</p>
<p>See <a href="http://www.xmlrpc.com">http://www.xmlrpc.com</a> to read more about XML-RPC.</p>
<p>JSON (JavaScript Object Notation) is an even simpler data format to support platform-neutral data interchange that is highly compatible across programming languages by restricting data organization to a set of five common types: bool, float, string, array, and object.</p>
<p>See <a href="http://www.json.org">http://www.json.org</a> to read more about JSON.</p>
<h1><a class="anchor" id="cpp"></a>
C++ XML-RPC and JSON                                                      </h1>
<p>XML-RPC and JSON data is interchangeable in this implementation, with the only exception that the dateTime and base64 types are handled as strings in JSON. Also, JSON's only numeric type is floating point. However, integers are handled just fine by this JSON implementation as 64 bit (<code>long long</code> or <code>LONG64</code>) without conversion to/from double floating point values. Developers should be aware of these limitations.</p>
<h2><a class="anchor" id="files"></a>
List of C++ Files                                                       </h2>
<p>The following C++ source files are provided for XML-RPC:</p>
<ul>
<li><code>xml-rpc-io.h</code>: C++ XML-RPC serialization over streams</li>
<li><code>xml-rpc-io.cpp</code>: C++ XML-RPC serialization over streams</li>
<li><code>xml-rpc.cpp</code>: C++ XML-RPC data management</li>
<li><code><a class="el" href="xml-rpc-iters_8h.html">xml-rpc-iters.h</a></code>: C++ iterators for structs, arrays, and parameters</li>
<li><code><a class="el" href="xml-rpc_8h.html">xml-rpc.h</a></code>: XML-RPC binding as a gSOAP .h file for soapcpp2 (do not #include this file in your project builds)</li>
</ul>
<p>For JSON serialization in C++, we use the following files:</p>
<ul>
<li><code><a class="el" href="json_8h.html">json.h</a></code>: C++ JSON serializer over streams</li>
<li><code>json.cpp</code>: C++ JSON serializer over streams</li>
<li><code>xml-rpc.cpp</code>: C++ XML-RPC data management</li>
<li><code><a class="el" href="xml-rpc-iters_8h.html">xml-rpc-iters.h</a></code>: C++ iterators for structs and arrays</li>
<li><code><a class="el" href="xml-rpc_8h.html">xml-rpc.h</a></code>: XML-RPC binding as a gSOAP .h file for soapcpp2 (do not #include this file in your project builds)</li>
</ul>
<p>The gSOAP header file <code><a class="el" href="xml-rpc_8h.html">xml-rpc.h</a></code> defines all XML-RPC and JSON types as struct with C++ member functions to create XML-RPC and JSON data and REST messages.</p>
<p>A note about the following auto-generated files: <code>soapH.h</code>, <code>soapStub.h</code> and <code>soapC.cpp</code>. These are required for XML-RPC and JSON. To auto-generate these files, execute: </p>
<pre class="fragment">soapcpp2 -CSL xml-rpc.h
</pre><p>Then compile and link the <code>.cpp</code> files listed above for XML-RPC or JSON with the auto-generted <code>soapC.cpp</code> and <code>stdsoap2.cpp</code> (or link with <code>libgsoap++.a</code> installed by the gSOAP package).</p>
<p>Because XML namespaces are not used, we can either use <code>-DWITH_NONAMESPACES</code> to compile <code>stdsoap2.cpp</code> without complaining about a missing global <code>Namespace</code>, or we can define an empty namespaces table somewhere in our code:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Namespace namespaces[] = { {NULL, NULL} };</div>
</div><!-- fragment --><p>For JSON-RPC over HTTP (JSON REST method), we use the <code>plugin/httppost.c</code> plugin. See <a href="#cpp-jr">JSON-RPC over HTTP</a> below.</p>
<h2><a class="anchor" id="cpp-ex"></a>
C++ XML-RPC and JSON with Examples                                     </h2>
<p>An XML-RPC/JSON data value is created in C++ as follows, which requires a context <code>ctx</code> with the engine state (the soap struct). A context manages memory of the value.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;soapH.h&quot;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>soap *ctx = soap_new1(SOAP_C_UTFSTRING);  <span class="comment">// new context</span></div>
<div class="line"></div>
<div class="line"><a class="code" href="structvalue.html" title="Represents the &lt;value&gt; container element.">value</a> v(ctx);</div>
<div class="line"></div>
<div class="line">soap_destroy(ctx);  <span class="comment">// delete values</span></div>
<div class="line">soap_end(ctx);      <span class="comment">// delete temp data</span></div>
<div class="line">soap_free(ctx);     <span class="comment">// free context</span></div>
</div><!-- fragment --><p>Note that <code>soapH.h</code> is an auto-generated file (see previous section). This file needs to be generated only once and for all. It also references <code>stdsoap2.h</code> and the auto-generated <code>soapStub.h</code> files. Compile and link your code with <code>stdsoap2.cpp</code> and the auto-generated <code>soapC.cpp</code> XML-RPC serializers. Also compile and link <code>json.cpp</code> for JSON and <code>xml-rpc.cpp</code>.</p>
<p>To dynamically allocate values for automatic deallocation by the engine context, use <code>soap_new_value(ctx)</code>:</p>
<div class="fragment"><div class="line"><a class="code" href="structvalue.html" title="Represents the &lt;value&gt; container element.">value</a> *v = soap_new_value(ctx);</div>
</div><!-- fragment --><p>You can use wide strings and Unicode can be stored in UTF-8-formattted 8-bit char strings. For compatibility with XML-RPC serialization of UTF-8-encoded strings, use the <code>SOAP_C_UTFSTRING</code> flag to initialize the context with <code>soap_new1(SOAP_C_UTFSTRING)</code>.</p>
<p>The code shown above creates an empty value <code>v</code>. It can be assigned any one of the following values:</p>
<div class="fragment"><div class="line"><a class="code" href="structvalue.html" title="Represents the &lt;value&gt; container element.">value</a> v = 12345LL;         <span class="comment">// 64 bit int</span></div>
<div class="line"></div>
<div class="line"><a class="code" href="structvalue.html" title="Represents the &lt;value&gt; container element.">value</a> v = 12.34;           <span class="comment">// double float</span></div>
<div class="line"></div>
<div class="line"><a class="code" href="structvalue.html" title="Represents the &lt;value&gt; container element.">value</a> v = <span class="stringliteral">&quot;abc&quot;</span>;           <span class="comment">// string</span></div>
<div class="line"></div>
<div class="line"><a class="code" href="structvalue.html" title="Represents the &lt;value&gt; container element.">value</a> v = string(<span class="stringliteral">&quot;abc&quot;</span>);   <span class="comment">// std::string</span></div>
<div class="line"></div>
<div class="line"><a class="code" href="structvalue.html" title="Represents the &lt;value&gt; container element.">value</a> v = L<span class="stringliteral">&quot;xyz&quot;</span>;          <span class="comment">// wide string converted to UTF-8</span></div>
<div class="line"></div>
<div class="line"><a class="code" href="structvalue.html" title="Represents the &lt;value&gt; container element.">value</a> v = wstring(L<span class="stringliteral">&quot;xyz&quot;</span>); <span class="comment">// std::wstring converted to UTF-8</span></div>
<div class="line"></div>
<div class="line"><a class="code" href="structvalue.html" title="Represents the &lt;value&gt; container element.">value</a> v = <span class="keyword">false</span>;           <span class="comment">// Boolean</span></div>
<div class="line"></div>
<div class="line"><a class="code" href="structvalue.html" title="Represents the &lt;value&gt; container element.">value</a> v = time(0);         <span class="comment">// time_t value serialized as ISO 8601 date time</span></div>
<div class="line"></div>
<div class="line"><a class="code" href="structvalue.html" title="Represents the &lt;value&gt; container element.">value</a> v;</div>
<div class="line">      v[0] = 24;           <span class="comment">// array [24, 99.99, &quot;abc&quot;]</span></div>
<div class="line">      v[1] = 99.99;</div>
<div class="line">      v[2] = <span class="stringliteral">&quot;abc&quot;</span>;</div>
<div class="line"></div>
<div class="line"><a class="code" href="structvalue.html" title="Represents the &lt;value&gt; container element.">value</a> v;</div>
<div class="line">      v[<span class="stringliteral">&quot;name&quot;</span>] = <span class="stringliteral">&quot;john&quot;</span>;  <span class="comment">// struct {&quot;name&quot;: &quot;john&quot;, &quot;age&quot;: 24}</span></div>
<div class="line">      v[<span class="stringliteral">&quot;age&quot;</span>]  = 24;      <span class="comment">// (JSON calls these &quot;objects&quot;)</span></div>
<div class="line"></div>
<div class="line"><a class="code" href="struct__base64.html" title="Represents the &lt;base64&gt; binary data element.">_base64</a> img(ctx, 100, ptr_to_rawimage100bytes);</div>
<div class="line"><a class="code" href="structvalue.html" title="Represents the &lt;value&gt; container element.">value</a> v = img;             <span class="comment">// data block of 100 raw bytes in base64</span></div>
</div><!-- fragment --><p>You can combine this syntax in many possible ways to create arrays of arrays, arrays of structs, and so on. For example:</p>
<div class="fragment"><div class="line"><a class="code" href="structvalue.html" title="Represents the &lt;value&gt; container element.">value</a> v(ctx);</div>
<div class="line">v[0][<span class="stringliteral">&quot;name&quot;</span>] = <span class="stringliteral">&quot;bob&quot;</span>;</div>
<div class="line">v[0][<span class="stringliteral">&quot;toys&quot;</span>][0] = <span class="stringliteral">&quot;ball&quot;</span>;</div>
<div class="line">v[0][<span class="stringliteral">&quot;toys&quot;</span>][1] = <span class="stringliteral">&quot;furby&quot;</span>;</div>
</div><!-- fragment --><p>which creates a singleton array containing an object with two members: <code>name</code> set to <code>"bob"</code> and <code>toys</code> set to an array containing <code>"ball"</code> and <code>"furby"</code>. In JSON format this is represented as: </p>
<pre class="fragment">           [ { "name": "bob", "toys": ["ball", "furby"] } ]
           ^ ^ ^              ^
           | | |              |
  an array_/ | |              |
 of 1 struct_/ |              |
with 2 members_/______________/
</pre><p>When receiving a value in XML-RPC or JSON, we generally first need to test its type to obtain its value. To check the type of a value, we use <code>is_Type</code> methods:</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> <a class="code" href="structvalue.html#a98b46005862c3378fa0f514876ac6967" title="true if value is not set (JSON null)">value::is_null</a>();       <span class="comment">// value is not set or assigned (JSON null)</span></div>
<div class="line"><span class="keywordtype">bool</span> <a class="code" href="structvalue.html#ae437ba0822eeec4bc1860040036ce8d1" title="true if value is int type">value::is_int</a>();        <span class="comment">// value is a 32 or a 64 bit int</span></div>
<div class="line"><span class="keywordtype">bool</span> <a class="code" href="structvalue.html#a689089dd0cb6ac9649dbe33dd31e8199" title="true if value is double type">value::is_double</a>();     <span class="comment">// value is a 64 bit double floating point</span></div>
<div class="line"><span class="keywordtype">bool</span> <a class="code" href="structvalue.html#a9b7b0789dc59f7a50c009c487777c282" title="true if value is string type">value::is_string</a>();     <span class="comment">// value is a string or wide string</span></div>
<div class="line"><span class="keywordtype">bool</span> <a class="code" href="structvalue.html#a2afd8b5e664abc2ade103843c319ac0a" title="true if value is boolean type">value::is_bool</a>();       <span class="comment">// value is a Boolean &quot;true&quot; or &quot;false&quot; value</span></div>
<div class="line"><span class="keywordtype">bool</span> <a class="code" href="structvalue.html#a069d409dd697b189efdde36b5c61d195" title="true if value is boolean true">value::is_true</a>();       <span class="comment">// value is Boolean &quot;true&quot;</span></div>
<div class="line"><span class="keywordtype">bool</span> <a class="code" href="structvalue.html#a9b5ddfed406b282aec258787a72bb590" title="true if value is boolean false">value::is_false</a>();      <span class="comment">// value is Boolean &quot;false&quot;</span></div>
<div class="line"><span class="keywordtype">bool</span> <a class="code" href="structvalue.html#acd5f0cc9c8de4b5a245223e227ee6b7e" title="true if value is array type">value::is_array</a>();      <span class="comment">// array of values</span></div>
<div class="line"><span class="keywordtype">bool</span> <a class="code" href="structvalue.html#a3fbb0450e00e7c69726479ea7ca30371" title="true if value is struct type">value::is_struct</a>();     <span class="comment">// structure, a.k.a. a JSON object</span></div>
<div class="line"><span class="keywordtype">bool</span> <a class="code" href="structvalue.html#a4d040ec372e86bee35041501dbfbb233" title="true if value is dateTime">value::is_dateTime</a>();   <span class="comment">// ISO 8601, always false for received JSON</span></div>
<div class="line"><span class="keywordtype">bool</span> <a class="code" href="structvalue.html#a1ee990d7bdf48e528f61bc1a133df651" title="true if value is base64 type">value::is_base64</a>();     <span class="comment">// base64, always false for received JSON</span></div>
</div><!-- fragment --><p>There are three additional methods that can be used with values that are arrays and structs:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="structvalue.html#a2db9152a4f86289696a72bd13e26e7b9" title="get array/struct size">value::size</a>(<span class="keywordtype">int</span>);      <span class="comment">// reset array size or pre-allocate space</span></div>
<div class="line"><span class="keywordtype">int</span> <a class="code" href="structvalue.html#a2db9152a4f86289696a72bd13e26e7b9" title="get array/struct size">value::size</a>();          <span class="comment">// returns array or struct size</span></div>
<div class="line"><span class="keywordtype">bool</span> <a class="code" href="structvalue.html#a95f0f36dbb5dd05b3fb15a3006f4db36" title="true if empty array or struct">value::empty</a>();        <span class="comment">// returns true if array or struct is empty</span></div>
</div><!-- fragment --><p>For example, take the value <code>v</code> that was assigned the array shown above. We have the following properties of this value:</p>
<div class="fragment"><div class="line">v.<a class="code" href="structvalue.html#a98b46005862c3378fa0f514876ac6967" title="true if value is not set (JSON null)">is_null</a>() == <span class="keyword">false</span></div>
<div class="line">v.<a class="code" href="structvalue.html#acd5f0cc9c8de4b5a245223e227ee6b7e" title="true if value is array type">is_array</a>() == <span class="keyword">true</span></div>
<div class="line">v.<a class="code" href="structvalue.html#aa348b92d0343ec28a56542f2c47dc3aa" title="set/allocate size of array">size</a>() == 1</div>
<div class="line">v[0].<a class="code" href="structvalue.html#a3fbb0450e00e7c69726479ea7ca30371" title="true if value is struct type">is_struct</a>() == <span class="keyword">true</span></div>
<div class="line">v[0][<span class="stringliteral">&quot;name&quot;</span>].<a class="code" href="structvalue.html#a9b7b0789dc59f7a50c009c487777c282" title="true if value is string type">is_string</a>() == <span class="keyword">true</span></div>
<div class="line">v[0][<span class="stringliteral">&quot;toys&quot;</span>].<a class="code" href="structvalue.html#acd5f0cc9c8de4b5a245223e227ee6b7e" title="true if value is array type">is_array</a>() == <span class="keyword">true</span></div>
<div class="line">v[0][<span class="stringliteral">&quot;toys&quot;</span>].<a class="code" href="structvalue.html#a95f0f36dbb5dd05b3fb15a3006f4db36" title="true if empty array or struct">empty</a>() == <span class="keyword">false</span></div>
</div><!-- fragment --><p>When indexing XML-RPC structs (JSON objects) to access members and values, make sure to use existing member names only. Otherwise, a new member is dynamically added to the structure. You may want to use iterators to extract data from structs (see below).</p>
<p>To extract data we can use casts on a value <code>v</code> as follows:</p>
<div class="fragment"><div class="line">(double)v                   <span class="comment">// 64 bit double or 0.0 if not numeric</span></div>
<div class="line">(<span class="keywordtype">int</span>)v                      <span class="comment">// 32 bit int or 0 if not numeric</span></div>
<div class="line">(LONG64)v                   <span class="comment">// 64 bit int or 0 if not numeric</span></div>
<div class="line">(<span class="keywordtype">char</span>*)v                    <span class="comment">// convert to string, when not string</span></div>
<div class="line">(<span class="keywordtype">string</span>)v                   <span class="comment">// convert to string, when not string</span></div>
<div class="line">(<span class="keywordtype">wchar_t</span>*)v                 <span class="comment">// convert to string, when not string</span></div>
<div class="line">(wstring)v                  <span class="comment">// convert to string, when not string</span></div>
<div class="line">(<span class="keywordtype">bool</span>)v                     <span class="comment">// same as is_true()</span></div>
<div class="line">(time_t)v                   <span class="comment">// nonzero if v contains a ISO 8601 date time</span></div>
<div class="line">(<a class="code" href="struct__base64.html" title="Represents the &lt;base64&gt; binary data element.">_base64</a>)v                  <span class="comment">// produces base64 from v if v is not base64</span></div>
</div><!-- fragment --><p>It is valid to cast a primitive type to any of the other primitive types shown above and no runtime error will occur, although you may loose some information when a value has no representation in the target type's value space. Casting a number to a string is fine, but casting a string to a number only gives a nonzero numeric value if the string is numeric. Casting a value to base64 produces its base64 encoding.</p>
<p>To access base64 binary raw data of a value <code>v</code>, we use the following methods:</p>
<div class="fragment"><div class="line"><a class="code" href="struct__base64.html" title="Represents the &lt;base64&gt; binary data element.">_base64</a>&amp; bin = v;</div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *raw = bin.<a class="code" href="struct__base64.html#accb75dbcdaf316a692d92d42783ffcb8" title="pointer to data">ptr</a>();</div>
<div class="line"><span class="keywordtype">int</span> size = bin.<a class="code" href="struct__base64.html#a89555bd2f9d977fd17bc2823bef10230" title="byte size of data">size</a>();</div>
</div><!-- fragment --><p>Arrays and structs are compound types that cannot be cast to or from other types (but if you do cast, an empty array or struct is created an no runtime error will occur). So we should check for array and struct types to obtain their content. For example:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (v.<a class="code" href="structvalue.html#acd5f0cc9c8de4b5a245223e227ee6b7e" title="true if value is array type">is_array</a>())</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; v.<a class="code" href="structvalue.html#aa348b92d0343ec28a56542f2c47dc3aa" title="set/allocate size of array">size</a>(); ++i)</div>
<div class="line">  {</div>
<div class="line">    <a class="code" href="structvalue.html" title="Represents the &lt;value&gt; container element.">value</a>&amp; array_element = v[i];</div>
<div class="line">    ... <span class="comment">// use array_element</span></div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>We use iterators for structs and should also use iterators for arrays for efficiency. Array and struct iterators have an <code>index()</code> method to obtain the array index (an int) and struct member name (a string). Dereferencing the iterator gives the value in the array or struct located at the current index.</p>
<p>For example, to traverse a value <code>v</code> that is an array or a struct:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (v.<a class="code" href="structvalue.html#acd5f0cc9c8de4b5a245223e227ee6b7e" title="true if value is array type">is_array</a>())</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="struct__array.html" title="Represents the &lt;array&gt; array of values element.">_array</a>&amp; vec = v;</div>
<div class="line">    <span class="keywordflow">for</span> (<a class="code" href="struct__array.html#a61e069daf5d5b31875a5d249216ac8d3">_array::iterator</a> i = vec.<a class="code" href="struct__array.html#ac15280959920d28bf27568d38ee7b6ba" title="array iterator begin">begin</a>(); i != vec.<a class="code" href="struct__array.html#a1f4d85181b117638a22d04925bb386f1" title="array iterator end">end</a>(); ++i)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordtype">int</span> index = i.index();</div>
<div class="line">        <a class="code" href="structvalue.html" title="Represents the &lt;value&gt; container element.">value</a>&amp; array_element = *i;</div>
<div class="line">        ... <span class="comment">// use index and array_element</span></div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (v.<a class="code" href="structvalue.html#a3fbb0450e00e7c69726479ea7ca30371" title="true if value is struct type">is_struct</a>())</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="struct__struct.html" title="Represents the &lt;struct&gt; record structure element.">_struct</a>&amp; rec = v;</div>
<div class="line">    <span class="keywordflow">for</span> (<a class="code" href="struct__struct.html#a88edf40f7bb954061eddc160b1105ff3">_struct::iterator</a> i = rec.<a class="code" href="struct__struct.html#a69e6a472947d4aa911a82a153b9d867a" title="struct accessor iterator begin">begin</a>(); i != rec.<a class="code" href="struct__struct.html#aef253f058f1679add8210023c4f6f8bb" title="struct accessor iterator end">end</a>(); ++i)</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">char</span> *member_name = i.index();</div>
<div class="line">        <a class="code" href="structvalue.html" title="Represents the &lt;value&gt; container element.">value</a>&amp; member_value = *i;</div>
<div class="line">        ... <span class="comment">// use member_name and member_value</span></div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Parameter lists are similar to arrays and its values are indexed. We can also iterate over parameter content of XML-RPC method call:</p>
<div class="fragment"><div class="line"><a class="code" href="structmethod_call.html" title="Represents the &lt;methodCall&gt; element with &lt;methodName&gt; and request &lt;params&gt; for remote invocation...">methodCall</a> rpc(ctx, <span class="stringliteral">&quot;endpoint URL&quot;</span>, <span class="stringliteral">&quot;methodName&quot;</span>);</div>
<div class="line"><a class="code" href="structparams.html" title="Represents the &lt;params&gt; of a &lt;methodCall&gt; request and response.">params</a> request(ctx, 2);</div>
<div class="line">request[0] = ...;                <span class="comment">// first request parameter</span></div>
<div class="line">request[1] = ...;                <span class="comment">// second request parameter</span></div>
<div class="line"><a class="code" href="structparams.html" title="Represents the &lt;params&gt; of a &lt;methodCall&gt; request and response.">params</a> response = rpc(request);  <span class="comment">// execute the call</span></div>
<div class="line"><span class="keywordflow">if</span> (!rpc.error())</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">for</span> (<a class="code" href="structparams.html#a42e515c9a4bc03a29382e63dddea8496">params::iterator</a> i = response.<a class="code" href="structparams.html#a21b28ad0796dba7d6e00abb4587f7ffa" title="parameter accessor iterator begin">begin</a>(); i != response.<a class="code" href="structparams.html#a4934efffe16d4d367203c1acd0e777ce" title="parameter accessor iterator end">end</a>(); ++i)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordtype">int</span> index = i.index();</div>
<div class="line">    <a class="code" href="structvalue.html" title="Represents the &lt;value&gt; container element.">value</a>&amp; param_value = *i;</div>
<div class="line">    ... <span class="comment">// use param_value of response params</span></div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>And a JSON method call, where JSON does not use a parameter type:</p>
<div class="fragment"><div class="line"><a class="code" href="structvalue.html" title="Represents the &lt;value&gt; container element.">value</a> request(ctx);</div>
<div class="line"><a class="code" href="structvalue.html" title="Represents the &lt;value&gt; container element.">value</a> response(ctx);</div>
<div class="line">request[0] = ...;                <span class="comment">// first request parameter</span></div>
<div class="line">request[1] = ...;                <span class="comment">// second request parameter</span></div>
<div class="line"><span class="keywordflow">if</span> (!<a class="code" href="json_8h.html#a35e61d508bfe781f609b5dfa72bbbfd9" title="Client-side JSON-RPC call.">json_call</a>(cts, <span class="stringliteral">&quot;endpoint URL&quot;</span>, request, response))</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">for</span> (<a class="code" href="structparams.html#a42e515c9a4bc03a29382e63dddea8496">params::iterator</a> i = response.<a class="code" href="structparams.html#a21b28ad0796dba7d6e00abb4587f7ffa" title="parameter accessor iterator begin">begin</a>(); i != response.<a class="code" href="structparams.html#a4934efffe16d4d367203c1acd0e777ce" title="parameter accessor iterator end">end</a>(); ++i)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordtype">int</span> index = i.index();</div>
<div class="line">    <a class="code" href="structvalue.html" title="Represents the &lt;value&gt; container element.">value</a>&amp; param_value = *i;</div>
<div class="line">    ... <span class="comment">// use param_value of response params</span></div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>There are two additional methods to invoke on parameters:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> <a class="code" href="structparams.html#a6e150e3958d176f05bd6579d5d14836c" title="number of parameters">params::size</a>();         <span class="comment">// get number of parameters</span></div>
<div class="line"><span class="keywordtype">bool</span> <a class="code" href="structparams.html#af65f66c853166bc136578dffdde31316" title="true if no parameters">params::empty</a>();       <span class="comment">// true if no parameters</span></div>
</div><!-- fragment --><p>All dynamically allocated memory that is internally used to store data is deallocated with:</p>
<div class="fragment"><div class="line">soap_destroy(ctx);  <span class="comment">// delete values</span></div>
<div class="line">soap_end(ctx);      <span class="comment">// delete temp data</span></div>
<div class="line">soap_free(ctx);     <span class="comment">// delete context allocated with soap_new()</span></div>
</div><!-- fragment --><p>Additional examples are provided in the software package:</p>
<ul>
<li><code>xml-rpc-currentTime.cpp</code>: XML-RPC client in C++, also uses JSON</li>
<li><code>xml-rpc-currentTimeServer.cpp</code>: XML-RPC server in C++</li>
<li><code>xml-rpc-weblogs.cpp</code>: XML-RPC client in C++</li>
<li><code>xml-rpc-json.cpp</code>: XML-RPC to/from JSON example</li>
<li><code>json-currentTime.cpp</code>: JSON client in C++</li>
<li><code>json-currentTimeServer.cpp</code>: JSON server in C++</li>
</ul>
<h2><a class="anchor" id="cpp-cl"></a>
C++ XML-RPC Client Example                                             </h2>
<p>A typical XML-RPC calling sequence in C++ is:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;soapH.h&quot;</span> <span class="comment">// generated by the command: soapcpp2 -CSL xml-rpc.h</span></div>
<div class="line"><span class="keyword">struct </span>Namespace namespaces[] = { {NULL, NULL} }; <span class="comment">// no XML namespaces</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// create an allocation context</span></div>
<div class="line">soap *ctx = soap_new1(SOAP_C_UTFSTRING); <span class="comment">// Store Unicode in UTF-8 format</span></div>
<div class="line"><span class="comment">// create a call object</span></div>
<div class="line"><a class="code" href="structmethod_call.html" title="Represents the &lt;methodCall&gt; element with &lt;methodName&gt; and request &lt;params&gt; for remote invocation...">methodCall</a> rpc(ctx, <span class="stringliteral">&quot;endpoint URL&quot;</span>, <span class="stringliteral">&quot;methodName&quot;</span>);</div>
<div class="line"><span class="comment">// create parameter list with 5 values</span></div>
<div class="line"><a class="code" href="structparams.html" title="Represents the &lt;params&gt; of a &lt;methodCall&gt; request and response.">params</a> request(ctx, 5);</div>
<div class="line"><span class="comment">// populate parameters</span></div>
<div class="line">request[0] = 123;           <span class="comment">// first parameter is an integer</span></div>
<div class="line">request[1] = <span class="stringliteral">&quot;abc&quot;</span>;         <span class="comment">// second is a string</span></div>
<div class="line">request[2][<span class="stringliteral">&quot;name&quot;</span>] = <span class="stringliteral">&quot;joe&quot;</span>; <span class="comment">// a record, first member &quot;name&quot;</span></div>
<div class="line">request[2][<span class="stringliteral">&quot;age&quot;</span>] = 23;     <span class="comment">// a record, second member &quot;age&quot;</span></div>
<div class="line">request[3][0] = 456.789;    <span class="comment">// an array, first element (a float)</span></div>
<div class="line">request[3][1] = <span class="stringliteral">&quot;widget&quot;</span>;   <span class="comment">// an array, second element (a string)</span></div>
<div class="line">request[3][2] = <span class="keyword">true</span>;       <span class="comment">// an array, third element (a bool)</span></div>
<div class="line"><a class="code" href="structvalue.html" title="Represents the &lt;value&gt; container element.">value</a> record(ctx);          <span class="comment">// another struct</span></div>
<div class="line">record[<span class="stringliteral">&quot;foo&quot;</span>] = 1;</div>
<div class="line">record[<span class="stringliteral">&quot;bar&quot;</span>] = 2;</div>
<div class="line">request[4] = record;        <span class="comment">// assign record to parameter</span></div>
<div class="line"><span class="comment">// get list of parameters by making the XML-RPC call</span></div>
<div class="line"><a class="code" href="structparams.html" title="Represents the &lt;params&gt; of a &lt;methodCall&gt; request and response.">params</a> response = rpc(request);</div>
<div class="line"><span class="comment">// check result</span></div>
<div class="line"><span class="keywordflow">if</span> (rpc.error())</div>
<div class="line">    soap_print_fault(ctx, stderr);</div>
<div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (response.<a class="code" href="structparams.html#af65f66c853166bc136578dffdde31316" title="true if no parameters">empty</a>())</div>
<div class="line">    printf(<span class="stringliteral">&quot;No response data\n&quot;</span>);</div>
<div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (response.<a class="code" href="structparams.html#a6e150e3958d176f05bd6579d5d14836c" title="number of parameters">size</a>() &gt; 1)</div>
<div class="line">    printf(<span class="stringliteral">&quot;More than one response data\n&quot;</span>);</div>
<div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (response[0].is_array() &amp;&amp; !response[0].<a class="code" href="structparams.html#af65f66c853166bc136578dffdde31316" title="true if no parameters">empty</a>())</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; response[0].<a class="code" href="structparams.html#a6e150e3958d176f05bd6579d5d14836c" title="number of parameters">size</a>())</div>
<div class="line">        ... = response[0][i];</div>
<div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (response[0].is_struct())</div>
<div class="line">{</div>
<div class="line">    ... = response[0][<span class="stringliteral">&quot;membername1&quot;</span>];</div>
<div class="line">    ... = response[0][<span class="stringliteral">&quot;membername2&quot;</span>];</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (response[0].is_base64())</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="struct__base64.html" title="Represents the &lt;base64&gt; binary data element.">_base64</a> raw&amp; = response[0];</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *raw = bin.<a class="code" href="struct__base64.html#accb75dbcdaf316a692d92d42783ffcb8" title="pointer to data">ptr</a>();</div>
<div class="line">    <span class="keywordtype">int</span> size = bin.<a class="code" href="struct__base64.html#a89555bd2f9d977fd17bc2823bef10230" title="byte size of data">size</a>();</div>
<div class="line">    ... <span class="comment">// use raw[0..size-1] data</span></div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (response[0].is_bool())</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">bool</span> flag = response[0];</div>
<div class="line">    ... <span class="comment">// use boolean flag</span></div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (response[0].is_int())</div>
<div class="line">{</div>
<div class="line">    LONG64 num = response[0];</div>
<div class="line">    ... <span class="comment">// use integer</span></div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (response[0].is_double())</div>
<div class="line">{   <span class="keywordtype">double</span> num = response[0];</div>
<div class="line">    ... <span class="comment">// use double float</span></div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (response[0].is_string())</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> *str = response[0];</div>
<div class="line">    <span class="comment">// use string, note that also legal is:</span></div>
<div class="line">    <span class="keyword">const</span> std::string&amp; st = response[0];</div>
<div class="line">    <span class="comment">// and conversion from UTF-8 to wide string unicode:</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">wchar_t</span> *w = response[0];</div>
<div class="line">    <span class="keyword">const</span> std::string&amp; ws = response[0];</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (response[0].is_dateTime())</div>
<div class="line">{</div>
<div class="line">    time_t t = response[0];</div>
<div class="line">    ... <span class="comment">// use time</span></div>
<div class="line">}</div>
<div class="line"><span class="comment">// deallocate all</span></div>
<div class="line">soap_destroy(ctx);</div>
<div class="line">soap_end(ctx);</div>
<div class="line">soap_free(ctx);</div>
</div><!-- fragment --><p>Alternatively when desired, the parameters of the <a class="el" href="structmethod_call.html" title="Represents the &lt;methodCall&gt; element with &lt;methodName&gt; and request &lt;params&gt; for remote invocation...">methodCall</a> object can be directly populated as follows:</p>
<div class="fragment"><div class="line"><a class="code" href="structmethod_call.html" title="Represents the &lt;methodCall&gt; element with &lt;methodName&gt; and request &lt;params&gt; for remote invocation...">methodCall</a> rpc(ctx, <span class="stringliteral">&quot;endpoint URL&quot;</span>, <span class="stringliteral">&quot;methodName&quot;</span>);</div>
<div class="line"><span class="comment">// populate parameters</span></div>
<div class="line">rpc[0] = 123;           <span class="comment">// first parameter is an integer</span></div>
<div class="line">rpc[1] = <span class="stringliteral">&quot;abc&quot;</span>;         <span class="comment">// second is a string</span></div>
<div class="line">rpc[2][<span class="stringliteral">&quot;name&quot;</span>] = <span class="stringliteral">&quot;joe&quot;</span>; <span class="comment">// a record, first member &quot;name&quot;</span></div>
<div class="line">rpc[2][<span class="stringliteral">&quot;age&quot;</span>] = 23;     <span class="comment">// a record, second member &quot;age&quot;</span></div>
<div class="line">rpc[3][0] = 456.789;    <span class="comment">// an array, first element (a float)</span></div>
<div class="line">rpc[3][1] = <span class="stringliteral">&quot;widget&quot;</span>;   <span class="comment">// an array, second element (a string)</span></div>
<div class="line">rpc[3][2] = <span class="keyword">true</span>;       <span class="comment">// an array, third element (a bool)</span></div>
<div class="line">rpc[4][<span class="stringliteral">&quot;foo&quot;</span>] = 1;</div>
<div class="line">rpc[4][<span class="stringliteral">&quot;bar&quot;</span>] = 2;</div>
<div class="line"><span class="comment">// get list of parameters by making the XML-RPC call</span></div>
<div class="line"><a class="code" href="structparams.html" title="Represents the &lt;params&gt; of a &lt;methodCall&gt; request and response.">params</a> response = rpc();</div>
</div><!-- fragment --><p>Note that in the client code, after the response is retrieved, the implicit type casts done by assignments extract the values. These casts can be used anywhere to extract values:</p>
<div class="fragment"><div class="line"><a class="code" href="structparams.html" title="Represents the &lt;params&gt; of a &lt;methodCall&gt; request and response.">params</a> response = rpc();</div>
<div class="line"><span class="keywordtype">double</span> sum = 0.0;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; response.<a class="code" href="structparams.html#a6e150e3958d176f05bd6579d5d14836c" title="number of parameters">size</a>(); i++)</div>
<div class="line">    <span class="keywordflow">if</span> (response[i].is_double())    <span class="comment">// is this parameter a double float?</span></div>
<div class="line">        sum += (<span class="keywordtype">double</span>)response[i];</div>
</div><!-- fragment --><p>Type casts can also be used to convert data, which means they never produce an exception. Casting to string <code>(const char*)</code> converts atomic values and base64 data to strings, but does not convert compound types such as arrays and structs.</p>
<div class="fragment"><div class="line"><a class="code" href="structparams.html" title="Represents the &lt;params&gt; of a &lt;methodCall&gt; request and response.">params</a> response = rpc();</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; response.<a class="code" href="structparams.html#a6e150e3958d176f05bd6579d5d14836c" title="number of parameters">size</a>(); i++)</div>
<div class="line">    printf(<span class="stringliteral">&quot;response[%d] = %s\n&quot;</span>, i, (<span class="keyword">const</span> <span class="keywordtype">char</span>*)response[i]);</div>
</div><!-- fragment --><p>which prints a string representation of the int, double, boolean, time, or base64 values of parameters. An empty string is printed for arrays and structs. Use iterators to walk over arrays and structs to print values. Or use the JSON module to print values in JSON format, see further on JSON below.</p>
<h2><a class="anchor" id="cpp-sr"></a>
C++ XML-RPC Server Example                                             </h2>
<p>A typical C++ XML-RPC server sequence is:</p>
<div class="fragment"><div class="line"><span class="comment">// create an allocation context</span></div>
<div class="line">soap *ctx = soap_new1(SOAP_C_UTFSTRING);</div>
<div class="line"><span class="comment">// create a method object</span></div>
<div class="line"><a class="code" href="structmethod_call.html" title="Represents the &lt;methodCall&gt; element with &lt;methodName&gt; and request &lt;params&gt; for remote invocation...">methodCall</a> rpc(ctx);</div>
<div class="line"><span class="comment">// option 1: parse and write to/from stdin/out</span></div>
<div class="line"><span class="comment">// (no code needed)</span></div>
<div class="line"><span class="comment">// option 2: parse and write to/from FILE</span></div>
<div class="line"><span class="comment">// ctx-&gt;recvfd = ...; // set input FD</span></div>
<div class="line"><span class="comment">// ctx-&gt;sendfd = ...; // set output FD</span></div>
<div class="line"><span class="comment">// option 3: parse and write to/from IO streams</span></div>
<div class="line"><span class="comment">// ctx-&gt;is = ...; // set input stream</span></div>
<div class="line"><span class="comment">// ctx-&gt;os = ...; // set output stream</span></div>
<div class="line"><span class="keywordflow">if</span> (rpc.recv() != SOAP_OK)</div>
<div class="line">    soap_print_fault(ctx, stderr);</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">{</div>
<div class="line">    <span class="comment">// create response</span></div>
<div class="line">    <a class="code" href="structmethod_response.html" title="Represents the &lt;methodResponse&gt; element with response &lt;params&gt; and &lt;fault&gt;.">methodResponse</a> response(ctx);</div>
<div class="line">    <span class="comment">// check method name</span></div>
<div class="line">    <span class="keywordflow">if</span> (!strcmp(rpc.name(), <span class="stringliteral">&quot;methodName&quot;</span>))</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// method name matches: populate response parameters with values:</span></div>
<div class="line">        response[0] = ...;</div>
<div class="line">        response[1] = ...;</div>
<div class="line">        ... <span class="comment">// add response data </span></div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// otherwise, set fault</span></div>
<div class="line">        response.set_fault(<span class="stringliteral">&quot;Wrong method&quot;</span>);</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// send response</span></div>
<div class="line">    <span class="keywordflow">if</span> (response.send() != SOAP_OK)</div>
<div class="line">        soap_print_fault(ctx, stderr);</div>
<div class="line">}</div>
<div class="line"><span class="comment">// close (but keep-alive setting keeps socket open)</span></div>
<div class="line">soap_closesock(ctx);</div>
<div class="line"><span class="comment">// clean up</span></div>
<div class="line">soap_destroy(ctx);</div>
<div class="line">soap_end(ctx);</div>
<div class="line"><span class="comment">// free context (but we can reuse it to serve next call)</span></div>
<div class="line">soap_free(ctx);</div>
</div><!-- fragment --><p>With option 1 the server code above uses standard in/out and thus runs over CGI. Other possibilities are given by options 2 and 3.</p>
<p>To serve requests at a port, we use the <code>soap_bind()</code> and <code>soap_accept()</code> calls to bind the server to a port and accept requests via socket, see also the docs and examples for these calls (e.g. samples/webserver.c):</p>
<div class="fragment"><div class="line"><span class="comment">// create an allocation context</span></div>
<div class="line">soap *ctx = soap_new1(SOAP_IO_KEEPALIVE | SOAP_C_UTFSTRING);</div>
<div class="line"><span class="comment">// bind to port 8080</span></div>
<div class="line"><span class="keywordflow">if</span> (!soap_valid_socket(soap_bind(ctx, NULL, 8080, 100)))</div>
<div class="line">    ... <span class="comment">// error, stop</span></div>
<div class="line"><span class="comment">// accept messages in server loop</span></div>
<div class="line"><span class="keywordflow">for</span> (;;)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (!soap_valid_socket(soap_accept(ctx)))</div>
<div class="line">        ... <span class="comment">// error, stop</span></div>
<div class="line">    <span class="comment">// create a method object</span></div>
<div class="line">    <a class="code" href="structmethod_call.html" title="Represents the &lt;methodCall&gt; element with &lt;methodName&gt; and request &lt;params&gt; for remote invocation...">methodCall</a> rpc(ctx);</div>
<div class="line">    <span class="comment">// parse it from socket</span></div>
<div class="line">    <span class="keywordflow">if</span> (rpc.recv() != SOAP_OK)</div>
<div class="line">        soap_print_fault(ctx, stderr);</div>
<div class="line">    ... <span class="comment">// process request, produce result to send as shown above</span></div>
<div class="line">    <span class="comment">// close (but keep-alive setting keeps socket open)</span></div>
<div class="line">    soap_closesock(ctx);</div>
<div class="line">    <span class="comment">// clean up</span></div>
<div class="line">    soap_destroy(ctx);</div>
<div class="line">    soap_end(ctx);</div>
<div class="line">}</div>
<div class="line"><span class="comment">// free context</span></div>
<div class="line">soap_free(ctx);</div>
</div><!-- fragment --><h2><a class="anchor" id="cpp-io"></a>
C++ XML-RPC Data Serialization from/to Streams                         </h2>
<p>To send and receive XML over streams, use <code>xml-rpc-io.h</code> and <code>xml-rpc-io.cpp</code>. For example:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;xml-rpc-io.h&quot;</span></div>
<div class="line">std::cout &lt;&lt; response[0] &lt;&lt; std::endl;</div>
</div><!-- fragment --><p>which will display the data in XML-RPC format. To parse XML-RPC data from a stream, use:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;xml-rpc-io.h&quot;</span></div>
<div class="line"><a class="code" href="structvalue.html" title="Represents the &lt;value&gt; container element.">value</a> v(ctx);</div>
<div class="line">std::cin &gt;&gt; v;</div>
</div><!-- fragment --><p>Compile and link together with <code>soapC.cpp</code>, <code>xml-rpc.cpp</code>, <code>xml-rpc-io.cpp</code>, and <code>stdsoap2.cpp</code>.</p>
<h2><a class="anchor" id="cpp-js"></a>
C++ JSON Serialization from/to Streams                                 </h2>
<p>To display values in JSON format or to parse JSON data, use the <code><a class="el" href="json_8h.html">json.h</a></code> and <code>json.cpp</code> JSON serializers in combination with <code>xml-rpc.cpp</code> and the auto-generated <code>soapH.h</code> and <code>soapC.cpp</code>. It is also possible to send and receive JSON data over HTTP as JSON-RPC operations, but this requires some more coding (see <a href="#cpp-jr">JSON-RPC over HTTP</a> below).</p>
<p>Because the internal data is the same for XML-RPC and JSON, You can dump data in XML-RPC or in JSON format. You can also parse XML-RPC data and dump to JSON data and vice versa.</p>
<p>For example, we can parse a JSON-formatted string and use that data to make an XML-RPC call:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="json_8h.html">json.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;sstream&gt;</span></div>
<div class="line"><span class="keyword">struct </span>Namespace namespaces[] = { {NULL, NULL} }; <span class="comment">// no XML namespaces</span></div>
<div class="line"></div>
<div class="line">soap *ctx = soap_new1(SOAP_C_UTFSTRING); <span class="comment">// UTF-8 in char*/std::string</span></div>
<div class="line"><a class="code" href="structvalue.html" title="Represents the &lt;value&gt; container element.">value</a> request(ctx);</div>
<div class="line">istringstream in;</div>
<div class="line">in.str(<span class="stringliteral">&quot;[ [1, \&quot;2\&quot;, 3.14, true], {\&quot;name\&quot;: \&quot;john\&quot;, \&quot;age\&quot;: 24} ]&quot;</span>);</div>
<div class="line">in &gt;&gt; request;                      <span class="comment">// parse JSON, store as XML-PRC data</span></div>
<div class="line"><a class="code" href="structparams.html" title="Represents the &lt;params&gt; of a &lt;methodCall&gt; request and response.">params</a> response = rpc(request);     <span class="comment">// make the XML-RPC call</span></div>
<div class="line">std::cout &lt;&lt; response &lt;&lt; std::endl; <span class="comment">// display result in JSON</span></div>
</div><!-- fragment --><p>Compile and link together with <code>soapC.cpp</code>, <code>xml-rpc.cpp</code>, <code>json.cpp</code>, and <code>stdsoap2.cpp</code>.</p>
<p>The JSON protocol has fewer data types than XML-RPC, so type information can be lost when serializing to JSON:</p>
<ul>
<li>XML-RPC has a dateTime type, JSON does not. The JSON serializer converts the dateTime type to a dateTime-formatted string.</li>
<li>XML-RPC uses a base64 type to exchange raw binary data. The base64 data is converted to a string with base64 content by the JSON serializer.</li>
</ul>
<p>See the section on C++ Examples on how to populate and extract C++ data.</p>
<p>Strings are stored and exchanged in UTF-8 format in 8-bit strings (<code>char*</code> and <code>std::string</code>) by using the <code>SOAP_C_UTFSTRING</code> flag. Without this flag, 8-bit strings are converted to UTF-8. By contrast, wide character strings use unicode.</p>
<p>To force reading and writing JSON in ISO 8859-1 format from UTF-8 strings, use the <code>SOAP_ENC_LATIN</code> flag to set the context.</p>
<h2><a class="anchor" id="cpp-jr"></a>
C++ JSON-RPC over HTTP (REST method)                                   </h2>
<p>To invoke JSON-RPC over HTTP on the client side, use <code>json_call</code>:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;soapH.h&quot;</span>           <span class="comment">// also compile and link soapC.cpp, xml-rpc.cpp</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="json_8h.html">json.h</a>&quot;</span>            <span class="comment">// also compile and link json.cpp</span></div>
<div class="line"><span class="keyword">struct </span>Namespace namespaces[] = { {NULL, NULL} }; <span class="comment">// no XML namespaces</span></div>
<div class="line"></div>
<div class="line">soap *ctx = soap_new1(SOAP_C_UTFSTRING);</div>
<div class="line"><a class="code" href="structvalue.html" title="Represents the &lt;value&gt; container element.">value</a> request(ctx), response(ctx);</div>
<div class="line"><span class="comment">// now populate the &#39;request&#39; data to send</span></div>
<div class="line"></div>
<div class="line"><span class="keywordflow">if</span> (<a class="code" href="json_8h.html#a35e61d508bfe781f609b5dfa72bbbfd9" title="Client-side JSON-RPC call.">json_call</a>(ctx, <span class="stringliteral">&quot;URL&quot;</span>, request, response) != SOAP_OK))</div>
<div class="line">  ... <span class="comment">// error</span></div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">  ... <span class="comment">// use the &#39;response&#39; data response</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// dealloc objects and temp data</span></div>
<div class="line">soap_destroy(ctx);</div>
<div class="line">soap_end(ctx);</div>
<div class="line">... <span class="comment">// make other calls etc.</span></div>
<div class="line"><span class="comment">// dealloc context</span></div>
<div class="line">soap_free(ctx);</div>
</div><!-- fragment --><p>To implement a JSON-RPC server for CGI (e.g. install in cgi-bin):</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;soapH.h&quot;</span>           <span class="comment">// also compile and link soapC.cpp, xml-rpc.cpp</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="json_8h.html">json.h</a>&quot;</span>            <span class="comment">// also compile and link json.cpp</span></div>
<div class="line"><span class="keyword">struct </span>Namespace namespaces[] = { {NULL, NULL} }; <span class="comment">// no XML namespaces</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{ soap *ctx = soap_new1(SOAP_C_UTFSTRING);</div>
<div class="line">  <a class="code" href="structvalue.html" title="Represents the &lt;value&gt; container element.">value</a> request(ctx), response(ctx);</div>
<div class="line">  <span class="keywordflow">if</span> (soap_begin_recv(ctx)</div>
<div class="line">   || <a class="code" href="json_8h.html#a9ff2a0fee68897b59e0b30ce64259b99">json_recv</a>(ctx, request)</div>
<div class="line">   || soap_end_recv(ctx))</div>
<div class="line">    soap_send_fault(ctx);</div>
<div class="line">  <span class="keywordflow">else</span></div>
<div class="line">  { ... <span class="comment">// use the &#39;request&#39; value</span></div>
<div class="line">    ... <span class="comment">// set the &#39;response&#39; value</span></div>
<div class="line">    <span class="comment">// set http content type</span></div>
<div class="line">    ctx-&gt;http_content = <span class="stringliteral">&quot;application/json; charset=utf-8&quot;</span>;</div>
<div class="line">    <span class="comment">// send http header and body</span></div>
<div class="line">    <span class="keywordflow">if</span> (soap_response(ctx, SOAP_FILE)</div>
<div class="line">     || <a class="code" href="json_8h.html#a57d66615d6ad549bafa44a3a14c77511">json_send</a>(ctx, response)</div>
<div class="line">     || soap_end_send(ctx))</div>
<div class="line">      soap_print_fault(ctx, stdout);</div>
<div class="line">  }</div>
<div class="line">  <span class="comment">// dealloc all</span></div>
<div class="line">  soap_destroy(ctx);</div>
<div class="line">  soap_end(ctx);</div>
<div class="line">  soap_free(ctx);</div>
<div class="line">}</div>
</div><!-- fragment --><p>For client and server examples, please see the gSOAP package content:</p>
<ul>
<li><code>gsoap/samples/xml-rpc-json/json-currentTime.cpp</code></li>
<li><code>gsoap/samples/xml-rpc-json/json-currentTimeServer.cpp</code></li>
</ul>
<h2><a class="anchor" id="json-ns"></a>
Moving JSON Types into a C++ Namespace                                </h2>
<p>A C++ namespace is preferred to separate JSON types and operations from other project-related types and operations.</p>
<p>To put all JSON (and XML-RPC) types and operations in a <code>json</code> C++ namespace, execute the following commands:</p>
<div class="fragment"><div class="line">soapcpp2 -qjson -CSL xml-rpc.h</div>
<div class="line">soapcpp2 -penv -CSL env.h</div>
</div><!-- fragment --><p>where <code>env.h</code> is an empty file. This generates <code>jsonStub.h</code>, <code>jsonH.h</code>, <code>jsonC.cpp</code>, and <code>envC.cpp</code>.</p>
<p>Then compile the source files together with <code>xml-rpc.cpp</code> and <code>json.cpp</code> and set the macro <code>-DJSON_NAMESPACE</code>:</p>
<div class="fragment"><div class="line">c++ -DJSON_NAMESPACE xml-rpc.cpp json.cpp jsonC.cpp envC.cpp stdsoap2.cpp ...</div>
</div><!-- fragment --><p>Your project should now use the <code>json</code> namespace with a <code>value</code>, for example:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="json_8h.html">json.h</a>&quot;</span></div>
<div class="line"><span class="keyword">struct </span>soap *ctx = soap_new();</div>
<div class="line">json::value v(ctx);</div>
<div class="line">std::cin &gt;&gt; v;        <span class="comment">// parse JSON</span></div>
<div class="line">std::cout &lt;&lt; v;       <span class="comment">// output JSON</span></div>
</div><!-- fragment --><h1><a class="anchor" id="c"></a>
C XML-RPC and JSON                                                          </h1>
<p>The following source files are provided for XML-RPC support in C:</p>
<ul>
<li><code><a class="el" href="xml-rpc_8h.html">xml-rpc.h</a></code>: XML-RPC binding as a gSOAP .h file for soapcpp2 (do not #include this file in your project builds)</li>
</ul>
<p>For JSON serialization, use the following files instead of xml-rpc-io.h and xml-rpc-io.cpp:</p>
<ul>
<li><code><a class="el" href="json__c_8h.html">json_c.h</a></code>: C JSON serializer</li>
<li><code>json_c.c</code>: C JSON serializer</li>
</ul>
<p>For JSON-RPC over HTTP (JSON REST method), please use the <code>plugin/httppost.c</code> plugin. See <a href="#c-jr">JSON-RPC over HTTP</a> explanation below.</p>
<p>Note that <code>soapH.h</code>, <code>soapStub.h</code>, and <code>soapC.c</code> are required for XML-RPC and JSON. To generate these C files, you need to execute: </p>
<pre class="fragment">soapcpp2 -c -CSL xml-rpc.h
</pre><p>Also compile and link with <code>stdsoap2.c</code> (or link with <code>libgsoap.a</code> installed by the gSOAP package).</p>
<h2><a class="anchor" id="c-ex"></a>
C Examples                                                               </h2>
<p>Examples are provided in the software package:</p>
<ul>
<li><code>xml-rpc-currentTime.c</code>: client in C</li>
<li><code>xml-rpc-weblogs.c</code>: client in C</li>
</ul>
<p>All XML-RPC and JSON message manipulation is done at a very low-level.</p>
<h2><a class="anchor" id="c-cl"></a>
C XML-RPC Client Example                                                 </h2>
<p>An XML RPC call is made using the following function that you can define for your convenience:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;soapH.h&quot;</span> <span class="comment">// generated by the command: soapcpp2 -c -CSL xml-rpc.h</span></div>
<div class="line"><span class="keyword">struct </span>Namespace namespaces[] = { {NULL, NULL} }; <span class="comment">// no XML namespaces</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> <a class="code" href="structmethod_call.html" title="Represents the &lt;methodCall&gt; element with &lt;methodName&gt; and request &lt;params&gt; for remote invocation...">methodCall</a>(<span class="keyword">struct</span> soap *ctx, <span class="keyword">const</span> <span class="keywordtype">char</span> *URL, <span class="keyword">struct</span> <a class="code" href="structmethod_call.html" title="Represents the &lt;methodCall&gt; element with &lt;methodName&gt; and request &lt;params&gt; for remote invocation...">methodCall</a> *m, <span class="keyword">struct</span> <a class="code" href="structmethod_response.html" title="Represents the &lt;methodResponse&gt; element with response &lt;params&gt; and &lt;fault&gt;.">methodResponse</a> *r)</div>
<div class="line">{   <span class="comment">/* no namespaces */</span></div>
<div class="line">    ctx-&gt;namespaces = NULL;</div>
<div class="line">    <span class="comment">/* no SOAP encodingStyle */</span></div>
<div class="line">    ctx-&gt;encodingStyle = NULL;</div>
<div class="line">    <span class="comment">/* connect, send request, and receive response */</span></div>
<div class="line">    <span class="keywordflow">if</span> (soap_connect(ctx, URL, NULL)</div>
<div class="line">     || soap_begin_send(ctx)</div>
<div class="line">     || soap_put_methodCall(ctx, m, <span class="stringliteral">&quot;methodCall&quot;</span>, NULL)</div>
<div class="line">     || soap_end_send(ctx)</div>
<div class="line">     || soap_begin_recv(ctx)</div>
<div class="line">     || !soap_get_methodResponse(ctx, r, <span class="stringliteral">&quot;methodResponse&quot;</span>, NULL)</div>
<div class="line">     || soap_end_recv(ctx))</div>
<div class="line">        <span class="keywordflow">return</span> soap_closesock(ctx); <span class="comment">/* closes socket and returns error */</span></div>
<div class="line">    soap_closesock(ctx);</div>
<div class="line">    <span class="keywordflow">return</span> SOAP_OK;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Then use this XML-RPC method caller in C as follows:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>soap *ctx = soap_new1(SOAP_C_UTFSTRING); <span class="comment">/* store UTF-8 in char* */</span></div>
<div class="line"><span class="keyword">struct </span><a class="code" href="structmethod_call.html" title="Represents the &lt;methodCall&gt; element with &lt;methodName&gt; and request &lt;params&gt; for remote invocation...">methodCall</a> m;</div>
<div class="line"><span class="keyword">struct </span><a class="code" href="structmethod_response.html" title="Represents the &lt;methodResponse&gt; element with response &lt;params&gt; and &lt;fault&gt;.">methodResponse</a> r;</div>
<div class="line"><span class="keyword">struct </span><a class="code" href="structparam.html" title="Represents a &lt;param&gt; of the &lt;params&gt; of a &lt;methodCall&gt;.">param</a> p[4];  <span class="comment">/* method has four parameters to send */</span></div>
<div class="line"><a class="code" href="xml-rpc_8h.html#aa426077eb6115a901e6e13fd6de086cf" title="Scalar &lt;i4&gt; element with 32 bit integer.">_i4</a> n;              <span class="comment">/* a 32 bit int */</span></div>
<div class="line"><a class="code" href="xml-rpc_8h.html#af491b2f23d4898155a36432d7292a3ba" title="Scalar &lt;int&gt; element with 64 bit integer.">_int</a> m;             <span class="comment">/* a 64 bit int */</span></div>
<div class="line"><a class="code" href="xml-rpc_8h.html#a19d7826ca00b37712548a85beada6778" title="Scalar &lt;double&gt; element with double floating point.">_double</a> x;          <span class="comment">/* a double float */</span></div>
<div class="line"><span class="keyword">struct </span><a class="code" href="struct__struct.html" title="Represents the &lt;struct&gt; record structure element.">_struct</a> s;   <span class="comment">/* a struct ... */</span></div>
<div class="line"><span class="keyword">struct </span><a class="code" href="structmember.html" title="Represents the &lt;member&gt; element of a &lt;struct&gt;.">member</a> f[2]; <span class="comment">/* ... with 2 members */</span></div>
<div class="line"><span class="keyword">struct </span><a class="code" href="struct__array.html" title="Represents the &lt;array&gt; array of values element.">_array</a> a;    <span class="comment">/* an array ... */</span></div>
<div class="line"><span class="keyword">struct </span><a class="code" href="structvalue.html" title="Represents the &lt;value&gt; container element.">value</a> v[2];  <span class="comment">/* ... with 2 values */</span></div>
<div class="line"><a class="code" href="xml-rpc_8h.html#a7d938291b52a0161e5fae7b812697c00" title="Scalar &lt;boolean&gt; element with values 0 (false) or 1 (true)">_boolean</a> <a class="code" href="json__c_8h.html#acce7277a58428ea88d62d2e5844fbc31">False</a> = 0, <a class="code" href="json__c_8h.html#ac6ae2bed188396fcbc0900db22b2563f">True</a> = 1;</div>
<div class="line"><span class="comment">/* Set up method call */</span></div>
<div class="line">m.methodName = <span class="stringliteral">&quot;methodName&quot;</span>;</div>
<div class="line"><span class="comment">/* set the four parameters */</span></div>
<div class="line">m.params.__size = 4;</div>
<div class="line">m.params.param = p;</div>
<div class="line">memset(p, 0, <span class="keyword">sizeof</span>(p));</div>
<div class="line">p[0].value.__type = SOAP_TYPE__string;</div>
<div class="line">p[0].value.ref = <span class="stringliteral">&quot;a string parameter&quot;</span>;</div>
<div class="line">p[1].value.__type = SOAP_TYPE__i4;  <span class="comment">/* IMPORTANT: _i4 is 32 bit */</span></div>
<div class="line">p[1].value.ref = &amp;n;</div>
<div class="line">n = 123;</div>
<div class="line">p[2].value.__type = SOAP_TYPE__int; <span class="comment">/* IMPORTANT: _int is 64 bit */</span></div>
<div class="line">p[2].value.ref = &amp;m;</div>
<div class="line">m = 1234567890;</div>
<div class="line">p[3].value.__type = SOAP_TYPE__double;</div>
<div class="line">p[3].value.ref = &amp;x;</div>
<div class="line">x = 4.56;</div>
<div class="line">p[4].value.__type = SOAP_TYPE__struct;</div>
<div class="line">p[4].value.ref = &amp;s;</div>
<div class="line">memset(&amp;s, 0, <span class="keyword">sizeof</span>(s));</div>
<div class="line">s.__size = 2;</div>
<div class="line">s.member = f;</div>
<div class="line">memset(f, 0, <span class="keyword">sizeof</span>(f));</div>
<div class="line">f[0].name = <span class="stringliteral">&quot;memberName1&quot;</span>;</div>
<div class="line">f[0].value.__type = SOAP_TYPE__boolean;</div>
<div class="line">f[0].value.ref = &amp;<a class="code" href="json__c_8h.html#ac6ae2bed188396fcbc0900db22b2563f">True</a>;</div>
<div class="line">f[1].name = <span class="stringliteral">&quot;memberName2&quot;</span>;</div>
<div class="line">f[0].value.__type = SOAP_TYPE__array;</div>
<div class="line">f[0].value.ref = &amp;a;</div>
<div class="line">memset(&amp;a, 0, <span class="keyword">sizeof</span>(a));</div>
<div class="line">a.data.__size = 2;</div>
<div class="line">a.data.value = v;</div>
<div class="line">memset(v, 0, <span class="keyword">sizeof</span>(v));</div>
<div class="line">v[0].__type = SOAP_TYPE__string;</div>
<div class="line">v[0].ref = <span class="stringliteral">&quot;hello&quot;</span>;</div>
<div class="line">v[1].__type = SOAP_TYPE__string;</div>
<div class="line">v[1].ref = <span class="stringliteral">&quot;world&quot;</span>;</div>
<div class="line"><span class="comment">/* connect, send request, and receive response */</span></div>
<div class="line"><span class="keywordflow">if</span> (<a class="code" href="structmethod_call.html" title="Represents the &lt;methodCall&gt; element with &lt;methodName&gt; and request &lt;params&gt; for remote invocation...">methodCall</a>(ctx, <span class="stringliteral">&quot;http://domain/path/service&quot;</span>, &amp;m, &amp;r))</div>
<div class="line">{   soap_print_fault(ctx, stderr);</div>
<div class="line">    exit(ctx-&gt;error);</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">if</span> (r.<a class="code" href="structmethod_response.html#a12cde024598eca0591034800c5e5396c" title="response fault">fault</a>)</div>
<div class="line">{   <span class="comment">/* print fault on stdout */</span></div>
<div class="line">    soap_begin_send(ctx);</div>
<div class="line">    soap_put_fault(ctx, r.<a class="code" href="structmethod_response.html#a12cde024598eca0591034800c5e5396c" title="response fault">fault</a>, <span class="stringliteral">&quot;fault&quot;</span>, NULL);</div>
<div class="line">    soap_end_send(ctx);</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">{   <span class="comment">/* print response parameters */</span></div>
<div class="line">    <span class="keywordtype">int</span> i;</div>
<div class="line">    <span class="keywordflow">for</span> (i = 0; i &lt; r.<a class="code" href="structmethod_response.html#aa7ce822e433441be354b3667876786be" title="response parameters">params</a>-&gt;<a class="code" href="structparams.html#a06e3329b37920ec9a0ed8a97cece2835" title="number of parameters">__size</a>; i++)</div>
<div class="line">    {   printf(<span class="stringliteral">&quot;Return parameter %d = &quot;</span>, i+1);</div>
<div class="line">        display(&amp;r.<a class="code" href="structmethod_response.html#aa7ce822e433441be354b3667876786be" title="response parameters">params</a>-&gt;<a class="code" href="structparams.html#a3d0af80a29239c8cb042d84ed52ea9f8" title="pointer to array of parameters">param</a>[i].<a class="code" href="structparam.html#a090957e613e95786c9328afc15651c60" title="parameter value">value</a>); <span class="comment">/* SEE BELOW */</span></div>
<div class="line">        printf(<span class="stringliteral">&quot;\n&quot;</span>);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>To dynamically allocate data for automatic deallocation by the gSOAP engine, use <code>soap_malloc(ctx, size)</code>, for example as follows:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structvalue.html" title="Represents the &lt;value&gt; container element.">value</a> *v = soap_malloc(ctx, 2 * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structvalue.html" title="Represents the &lt;value&gt; container element.">value</a>));</div>
<div class="line">memset(v, 0, 2 * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structvalue.html" title="Represents the &lt;value&gt; container element.">value</a>));</div>
<div class="line"></div>
<div class="line">soap_end(ctx); <span class="comment">/* deallocate all */</span></div>
</div><!-- fragment --><p>See <code>xml-rpc-currentTime.c</code> and <code>xml-rpc-weblogs.c</code> for example C code.</p>
<p>A convenient way to display XML RPC data can be implemented as follows:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> display(<span class="keyword">struct</span> <a class="code" href="structvalue.html" title="Represents the &lt;value&gt; container element.">value</a> *v)</div>
<div class="line">{   <span class="keywordtype">int</span> i;</div>
<div class="line">    <span class="keywordflow">switch</span> (v-&gt;<a class="code" href="structvalue.html#a5f111b2916de3127c723bd7e74e392df" title="optional SOAP_TYPE_X, where X is a type name">__type</a>)</div>
<div class="line">    {   <span class="keywordflow">case</span> SOAP_TYPE__boolean:</div>
<div class="line">            printf(*((<span class="keywordtype">char</span>*)v-&gt;<a class="code" href="structvalue.html#a9d8bdea6bebd0043f1ff58b9a8a38d7c" title="ref to data">ref</a>) ? <span class="stringliteral">&quot;TRUE&quot;</span> : <span class="stringliteral">&quot;FALSE&quot;</span>);</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        <span class="keywordflow">case</span> SOAP_TYPE__double:</div>
<div class="line">            printf(<span class="stringliteral">&quot;%g&quot;</span>, *((<span class="keywordtype">double</span>*)v-&gt;<a class="code" href="structvalue.html#a9d8bdea6bebd0043f1ff58b9a8a38d7c" title="ref to data">ref</a>));</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        <span class="keywordflow">case</span> SOAP_TYPE__i4:  <span class="comment">/* IMPORTANT: _i4 is 32 bit */</span></div>
<div class="line">            printf(<span class="stringliteral">&quot;%d&quot;</span>, *((<span class="keywordtype">int</span>*)v-&gt;<a class="code" href="structvalue.html#a9d8bdea6bebd0043f1ff58b9a8a38d7c" title="ref to data">ref</a>));</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        <span class="keywordflow">case</span> SOAP_TYPE__int: <span class="comment">/* IMPORTANT: _int is 64 bit */</span></div>
<div class="line">            printf(<span class="stringliteral">&quot;%lld&quot;</span>, *((LONG64*)v-&gt;<a class="code" href="structvalue.html#a9d8bdea6bebd0043f1ff58b9a8a38d7c" title="ref to data">ref</a>));</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        <span class="keywordflow">case</span> SOAP_TYPE__dateTime_DOTiso8601:</div>
<div class="line">            printf(<span class="stringliteral">&quot;%s&quot;</span>, (<span class="keywordtype">char</span>*)v-&gt;<a class="code" href="structvalue.html#a9d8bdea6bebd0043f1ff58b9a8a38d7c" title="ref to data">ref</a>);</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        <span class="keywordflow">case</span> SOAP_TYPE__string:</div>
<div class="line">            printf(<span class="stringliteral">&quot;\&quot;%s\&quot;&quot;</span>, (<span class="keywordtype">char</span>*)v-&gt;<a class="code" href="structvalue.html#a9d8bdea6bebd0043f1ff58b9a8a38d7c" title="ref to data">ref</a>);</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        <span class="keywordflow">case</span> SOAP_TYPE__base64:</div>
<div class="line">            printf(<span class="stringliteral">&quot;[%d bytes of raw data at %p]&quot;</span>,</div>
<div class="line">                ((<span class="keyword">struct</span> <a class="code" href="struct__base64.html" title="Represents the &lt;base64&gt; binary data element.">_base64</a>*)v-&gt;<a class="code" href="structvalue.html#a9d8bdea6bebd0043f1ff58b9a8a38d7c" title="ref to data">ref</a>)-&gt;__size,</div>
<div class="line">                ((<span class="keyword">struct</span> <a class="code" href="struct__base64.html" title="Represents the &lt;base64&gt; binary data element.">_base64</a>*)v-&gt;<a class="code" href="structvalue.html#a9d8bdea6bebd0043f1ff58b9a8a38d7c" title="ref to data">ref</a>)-&gt;__ptr);</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        <span class="keywordflow">case</span> SOAP_TYPE__struct:</div>
<div class="line">            printf(<span class="stringliteral">&quot;{\n&quot;</span>);</div>
<div class="line">            <span class="keywordflow">for</span> (i = 0; i &lt; ((<span class="keyword">struct </span><a class="code" href="struct__struct.html" title="Represents the &lt;struct&gt; record structure element.">_struct</a>*)v-&gt;<a class="code" href="structvalue.html#a9d8bdea6bebd0043f1ff58b9a8a38d7c" title="ref to data">ref</a>)-&gt;__size; i++)</div>
<div class="line">            {   printf(<span class="stringliteral">&quot;\&quot;%s\&quot;:&quot;</span>, ((<span class="keyword">struct</span> <a class="code" href="struct__struct.html" title="Represents the &lt;struct&gt; record structure element.">_struct</a>*)v-&gt;<a class="code" href="structvalue.html#a9d8bdea6bebd0043f1ff58b9a8a38d7c" title="ref to data">ref</a>)-&gt;member[i].name);</div>
<div class="line">                display(&amp;((<span class="keyword">struct</span> <a class="code" href="struct__struct.html" title="Represents the &lt;struct&gt; record structure element.">_struct</a>*)v-&gt;<a class="code" href="structvalue.html#a9d8bdea6bebd0043f1ff58b9a8a38d7c" title="ref to data">ref</a>)-&gt;member[i].value);</div>
<div class="line">                printf(<span class="stringliteral">&quot;,\n&quot;</span>);</div>
<div class="line">            }</div>
<div class="line">            printf(<span class="stringliteral">&quot;}\n&quot;</span>);</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        <span class="keywordflow">case</span> SOAP_TYPE__array:</div>
<div class="line">            printf(<span class="stringliteral">&quot;[\n&quot;</span>);</div>
<div class="line">            <span class="keywordflow">for</span> (i = 0; i &lt; ((<span class="keyword">struct </span><a class="code" href="struct__array.html" title="Represents the &lt;array&gt; array of values element.">_array</a>*)v-&gt;<a class="code" href="structvalue.html#a9d8bdea6bebd0043f1ff58b9a8a38d7c" title="ref to data">ref</a>)-&gt;data.__size; i++)</div>
<div class="line">            {   display(&amp;((<span class="keyword">struct</span> <a class="code" href="struct__array.html" title="Represents the &lt;array&gt; array of values element.">_array</a>*)v-&gt;<a class="code" href="structvalue.html#a9d8bdea6bebd0043f1ff58b9a8a38d7c" title="ref to data">ref</a>)-&gt;data.value[i]);</div>
<div class="line">                printf(<span class="stringliteral">&quot;,\n&quot;</span>);</div>
<div class="line">            }</div>
<div class="line">            printf(<span class="stringliteral">&quot;]\n&quot;</span>);</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        <span class="keywordflow">default</span>:</div>
<div class="line">            <span class="keywordflow">if</span> (!v-&gt;<a class="code" href="structvalue.html#a5f111b2916de3127c723bd7e74e392df" title="optional SOAP_TYPE_X, where X is a type name">__type</a>)</div>
<div class="line">                printf(<span class="stringliteral">&quot;\&quot;%s\&quot;&quot;</span>, v-&gt;<a class="code" href="structvalue.html#ad1ba4e5292336e96e96871a76fae13ab" title="&lt;value&gt; string content, when present">__any</a>);</div>
<div class="line">            <span class="keywordflow">else</span></div>
<div class="line">                printf(<span class="stringliteral">&quot;{?}&quot;</span>);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="c-js"></a>
C JSON Serialization                                                     </h2>
<p>To display values in JSON format or parse JSON data, use the <code><a class="el" href="json__c_8h.html">json_c.h</a></code> and <code>json_c.c</code> JSON serializers. It is also possible to send and receive JSON data over HTTP.</p>
<p>You can dump the XML-RPC data in JSON or populate XML-RPC from JSON data, because the data stored in C is independent of XML-RPC and JSON formats.</p>
<p>For example:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="json__c_8h.html">json_c.h</a>&quot;</span> <span class="comment">// also compile and link json.cpp for JSON serialization</span></div>
<div class="line"><span class="keyword">struct </span>Namespace namespaces[] = { {NULL, NULL} }; <span class="comment">// no XML namespaces</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>soap *ctx = soap_new1(SOAP_C_UTFSTRING);</div>
<div class="line"><span class="keyword">struct </span><a class="code" href="structvalue.html" title="Represents the &lt;value&gt; container element.">value</a> v;</div>
<div class="line"></div>
<div class="line">ctx-&gt;recvfd = ...;          <span class="comment">// set file descriptor</span></div>
<div class="line"><a class="code" href="json_8h.html#a9ff2a0fee68897b59e0b30ce64259b99">json_recv</a>(ctx, &amp;v);         <span class="comment">// parse JSON, store as XML-PRC data</span></div>
<div class="line"></div>
<div class="line">ctx-&gt;sendfd = ...;          <span class="comment">// set file descriptor</span></div>
<div class="line"><a class="code" href="json_8h.html#a57d66615d6ad549bafa44a3a14c77511">json_send</a>(ctx, &amp;v);         <span class="comment">// output JSON value</span></div>
</div><!-- fragment --><p>The JSON protocol has fewer data types than XML-RPC, so type information can be lost when serializing to JSON:</p>
<ul>
<li>XML-RPC distinguishes ints from floats while JSON only supports floats. Ints are converted to double floats by the JSON serializer.</li>
<li>XML-RPC has a dateTime type, JSON does not. The JSON serializer converts the dateTime type to a dateTime-formatted string.</li>
<li>XML-RPC uses a base64 type to exchange raw binary data. The base64 data is converted to a string with base64 content by the JSON serializer.</li>
</ul>
<p>See the section on C++ Examples on how to populate and extract C++ data.</p>
<p>Strings are stored and exchanged in UTF-8 format in 8-bit strings (<code>char*</code>) by using the <code>SOAP_C_UTFSTRING</code> flag. Without this flag, 8-bit strings are converted to UTF-8. By contrast, wide character strings use unicode.</p>
<p>To force reading and writing JSON in ISO 8859-1 format from UTF-8 strings, use the <code>SOAP_ENC_LATIN</code> flag to set the context.</p>
<h2><a class="anchor" id="c-jr"></a>
C JSON-RPC over HTTP (REST method)                                       </h2>
<p>To serialize JSON over HTTP as a client application, use <code>plugin/httppost.c</code>, for example:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;plugin/httppost.h&quot;</span>  <span class="comment">// also compile and link plugin/httppost.c</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="json__c_8h.html">json_c.h</a>&quot;</span>           <span class="comment">// also compile and link json_c.c</span></div>
<div class="line"><span class="keyword">struct </span>Namespace namespaces[] = { {NULL, NULL} }; <span class="comment">// no XML namespaces</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>soap *ctx = soap_new1(SOAP_C_UTFSTRING); <span class="comment">// UTF-8 in char*/std::string</span></div>
<div class="line"><span class="keyword">struct </span><a class="code" href="structvalue.html" title="Represents the &lt;value&gt; container element.">value</a> request;</div>
<div class="line">... <span class="comment">// now populate the &#39;request&#39; data to be send</span></div>
<div class="line"><span class="keywordflow">if</span> (soap_post_connect(ctx, <span class="stringliteral">&quot;URL&quot;</span>, NULL, <span class="stringliteral">&quot;application/json&quot;</span>)</div>
<div class="line"> || <a class="code" href="json_8h.html#a57d66615d6ad549bafa44a3a14c77511">json_send</a>(ctx, request)</div>
<div class="line"> || soap_end_send(ctx))</div>
<div class="line">    ... <span class="comment">// error</span></div>
<div class="line"><span class="keyword">struct </span><a class="code" href="structvalue.html" title="Represents the &lt;value&gt; container element.">value</a> response;</div>
<div class="line"><span class="keywordflow">if</span> (soap_begin_recv(ctx)</div>
<div class="line"> || <a class="code" href="json_8h.html#a9ff2a0fee68897b59e0b30ce64259b99">json_recv</a>(ctx, response)</div>
<div class="line"> || soap_end_recv(ctx))</div>
<div class="line">    ... <span class="comment">// error</span></div>
<div class="line">... <span class="comment">// use the &#39;response&#39; data response</span></div>
<div class="line"><span class="comment">// dealloc objects and temp data</span></div>
<div class="line">soap_end(ctx);</div>
<div class="line">... <span class="comment">// make other calls etc.</span></div>
<div class="line"><span class="comment">// dealloc context</span></div>
<div class="line">soap_free(ctx);</div>
</div><!-- fragment --> </div></div><!-- contents -->
<hr class="footer"><address class="footer"><small>
Generated on Mon Nov 9 2015 08:44:04 for <a href="http://www.genivia.com">Genivia</a> documentation of XML-RPC &amp; JSON by <a target="_blank" href="http://www.doxygen.org/index.html">Doxygen</a> 1.8.3</small></address>
</body>
</html>
