<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8">
<meta http-equiv="cache-control" content="no-cache">
<title>Genivia - soap Struct Reference</title>
<link href="genivia_tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="genivia_content.css" rel="stylesheet" type="text/css">
</head>
<body>
<div id="top">
 <div id="titlearea">
  <table height="72px" width="100%" cellspacing="0" cellpadding="0">
   <tbody>
    <tr>
     <td width="10%">&nbsp;</td>
     <td width="175px"><a href="https://www.genivia.com"><img alt="Genivia" src="GeniviaLogo2_trans_noslogan.png"/></a></td>
     <td class="tab_home"><a href="https://www.genivia.com">Home</a></td>
     <td class="tab_home"><a href="https://www.genivia.com/docs.html">Documentation</a></td>
     <td>
      <div style="float: right; font-size: 18px; font-weight: bold;">soap Struct Reference</div>
      <br>
      <div style="float: right; font-size: 10px;">updated Tue Dec 11 2018 by Robert van Engelen</div>
     </td>
     <td width="10%">&nbsp;</td>
    </tr>
   </tbody>
  </table>
 </div>
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('structsoap.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="structsoap-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">soap Struct Reference<div class="ingroups"><a class="el" href="group__group__context.html">Context with engine state</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Context with the engine state.  
 <a href="structsoap.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a740f8760f6ee4c6584e25c612f585d70"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#a740f8760f6ee4c6584e25c612f585d70">soap</a> ()</td></tr>
<tr class="memdesc:a740f8760f6ee4c6584e25c612f585d70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context (C++ only, in C use <code><a class="el" href="group__group__context.html#ga87c20488b2dc680aaa7689b1d024989c" title="Allocate and initialize a new soap context. ">soap_new</a></code> or <code><a class="el" href="group__group__context.html#ga8e034e1a7d6093eaddc11b647179657c" title="Initialize a stack-allocated soap context. ">soap_init</a></code>)  <a href="#a740f8760f6ee4c6584e25c612f585d70">More...</a><br /></td></tr>
<tr class="separator:a740f8760f6ee4c6584e25c612f585d70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa7272f77346aa7c5dbfcaa6d57ca928"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#aaa7272f77346aa7c5dbfcaa6d57ca928">soap</a> (<a class="el" href="group__group__flags.html#ga72b0491c9cbf2071f0c96c7d29b719bb">soap_mode</a> input_and_output_mode)</td></tr>
<tr class="memdesc:aaa7272f77346aa7c5dbfcaa6d57ca928"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context with the specified input and output <code><a class="el" href="group__group__flags.html#ga72b0491c9cbf2071f0c96c7d29b719bb" title="The soap_mode flags to initialize the soap context, flags can be combined with | (bit-wise or) ...">soap_mode</a></code> flags (C++ only, in C use <code><a class="el" href="group__group__context.html#ga51cde138234ed7ec8c4e25bdf6418658" title="Allocate and initialize a new soap context with input and output soap_mode flags. ...">soap_new1</a></code> or <code><a class="el" href="group__group__context.html#gac87126c3e45d2fda488e9832c2dd5be1" title="Initialize a stack-allocated soap context with input and output soap_mode flags. ">soap_init1</a></code>))  <a href="#aaa7272f77346aa7c5dbfcaa6d57ca928">More...</a><br /></td></tr>
<tr class="separator:aaa7272f77346aa7c5dbfcaa6d57ca928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a537033a707df9a2217bb397eb8762f5a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#a537033a707df9a2217bb397eb8762f5a">soap</a> (<a class="el" href="group__group__flags.html#ga72b0491c9cbf2071f0c96c7d29b719bb">soap_mode</a> input_mode, <a class="el" href="group__group__flags.html#ga72b0491c9cbf2071f0c96c7d29b719bb">soap_mode</a> output_mode)</td></tr>
<tr class="memdesc:a537033a707df9a2217bb397eb8762f5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context with the specified input and output <code><a class="el" href="group__group__flags.html#ga72b0491c9cbf2071f0c96c7d29b719bb" title="The soap_mode flags to initialize the soap context, flags can be combined with | (bit-wise or) ...">soap_mode</a></code> flags (C++ only, in C use <code><a class="el" href="group__group__context.html#ga12a87f6795b62b05164edc392b2adb1d" title="Allocate and initialize a new soap context with separate input and output soap_mode flags...">soap_new2</a></code> or <code><a class="el" href="group__group__context.html#ga3c70b587fc4f65553cfe69751d1a157e" title="Initialize a stack-allocated soap context with input and output soap_mode flags. ">soap_init2</a></code>))  <a href="#a537033a707df9a2217bb397eb8762f5a">More...</a><br /></td></tr>
<tr class="separator:a537033a707df9a2217bb397eb8762f5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b8499f93cceb2ad2cda72dbf2e4c0e0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#a5b8499f93cceb2ad2cda72dbf2e4c0e0">soap</a> (const struct <a class="el" href="structsoap.html">soap</a> &amp;)</td></tr>
<tr class="memdesc:a5b8499f93cceb2ad2cda72dbf2e4c0e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor (C++ only, in C use <code><a class="el" href="group__group__context.html#gab4c3f8ce80baf0f1fec8c86f0bb5788a" title="Allocate and initialize a new soap context as a copy of the given soap context. ">soap_copy</a></code> or <code><a class="el" href="group__group__context.html#gabcb00978a07439254c4dd44c6332b2bf" title="Copy a given soap context to an uninitialized destination soap context. ">soap_copy_context</a></code>)  <a href="#a5b8499f93cceb2ad2cda72dbf2e4c0e0">More...</a><br /></td></tr>
<tr class="separator:a5b8499f93cceb2ad2cda72dbf2e4c0e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae731dd4b82b3a91b679c410756ee4faa"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structsoap.html">soap</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#ae731dd4b82b3a91b679c410756ee4faa">operator=</a> (const struct <a class="el" href="structsoap.html">soap</a> &amp;)</td></tr>
<tr class="memdesc:ae731dd4b82b3a91b679c410756ee4faa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment constructor (C++ only, in C use <code><a class="el" href="group__group__context.html#gab4c3f8ce80baf0f1fec8c86f0bb5788a" title="Allocate and initialize a new soap context as a copy of the given soap context. ">soap_copy</a></code> or <code><a class="el" href="group__group__context.html#gabcb00978a07439254c4dd44c6332b2bf" title="Copy a given soap context to an uninitialized destination soap context. ">soap_copy_context</a></code>)  <a href="#ae731dd4b82b3a91b679c410756ee4faa">More...</a><br /></td></tr>
<tr class="separator:ae731dd4b82b3a91b679c410756ee4faa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c714b6ed5245dbe34cf7b747aa226ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#a0c714b6ed5245dbe34cf7b747aa226ac">destroy</a> ()</td></tr>
<tr class="memdesc:a0c714b6ed5245dbe34cf7b747aa226ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete all dynamically-allocated objects and data managed by this <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context (C++ only, in C use <code><a class="el" href="group__group__context.html#ga81a009ae1ea825a05e5241e2b7a8ece9" title="Delete all data from heap memory managed by the specified soap context and release the freed memory b...">soap_end</a></code>)  <a href="#a0c714b6ed5245dbe34cf7b747aa226ac">More...</a><br /></td></tr>
<tr class="separator:a0c714b6ed5245dbe34cf7b747aa226ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63d4dae42dd30970b89bfc081743503a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#a63d4dae42dd30970b89bfc081743503a">~soap</a> ()</td></tr>
<tr class="memdesc:a63d4dae42dd30970b89bfc081743503a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize and delete the <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context by finalizing with soap_done(this) (C++ only, in C use <code><a class="el" href="group__group__context.html#ga57108ca4681186e58b5b189c3528f10a" title="Finalize and free the given soap context from unmanaged heap memory. ">soap_free</a></code> or <code><a class="el" href="group__group__context.html#ga28ee8fdcf500443e0e51750324aa6a1a" title="Finalize the given soap context, i.e. when the soap context is stack allocated, automatically invoked...">soap_done</a></code>)  <a href="#a63d4dae42dd30970b89bfc081743503a">More...</a><br /></td></tr>
<tr class="separator:a63d4dae42dd30970b89bfc081743503a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a4c24dec1ac79111c4ebeb30ba73cca65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__flags.html#ga72b0491c9cbf2071f0c96c7d29b719bb">soap_mode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#a4c24dec1ac79111c4ebeb30ba73cca65">imode</a></td></tr>
<tr class="memdesc:a4c24dec1ac79111c4ebeb30ba73cca65"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context input <code><a class="el" href="group__group__flags.html#ga72b0491c9cbf2071f0c96c7d29b719bb" title="The soap_mode flags to initialize the soap context, flags can be combined with | (bit-wise or) ...">soap_mode</a></code> flags that are set at context initialization and set or cleared with <code><a class="el" href="group__group__context.html#gaa9b0819dae844b848bcd8a3598a301aa" title="Set input soap_mode flags of the given soap context. ">soap_set_imode</a></code> or <code><a class="el" href="group__group__context.html#ga0e789bd6c2f76609aec0c9f93d121e4c" title="Clear input soap_mode flags of the given soap context. ">soap_clr_imode</a></code>, respectively.  <a href="#a4c24dec1ac79111c4ebeb30ba73cca65">More...</a><br /></td></tr>
<tr class="separator:a4c24dec1ac79111c4ebeb30ba73cca65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f7cfb4dd32a7be1ec63a20f55e12521"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__flags.html#ga72b0491c9cbf2071f0c96c7d29b719bb">soap_mode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#a0f7cfb4dd32a7be1ec63a20f55e12521">omode</a></td></tr>
<tr class="memdesc:a0f7cfb4dd32a7be1ec63a20f55e12521"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context output <code><a class="el" href="group__group__flags.html#ga72b0491c9cbf2071f0c96c7d29b719bb" title="The soap_mode flags to initialize the soap context, flags can be combined with | (bit-wise or) ...">soap_mode</a></code> flags that are set at context initialization and set or cleared with <code><a class="el" href="group__group__context.html#gaf6fa6e197f360834eae124fa37e68cf7" title="Set output soap_mode flags of the given soap context. ">soap_set_omode</a></code> or <code><a class="el" href="group__group__context.html#ga8c28d2943bee7aa5c3ffaf32803b31bd" title="Clear output soap_mode flags of the given soap context. ">soap_clr_omode</a></code>, respectively.  <a href="#a0f7cfb4dd32a7be1ec63a20f55e12521">More...</a><br /></td></tr>
<tr class="separator:a0f7cfb4dd32a7be1ec63a20f55e12521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ba5188ff4e8d734652a55a11842e79c"><td class="memItemLeft" align="right" valign="top">SSL_CTX *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#a2ba5188ff4e8d734652a55a11842e79c">ctx</a></td></tr>
<tr class="memdesc:a2ba5188ff4e8d734652a55a11842e79c"><td class="mdescLeft">&#160;</td><td class="mdescRight">OpenSSL context pointer.  <a href="#a2ba5188ff4e8d734652a55a11842e79c">More...</a><br /></td></tr>
<tr class="separator:a2ba5188ff4e8d734652a55a11842e79c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39daa19f039aebc76b8c4b6bf933570a"><td class="memItemLeft" align="right" valign="top">short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#a39daa19f039aebc76b8c4b6bf933570a">version</a></td></tr>
<tr class="memdesc:a39daa19f039aebc76b8c4b6bf933570a"><td class="mdescLeft">&#160;</td><td class="mdescRight">SOAP version (0 = no SOAP, 1 = SOAP 1.1, 2 = SOAP 1.2)  <a href="#a39daa19f039aebc76b8c4b6bf933570a">More...</a><br /></td></tr>
<tr class="separator:a39daa19f039aebc76b8c4b6bf933570a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b86360871d347d0a5f18a231fa82dc8"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#a6b86360871d347d0a5f18a231fa82dc8">encodingStyle</a></td></tr>
<tr class="memdesc:a6b86360871d347d0a5f18a231fa82dc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-definable <em><code>SOAP-ENV:encodingStyle</code></em> URI value.  <a href="#a6b86360871d347d0a5f18a231fa82dc8">More...</a><br /></td></tr>
<tr class="separator:a6b86360871d347d0a5f18a231fa82dc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abda4ccd0d64f76eb57145cc4890c87b2"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#abda4ccd0d64f76eb57145cc4890c87b2">actor</a></td></tr>
<tr class="memdesc:abda4ccd0d64f76eb57145cc4890c87b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-definable <em><code>SOAP-ENV:actor</code></em> (SOAP 1.1) or <em><code>SOAP-ENV:role</code></em> (SOAP 1.2) attribute value of all <em><code>SOAP-ENV:mustUnderstand</code></em> attributed header elements.  <a href="#abda4ccd0d64f76eb57145cc4890c87b2">More...</a><br /></td></tr>
<tr class="separator:abda4ccd0d64f76eb57145cc4890c87b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a632c5b76ad5a032fd5b0f36f29ce5dcc"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#a632c5b76ad5a032fd5b0f36f29ce5dcc">lang</a></td></tr>
<tr class="memdesc:a632c5b76ad5a032fd5b0f36f29ce5dcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-definable <em><code>xml:lang</code></em> attribute value of <em><code>SOAP-ENV:Text</code></em> to output the SOAP Fault string/reason (<code>en</code> by default)  <a href="#a632c5b76ad5a032fd5b0f36f29ce5dcc">More...</a><br /></td></tr>
<tr class="separator:a632c5b76ad5a032fd5b0f36f29ce5dcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d7aca6ac1d62302102c17508a8b0ec0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#a1d7aca6ac1d62302102c17508a8b0ec0">max_keep_alive</a></td></tr>
<tr class="memdesc:a1d7aca6ac1d62302102c17508a8b0ec0"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-definable maximum number of keep-alive message exchanges per connection (<code><a class="el" href="group__group__soap.html#ga9750ea0479df8aa88e06f6a148b2a670" title="User-definable maximum iterations in the server-side soap_serve loop (or the C++ service class serve ...">SOAP_MAXKEEPALIVE</a></code> by default)  <a href="#a1d7aca6ac1d62302102c17508a8b0ec0">More...</a><br /></td></tr>
<tr class="separator:a1d7aca6ac1d62302102c17508a8b0ec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d93ba968bb58373f5884177a7ec0d83"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#a3d93ba968bb58373f5884177a7ec0d83">keep_alive</a></td></tr>
<tr class="memdesc:a3d93ba968bb58373f5884177a7ec0d83"><td class="mdescLeft">&#160;</td><td class="mdescRight">HTTP keep-alive flag (try to enable when -1, disabled when 0) and counter (enabled when &gt;0)  <a href="#a3d93ba968bb58373f5884177a7ec0d83">More...</a><br /></td></tr>
<tr class="separator:a3d93ba968bb58373f5884177a7ec0d83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a400a1663c7b747b84fa17100e10e3eb9"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#a400a1663c7b747b84fa17100e10e3eb9">c14ninclude</a></td></tr>
<tr class="memdesc:a400a1663c7b747b84fa17100e10e3eb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-definable string to control the XML namespace prefixes that are subject to XML canonicalization with the <code><a class="el" href="group__group__flags.html#ga757fa32433be64f8c228b1ecce727815" title="soap_mode XML output flag value to send XML messages in exclusive canonical format as per W3C XML C14...">SOAP_XML_CANONICAL</a></code> output mode flag, specified by space-separated prefixes in the string, or <code>*</code> to specify that all prefixes are inclusive, or NULL when unused.  <a href="#a400a1663c7b747b84fa17100e10e3eb9">More...</a><br /></td></tr>
<tr class="separator:a400a1663c7b747b84fa17100e10e3eb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd294a7412902194179ec31c2d0200ef"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#afd294a7412902194179ec31c2d0200ef">c14nexclude</a></td></tr>
<tr class="memdesc:afd294a7412902194179ec31c2d0200ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-definable string to control the XML namespace prefixes that are subject to XML canonicalization with <code><a class="el" href="group__group__flags.html#ga757fa32433be64f8c228b1ecce727815" title="soap_mode XML output flag value to send XML messages in exclusive canonical format as per W3C XML C14...">SOAP_XML_CANONICAL</a></code> output mode flag, specified by space-separated prefixes in the string, or NULL when unused.  <a href="#afd294a7412902194179ec31c2d0200ef">More...</a><br /></td></tr>
<tr class="separator:afd294a7412902194179ec31c2d0200ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec65c0198db5df4bef7afd2df29ff88d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#aec65c0198db5df4bef7afd2df29ff88d">status</a></td></tr>
<tr class="memdesc:aec65c0198db5df4bef7afd2df29ff88d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context HTTP status code received at the client side (100 to 599), HTTP header method received at the server side (<code><a class="el" href="group__group__io.html#ga41f39e73106f1a2283ae3aa65698050f" title="HTTP POST command code. ">SOAP_POST</a></code>, <code><a class="el" href="group__group__io.html#ga0f6661cfe8eff845600e7a75a2f46701" title="HTTP PATCH command code with custom content type. ">SOAP_PATCH</a></code>, <code><a class="el" href="group__group__io.html#ga3abcdd760843c4bdc56c19b85453ed04" title="HTTP GET command code. ">SOAP_GET</a></code>, <code><a class="el" href="group__group__io.html#ga32a114ef8df190363b9c3ad37bcb6335" title="HTTP PUT command code with custom content type. ">SOAP_PUT</a></code>, <code><a class="el" href="group__group__io.html#ga6e1b491acf772e88f64909ee5baae18d" title="HTTP DEL command code. ">SOAP_DEL</a></code>, <code><a class="el" href="group__group__io.html#ga31ba86b35e83440e4047b021add6fe2c" title="HTTP HEAD command code. ">SOAP_HEAD</a></code>, <code><a class="el" href="group__group__io.html#gab85d36efa8017c3d328289e25318fb18" title="HTTP OPTIONS command code. ">SOAP_OPTIONS</a></code>), or the HTTP method to use for sending a message with <code><a class="el" href="group__group__io.html#ga315b6e1d5888780bf4ef320c50f23796" title="Connect to a server. ">soap_connect_command</a></code> or with <code><a class="el" href="group__group__io.html#ga0390e58bd2a3ebe6fe3a46de0534a614" title="Initialize the context for server-side sending and send a HTTP response header. ">soap_response</a></code> (<code><a class="el" href="group__group__io.html#ga41f39e73106f1a2283ae3aa65698050f" title="HTTP POST command code. ">SOAP_POST</a></code>, <code><a class="el" href="group__group__io.html#ga4c291263eadcefa290e90c64e632ae47" title="HTTP POST command code with custom content type. ">SOAP_POST_FILE</a></code>, <code><a class="el" href="group__group__io.html#ga0f6661cfe8eff845600e7a75a2f46701" title="HTTP PATCH command code with custom content type. ">SOAP_PATCH</a></code>, <code><a class="el" href="group__group__io.html#ga3abcdd760843c4bdc56c19b85453ed04" title="HTTP GET command code. ">SOAP_GET</a></code>, <code><a class="el" href="group__group__io.html#ga32a114ef8df190363b9c3ad37bcb6335" title="HTTP PUT command code with custom content type. ">SOAP_PUT</a></code>, <code><a class="el" href="group__group__io.html#ga32a114ef8df190363b9c3ad37bcb6335" title="HTTP PUT command code with custom content type. ">SOAP_PUT</a></code>, <code><a class="el" href="group__group__io.html#ga6e1b491acf772e88f64909ee5baae18d" title="HTTP DEL command code. ">SOAP_DEL</a></code>, <code><a class="el" href="group__group__io.html#gaaf0409312a4af954ee5b183b92967e0b" title="HTTP CONNECT command code. ">SOAP_CONNECT</a></code>, <code><a class="el" href="group__group__io.html#ga31ba86b35e83440e4047b021add6fe2c" title="HTTP HEAD command code. ">SOAP_HEAD</a></code>, <code><a class="el" href="group__group__io.html#gab85d36efa8017c3d328289e25318fb18" title="HTTP OPTIONS command code. ">SOAP_OPTIONS</a></code>)  <a href="#aec65c0198db5df4bef7afd2df29ff88d">More...</a><br /></td></tr>
<tr class="separator:aec65c0198db5df4bef7afd2df29ff88d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab85f5d42702963d13ea540bd9876e6d2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#ab85f5d42702963d13ea540bd9876e6d2">error</a></td></tr>
<tr class="memdesc:ab85f5d42702963d13ea540bd9876e6d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context <code><a class="el" href="group__group__errors.html#gac0eadf8f72bacb5b41b750beaeca0444" title="Status and error codes are int values, a zero value or SOAP_OK (0) means no error, nonzero means error. ">soap_status</a></code> (int) error code of the last operation or <code><a class="el" href="group__group__errors.html#ga3b10a68f354f39cbb0fe0d043ad4c7c0" title="The soap_status code for no error (zero) ">SOAP_OK</a></code> (zero)  <a href="#ab85f5d42702963d13ea540bd9876e6d2">More...</a><br /></td></tr>
<tr class="separator:ab85f5d42702963d13ea540bd9876e6d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10b66d6d489690b7d0f591ae2633dd13"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#a10b66d6d489690b7d0f591ae2633dd13">errnum</a></td></tr>
<tr class="memdesc:a10b66d6d489690b7d0f591ae2633dd13"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code>errno</code> value of the last failed IO operation.  <a href="#a10b66d6d489690b7d0f591ae2633dd13">More...</a><br /></td></tr>
<tr class="separator:a10b66d6d489690b7d0f591ae2633dd13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac091dfe4e01b6a082d916c381e7006ba"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="struct_s_o_a_p___e_n_v_____header.html">SOAP_ENV__Header</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#ac091dfe4e01b6a082d916c381e7006ba">header</a></td></tr>
<tr class="memdesc:ac091dfe4e01b6a082d916c381e7006ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code><a class="el" href="structsoap.html#ac091dfe4e01b6a082d916c381e7006ba" title="The soap::header points to a SOAP_ENV__Header structure with the SOAP Header that was received or tha...">soap::header</a></code> points to a <code><a class="el" href="struct_s_o_a_p___e_n_v_____header.html" title="SOAP Header structure. ">SOAP_ENV__Header</a></code> structure with the SOAP Header that was received or that can be populated by the user to be sent, or NULL when no SOAP Header is present.  <a href="#ac091dfe4e01b6a082d916c381e7006ba">More...</a><br /></td></tr>
<tr class="separator:ac091dfe4e01b6a082d916c381e7006ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a920e2840ab2c816378059022dcfd96e0"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="struct_s_o_a_p___e_n_v_____fault.html">SOAP_ENV__Fault</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#a920e2840ab2c816378059022dcfd96e0">fault</a></td></tr>
<tr class="memdesc:a920e2840ab2c816378059022dcfd96e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code><a class="el" href="structsoap.html#a920e2840ab2c816378059022dcfd96e0" title="The soap::fault points to a SOAP_ENV__Fault structure with the SOAP Fault that was received or that c...">soap::fault</a></code> points to a <code><a class="el" href="struct_s_o_a_p___e_n_v_____fault.html" title="SOAP Fault structure. ">SOAP_ENV__Fault</a></code> structure with the SOAP Fault that was received or that can be populated by the user to be sent, or NULL when no SOAP Fault is present.  <a href="#a920e2840ab2c816378059022dcfd96e0">More...</a><br /></td></tr>
<tr class="separator:a920e2840ab2c816378059022dcfd96e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eb35c04359a567c0b5e2664f3f94d5b"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#a8eb35c04359a567c0b5e2664f3f94d5b">user</a></td></tr>
<tr class="memdesc:a8eb35c04359a567c0b5e2664f3f94d5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-definable variable that may point to user-specified data to pass the data through callbacks and plugins to the user's code.  <a href="#a8eb35c04359a567c0b5e2664f3f94d5b">More...</a><br /></td></tr>
<tr class="separator:a8eb35c04359a567c0b5e2664f3f94d5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17c750f20dab579a6a23c30199ed1263"><td class="memItemLeft" align="right" valign="top">short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#a17c750f20dab579a6a23c30199ed1263">mustUnderstand</a></td></tr>
<tr class="memdesc:a17c750f20dab579a6a23c30199ed1263"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code><a class="el" href="structsoap.html#a17c750f20dab579a6a23c30199ed1263" title="The soap::mustUnderstand flag is set when a SOAP Header element carries a SOAP-ENV:mustUnderstand att...">soap::mustUnderstand</a></code> flag is set when a SOAP Header element carries a <em><code>SOAP-ENV:mustUnderstand</code></em> attribute that is true.  <a href="#a17c750f20dab579a6a23c30199ed1263">More...</a><br /></td></tr>
<tr class="separator:a17c750f20dab579a6a23c30199ed1263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addf099ccce764cf38f96be305b44406a"><td class="memItemLeft" align="right" valign="top">short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#addf099ccce764cf38f96be305b44406a">null</a></td></tr>
<tr class="memdesc:addf099ccce764cf38f96be305b44406a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code><a class="el" href="structsoap.html#addf099ccce764cf38f96be305b44406a" title="The soap::null flag is set when an element carries a xsi:nil attribute that is true. ">soap::null</a></code> flag is set when an element carries a <em><code>xsi:nil</code></em> attribute that is true.  <a href="#addf099ccce764cf38f96be305b44406a">More...</a><br /></td></tr>
<tr class="separator:addf099ccce764cf38f96be305b44406a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b89f13ece11d9f9b6e48bf15ff48be6"><td class="memItemLeft" align="right" valign="top">short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#a3b89f13ece11d9f9b6e48bf15ff48be6">body</a></td></tr>
<tr class="memdesc:a3b89f13ece11d9f9b6e48bf15ff48be6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code><a class="el" href="structsoap.html#a3b89f13ece11d9f9b6e48bf15ff48be6" title="The soap::body flag is set when an element has element content during XML parsing or when a HTTP mess...">soap::body</a></code> flag is set when an element has element content during XML parsing or when a HTTP message has a body when parsing an HTTP header.  <a href="#a3b89f13ece11d9f9b6e48bf15ff48be6">More...</a><br /></td></tr>
<tr class="separator:a3b89f13ece11d9f9b6e48bf15ff48be6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7579168b69a40fbde783efafcf2e0d87"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#a7579168b69a40fbde783efafcf2e0d87">prolog</a></td></tr>
<tr class="memdesc:a7579168b69a40fbde783efafcf2e0d87"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-definable XML declaration prolog (<em><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;</code></em> by default)  <a href="#a7579168b69a40fbde783efafcf2e0d87">More...</a><br /></td></tr>
<tr class="separator:a7579168b69a40fbde783efafcf2e0d87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2ecfbae740da7839a0c5c96eb65db2a"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#af2ecfbae740da7839a0c5c96eb65db2a">cookie_domain</a></td></tr>
<tr class="memdesc:af2ecfbae740da7839a0c5c96eb65db2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-definable string that specifies the HTTP cookie domain of the running server.  <a href="#af2ecfbae740da7839a0c5c96eb65db2a">More...</a><br /></td></tr>
<tr class="separator:af2ecfbae740da7839a0c5c96eb65db2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdd91ce1189fedd32ebfa51dd6ed33eb"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#afdd91ce1189fedd32ebfa51dd6ed33eb">cookie_path</a></td></tr>
<tr class="memdesc:afdd91ce1189fedd32ebfa51dd6ed33eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-definable string that specifies the HTTP cookie path of the running server.  <a href="#afdd91ce1189fedd32ebfa51dd6ed33eb">More...</a><br /></td></tr>
<tr class="separator:afdd91ce1189fedd32ebfa51dd6ed33eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44bd7fc8ba08b1dec2f08299d7f723dd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#a44bd7fc8ba08b1dec2f08299d7f723dd">cookie_max</a></td></tr>
<tr class="memdesc:a44bd7fc8ba08b1dec2f08299d7f723dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-definable maximum number of active cookies allowed to be set with <code><a class="el" href="group__group__cookies.html#ga7d5b0588ea763e511772f0cc2498e322" title="Add a cookie. ">soap_set_cookie</a></code> before cookie memory is reused (32 by default)  <a href="#a44bd7fc8ba08b1dec2f08299d7f723dd">More...</a><br /></td></tr>
<tr class="separator:a44bd7fc8ba08b1dec2f08299d7f723dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acefda44460d269105320e1ebe186608f"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structsoap__cookie.html">soap_cookie</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#acefda44460d269105320e1ebe186608f">cookies</a></td></tr>
<tr class="memdesc:acefda44460d269105320e1ebe186608f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The cookie store is a linked list of cookies.  <a href="#acefda44460d269105320e1ebe186608f">More...</a><br /></td></tr>
<tr class="separator:acefda44460d269105320e1ebe186608f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5e98733a4349b5e1466a9e0ccc22c11"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#ae5e98733a4349b5e1466a9e0ccc22c11">http_content</a></td></tr>
<tr class="memdesc:ae5e98733a4349b5e1466a9e0ccc22c11"><td class="mdescLeft">&#160;</td><td class="mdescRight">String with HTTP content type header value received, can also be assigned to specify a content type header when using <code><a class="el" href="group__group__io.html#ga315b6e1d5888780bf4ef320c50f23796" title="Connect to a server. ">soap_connect_command</a></code> with <code><a class="el" href="group__group__io.html#ga4c291263eadcefa290e90c64e632ae47" title="HTTP POST command code with custom content type. ">SOAP_POST_FILE</a></code>, <code><a class="el" href="group__group__io.html#ga32a114ef8df190363b9c3ad37bcb6335" title="HTTP PUT command code with custom content type. ">SOAP_PUT</a></code> and <code><a class="el" href="group__group__io.html#ga0f6661cfe8eff845600e7a75a2f46701" title="HTTP PATCH command code with custom content type. ">SOAP_PATCH</a></code> or when using <code><a class="el" href="group__group__io.html#ga0390e58bd2a3ebe6fe3a46de0534a614" title="Initialize the context for server-side sending and send a HTTP response header. ">soap_response</a></code> with <code><a class="el" href="group__group__io.html#ga05be99343f556fe70940145e874cdb99" title="A special soap_status error code to signal that a custom file-based HTTP response is present and no H...">SOAP_FILE</a></code>.  <a href="#ae5e98733a4349b5e1466a9e0ccc22c11">More...</a><br /></td></tr>
<tr class="separator:ae5e98733a4349b5e1466a9e0ccc22c11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb22ae0a494a35268914286bd00446ab"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#afb22ae0a494a35268914286bd00446ab">http_extra_header</a></td></tr>
<tr class="memdesc:afb22ae0a494a35268914286bd00446ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-definable string that specifies an extra HTTP header or headers when separated by CRLF, to include in the next HTTP request (client side) or to include with the HTTP response (server side)  <a href="#afb22ae0a494a35268914286bd00446ab">More...</a><br /></td></tr>
<tr class="separator:afb22ae0a494a35268914286bd00446ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab649b8f3b71081d14ec6350ab4b06794"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__soap.html#ga6eb1bde7cecc2fbadbcbbc6395227439">SOAP_SOCKET</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#ab649b8f3b71081d14ec6350ab4b06794">master</a></td></tr>
<tr class="memdesc:ab649b8f3b71081d14ec6350ab4b06794"><td class="mdescLeft">&#160;</td><td class="mdescRight">The socket set by <code><a class="el" href="group__group__io.html#ga0a9725a3edbc27b97456190fee47cc18" title="Bind and listen to a port. ">soap_bind</a></code> (or the C++ service class <code>bind</code> method) to serve as the master socket bound to a specified port, or <code><a class="el" href="group__group__soap.html#gab9e77b1557780293eec0b269ef191472" title="Macro that defines a portable invalid socket value (usually -1, but the value depends on the OS) ...">SOAP_INVALID_SOCKET</a></code> when unassigned.  <a href="#ab649b8f3b71081d14ec6350ab4b06794">More...</a><br /></td></tr>
<tr class="separator:ab649b8f3b71081d14ec6350ab4b06794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1579bd8bd106afc9a906a673ca473046"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__soap.html#ga6eb1bde7cecc2fbadbcbbc6395227439">SOAP_SOCKET</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#a1579bd8bd106afc9a906a673ca473046">socket</a></td></tr>
<tr class="memdesc:a1579bd8bd106afc9a906a673ca473046"><td class="mdescLeft">&#160;</td><td class="mdescRight">The socket set by <code><a class="el" href="group__group__io.html#gaec0e1aecc2d5479d8099762feb4713c6" title="Accept a connection with a client. ">soap_accept</a></code> (or the C++ service class <code>accept</code> method) or <code><a class="el" href="group__group__io.html#ga5c87e9d0a43fe18cc349c724f198f64a" title="Connect to a server using HTTP POST. ">soap_connect</a></code> or <code><a class="el" href="group__group__io.html#ga315b6e1d5888780bf4ef320c50f23796" title="Connect to a server. ">soap_connect_command</a></code> (or the C++ proxy methods) when successful, or <code><a class="el" href="group__group__soap.html#gab9e77b1557780293eec0b269ef191472" title="Macro that defines a portable invalid socket value (usually -1, but the value depends on the OS) ...">SOAP_INVALID_SOCKET</a></code> when unassigned.  <a href="#a1579bd8bd106afc9a906a673ca473046">More...</a><br /></td></tr>
<tr class="separator:a1579bd8bd106afc9a906a673ca473046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a192c25cc206668600212fd34f6541f34"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#a192c25cc206668600212fd34f6541f34">recvfd</a></td></tr>
<tr class="memdesc:a192c25cc206668600212fd34f6541f34"><td class="mdescLeft">&#160;</td><td class="mdescRight">The file descriptor to read data from when no socket communications are set (<code><a class="el" href="structsoap.html#a1579bd8bd106afc9a906a673ca473046" title="The socket set by soap_accept (or the C++ service class accept method) or soap_connect or soap_connec...">soap::socket</a></code> == <code><a class="el" href="group__group__soap.html#gab9e77b1557780293eec0b269ef191472" title="Macro that defines a portable invalid socket value (usually -1, but the value depends on the OS) ...">SOAP_INVALID_SOCKET</a></code>) and <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a>:is</code> == NULL, default value is 0 (stdin)  <a href="#a192c25cc206668600212fd34f6541f34">More...</a><br /></td></tr>
<tr class="separator:a192c25cc206668600212fd34f6541f34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a200d71a901cdc5c9aa02140e9d2369b9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#a200d71a901cdc5c9aa02140e9d2369b9">sendfd</a></td></tr>
<tr class="memdesc:a200d71a901cdc5c9aa02140e9d2369b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The file descriptor to write data to when no socket communications are set (<code><a class="el" href="structsoap.html#a1579bd8bd106afc9a906a673ca473046" title="The socket set by soap_accept (or the C++ service class accept method) or soap_connect or soap_connec...">soap::socket</a></code> == <code><a class="el" href="group__group__soap.html#gab9e77b1557780293eec0b269ef191472" title="Macro that defines a portable invalid socket value (usually -1, but the value depends on the OS) ...">SOAP_INVALID_SOCKET</a></code>) and <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a>:os</code> == NULL, default value is 1 (stdout)  <a href="#a200d71a901cdc5c9aa02140e9d2369b9">More...</a><br /></td></tr>
<tr class="separator:a200d71a901cdc5c9aa02140e9d2369b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a285e8a3584ffb1cea07a700c951e436d"><td class="memItemLeft" align="right" valign="top">SOAP_SOURCE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#a285e8a3584ffb1cea07a700c951e436d">is</a></td></tr>
<tr class="memdesc:a285e8a3584ffb1cea07a700c951e436d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The source to read data from when non-NULL, which in C++ is a <code>std::istream</code> object and in C is a 0-terminated string to be read, default value is NULL.  <a href="#a285e8a3584ffb1cea07a700c951e436d">More...</a><br /></td></tr>
<tr class="separator:a285e8a3584ffb1cea07a700c951e436d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27b166e404c7c98cfa45d6d7a5da90c0"><td class="memItemLeft" align="right" valign="top">SOAP_SINK *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#a27b166e404c7c98cfa45d6d7a5da90c0">os</a></td></tr>
<tr class="memdesc:a27b166e404c7c98cfa45d6d7a5da90c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The sink to write data to when non-NULL, which in C++ is a <code>std::ostream</code> object and in C is a pointer to a <code>char*</code> string variable that will be set to point to a managed 0-terminated string with the data, default value is NULL.  <a href="#a27b166e404c7c98cfa45d6d7a5da90c0">More...</a><br /></td></tr>
<tr class="separator:a27b166e404c7c98cfa45d6d7a5da90c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a345900c2db67e915ceb02bfa21ecbcbd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__soap.html#ga7c6e38d209f60a18e362172dca1a3b6e">ULONG64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#a345900c2db67e915ceb02bfa21ecbcbd">recv_maxlength</a></td></tr>
<tr class="memdesc:a345900c2db67e915ceb02bfa21ecbcbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-definable maximum message length that is permitted to be received, zero means unlimited (2GB by default)  <a href="#a345900c2db67e915ceb02bfa21ecbcbd">More...</a><br /></td></tr>
<tr class="separator:a345900c2db67e915ceb02bfa21ecbcbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcf1d236d052579122f785d7639c43c7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#afcf1d236d052579122f785d7639c43c7">transfer_timeout</a></td></tr>
<tr class="memdesc:afcf1d236d052579122f785d7639c43c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-definable timeout to send or receive an entire message, positive timeout values are seconds, negative timeout values are microseconds, zero means no timeout (0 by default)  <a href="#afcf1d236d052579122f785d7639c43c7">More...</a><br /></td></tr>
<tr class="separator:afcf1d236d052579122f785d7639c43c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5d5fb92fffda724ccb3b038d2bb2388"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#ac5d5fb92fffda724ccb3b038d2bb2388">recv_timeout</a></td></tr>
<tr class="memdesc:ac5d5fb92fffda724ccb3b038d2bb2388"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-definable timeout to receive a packet of data, positive timeout values are seconds, negative timeout values are microseconds, zero means no timeout (0 by default)  <a href="#ac5d5fb92fffda724ccb3b038d2bb2388">More...</a><br /></td></tr>
<tr class="separator:ac5d5fb92fffda724ccb3b038d2bb2388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a711bb3a53de7cc62429e4d3a2e0b5474"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#a711bb3a53de7cc62429e4d3a2e0b5474">send_timeout</a></td></tr>
<tr class="memdesc:a711bb3a53de7cc62429e4d3a2e0b5474"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-definable timeout to send a packet of data, positive timeout values are seconds, negative timeout values are microseconds, zero means no timeout (0 by default)  <a href="#a711bb3a53de7cc62429e4d3a2e0b5474">More...</a><br /></td></tr>
<tr class="separator:a711bb3a53de7cc62429e4d3a2e0b5474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af32b5f3975eac2bd1202571515859163"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#af32b5f3975eac2bd1202571515859163">connect_timeout</a></td></tr>
<tr class="memdesc:af32b5f3975eac2bd1202571515859163"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-definable timeout when waiting to connect to a server at the client-side, positive timeout values are seconds, negative timeout values are microseconds, zero means no timeout (0 by default)  <a href="#af32b5f3975eac2bd1202571515859163">More...</a><br /></td></tr>
<tr class="separator:af32b5f3975eac2bd1202571515859163"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78199a81c504833047224a0ceff6f906"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#a78199a81c504833047224a0ceff6f906">accept_timeout</a></td></tr>
<tr class="memdesc:a78199a81c504833047224a0ceff6f906"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-definable timeout when waiting to accept a request from a client at the server-side with <code><a class="el" href="group__group__io.html#gaec0e1aecc2d5479d8099762feb4713c6" title="Accept a connection with a client. ">soap_accept</a></code> (or the C++ service class <code>accept</code> method), positive timeout values are seconds, negative timeout values are microseconds, zero means no timeout (0 by default)  <a href="#a78199a81c504833047224a0ceff6f906">More...</a><br /></td></tr>
<tr class="separator:a78199a81c504833047224a0ceff6f906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80dbe084f7efe713ac93e6e6a2d30d7f"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#a80dbe084f7efe713ac93e6e6a2d30d7f">maxlevel</a></td></tr>
<tr class="memdesc:a80dbe084f7efe713ac93e6e6a2d30d7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-definable maximum XML and JSON nesting level permitted, initially set to <code><a class="el" href="group__group__soap.html#ga2ad35599c611417132d6b0a9b6870652" title="User-definable maximum XML nesting depth level permitted by the XML parser, must be greater than zero...">SOAP_MAXLEVEL</a></code> (10000 by default)  <a href="#a80dbe084f7efe713ac93e6e6a2d30d7f">More...</a><br /></td></tr>
<tr class="separator:a80dbe084f7efe713ac93e6e6a2d30d7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5d564f947cbd74c29124972823fe775"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#aa5d564f947cbd74c29124972823fe775">maxlength</a></td></tr>
<tr class="memdesc:aa5d564f947cbd74c29124972823fe775"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-definable maximum string length parsed from XML and JSON, initially set to <code><a class="el" href="group__group__soap.html#gabd0dd334a752d8c145fa720deb905508" title="User-definable maximum string content length for strings not already constrained by XML schema valida...">SOAP_MAXLENGTH</a></code>, zero or negative means unlimited (0 by default)  <a href="#aa5d564f947cbd74c29124972823fe775">More...</a><br /></td></tr>
<tr class="separator:aa5d564f947cbd74c29124972823fe775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00bc20ad1100f580a173ba651e05bcb9"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#a00bc20ad1100f580a173ba651e05bcb9">maxoccurs</a></td></tr>
<tr class="memdesc:a00bc20ad1100f580a173ba651e05bcb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-definable maximum array and container size (maximum item occurrence constraint) as parsed from XML and JSON, except when specifie XML schema validation constraints permit greater sizes, initially set to <code><a class="el" href="group__group__soap.html#ga3933a58d23a5bf2ad64039725cb23786" title="User-definable maximum number of array or container elements for containers that are not already cons...">SOAP_MAXOCCURS</a></code> (100000 by default)  <a href="#a00bc20ad1100f580a173ba651e05bcb9">More...</a><br /></td></tr>
<tr class="separator:a00bc20ad1100f580a173ba651e05bcb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae3eee771d8c4031d30d4ca7633edf9f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#aae3eee771d8c4031d30d4ca7633edf9f">socket_flags</a></td></tr>
<tr class="memdesc:aae3eee771d8c4031d30d4ca7633edf9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-definable socket <code>send</code> and <code>recv</code> flags, for example assign <code>MSG_NOSIGNAL</code> to disable sigpipe (0 by default)  <a href="#aae3eee771d8c4031d30d4ca7633edf9f">More...</a><br /></td></tr>
<tr class="separator:aae3eee771d8c4031d30d4ca7633edf9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52a22fafc369b3a54fb0d16f53158794"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#a52a22fafc369b3a54fb0d16f53158794">connect_flags</a></td></tr>
<tr class="memdesc:a52a22fafc369b3a54fb0d16f53158794"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-definable <code>setsockopt</code> level <code>SOL_SOCKET</code> flags when connecting <code><a class="el" href="structsoap.html#a1579bd8bd106afc9a906a673ca473046" title="The socket set by soap_accept (or the C++ service class accept method) or soap_connect or soap_connec...">soap::socket</a></code> to a server (0 by default)  <a href="#a52a22fafc369b3a54fb0d16f53158794">More...</a><br /></td></tr>
<tr class="separator:a52a22fafc369b3a54fb0d16f53158794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b18b017ce2c77ac2b6331469094de59"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#a6b18b017ce2c77ac2b6331469094de59">bind_flags</a></td></tr>
<tr class="memdesc:a6b18b017ce2c77ac2b6331469094de59"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-definable <code>setsockopt</code> level <code>SOL_SOCKET</code> flags when binding <code><a class="el" href="structsoap.html#ab649b8f3b71081d14ec6350ab4b06794" title="The socket set by soap_bind (or the C++ service class bind method) to serve as the master socket boun...">soap::master</a></code> socket (0 by default)  <a href="#a6b18b017ce2c77ac2b6331469094de59">More...</a><br /></td></tr>
<tr class="separator:a6b18b017ce2c77ac2b6331469094de59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08f1b076f0f041cdf89b9a969520fd4a"><td class="memItemLeft" align="right" valign="top">short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#a08f1b076f0f041cdf89b9a969520fd4a">bind_inet6</a></td></tr>
<tr class="memdesc:a08f1b076f0f041cdf89b9a969520fd4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-definable flag, when nonzero uses <code>AF_INET6</code> instead of <code>PF_UNSPEC</code> when binding the <code><a class="el" href="structsoap.html#ab649b8f3b71081d14ec6350ab4b06794" title="The socket set by soap_bind (or the C++ service class bind method) to serve as the master socket boun...">soap::master</a></code> socket in <code><a class="el" href="group__group__io.html#ga0a9725a3edbc27b97456190fee47cc18" title="Bind and listen to a port. ">soap_bind</a></code> (or the C++ service class <code>bind</code> method), to remap IPv4 to IPv6 addresses, meaningful only when used with <code><a class="el" href="group__group__with.html#ga40cbd680e7dbdeb63bce1d6d4b7b9620" title="When this macro is defined at compile time (undefined by default), IPv6 support is enabled and both I...">WITH_IPV6</a></code>  <a href="#a08f1b076f0f041cdf89b9a969520fd4a">More...</a><br /></td></tr>
<tr class="separator:a08f1b076f0f041cdf89b9a969520fd4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90e04027ea9efa26e550f5438ab9f3d6"><td class="memItemLeft" align="right" valign="top">short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#a90e04027ea9efa26e550f5438ab9f3d6">bind_v6only</a></td></tr>
<tr class="memdesc:a90e04027ea9efa26e550f5438ab9f3d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-definable flag, when nonzero enables <code>IPPROTO_IPV6</code> <code>setsockopt</code> <code>IPV6_V6ONLY</code> when binding the <code><a class="el" href="structsoap.html#ab649b8f3b71081d14ec6350ab4b06794" title="The socket set by soap_bind (or the C++ service class bind method) to serve as the master socket boun...">soap::master</a></code> socket with <code><a class="el" href="group__group__io.html#ga0a9725a3edbc27b97456190fee47cc18" title="Bind and listen to a port. ">soap_bind</a></code> (or the C++ service class <code>bind</code> method), meaningful only when used with <code><a class="el" href="group__group__with.html#ga40cbd680e7dbdeb63bce1d6d4b7b9620" title="When this macro is defined at compile time (undefined by default), IPv6 support is enabled and both I...">WITH_IPV6</a></code>  <a href="#a90e04027ea9efa26e550f5438ab9f3d6">More...</a><br /></td></tr>
<tr class="separator:a90e04027ea9efa26e550f5438ab9f3d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad98f12f602efdde049dbd367a43e7cb0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#ad98f12f602efdde049dbd367a43e7cb0">accept_flags</a></td></tr>
<tr class="memdesc:ad98f12f602efdde049dbd367a43e7cb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-definable <code>setsockopt</code> level <code>SOL_SOCKET</code> flags (0 by default), when nonzero sets the <code><a class="el" href="structsoap.html#a1579bd8bd106afc9a906a673ca473046" title="The socket set by soap_accept (or the C++ service class accept method) or soap_connect or soap_connec...">soap::socket</a></code> flags when accepting a request with <code><a class="el" href="group__group__io.html#gaec0e1aecc2d5479d8099762feb4713c6" title="Accept a connection with a client. ">soap_accept</a></code> (or the C++ service class <code>accept</code> method)  <a href="#ad98f12f602efdde049dbd367a43e7cb0">More...</a><br /></td></tr>
<tr class="separator:ad98f12f602efdde049dbd367a43e7cb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f4d025053fde77216a0ca674077198d"><td class="memItemLeft" align="right" valign="top">unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#a0f4d025053fde77216a0ca674077198d">linger_time</a></td></tr>
<tr class="memdesc:a0f4d025053fde77216a0ca674077198d"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-definable linger time value, requires the <code>SO_LINGER</code> <code>setsockopt</code> flag value to be assigned to <code><a class="el" href="structsoap.html#aae3eee771d8c4031d30d4ca7633edf9f" title="User-definable socket send and recv flags, for example assign MSG_NOSIGNAL to disable sigpipe (0 by d...">soap::socket_flags</a></code>  <a href="#a0f4d025053fde77216a0ca674077198d">More...</a><br /></td></tr>
<tr class="separator:a0f4d025053fde77216a0ca674077198d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2b1fc40a14f7ed925658246a26497c8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#af2b1fc40a14f7ed925658246a26497c8">rcvbuf</a></td></tr>
<tr class="memdesc:af2b1fc40a14f7ed925658246a26497c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-definable value to set <code>SO_RCVBUF</code> <code>setsockopt</code> (<code><a class="el" href="group__group__soap.html#ga6ec95d997cc20a6a84dd4d76b3ea2fcc" title="User-definable size of the input and output message buffer soap::buf (65536 by default) ...">SOAP_BUFLEN</a></code> by default)  <a href="#af2b1fc40a14f7ed925658246a26497c8">More...</a><br /></td></tr>
<tr class="separator:af2b1fc40a14f7ed925658246a26497c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02a7fffd05ff6e6c751f2033ef83854f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#a02a7fffd05ff6e6c751f2033ef83854f">sndbuf</a></td></tr>
<tr class="memdesc:a02a7fffd05ff6e6c751f2033ef83854f"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-definable value to set <code>SO_SNDBUF</code> <code>setsockopt</code> (<code><a class="el" href="group__group__soap.html#ga6ec95d997cc20a6a84dd4d76b3ea2fcc" title="User-definable size of the input and output message buffer soap::buf (65536 by default) ...">SOAP_BUFLEN</a></code> by default)  <a href="#a02a7fffd05ff6e6c751f2033ef83854f">More...</a><br /></td></tr>
<tr class="separator:a02a7fffd05ff6e6c751f2033ef83854f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8f80a7bd8c09335c6fb836a612231bb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#af8f80a7bd8c09335c6fb836a612231bb">tcp_keep_alive</a></td></tr>
<tr class="memdesc:af8f80a7bd8c09335c6fb836a612231bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-definable value to set <code>SO_KEEPALIVE</code> <code>setsockopt</code> (0 by default unless the <code><a class="el" href="group__group__flags.html#ga0a4635737732c912058ff4dba668c1b2" title="soap_mode IO output flag value to keep the socket connection alive for SOAP_MAXKEEPALIVE message exch...">SOAP_IO_KEEPALIVE</a></code> mode flag is set)  <a href="#af8f80a7bd8c09335c6fb836a612231bb">More...</a><br /></td></tr>
<tr class="separator:af8f80a7bd8c09335c6fb836a612231bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c0822cb0399ed55de6c2a482171868f"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#a8c0822cb0399ed55de6c2a482171868f">tcp_keep_idle</a></td></tr>
<tr class="memdesc:a8c0822cb0399ed55de6c2a482171868f"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-definable value to set <code>TCP_KEEPIDLE</code> <code>setsockopt</code> (0 by default)  <a href="#a8c0822cb0399ed55de6c2a482171868f">More...</a><br /></td></tr>
<tr class="separator:a8c0822cb0399ed55de6c2a482171868f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a822aba3e7ae74fa86277c683569f80ae"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#a822aba3e7ae74fa86277c683569f80ae">tcp_keep_intvl</a></td></tr>
<tr class="memdesc:a822aba3e7ae74fa86277c683569f80ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-definable value to set <code>TCP_KEEPINTVL</code> <code>setsockopt</code> (0 by default)  <a href="#a822aba3e7ae74fa86277c683569f80ae">More...</a><br /></td></tr>
<tr class="separator:a822aba3e7ae74fa86277c683569f80ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a811041faab1cf481e7e656f81dc88901"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#a811041faab1cf481e7e656f81dc88901">tcp_keep_cnt</a></td></tr>
<tr class="memdesc:a811041faab1cf481e7e656f81dc88901"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-definable value to set <code>TCP_KEEPCNT</code> <code>setsockopt</code> (0 by default)  <a href="#a811041faab1cf481e7e656f81dc88901">More...</a><br /></td></tr>
<tr class="separator:a811041faab1cf481e7e656f81dc88901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3db0542e8eb7db6a2f2cbc16fb24082b"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#a3db0542e8eb7db6a2f2cbc16fb24082b">ipv6_multicast_if</a></td></tr>
<tr class="memdesc:a3db0542e8eb7db6a2f2cbc16fb24082b"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-definable value to set <code>sockaddr_in6::sin6_scope_id</code> when nonzero.  <a href="#a3db0542e8eb7db6a2f2cbc16fb24082b">More...</a><br /></td></tr>
<tr class="separator:a3db0542e8eb7db6a2f2cbc16fb24082b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accb43a5716005b473fa1d5688967a3b3"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#accb43a5716005b473fa1d5688967a3b3">ipv4_multicast_if</a></td></tr>
<tr class="memdesc:accb43a5716005b473fa1d5688967a3b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-definable value to set <code>setsockopt</code> level <code>IPPROTO_IP</code> to <code>IP_MULTICAST_IF</code> when non-NULL.  <a href="#accb43a5716005b473fa1d5688967a3b3">More...</a><br /></td></tr>
<tr class="separator:accb43a5716005b473fa1d5688967a3b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5faa7630425a8ab8018f0b2d4d0c18d"><td class="memItemLeft" align="right" valign="top">unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#aa5faa7630425a8ab8018f0b2d4d0c18d">ipv4_multicast_ttl</a></td></tr>
<tr class="memdesc:aa5faa7630425a8ab8018f0b2d4d0c18d"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-definable value to set <code>setsockopt</code> level <code>IPPROTO_IP</code> to <code>IP_MULTICAST_TTL</code> when nonzero.  <a href="#aa5faa7630425a8ab8018f0b2d4d0c18d">More...</a><br /></td></tr>
<tr class="separator:aa5faa7630425a8ab8018f0b2d4d0c18d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b424c2622c9f8e4284eba0e6c74e67c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#a9b424c2622c9f8e4284eba0e6c74e67c">client_port</a></td></tr>
<tr class="memdesc:a9b424c2622c9f8e4284eba0e6c74e67c"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-definable client port to bind to when connecting, when non-negative.  <a href="#a9b424c2622c9f8e4284eba0e6c74e67c">More...</a><br /></td></tr>
<tr class="separator:a9b424c2622c9f8e4284eba0e6c74e67c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa66026bcd099d88d44c985b49928a05d"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#aa66026bcd099d88d44c985b49928a05d">client_interface</a></td></tr>
<tr class="memdesc:aa66026bcd099d88d44c985b49928a05d"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-definable client address to use when connecting, when non-NULL.  <a href="#aa66026bcd099d88d44c985b49928a05d">More...</a><br /></td></tr>
<tr class="separator:aa66026bcd099d88d44c985b49928a05d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fae46446ebcb1a51417f2c0c1db31f8"><td class="memItemLeft" align="right" valign="top">unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#a9fae46446ebcb1a51417f2c0c1db31f8">z_level</a></td></tr>
<tr class="memdesc:a9fae46446ebcb1a51417f2c0c1db31f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-definable compression level for gzip compression (0=none, 1=fast to 9=best) default level is 6.  <a href="#a9fae46446ebcb1a51417f2c0c1db31f8">More...</a><br /></td></tr>
<tr class="separator:a9fae46446ebcb1a51417f2c0c1db31f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cc15a11a897cde81f4303866df747ac"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#a6cc15a11a897cde81f4303866df747ac">z_ratio_in</a></td></tr>
<tr class="memdesc:a6cc15a11a897cde81f4303866df747ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">The compression ratio = compressed.size/uncompressed.size of the compressed message received.  <a href="#a6cc15a11a897cde81f4303866df747ac">More...</a><br /></td></tr>
<tr class="separator:a6cc15a11a897cde81f4303866df747ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9d0aab0f89e2109ba02ca460c219541"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#ab9d0aab0f89e2109ba02ca460c219541">z_ratio_out</a></td></tr>
<tr class="memdesc:ab9d0aab0f89e2109ba02ca460c219541"><td class="mdescLeft">&#160;</td><td class="mdescRight">The compression ratio = compressed.size/uncompressed.size of the compressed message sent.  <a href="#ab9d0aab0f89e2109ba02ca460c219541">More...</a><br /></td></tr>
<tr class="separator:ab9d0aab0f89e2109ba02ca460c219541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5213a5328b44244689fd3c2937cc8b92"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#a5213a5328b44244689fd3c2937cc8b92">bearer</a></td></tr>
<tr class="memdesc:a5213a5328b44244689fd3c2937cc8b92"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-definable HTTP authorization bearer token value to be sent by the client, server side receives this string when the client sends authorization bearer.  <a href="#a5213a5328b44244689fd3c2937cc8b92">More...</a><br /></td></tr>
<tr class="separator:a5213a5328b44244689fd3c2937cc8b92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ede02095d98942f4c220fd17b495703"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#a2ede02095d98942f4c220fd17b495703">userid</a></td></tr>
<tr class="memdesc:a2ede02095d98942f4c220fd17b495703"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-definable HTTP and NTLM authorization user id string for HTTP basic and NTLM authentication by the client, server side receives this string when the client uses HTTP basic authentication, for HTTP digest authentication see the gSOAP HTTP digest authentication plugin.  <a href="#a2ede02095d98942f4c220fd17b495703">More...</a><br /></td></tr>
<tr class="separator:a2ede02095d98942f4c220fd17b495703"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22d219c98f0fcf456641277cc64174a3"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#a22d219c98f0fcf456641277cc64174a3">passwd</a></td></tr>
<tr class="memdesc:a22d219c98f0fcf456641277cc64174a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-definable HTTP and NTLM authorization password string required for HTTP basic and NTLM authentication by the client, server side receives this string when the client uses HTTP basic authentication.  <a href="#a22d219c98f0fcf456641277cc64174a3">More...</a><br /></td></tr>
<tr class="separator:a22d219c98f0fcf456641277cc64174a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dbe57d59f683d99305a44b4d7939bfd"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#a8dbe57d59f683d99305a44b4d7939bfd">authrealm</a></td></tr>
<tr class="memdesc:a8dbe57d59f683d99305a44b4d7939bfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The HTTP and NTLM authorization realm/domain string received by the client with the <code>WWW-Authenticate</code> or <code>Proxy-Authenticate</code> HTTP headers, user-definable on the server side to send a <code>WWW-Authenticate</code> header to require authentication (service operation should return 401 to respond with "Unauthorized"), also serves as NTLM domain value.  <a href="#a8dbe57d59f683d99305a44b4d7939bfd">More...</a><br /></td></tr>
<tr class="separator:a8dbe57d59f683d99305a44b4d7939bfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2c9e77616c132831ebf041d9e4d18b1"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#af2c9e77616c132831ebf041d9e4d18b1">ntlm_challenge</a></td></tr>
<tr class="memdesc:af2c9e77616c132831ebf041d9e4d18b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-definable NTLM authentication challenge key string.  <a href="#af2c9e77616c132831ebf041d9e4d18b1">More...</a><br /></td></tr>
<tr class="separator:af2c9e77616c132831ebf041d9e4d18b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac172bd9019afeebb3635b3a9f72a9101"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#ac172bd9019afeebb3635b3a9f72a9101">proxy_host</a></td></tr>
<tr class="memdesc:ac172bd9019afeebb3635b3a9f72a9101"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-definable proxy host name string which should be set to connect through an HTTP proxy.  <a href="#ac172bd9019afeebb3635b3a9f72a9101">More...</a><br /></td></tr>
<tr class="separator:ac172bd9019afeebb3635b3a9f72a9101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a037554fd2cf54fb9a6d5326b11c8ffa0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#a037554fd2cf54fb9a6d5326b11c8ffa0">proxy_port</a></td></tr>
<tr class="memdesc:a037554fd2cf54fb9a6d5326b11c8ffa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-definable proxy port which should be set to connect through an HTTP proxy (8080 by default)  <a href="#a037554fd2cf54fb9a6d5326b11c8ffa0">More...</a><br /></td></tr>
<tr class="separator:a037554fd2cf54fb9a6d5326b11c8ffa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e7e9e9d65bba6237298cf2ed7cec599"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#a7e7e9e9d65bba6237298cf2ed7cec599">proxy_userid</a></td></tr>
<tr class="memdesc:a7e7e9e9d65bba6237298cf2ed7cec599"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-definable proxy authorization user id string to authenticate and connect to an HTTP proxy.  <a href="#a7e7e9e9d65bba6237298cf2ed7cec599">More...</a><br /></td></tr>
<tr class="separator:a7e7e9e9d65bba6237298cf2ed7cec599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad75a4abe119a1a74a26d06401fa11c3a"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#ad75a4abe119a1a74a26d06401fa11c3a">proxy_passwd</a></td></tr>
<tr class="memdesc:ad75a4abe119a1a74a26d06401fa11c3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-definable proxy authorization password string to authenticate and connect to an HTTP proxy.  <a href="#ad75a4abe119a1a74a26d06401fa11c3a">More...</a><br /></td></tr>
<tr class="separator:ad75a4abe119a1a74a26d06401fa11c3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59b7a3c700fd54ba1708f97c7b60876b"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#a59b7a3c700fd54ba1708f97c7b60876b">proxy_from</a></td></tr>
<tr class="memdesc:a59b7a3c700fd54ba1708f97c7b60876b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code>X-Forwarding-For</code> HTTP header string value received.  <a href="#a59b7a3c700fd54ba1708f97c7b60876b">More...</a><br /></td></tr>
<tr class="separator:a59b7a3c700fd54ba1708f97c7b60876b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4565a0ad4ea08ada721155ded8e8036f"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#a4565a0ad4ea08ada721155ded8e8036f">ip</a></td></tr>
<tr class="memdesc:a4565a0ad4ea08ada721155ded8e8036f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The IPv4 address in numeric form of the client as received on the server side by <code><a class="el" href="group__group__io.html#gaec0e1aecc2d5479d8099762feb4713c6" title="Accept a connection with a client. ">soap_accept</a></code> (or the C++ service class <code>accept</code> method), possibly set to zero when <code><a class="el" href="group__group__with.html#ga40cbd680e7dbdeb63bce1d6d4b7b9620" title="When this macro is defined at compile time (undefined by default), IPv6 support is enabled and both I...">WITH_IPV6</a></code> is used.  <a href="#a4565a0ad4ea08ada721155ded8e8036f">More...</a><br /></td></tr>
<tr class="separator:a4565a0ad4ea08ada721155ded8e8036f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d942a41712800a7d81b0e0fe3f10613"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#a3d942a41712800a7d81b0e0fe3f10613">ip6</a> [4]</td></tr>
<tr class="memdesc:a3d942a41712800a7d81b0e0fe3f10613"><td class="mdescLeft">&#160;</td><td class="mdescRight">The IPv6 address in numeric form (upper ip6[0] to lower ip6[3]) of the client as received on the server side by <code><a class="el" href="group__group__io.html#gaec0e1aecc2d5479d8099762feb4713c6" title="Accept a connection with a client. ">soap_accept</a></code> (or the C++ service class <code>accept</code> method), requires <code><a class="el" href="group__group__with.html#ga40cbd680e7dbdeb63bce1d6d4b7b9620" title="When this macro is defined at compile time (undefined by default), IPv6 support is enabled and both I...">WITH_IPV6</a></code>  <a href="#a3d942a41712800a7d81b0e0fe3f10613">More...</a><br /></td></tr>
<tr class="separator:a3d942a41712800a7d81b0e0fe3f10613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acef722da5f6789721603beeb0b505838"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#acef722da5f6789721603beeb0b505838">port</a></td></tr>
<tr class="memdesc:acef722da5f6789721603beeb0b505838"><td class="mdescLeft">&#160;</td><td class="mdescRight">The client port connected to as received on the server side by <code><a class="el" href="group__group__io.html#gaec0e1aecc2d5479d8099762feb4713c6" title="Accept a connection with a client. ">soap_accept</a></code> (or the C++ service class <code>accept</code> method)  <a href="#acef722da5f6789721603beeb0b505838">More...</a><br /></td></tr>
<tr class="separator:acef722da5f6789721603beeb0b505838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed1b86b8a34aea86103751a932c9dce9"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#aed1b86b8a34aea86103751a932c9dce9">endpoint</a> [<a class="el" href="group__group__soap.html#ga69f1ba9e1b47201e54822f365087f5a5">SOAP_TAGLEN</a>]</td></tr>
<tr class="memdesc:aed1b86b8a34aea86103751a932c9dce9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The endpoint string as received on the server side.  <a href="#aed1b86b8a34aea86103751a932c9dce9">More...</a><br /></td></tr>
<tr class="separator:aed1b86b8a34aea86103751a932c9dce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8f356cfb0a1ba87c26cb0ae4c9ee713"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#ab8f356cfb0a1ba87c26cb0ae4c9ee713">host</a> [<a class="el" href="group__group__soap.html#ga69f1ba9e1b47201e54822f365087f5a5">SOAP_TAGLEN</a>]</td></tr>
<tr class="memdesc:ab8f356cfb0a1ba87c26cb0ae4c9ee713"><td class="mdescLeft">&#160;</td><td class="mdescRight">The client host name or IP address as received on the server side.  <a href="#ab8f356cfb0a1ba87c26cb0ae4c9ee713">More...</a><br /></td></tr>
<tr class="separator:ab8f356cfb0a1ba87c26cb0ae4c9ee713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c2bd2822146a8ccca20f8f217c2f309"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#a3c2bd2822146a8ccca20f8f217c2f309">path</a> [<a class="el" href="group__group__soap.html#ga69f1ba9e1b47201e54822f365087f5a5">SOAP_TAGLEN</a>]</td></tr>
<tr class="memdesc:a3c2bd2822146a8ccca20f8f217c2f309"><td class="mdescLeft">&#160;</td><td class="mdescRight">The client request path as received on the server side.  <a href="#a3c2bd2822146a8ccca20f8f217c2f309">More...</a><br /></td></tr>
<tr class="separator:a3c2bd2822146a8ccca20f8f217c2f309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a166405369ad10bc20b90fb9285420cae"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#a166405369ad10bc20b90fb9285420cae">override_host</a></td></tr>
<tr class="memdesc:a166405369ad10bc20b90fb9285420cae"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-definable string to override the host name or IP address in the HTTP header when connecting at the client side.  <a href="#a166405369ad10bc20b90fb9285420cae">More...</a><br /></td></tr>
<tr class="separator:a166405369ad10bc20b90fb9285420cae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a914dcb6eb067f2fd3a47f9207257b606"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#a914dcb6eb067f2fd3a47f9207257b606">override_port</a></td></tr>
<tr class="memdesc:a914dcb6eb067f2fd3a47f9207257b606"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-definable port number to override the port address in the HTTP header when connecting at the client side.  <a href="#a914dcb6eb067f2fd3a47f9207257b606">More...</a><br /></td></tr>
<tr class="separator:a914dcb6eb067f2fd3a47f9207257b606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a5abddf8cedcbe713d61dc6a82d54c3"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#a4a5abddf8cedcbe713d61dc6a82d54c3">origin</a></td></tr>
<tr class="memdesc:a4a5abddf8cedcbe713d61dc6a82d54c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The CORS Origin HTTP header string value received.  <a href="#a4a5abddf8cedcbe713d61dc6a82d54c3">More...</a><br /></td></tr>
<tr class="separator:a4a5abddf8cedcbe713d61dc6a82d54c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4a79c23a3ebab6023b6b6e16de734cc"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#ae4a79c23a3ebab6023b6b6e16de734cc">cors_origin</a></td></tr>
<tr class="memdesc:ae4a79c23a3ebab6023b6b6e16de734cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The CORS Access-Control-Allow-Origin HTTP header string value received or the user-definable value to be returned by the server when set.  <a href="#ae4a79c23a3ebab6023b6b6e16de734cc">More...</a><br /></td></tr>
<tr class="separator:ae4a79c23a3ebab6023b6b6e16de734cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a1a820717a3a9c806c0d0f277f47427"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#a9a1a820717a3a9c806c0d0f277f47427">cors_allow</a></td></tr>
<tr class="memdesc:a9a1a820717a3a9c806c0d0f277f47427"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-definable CORS Access-Control-Allow-Origin HTTP header string default value (<code>*</code> by default)  <a href="#a9a1a820717a3a9c806c0d0f277f47427">More...</a><br /></td></tr>
<tr class="separator:a9a1a820717a3a9c806c0d0f277f47427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c70d16d39b9f403fc1827b78ca8e29f"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#a6c70d16d39b9f403fc1827b78ca8e29f">cors_method</a></td></tr>
<tr class="memdesc:a6c70d16d39b9f403fc1827b78ca8e29f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The CORS Access-Control-Request-Method HTTP header string received.  <a href="#a6c70d16d39b9f403fc1827b78ca8e29f">More...</a><br /></td></tr>
<tr class="separator:a6c70d16d39b9f403fc1827b78ca8e29f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc8032dc7b29093757d5f5f5241463de"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#afc8032dc7b29093757d5f5f5241463de">cors_header</a></td></tr>
<tr class="memdesc:afc8032dc7b29093757d5f5f5241463de"><td class="mdescLeft">&#160;</td><td class="mdescRight">The CORS Access-Control-Request-Headers HTTP header string received.  <a href="#afc8032dc7b29093757d5f5f5241463de">More...</a><br /></td></tr>
<tr class="separator:afc8032dc7b29093757d5f5f5241463de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeacd72a210204ebde6dcdb81bdaf4eef"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#aeacd72a210204ebde6dcdb81bdaf4eef">cors_methods</a></td></tr>
<tr class="memdesc:aeacd72a210204ebde6dcdb81bdaf4eef"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-definable CORS Access-Control-Request-Methods HTTP header string to be returned by the server.  <a href="#aeacd72a210204ebde6dcdb81bdaf4eef">More...</a><br /></td></tr>
<tr class="separator:aeacd72a210204ebde6dcdb81bdaf4eef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9681c002ba2bb1b2347dc177f102031"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#af9681c002ba2bb1b2347dc177f102031">cors_headers</a></td></tr>
<tr class="memdesc:af9681c002ba2bb1b2347dc177f102031"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-definable CORS Access-Control-Request-Headers HTTP header string to be returned by the server.  <a href="#af9681c002ba2bb1b2347dc177f102031">More...</a><br /></td></tr>
<tr class="separator:af9681c002ba2bb1b2347dc177f102031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d7e87aec3cb136b6762a6ffb90a922a"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#a7d7e87aec3cb136b6762a6ffb90a922a">float_format</a></td></tr>
<tr class="memdesc:a7d7e87aec3cb136b6762a6ffb90a922a"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-definable floating point format string (<code>%.9G</code> by default, the printed format should not exceed 1023 bytes)  <a href="#a7d7e87aec3cb136b6762a6ffb90a922a">More...</a><br /></td></tr>
<tr class="separator:a7d7e87aec3cb136b6762a6ffb90a922a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1647309c9aec4b10cd9036cfabee86b"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#ae1647309c9aec4b10cd9036cfabee86b">double_format</a></td></tr>
<tr class="memdesc:ae1647309c9aec4b10cd9036cfabee86b"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-definable double floating point format string (<code>%.17lG</code> by default, the printed format should not exceed 1023 bytes)  <a href="#ae1647309c9aec4b10cd9036cfabee86b">More...</a><br /></td></tr>
<tr class="separator:ae1647309c9aec4b10cd9036cfabee86b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcbd52999b85cad509a9b4b479cb9f4d"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#adcbd52999b85cad509a9b4b479cb9f4d">long_double_format</a></td></tr>
<tr class="memdesc:adcbd52999b85cad509a9b4b479cb9f4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-definable long double floating point format string (NULL by default and defined by the long_double.c custom serializer, the printed format should not exceed 1023 bytes)  <a href="#adcbd52999b85cad509a9b4b479cb9f4d">More...</a><br /></td></tr>
<tr class="separator:adcbd52999b85cad509a9b4b479cb9f4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8541bff0934439c9f6fee6c449400fbe"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#a8541bff0934439c9f6fee6c449400fbe">dime_id_format</a></td></tr>
<tr class="memdesc:a8541bff0934439c9f6fee6c449400fbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-definable format string to generate DIME content IDs.  <a href="#a8541bff0934439c9f6fee6c449400fbe">More...</a><br /></td></tr>
<tr class="separator:a8541bff0934439c9f6fee6c449400fbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7114dcbd53dfdb3518af7bb3e2d41ab"><td class="memItemLeft" align="right" valign="top">struct soap_dom_element *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#ab7114dcbd53dfdb3518af7bb3e2d41ab">dom</a></td></tr>
<tr class="memdesc:ab7114dcbd53dfdb3518af7bb3e2d41ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">DOM tree received.  <a href="#ab7114dcbd53dfdb3518af7bb3e2d41ab">More...</a><br /></td></tr>
<tr class="separator:ab7114dcbd53dfdb3518af7bb3e2d41ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38845a4e0cc0696782769ac9976c4dfa"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structsoap__dime.html">soap_dime</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#a38845a4e0cc0696782769ac9976c4dfa">dime</a></td></tr>
<tr class="memdesc:a38845a4e0cc0696782769ac9976c4dfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">DIME attachments received.  <a href="#a38845a4e0cc0696782769ac9976c4dfa">More...</a><br /></td></tr>
<tr class="separator:a38845a4e0cc0696782769ac9976c4dfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2f4dbd6f73f19f1beeaa3a7e9d9cc2c"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structsoap__mime.html">soap_mime</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#af2f4dbd6f73f19f1beeaa3a7e9d9cc2c">mime</a></td></tr>
<tr class="memdesc:af2f4dbd6f73f19f1beeaa3a7e9d9cc2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">MIME attachments received.  <a href="#af2f4dbd6f73f19f1beeaa3a7e9d9cc2c">More...</a><br /></td></tr>
<tr class="separator:af2f4dbd6f73f19f1beeaa3a7e9d9cc2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dfa3dce8e02bf011c3bbbbfe2f8042a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#a2dfa3dce8e02bf011c3bbbbfe2f8042a">bufidx</a></td></tr>
<tr class="memdesc:a2dfa3dce8e02bf011c3bbbbfe2f8042a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal index that keeps track of the current position in the <code><a class="el" href="structsoap.html#acda1736fbaac07261226befe165a5681" title="Internal buffer with partial data received or partial data to be sent, where the data occupies soap::...">soap::buf</a></code> buffer after receiving data into the buffer.  <a href="#a2dfa3dce8e02bf011c3bbbbfe2f8042a">More...</a><br /></td></tr>
<tr class="separator:a2dfa3dce8e02bf011c3bbbbfe2f8042a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b72b2e13d73dd568d845143822d29d8"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#a0b72b2e13d73dd568d845143822d29d8">buflen</a></td></tr>
<tr class="memdesc:a0b72b2e13d73dd568d845143822d29d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal index that keeps track of the length of the data available in the <code><a class="el" href="structsoap.html#acda1736fbaac07261226befe165a5681" title="Internal buffer with partial data received or partial data to be sent, where the data occupies soap::...">soap::buf</a></code> buffer, does not exceed <code><a class="el" href="group__group__soap.html#ga6ec95d997cc20a6a84dd4d76b3ea2fcc" title="User-definable size of the input and output message buffer soap::buf (65536 by default) ...">SOAP_BUFLEN</a></code>  <a href="#a0b72b2e13d73dd568d845143822d29d8">More...</a><br /></td></tr>
<tr class="separator:a0b72b2e13d73dd568d845143822d29d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acda1736fbaac07261226befe165a5681"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#acda1736fbaac07261226befe165a5681">buf</a> [<a class="el" href="group__group__soap.html#ga6ec95d997cc20a6a84dd4d76b3ea2fcc">SOAP_BUFLEN</a>]</td></tr>
<tr class="memdesc:acda1736fbaac07261226befe165a5681"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal buffer with partial data received or partial data to be sent, where the data occupies <code><a class="el" href="structsoap.html#a0b72b2e13d73dd568d845143822d29d8" title="Internal index that keeps track of the length of the data available in the soap::buf buffer...">soap::buflen</a></code> bytes.  <a href="#acda1736fbaac07261226befe165a5681">More...</a><br /></td></tr>
<tr class="separator:acda1736fbaac07261226befe165a5681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58350076d9fa133bacca27424fe0feff"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#a58350076d9fa133bacca27424fe0feff">msgbuf</a> [<a class="el" href="group__group__soap.html#ga92d654b655b8aca035c8281a836f495f">SOAP_TMPLEN</a>]</td></tr>
<tr class="memdesc:a58350076d9fa133bacca27424fe0feff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal buffer to hold short messages, URLs and HTTP/MIME header lines, must have at least <code><a class="el" href="group__group__soap.html#ga92d654b655b8aca035c8281a836f495f" title="User-definable maximum length of temporary string values stored in soap::msgbuf and soap::tmpbuf...">SOAP_TMPLEN</a></code> = 1024 bytes of space allocated.  <a href="#a58350076d9fa133bacca27424fe0feff">More...</a><br /></td></tr>
<tr class="separator:a58350076d9fa133bacca27424fe0feff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a194bcafed0c3e368b92f452fc80b2d31"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#a194bcafed0c3e368b92f452fc80b2d31">tmpbuf</a> [<a class="el" href="group__group__soap.html#ga92d654b655b8aca035c8281a836f495f">SOAP_TMPLEN</a>]</td></tr>
<tr class="memdesc:a194bcafed0c3e368b92f452fc80b2d31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal buffer to hold temporary strings such as string representations of primitive values, XML tag names, HTTP header lines and so on, must have at least <code><a class="el" href="group__group__soap.html#ga92d654b655b8aca035c8281a836f495f" title="User-definable maximum length of temporary string values stored in soap::msgbuf and soap::tmpbuf...">SOAP_TMPLEN</a></code> = 1024 bytes of space allocated.  <a href="#a194bcafed0c3e368b92f452fc80b2d31">More...</a><br /></td></tr>
<tr class="separator:a194bcafed0c3e368b92f452fc80b2d31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a407dae4bc84d0e7b809d51a3b8798e0c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__soap.html#ga7c6e38d209f60a18e362172dca1a3b6e">ULONG64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#a407dae4bc84d0e7b809d51a3b8798e0c">count</a></td></tr>
<tr class="memdesc:a407dae4bc84d0e7b809d51a3b8798e0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Message length counter value of the message received and counter value of the HTTP content length header to send a message.  <a href="#a407dae4bc84d0e7b809d51a3b8798e0c">More...</a><br /></td></tr>
<tr class="separator:a407dae4bc84d0e7b809d51a3b8798e0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a791a5b372f65291dd53e6afbbc9fbaa5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__soap.html#ga7c6e38d209f60a18e362172dca1a3b6e">ULONG64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html#a791a5b372f65291dd53e6afbbc9fbaa5">length</a></td></tr>
<tr class="memdesc:a791a5b372f65291dd53e6afbbc9fbaa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The HTTP content length header value received or 0 when HTTP transfer encoding is chunked.  <a href="#a791a5b372f65291dd53e6afbbc9fbaa5">More...</a><br /></td></tr>
<tr class="separator:a791a5b372f65291dd53e6afbbc9fbaa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78d2b5440b33d3882b595ca8cfdec425"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__callbacks.html#ga78d2b5440b33d3882b595ca8cfdec425">fpost</a> )(struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, const char *<a class="el" href="structsoap.html#aed1b86b8a34aea86103751a932c9dce9">endpoint</a>, const char *<a class="el" href="structsoap.html#ab8f356cfb0a1ba87c26cb0ae4c9ee713">host</a>, int <a class="el" href="structsoap.html#acef722da5f6789721603beeb0b505838">port</a>, const char *<a class="el" href="structsoap.html#a3c2bd2822146a8ccca20f8f217c2f309">path</a>, const char *action, <a class="el" href="group__group__soap.html#ga7c6e38d209f60a18e362172dca1a3b6e">ULONG64</a> <a class="el" href="structsoap.html#a407dae4bc84d0e7b809d51a3b8798e0c">count</a>)</td></tr>
<tr class="memdesc:ga78d2b5440b33d3882b595ca8cfdec425"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback that populates and then sends HTTP headers from the client-side to a connected HTTP server.  <a href="group__group__callbacks.html#ga78d2b5440b33d3882b595ca8cfdec425">More...</a><br /></td></tr>
<tr class="separator:ga78d2b5440b33d3882b595ca8cfdec425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d8e8e2b7ad7f1ac995c287b3a9f67a9"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__callbacks.html#ga3d8e8e2b7ad7f1ac995c287b3a9f67a9">fresponse</a> )(struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, int <a class="el" href="structsoap.html#aec65c0198db5df4bef7afd2df29ff88d">status</a>, <a class="el" href="group__group__soap.html#ga7c6e38d209f60a18e362172dca1a3b6e">ULONG64</a> <a class="el" href="structsoap.html#a407dae4bc84d0e7b809d51a3b8798e0c">count</a>)</td></tr>
<tr class="memdesc:ga3d8e8e2b7ad7f1ac995c287b3a9f67a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback that populates and then sends HTTP headers from the server-side to a connected client.  <a href="group__group__callbacks.html#ga3d8e8e2b7ad7f1ac995c287b3a9f67a9">More...</a><br /></td></tr>
<tr class="separator:ga3d8e8e2b7ad7f1ac995c287b3a9f67a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab836b5b06024279f4ee190e69d7ccf75"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__callbacks.html#gab836b5b06024279f4ee190e69d7ccf75">fposthdr</a> )(struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, const char *key, const char *val)</td></tr>
<tr class="memdesc:gab836b5b06024279f4ee190e69d7ccf75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback that sends a single HTTP header given a key-value pair.  <a href="group__group__callbacks.html#gab836b5b06024279f4ee190e69d7ccf75">More...</a><br /></td></tr>
<tr class="separator:gab836b5b06024279f4ee190e69d7ccf75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9cb05ce98f845f16c920c44426ac35a5"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__callbacks.html#ga9cb05ce98f845f16c920c44426ac35a5">fparse</a> )(struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>)</td></tr>
<tr class="memdesc:ga9cb05ce98f845f16c920c44426ac35a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback that reads and parses HTTP and MIME headers.  <a href="group__group__callbacks.html#ga9cb05ce98f845f16c920c44426ac35a5">More...</a><br /></td></tr>
<tr class="separator:ga9cb05ce98f845f16c920c44426ac35a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70b75026b5fb1a9a2d5779f72454f082"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__callbacks.html#ga70b75026b5fb1a9a2d5779f72454f082">fparsehdr</a> )(struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, const char *key, const char *val)</td></tr>
<tr class="memdesc:ga70b75026b5fb1a9a2d5779f72454f082"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback that consumes an HTTP header that consists of a key-value pair.  <a href="group__group__callbacks.html#ga70b75026b5fb1a9a2d5779f72454f082">More...</a><br /></td></tr>
<tr class="separator:ga70b75026b5fb1a9a2d5779f72454f082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae022204ff7004df2d5ac9e083cbb5b16"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__callbacks.html#gae022204ff7004df2d5ac9e083cbb5b16">fget</a> )(struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>)</td></tr>
<tr class="memdesc:gae022204ff7004df2d5ac9e083cbb5b16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to implement logic at the server-side to serve responses to HTTP GET requests from clients.  <a href="group__group__callbacks.html#gae022204ff7004df2d5ac9e083cbb5b16">More...</a><br /></td></tr>
<tr class="separator:gae022204ff7004df2d5ac9e083cbb5b16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf263ffe14d8c2508ce4c734d4f33a854"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__callbacks.html#gaf263ffe14d8c2508ce4c734d4f33a854">fput</a> )(struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>)</td></tr>
<tr class="memdesc:gaf263ffe14d8c2508ce4c734d4f33a854"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to implement logic at the server-side to serve responses to HTTP PUT requests from clients.  <a href="group__group__callbacks.html#gaf263ffe14d8c2508ce4c734d4f33a854">More...</a><br /></td></tr>
<tr class="separator:gaf263ffe14d8c2508ce4c734d4f33a854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga808a6a9b7e6d17e039fb53a5e8a9b84a"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__callbacks.html#ga808a6a9b7e6d17e039fb53a5e8a9b84a">fpatch</a> )(struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>)</td></tr>
<tr class="memdesc:ga808a6a9b7e6d17e039fb53a5e8a9b84a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to implement logic at the server-side to serve responses to HTTP PATCH requests from clients.  <a href="group__group__callbacks.html#ga808a6a9b7e6d17e039fb53a5e8a9b84a">More...</a><br /></td></tr>
<tr class="separator:ga808a6a9b7e6d17e039fb53a5e8a9b84a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2bda0187489c8f2b9857f61b96ad0e0"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__callbacks.html#gaf2bda0187489c8f2b9857f61b96ad0e0">fdel</a> )(struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>)</td></tr>
<tr class="memdesc:gaf2bda0187489c8f2b9857f61b96ad0e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to implement logic at the server-side to serve responses to HTTP DELETE requests from clients.  <a href="group__group__callbacks.html#gaf2bda0187489c8f2b9857f61b96ad0e0">More...</a><br /></td></tr>
<tr class="separator:gaf2bda0187489c8f2b9857f61b96ad0e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65272c1ecb5ed9925a5a670cf7e77d10"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__callbacks.html#ga65272c1ecb5ed9925a5a670cf7e77d10">fopt</a> )(struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>)</td></tr>
<tr class="memdesc:ga65272c1ecb5ed9925a5a670cf7e77d10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to implement logic at the server-side to serve responses to HTTP OPTION requests from clients.  <a href="group__group__callbacks.html#ga65272c1ecb5ed9925a5a670cf7e77d10">More...</a><br /></td></tr>
<tr class="separator:ga65272c1ecb5ed9925a5a670cf7e77d10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadff52b7b3ecc16379eb2d7b1ff361978"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__callbacks.html#gadff52b7b3ecc16379eb2d7b1ff361978">fhead</a> )(struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>)</td></tr>
<tr class="memdesc:gadff52b7b3ecc16379eb2d7b1ff361978"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to implement logic at the server-side to serve responses to HTTP HEAD requests from clients.  <a href="group__group__callbacks.html#gadff52b7b3ecc16379eb2d7b1ff361978">More...</a><br /></td></tr>
<tr class="separator:gadff52b7b3ecc16379eb2d7b1ff361978"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga052cdf13e382b4af3d16128955546671"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__callbacks.html#ga052cdf13e382b4af3d16128955546671">fform</a> )(struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>)</td></tr>
<tr class="memdesc:ga052cdf13e382b4af3d16128955546671"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to implement logic at the server-side to handle HTML forms, such as done by the callbacks provided by the HTTP FORM handler plugin.  <a href="group__group__callbacks.html#ga052cdf13e382b4af3d16128955546671">More...</a><br /></td></tr>
<tr class="separator:ga052cdf13e382b4af3d16128955546671"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae88b674df5fdcfa866c04e4330fe0afe"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__callbacks.html#gae88b674df5fdcfa866c04e4330fe0afe">fheader</a> )(struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>)</td></tr>
<tr class="memdesc:gae88b674df5fdcfa866c04e4330fe0afe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to inspect the SOAP Header received before the rest of the message with the SOAP Body is consumed.  <a href="group__group__callbacks.html#gae88b674df5fdcfa866c04e4330fe0afe">More...</a><br /></td></tr>
<tr class="separator:gae88b674df5fdcfa866c04e4330fe0afe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c2e1a0b5a5197128af1acc48662b1bd"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__callbacks.html#ga0c2e1a0b5a5197128af1acc48662b1bd">fignore</a> )(struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, const char *tag)</td></tr>
<tr class="memdesc:ga0c2e1a0b5a5197128af1acc48662b1bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to catch unrecognized XML elements and overrides <code><a class="el" href="group__group__flags.html#ga5faa29a69a247642495846d69ec8b90d" title="soap_mode XML input flag value to enable strict XML validation of messages received, not recommended for SOAP RPC encoding style messaging, but SOAP document/literal style messages can be validated ">SOAP_XML_STRICT</a></code> validation errors for these.  <a href="group__group__callbacks.html#ga0c2e1a0b5a5197128af1acc48662b1bd">More...</a><br /></td></tr>
<tr class="separator:ga0c2e1a0b5a5197128af1acc48662b1bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a5e29b860d28f855c8d9a67c096d311"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__callbacks.html#ga6a5e29b860d28f855c8d9a67c096d311">fsvalidate</a> )(struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, const char *pattern, const char *string)</td></tr>
<tr class="memdesc:ga6a5e29b860d28f855c8d9a67c096d311"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to validate strings against XML regex patterns.  <a href="group__group__callbacks.html#ga6a5e29b860d28f855c8d9a67c096d311">More...</a><br /></td></tr>
<tr class="separator:ga6a5e29b860d28f855c8d9a67c096d311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a38366b5b84730713c45ccada84e3ca"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__callbacks.html#ga1a38366b5b84730713c45ccada84e3ca">fwvalidate</a> )(struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, const char *pattern, const wchar_t *string)</td></tr>
<tr class="memdesc:ga1a38366b5b84730713c45ccada84e3ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to validate wide strings against XML regex patterns.  <a href="group__group__callbacks.html#ga1a38366b5b84730713c45ccada84e3ca">More...</a><br /></td></tr>
<tr class="separator:ga1a38366b5b84730713c45ccada84e3ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4523d86587b4181a138850b92498f5b7"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__callbacks.html#ga4523d86587b4181a138850b92498f5b7">fseterror</a> )(struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, const char **faultcode, const char **faultstring)</td></tr>
<tr class="memdesc:ga4523d86587b4181a138850b92498f5b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to inspect or override fault code or fault string messages.  <a href="group__group__callbacks.html#ga4523d86587b4181a138850b92498f5b7">More...</a><br /></td></tr>
<tr class="separator:ga4523d86587b4181a138850b92498f5b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b4985eb5a588f4c16ad88ef7ca329dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__soap.html#ga6eb1bde7cecc2fbadbcbbc6395227439">SOAP_SOCKET</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__callbacks.html#ga9b4985eb5a588f4c16ad88ef7ca329dc">fopen</a> )(struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, const char *<a class="el" href="structsoap.html#aed1b86b8a34aea86103751a932c9dce9">endpoint</a>, const char *<a class="el" href="structsoap.html#ab8f356cfb0a1ba87c26cb0ae4c9ee713">host</a>, int <a class="el" href="structsoap.html#acef722da5f6789721603beeb0b505838">port</a>)</td></tr>
<tr class="memdesc:ga9b4985eb5a588f4c16ad88ef7ca329dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback that opens a socket connection to a server endpoint.  <a href="group__group__callbacks.html#ga9b4985eb5a588f4c16ad88ef7ca329dc">More...</a><br /></td></tr>
<tr class="separator:ga9b4985eb5a588f4c16ad88ef7ca329dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8249b4c23f662dbe680ad0deef274ae8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__soap.html#ga6eb1bde7cecc2fbadbcbbc6395227439">SOAP_SOCKET</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__callbacks.html#ga8249b4c23f662dbe680ad0deef274ae8">faccept</a> )(struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, <a class="el" href="group__group__soap.html#ga6eb1bde7cecc2fbadbcbbc6395227439">SOAP_SOCKET</a> sock, struct sockaddr *addr, int *len)</td></tr>
<tr class="memdesc:ga8249b4c23f662dbe680ad0deef274ae8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback that waits for and accepts a socket connection requested by a client.  <a href="group__group__callbacks.html#ga8249b4c23f662dbe680ad0deef274ae8">More...</a><br /></td></tr>
<tr class="separator:ga8249b4c23f662dbe680ad0deef274ae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9591dd80dbb0e571784bad5421b2202"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__callbacks.html#gab9591dd80dbb0e571784bad5421b2202">fclose</a> )(struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>)</td></tr>
<tr class="memdesc:gab9591dd80dbb0e571784bad5421b2202"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback that closes the current socket connection.  <a href="group__group__callbacks.html#gab9591dd80dbb0e571784bad5421b2202">More...</a><br /></td></tr>
<tr class="separator:gab9591dd80dbb0e571784bad5421b2202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ae800fa60c5e65a867e5d0e3ce7223e"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__callbacks.html#ga0ae800fa60c5e65a867e5d0e3ce7223e">fresolve</a> )(struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, const char *name, struct in_addr *inaddr)</td></tr>
<tr class="memdesc:ga0ae800fa60c5e65a867e5d0e3ce7223e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback that resolves a host name by address translation.  <a href="group__group__callbacks.html#ga0ae800fa60c5e65a867e5d0e3ce7223e">More...</a><br /></td></tr>
<tr class="separator:ga0ae800fa60c5e65a867e5d0e3ce7223e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a0d27154b0e9e32d9adbcc4efc92b5c"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__callbacks.html#ga0a0d27154b0e9e32d9adbcc4efc92b5c">fconnect</a> )(struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, const char *<a class="el" href="structsoap.html#aed1b86b8a34aea86103751a932c9dce9">endpoint</a>, const char *<a class="el" href="structsoap.html#ab8f356cfb0a1ba87c26cb0ae4c9ee713">host</a>, int <a class="el" href="structsoap.html#acef722da5f6789721603beeb0b505838">port</a>)</td></tr>
<tr class="memdesc:ga0a0d27154b0e9e32d9adbcc4efc92b5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback that overrides the client-side connecting operations.  <a href="group__group__callbacks.html#ga0a0d27154b0e9e32d9adbcc4efc92b5c">More...</a><br /></td></tr>
<tr class="separator:ga0a0d27154b0e9e32d9adbcc4efc92b5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2de194075f645d77c15f78c52ca24858"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__callbacks.html#ga2de194075f645d77c15f78c52ca24858">fdisconnect</a> )(struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>)</td></tr>
<tr class="memdesc:ga2de194075f645d77c15f78c52ca24858"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback that executes disconnect logic before closing.  <a href="group__group__callbacks.html#ga2de194075f645d77c15f78c52ca24858">More...</a><br /></td></tr>
<tr class="separator:ga2de194075f645d77c15f78c52ca24858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21edadcbd081c7f37822d04bb05a9d29"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__callbacks.html#ga21edadcbd081c7f37822d04bb05a9d29">fclosesocket</a> )(struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, <a class="el" href="group__group__soap.html#ga6eb1bde7cecc2fbadbcbbc6395227439">SOAP_SOCKET</a> sock)</td></tr>
<tr class="memdesc:ga21edadcbd081c7f37822d04bb05a9d29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback that closes a given socket.  <a href="group__group__callbacks.html#ga21edadcbd081c7f37822d04bb05a9d29">More...</a><br /></td></tr>
<tr class="separator:ga21edadcbd081c7f37822d04bb05a9d29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51e09ddf769a2ddcd874fb6e6fb5289d"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__callbacks.html#ga51e09ddf769a2ddcd874fb6e6fb5289d">fshutdownsocket</a> )(struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, <a class="el" href="group__group__soap.html#ga6eb1bde7cecc2fbadbcbbc6395227439">SOAP_SOCKET</a> sock, int how)</td></tr>
<tr class="memdesc:ga51e09ddf769a2ddcd874fb6e6fb5289d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback that shuts down a given socket.  <a href="group__group__callbacks.html#ga51e09ddf769a2ddcd874fb6e6fb5289d">More...</a><br /></td></tr>
<tr class="separator:ga51e09ddf769a2ddcd874fb6e6fb5289d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20210aa171019b27ef182d853e2d6e2f"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__callbacks.html#ga20210aa171019b27ef182d853e2d6e2f">fpoll</a> )(struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>)</td></tr>
<tr class="memdesc:ga20210aa171019b27ef182d853e2d6e2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback that blocks until activity is detected on the <code><a class="el" href="structsoap.html#a1579bd8bd106afc9a906a673ca473046" title="The socket set by soap_accept (or the C++ service class accept method) or soap_connect or soap_connec...">soap::socket</a></code> or <code><a class="el" href="structsoap.html#ab649b8f3b71081d14ec6350ab4b06794" title="The socket set by soap_bind (or the C++ service class bind method) to serve as the master socket boun...">soap::master</a></code> socket, times out when <code><a class="el" href="structsoap.html#a711bb3a53de7cc62429e4d3a2e0b5474" title="User-definable timeout to send a packet of data, positive timeout values are seconds, negative timeout values are microseconds, zero means no timeout (0 by default) ">soap::send_timeout</a></code> or <code><a class="el" href="structsoap.html#ac5d5fb92fffda724ccb3b038d2bb2388" title="User-definable timeout to receive a packet of data, positive timeout values are seconds, negative timeout values are microseconds, zero means no timeout (0 by default) ">soap::recv_timeout</a></code> are set.  <a href="group__group__callbacks.html#ga20210aa171019b27ef182d853e2d6e2f">More...</a><br /></td></tr>
<tr class="separator:ga20210aa171019b27ef182d853e2d6e2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c218cd5552045745cc640998e25ed72"><td class="memItemLeft" align="right" valign="top">size_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__callbacks.html#ga0c218cd5552045745cc640998e25ed72">frecv</a> )(struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, char *<a class="el" href="structsoap.html#acda1736fbaac07261226befe165a5681">buf</a>, size_t len)</td></tr>
<tr class="memdesc:ga0c218cd5552045745cc640998e25ed72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback that receives bytes of data into the given buffer.  <a href="group__group__callbacks.html#ga0c218cd5552045745cc640998e25ed72">More...</a><br /></td></tr>
<tr class="separator:ga0c218cd5552045745cc640998e25ed72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd52b80655e4f1021edd6c55b8dfedff"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__callbacks.html#gafd52b80655e4f1021edd6c55b8dfedff">fsend</a> )(struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, const char *data, size_t len)</td></tr>
<tr class="memdesc:gafd52b80655e4f1021edd6c55b8dfedff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback that sends the given bytes of data.  <a href="group__group__callbacks.html#gafd52b80655e4f1021edd6c55b8dfedff">More...</a><br /></td></tr>
<tr class="separator:gafd52b80655e4f1021edd6c55b8dfedff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76024ad8bab31b591432a5dbdcf3a0a4"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__callbacks.html#ga76024ad8bab31b591432a5dbdcf3a0a4">fserveloop</a> )(struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>)</td></tr>
<tr class="memdesc:ga76024ad8bab31b591432a5dbdcf3a0a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback executed by the engine at the server side immediately after a server operation successfully completed.  <a href="group__group__callbacks.html#ga76024ad8bab31b591432a5dbdcf3a0a4">More...</a><br /></td></tr>
<tr class="separator:ga76024ad8bab31b591432a5dbdcf3a0a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2a9bb5e497817ef2af6f2c8fc1089d9"><td class="memItemLeft" align="right" valign="top">void *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__callbacks.html#gae2a9bb5e497817ef2af6f2c8fc1089d9">fmalloc</a> )(struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, size_t size)</td></tr>
<tr class="memdesc:gae2a9bb5e497817ef2af6f2c8fc1089d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to override dynamic memory allocation and management.  <a href="group__group__callbacks.html#gae2a9bb5e497817ef2af6f2c8fc1089d9">More...</a><br /></td></tr>
<tr class="separator:gae2a9bb5e497817ef2af6f2c8fc1089d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga068455ce417bddb1636d4d565e0ebf56"><td class="memItemLeft" align="right" valign="top">void *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__callbacks.html#ga068455ce417bddb1636d4d565e0ebf56">fdimereadopen</a> )(struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, void *handle, const char *id, const char *type, const char *options)</td></tr>
<tr class="memdesc:ga068455ce417bddb1636d4d565e0ebf56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to open a streaming DIME attachment for reading.  <a href="group__group__callbacks.html#ga068455ce417bddb1636d4d565e0ebf56">More...</a><br /></td></tr>
<tr class="separator:ga068455ce417bddb1636d4d565e0ebf56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48270ad98961c3ff48c7b56484ebb3fa"><td class="memItemLeft" align="right" valign="top">size_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__callbacks.html#ga48270ad98961c3ff48c7b56484ebb3fa">fdimeread</a> )(struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, void *handle, char *<a class="el" href="structsoap.html#acda1736fbaac07261226befe165a5681">buf</a>, size_t len)</td></tr>
<tr class="memdesc:ga48270ad98961c3ff48c7b56484ebb3fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to read data in a DIME attachment stream.  <a href="group__group__callbacks.html#ga48270ad98961c3ff48c7b56484ebb3fa">More...</a><br /></td></tr>
<tr class="separator:ga48270ad98961c3ff48c7b56484ebb3fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga154752e553be41ed3b10fe3a1273ac71"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__callbacks.html#ga154752e553be41ed3b10fe3a1273ac71">fdimereadclose</a> )(struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, void *handle)</td></tr>
<tr class="memdesc:ga154752e553be41ed3b10fe3a1273ac71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to close a DIME attachment stream after reading.  <a href="group__group__callbacks.html#ga154752e553be41ed3b10fe3a1273ac71">More...</a><br /></td></tr>
<tr class="separator:ga154752e553be41ed3b10fe3a1273ac71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b1e4aa046b683535110a34fc46ab1eb"><td class="memItemLeft" align="right" valign="top">void *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__callbacks.html#ga3b1e4aa046b683535110a34fc46ab1eb">fdimewriteopen</a> )(struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, const char *id, const char *type, const char *options)</td></tr>
<tr class="memdesc:ga3b1e4aa046b683535110a34fc46ab1eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to open a streaming DIME attachment for writing.  <a href="group__group__callbacks.html#ga3b1e4aa046b683535110a34fc46ab1eb">More...</a><br /></td></tr>
<tr class="separator:ga3b1e4aa046b683535110a34fc46ab1eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f3214caa607f74505f11c76ade85cce"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__callbacks.html#ga0f3214caa607f74505f11c76ade85cce">fdimewrite</a> )(struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, void *, const char *, size_t)</td></tr>
<tr class="memdesc:ga0f3214caa607f74505f11c76ade85cce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to write data in a DIME attachment stream.  <a href="group__group__callbacks.html#ga0f3214caa607f74505f11c76ade85cce">More...</a><br /></td></tr>
<tr class="separator:ga0f3214caa607f74505f11c76ade85cce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ea0ca0526c4ccba02ec52f62e0678a9"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__callbacks.html#ga1ea0ca0526c4ccba02ec52f62e0678a9">fdimewriteclose</a> )(struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, void *handle)</td></tr>
<tr class="memdesc:ga1ea0ca0526c4ccba02ec52f62e0678a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to close a DIME attachment stream after writing.  <a href="group__group__callbacks.html#ga1ea0ca0526c4ccba02ec52f62e0678a9">More...</a><br /></td></tr>
<tr class="separator:ga1ea0ca0526c4ccba02ec52f62e0678a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga610f2a6a56d5ad04cb5124440a5de1dc"><td class="memItemLeft" align="right" valign="top">void *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__callbacks.html#ga610f2a6a56d5ad04cb5124440a5de1dc">fmimereadopen</a> )(struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, void *, const char *, const char *, const char *)</td></tr>
<tr class="memdesc:ga610f2a6a56d5ad04cb5124440a5de1dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to open a streaming MIME/MTOM attachment for reading.  <a href="group__group__callbacks.html#ga610f2a6a56d5ad04cb5124440a5de1dc">More...</a><br /></td></tr>
<tr class="separator:ga610f2a6a56d5ad04cb5124440a5de1dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff40a1ca6fbf075b54ccbf479009ce74"><td class="memItemLeft" align="right" valign="top">size_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__callbacks.html#gaff40a1ca6fbf075b54ccbf479009ce74">fmimeread</a> )(struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, void *handle, char *<a class="el" href="structsoap.html#acda1736fbaac07261226befe165a5681">buf</a>, size_t len)</td></tr>
<tr class="memdesc:gaff40a1ca6fbf075b54ccbf479009ce74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to read data in a MIME/MTOM attachment stream.  <a href="group__group__callbacks.html#gaff40a1ca6fbf075b54ccbf479009ce74">More...</a><br /></td></tr>
<tr class="separator:gaff40a1ca6fbf075b54ccbf479009ce74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga884e94e8450f56049ba5071786170dd5"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__callbacks.html#ga884e94e8450f56049ba5071786170dd5">fmimereadclose</a> )(struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, void *handle)</td></tr>
<tr class="memdesc:ga884e94e8450f56049ba5071786170dd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to close a MIME/MTOM attachment stream after reading.  <a href="group__group__callbacks.html#ga884e94e8450f56049ba5071786170dd5">More...</a><br /></td></tr>
<tr class="separator:ga884e94e8450f56049ba5071786170dd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef809b275fd65e57991a80663288fa72"><td class="memItemLeft" align="right" valign="top">void *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__callbacks.html#gaef809b275fd65e57991a80663288fa72">fmimewriteopen</a> )(struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, void *handle, const char *id, const char *type, const char *description, enum <a class="el" href="group__group__mime.html#ga3fec7633da07bff2bf5fd6330bef1844">soap_mime_encoding</a> encoding)</td></tr>
<tr class="memdesc:gaef809b275fd65e57991a80663288fa72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to open a streaming MIME/MTOM attachment for writing.  <a href="group__group__callbacks.html#gaef809b275fd65e57991a80663288fa72">More...</a><br /></td></tr>
<tr class="separator:gaef809b275fd65e57991a80663288fa72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9084f0392e4a54287366121d30bc4830"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__callbacks.html#ga9084f0392e4a54287366121d30bc4830">fmimewrite</a> )(struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, void *handle, const char *<a class="el" href="structsoap.html#acda1736fbaac07261226befe165a5681">buf</a>, size_t len)</td></tr>
<tr class="memdesc:ga9084f0392e4a54287366121d30bc4830"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to write data in a MIME attachment stream.  <a href="group__group__callbacks.html#ga9084f0392e4a54287366121d30bc4830">More...</a><br /></td></tr>
<tr class="separator:ga9084f0392e4a54287366121d30bc4830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8af884096b21cea1b69133843131a47b"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__callbacks.html#ga8af884096b21cea1b69133843131a47b">fmimewriteclose</a> )(struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, void *handle)</td></tr>
<tr class="memdesc:ga8af884096b21cea1b69133843131a47b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to close a MIME/MTOM attachment stream after writing.  <a href="group__group__callbacks.html#ga8af884096b21cea1b69133843131a47b">More...</a><br /></td></tr>
<tr class="separator:ga8af884096b21cea1b69133843131a47b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec56697005ded17d4d19705013f908ee"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__callbacks.html#gaec56697005ded17d4d19705013f908ee">fsslauth</a> )(struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>)</td></tr>
<tr class="memdesc:gaec56697005ded17d4d19705013f908ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to initialize the OpenSSL library.  <a href="group__group__callbacks.html#gaec56697005ded17d4d19705013f908ee">More...</a><br /></td></tr>
<tr class="separator:gaec56697005ded17d4d19705013f908ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49fee9ca4a78f9a681afbdfbc0194bf0"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__callbacks.html#ga49fee9ca4a78f9a681afbdfbc0194bf0">fsslverify</a> )(int ok, X509_STORE_CTX *store)</td></tr>
<tr class="memdesc:ga49fee9ca4a78f9a681afbdfbc0194bf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to manage the verification of the certificate provided by a peer (typically a server)  <a href="group__group__callbacks.html#ga49fee9ca4a78f9a681afbdfbc0194bf0">More...</a><br /></td></tr>
<tr class="separator:ga49fee9ca4a78f9a681afbdfbc0194bf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Context with the engine state. </p>
<p>The <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context should be passed as the first parameter to all gSOAP functions and should only be used by a single thread at a time. Each thread should use a copy of the context created with <code><a class="el" href="group__group__context.html#gab4c3f8ce80baf0f1fec8c86f0bb5788a" title="Allocate and initialize a new soap context as a copy of the given soap context. ">soap_copy</a></code> or with the <code><a class="el" href="structsoap.html#a740f8760f6ee4c6584e25c612f585d70" title="Construct a soap context (C++ only, in C use soap_new or soap_init) ">soap::soap</a></code> copy constructor.</p>
<p>To allocate a new <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context, use one of these three allocators that take <code><a class="el" href="group__group__flags.html#ga72b0491c9cbf2071f0c96c7d29b719bb" title="The soap_mode flags to initialize the soap context, flags can be combined with | (bit-wise or) ...">soap_mode</a></code> parameters:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>soap *soap1 = <a class="code" href="group__group__context.html#ga87c20488b2dc680aaa7689b1d024989c">soap_new</a>();</div><div class="line"><span class="keyword">struct </span>soap *soap2 = <a class="code" href="group__group__context.html#ga51cde138234ed7ec8c4e25bdf6418658">soap_new1</a>(input_and_output_mode);</div><div class="line"><span class="keyword">struct </span>soap *soap3 = <a class="code" href="group__group__context.html#ga12a87f6795b62b05164edc392b2adb1d">soap_new2</a>(input_mode, output_mode);</div></div><!-- fragment --><p>Alternatively, use contructors in C++ as follows:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>soap *soap1();</div><div class="line"><span class="keyword">struct </span>soap *soap2(input_and_output_mode);</div><div class="line"><span class="keyword">struct </span>soap *soap3(input_mode, output_mode);</div></div><!-- fragment --><p>To copy the <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context, for example to be used by another thread, use:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>soap *soap2 = <a class="code" href="group__group__context.html#gab4c3f8ce80baf0f1fec8c86f0bb5788a">soap_copy</a>(soap1);</div></div><!-- fragment --><p>Alternatively, use the copy constructor in C++ as follows:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>soap *soap2 = <span class="keyword">new</span> <a class="code" href="structsoap.html#a740f8760f6ee4c6584e25c612f585d70">soap</a>(soap1);</div></div><!-- fragment --><p>To free the <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context or a copy of a <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context, use:</p>
<div class="fragment"><div class="line"><a class="code" href="group__group__context.html#ga57108ca4681186e58b5b189c3528f10a">soap_free</a>(soap1);</div></div><!-- fragment --><p>To stack-allocate a <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context (i.e. as opposed to heap-allocating it as shown above), initialize the <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context with one of these three initializers that take <code><a class="el" href="group__group__flags.html#ga72b0491c9cbf2071f0c96c7d29b719bb" title="The soap_mode flags to initialize the soap context, flags can be combined with | (bit-wise or) ...">soap_mode</a></code> parameters:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>soap soap1, soap2, soap3;</div><div class="line"><a class="code" href="group__group__context.html#ga8e034e1a7d6093eaddc11b647179657c">soap_init</a>(&amp;soap1);</div><div class="line"><a class="code" href="group__group__context.html#gac87126c3e45d2fda488e9832c2dd5be1">soap_init1</a>(&amp;soap2, input_and_output_mode);</div><div class="line"><a class="code" href="group__group__context.html#ga3c70b587fc4f65553cfe69751d1a157e">soap_init2</a>(&amp;soap3, input_mode, output_mode);</div></div><!-- fragment --><p>Alternatively, use contructors in C++:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>soap soap1();</div><div class="line"><span class="keyword">struct </span>soap soap2(input_and_output_mode);</div><div class="line"><span class="keyword">struct </span>soap soap3(input_mode, output_mode);</div></div><!-- fragment --><p>Finalization of the <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context is automatically done by the C++ destructor. In C, you should finalize a stack-allocated <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context before it is reclaimed by the stack:</p>
<div class="fragment"><div class="line"><a class="code" href="group__group__context.html#ga28ee8fdcf500443e0e51750324aa6a1a">soap_done</a>(&amp;soap1);</div></div><!-- fragment --><p>Before freeing or finalizating a <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context, you may want to delete all data allocated in managed heap memory with these two calls in this specific order:</p>
<div class="fragment"><div class="line"><a class="code" href="group__group__context.html#gaf7d0176161e9def36981e24faa1913d9">soap_destroy</a>(soap1);</div><div class="line"><a class="code" href="group__group__context.html#ga81a009ae1ea825a05e5241e2b7a8ece9">soap_end</a>(soap1);</div></div><!-- fragment --><p>Alternatively, in C++ you can simply invoke one method to perform both calls at once:</p>
<div class="fragment"><div class="line">soap1.<a class="code" href="structsoap.html#a0c714b6ed5245dbe34cf7b747aa226ac">destroy</a>();</div></div><!-- fragment --> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a740f8760f6ee4c6584e25c612f585d70"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">soap::soap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context (C++ only, in C use <code><a class="el" href="group__group__context.html#ga87c20488b2dc680aaa7689b1d024989c" title="Allocate and initialize a new soap context. ">soap_new</a></code> or <code><a class="el" href="group__group__context.html#ga8e034e1a7d6093eaddc11b647179657c" title="Initialize a stack-allocated soap context. ">soap_init</a></code>) </p>

</div>
</div>
<a class="anchor" id="aaa7272f77346aa7c5dbfcaa6d57ca928"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">soap::soap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__flags.html#ga72b0491c9cbf2071f0c96c7d29b719bb">soap_mode</a>&#160;</td>
          <td class="paramname"><em>input_and_output_mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context with the specified input and output <code><a class="el" href="group__group__flags.html#ga72b0491c9cbf2071f0c96c7d29b719bb" title="The soap_mode flags to initialize the soap context, flags can be combined with | (bit-wise or) ...">soap_mode</a></code> flags (C++ only, in C use <code><a class="el" href="group__group__context.html#ga51cde138234ed7ec8c4e25bdf6418658" title="Allocate and initialize a new soap context with input and output soap_mode flags. ...">soap_new1</a></code> or <code><a class="el" href="group__group__context.html#gac87126c3e45d2fda488e9832c2dd5be1" title="Initialize a stack-allocated soap context with input and output soap_mode flags. ">soap_init1</a></code>)) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input_and_output_mode</td><td>input and output <code><a class="el" href="group__group__flags.html#ga72b0491c9cbf2071f0c96c7d29b719bb" title="The soap_mode flags to initialize the soap context, flags can be combined with | (bit-wise or) ...">soap_mode</a></code> flags </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a537033a707df9a2217bb397eb8762f5a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">soap::soap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__flags.html#ga72b0491c9cbf2071f0c96c7d29b719bb">soap_mode</a>&#160;</td>
          <td class="paramname"><em>input_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__flags.html#ga72b0491c9cbf2071f0c96c7d29b719bb">soap_mode</a>&#160;</td>
          <td class="paramname"><em>output_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context with the specified input and output <code><a class="el" href="group__group__flags.html#ga72b0491c9cbf2071f0c96c7d29b719bb" title="The soap_mode flags to initialize the soap context, flags can be combined with | (bit-wise or) ...">soap_mode</a></code> flags (C++ only, in C use <code><a class="el" href="group__group__context.html#ga12a87f6795b62b05164edc392b2adb1d" title="Allocate and initialize a new soap context with separate input and output soap_mode flags...">soap_new2</a></code> or <code><a class="el" href="group__group__context.html#ga3c70b587fc4f65553cfe69751d1a157e" title="Initialize a stack-allocated soap context with input and output soap_mode flags. ">soap_init2</a></code>)) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input_mode</td><td>input <code><a class="el" href="group__group__flags.html#ga72b0491c9cbf2071f0c96c7d29b719bb" title="The soap_mode flags to initialize the soap context, flags can be combined with | (bit-wise or) ...">soap_mode</a></code> flags </td></tr>
    <tr><td class="paramname">output_mode</td><td>output <code><a class="el" href="group__group__flags.html#ga72b0491c9cbf2071f0c96c7d29b719bb" title="The soap_mode flags to initialize the soap context, flags can be combined with | (bit-wise or) ...">soap_mode</a></code> flags </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5b8499f93cceb2ad2cda72dbf2e4c0e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">soap::soap </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structsoap.html">soap</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructor (C++ only, in C use <code><a class="el" href="group__group__context.html#gab4c3f8ce80baf0f1fec8c86f0bb5788a" title="Allocate and initialize a new soap context as a copy of the given soap context. ">soap_copy</a></code> or <code><a class="el" href="group__group__context.html#gabcb00978a07439254c4dd44c6332b2bf" title="Copy a given soap context to an uninitialized destination soap context. ">soap_copy_context</a></code>) </p>

</div>
</div>
<a class="anchor" id="a63d4dae42dd30970b89bfc081743503a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">soap::~soap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalize and delete the <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context by finalizing with soap_done(this) (C++ only, in C use <code><a class="el" href="group__group__context.html#ga57108ca4681186e58b5b189c3528f10a" title="Finalize and free the given soap context from unmanaged heap memory. ">soap_free</a></code> or <code><a class="el" href="group__group__context.html#ga28ee8fdcf500443e0e51750324aa6a1a" title="Finalize the given soap context, i.e. when the soap context is stack allocated, automatically invoked...">soap_done</a></code>) </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a0c714b6ed5245dbe34cf7b747aa226ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void soap::destroy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete all dynamically-allocated objects and data managed by this <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context (C++ only, in C use <code><a class="el" href="group__group__context.html#ga81a009ae1ea825a05e5241e2b7a8ece9" title="Delete all data from heap memory managed by the specified soap context and release the freed memory b...">soap_end</a></code>) </p>

</div>
</div>
<a class="anchor" id="ae731dd4b82b3a91b679c410756ee4faa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structsoap.html">soap</a>&amp; soap::operator= </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structsoap.html">soap</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assignment constructor (C++ only, in C use <code><a class="el" href="group__group__context.html#gab4c3f8ce80baf0f1fec8c86f0bb5788a" title="Allocate and initialize a new soap context as a copy of the given soap context. ">soap_copy</a></code> or <code><a class="el" href="group__group__context.html#gabcb00978a07439254c4dd44c6332b2bf" title="Copy a given soap context to an uninitialized destination soap context. ">soap_copy_context</a></code>) </p>
<dl class="section return"><dt>Returns</dt><dd>this <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="ad98f12f602efdde049dbd367a43e7cb0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soap::accept_flags</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User-definable <code>setsockopt</code> level <code>SOL_SOCKET</code> flags (0 by default), when nonzero sets the <code><a class="el" href="structsoap.html#a1579bd8bd106afc9a906a673ca473046" title="The socket set by soap_accept (or the C++ service class accept method) or soap_connect or soap_connec...">soap::socket</a></code> flags when accepting a request with <code><a class="el" href="group__group__io.html#gaec0e1aecc2d5479d8099762feb4713c6" title="Accept a connection with a client. ">soap_accept</a></code> (or the C++ service class <code>accept</code> method) </p>
<dl class="section user"><dt>Example:</dt><dd></dd></dl>
<div class="fragment"><div class="line"><span class="keyword">struct </span>soap *soap = <a class="code" href="group__group__context.html#ga87c20488b2dc680aaa7689b1d024989c">soap_new</a>();</div><div class="line">soap-&gt;<a class="code" href="structsoap.html#ad98f12f602efdde049dbd367a43e7cb0">accept_flags</a> = SO_NOSIGPIPE; <span class="comment">// no sigpipe (this is not portable)</span></div></div><!-- fragment --><p>Other ways to disable sigpipe:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>soap *soap = <a class="code" href="group__group__context.html#ga87c20488b2dc680aaa7689b1d024989c">soap_new</a>();</div><div class="line">soap-&gt;<a class="code" href="structsoap.html#aae3eee771d8c4031d30d4ca7633edf9f">socket_flags</a> = MSG_NOSIGNAL;</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;signal.h&gt;</span></div><div class="line"><span class="keywordtype">void</span> sigpipe_handle(<span class="keywordtype">int</span>) { }</div><div class="line"></div><div class="line">signal(SIGPIPE, sigpipe_handle);</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><code><a class="el" href="structsoap.html#aae3eee771d8c4031d30d4ca7633edf9f" title="User-definable socket send and recv flags, for example assign MSG_NOSIGNAL to disable sigpipe (0 by d...">soap::socket_flags</a></code>, <code><a class="el" href="structsoap.html#a52a22fafc369b3a54fb0d16f53158794" title="User-definable setsockopt level SOL_SOCKET flags when connecting soap::socket to a server (0 by defau...">soap::connect_flags</a></code>, <code><a class="el" href="structsoap.html#a6b18b017ce2c77ac2b6331469094de59" title="User-definable setsockopt level SOL_SOCKET flags when binding soap::master socket (0 by default) ...">soap::bind_flags</a></code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a78199a81c504833047224a0ceff6f906"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soap::accept_timeout</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User-definable timeout when waiting to accept a request from a client at the server-side with <code><a class="el" href="group__group__io.html#gaec0e1aecc2d5479d8099762feb4713c6" title="Accept a connection with a client. ">soap_accept</a></code> (or the C++ service class <code>accept</code> method), positive timeout values are seconds, negative timeout values are microseconds, zero means no timeout (0 by default) </p>
<dl class="section user"><dt>Example:</dt><dd></dd></dl>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;soapH.h&quot;</span></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keyword">struct </span>soap *soap = <a class="code" href="group__group__context.html#ga87c20488b2dc680aaa7689b1d024989c">soap_new</a>();</div><div class="line">  soap-&gt;<a class="code" href="structsoap.html#a78199a81c504833047224a0ceff6f906">accept_timeout</a> = 3600;                <span class="comment">// exit loop when no request arrives in one hour</span></div><div class="line">  soap-&gt;<a class="code" href="structsoap.html#a711bb3a53de7cc62429e4d3a2e0b5474">send_timeout</a> = soap_recv_timeout = 5; <span class="comment">// 5 seconds max socket stall time (unlimited by default)</span></div><div class="line">  soap-&gt;<a class="code" href="structsoap.html#afcf1d236d052579122f785d7639c43c7">transfer_timeout</a> = 30;                <span class="comment">// 30 seconds max message transfer time (unlimited by default)</span></div><div class="line">  soap-&gt;<a class="code" href="structsoap.html#a345900c2db67e915ceb02bfa21ecbcbd">recv_maxlength</a> = 1048576;             <span class="comment">// limit messages received to 1MB (2GB by default)</span></div><div class="line">  <span class="keywordflow">if</span> (<a class="code" href="group__group__soap.html#gaaae8747f4cdacee575875c3a2488d99c">soap_valid_socket</a>(<a class="code" href="group__group__io.html#ga0a9725a3edbc27b97456190fee47cc18">soap_bind</a>(soap, NULL, PORTNUM, BACKLOG)))</div><div class="line">  {</div><div class="line">    <span class="keywordflow">while</span> (1)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">if</span> (<a class="code" href="group__group__soap.html#gaaae8747f4cdacee575875c3a2488d99c">soap_valid_socket</a>(<a class="code" href="group__group__io.html#gaec0e1aecc2d5479d8099762feb4713c6">soap_accept</a>(soap)))</div><div class="line">      {</div><div class="line">        <span class="keywordflow">if</span> (<a class="code" href="group__group__io.html#ga51dba7706a505240bd8935c0b28e419d">soap_serve</a>(soap))</div><div class="line">          <a class="code" href="group__group__fault.html#ga931a4ab6df2553b48a0c270f8a0a88af">soap_print_fault</a>(soap, stderr);</div><div class="line">      }</div><div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (soap-&gt;<a class="code" href="structsoap.html#a10b66d6d489690b7d0f591ae2633dd13">errnum</a>) <span class="comment">// accept failed, try again after 1 second</span></div><div class="line">      {</div><div class="line">        <a class="code" href="group__group__fault.html#ga931a4ab6df2553b48a0c270f8a0a88af">soap_print_fault</a>(soap, stderr);</div><div class="line">        sleep(1);</div><div class="line">      }</div><div class="line">      <span class="keywordflow">else</span> <span class="comment">// accept timed out, quit looping</span></div><div class="line">      {</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">      }</div><div class="line">      <a class="code" href="group__group__context.html#gaf7d0176161e9def36981e24faa1913d9">soap_destroy</a>(soap);</div><div class="line">      <a class="code" href="group__group__context.html#ga81a009ae1ea825a05e5241e2b7a8ece9">soap_end</a>(soap);</div><div class="line">    }</div><div class="line">  }</div><div class="line">  <a class="code" href="group__group__context.html#ga57108ca4681186e58b5b189c3528f10a">soap_free</a>(soap);</div><div class="line">}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><code><a class="el" href="structsoap.html#ab85f5d42702963d13ea540bd9876e6d2" title="The soap context soap_status (int) error code of the last operation or SOAP_OK (zero) ...">soap::error</a></code>, <code><a class="el" href="structsoap.html#a10b66d6d489690b7d0f591ae2633dd13" title="The errno value of the last failed IO operation. ">soap::errnum</a></code>, <code><a class="el" href="structsoap.html#af32b5f3975eac2bd1202571515859163" title="User-definable timeout when waiting to connect to a server at the client-side, positive timeout value...">soap::connect_timeout</a></code>, <code><a class="el" href="structsoap.html#ac5d5fb92fffda724ccb3b038d2bb2388" title="User-definable timeout to receive a packet of data, positive timeout values are seconds, negative timeout values are microseconds, zero means no timeout (0 by default) ">soap::recv_timeout</a></code>, <code><a class="el" href="structsoap.html#a711bb3a53de7cc62429e4d3a2e0b5474" title="User-definable timeout to send a packet of data, positive timeout values are seconds, negative timeout values are microseconds, zero means no timeout (0 by default) ">soap::send_timeout</a></code>, <code><a class="el" href="structsoap.html#afcf1d236d052579122f785d7639c43c7" title="User-definable timeout to send or receive an entire message, positive timeout values are seconds...">soap::transfer_timeout</a></code>, <code><a class="el" href="structsoap.html#a345900c2db67e915ceb02bfa21ecbcbd" title="User-definable maximum message length that is permitted to be received, zero means unlimited (2GB by ...">soap::recv_maxlength</a></code>. </dd></dl>

</div>
</div>
<a class="anchor" id="abda4ccd0d64f76eb57145cc4890c87b2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* soap::actor</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User-definable <em><code>SOAP-ENV:actor</code></em> (SOAP 1.1) or <em><code>SOAP-ENV:role</code></em> (SOAP 1.2) attribute value of all <em><code>SOAP-ENV:mustUnderstand</code></em> attributed header elements. </p>
<dl class="section user"><dt>Example:</dt><dd></dd></dl>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;soapH.h&quot;</span></div><div class="line"><span class="keyword">struct </span>soap *soap = <a class="code" href="group__group__context.html#ga87c20488b2dc680aaa7689b1d024989c">soap_new</a>();</div><div class="line">... <span class="comment">// context initializations</span></div><div class="line"><span class="comment">// add a SOAP Header to the message</span></div><div class="line"><a class="code" href="struct_s_o_a_p___e_n_v_____header.html">SOAP_ENV__Header</a> <a class="code" href="structsoap.html#ac091dfe4e01b6a082d916c381e7006ba">header</a>;</div><div class="line">header-&gt;ns__required_value = 123; <span class="comment">// a header element marked mustUnderstand</span></div><div class="line">soap-&gt;<a class="code" href="structsoap.html#ac091dfe4e01b6a082d916c381e7006ba">header</a> = &amp;<a class="code" href="structsoap.html#ac091dfe4e01b6a082d916c381e7006ba">header</a>;</div><div class="line"><span class="comment">// add SOAP-ENV:role=&quot;http://www.w3.org/2002/06/soap-envelope/role/next&quot;;</span></div><div class="line">soap-&gt;<a class="code" href="structsoap.html#abda4ccd0d64f76eb57145cc4890c87b2">actor</a> = <span class="stringliteral">&quot;http://www.w3.org/2002/06/soap-envelope/role/next&quot;</span>;</div><div class="line"><span class="keywordflow">if</span> (soap_call_ns__webmethod(soap, <a class="code" href="structsoap.html#aed1b86b8a34aea86103751a932c9dce9">endpoint</a>, NULL, ...))</div><div class="line">  <a class="code" href="group__group__fault.html#ga931a4ab6df2553b48a0c270f8a0a88af">soap_print_fault</a>(soap, stderr);</div><div class="line"><span class="keywordflow">else</span></div><div class="line">  ... <span class="comment">// success</span></div><div class="line"><a class="code" href="group__group__context.html#gaf7d0176161e9def36981e24faa1913d9">soap_destroy</a>(soap);</div><div class="line"><a class="code" href="group__group__context.html#ga81a009ae1ea825a05e5241e2b7a8ece9">soap_end</a>(soap);</div><div class="line"><a class="code" href="group__group__context.html#ga57108ca4681186e58b5b189c3528f10a">soap_free</a>(soap);</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><code><a class="el" href="struct_s_o_a_p___e_n_v_____header.html" title="SOAP Header structure. ">SOAP_ENV__Header</a></code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a8dbe57d59f683d99305a44b4d7939bfd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* soap::authrealm</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The HTTP and NTLM authorization realm/domain string received by the client with the <code>WWW-Authenticate</code> or <code>Proxy-Authenticate</code> HTTP headers, user-definable on the server side to send a <code>WWW-Authenticate</code> header to require authentication (service operation should return 401 to respond with "Unauthorized"), also serves as NTLM domain value. </p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="structsoap.html#a2ede02095d98942f4c220fd17b495703" title="User-definable HTTP and NTLM authorization user id string for HTTP basic and NTLM authentication by t...">soap::userid</a></code>, <code><a class="el" href="structsoap.html#a22d219c98f0fcf456641277cc64174a3" title="User-definable HTTP and NTLM authorization password string required for HTTP basic and NTLM authentic...">soap::passwd</a></code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a5213a5328b44244689fd3c2937cc8b92"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* soap::bearer</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User-definable HTTP authorization bearer token value to be sent by the client, server side receives this string when the client sends authorization bearer. </p>
<dl class="section user"><dt>Example:</dt><dd></dd></dl>
<div class="fragment"><div class="line"><span class="keyword">struct </span>soap *soap = <a class="code" href="group__group__context.html#ga87c20488b2dc680aaa7689b1d024989c">soap_new</a>();</div><div class="line"><span class="keywordflow">if</span> (<a class="code" href="group__group__ssl.html#ga269c7732b1cda9dc79db08fcbf1d5438">soap_ssl_client_context</a>(soap, ...))</div><div class="line">  exit(EXIT_FAILURE);</div><div class="line">soap-&gt;<a class="code" href="structsoap.html#a5213a5328b44244689fd3c2937cc8b92">bearer</a> = <span class="stringliteral">&quot;bearer-token&quot;</span>;</div><div class="line"><span class="keywordflow">if</span> (soap_call_ns__webmethod(soap, <a class="code" href="structsoap.html#aed1b86b8a34aea86103751a932c9dce9">endpoint</a>, NULL, ...))</div><div class="line">  <a class="code" href="group__group__fault.html#ga931a4ab6df2553b48a0c270f8a0a88af">soap_print_fault</a>(soap, stderr);</div><div class="line"><span class="keywordflow">else</span></div><div class="line">  ... <span class="comment">// success</span></div><div class="line"><a class="code" href="group__group__context.html#gaf7d0176161e9def36981e24faa1913d9">soap_destroy</a>(soap);</div><div class="line"><a class="code" href="group__group__context.html#ga81a009ae1ea825a05e5241e2b7a8ece9">soap_end</a>(soap);</div><div class="line"><a class="code" href="group__group__context.html#ga57108ca4681186e58b5b189c3528f10a">soap_free</a>(soap);</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keyword">struct </span>soap *soap = <a class="code" href="group__group__context.html#ga87c20488b2dc680aaa7689b1d024989c">soap_new</a>();</div><div class="line">  <span class="keywordflow">if</span> (<a class="code" href="group__group__ssl.html#ga3492465cdd8aa71fe746199d3842cac7">soap_ssl_server_context</a>(soap, ...))</div><div class="line">    exit(EXIT_FAILURE);</div><div class="line">  ... <span class="comment">// serve requests with soap_bind, soap_accept, soap_ssl_accept, and soap_serve</span></div><div class="line">}</div><div class="line"><span class="keywordtype">int</span> ns__webmethod(<span class="keyword">struct</span> soap *soap, ...)</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> (!soap-&gt;<a class="code" href="structsoap.html#a5213a5328b44244689fd3c2937cc8b92">bearer</a> || strcmp(soap-&gt;<a class="code" href="structsoap.html#a5213a5328b44244689fd3c2937cc8b92">bearer</a>, <span class="stringliteral">&quot;bearer-token&quot;</span>))</div><div class="line">    <span class="keywordflow">return</span> 401; <span class="comment">// Unauthorized</span></div><div class="line">  ... <span class="comment">// process the request data and populate the response data</span></div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="group__group__errors.html#ga3b10a68f354f39cbb0fe0d043ad4c7c0">SOAP_OK</a>;</div><div class="line">}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__group__ssl.html#ga269c7732b1cda9dc79db08fcbf1d5438" title="Initialize the client-side SSL/TLS context. ">soap_ssl_client_context</a></code>, <code><a class="el" href="group__group__ssl.html#ga3492465cdd8aa71fe746199d3842cac7" title="Initialize the server-side SSL/TLS context. ">soap_ssl_server_context</a></code>, <code><a class="el" href="structsoap.html#a2ede02095d98942f4c220fd17b495703" title="User-definable HTTP and NTLM authorization user id string for HTTP basic and NTLM authentication by t...">soap::userid</a></code>, <code><a class="el" href="structsoap.html#a22d219c98f0fcf456641277cc64174a3" title="User-definable HTTP and NTLM authorization password string required for HTTP basic and NTLM authentic...">soap::passwd</a></code>, <code><a class="el" href="structsoap.html#af2c9e77616c132831ebf041d9e4d18b1" title="User-definable NTLM authentication challenge key string. ">soap::ntlm_challenge</a></code> and the <a href="../../httpda/html/httpda.html">HTTP digest plugin</a> documentation. </dd></dl>

</div>
</div>
<a class="anchor" id="a6b18b017ce2c77ac2b6331469094de59"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soap::bind_flags</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User-definable <code>setsockopt</code> level <code>SOL_SOCKET</code> flags when binding <code><a class="el" href="structsoap.html#ab649b8f3b71081d14ec6350ab4b06794" title="The socket set by soap_bind (or the C++ service class bind method) to serve as the master socket boun...">soap::master</a></code> socket (0 by default) </p>
<dl class="section user"><dt>Example</dt><dd></dd></dl>
<div class="fragment"><div class="line"><span class="keyword">struct </span>soap *soap = <a class="code" href="group__group__context.html#ga87c20488b2dc680aaa7689b1d024989c">soap_new</a>();</div><div class="line">soap-&gt;<a class="code" href="structsoap.html#a6b18b017ce2c77ac2b6331469094de59">bind_flags</a> = SO_REUSEADDR; <span class="comment">// immediate port reuse when binding</span></div><div class="line"><span class="keywordflow">if</span> (<a class="code" href="group__group__soap.html#gaaae8747f4cdacee575875c3a2488d99c">soap_valid_socket</a>(<a class="code" href="group__group__io.html#ga0a9725a3edbc27b97456190fee47cc18">soap_bind</a>(soap, NULL, PORTNUM, BACKLOG))</div><div class="line">  ... <span class="comment">// success</span></div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><code><a class="el" href="structsoap.html#aae3eee771d8c4031d30d4ca7633edf9f" title="User-definable socket send and recv flags, for example assign MSG_NOSIGNAL to disable sigpipe (0 by d...">soap::socket_flags</a></code>, <code><a class="el" href="structsoap.html#a52a22fafc369b3a54fb0d16f53158794" title="User-definable setsockopt level SOL_SOCKET flags when connecting soap::socket to a server (0 by defau...">soap::connect_flags</a></code>, <code><a class="el" href="structsoap.html#ad98f12f602efdde049dbd367a43e7cb0" title="User-definable setsockopt level SOL_SOCKET flags (0 by default), when nonzero sets the soap::socket f...">soap::accept_flags</a></code>, <code><a class="el" href="group__group__with.html#ga40cbd680e7dbdeb63bce1d6d4b7b9620" title="When this macro is defined at compile time (undefined by default), IPv6 support is enabled and both I...">WITH_IPV6</a></code>, <code><a class="el" href="group__group__with.html#ga2854fe8474c2f87a9916d892306cb94c" title="When this macro is defined at compile time (undefined by default), IPv6-only is enabled for port bind...">WITH_IPV6_V6ONLY</a></code>, <code><a class="el" href="group__group__flags.html#ga388dae9abc80cd6f6d0ecfba383da03b" title="soap_mode IO input/output flag value to use UDP datagrams, message size is limited to UDP packet size...">SOAP_IO_UDP</a></code>, <code><a class="el" href="structsoap.html#a08f1b076f0f041cdf89b9a969520fd4a" title="User-definable flag, when nonzero uses AF_INET6 instead of PF_UNSPEC when binding the soap::master so...">soap::bind_inet6</a></code>, <code><a class="el" href="structsoap.html#a90e04027ea9efa26e550f5438ab9f3d6" title="User-definable flag, when nonzero enables IPPROTO_IPV6 setsockopt IPV6_V6ONLY when binding the soap::...">soap::bind_v6only</a></code>, <code><a class="el" href="structsoap.html#af2b1fc40a14f7ed925658246a26497c8" title="User-definable value to set SO_RCVBUF setsockopt (SOAP_BUFLEN by default) ">soap::rcvbuf</a></code>, <code><a class="el" href="structsoap.html#a02a7fffd05ff6e6c751f2033ef83854f" title="User-definable value to set SO_SNDBUF setsockopt (SOAP_BUFLEN by default) ">soap::sndbuf</a></code>, <code><a class="el" href="structsoap.html#ab649b8f3b71081d14ec6350ab4b06794" title="The socket set by soap_bind (or the C++ service class bind method) to serve as the master socket boun...">soap::master</a></code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a08f1b076f0f041cdf89b9a969520fd4a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">short soap::bind_inet6</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User-definable flag, when nonzero uses <code>AF_INET6</code> instead of <code>PF_UNSPEC</code> when binding the <code><a class="el" href="structsoap.html#ab649b8f3b71081d14ec6350ab4b06794" title="The socket set by soap_bind (or the C++ service class bind method) to serve as the master socket boun...">soap::master</a></code> socket in <code><a class="el" href="group__group__io.html#ga0a9725a3edbc27b97456190fee47cc18" title="Bind and listen to a port. ">soap_bind</a></code> (or the C++ service class <code>bind</code> method), to remap IPv4 to IPv6 addresses, meaningful only when used with <code><a class="el" href="group__group__with.html#ga40cbd680e7dbdeb63bce1d6d4b7b9620" title="When this macro is defined at compile time (undefined by default), IPv6 support is enabled and both I...">WITH_IPV6</a></code> </p>
<dl class="section user"><dt>Example:</dt><dd></dd></dl>
<div class="fragment"><div class="line"><span class="comment">// requires compilation with compile-time flag -D WITH_IPV6</span></div><div class="line"><span class="keyword">struct </span>soap *soap = <a class="code" href="group__group__context.html#ga87c20488b2dc680aaa7689b1d024989c">soap_new</a>();</div><div class="line">soap-&gt;<a class="code" href="structsoap.html#a08f1b076f0f041cdf89b9a969520fd4a">bind_inet6</a> = 1;</div><div class="line">soap-&gt;<a class="code" href="structsoap.html#a90e04027ea9efa26e550f5438ab9f3d6">bind_v6only</a> = 1;</div><div class="line"><span class="keywordflow">if</span> (<a class="code" href="group__group__soap.html#gaaae8747f4cdacee575875c3a2488d99c">soap_valid_socket</a>(<a class="code" href="group__group__io.html#ga0a9725a3edbc27b97456190fee47cc18">soap_bind</a>(soap, NULL, PORTNUM, BACKLOG)) <span class="comment">// IPv6 address binding</span></div><div class="line">  ... <span class="comment">// success</span></div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><code><a class="el" href="structsoap.html#a90e04027ea9efa26e550f5438ab9f3d6" title="User-definable flag, when nonzero enables IPPROTO_IPV6 setsockopt IPV6_V6ONLY when binding the soap::...">soap::bind_v6only</a></code>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Requires compilation with <code><a class="el" href="group__group__with.html#ga40cbd680e7dbdeb63bce1d6d4b7b9620" title="When this macro is defined at compile time (undefined by default), IPv6 support is enabled and both I...">WITH_IPV6</a></code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a90e04027ea9efa26e550f5438ab9f3d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">short soap::bind_v6only</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User-definable flag, when nonzero enables <code>IPPROTO_IPV6</code> <code>setsockopt</code> <code>IPV6_V6ONLY</code> when binding the <code><a class="el" href="structsoap.html#ab649b8f3b71081d14ec6350ab4b06794" title="The socket set by soap_bind (or the C++ service class bind method) to serve as the master socket boun...">soap::master</a></code> socket with <code><a class="el" href="group__group__io.html#ga0a9725a3edbc27b97456190fee47cc18" title="Bind and listen to a port. ">soap_bind</a></code> (or the C++ service class <code>bind</code> method), meaningful only when used with <code><a class="el" href="group__group__with.html#ga40cbd680e7dbdeb63bce1d6d4b7b9620" title="When this macro is defined at compile time (undefined by default), IPv6 support is enabled and both I...">WITH_IPV6</a></code> </p>
<dl class="section user"><dt>Example:</dt><dd></dd></dl>
<div class="fragment"><div class="line"><span class="comment">// requires compilation with compile-time flag -D WITH_IPV6</span></div><div class="line"><span class="keyword">struct </span>soap *soap = <a class="code" href="group__group__context.html#ga87c20488b2dc680aaa7689b1d024989c">soap_new</a>();</div><div class="line">soap-&gt;<a class="code" href="structsoap.html#a08f1b076f0f041cdf89b9a969520fd4a">bind_inet6</a> = 1;</div><div class="line">soap-&gt;<a class="code" href="structsoap.html#a90e04027ea9efa26e550f5438ab9f3d6">bind_v6only</a> = 1;</div><div class="line"><span class="keywordflow">if</span> (<a class="code" href="group__group__soap.html#gaaae8747f4cdacee575875c3a2488d99c">soap_valid_socket</a>(<a class="code" href="group__group__io.html#ga0a9725a3edbc27b97456190fee47cc18">soap_bind</a>(soap, NULL, PORTNUM, BACKLOG)) <span class="comment">// IPv6 address binding</span></div><div class="line">  ... <span class="comment">// success</span></div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><code><a class="el" href="structsoap.html#a08f1b076f0f041cdf89b9a969520fd4a" title="User-definable flag, when nonzero uses AF_INET6 instead of PF_UNSPEC when binding the soap::master so...">soap::bind_inet6</a></code>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Requires compilation with <code><a class="el" href="group__group__with.html#ga40cbd680e7dbdeb63bce1d6d4b7b9620" title="When this macro is defined at compile time (undefined by default), IPv6 support is enabled and both I...">WITH_IPV6</a></code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a3b89f13ece11d9f9b6e48bf15ff48be6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">short soap::body</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <code><a class="el" href="structsoap.html#a3b89f13ece11d9f9b6e48bf15ff48be6" title="The soap::body flag is set when an element has element content during XML parsing or when a HTTP mess...">soap::body</a></code> flag is set when an element has element content during XML parsing or when a HTTP message has a body when parsing an HTTP header. </p>

</div>
</div>
<a class="anchor" id="acda1736fbaac07261226befe165a5681"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char soap::buf[<a class="el" href="group__group__soap.html#ga6ec95d997cc20a6a84dd4d76b3ea2fcc">SOAP_BUFLEN</a>]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Internal buffer with partial data received or partial data to be sent, where the data occupies <code><a class="el" href="structsoap.html#a0b72b2e13d73dd568d845143822d29d8" title="Internal index that keeps track of the length of the data available in the soap::buf buffer...">soap::buflen</a></code> bytes. </p>

</div>
</div>
<a class="anchor" id="a2dfa3dce8e02bf011c3bbbbfe2f8042a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t soap::bufidx</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Internal index that keeps track of the current position in the <code><a class="el" href="structsoap.html#acda1736fbaac07261226befe165a5681" title="Internal buffer with partial data received or partial data to be sent, where the data occupies soap::...">soap::buf</a></code> buffer after receiving data into the buffer. </p>

</div>
</div>
<a class="anchor" id="a0b72b2e13d73dd568d845143822d29d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t soap::buflen</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Internal index that keeps track of the length of the data available in the <code><a class="el" href="structsoap.html#acda1736fbaac07261226befe165a5681" title="Internal buffer with partial data received or partial data to be sent, where the data occupies soap::...">soap::buf</a></code> buffer, does not exceed <code><a class="el" href="group__group__soap.html#ga6ec95d997cc20a6a84dd4d76b3ea2fcc" title="User-definable size of the input and output message buffer soap::buf (65536 by default) ...">SOAP_BUFLEN</a></code> </p>

</div>
</div>
<a class="anchor" id="afd294a7412902194179ec31c2d0200ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* soap::c14nexclude</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User-definable string to control the XML namespace prefixes that are subject to XML canonicalization with <code><a class="el" href="group__group__flags.html#ga757fa32433be64f8c228b1ecce727815" title="soap_mode XML output flag value to send XML messages in exclusive canonical format as per W3C XML C14...">SOAP_XML_CANONICAL</a></code> output mode flag, specified by space-separated prefixes in the string, or NULL when unused. </p>

</div>
</div>
<a class="anchor" id="a400a1663c7b747b84fa17100e10e3eb9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* soap::c14ninclude</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User-definable string to control the XML namespace prefixes that are subject to XML canonicalization with the <code><a class="el" href="group__group__flags.html#ga757fa32433be64f8c228b1ecce727815" title="soap_mode XML output flag value to send XML messages in exclusive canonical format as per W3C XML C14...">SOAP_XML_CANONICAL</a></code> output mode flag, specified by space-separated prefixes in the string, or <code>*</code> to specify that all prefixes are inclusive, or NULL when unused. </p>

</div>
</div>
<a class="anchor" id="aa66026bcd099d88d44c985b49928a05d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* soap::client_interface</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User-definable client address to use when connecting, when non-NULL. </p>
<p>When non-NULL, sets the client address before connecting to a server. The value is reset to NULL after connecting successfully or unsuccessfully to the server.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="structsoap.html#a9b424c2622c9f8e4284eba0e6c74e67c" title="User-definable client port to bind to when connecting, when non-negative. ">soap::client_port</a></code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a9b424c2622c9f8e4284eba0e6c74e67c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soap::client_port</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User-definable client port to bind to when connecting, when non-negative. </p>
<p>When non-negative, executes a <code>bind</code> with this port number before connecting to a server. The value is reset to -1 after connecting successfully or unsuccessfully to the server.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="structsoap.html#aa66026bcd099d88d44c985b49928a05d" title="User-definable client address to use when connecting, when non-NULL. ">soap::client_interface</a></code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a52a22fafc369b3a54fb0d16f53158794"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soap::connect_flags</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User-definable <code>setsockopt</code> level <code>SOL_SOCKET</code> flags when connecting <code><a class="el" href="structsoap.html#a1579bd8bd106afc9a906a673ca473046" title="The socket set by soap_accept (or the C++ service class accept method) or soap_connect or soap_connec...">soap::socket</a></code> to a server (0 by default) </p>
<dl class="section user"><dt>Examples:</dt><dd></dd></dl>
<div class="fragment"><div class="line"><span class="keyword">struct </span>soap *soap = <a class="code" href="group__group__context.html#ga87c20488b2dc680aaa7689b1d024989c">soap_new</a>();</div><div class="line">soap-&gt;<a class="code" href="structsoap.html#a52a22fafc369b3a54fb0d16f53158794">connect_flags</a> = SO_LINGER;</div><div class="line">soap-&gt;<a class="code" href="structsoap.html#a0f4d025053fde77216a0ca674077198d">linger_time</a> = 5;</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">struct </span>soap *soap = <a class="code" href="group__group__context.html#ga87c20488b2dc680aaa7689b1d024989c">soap_new</a>();</div><div class="line">soap-&gt;<a class="code" href="structsoap.html#a52a22fafc369b3a54fb0d16f53158794">connect_flags</a> = SO_BROADCAST;</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><code><a class="el" href="structsoap.html#aae3eee771d8c4031d30d4ca7633edf9f" title="User-definable socket send and recv flags, for example assign MSG_NOSIGNAL to disable sigpipe (0 by d...">soap::socket_flags</a></code>, <code><a class="el" href="structsoap.html#a6b18b017ce2c77ac2b6331469094de59" title="User-definable setsockopt level SOL_SOCKET flags when binding soap::master socket (0 by default) ...">soap::bind_flags</a></code>, <code><a class="el" href="structsoap.html#ad98f12f602efdde049dbd367a43e7cb0" title="User-definable setsockopt level SOL_SOCKET flags (0 by default), when nonzero sets the soap::socket f...">soap::accept_flags</a></code>. </dd></dl>

</div>
</div>
<a class="anchor" id="af32b5f3975eac2bd1202571515859163"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soap::connect_timeout</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User-definable timeout when waiting to connect to a server at the client-side, positive timeout values are seconds, negative timeout values are microseconds, zero means no timeout (0 by default) </p>
<dl class="section user"><dt>Example:</dt><dd></dd></dl>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;soapH.h&quot;</span></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keyword">struct </span>soap *soap = <a class="code" href="group__group__context.html#ga87c20488b2dc680aaa7689b1d024989c">soap_new</a>();</div><div class="line">  soap-&gt;<a class="code" href="structsoap.html#af32b5f3975eac2bd1202571515859163">connect_timeout</a> = 30;                 <span class="comment">// 30 seconds max connect stall time</span></div><div class="line">  soap-&gt;<a class="code" href="structsoap.html#a711bb3a53de7cc62429e4d3a2e0b5474">send_timeout</a> = soap_recv_timeout = 5; <span class="comment">// 5 seconds max socket stall time (unlimited by default)</span></div><div class="line">  soap-&gt;<a class="code" href="structsoap.html#afcf1d236d052579122f785d7639c43c7">transfer_timeout</a> = 30;                <span class="comment">// 30 seconds max message transfer time (unlimited by default)</span></div><div class="line">  soap-&gt;<a class="code" href="structsoap.html#a345900c2db67e915ceb02bfa21ecbcbd">recv_maxlength</a> = 1048576;             <span class="comment">// limit messages received to 1MB (2GB by default)</span></div><div class="line">  <span class="keywordflow">if</span> (soap_call_ns__webmethod(soap, <a class="code" href="structsoap.html#aed1b86b8a34aea86103751a932c9dce9">endpoint</a>, NULL, ...))</div><div class="line">  {</div><div class="line">    <a class="code" href="group__group__fault.html#ga931a4ab6df2553b48a0c270f8a0a88af">soap_print_fault</a>(soap, stderr);</div><div class="line">    <span class="keywordflow">if</span> (soap-&gt;<a class="code" href="structsoap.html#a10b66d6d489690b7d0f591ae2633dd13">errnum</a> == 0) <span class="comment">// timed out, exit program</span></div><div class="line">      exit(EXIT_FAILURE);</div><div class="line">  }</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">  {</div><div class="line">    ... <span class="comment">// success</span></div><div class="line">  }</div><div class="line">  <a class="code" href="group__group__context.html#gaf7d0176161e9def36981e24faa1913d9">soap_destroy</a>(soap);</div><div class="line">  <a class="code" href="group__group__context.html#ga81a009ae1ea825a05e5241e2b7a8ece9">soap_end</a>(soap);</div><div class="line">  <a class="code" href="group__group__context.html#ga57108ca4681186e58b5b189c3528f10a">soap_free</a>(soap);</div><div class="line">}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><code><a class="el" href="structsoap.html#ab85f5d42702963d13ea540bd9876e6d2" title="The soap context soap_status (int) error code of the last operation or SOAP_OK (zero) ...">soap::error</a></code>, <code><a class="el" href="structsoap.html#a10b66d6d489690b7d0f591ae2633dd13" title="The errno value of the last failed IO operation. ">soap::errnum</a></code>, <code><a class="el" href="structsoap.html#a78199a81c504833047224a0ceff6f906" title="User-definable timeout when waiting to accept a request from a client at the server-side with soap_ac...">soap::accept_timeout</a></code>, <code><a class="el" href="structsoap.html#ac5d5fb92fffda724ccb3b038d2bb2388" title="User-definable timeout to receive a packet of data, positive timeout values are seconds, negative timeout values are microseconds, zero means no timeout (0 by default) ">soap::recv_timeout</a></code>, <code><a class="el" href="structsoap.html#a711bb3a53de7cc62429e4d3a2e0b5474" title="User-definable timeout to send a packet of data, positive timeout values are seconds, negative timeout values are microseconds, zero means no timeout (0 by default) ">soap::send_timeout</a></code>, <code><a class="el" href="structsoap.html#afcf1d236d052579122f785d7639c43c7" title="User-definable timeout to send or receive an entire message, positive timeout values are seconds...">soap::transfer_timeout</a></code>, <code><a class="el" href="structsoap.html#a345900c2db67e915ceb02bfa21ecbcbd" title="User-definable maximum message length that is permitted to be received, zero means unlimited (2GB by ...">soap::recv_maxlength</a></code>. </dd></dl>

</div>
</div>
<a class="anchor" id="af2ecfbae740da7839a0c5c96eb65db2a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* soap::cookie_domain</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User-definable string that specifies the HTTP cookie domain of the running server. </p>

</div>
</div>
<a class="anchor" id="a44bd7fc8ba08b1dec2f08299d7f723dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soap::cookie_max</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User-definable maximum number of active cookies allowed to be set with <code><a class="el" href="group__group__cookies.html#ga7d5b0588ea763e511772f0cc2498e322" title="Add a cookie. ">soap_set_cookie</a></code> before cookie memory is reused (32 by default) </p>

</div>
</div>
<a class="anchor" id="afdd91ce1189fedd32ebfa51dd6ed33eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* soap::cookie_path</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User-definable string that specifies the HTTP cookie path of the running server. </p>

</div>
</div>
<a class="anchor" id="acefda44460d269105320e1ebe186608f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structsoap__cookie.html">soap_cookie</a>* soap::cookies</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The cookie store is a linked list of cookies. </p>

</div>
</div>
<a class="anchor" id="a9a1a820717a3a9c806c0d0f277f47427"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* soap::cors_allow</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User-definable CORS Access-Control-Allow-Origin HTTP header string default value (<code>*</code> by default) </p>
<p>CORS is automatic at the server side. At the client side, CORS requires the HTTP OPTIONS method with CORS headers.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="structsoap.html#a4a5abddf8cedcbe713d61dc6a82d54c3" title="The CORS Origin HTTP header string value received. ">soap::origin</a></code>. </dd></dl>

</div>
</div>
<a class="anchor" id="afc8032dc7b29093757d5f5f5241463de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* soap::cors_header</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The CORS Access-Control-Request-Headers HTTP header string received. </p>
<p>CORS is automatic at the server side. At the client side, CORS requires the HTTP OPTIONS method with CORS headers.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="structsoap.html#a4a5abddf8cedcbe713d61dc6a82d54c3" title="The CORS Origin HTTP header string value received. ">soap::origin</a></code>. </dd></dl>

</div>
</div>
<a class="anchor" id="af9681c002ba2bb1b2347dc177f102031"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* soap::cors_headers</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User-definable CORS Access-Control-Request-Headers HTTP header string to be returned by the server. </p>
<p>CORS is automatic at the server side. At the client side, CORS requires the HTTP OPTIONS method with CORS headers.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="structsoap.html#a4a5abddf8cedcbe713d61dc6a82d54c3" title="The CORS Origin HTTP header string value received. ">soap::origin</a></code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a6c70d16d39b9f403fc1827b78ca8e29f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* soap::cors_method</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The CORS Access-Control-Request-Method HTTP header string received. </p>
<p>CORS is automatic at the server side. At the client side, CORS requires the HTTP OPTIONS method with CORS headers.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="structsoap.html#a4a5abddf8cedcbe713d61dc6a82d54c3" title="The CORS Origin HTTP header string value received. ">soap::origin</a></code>. </dd></dl>

</div>
</div>
<a class="anchor" id="aeacd72a210204ebde6dcdb81bdaf4eef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* soap::cors_methods</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User-definable CORS Access-Control-Request-Methods HTTP header string to be returned by the server. </p>
<p>CORS is automatic at the server side. At the client side, CORS requires the HTTP OPTIONS method with CORS headers.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="structsoap.html#a4a5abddf8cedcbe713d61dc6a82d54c3" title="The CORS Origin HTTP header string value received. ">soap::origin</a></code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ae4a79c23a3ebab6023b6b6e16de734cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* soap::cors_origin</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The CORS Access-Control-Allow-Origin HTTP header string value received or the user-definable value to be returned by the server when set. </p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="structsoap.html#a4a5abddf8cedcbe713d61dc6a82d54c3" title="The CORS Origin HTTP header string value received. ">soap::origin</a></code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a407dae4bc84d0e7b809d51a3b8798e0c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__soap.html#ga7c6e38d209f60a18e362172dca1a3b6e">ULONG64</a> soap::count</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Message length counter value of the message received and counter value of the HTTP content length header to send a message. </p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__group__io.html#ga323e88327f1e0a1ce00b1428d7d9b4ba" title="Initialize context to count message length for sending. ">soap_begin_count</a></code>, <code><a class="el" href="group__group__io.html#gae2099fe49c19fb1409c31ec3d51fd8b4" title="Finalize context to count message length for sending. ">soap_end_count</a></code>, <code><a class="el" href="group__group__flags.html#gae27399f26b6a31d91b6884b957925c3e" title="soap_mode IO output flag value to calculate message length when sending a message without transmissio...">SOAP_IO_LENGTH</a></code>, <code><a class="el" href="group__group__flags.html#gaea7443dc67c979b06cf347ed16db1b51" title="soap_mode IO output flag value to send HTTP chunked messages, buffers the message in packets of size ...">SOAP_IO_CHUNK</a></code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a2ba5188ff4e8d734652a55a11842e79c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SSL_CTX* soap::ctx</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>OpenSSL context pointer. </p>
<p>This pointer is non-NULL after calling <code><a class="el" href="group__group__ssl.html#ga3492465cdd8aa71fe746199d3842cac7" title="Initialize the server-side SSL/TLS context. ">soap_ssl_server_context</a></code> or <code><a class="el" href="group__group__ssl.html#ga269c7732b1cda9dc79db08fcbf1d5438" title="Initialize the client-side SSL/TLS context. ">soap_ssl_client_context</a></code> and points to the OpenSSL context which can be configured with OpenSSL API functions such as <code>SSL_CTX_set_cipher_list</code>.</p>
<dl class="section note"><dt>Note</dt><dd>Requires compilation with <code><a class="el" href="group__group__with.html#gae5fa06f0e13edb611016c85364b0d0f0" title="When this macro is defined at compile time (undefined by default), enables linkage with OpenSSL for H...">WITH_OPENSSL</a></code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__group__ssl.html#ga3492465cdd8aa71fe746199d3842cac7" title="Initialize the server-side SSL/TLS context. ">soap_ssl_server_context</a></code>, <code><a class="el" href="group__group__ssl.html#ga269c7732b1cda9dc79db08fcbf1d5438" title="Initialize the client-side SSL/TLS context. ">soap_ssl_client_context</a></code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a38845a4e0cc0696782769ac9976c4dfa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structsoap__dime.html">soap_dime</a> soap::dime</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DIME attachments received. </p>
<p>This structure contains a linked list of DIME attachments received. </p>

</div>
</div>
<a class="anchor" id="a8541bff0934439c9f6fee6c449400fbe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* soap::dime_id_format</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User-definable format string to generate DIME content IDs. </p>
<p>The format string should contain a <code>d</code> or <code>x</code>. The default format string is "cid:id%d". </p>

</div>
</div>
<a class="anchor" id="ab7114dcbd53dfdb3518af7bb3e2d41ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct soap_dom_element* soap::dom</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DOM tree received. </p>
<p>This pointer points to the DOM tree received when <code><a class="el" href="group__group__flags.html#gaf16803276fca85d51698e5371a37b34e" title="soap_mode XML input/output flag value to enable DOM node tree construction of the XML received and se...">SOAP_XML_DOM</a></code> mode is enabled and the engine is configured with <code><a class="el" href="group__group__with.html#gac446a18bcd54c58c0b62362f2e6113e2" title="When this macro is defined at compile time (undefined by default), enables WS-Security signature veri...">WITH_DOM</a></code>.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__group__with.html#gac446a18bcd54c58c0b62362f2e6113e2" title="When this macro is defined at compile time (undefined by default), enables WS-Security signature veri...">WITH_DOM</a></code>, <code><a class="el" href="group__group__flags.html#gaf16803276fca85d51698e5371a37b34e" title="soap_mode XML input/output flag value to enable DOM node tree construction of the XML received and se...">SOAP_XML_DOM</a></code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ae1647309c9aec4b10cd9036cfabee86b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* soap::double_format</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User-definable double floating point format string (<code>%.17lG</code> by default, the printed format should not exceed 1023 bytes) </p>
<dl class="section user"><dt>Example:</dt><dd></dd></dl>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;soapH.h&quot;</span></div><div class="line"><span class="keyword">struct </span>soap *soap = <a class="code" href="group__group__context.html#ga87c20488b2dc680aaa7689b1d024989c">soap_new</a>();</div><div class="line">soap-&gt;<a class="code" href="structsoap.html#a7d7e87aec3cb136b6762a6ffb90a922a">float_format</a> = <span class="stringliteral">&quot;%g&quot;</span>;</div><div class="line">soap-&gt;<a class="code" href="structsoap.html#ae1647309c9aec4b10cd9036cfabee86b">double_format</a> = <span class="stringliteral">&quot;%g&quot;</span>;</div><div class="line">soap-&gt;<a class="code" href="structsoap.html#adcbd52999b85cad509a9b4b479cb9f4d">long_double_format</a> = <span class="stringliteral">&quot;%Lg&quot;</span>;</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a6b86360871d347d0a5f18a231fa82dc8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* soap::encodingStyle</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User-definable <em><code>SOAP-ENV:encodingStyle</code></em> URI value. </p>
<p>This URI string value is pre-defined by the engine depending on the SOAP protocol version used, setting this to NULL means no SOAP encodingStyle, setting this to "" means that the engine will set the encodingStyle URI according to the SOAP version used.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="structsoap.html#a39daa19f039aebc76b8c4b6bf933570a" title="SOAP version (0 = no SOAP, 1 = SOAP 1.1, 2 = SOAP 1.2) ">soap::version</a></code>, <code><a class="el" href="group__group__context.html#ga7c0a034b54cd46ee06ce1253e5a40467" title="Set SOAP version (0 = no SOAP, 1 = SOAP 1.1, 2 = SOAP 1.2) ">soap_set_version</a></code>. </dd></dl>

</div>
</div>
<a class="anchor" id="aed1b86b8a34aea86103751a932c9dce9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char soap::endpoint[<a class="el" href="group__group__soap.html#ga69f1ba9e1b47201e54822f365087f5a5">SOAP_TAGLEN</a>]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The endpoint string as received on the server side. </p>
<p>The URL endpoint string is extracted from the HTTP header by <code><a class="el" href="group__group__callbacks.html#ga9cb05ce98f845f16c920c44426ac35a5" title="Callback that reads and parses HTTP and MIME headers. ">soap::fparse</a></code> called by <code><a class="el" href="group__group__io.html#gaf4ce538944f65ac97d82bfeaa9345c42" title="Initialize the context for receiving. ">soap_begin_recv</a></code> and consists of <code><a class="el" href="structsoap.html#ab8f356cfb0a1ba87c26cb0ae4c9ee713" title="The client host name or IP address as received on the server side. ">soap::host</a></code>, <code><a class="el" href="structsoap.html#acef722da5f6789721603beeb0b505838" title="The client port connected to as received on the server side by soap_accept (or the C++ service class ...">soap::port</a></code>, and <code><a class="el" href="structsoap.html#a3c2bd2822146a8ccca20f8f217c2f309" title="The client request path as received on the server side. ">soap::path</a></code> concatenated.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="structsoap.html#a4565a0ad4ea08ada721155ded8e8036f" title="The IPv4 address in numeric form of the client as received on the server side by soap_accept (or the ...">soap::ip</a></code>, <code><a class="el" href="structsoap.html#a3d942a41712800a7d81b0e0fe3f10613" title="The IPv6 address in numeric form (upper ip6[0] to lower ip6[3]) of the client as received on the serv...">soap::ip6</a></code>, <code><a class="el" href="structsoap.html#ab8f356cfb0a1ba87c26cb0ae4c9ee713" title="The client host name or IP address as received on the server side. ">soap::host</a></code>, <code><a class="el" href="structsoap.html#acef722da5f6789721603beeb0b505838" title="The client port connected to as received on the server side by soap_accept (or the C++ service class ...">soap::port</a></code>, <code><a class="el" href="structsoap.html#a3c2bd2822146a8ccca20f8f217c2f309" title="The client request path as received on the server side. ">soap::path</a></code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a10b66d6d489690b7d0f591ae2633dd13"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soap::errnum</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <code>errno</code> value of the last failed IO operation. </p>
<p>The <code><a class="el" href="structsoap.html#a10b66d6d489690b7d0f591ae2633dd13" title="The errno value of the last failed IO operation. ">soap::errnum</a></code> value is set to the value or <code>errno</code> when a <code><a class="el" href="group__group__errors.html#ga224b2c2b830135f12b53536f189b4ebd" title="A soap_status error code: unexpected end of file, no input, transmission interrupted or timed out (sa...">SOAP_EOF</a></code> or <code><a class="el" href="group__group__errors.html#ga5087817634de39f79e74246b1eb4da54" title="A soap_status error code: a TCP/IP connection error occured. ">SOAP_TCP_ERROR</a></code> error occurred. This allows for reporting the error condition with <code><a class="el" href="group__group__fault.html#ga931a4ab6df2553b48a0c270f8a0a88af" title="Print error message on the specified output. ">soap_print_fault</a></code>, <code><a class="el" href="group__group__fault.html#gaab984763de3f5fdd4363aa62b4f250c2" title="Print error message on the specified output stream. ">soap_stream_fault</a></code>, and <code><a class="el" href="group__group__fault.html#gafc9d67060889f7243381299047f0e8e6" title="Print error message to the specified string buffer. ">soap_sprint_fault</a></code>. For the <code><a class="el" href="group__group__errors.html#ga224b2c2b830135f12b53536f189b4ebd" title="A soap_status error code: unexpected end of file, no input, transmission interrupted or timed out (sa...">SOAP_EOF</a></code> error, <code><a class="el" href="structsoap.html#a10b66d6d489690b7d0f591ae2633dd13" title="The errno value of the last failed IO operation. ">soap::errnum</a></code> is set to zero when IO operations timed out, when a client's connection attempt to a server timed out, or when a server-side <code><a class="el" href="group__group__io.html#gaec0e1aecc2d5479d8099762feb4713c6" title="Accept a connection with a client. ">soap_accept</a></code> timed out.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="structsoap.html#ab85f5d42702963d13ea540bd9876e6d2" title="The soap context soap_status (int) error code of the last operation or SOAP_OK (zero) ...">soap::error</a></code>, <code><a class="el" href="structsoap.html#af32b5f3975eac2bd1202571515859163" title="User-definable timeout when waiting to connect to a server at the client-side, positive timeout value...">soap::connect_timeout</a></code>, <code><a class="el" href="structsoap.html#a78199a81c504833047224a0ceff6f906" title="User-definable timeout when waiting to accept a request from a client at the server-side with soap_ac...">soap::accept_timeout</a></code>, <code><a class="el" href="structsoap.html#ac5d5fb92fffda724ccb3b038d2bb2388" title="User-definable timeout to receive a packet of data, positive timeout values are seconds, negative timeout values are microseconds, zero means no timeout (0 by default) ">soap::recv_timeout</a></code>, <code><a class="el" href="structsoap.html#a711bb3a53de7cc62429e4d3a2e0b5474" title="User-definable timeout to send a packet of data, positive timeout values are seconds, negative timeout values are microseconds, zero means no timeout (0 by default) ">soap::send_timeout</a></code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ab85f5d42702963d13ea540bd9876e6d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soap::error</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context <code><a class="el" href="group__group__errors.html#gac0eadf8f72bacb5b41b750beaeca0444" title="Status and error codes are int values, a zero value or SOAP_OK (0) means no error, nonzero means error. ">soap_status</a></code> (int) error code of the last operation or <code><a class="el" href="group__group__errors.html#ga3b10a68f354f39cbb0fe0d043ad4c7c0" title="The soap_status code for no error (zero) ">SOAP_OK</a></code> (zero) </p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__group__errors.html#gac0eadf8f72bacb5b41b750beaeca0444" title="Status and error codes are int values, a zero value or SOAP_OK (0) means no error, nonzero means error. ">soap_status</a></code>, <code><a class="el" href="structsoap.html#a10b66d6d489690b7d0f591ae2633dd13" title="The errno value of the last failed IO operation. ">soap::errnum</a></code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a920e2840ab2c816378059022dcfd96e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="struct_s_o_a_p___e_n_v_____fault.html">SOAP_ENV__Fault</a>* soap::fault</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <code><a class="el" href="structsoap.html#a920e2840ab2c816378059022dcfd96e0" title="The soap::fault points to a SOAP_ENV__Fault structure with the SOAP Fault that was received or that c...">soap::fault</a></code> points to a <code><a class="el" href="struct_s_o_a_p___e_n_v_____fault.html" title="SOAP Fault structure. ">SOAP_ENV__Fault</a></code> structure with the SOAP Fault that was received or that can be populated by the user to be sent, or NULL when no SOAP Fault is present. </p>

</div>
</div>
<a class="anchor" id="a7d7e87aec3cb136b6762a6ffb90a922a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* soap::float_format</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User-definable floating point format string (<code>%.9G</code> by default, the printed format should not exceed 1023 bytes) </p>
<dl class="section user"><dt>Example:</dt><dd></dd></dl>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;soapH.h&quot;</span></div><div class="line"><span class="keyword">struct </span>soap *soap = <a class="code" href="group__group__context.html#ga87c20488b2dc680aaa7689b1d024989c">soap_new</a>();</div><div class="line">soap-&gt;<a class="code" href="structsoap.html#a7d7e87aec3cb136b6762a6ffb90a922a">float_format</a> = <span class="stringliteral">&quot;%g&quot;</span>;</div><div class="line">soap-&gt;<a class="code" href="structsoap.html#ae1647309c9aec4b10cd9036cfabee86b">double_format</a> = <span class="stringliteral">&quot;%g&quot;</span>;</div><div class="line">soap-&gt;<a class="code" href="structsoap.html#adcbd52999b85cad509a9b4b479cb9f4d">long_double_format</a> = <span class="stringliteral">&quot;%Lg&quot;</span>;</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ac091dfe4e01b6a082d916c381e7006ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="struct_s_o_a_p___e_n_v_____header.html">SOAP_ENV__Header</a>* soap::header</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <code><a class="el" href="structsoap.html#ac091dfe4e01b6a082d916c381e7006ba" title="The soap::header points to a SOAP_ENV__Header structure with the SOAP Header that was received or tha...">soap::header</a></code> points to a <code><a class="el" href="struct_s_o_a_p___e_n_v_____header.html" title="SOAP Header structure. ">SOAP_ENV__Header</a></code> structure with the SOAP Header that was received or that can be populated by the user to be sent, or NULL when no SOAP Header is present. </p>
<dl class="section user"><dt>Example:</dt><dd></dd></dl>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;soapH.h&quot;</span></div><div class="line"><span class="keyword">struct </span>soap *soap = <a class="code" href="group__group__context.html#ga87c20488b2dc680aaa7689b1d024989c">soap_new</a>();</div><div class="line">... <span class="comment">// context initializations</span></div><div class="line"><span class="comment">// add a SOAP Header to the message</span></div><div class="line"><a class="code" href="struct_s_o_a_p___e_n_v_____header.html">SOAP_ENV__Header</a> <a class="code" href="structsoap.html#ac091dfe4e01b6a082d916c381e7006ba">header</a>;</div><div class="line">header-&gt;ns__someHeaderValue = 123;</div><div class="line"><span class="keywordflow">if</span> (soap_call_ns__webmethod(soap, <a class="code" href="structsoap.html#aed1b86b8a34aea86103751a932c9dce9">endpoint</a>, NULL, ...))</div><div class="line">{</div><div class="line">  <a class="code" href="group__group__fault.html#ga931a4ab6df2553b48a0c270f8a0a88af">soap_print_fault</a>(soap, stderr);</div><div class="line">}</div><div class="line"><span class="keywordflow">else</span></div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> (soap-&gt;<a class="code" href="structsoap.html#ac091dfe4e01b6a082d916c381e7006ba">header</a>) <span class="comment">// received a SOAP_ENV__Header?</span></div><div class="line">    ... <span class="comment">// yes, inspect SOAP_ENV__Header headers</span></div><div class="line">}</div><div class="line"><a class="code" href="group__group__context.html#gaf7d0176161e9def36981e24faa1913d9">soap_destroy</a>(soap);</div><div class="line"><a class="code" href="group__group__context.html#ga81a009ae1ea825a05e5241e2b7a8ece9">soap_end</a>(soap);</div><div class="line"><a class="code" href="group__group__context.html#ga57108ca4681186e58b5b189c3528f10a">soap_free</a>(soap);</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><code><a class="el" href="struct_s_o_a_p___e_n_v_____header.html" title="SOAP Header structure. ">SOAP_ENV__Header</a></code>, <code><a class="el" href="structsoap.html#abda4ccd0d64f76eb57145cc4890c87b2" title="User-definable SOAP-ENV:actor (SOAP 1.1) or SOAP-ENV:role (SOAP 1.2) attribute value of all SOAP-ENV:...">soap::actor</a></code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ab8f356cfb0a1ba87c26cb0ae4c9ee713"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char soap::host[<a class="el" href="group__group__soap.html#ga69f1ba9e1b47201e54822f365087f5a5">SOAP_TAGLEN</a>]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The client host name or IP address as received on the server side. </p>
<p>The URL host string is extracted from the HTTP header by <code><a class="el" href="group__group__callbacks.html#ga9cb05ce98f845f16c920c44426ac35a5" title="Callback that reads and parses HTTP and MIME headers. ">soap::fparse</a></code> called by <code><a class="el" href="group__group__io.html#gaf4ce538944f65ac97d82bfeaa9345c42" title="Initialize the context for receiving. ">soap_begin_recv</a></code>.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="structsoap.html#a4565a0ad4ea08ada721155ded8e8036f" title="The IPv4 address in numeric form of the client as received on the server side by soap_accept (or the ...">soap::ip</a></code>, <code><a class="el" href="structsoap.html#a3d942a41712800a7d81b0e0fe3f10613" title="The IPv6 address in numeric form (upper ip6[0] to lower ip6[3]) of the client as received on the serv...">soap::ip6</a></code>, <code><a class="el" href="structsoap.html#aed1b86b8a34aea86103751a932c9dce9" title="The endpoint string as received on the server side. ">soap::endpoint</a></code>, <code><a class="el" href="structsoap.html#acef722da5f6789721603beeb0b505838" title="The client port connected to as received on the server side by soap_accept (or the C++ service class ...">soap::port</a></code>, <code><a class="el" href="structsoap.html#a3c2bd2822146a8ccca20f8f217c2f309" title="The client request path as received on the server side. ">soap::path</a></code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ae5e98733a4349b5e1466a9e0ccc22c11"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* soap::http_content</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>String with HTTP content type header value received, can also be assigned to specify a content type header when using <code><a class="el" href="group__group__io.html#ga315b6e1d5888780bf4ef320c50f23796" title="Connect to a server. ">soap_connect_command</a></code> with <code><a class="el" href="group__group__io.html#ga4c291263eadcefa290e90c64e632ae47" title="HTTP POST command code with custom content type. ">SOAP_POST_FILE</a></code>, <code><a class="el" href="group__group__io.html#ga32a114ef8df190363b9c3ad37bcb6335" title="HTTP PUT command code with custom content type. ">SOAP_PUT</a></code> and <code><a class="el" href="group__group__io.html#ga0f6661cfe8eff845600e7a75a2f46701" title="HTTP PATCH command code with custom content type. ">SOAP_PATCH</a></code> or when using <code><a class="el" href="group__group__io.html#ga0390e58bd2a3ebe6fe3a46de0534a614" title="Initialize the context for server-side sending and send a HTTP response header. ">soap_response</a></code> with <code><a class="el" href="group__group__io.html#ga05be99343f556fe70940145e874cdb99" title="A special soap_status error code to signal that a custom file-based HTTP response is present and no H...">SOAP_FILE</a></code>. </p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__group__io.html#ga315b6e1d5888780bf4ef320c50f23796" title="Connect to a server. ">soap_connect_command</a></code>, <code><a class="el" href="group__group__io.html#gae93e23c11379e71baeb6fafe68e14709" title="HTTP PUT content to server. ">soap_PUT</a></code>, <code><a class="el" href="group__group__io.html#ga71eebf1ab266c7480831a2fb10b6ca1a" title="HTTP PATCH content to server. ">soap_PATCH</a></code>, <code><a class="el" href="group__group__io.html#gaf502246613cb6d4ea120965065d8c0b2" title="HTTP POST content to server. ">soap_POST</a></code>, <code><a class="el" href="group__group__io.html#ga0390e58bd2a3ebe6fe3a46de0534a614" title="Initialize the context for server-side sending and send a HTTP response header. ">soap_response</a></code>. </dd></dl>

</div>
</div>
<a class="anchor" id="afb22ae0a494a35268914286bd00446ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* soap::http_extra_header</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User-definable string that specifies an extra HTTP header or headers when separated by CRLF, to include in the next HTTP request (client side) or to include with the HTTP response (server side) </p>
<dl class="section user"><dt>Examples:</dt><dd></dd></dl>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;soapH.h&quot;</span></div><div class="line"><span class="keyword">struct </span>soap *soap = <a class="code" href="group__group__context.html#ga87c20488b2dc680aaa7689b1d024989c">soap_new</a>();</div><div class="line">... <span class="comment">// context initializations</span></div><div class="line">soap-&gt;<a class="code" href="structsoap.html#afb22ae0a494a35268914286bd00446ab">http_extra_header</a> = <span class="stringliteral">&quot;X-CUSTOM-RequestMessageNumber: 1\r\nX-CUSTOM-TotalRequests: 5&quot;</span>;</div><div class="line"><span class="keywordflow">if</span> (soap_call_ns__webmethod(soap, <a class="code" href="structsoap.html#aed1b86b8a34aea86103751a932c9dce9">endpoint</a>, NULL, ...))</div><div class="line">  <a class="code" href="group__group__fault.html#ga931a4ab6df2553b48a0c270f8a0a88af">soap_print_fault</a>(soap, stderr);</div><div class="line"><span class="keywordflow">else</span></div><div class="line">  ... <span class="comment">// success</span></div><div class="line"><a class="code" href="group__group__context.html#gaf7d0176161e9def36981e24faa1913d9">soap_destroy</a>(soap);</div><div class="line"><a class="code" href="group__group__context.html#ga81a009ae1ea825a05e5241e2b7a8ece9">soap_end</a>(soap);</div><div class="line"><a class="code" href="group__group__context.html#ga57108ca4681186e58b5b189c3528f10a">soap_free</a>(soap);</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;soapH.h&quot;</span></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keyword">struct </span>soap *soap = <a class="code" href="group__group__context.html#ga87c20488b2dc680aaa7689b1d024989c">soap_new</a>();</div><div class="line">  <span class="keywordflow">if</span> (<a class="code" href="group__group__ssl.html#ga3492465cdd8aa71fe746199d3842cac7">soap_ssl_server_context</a>(soap, ...))</div><div class="line">    exit(EXIT_FAILURE);</div><div class="line">  ... <span class="comment">// serve requests with soap_bind, soap_accept, soap_ssl_accept, and soap_serve</span></div><div class="line">}</div><div class="line"><span class="keywordtype">int</span> ns__webmethod(<span class="keyword">struct</span> soap *soap, ...)</div><div class="line">{</div><div class="line">  ... <span class="comment">// process the request data and populate the response data</span></div><div class="line">  soap-&gt;<a class="code" href="structsoap.html#afb22ae0a494a35268914286bd00446ab">http_extra_header</a> = <span class="stringliteral">&quot;X-CUSTOM-ResponseMessageNumber: 1&quot;</span>;</div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="group__group__errors.html#ga3b10a68f354f39cbb0fe0d043ad4c7c0">SOAP_OK</a>;</div><div class="line">}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__group__io.html#ga953bdee7ebf242b056834e5592079ae9" title="HTTP GET content from server. ">soap_GET</a></code>, <code><a class="el" href="group__group__io.html#gae93e23c11379e71baeb6fafe68e14709" title="HTTP PUT content to server. ">soap_PUT</a></code>, <code><a class="el" href="group__group__io.html#ga71eebf1ab266c7480831a2fb10b6ca1a" title="HTTP PATCH content to server. ">soap_PATCH</a></code>, <code><a class="el" href="group__group__io.html#gaf502246613cb6d4ea120965065d8c0b2" title="HTTP POST content to server. ">soap_POST</a></code>, <code><a class="el" href="group__group__io.html#ga98e63f6969d2d83a31f178728a01c7cc" title="HTTP DELETE content from server. ">soap_DELETE</a></code>, <code><a class="el" href="group__group__callbacks.html#ga70b75026b5fb1a9a2d5779f72454f082" title="Callback that consumes an HTTP header that consists of a key-value pair. ">soap::fparsehdr</a></code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a4c24dec1ac79111c4ebeb30ba73cca65"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__flags.html#ga72b0491c9cbf2071f0c96c7d29b719bb">soap_mode</a> soap::imode</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context input <code><a class="el" href="group__group__flags.html#ga72b0491c9cbf2071f0c96c7d29b719bb" title="The soap_mode flags to initialize the soap context, flags can be combined with | (bit-wise or) ...">soap_mode</a></code> flags that are set at context initialization and set or cleared with <code><a class="el" href="group__group__context.html#gaa9b0819dae844b848bcd8a3598a301aa" title="Set input soap_mode flags of the given soap context. ">soap_set_imode</a></code> or <code><a class="el" href="group__group__context.html#ga0e789bd6c2f76609aec0c9f93d121e4c" title="Clear input soap_mode flags of the given soap context. ">soap_clr_imode</a></code>, respectively. </p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="structsoap.html#a0f7cfb4dd32a7be1ec63a20f55e12521" title="The soap context output soap_mode flags that are set at context initialization and set or cleared wit...">soap::omode</a></code>, <code><a class="el" href="group__group__context.html#gaf6fa6e197f360834eae124fa37e68cf7" title="Set output soap_mode flags of the given soap context. ">soap_set_omode</a></code>, <code><a class="el" href="group__group__context.html#ga84f52a67a41009b260ff2c036df7f6ab" title="Set input and output soap_mode flags of the given soap context. ">soap_set_mode</a></code>, <code><a class="el" href="group__group__context.html#ga8c28d2943bee7aa5c3ffaf32803b31bd" title="Clear output soap_mode flags of the given soap context. ">soap_clr_omode</a></code>, <code><a class="el" href="group__group__context.html#ga06f769f80bcea7beb2ebffd0a40fc521" title="Clear input and output soap_mode flags of the given soap context. ">soap_clr_mode</a></code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a4565a0ad4ea08ada721155ded8e8036f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int soap::ip</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The IPv4 address in numeric form of the client as received on the server side by <code><a class="el" href="group__group__io.html#gaec0e1aecc2d5479d8099762feb4713c6" title="Accept a connection with a client. ">soap_accept</a></code> (or the C++ service class <code>accept</code> method), possibly set to zero when <code><a class="el" href="group__group__with.html#ga40cbd680e7dbdeb63bce1d6d4b7b9620" title="When this macro is defined at compile time (undefined by default), IPv6 support is enabled and both I...">WITH_IPV6</a></code> is used. </p>
<dl class="section user"><dt>Example:</dt><dd></dd></dl>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;soapH.h&quot;</span></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keyword">struct </span>soap *soap = <a class="code" href="group__group__context.html#ga87c20488b2dc680aaa7689b1d024989c">soap_new</a>();</div><div class="line">  soap-&gt;<a class="code" href="structsoap.html#a78199a81c504833047224a0ceff6f906">accept_timeout</a> = 3600;                <span class="comment">// exit loop when no request arrives in one hour</span></div><div class="line">  ... <span class="comment">// context initializations</span></div><div class="line">  <span class="keywordflow">if</span> (<a class="code" href="group__group__soap.html#gaaae8747f4cdacee575875c3a2488d99c">soap_valid_socket</a>(<a class="code" href="group__group__io.html#ga0a9725a3edbc27b97456190fee47cc18">soap_bind</a>(soap, NULL, PORTNUM, BACKLOG)))</div><div class="line">  {</div><div class="line">    <span class="keywordflow">while</span> (1)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">if</span> (<a class="code" href="group__group__soap.html#gaaae8747f4cdacee575875c3a2488d99c">soap_valid_socket</a>(<a class="code" href="group__group__io.html#gaec0e1aecc2d5479d8099762feb4713c6">soap_accept</a>(soap)))</div><div class="line">      {</div><div class="line">        printf(<span class="stringliteral">&quot;Client host = %s port = %d path = %s ip = %d.%d.%d.%d\n&quot;</span>, soap-&gt;<a class="code" href="structsoap.html#ab8f356cfb0a1ba87c26cb0ae4c9ee713">host</a>, soap-&gt;<a class="code" href="structsoap.html#acef722da5f6789721603beeb0b505838">port</a>, soap-&gt;<a class="code" href="structsoap.html#a3c2bd2822146a8ccca20f8f217c2f309">path</a>, soap-&gt;<a class="code" href="structsoap.html#a4565a0ad4ea08ada721155ded8e8036f">ip</a> &gt;&gt; 24, (soap-&gt;<a class="code" href="structsoap.html#a4565a0ad4ea08ada721155ded8e8036f">ip</a> &gt;&gt; 16) &amp; 0xFF, (soap-&gt;<a class="code" href="structsoap.html#a4565a0ad4ea08ada721155ded8e8036f">ip</a> &gt;&gt; 8) &amp; 0xFF, soap-&gt;<a class="code" href="structsoap.html#a4565a0ad4ea08ada721155ded8e8036f">ip</a> &amp; 0xFF);</div><div class="line">        <span class="keywordflow">if</span> (<a class="code" href="group__group__io.html#ga51dba7706a505240bd8935c0b28e419d">soap_serve</a>(soap))</div><div class="line">          <a class="code" href="group__group__fault.html#ga931a4ab6df2553b48a0c270f8a0a88af">soap_print_fault</a>(soap, stderr);</div><div class="line">      }</div><div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (soap-&gt;<a class="code" href="structsoap.html#a10b66d6d489690b7d0f591ae2633dd13">errnum</a>) <span class="comment">// accept failed, try again after 1 second</span></div><div class="line">      {</div><div class="line">        <a class="code" href="group__group__fault.html#ga931a4ab6df2553b48a0c270f8a0a88af">soap_print_fault</a>(soap, stderr);</div><div class="line">        sleep(1);</div><div class="line">      }</div><div class="line">      <span class="keywordflow">else</span> <span class="comment">// accept timed out, quit looping</span></div><div class="line">      {</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">      }</div><div class="line">      <a class="code" href="group__group__context.html#gaf7d0176161e9def36981e24faa1913d9">soap_destroy</a>(soap);</div><div class="line">      <a class="code" href="group__group__context.html#ga81a009ae1ea825a05e5241e2b7a8ece9">soap_end</a>(soap);</div><div class="line">    }</div><div class="line">  }</div><div class="line">  <a class="code" href="group__group__context.html#ga57108ca4681186e58b5b189c3528f10a">soap_free</a>(soap);</div><div class="line">}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><code><a class="el" href="structsoap.html#a3d942a41712800a7d81b0e0fe3f10613" title="The IPv6 address in numeric form (upper ip6[0] to lower ip6[3]) of the client as received on the serv...">soap::ip6</a></code>, <code><a class="el" href="group__group__io.html#ga0a9725a3edbc27b97456190fee47cc18" title="Bind and listen to a port. ">soap_bind</a></code>, <code><a class="el" href="group__group__io.html#gaec0e1aecc2d5479d8099762feb4713c6" title="Accept a connection with a client. ">soap_accept</a></code>, <code><a class="el" href="group__group__ssl.html#ga990083effa5d8ed931fd75dc2630a2cc" title="Accept SSL/TLS connection. ">soap_ssl_accept</a></code>, <code><a class="el" href="group__group__io.html#ga51dba7706a505240bd8935c0b28e419d" title="Serve a pending request. ">soap_serve</a></code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a3d942a41712800a7d81b0e0fe3f10613"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int soap::ip6[4]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The IPv6 address in numeric form (upper ip6[0] to lower ip6[3]) of the client as received on the server side by <code><a class="el" href="group__group__io.html#gaec0e1aecc2d5479d8099762feb4713c6" title="Accept a connection with a client. ">soap_accept</a></code> (or the C++ service class <code>accept</code> method), requires <code><a class="el" href="group__group__with.html#ga40cbd680e7dbdeb63bce1d6d4b7b9620" title="When this macro is defined at compile time (undefined by default), IPv6 support is enabled and both I...">WITH_IPV6</a></code> </p>
<dl class="section user"><dt>Example:</dt><dd></dd></dl>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;soapH.h&quot;</span></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keyword">struct </span>soap *soap = <a class="code" href="group__group__context.html#ga87c20488b2dc680aaa7689b1d024989c">soap_new</a>();</div><div class="line">  soap-&gt;<a class="code" href="structsoap.html#a78199a81c504833047224a0ceff6f906">accept_timeout</a> = 3600;                <span class="comment">// exit loop when no request arrives in one hour</span></div><div class="line">  ... <span class="comment">// context initializations</span></div><div class="line">  <span class="keywordflow">if</span> (<a class="code" href="group__group__soap.html#gaaae8747f4cdacee575875c3a2488d99c">soap_valid_socket</a>(<a class="code" href="group__group__io.html#ga0a9725a3edbc27b97456190fee47cc18">soap_bind</a>(soap, NULL, PORTNUM, BACKLOG)))</div><div class="line">  {</div><div class="line">    <span class="keywordflow">while</span> (1)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">if</span> (<a class="code" href="group__group__soap.html#gaaae8747f4cdacee575875c3a2488d99c">soap_valid_socket</a>(<a class="code" href="group__group__io.html#gaec0e1aecc2d5479d8099762feb4713c6">soap_accept</a>(soap)))</div><div class="line">      {</div><div class="line">        printf(<span class="stringliteral">&quot;Client host = %s port = %d path = %s &quot;</span>, soap-&gt;<a class="code" href="structsoap.html#ab8f356cfb0a1ba87c26cb0ae4c9ee713">host</a>, soap-&gt;<a class="code" href="structsoap.html#acef722da5f6789721603beeb0b505838">port</a>, soap-&gt;<a class="code" href="structsoap.html#a3c2bd2822146a8ccca20f8f217c2f309">path</a>);</div><div class="line">        <span class="keywordflow">if</span> (soap-&gt;<a class="code" href="structsoap.html#a4565a0ad4ea08ada721155ded8e8036f">ip</a>)</div><div class="line">          printf(<span class="stringliteral">&quot;ip4 = %d.%d.%d.%d\n&quot;</span>, soap-&gt;<a class="code" href="structsoap.html#a4565a0ad4ea08ada721155ded8e8036f">ip</a> &gt;&gt; 24, (soap-&gt;<a class="code" href="structsoap.html#a4565a0ad4ea08ada721155ded8e8036f">ip</a> &gt;&gt; 16) &amp; 0xFF, (soap-&gt;<a class="code" href="structsoap.html#a4565a0ad4ea08ada721155ded8e8036f">ip</a> &gt;&gt; 8) &amp; 0xFF, soap-&gt;<a class="code" href="structsoap.html#a4565a0ad4ea08ada721155ded8e8036f">ip</a> &amp; 0xFF);</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          printf(<span class="stringliteral">&quot;ip6 = %.8x%.8x%.8x%.8x\n&quot;</span>, soap-&gt;<a class="code" href="structsoap.html#a3d942a41712800a7d81b0e0fe3f10613">ip6</a>[0], soap-&gt;<a class="code" href="structsoap.html#a3d942a41712800a7d81b0e0fe3f10613">ip6</a>[1], soap-&gt;<a class="code" href="structsoap.html#a3d942a41712800a7d81b0e0fe3f10613">ip6</a>[2], soap-&gt;<a class="code" href="structsoap.html#a3d942a41712800a7d81b0e0fe3f10613">ip6</a>[3]);</div><div class="line">        <span class="keywordflow">if</span> (<a class="code" href="group__group__io.html#ga51dba7706a505240bd8935c0b28e419d">soap_serve</a>(soap))</div><div class="line">          <a class="code" href="group__group__fault.html#ga931a4ab6df2553b48a0c270f8a0a88af">soap_print_fault</a>(soap, stderr);</div><div class="line">      }</div><div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (soap-&gt;<a class="code" href="structsoap.html#a10b66d6d489690b7d0f591ae2633dd13">errnum</a>) <span class="comment">// accept failed, try again after 1 second</span></div><div class="line">      {</div><div class="line">        <a class="code" href="group__group__fault.html#ga931a4ab6df2553b48a0c270f8a0a88af">soap_print_fault</a>(soap, stderr);</div><div class="line">        sleep(1);</div><div class="line">      }</div><div class="line">      <span class="keywordflow">else</span> <span class="comment">// accept timed out, quit looping</span></div><div class="line">      {</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">      }</div><div class="line">      <a class="code" href="group__group__context.html#gaf7d0176161e9def36981e24faa1913d9">soap_destroy</a>(soap);</div><div class="line">      <a class="code" href="group__group__context.html#ga81a009ae1ea825a05e5241e2b7a8ece9">soap_end</a>(soap);</div><div class="line">    }</div><div class="line">  }</div><div class="line">  <a class="code" href="group__group__context.html#ga57108ca4681186e58b5b189c3528f10a">soap_free</a>(soap);</div><div class="line">}</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Requires compilation with <code><a class="el" href="group__group__with.html#ga40cbd680e7dbdeb63bce1d6d4b7b9620" title="When this macro is defined at compile time (undefined by default), IPv6 support is enabled and both I...">WITH_IPV6</a></code> or <code><a class="el" href="group__group__with.html#ga2854fe8474c2f87a9916d892306cb94c" title="When this macro is defined at compile time (undefined by default), IPv6-only is enabled for port bind...">WITH_IPV6_V6ONLY</a></code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="structsoap.html#ab8f356cfb0a1ba87c26cb0ae4c9ee713" title="The client host name or IP address as received on the server side. ">soap::host</a></code>, <code><a class="el" href="structsoap.html#acef722da5f6789721603beeb0b505838" title="The client port connected to as received on the server side by soap_accept (or the C++ service class ...">soap::port</a></code>, <code><a class="el" href="structsoap.html#a3d942a41712800a7d81b0e0fe3f10613" title="The IPv6 address in numeric form (upper ip6[0] to lower ip6[3]) of the client as received on the serv...">soap::ip6</a></code>, <code><a class="el" href="group__group__io.html#ga0a9725a3edbc27b97456190fee47cc18" title="Bind and listen to a port. ">soap_bind</a></code>, <code><a class="el" href="group__group__io.html#gaec0e1aecc2d5479d8099762feb4713c6" title="Accept a connection with a client. ">soap_accept</a></code>, <code><a class="el" href="group__group__ssl.html#ga990083effa5d8ed931fd75dc2630a2cc" title="Accept SSL/TLS connection. ">soap_ssl_accept</a></code>, <code><a class="el" href="group__group__io.html#ga51dba7706a505240bd8935c0b28e419d" title="Serve a pending request. ">soap_serve</a></code>. </dd></dl>

</div>
</div>
<a class="anchor" id="accb43a5716005b473fa1d5688967a3b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* soap::ipv4_multicast_if</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User-definable value to set <code>setsockopt</code> level <code>IPPROTO_IP</code> to <code>IP_MULTICAST_IF</code> when non-NULL. </p>
<p>This value is used by the engine for UDP multicast messaging at the client side, sets <code>setsockopt</code> level <code>IPPROTO_IP</code> to <code>IP_MULTICAST_IF</code> with value <code><a class="el" href="structsoap.html#accb43a5716005b473fa1d5688967a3b3" title="User-definable value to set setsockopt level IPPROTO_IP to IP_MULTICAST_IF when non-NULL. ">soap::ipv4_multicast_if</a></code> when non-NULL.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__group__flags.html#ga388dae9abc80cd6f6d0ecfba383da03b" title="soap_mode IO input/output flag value to use UDP datagrams, message size is limited to UDP packet size...">SOAP_IO_UDP</a></code>, <code><a class="el" href="structsoap.html#a3db0542e8eb7db6a2f2cbc16fb24082b" title="User-definable value to set sockaddr_in6::sin6_scope_id when nonzero. ">soap::ipv6_multicast_if</a></code>, <code><a class="el" href="structsoap.html#aa5faa7630425a8ab8018f0b2d4d0c18d" title="User-definable value to set setsockopt level IPPROTO_IP to IP_MULTICAST_TTL when nonzero. ">soap::ipv4_multicast_ttl</a></code>. </dd></dl>

</div>
</div>
<a class="anchor" id="aa5faa7630425a8ab8018f0b2d4d0c18d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char soap::ipv4_multicast_ttl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User-definable value to set <code>setsockopt</code> level <code>IPPROTO_IP</code> to <code>IP_MULTICAST_TTL</code> when nonzero. </p>
<p>This value is used by the engine for UDP multicast messaging at the client side, sets <code>setsockopt</code> level <code>IPPROTO_IP</code> to <code>IP_MULTICAST_TTL</code> with value <code><a class="el" href="structsoap.html#aa5faa7630425a8ab8018f0b2d4d0c18d" title="User-definable value to set setsockopt level IPPROTO_IP to IP_MULTICAST_TTL when nonzero. ">soap::ipv4_multicast_ttl</a></code> when nonzero.</p>
<dl class="section user"><dt>Example:</dt><dd></dd></dl>
<div class="fragment"><div class="line"><span class="keyword">struct </span>soap *soap = <a class="code" href="group__group__context.html#ga87c20488b2dc680aaa7689b1d024989c">soap_new</a>(); </div><div class="line">in_addr_t addr = inet_addr(<span class="stringliteral">&quot;1.2.3.4&quot;</span>); <span class="comment">// optional </span></div><div class="line">soap-&gt;<a class="code" href="structsoap.html#a711bb3a53de7cc62429e4d3a2e0b5474">send_timeout</a> = 5;                <span class="comment">// 5 seconds max socket delay</span></div><div class="line">soap-&gt;<a class="code" href="structsoap.html#a52a22fafc369b3a54fb0d16f53158794">connect_flags</a> = SO_BROADCAST;    <span class="comment">// required for broadcast </span></div><div class="line">soap-&gt;<a class="code" href="structsoap.html#accb43a5716005b473fa1d5688967a3b3">ipv4_multicast_if</a> = &amp;addr;       <span class="comment">// optional for IPv4, see setsockopt IPPROTO_IP IP_MULTICAST_IF </span></div><div class="line">soap-&gt;<a class="code" href="structsoap.html#a3db0542e8eb7db6a2f2cbc16fb24082b">ipv6_multicast_if</a> = addr;        <span class="comment">// optional for IPv6, multicast sin6_scope_id </span></div><div class="line">soap-&gt;<a class="code" href="structsoap.html#aa5faa7630425a8ab8018f0b2d4d0c18d">ipv4_multicast_ttl</a> = 1;          <span class="comment">// optional, see setsockopt IPPROTO_IP, IP_MULTICAST_TTL </span></div></div><!-- fragment --><p>Refer to the socket options for <code>IPPROTO_IP</code> <code>IP_MULTICAST_TTL</code> to limit the lifetime of the packet. Multicast datagrams are sent with a default value of 1, to prevent them to be forwarded beyond the local network. This parameter can be set between 1 to 255.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__group__flags.html#ga388dae9abc80cd6f6d0ecfba383da03b" title="soap_mode IO input/output flag value to use UDP datagrams, message size is limited to UDP packet size...">SOAP_IO_UDP</a></code>, <code><a class="el" href="structsoap.html#a3db0542e8eb7db6a2f2cbc16fb24082b" title="User-definable value to set sockaddr_in6::sin6_scope_id when nonzero. ">soap::ipv6_multicast_if</a></code>, <code><a class="el" href="structsoap.html#accb43a5716005b473fa1d5688967a3b3" title="User-definable value to set setsockopt level IPPROTO_IP to IP_MULTICAST_IF when non-NULL. ">soap::ipv4_multicast_if</a></code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a3db0542e8eb7db6a2f2cbc16fb24082b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int soap::ipv6_multicast_if</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User-definable value to set <code>sockaddr_in6::sin6_scope_id</code> when nonzero. </p>
<p>This value is used by the engine for UDP multicast messaging at the client side, sets <code>sockaddr_in6::sin6_scope_id</code> to <code><a class="el" href="structsoap.html#a3db0542e8eb7db6a2f2cbc16fb24082b" title="User-definable value to set sockaddr_in6::sin6_scope_id when nonzero. ">soap::ipv6_multicast_if</a></code> when nonzero.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__group__flags.html#ga388dae9abc80cd6f6d0ecfba383da03b" title="soap_mode IO input/output flag value to use UDP datagrams, message size is limited to UDP packet size...">SOAP_IO_UDP</a></code>, <code><a class="el" href="structsoap.html#accb43a5716005b473fa1d5688967a3b3" title="User-definable value to set setsockopt level IPPROTO_IP to IP_MULTICAST_IF when non-NULL. ">soap::ipv4_multicast_if</a></code>, <code><a class="el" href="structsoap.html#aa5faa7630425a8ab8018f0b2d4d0c18d" title="User-definable value to set setsockopt level IPPROTO_IP to IP_MULTICAST_TTL when nonzero. ">soap::ipv4_multicast_ttl</a></code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a285e8a3584ffb1cea07a700c951e436d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SOAP_SOURCE* soap::is</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The source to read data from when non-NULL, which in C++ is a <code>std::istream</code> object and in C is a 0-terminated string to be read, default value is NULL. </p>
<dl class="section user"><dt>Examples:</dt><dd></dd></dl>
<div class="fragment"><div class="line"><span class="comment">// C example</span></div><div class="line"><span class="preprocessor">#include &quot;soapH.h&quot;</span></div><div class="line"><span class="keyword">struct </span>soap *soap = <a class="code" href="group__group__context.html#ga51cde138234ed7ec8c4e25bdf6418658">soap_new1</a>(<a class="code" href="group__group__flags.html#ga08a6a913484a5c771bfca7b7b5b9cfc8">SOAP_DOM_TREE</a>);</div><div class="line"><span class="keyword">struct </span>ns__someElement data;</div><div class="line">soap-&gt;<a class="code" href="structsoap.html#a285e8a3584ffb1cea07a700c951e436d">is</a> = <span class="stringliteral">&quot;&lt;ns:someElement xmlns:ns=&quot;</span>urn:example<span class="stringliteral">&quot;&gt;&lt;text&gt;example&lt;/text&gt;&lt;/ns:someElement&gt;\n&quot;</span>;</div><div class="line"><span class="comment">// parse and deserialize XML into a ns__someElement structure</span></div><div class="line"><span class="keywordflow">if</span> (soap_read_ns__someElement(soap, &amp;data))</div><div class="line">  ... <span class="comment">// an error occurred</span></div><div class="line">soap-&gt;<a class="code" href="structsoap.html#a285e8a3584ffb1cea07a700c951e436d">is</a> = NULL;</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">// C++ example</span></div><div class="line"><span class="preprocessor">#include &quot;soapH.h&quot;</span></div><div class="line"><span class="keyword">struct </span>soap *soap = <a class="code" href="group__group__context.html#ga51cde138234ed7ec8c4e25bdf6418658">soap_new1</a>(<a class="code" href="group__group__flags.html#ga08a6a913484a5c771bfca7b7b5b9cfc8">SOAP_DOM_TREE</a>);</div><div class="line"><span class="keyword">struct </span>ns__someElement data;</div><div class="line">std::stringstream ss(<span class="stringliteral">&quot;&lt;ns:someElement xmlns:ns=&quot;</span>urn:example<span class="stringliteral">&quot;&gt;&lt;text&gt;example&lt;/text&gt;&lt;/ns:someElement&gt;\n&quot;</span>);</div><div class="line">soap-&gt;<a class="code" href="structsoap.html#a285e8a3584ffb1cea07a700c951e436d">is</a> = &amp;ss;</div><div class="line"><span class="comment">// parse and deserialize XML into a ns__someElement structure</span></div><div class="line"><span class="keywordflow">if</span> (soap_read_ns__someElement(soap, &amp;data))</div><div class="line">  ... <span class="comment">// an error occurred</span></div><div class="line">soap-&gt;<a class="code" href="structsoap.html#a285e8a3584ffb1cea07a700c951e436d">is</a> = NULL;</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a3d93ba968bb58373f5884177a7ec0d83"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soap::keep_alive</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>HTTP keep-alive flag (try to enable when -1, disabled when 0) and counter (enabled when &gt;0) </p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__group__flags.html#ga0a4635737732c912058ff4dba668c1b2" title="soap_mode IO output flag value to keep the socket connection alive for SOAP_MAXKEEPALIVE message exch...">SOAP_IO_KEEPALIVE</a></code>, <code><a class="el" href="group__group__io.html#ga51dba7706a505240bd8935c0b28e419d" title="Serve a pending request. ">soap_serve</a></code>, <code><a class="el" href="group__group__io.html#ga06d59094afa3df6b1b9f6b2bb484207c" title="Close the socket connection. ">soap_closesock</a></code>, <code><a class="el" href="structsoap.html#a1d7aca6ac1d62302102c17508a8b0ec0" title="User-definable maximum number of keep-alive message exchanges per connection (SOAP_MAXKEEPALIVE by de...">soap::max_keep_alive</a></code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a632c5b76ad5a032fd5b0f36f29ce5dcc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* soap::lang</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User-definable <em><code>xml:lang</code></em> attribute value of <em><code>SOAP-ENV:Text</code></em> to output the SOAP Fault string/reason (<code>en</code> by default) </p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="struct_s_o_a_p___e_n_v_____reason.html" title="SOAP Fault Reason structure generated by soapcpp2. ">SOAP_ENV__Reason</a></code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a791a5b372f65291dd53e6afbbc9fbaa5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__soap.html#ga7c6e38d209f60a18e362172dca1a3b6e">ULONG64</a> soap::length</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The HTTP content length header value received or 0 when HTTP transfer encoding is chunked. </p>

</div>
</div>
<a class="anchor" id="a0f4d025053fde77216a0ca674077198d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned short soap::linger_time</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User-definable linger time value, requires the <code>SO_LINGER</code> <code>setsockopt</code> flag value to be assigned to <code><a class="el" href="structsoap.html#aae3eee771d8c4031d30d4ca7633edf9f" title="User-definable socket send and recv flags, for example assign MSG_NOSIGNAL to disable sigpipe (0 by d...">soap::socket_flags</a></code> </p>
<dl class="section user"><dt>Example:</dt><dd></dd></dl>
<div class="fragment"><div class="line"><span class="keyword">struct </span>soap *soap = <a class="code" href="group__group__context.html#ga87c20488b2dc680aaa7689b1d024989c">soap_new</a>();</div><div class="line">soap-&gt;<a class="code" href="structsoap.html#a52a22fafc369b3a54fb0d16f53158794">connect_flags</a> = SO_LINGER;</div><div class="line">soap-&gt;<a class="code" href="structsoap.html#a0f4d025053fde77216a0ca674077198d">linger_time</a> = 5;</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="adcbd52999b85cad509a9b4b479cb9f4d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* soap::long_double_format</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User-definable long double floating point format string (NULL by default and defined by the long_double.c custom serializer, the printed format should not exceed 1023 bytes) </p>
<dl class="section user"><dt>Example:</dt><dd></dd></dl>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;soapH.h&quot;</span></div><div class="line"><span class="keyword">struct </span>soap *soap = <a class="code" href="group__group__context.html#ga87c20488b2dc680aaa7689b1d024989c">soap_new</a>();</div><div class="line">soap-&gt;<a class="code" href="structsoap.html#a7d7e87aec3cb136b6762a6ffb90a922a">float_format</a> = <span class="stringliteral">&quot;%g&quot;</span>;</div><div class="line">soap-&gt;<a class="code" href="structsoap.html#ae1647309c9aec4b10cd9036cfabee86b">double_format</a> = <span class="stringliteral">&quot;%g&quot;</span>;</div><div class="line">soap-&gt;<a class="code" href="structsoap.html#adcbd52999b85cad509a9b4b479cb9f4d">long_double_format</a> = <span class="stringliteral">&quot;%Lg&quot;</span>;</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Requires <code>#import "custom/long_double.h" in the .h file for soapcpp2 to generate code that supports</code>long double<code>and compiling &lt;i&gt;</code>gsoap/custom/long_double.c<code>&lt;/i&gt; to serialize</code>long double`. </dd></dl>

</div>
</div>
<a class="anchor" id="ab649b8f3b71081d14ec6350ab4b06794"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__soap.html#ga6eb1bde7cecc2fbadbcbbc6395227439">SOAP_SOCKET</a> soap::master</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The socket set by <code><a class="el" href="group__group__io.html#ga0a9725a3edbc27b97456190fee47cc18" title="Bind and listen to a port. ">soap_bind</a></code> (or the C++ service class <code>bind</code> method) to serve as the master socket bound to a specified port, or <code><a class="el" href="group__group__soap.html#gab9e77b1557780293eec0b269ef191472" title="Macro that defines a portable invalid socket value (usually -1, but the value depends on the OS) ...">SOAP_INVALID_SOCKET</a></code> when unassigned. </p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__group__io.html#ga0a9725a3edbc27b97456190fee47cc18" title="Bind and listen to a port. ">soap_bind</a></code>, <code><a class="el" href="group__group__soap.html#gaaae8747f4cdacee575875c3a2488d99c" title="Function macro to check if a socket is valid, i.e. not equal to SOAP_INVALID_SOCKET ...">soap_valid_socket</a></code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a1d7aca6ac1d62302102c17508a8b0ec0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soap::max_keep_alive</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User-definable maximum number of keep-alive message exchanges per connection (<code><a class="el" href="group__group__soap.html#ga9750ea0479df8aa88e06f6a148b2a670" title="User-definable maximum iterations in the server-side soap_serve loop (or the C++ service class serve ...">SOAP_MAXKEEPALIVE</a></code> by default) </p>
<dl class="section user"><dt>Example:</dt><dd></dd></dl>
<div class="fragment"><div class="line"><span class="keyword">struct </span>soap *soap = <a class="code" href="group__group__context.html#ga51cde138234ed7ec8c4e25bdf6418658">soap_new1</a>(<a class="code" href="group__group__flags.html#ga0a4635737732c912058ff4dba668c1b2">SOAP_IO_KEEPALIVE</a>); <span class="comment">// enable HTTP keep-alive</span></div><div class="line">soap-&gt;<a class="code" href="structsoap.html#a1d7aca6ac1d62302102c17508a8b0ec0">max_keep_alive</a> = 50;                        <span class="comment">// 50 max keep-alive exchanges (SOAP_MAXKEEPALIVE by default)</span></div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__group__flags.html#ga0a4635737732c912058ff4dba668c1b2" title="soap_mode IO output flag value to keep the socket connection alive for SOAP_MAXKEEPALIVE message exch...">SOAP_IO_KEEPALIVE</a></code>, <code><a class="el" href="group__group__io.html#ga51dba7706a505240bd8935c0b28e419d" title="Serve a pending request. ">soap_serve</a></code>, <code><a class="el" href="structsoap.html#a3d93ba968bb58373f5884177a7ec0d83" title="HTTP keep-alive flag (try to enable when -1, disabled when 0) and counter (enabled when &gt;0) ...">soap::keep_alive</a></code>. </dd></dl>

</div>
</div>
<a class="anchor" id="aa5d564f947cbd74c29124972823fe775"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long soap::maxlength</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User-definable maximum string length parsed from XML and JSON, initially set to <code><a class="el" href="group__group__soap.html#gabd0dd334a752d8c145fa720deb905508" title="User-definable maximum string content length for strings not already constrained by XML schema valida...">SOAP_MAXLENGTH</a></code>, zero or negative means unlimited (0 by default) </p>
<p>The length of a string is the number of characters it contains. Multi-byte strings with UTF-8 content (enabled with <code><a class="el" href="group__group__flags.html#ga9006d22d0abc39831dfe3ce1e491ce6f" title="soap_mode C-related input/output flag value to serialize and deserialize 8-bit C/C++ strings containi...">SOAP_C_UTFSTRING</a></code>) contain up to the specified number of multi-byte characters. The byte length depends on the UTF-8 encoding. The specified limit applies to strings that are not subject to string length schema validation constraints, to ensure that schema validation is not affected.</p>
<dl class="section user"><dt>Example:</dt><dd></dd></dl>
<div class="fragment"><div class="line"><span class="keyword">struct </span>soap *soap = <a class="code" href="group__group__context.html#ga87c20488b2dc680aaa7689b1d024989c">soap_new</a>();</div><div class="line">soap-&gt;<a class="code" href="structsoap.html#aa5d564f947cbd74c29124972823fe775">maxlength</a> = 256; <span class="comment">// limit string lengths to 256 characters (unlimited by default)</span></div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><code><a class="el" href="structsoap.html#a345900c2db67e915ceb02bfa21ecbcbd" title="User-definable maximum message length that is permitted to be received, zero means unlimited (2GB by ...">soap::recv_maxlength</a></code>, <code><a class="el" href="structsoap.html#a80dbe084f7efe713ac93e6e6a2d30d7f" title="User-definable maximum XML and JSON nesting level permitted, initially set to SOAP_MAXLEVEL (10000 by...">soap::maxlevel</a></code>, <code><a class="el" href="structsoap.html#a00bc20ad1100f580a173ba651e05bcb9" title="User-definable maximum array and container size (maximum item occurrence constraint) as parsed from X...">soap::maxoccurs</a></code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a80dbe084f7efe713ac93e6e6a2d30d7f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int soap::maxlevel</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User-definable maximum XML and JSON nesting level permitted, initially set to <code><a class="el" href="group__group__soap.html#ga2ad35599c611417132d6b0a9b6870652" title="User-definable maximum XML nesting depth level permitted by the XML parser, must be greater than zero...">SOAP_MAXLEVEL</a></code> (10000 by default) </p>
<dl class="section user"><dt>Example:</dt><dd></dd></dl>
<div class="fragment"><div class="line"><span class="keyword">struct </span>soap *soap = <a class="code" href="group__group__context.html#ga87c20488b2dc680aaa7689b1d024989c">soap_new</a>();</div><div class="line">soap-&gt;<a class="code" href="structsoap.html#a80dbe084f7efe713ac93e6e6a2d30d7f">maxlevel</a> = 10; <span class="comment">// limit XML nesting depth to 10 (10000 by default)</span></div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><code><a class="el" href="structsoap.html#a345900c2db67e915ceb02bfa21ecbcbd" title="User-definable maximum message length that is permitted to be received, zero means unlimited (2GB by ...">soap::recv_maxlength</a></code>, <code><a class="el" href="structsoap.html#aa5d564f947cbd74c29124972823fe775" title="User-definable maximum string length parsed from XML and JSON, initially set to SOAP_MAXLENGTH, zero or negative means unlimited (0 by default) ">soap::maxlength</a></code>, <code><a class="el" href="structsoap.html#a00bc20ad1100f580a173ba651e05bcb9" title="User-definable maximum array and container size (maximum item occurrence constraint) as parsed from X...">soap::maxoccurs</a></code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a00bc20ad1100f580a173ba651e05bcb9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t soap::maxoccurs</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User-definable maximum array and container size (maximum item occurrence constraint) as parsed from XML and JSON, except when specifie XML schema validation constraints permit greater sizes, initially set to <code><a class="el" href="group__group__soap.html#ga3933a58d23a5bf2ad64039725cb23786" title="User-definable maximum number of array or container elements for containers that are not already cons...">SOAP_MAXOCCURS</a></code> (100000 by default) </p>
<p>The specified occurrence limit applies to arrays and containers that are not subject to occurrence validation constraints (<code>minOccurs</code> and <code>maxOccurs</code>, to ensure that schema validation is not affected.</p>
<dl class="section user"><dt>Example:</dt><dd></dd></dl>
<div class="fragment"><div class="line"><span class="keyword">struct </span>soap *soap = <a class="code" href="group__group__context.html#ga87c20488b2dc680aaa7689b1d024989c">soap_new</a>();</div><div class="line">soap-&gt;<a class="code" href="structsoap.html#a00bc20ad1100f580a173ba651e05bcb9">maxoccurs</a> = 100; <span class="comment">// limit arrays and containers to 100 items (100000 by default)</span></div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><code><a class="el" href="structsoap.html#a345900c2db67e915ceb02bfa21ecbcbd" title="User-definable maximum message length that is permitted to be received, zero means unlimited (2GB by ...">soap::recv_maxlength</a></code>, <code><a class="el" href="structsoap.html#a80dbe084f7efe713ac93e6e6a2d30d7f" title="User-definable maximum XML and JSON nesting level permitted, initially set to SOAP_MAXLEVEL (10000 by...">soap::maxlevel</a></code>, <code><a class="el" href="structsoap.html#aa5d564f947cbd74c29124972823fe775" title="User-definable maximum string length parsed from XML and JSON, initially set to SOAP_MAXLENGTH, zero or negative means unlimited (0 by default) ">soap::maxlength</a></code>. </dd></dl>

</div>
</div>
<a class="anchor" id="af2f4dbd6f73f19f1beeaa3a7e9d9cc2c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structsoap__mime.html">soap_mime</a> soap::mime</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>MIME attachments received. </p>
<p>This structure contains a linked list of MIME attachments received. </p>

</div>
</div>
<a class="anchor" id="a58350076d9fa133bacca27424fe0feff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char soap::msgbuf[<a class="el" href="group__group__soap.html#ga92d654b655b8aca035c8281a836f495f">SOAP_TMPLEN</a>]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Internal buffer to hold short messages, URLs and HTTP/MIME header lines, must have at least <code><a class="el" href="group__group__soap.html#ga92d654b655b8aca035c8281a836f495f" title="User-definable maximum length of temporary string values stored in soap::msgbuf and soap::tmpbuf...">SOAP_TMPLEN</a></code> = 1024 bytes of space allocated. </p>

</div>
</div>
<a class="anchor" id="a17c750f20dab579a6a23c30199ed1263"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">short soap::mustUnderstand</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <code><a class="el" href="structsoap.html#a17c750f20dab579a6a23c30199ed1263" title="The soap::mustUnderstand flag is set when a SOAP Header element carries a SOAP-ENV:mustUnderstand att...">soap::mustUnderstand</a></code> flag is set when a SOAP Header element carries a <em><code>SOAP-ENV:mustUnderstand</code></em> attribute that is true. </p>

</div>
</div>
<a class="anchor" id="af2c9e77616c132831ebf041d9e4d18b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* soap::ntlm_challenge</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User-definable NTLM authentication challenge key string. </p>
<dl class="section user"><dt>Examples:</dt><dd></dd></dl>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;soapH.h&quot;</span></div><div class="line"><span class="keyword">struct </span>soap *soap = <a class="code" href="group__group__context.html#ga87c20488b2dc680aaa7689b1d024989c">soap_new</a>();</div><div class="line"><span class="keywordflow">if</span> (soap_call_ns__webmethod(soap, <a class="code" href="structsoap.html#aed1b86b8a34aea86103751a932c9dce9">endpoint</a>, NULL, ...) == 401) <span class="comment">// Unauthorized, got soap-&gt;authrealm with NTLM domain</span></div><div class="line">{</div><div class="line">  soap-&gt;<a class="code" href="structsoap.html#a2ede02095d98942f4c220fd17b495703">userid</a> = <span class="stringliteral">&quot;user-id&quot;</span>; <span class="comment">// NTLM auth credential</span></div><div class="line">  soap-&gt;<a class="code" href="structsoap.html#a22d219c98f0fcf456641277cc64174a3">passwd</a> = <span class="stringliteral">&quot;user-pw&quot;</span>; <span class="comment">// NTLM auth credential</span></div><div class="line">  <span class="keywordflow">if</span> (soap_call_ns__webmethod(soap, <a class="code" href="structsoap.html#aed1b86b8a34aea86103751a932c9dce9">endpoint</a>, NULL, ...)) <span class="comment">// try again</span></div><div class="line">    <a class="code" href="group__group__fault.html#ga931a4ab6df2553b48a0c270f8a0a88af">soap_print_fault</a>(soap, stderr);</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    ... <span class="comment">// success</span></div><div class="line">}</div><div class="line"><span class="keywordflow">else</span></div><div class="line">{</div><div class="line">  ... <span class="comment">// success</span></div><div class="line">}</div><div class="line"><a class="code" href="group__group__context.html#gaf7d0176161e9def36981e24faa1913d9">soap_destroy</a>(soap);</div><div class="line"><a class="code" href="group__group__context.html#ga81a009ae1ea825a05e5241e2b7a8ece9">soap_end</a>(soap);</div><div class="line"><a class="code" href="group__group__context.html#ga57108ca4681186e58b5b189c3528f10a">soap_free</a>(soap);</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;soapH.h&quot;</span></div><div class="line"><span class="keyword">struct </span>soap *soap = <a class="code" href="group__group__context.html#ga87c20488b2dc680aaa7689b1d024989c">soap_new</a>();</div><div class="line">soap-&gt;<a class="code" href="structsoap.html#af2c9e77616c132831ebf041d9e4d18b1">ntlm_challenge</a> = <span class="stringliteral">&quot;&quot;</span>; <span class="comment">// pretend we&#39;ve been challenged</span></div><div class="line">soap-&gt;<a class="code" href="structsoap.html#a2ede02095d98942f4c220fd17b495703">userid</a> = <span class="stringliteral">&quot;user-id&quot;</span>;  <span class="comment">// NTLM credential</span></div><div class="line">soap-&gt;<a class="code" href="structsoap.html#a22d219c98f0fcf456641277cc64174a3">passwd</a> = <span class="stringliteral">&quot;user-pw&quot;</span>;  <span class="comment">// NTLM credential</span></div><div class="line">soap-&gt;<a class="code" href="structsoap.html#a8dbe57d59f683d99305a44b4d7939bfd">authrealm</a> = <span class="stringliteral">&quot;server-domain&quot;</span>; <span class="comment">// NTLM domain</span></div><div class="line"><span class="keywordflow">if</span> (soap_call_ns__webmethod(soap, <a class="code" href="structsoap.html#aed1b86b8a34aea86103751a932c9dce9">endpoint</a>, NULL, ...))</div><div class="line">  <a class="code" href="group__group__fault.html#ga931a4ab6df2553b48a0c270f8a0a88af">soap_print_fault</a>(soap, stderr);</div><div class="line"><span class="keywordflow">else</span></div><div class="line">  ... <span class="comment">// success</span></div><div class="line"><a class="code" href="group__group__context.html#gaf7d0176161e9def36981e24faa1913d9">soap_destroy</a>(soap);</div><div class="line"><a class="code" href="group__group__context.html#ga81a009ae1ea825a05e5241e2b7a8ece9">soap_end</a>(soap);</div><div class="line"><a class="code" href="group__group__context.html#ga57108ca4681186e58b5b189c3528f10a">soap_free</a>(soap);</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Requires compilation with <code><a class="el" href="group__group__with.html#ga4a743d1499292194cfc81d305500c83f" title="When this macro is defined at compile time (undefined by default), enables linkage with the ntlm libr...">WITH_NTLM</a></code> and linking libntlm available at <a href="http://www.nongnu.org/libntlm">http://www.nongnu.org/libntlm</a> for non-Windows platforms.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="structsoap.html#a5213a5328b44244689fd3c2937cc8b92" title="User-definable HTTP authorization bearer token value to be sent by the client, server side receives t...">soap::bearer</a></code>, <code><a class="el" href="structsoap.html#a2ede02095d98942f4c220fd17b495703" title="User-definable HTTP and NTLM authorization user id string for HTTP basic and NTLM authentication by t...">soap::userid</a></code>, <code><a class="el" href="structsoap.html#a22d219c98f0fcf456641277cc64174a3" title="User-definable HTTP and NTLM authorization password string required for HTTP basic and NTLM authentic...">soap::passwd</a></code>, <code><a class="el" href="structsoap.html#a7e7e9e9d65bba6237298cf2ed7cec599" title="User-definable proxy authorization user id string to authenticate and connect to an HTTP proxy...">soap::proxy_userid</a></code>, <code><a class="el" href="structsoap.html#ad75a4abe119a1a74a26d06401fa11c3a" title="User-definable proxy authorization password string to authenticate and connect to an HTTP proxy...">soap::proxy_passwd</a></code>. </dd></dl>

</div>
</div>
<a class="anchor" id="addf099ccce764cf38f96be305b44406a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">short soap::null</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <code><a class="el" href="structsoap.html#addf099ccce764cf38f96be305b44406a" title="The soap::null flag is set when an element carries a xsi:nil attribute that is true. ">soap::null</a></code> flag is set when an element carries a <em><code>xsi:nil</code></em> attribute that is true. </p>

</div>
</div>
<a class="anchor" id="a0f7cfb4dd32a7be1ec63a20f55e12521"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__flags.html#ga72b0491c9cbf2071f0c96c7d29b719bb">soap_mode</a> soap::omode</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context output <code><a class="el" href="group__group__flags.html#ga72b0491c9cbf2071f0c96c7d29b719bb" title="The soap_mode flags to initialize the soap context, flags can be combined with | (bit-wise or) ...">soap_mode</a></code> flags that are set at context initialization and set or cleared with <code><a class="el" href="group__group__context.html#gaf6fa6e197f360834eae124fa37e68cf7" title="Set output soap_mode flags of the given soap context. ">soap_set_omode</a></code> or <code><a class="el" href="group__group__context.html#ga8c28d2943bee7aa5c3ffaf32803b31bd" title="Clear output soap_mode flags of the given soap context. ">soap_clr_omode</a></code>, respectively. </p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="structsoap.html#a4c24dec1ac79111c4ebeb30ba73cca65" title="The soap context input soap_mode flags that are set at context initialization and set or cleared with...">soap::imode</a></code>, <code><a class="el" href="group__group__context.html#gaf6fa6e197f360834eae124fa37e68cf7" title="Set output soap_mode flags of the given soap context. ">soap_set_omode</a></code>, <code><a class="el" href="group__group__context.html#ga84f52a67a41009b260ff2c036df7f6ab" title="Set input and output soap_mode flags of the given soap context. ">soap_set_mode</a></code>, <code><a class="el" href="group__group__context.html#ga8c28d2943bee7aa5c3ffaf32803b31bd" title="Clear output soap_mode flags of the given soap context. ">soap_clr_omode</a></code>, <code><a class="el" href="group__group__context.html#ga06f769f80bcea7beb2ebffd0a40fc521" title="Clear input and output soap_mode flags of the given soap context. ">soap_clr_mode</a></code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a4a5abddf8cedcbe713d61dc6a82d54c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* soap::origin</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The CORS Origin HTTP header string value received. </p>
<p>CORS is automatic at the server side. The server internally calls the <code><a class="el" href="group__group__callbacks.html#ga65272c1ecb5ed9925a5a670cf7e77d10" title="Callback to implement logic at the server-side to serve responses to HTTP OPTION requests from client...">soap::fopt</a></code> callback to serve the OPTION method CORS request, which returns HTTP 200 OK with CORS headers. The default value of the CORS Access-Control-Allow-Origin header is "*".</p>
<p>At the client side, CORS requires the HTTP OPTIONS method with CORS headers. Use the following code to send HTTP OPTIONS with CORS headers to a server:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;soapH.h&quot;</span></div><div class="line"><span class="keyword">struct </span>soap *soap = <a class="code" href="group__group__context.html#ga87c20488b2dc680aaa7689b1d024989c">soap_new</a>();</div><div class="line">soap-&gt;<a class="code" href="structsoap.html#a4a5abddf8cedcbe713d61dc6a82d54c3">origin</a> = <span class="stringliteral">&quot;http://example.com&quot;</span>;</div><div class="line">soap-&gt;<a class="code" href="structsoap.html#a6c70d16d39b9f403fc1827b78ca8e29f">cors_method</a> = <span class="stringliteral">&quot;POST&quot;</span>; <span class="comment">// request method is POST</span></div><div class="line">soap-&gt;<a class="code" href="structsoap.html#afc8032dc7b29093757d5f5f5241463de">cors_header</a> = <span class="stringliteral">&quot;...&quot;</span>;  <span class="comment">// list of comma-separated request headers (may be omitted)</span></div><div class="line"><span class="keywordflow">if</span> (<a class="code" href="group__group__io.html#ga315b6e1d5888780bf4ef320c50f23796">soap_connect_command</a>(soap, <a class="code" href="group__group__io.html#gab85d36efa8017c3d328289e25318fb18">SOAP_OPTIONS</a>, <a class="code" href="structsoap.html#aed1b86b8a34aea86103751a932c9dce9">endpoint</a>, NULL)</div><div class="line"> || <a class="code" href="group__group__io.html#ga290ddb46afdbf5ec6669b6ac8daca5c9">soap_end_send</a>(soap)</div><div class="line"> || <a class="code" href="group__group__io.html#ga8bb9d541b641a6c261d8879363c7694c">soap_recv_empty_response</a>(soap))</div><div class="line">  <a class="code" href="group__group__fault.html#ga931a4ab6df2553b48a0c270f8a0a88af">soap_print_fault</a>(soap, stderr);</div><div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (soap_call_ns__webmethod(soap, <a class="code" href="structsoap.html#aed1b86b8a34aea86103751a932c9dce9">endpoint</a>, NULL, ...))</div><div class="line">  <a class="code" href="group__group__fault.html#ga931a4ab6df2553b48a0c270f8a0a88af">soap_print_fault</a>(soap, stderr);</div><div class="line"><span class="keywordflow">else</span></div><div class="line">  ... <span class="comment">// success</span></div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><code><a class="el" href="structsoap.html#ae4a79c23a3ebab6023b6b6e16de734cc" title="The CORS Access-Control-Allow-Origin HTTP header string value received or the user-definable value to...">soap::cors_origin</a></code>, <code><a class="el" href="structsoap.html#a9a1a820717a3a9c806c0d0f277f47427" title="User-definable CORS Access-Control-Allow-Origin HTTP header string default value (* by default) ...">soap::cors_allow</a></code>, <code><a class="el" href="structsoap.html#a6c70d16d39b9f403fc1827b78ca8e29f" title="The CORS Access-Control-Request-Method HTTP header string received. ">soap::cors_method</a></code>, <code><a class="el" href="structsoap.html#afc8032dc7b29093757d5f5f5241463de" title="The CORS Access-Control-Request-Headers HTTP header string received. ">soap::cors_header</a></code>, <code><a class="el" href="structsoap.html#aeacd72a210204ebde6dcdb81bdaf4eef" title="User-definable CORS Access-Control-Request-Methods HTTP header string to be returned by the server...">soap::cors_methods</a></code>, <code><a class="el" href="structsoap.html#afc8032dc7b29093757d5f5f5241463de" title="The CORS Access-Control-Request-Headers HTTP header string received. ">soap::cors_header</a></code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a27b166e404c7c98cfa45d6d7a5da90c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SOAP_SINK* soap::os</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The sink to write data to when non-NULL, which in C++ is a <code>std::ostream</code> object and in C is a pointer to a <code>char*</code> string variable that will be set to point to a managed 0-terminated string with the data, default value is NULL. </p>
<dl class="section user"><dt>Examples:</dt><dd></dd></dl>
<div class="fragment"><div class="line"><span class="comment">// C example</span></div><div class="line"><span class="preprocessor">#include &quot;soapH.h&quot;</span></div><div class="line"><span class="keyword">struct </span>soap *soap = <a class="code" href="group__group__context.html#ga51cde138234ed7ec8c4e25bdf6418658">soap_new1</a>(<a class="code" href="group__group__flags.html#ga08a6a913484a5c771bfca7b7b5b9cfc8">SOAP_DOM_TREE</a>);</div><div class="line"><span class="keyword">struct </span>ns__someElement data;</div><div class="line"><span class="keywordtype">char</span> *cs = NULL;</div><div class="line">... <span class="comment">// populate the data</span></div><div class="line">soap-&gt;<a class="code" href="structsoap.html#a27b166e404c7c98cfa45d6d7a5da90c0">os</a> = &amp;cs;</div><div class="line"><span class="comment">// serialize ns__someElement structure as XML</span></div><div class="line"><span class="keywordflow">if</span> (soap_write_ns__someElement(soap, &amp;data))</div><div class="line">  ... <span class="comment">// an error occurred</span></div><div class="line">soap-&gt;<a class="code" href="structsoap.html#a27b166e404c7c98cfa45d6d7a5da90c0">os</a> = NULL;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> *xml = cs; <span class="comment">// string allocated and managed by the context</span></div></div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">// C++ example</span></div><div class="line"><span class="preprocessor">#include &quot;soapH.h&quot;</span></div><div class="line"><span class="keyword">struct </span>soap *soap = <a class="code" href="group__group__context.html#ga51cde138234ed7ec8c4e25bdf6418658">soap_new1</a>(<a class="code" href="group__group__flags.html#ga08a6a913484a5c771bfca7b7b5b9cfc8">SOAP_DOM_TREE</a>);</div><div class="line"><span class="keyword">struct </span>ns__someElement data;</div><div class="line">... <span class="comment">// populate the data</span></div><div class="line">std::stringstream ss;</div><div class="line">soap-&gt;<a class="code" href="structsoap.html#a27b166e404c7c98cfa45d6d7a5da90c0">os</a> = &amp;ss;</div><div class="line"><span class="comment">// serialize ns__someElement structure as XML</span></div><div class="line"><span class="keywordflow">if</span> (soap_write_ns__someElement(soap, &amp;data))</div><div class="line">  ... <span class="comment">// an error occurred</span></div><div class="line">soap-&gt;<a class="code" href="structsoap.html#a27b166e404c7c98cfa45d6d7a5da90c0">os</a> = NULL;</div><div class="line">std::string xml = ss.str();</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a166405369ad10bc20b90fb9285420cae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* soap::override_host</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User-definable string to override the host name or IP address in the HTTP header when connecting at the client side. </p>
<dl class="section user"><dt>Example:</dt><dd></dd></dl>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;soapH.h&quot;</span></div><div class="line"><span class="keyword">struct </span>soap *soap = <a class="code" href="group__group__context.html#ga51cde138234ed7ec8c4e25bdf6418658">soap_new1</a>(<a class="code" href="group__group__flags.html#gaea7443dc67c979b06cf347ed16db1b51">SOAP_IO_CHUNK</a>);</div><div class="line">... <span class="comment">// initializations</span></div><div class="line">soap-&gt;<a class="code" href="structsoap.html#a166405369ad10bc20b90fb9285420cae">override_host</a> = <span class="stringliteral">&quot;server-domain-or-IP&quot;</span>;</div><div class="line">soap-&gt;<a class="code" href="structsoap.html#a914dcb6eb067f2fd3a47f9207257b606">override_port</a> = 1234;</div><div class="line"><span class="keywordflow">if</span> (soap_call_ns__webmethod(soap, <a class="code" href="structsoap.html#aed1b86b8a34aea86103751a932c9dce9">endpoint</a>, NULL, ...))</div><div class="line">  <a class="code" href="group__group__fault.html#ga931a4ab6df2553b48a0c270f8a0a88af">soap_print_fault</a>(soap, stderr);</div><div class="line"><span class="keywordflow">else</span></div><div class="line">  ... <span class="comment">// success</span></div><div class="line"><a class="code" href="group__group__context.html#gaf7d0176161e9def36981e24faa1913d9">soap_destroy</a>(soap);</div><div class="line"><a class="code" href="group__group__context.html#ga81a009ae1ea825a05e5241e2b7a8ece9">soap_end</a>(soap);</div><div class="line"><a class="code" href="group__group__context.html#ga57108ca4681186e58b5b189c3528f10a">soap_free</a>(soap);</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><code><a class="el" href="structsoap.html#a914dcb6eb067f2fd3a47f9207257b606" title="User-definable port number to override the port address in the HTTP header when connecting at the cli...">soap::override_port</a></code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a914dcb6eb067f2fd3a47f9207257b606"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soap::override_port</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User-definable port number to override the port address in the HTTP header when connecting at the client side. </p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="structsoap.html#a166405369ad10bc20b90fb9285420cae" title="User-definable string to override the host name or IP address in the HTTP header when connecting at t...">soap::override_host</a></code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a22d219c98f0fcf456641277cc64174a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* soap::passwd</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User-definable HTTP and NTLM authorization password string required for HTTP basic and NTLM authentication by the client, server side receives this string when the client uses HTTP basic authentication. </p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="structsoap.html#a2ede02095d98942f4c220fd17b495703" title="User-definable HTTP and NTLM authorization user id string for HTTP basic and NTLM authentication by t...">soap::userid</a></code>, <code><a class="el" href="structsoap.html#a8dbe57d59f683d99305a44b4d7939bfd" title="The HTTP and NTLM authorization realm/domain string received by the client with the WWW-Authenticate ...">soap::authrealm</a></code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a3c2bd2822146a8ccca20f8f217c2f309"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char soap::path[<a class="el" href="group__group__soap.html#ga69f1ba9e1b47201e54822f365087f5a5">SOAP_TAGLEN</a>]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The client request path as received on the server side. </p>
<p>The URL path string is extracted from the HTTP header by <code><a class="el" href="group__group__callbacks.html#ga9cb05ce98f845f16c920c44426ac35a5" title="Callback that reads and parses HTTP and MIME headers. ">soap::fparse</a></code> called by <code><a class="el" href="group__group__io.html#gaf4ce538944f65ac97d82bfeaa9345c42" title="Initialize the context for receiving. ">soap_begin_recv</a></code> and starts with a "/".</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="structsoap.html#a4565a0ad4ea08ada721155ded8e8036f" title="The IPv4 address in numeric form of the client as received on the server side by soap_accept (or the ...">soap::ip</a></code>, <code><a class="el" href="structsoap.html#a3d942a41712800a7d81b0e0fe3f10613" title="The IPv6 address in numeric form (upper ip6[0] to lower ip6[3]) of the client as received on the serv...">soap::ip6</a></code>, <code><a class="el" href="structsoap.html#aed1b86b8a34aea86103751a932c9dce9" title="The endpoint string as received on the server side. ">soap::endpoint</a></code>, <code><a class="el" href="structsoap.html#ab8f356cfb0a1ba87c26cb0ae4c9ee713" title="The client host name or IP address as received on the server side. ">soap::host</a></code>, <code><a class="el" href="structsoap.html#acef722da5f6789721603beeb0b505838" title="The client port connected to as received on the server side by soap_accept (or the C++ service class ...">soap::port</a></code>, <code><a class="el" href="group__group__io.html#ga6a84b61777a04a066e6e11baa89c579b" title="Extract the query string from the URL path at the server side with the http_get plugin. ">soap_query</a></code>. </dd></dl>

</div>
</div>
<a class="anchor" id="acef722da5f6789721603beeb0b505838"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soap::port</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The client port connected to as received on the server side by <code><a class="el" href="group__group__io.html#gaec0e1aecc2d5479d8099762feb4713c6" title="Accept a connection with a client. ">soap_accept</a></code> (or the C++ service class <code>accept</code> method) </p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="structsoap.html#a4565a0ad4ea08ada721155ded8e8036f" title="The IPv4 address in numeric form of the client as received on the server side by soap_accept (or the ...">soap::ip</a></code>, <code><a class="el" href="structsoap.html#a3d942a41712800a7d81b0e0fe3f10613" title="The IPv6 address in numeric form (upper ip6[0] to lower ip6[3]) of the client as received on the serv...">soap::ip6</a></code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a7579168b69a40fbde783efafcf2e0d87"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* soap::prolog</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User-definable XML declaration prolog (<em><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;</code></em> by default) </p>

</div>
</div>
<a class="anchor" id="a59b7a3c700fd54ba1708f97c7b60876b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* soap::proxy_from</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <code>X-Forwarding-For</code> HTTP header string value received. </p>

</div>
</div>
<a class="anchor" id="ac172bd9019afeebb3635b3a9f72a9101"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* soap::proxy_host</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User-definable proxy host name string which should be set to connect through an HTTP proxy. </p>
<dl class="section user"><dt>Example:</dt><dd></dd></dl>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;soapH.h&quot;</span></div><div class="line"><span class="keyword">struct </span>soap *soap = <a class="code" href="group__group__context.html#ga87c20488b2dc680aaa7689b1d024989c">soap_new</a>();</div><div class="line">soap-&gt;<a class="code" href="structsoap.html#ac172bd9019afeebb3635b3a9f72a9101">proxy_host</a> = <span class="stringliteral">&quot;proxy-domain-or-IP&quot;</span>;</div><div class="line">soap-&gt;<a class="code" href="structsoap.html#a037554fd2cf54fb9a6d5326b11c8ffa0">proxy_port</a> = 3128;</div><div class="line">soap-&gt;<a class="code" href="structsoap.html#a7e7e9e9d65bba6237298cf2ed7cec599">proxy_userid</a> = <span class="stringliteral">&quot;proxy-id&quot;</span>;</div><div class="line">soap-&gt;<a class="code" href="structsoap.html#ad75a4abe119a1a74a26d06401fa11c3a">proxy_passwd</a> = <span class="stringliteral">&quot;proxy-pw&quot;</span>;</div><div class="line"><span class="keywordflow">if</span> (soap_call_ns__webmethod(soap, <a class="code" href="structsoap.html#aed1b86b8a34aea86103751a932c9dce9">endpoint</a>, NULL, ...))</div><div class="line">  <a class="code" href="group__group__fault.html#ga931a4ab6df2553b48a0c270f8a0a88af">soap_print_fault</a>(soap, stderr);</div><div class="line"><span class="keywordflow">else</span></div><div class="line">  ... <span class="comment">// success</span></div><div class="line"><a class="code" href="group__group__context.html#gaf7d0176161e9def36981e24faa1913d9">soap_destroy</a>(soap);</div><div class="line"><a class="code" href="group__group__context.html#ga81a009ae1ea825a05e5241e2b7a8ece9">soap_end</a>(soap);</div><div class="line"><a class="code" href="group__group__context.html#ga57108ca4681186e58b5b189c3528f10a">soap_free</a>(soap);</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><code><a class="el" href="structsoap.html#a5213a5328b44244689fd3c2937cc8b92" title="User-definable HTTP authorization bearer token value to be sent by the client, server side receives t...">soap::bearer</a></code>, <code><a class="el" href="structsoap.html#a2ede02095d98942f4c220fd17b495703" title="User-definable HTTP and NTLM authorization user id string for HTTP basic and NTLM authentication by t...">soap::userid</a></code>, <code><a class="el" href="structsoap.html#a22d219c98f0fcf456641277cc64174a3" title="User-definable HTTP and NTLM authorization password string required for HTTP basic and NTLM authentic...">soap::passwd</a></code>, <code><a class="el" href="structsoap.html#af2c9e77616c132831ebf041d9e4d18b1" title="User-definable NTLM authentication challenge key string. ">soap::ntlm_challenge</a></code>, <code><a class="el" href="structsoap.html#afb22ae0a494a35268914286bd00446ab" title="User-definable string that specifies an extra HTTP header or headers when separated by CRLF...">soap::http_extra_header</a></code>, and the <a href="../../httpda/html/httpda.html">HTTP digest plugin</a> documentation. </dd></dl>

</div>
</div>
<a class="anchor" id="ad75a4abe119a1a74a26d06401fa11c3a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* soap::proxy_passwd</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User-definable proxy authorization password string to authenticate and connect to an HTTP proxy. </p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="structsoap.html#ac172bd9019afeebb3635b3a9f72a9101" title="User-definable proxy host name string which should be set to connect through an HTTP proxy...">soap::proxy_host</a></code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a037554fd2cf54fb9a6d5326b11c8ffa0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soap::proxy_port</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User-definable proxy port which should be set to connect through an HTTP proxy (8080 by default) </p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="structsoap.html#ac172bd9019afeebb3635b3a9f72a9101" title="User-definable proxy host name string which should be set to connect through an HTTP proxy...">soap::proxy_host</a></code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a7e7e9e9d65bba6237298cf2ed7cec599"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* soap::proxy_userid</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User-definable proxy authorization user id string to authenticate and connect to an HTTP proxy. </p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="structsoap.html#ac172bd9019afeebb3635b3a9f72a9101" title="User-definable proxy host name string which should be set to connect through an HTTP proxy...">soap::proxy_host</a></code>. </dd></dl>

</div>
</div>
<a class="anchor" id="af2b1fc40a14f7ed925658246a26497c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soap::rcvbuf</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User-definable value to set <code>SO_RCVBUF</code> <code>setsockopt</code> (<code><a class="el" href="group__group__soap.html#ga6ec95d997cc20a6a84dd4d76b3ea2fcc" title="User-definable size of the input and output message buffer soap::buf (65536 by default) ...">SOAP_BUFLEN</a></code> by default) </p>
<dl class="section user"><dt>Example:</dt><dd></dd></dl>
<div class="fragment"><div class="line"><span class="keyword">struct </span>soap *soap = <a class="code" href="group__group__context.html#ga87c20488b2dc680aaa7689b1d024989c">soap_new</a>();</div><div class="line">soap-&gt;<a class="code" href="structsoap.html#af2b1fc40a14f7ed925658246a26497c8">rcvbuf</a> = 32768; <span class="comment">// setsockopt SO_RCVBUF size</span></div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a345900c2db67e915ceb02bfa21ecbcbd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__soap.html#ga7c6e38d209f60a18e362172dca1a3b6e">ULONG64</a> soap::recv_maxlength</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User-definable maximum message length that is permitted to be received, zero means unlimited (2GB by default) </p>
<dl class="section user"><dt>Example:</dt><dd></dd></dl>
<div class="fragment"><div class="line"><span class="keyword">struct </span>soap *soap = <a class="code" href="group__group__context.html#ga87c20488b2dc680aaa7689b1d024989c">soap_new</a>();</div><div class="line">soap-&gt;<a class="code" href="structsoap.html#a711bb3a53de7cc62429e4d3a2e0b5474">send_timeout</a> = soap_recv_timeout = 5; <span class="comment">// 5 seconds max socket stall time (unlimited by default)</span></div><div class="line">soap-&gt;<a class="code" href="structsoap.html#afcf1d236d052579122f785d7639c43c7">transfer_timeout</a> = 30;                <span class="comment">// 30 seconds max message transfer time (unlimited by default)</span></div><div class="line">soap-&gt;<a class="code" href="structsoap.html#a345900c2db67e915ceb02bfa21ecbcbd">recv_maxlength</a> = 1048576;             <span class="comment">// limit messages received to 1MB (2GB by default)</span></div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ac5d5fb92fffda724ccb3b038d2bb2388"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soap::recv_timeout</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User-definable timeout to receive a packet of data, positive timeout values are seconds, negative timeout values are microseconds, zero means no timeout (0 by default) </p>
<dl class="section user"><dt>Example:</dt><dd></dd></dl>
<div class="fragment"><div class="line"><span class="keyword">struct </span>soap *soap = <a class="code" href="group__group__context.html#ga87c20488b2dc680aaa7689b1d024989c">soap_new</a>();</div><div class="line">soap-&gt;<a class="code" href="structsoap.html#a711bb3a53de7cc62429e4d3a2e0b5474">send_timeout</a> = soap_recv_timeout = 5; <span class="comment">// 5 seconds max socket stall time (unlimited by default)</span></div><div class="line">soap-&gt;<a class="code" href="structsoap.html#afcf1d236d052579122f785d7639c43c7">transfer_timeout</a> = 30;                <span class="comment">// 30 seconds max message transfer time (unlimited by default)</span></div><div class="line">soap-&gt;<a class="code" href="structsoap.html#a345900c2db67e915ceb02bfa21ecbcbd">recv_maxlength</a> = 1048576;             <span class="comment">// limit messages received to 1MB (2GB by default)</span></div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><code><a class="el" href="structsoap.html#ab85f5d42702963d13ea540bd9876e6d2" title="The soap context soap_status (int) error code of the last operation or SOAP_OK (zero) ...">soap::error</a></code>, <code><a class="el" href="structsoap.html#a10b66d6d489690b7d0f591ae2633dd13" title="The errno value of the last failed IO operation. ">soap::errnum</a></code>, <code><a class="el" href="structsoap.html#af32b5f3975eac2bd1202571515859163" title="User-definable timeout when waiting to connect to a server at the client-side, positive timeout value...">soap::connect_timeout</a></code>, <code><a class="el" href="structsoap.html#a78199a81c504833047224a0ceff6f906" title="User-definable timeout when waiting to accept a request from a client at the server-side with soap_ac...">soap::accept_timeout</a></code>, <code><a class="el" href="structsoap.html#a711bb3a53de7cc62429e4d3a2e0b5474" title="User-definable timeout to send a packet of data, positive timeout values are seconds, negative timeout values are microseconds, zero means no timeout (0 by default) ">soap::send_timeout</a></code>, <code><a class="el" href="structsoap.html#afcf1d236d052579122f785d7639c43c7" title="User-definable timeout to send or receive an entire message, positive timeout values are seconds...">soap::transfer_timeout</a></code>, <code><a class="el" href="structsoap.html#a345900c2db67e915ceb02bfa21ecbcbd" title="User-definable maximum message length that is permitted to be received, zero means unlimited (2GB by ...">soap::recv_maxlength</a></code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a192c25cc206668600212fd34f6541f34"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soap::recvfd</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The file descriptor to read data from when no socket communications are set (<code><a class="el" href="structsoap.html#a1579bd8bd106afc9a906a673ca473046" title="The socket set by soap_accept (or the C++ service class accept method) or soap_connect or soap_connec...">soap::socket</a></code> == <code><a class="el" href="group__group__soap.html#gab9e77b1557780293eec0b269ef191472" title="Macro that defines a portable invalid socket value (usually -1, but the value depends on the OS) ...">SOAP_INVALID_SOCKET</a></code>) and <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a>:is</code> == NULL, default value is 0 (stdin) </p>
<dl class="section user"><dt>Example:</dt><dd></dd></dl>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;soapH.h&quot;</span></div><div class="line"><span class="keyword">struct </span>soap *soap = <a class="code" href="group__group__context.html#ga51cde138234ed7ec8c4e25bdf6418658">soap_new1</a>(<a class="code" href="group__group__flags.html#ga08a6a913484a5c771bfca7b7b5b9cfc8">SOAP_DOM_TREE</a>);</div><div class="line"><span class="keyword">struct </span>ns__someElement data;</div><div class="line"><span class="keywordflow">if</span> ((soap-&gt;<a class="code" href="structsoap.html#a192c25cc206668600212fd34f6541f34">recvfd</a> = open(<span class="stringliteral">&quot;doc.xml&quot;</span>, O_RDONLY)) == 0)</div><div class="line">  ... <span class="comment">// an error occurred</span></div><div class="line"><span class="comment">// parse and deserialize XML into a ns__someElement structure</span></div><div class="line"><span class="keywordflow">if</span> (soap_read_ns__someElement(soap, &amp;data))</div><div class="line">  ... <span class="comment">// an error occurred</span></div><div class="line">close(soap-&gt;<a class="code" href="structsoap.html#a192c25cc206668600212fd34f6541f34">recvfd</a>);</div><div class="line">soap-&gt;<a class="code" href="structsoap.html#a192c25cc206668600212fd34f6541f34">recvfd</a> = 0;</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a711bb3a53de7cc62429e4d3a2e0b5474"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soap::send_timeout</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User-definable timeout to send a packet of data, positive timeout values are seconds, negative timeout values are microseconds, zero means no timeout (0 by default) </p>
<dl class="section user"><dt>Example:</dt><dd></dd></dl>
<div class="fragment"><div class="line"><span class="keyword">struct </span>soap *soap = <a class="code" href="group__group__context.html#ga87c20488b2dc680aaa7689b1d024989c">soap_new</a>();</div><div class="line">soap-&gt;<a class="code" href="structsoap.html#a711bb3a53de7cc62429e4d3a2e0b5474">send_timeout</a> = soap_recv_timeout = 5; <span class="comment">// 5 seconds max socket stall time (unlimited by default)</span></div><div class="line">soap-&gt;<a class="code" href="structsoap.html#afcf1d236d052579122f785d7639c43c7">transfer_timeout</a> = 30;                <span class="comment">// 30 seconds max message transfer time (unlimited by default)</span></div><div class="line">soap-&gt;<a class="code" href="structsoap.html#a345900c2db67e915ceb02bfa21ecbcbd">recv_maxlength</a> = 1048576;             <span class="comment">// limit messages received to 1MB (2GB by default)</span></div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><code><a class="el" href="structsoap.html#ab85f5d42702963d13ea540bd9876e6d2" title="The soap context soap_status (int) error code of the last operation or SOAP_OK (zero) ...">soap::error</a></code>, <code><a class="el" href="structsoap.html#a10b66d6d489690b7d0f591ae2633dd13" title="The errno value of the last failed IO operation. ">soap::errnum</a></code>, <code><a class="el" href="structsoap.html#af32b5f3975eac2bd1202571515859163" title="User-definable timeout when waiting to connect to a server at the client-side, positive timeout value...">soap::connect_timeout</a></code>, <code><a class="el" href="structsoap.html#a78199a81c504833047224a0ceff6f906" title="User-definable timeout when waiting to accept a request from a client at the server-side with soap_ac...">soap::accept_timeout</a></code>, <code><a class="el" href="structsoap.html#ac5d5fb92fffda724ccb3b038d2bb2388" title="User-definable timeout to receive a packet of data, positive timeout values are seconds, negative timeout values are microseconds, zero means no timeout (0 by default) ">soap::recv_timeout</a></code>, <code><a class="el" href="structsoap.html#afcf1d236d052579122f785d7639c43c7" title="User-definable timeout to send or receive an entire message, positive timeout values are seconds...">soap::transfer_timeout</a></code>, <code><a class="el" href="structsoap.html#a345900c2db67e915ceb02bfa21ecbcbd" title="User-definable maximum message length that is permitted to be received, zero means unlimited (2GB by ...">soap::recv_maxlength</a></code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a200d71a901cdc5c9aa02140e9d2369b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soap::sendfd</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The file descriptor to write data to when no socket communications are set (<code><a class="el" href="structsoap.html#a1579bd8bd106afc9a906a673ca473046" title="The socket set by soap_accept (or the C++ service class accept method) or soap_connect or soap_connec...">soap::socket</a></code> == <code><a class="el" href="group__group__soap.html#gab9e77b1557780293eec0b269ef191472" title="Macro that defines a portable invalid socket value (usually -1, but the value depends on the OS) ...">SOAP_INVALID_SOCKET</a></code>) and <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a>:os</code> == NULL, default value is 1 (stdout) </p>
<dl class="section user"><dt>Example:</dt><dd></dd></dl>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;soapH.h&quot;</span></div><div class="line"><span class="keyword">struct </span>soap *soap = <a class="code" href="group__group__context.html#ga51cde138234ed7ec8c4e25bdf6418658">soap_new1</a>(<a class="code" href="group__group__flags.html#ga08a6a913484a5c771bfca7b7b5b9cfc8">SOAP_DOM_TREE</a>);</div><div class="line"><span class="keyword">struct </span>ns__someElement data;</div><div class="line">... <span class="comment">// populate the data</span></div><div class="line"><span class="keywordflow">if</span> ((soap-&gt;<a class="code" href="structsoap.html#a200d71a901cdc5c9aa02140e9d2369b9">sendfd</a> = open(<span class="stringliteral">&quot;doc.xml&quot;</span>, O_CREAT | O_RDWR, 0644)) == 0)</div><div class="line">  ... <span class="comment">// an error occurred</span></div><div class="line"><span class="comment">// serialize ns__someElement structure as XML</span></div><div class="line"><span class="keywordflow">if</span> (soap_write_ns__someElement(soap, &amp;data))</div><div class="line">  ... <span class="comment">// an error occurred</span></div><div class="line">close(soap-&gt;<a class="code" href="structsoap.html#a200d71a901cdc5c9aa02140e9d2369b9">sendfd</a>);</div><div class="line">soap-&gt;<a class="code" href="structsoap.html#a200d71a901cdc5c9aa02140e9d2369b9">sendfd</a> = 1;</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a02a7fffd05ff6e6c751f2033ef83854f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soap::sndbuf</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User-definable value to set <code>SO_SNDBUF</code> <code>setsockopt</code> (<code><a class="el" href="group__group__soap.html#ga6ec95d997cc20a6a84dd4d76b3ea2fcc" title="User-definable size of the input and output message buffer soap::buf (65536 by default) ...">SOAP_BUFLEN</a></code> by default) </p>
<dl class="section user"><dt>Example:</dt><dd></dd></dl>
<div class="fragment"><div class="line"><span class="keyword">struct </span>soap *soap = <a class="code" href="group__group__context.html#ga87c20488b2dc680aaa7689b1d024989c">soap_new</a>();</div><div class="line">soap-&gt;<a class="code" href="structsoap.html#a02a7fffd05ff6e6c751f2033ef83854f">sndbuf</a> = 32768; <span class="comment">// setsockopt SO_SNDBUF size</span></div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a1579bd8bd106afc9a906a673ca473046"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__soap.html#ga6eb1bde7cecc2fbadbcbbc6395227439">SOAP_SOCKET</a> soap::socket</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The socket set by <code><a class="el" href="group__group__io.html#gaec0e1aecc2d5479d8099762feb4713c6" title="Accept a connection with a client. ">soap_accept</a></code> (or the C++ service class <code>accept</code> method) or <code><a class="el" href="group__group__io.html#ga5c87e9d0a43fe18cc349c724f198f64a" title="Connect to a server using HTTP POST. ">soap_connect</a></code> or <code><a class="el" href="group__group__io.html#ga315b6e1d5888780bf4ef320c50f23796" title="Connect to a server. ">soap_connect_command</a></code> (or the C++ proxy methods) when successful, or <code><a class="el" href="group__group__soap.html#gab9e77b1557780293eec0b269ef191472" title="Macro that defines a portable invalid socket value (usually -1, but the value depends on the OS) ...">SOAP_INVALID_SOCKET</a></code> when unassigned. </p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__group__io.html#gaec0e1aecc2d5479d8099762feb4713c6" title="Accept a connection with a client. ">soap_accept</a></code>, <code><a class="el" href="group__group__io.html#ga5c87e9d0a43fe18cc349c724f198f64a" title="Connect to a server using HTTP POST. ">soap_connect</a></code>, <code><a class="el" href="group__group__io.html#ga315b6e1d5888780bf4ef320c50f23796" title="Connect to a server. ">soap_connect_command</a></code>, <code><a class="el" href="group__group__soap.html#gaaae8747f4cdacee575875c3a2488d99c" title="Function macro to check if a socket is valid, i.e. not equal to SOAP_INVALID_SOCKET ...">soap_valid_socket</a></code>. </dd></dl>

</div>
</div>
<a class="anchor" id="aae3eee771d8c4031d30d4ca7633edf9f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soap::socket_flags</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User-definable socket <code>send</code> and <code>recv</code> flags, for example assign <code>MSG_NOSIGNAL</code> to disable sigpipe (0 by default) </p>
<dl class="section user"><dt>Example:</dt><dd></dd></dl>
<div class="fragment"><div class="line"><span class="keyword">struct </span>soap *soap = <a class="code" href="group__group__context.html#ga87c20488b2dc680aaa7689b1d024989c">soap_new</a>();</div><div class="line">soap-&gt;<a class="code" href="structsoap.html#aae3eee771d8c4031d30d4ca7633edf9f">socket_flags</a> = MSG_NOSIGNAL; <span class="comment">// no sigpipe (this is not portable)</span></div></div><!-- fragment --><p>Other ways to disable sigpipe:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>soap *soap = <a class="code" href="group__group__context.html#ga87c20488b2dc680aaa7689b1d024989c">soap_new</a>();</div><div class="line">soap-&gt;<a class="code" href="structsoap.html#a52a22fafc369b3a54fb0d16f53158794">connect_flags</a> = SO_NOSIGPIPE;</div><div class="line">soap-&gt;<a class="code" href="structsoap.html#a6b18b017ce2c77ac2b6331469094de59">bind_flags</a> = SO_NOSIGPIPE;</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;signal.h&gt;</span></div><div class="line"><span class="keywordtype">void</span> sigpipe_handle(<span class="keywordtype">int</span>) { }</div><div class="line"></div><div class="line">signal(SIGPIPE, sigpipe_handle);</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><code><a class="el" href="structsoap.html#a52a22fafc369b3a54fb0d16f53158794" title="User-definable setsockopt level SOL_SOCKET flags when connecting soap::socket to a server (0 by defau...">soap::connect_flags</a></code>, <code><a class="el" href="structsoap.html#a6b18b017ce2c77ac2b6331469094de59" title="User-definable setsockopt level SOL_SOCKET flags when binding soap::master socket (0 by default) ...">soap::bind_flags</a></code>, <code><a class="el" href="structsoap.html#ad98f12f602efdde049dbd367a43e7cb0" title="User-definable setsockopt level SOL_SOCKET flags (0 by default), when nonzero sets the soap::socket f...">soap::accept_flags</a></code>. </dd></dl>

</div>
</div>
<a class="anchor" id="aec65c0198db5df4bef7afd2df29ff88d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soap::status</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context HTTP status code received at the client side (100 to 599), HTTP header method received at the server side (<code><a class="el" href="group__group__io.html#ga41f39e73106f1a2283ae3aa65698050f" title="HTTP POST command code. ">SOAP_POST</a></code>, <code><a class="el" href="group__group__io.html#ga0f6661cfe8eff845600e7a75a2f46701" title="HTTP PATCH command code with custom content type. ">SOAP_PATCH</a></code>, <code><a class="el" href="group__group__io.html#ga3abcdd760843c4bdc56c19b85453ed04" title="HTTP GET command code. ">SOAP_GET</a></code>, <code><a class="el" href="group__group__io.html#ga32a114ef8df190363b9c3ad37bcb6335" title="HTTP PUT command code with custom content type. ">SOAP_PUT</a></code>, <code><a class="el" href="group__group__io.html#ga6e1b491acf772e88f64909ee5baae18d" title="HTTP DEL command code. ">SOAP_DEL</a></code>, <code><a class="el" href="group__group__io.html#ga31ba86b35e83440e4047b021add6fe2c" title="HTTP HEAD command code. ">SOAP_HEAD</a></code>, <code><a class="el" href="group__group__io.html#gab85d36efa8017c3d328289e25318fb18" title="HTTP OPTIONS command code. ">SOAP_OPTIONS</a></code>), or the HTTP method to use for sending a message with <code><a class="el" href="group__group__io.html#ga315b6e1d5888780bf4ef320c50f23796" title="Connect to a server. ">soap_connect_command</a></code> or with <code><a class="el" href="group__group__io.html#ga0390e58bd2a3ebe6fe3a46de0534a614" title="Initialize the context for server-side sending and send a HTTP response header. ">soap_response</a></code> (<code><a class="el" href="group__group__io.html#ga41f39e73106f1a2283ae3aa65698050f" title="HTTP POST command code. ">SOAP_POST</a></code>, <code><a class="el" href="group__group__io.html#ga4c291263eadcefa290e90c64e632ae47" title="HTTP POST command code with custom content type. ">SOAP_POST_FILE</a></code>, <code><a class="el" href="group__group__io.html#ga0f6661cfe8eff845600e7a75a2f46701" title="HTTP PATCH command code with custom content type. ">SOAP_PATCH</a></code>, <code><a class="el" href="group__group__io.html#ga3abcdd760843c4bdc56c19b85453ed04" title="HTTP GET command code. ">SOAP_GET</a></code>, <code><a class="el" href="group__group__io.html#ga32a114ef8df190363b9c3ad37bcb6335" title="HTTP PUT command code with custom content type. ">SOAP_PUT</a></code>, <code><a class="el" href="group__group__io.html#ga32a114ef8df190363b9c3ad37bcb6335" title="HTTP PUT command code with custom content type. ">SOAP_PUT</a></code>, <code><a class="el" href="group__group__io.html#ga6e1b491acf772e88f64909ee5baae18d" title="HTTP DEL command code. ">SOAP_DEL</a></code>, <code><a class="el" href="group__group__io.html#gaaf0409312a4af954ee5b183b92967e0b" title="HTTP CONNECT command code. ">SOAP_CONNECT</a></code>, <code><a class="el" href="group__group__io.html#ga31ba86b35e83440e4047b021add6fe2c" title="HTTP HEAD command code. ">SOAP_HEAD</a></code>, <code><a class="el" href="group__group__io.html#gab85d36efa8017c3d328289e25318fb18" title="HTTP OPTIONS command code. ">SOAP_OPTIONS</a></code>) </p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__group__io.html#ga315b6e1d5888780bf4ef320c50f23796" title="Connect to a server. ">soap_connect_command</a></code>, <code><a class="el" href="group__group__io.html#ga953bdee7ebf242b056834e5592079ae9" title="HTTP GET content from server. ">soap_GET</a></code>, <code><a class="el" href="group__group__io.html#gae93e23c11379e71baeb6fafe68e14709" title="HTTP PUT content to server. ">soap_PUT</a></code>, <code><a class="el" href="group__group__io.html#ga71eebf1ab266c7480831a2fb10b6ca1a" title="HTTP PATCH content to server. ">soap_PATCH</a></code>, <code><a class="el" href="group__group__io.html#gaf502246613cb6d4ea120965065d8c0b2" title="HTTP POST content to server. ">soap_POST</a></code>, <code><a class="el" href="group__group__io.html#ga98e63f6969d2d83a31f178728a01c7cc" title="HTTP DELETE content from server. ">soap_DELETE</a></code>, <code><a class="el" href="group__group__io.html#ga0390e58bd2a3ebe6fe3a46de0534a614" title="Initialize the context for server-side sending and send a HTTP response header. ">soap_response</a></code>. </dd></dl>

</div>
</div>
<a class="anchor" id="af8f80a7bd8c09335c6fb836a612231bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soap::tcp_keep_alive</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User-definable value to set <code>SO_KEEPALIVE</code> <code>setsockopt</code> (0 by default unless the <code><a class="el" href="group__group__flags.html#ga0a4635737732c912058ff4dba668c1b2" title="soap_mode IO output flag value to keep the socket connection alive for SOAP_MAXKEEPALIVE message exch...">SOAP_IO_KEEPALIVE</a></code> mode flag is set) </p>
<dl class="section user"><dt>Example:</dt><dd></dd></dl>
<div class="fragment"><div class="line"><span class="keyword">struct </span>soap *soap = <a class="code" href="group__group__context.html#ga87c20488b2dc680aaa7689b1d024989c">soap_new</a>();</div><div class="line">soap-&gt;<a class="code" href="structsoap.html#af8f80a7bd8c09335c6fb836a612231bb">tcp_keep_alive</a> = 1;   <span class="comment">// setsockopt SO_KEEPALIVE</span></div><div class="line">soap-&gt;<a class="code" href="structsoap.html#a8c0822cb0399ed55de6c2a482171868f">tcp_keep_idle</a> = 30;   <span class="comment">// time in seconds the connection needs to remain idle before TCP starts sending keepalive probes</span></div><div class="line">soap-&gt;<a class="code" href="structsoap.html#a822aba3e7ae74fa86277c683569f80ae">tcp_keep_intvl</a> = 120; <span class="comment">// time in seconds between individual keepalive probes</span></div><div class="line">soap-&gt;<a class="code" href="structsoap.html#a811041faab1cf481e7e656f81dc88901">tcp_keep_cnt</a> = 5;     <span class="comment">// maximum number of keepalive probes TCP should send before dropping the connection</span></div></div><!-- fragment --><p>HTTP keep-alive together with TCP <code>SO_KEEPALIVE</code> is enabled with:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>soap *soap = <a class="code" href="group__group__context.html#ga51cde138234ed7ec8c4e25bdf6418658">soap_new1</a>(<a class="code" href="group__group__flags.html#ga0a4635737732c912058ff4dba668c1b2">SOAP_IO_KEEPALIVE</a>); <span class="comment">// enable HTTP keep-alive</span></div><div class="line">soap-&gt;<a class="code" href="structsoap.html#a1d7aca6ac1d62302102c17508a8b0ec0">max_keep_alive</a> = 50;  <span class="comment">// 50 max keep-alive exchanges for SOAP_IO_KEEPALIVE (SOAP_MAXKEEPALIVE by default)</span></div><div class="line">soap-&gt;<a class="code" href="structsoap.html#a8c0822cb0399ed55de6c2a482171868f">tcp_keep_idle</a> = 30;   <span class="comment">// time in seconds the connection needs to remain idle before TCP starts sending keepalive probes</span></div><div class="line">soap-&gt;<a class="code" href="structsoap.html#a822aba3e7ae74fa86277c683569f80ae">tcp_keep_intvl</a> = 120; <span class="comment">// time in seconds between individual keepalive probes</span></div><div class="line">soap-&gt;<a class="code" href="structsoap.html#a811041faab1cf481e7e656f81dc88901">tcp_keep_cnt</a> = 5;     <span class="comment">// maximum number of keepalive probes TCP should send before dropping the connection</span></div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__group__flags.html#ga0a4635737732c912058ff4dba668c1b2" title="soap_mode IO output flag value to keep the socket connection alive for SOAP_MAXKEEPALIVE message exch...">SOAP_IO_KEEPALIVE</a></code>, <code><a class="el" href="structsoap.html#a8c0822cb0399ed55de6c2a482171868f" title="User-definable value to set TCP_KEEPIDLE setsockopt (0 by default) ">soap::tcp_keep_idle</a></code>, <code><a class="el" href="structsoap.html#a822aba3e7ae74fa86277c683569f80ae" title="User-definable value to set TCP_KEEPINTVL setsockopt (0 by default) ">soap::tcp_keep_intvl</a></code> and <code><a class="el" href="structsoap.html#a811041faab1cf481e7e656f81dc88901" title="User-definable value to set TCP_KEEPCNT setsockopt (0 by default) ">soap::tcp_keep_cnt</a></code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a811041faab1cf481e7e656f81dc88901"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int soap::tcp_keep_cnt</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User-definable value to set <code>TCP_KEEPCNT</code> <code>setsockopt</code> (0 by default) </p>
<dl class="section user"><dt>Example:</dt><dd></dd></dl>
<div class="fragment"><div class="line"><span class="keyword">struct </span>soap *soap = <a class="code" href="group__group__context.html#ga87c20488b2dc680aaa7689b1d024989c">soap_new</a>();</div><div class="line">soap-&gt;<a class="code" href="structsoap.html#af8f80a7bd8c09335c6fb836a612231bb">tcp_keep_alive</a> = 1;   <span class="comment">// setsockopt SO_KEEPALIVE</span></div><div class="line">soap-&gt;<a class="code" href="structsoap.html#a8c0822cb0399ed55de6c2a482171868f">tcp_keep_idle</a> = 30;   <span class="comment">// time in seconds the connection needs to remain idle before TCP starts sending keepalive probes</span></div><div class="line">soap-&gt;<a class="code" href="structsoap.html#a822aba3e7ae74fa86277c683569f80ae">tcp_keep_intvl</a> = 120; <span class="comment">// time in seconds between individual keepalive probes</span></div><div class="line">soap-&gt;<a class="code" href="structsoap.html#a811041faab1cf481e7e656f81dc88901">tcp_keep_cnt</a> = 5;     <span class="comment">// maximum number of keepalive probes TCP should send before dropping the connection</span></div></div><!-- fragment --><p>HTTP keep-alive with TCP <code>SO_KEEPALIVE</code> is enabled with:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>soap *soap = <a class="code" href="group__group__context.html#ga51cde138234ed7ec8c4e25bdf6418658">soap_new1</a>(<a class="code" href="group__group__flags.html#ga0a4635737732c912058ff4dba668c1b2">SOAP_IO_KEEPALIVE</a>); <span class="comment">// enable HTTP keep-alive</span></div><div class="line">soap-&gt;<a class="code" href="structsoap.html#a1d7aca6ac1d62302102c17508a8b0ec0">max_keep_alive</a> = 50;  <span class="comment">// 50 max keep-alive exchanges (SOAP_MAXKEEPALIVE by default)</span></div><div class="line">soap-&gt;<a class="code" href="structsoap.html#a8c0822cb0399ed55de6c2a482171868f">tcp_keep_idle</a> = 30;   <span class="comment">// time in seconds the connection needs to remain idle before TCP starts sending keepalive probes</span></div><div class="line">soap-&gt;<a class="code" href="structsoap.html#a822aba3e7ae74fa86277c683569f80ae">tcp_keep_intvl</a> = 120; <span class="comment">// time in seconds between individual keepalive probes</span></div><div class="line">soap-&gt;<a class="code" href="structsoap.html#a811041faab1cf481e7e656f81dc88901">tcp_keep_cnt</a> = 5;     <span class="comment">// maximum number of keepalive probes TCP should send before dropping the connection</span></div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><code><a class="el" href="structsoap.html#af8f80a7bd8c09335c6fb836a612231bb" title="User-definable value to set SO_KEEPALIVE setsockopt (0 by default unless the SOAP_IO_KEEPALIVE mode f...">soap::tcp_keep_alive</a></code>, <code><a class="el" href="structsoap.html#a8c0822cb0399ed55de6c2a482171868f" title="User-definable value to set TCP_KEEPIDLE setsockopt (0 by default) ">soap::tcp_keep_idle</a></code> and <code><a class="el" href="structsoap.html#a822aba3e7ae74fa86277c683569f80ae" title="User-definable value to set TCP_KEEPINTVL setsockopt (0 by default) ">soap::tcp_keep_intvl</a></code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a8c0822cb0399ed55de6c2a482171868f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int soap::tcp_keep_idle</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User-definable value to set <code>TCP_KEEPIDLE</code> <code>setsockopt</code> (0 by default) </p>
<dl class="section user"><dt>Example:</dt><dd></dd></dl>
<div class="fragment"><div class="line"><span class="keyword">struct </span>soap *soap = <a class="code" href="group__group__context.html#ga87c20488b2dc680aaa7689b1d024989c">soap_new</a>();</div><div class="line">soap-&gt;<a class="code" href="structsoap.html#af8f80a7bd8c09335c6fb836a612231bb">tcp_keep_alive</a> = 1;   <span class="comment">// setsockopt SO_KEEPALIVE</span></div><div class="line">soap-&gt;<a class="code" href="structsoap.html#a8c0822cb0399ed55de6c2a482171868f">tcp_keep_idle</a> = 30;   <span class="comment">// time in seconds the connection needs to remain idle before TCP starts sending keepalive probes</span></div><div class="line">soap-&gt;<a class="code" href="structsoap.html#a822aba3e7ae74fa86277c683569f80ae">tcp_keep_intvl</a> = 120; <span class="comment">// time in seconds between individual keepalive probes</span></div><div class="line">soap-&gt;<a class="code" href="structsoap.html#a811041faab1cf481e7e656f81dc88901">tcp_keep_cnt</a> = 5;     <span class="comment">// maximum number of keepalive probes TCP should send before dropping the connection</span></div></div><!-- fragment --><p>HTTP keep-alive with TCP <code>SO_KEEPALIVE</code> is enabled with:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>soap *soap = <a class="code" href="group__group__context.html#ga51cde138234ed7ec8c4e25bdf6418658">soap_new1</a>(<a class="code" href="group__group__flags.html#ga0a4635737732c912058ff4dba668c1b2">SOAP_IO_KEEPALIVE</a>); <span class="comment">// enable HTTP keep-alive</span></div><div class="line">soap-&gt;<a class="code" href="structsoap.html#a1d7aca6ac1d62302102c17508a8b0ec0">max_keep_alive</a> = 50;  <span class="comment">// 50 max keep-alive exchanges (SOAP_MAXKEEPALIVE by default)</span></div><div class="line">soap-&gt;<a class="code" href="structsoap.html#a8c0822cb0399ed55de6c2a482171868f">tcp_keep_idle</a> = 30;   <span class="comment">// time in seconds the connection needs to remain idle before TCP starts sending keepalive probes</span></div><div class="line">soap-&gt;<a class="code" href="structsoap.html#a822aba3e7ae74fa86277c683569f80ae">tcp_keep_intvl</a> = 120; <span class="comment">// time in seconds between individual keepalive probes</span></div><div class="line">soap-&gt;<a class="code" href="structsoap.html#a811041faab1cf481e7e656f81dc88901">tcp_keep_cnt</a> = 5;     <span class="comment">// maximum number of keepalive probes TCP should send before dropping the connection</span></div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><code><a class="el" href="structsoap.html#af8f80a7bd8c09335c6fb836a612231bb" title="User-definable value to set SO_KEEPALIVE setsockopt (0 by default unless the SOAP_IO_KEEPALIVE mode f...">soap::tcp_keep_alive</a></code>, <code><a class="el" href="structsoap.html#a822aba3e7ae74fa86277c683569f80ae" title="User-definable value to set TCP_KEEPINTVL setsockopt (0 by default) ">soap::tcp_keep_intvl</a></code> and <code><a class="el" href="structsoap.html#a811041faab1cf481e7e656f81dc88901" title="User-definable value to set TCP_KEEPCNT setsockopt (0 by default) ">soap::tcp_keep_cnt</a></code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a822aba3e7ae74fa86277c683569f80ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int soap::tcp_keep_intvl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User-definable value to set <code>TCP_KEEPINTVL</code> <code>setsockopt</code> (0 by default) </p>
<dl class="section user"><dt>Example:</dt><dd></dd></dl>
<div class="fragment"><div class="line"><span class="keyword">struct </span>soap *soap = <a class="code" href="group__group__context.html#ga87c20488b2dc680aaa7689b1d024989c">soap_new</a>();</div><div class="line">soap-&gt;<a class="code" href="structsoap.html#af8f80a7bd8c09335c6fb836a612231bb">tcp_keep_alive</a> = 1;   <span class="comment">// setsockopt SO_KEEPALIVE</span></div><div class="line">soap-&gt;<a class="code" href="structsoap.html#a8c0822cb0399ed55de6c2a482171868f">tcp_keep_idle</a> = 30;   <span class="comment">// time in seconds the connection needs to remain idle before TCP starts sending keepalive probes</span></div><div class="line">soap-&gt;<a class="code" href="structsoap.html#a822aba3e7ae74fa86277c683569f80ae">tcp_keep_intvl</a> = 120; <span class="comment">// time in seconds between individual keepalive probes</span></div><div class="line">soap-&gt;<a class="code" href="structsoap.html#a811041faab1cf481e7e656f81dc88901">tcp_keep_cnt</a> = 5;     <span class="comment">// maximum number of keepalive probes TCP should send before dropping the connection</span></div></div><!-- fragment --><p>HTTP keep-alive with TCP <code>SO_KEEPALIVE</code> is enabled with:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>soap *soap = <a class="code" href="group__group__context.html#ga51cde138234ed7ec8c4e25bdf6418658">soap_new1</a>(<a class="code" href="group__group__flags.html#ga0a4635737732c912058ff4dba668c1b2">SOAP_IO_KEEPALIVE</a>); <span class="comment">// enable HTTP keep-alive</span></div><div class="line">soap-&gt;<a class="code" href="structsoap.html#a1d7aca6ac1d62302102c17508a8b0ec0">max_keep_alive</a> = 50;  <span class="comment">// 50 max keep-alive exchanges (SOAP_MAXKEEPALIVE by default)</span></div><div class="line">soap-&gt;<a class="code" href="structsoap.html#a8c0822cb0399ed55de6c2a482171868f">tcp_keep_idle</a> = 30;   <span class="comment">// time in seconds the connection needs to remain idle before TCP starts sending keepalive probes</span></div><div class="line">soap-&gt;<a class="code" href="structsoap.html#a822aba3e7ae74fa86277c683569f80ae">tcp_keep_intvl</a> = 120; <span class="comment">// time in seconds between individual keepalive probes</span></div><div class="line">soap-&gt;<a class="code" href="structsoap.html#a811041faab1cf481e7e656f81dc88901">tcp_keep_cnt</a> = 5;     <span class="comment">// maximum number of keepalive probes TCP should send before dropping the connection</span></div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><code><a class="el" href="structsoap.html#af8f80a7bd8c09335c6fb836a612231bb" title="User-definable value to set SO_KEEPALIVE setsockopt (0 by default unless the SOAP_IO_KEEPALIVE mode f...">soap::tcp_keep_alive</a></code>, <code><a class="el" href="structsoap.html#a8c0822cb0399ed55de6c2a482171868f" title="User-definable value to set TCP_KEEPIDLE setsockopt (0 by default) ">soap::tcp_keep_idle</a></code> and <code><a class="el" href="structsoap.html#a811041faab1cf481e7e656f81dc88901" title="User-definable value to set TCP_KEEPCNT setsockopt (0 by default) ">soap::tcp_keep_cnt</a></code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a194bcafed0c3e368b92f452fc80b2d31"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char soap::tmpbuf[<a class="el" href="group__group__soap.html#ga92d654b655b8aca035c8281a836f495f">SOAP_TMPLEN</a>]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Internal buffer to hold temporary strings such as string representations of primitive values, XML tag names, HTTP header lines and so on, must have at least <code><a class="el" href="group__group__soap.html#ga92d654b655b8aca035c8281a836f495f" title="User-definable maximum length of temporary string values stored in soap::msgbuf and soap::tmpbuf...">SOAP_TMPLEN</a></code> = 1024 bytes of space allocated. </p>

</div>
</div>
<a class="anchor" id="afcf1d236d052579122f785d7639c43c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soap::transfer_timeout</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User-definable timeout to send or receive an entire message, positive timeout values are seconds, negative timeout values are microseconds, zero means no timeout (0 by default) </p>
<dl class="section user"><dt>Example:</dt><dd></dd></dl>
<div class="fragment"><div class="line"><span class="keyword">struct </span>soap *soap = <a class="code" href="group__group__context.html#ga87c20488b2dc680aaa7689b1d024989c">soap_new</a>();</div><div class="line">soap-&gt;<a class="code" href="structsoap.html#a711bb3a53de7cc62429e4d3a2e0b5474">send_timeout</a> = soap_recv_timeout = 5; <span class="comment">// 5 seconds max socket stall time (unlimited by default)</span></div><div class="line">soap-&gt;<a class="code" href="structsoap.html#afcf1d236d052579122f785d7639c43c7">transfer_timeout</a> = 30;                <span class="comment">// 30 seconds max message transfer time (unlimited by default)</span></div><div class="line">soap-&gt;<a class="code" href="structsoap.html#a345900c2db67e915ceb02bfa21ecbcbd">recv_maxlength</a> = 1048576;             <span class="comment">// limit messages received to 1MB (2GB by default)</span></div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><code><a class="el" href="structsoap.html#ab85f5d42702963d13ea540bd9876e6d2" title="The soap context soap_status (int) error code of the last operation or SOAP_OK (zero) ...">soap::error</a></code>, <code><a class="el" href="structsoap.html#a10b66d6d489690b7d0f591ae2633dd13" title="The errno value of the last failed IO operation. ">soap::errnum</a></code>, <code><a class="el" href="structsoap.html#af32b5f3975eac2bd1202571515859163" title="User-definable timeout when waiting to connect to a server at the client-side, positive timeout value...">soap::connect_timeout</a></code>, <code><a class="el" href="structsoap.html#a78199a81c504833047224a0ceff6f906" title="User-definable timeout when waiting to accept a request from a client at the server-side with soap_ac...">soap::accept_timeout</a></code>, <code><a class="el" href="structsoap.html#ac5d5fb92fffda724ccb3b038d2bb2388" title="User-definable timeout to receive a packet of data, positive timeout values are seconds, negative timeout values are microseconds, zero means no timeout (0 by default) ">soap::recv_timeout</a></code>, <code><a class="el" href="structsoap.html#a711bb3a53de7cc62429e4d3a2e0b5474" title="User-definable timeout to send a packet of data, positive timeout values are seconds, negative timeout values are microseconds, zero means no timeout (0 by default) ">soap::send_timeout</a></code>, <code><a class="el" href="structsoap.html#a345900c2db67e915ceb02bfa21ecbcbd" title="User-definable maximum message length that is permitted to be received, zero means unlimited (2GB by ...">soap::recv_maxlength</a></code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a8eb35c04359a567c0b5e2664f3f94d5b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* soap::user</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User-definable variable that may point to user-specified data to pass the data through callbacks and plugins to the user's code. </p>

</div>
</div>
<a class="anchor" id="a2ede02095d98942f4c220fd17b495703"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* soap::userid</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User-definable HTTP and NTLM authorization user id string for HTTP basic and NTLM authentication by the client, server side receives this string when the client uses HTTP basic authentication, for HTTP digest authentication see the gSOAP HTTP digest authentication plugin. </p>
<dl class="section user"><dt>Examples:</dt><dd></dd></dl>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;soapH.h&quot;</span></div><div class="line"><span class="keyword">struct </span>soap *soap = <a class="code" href="group__group__context.html#ga87c20488b2dc680aaa7689b1d024989c">soap_new</a>();</div><div class="line"><span class="keywordflow">if</span> (<a class="code" href="group__group__ssl.html#ga269c7732b1cda9dc79db08fcbf1d5438">soap_ssl_client_context</a>(soap, ...))</div><div class="line">  exit(EXIT_FAILURE);</div><div class="line">soap-&gt;<a class="code" href="structsoap.html#a2ede02095d98942f4c220fd17b495703">userid</a> = <span class="stringliteral">&quot;user-id&quot;</span>; <span class="comment">// HTTP basic auth credential</span></div><div class="line">soap-&gt;<a class="code" href="structsoap.html#a22d219c98f0fcf456641277cc64174a3">passwd</a> = <span class="stringliteral">&quot;user-pw&quot;</span>; <span class="comment">// HTTP basic auth credential</span></div><div class="line">soap-&gt;<a class="code" href="structsoap.html#a8dbe57d59f683d99305a44b4d7939bfd">authrealm</a> = <span class="stringliteral">&quot;server-domain&quot;</span>; <span class="comment">// if known in advance, see example below</span></div><div class="line"><span class="keywordflow">if</span> (soap_call_ns__webmethod(soap, <a class="code" href="structsoap.html#aed1b86b8a34aea86103751a932c9dce9">endpoint</a>, NULL, ...))</div><div class="line">  <a class="code" href="group__group__fault.html#ga931a4ab6df2553b48a0c270f8a0a88af">soap_print_fault</a>(soap, stderr);</div><div class="line"><span class="keywordflow">else</span></div><div class="line">  ... <span class="comment">// success</span></div><div class="line"><a class="code" href="group__group__context.html#gaf7d0176161e9def36981e24faa1913d9">soap_destroy</a>(soap);</div><div class="line"><a class="code" href="group__group__context.html#ga81a009ae1ea825a05e5241e2b7a8ece9">soap_end</a>(soap);</div><div class="line"><a class="code" href="group__group__context.html#ga57108ca4681186e58b5b189c3528f10a">soap_free</a>(soap);</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;soapH.h&quot;</span></div><div class="line"><span class="keyword">struct </span>soap *soap = <a class="code" href="group__group__context.html#ga87c20488b2dc680aaa7689b1d024989c">soap_new</a>();</div><div class="line"><span class="keywordflow">if</span> (<a class="code" href="group__group__ssl.html#ga269c7732b1cda9dc79db08fcbf1d5438">soap_ssl_client_context</a>(soap, ...))</div><div class="line">  exit(EXIT_FAILURE);</div><div class="line"><span class="keywordflow">if</span> (soap_call_ns__webmethod(soap, <a class="code" href="structsoap.html#aed1b86b8a34aea86103751a932c9dce9">endpoint</a>, NULL, ...) == 401) <span class="comment">// Unauthorized, got soap-&gt;authrealm</span></div><div class="line">{</div><div class="line">  soap-&gt;<a class="code" href="structsoap.html#a2ede02095d98942f4c220fd17b495703">userid</a> = <span class="stringliteral">&quot;user-id&quot;</span>; <span class="comment">// HTTP basic auth credential</span></div><div class="line">  soap-&gt;<a class="code" href="structsoap.html#a22d219c98f0fcf456641277cc64174a3">passwd</a> = <span class="stringliteral">&quot;user-pw&quot;</span>; <span class="comment">// HTTP basic auth credential</span></div><div class="line">  <span class="keywordflow">if</span> (soap_call_ns__webmethod(soap, <a class="code" href="structsoap.html#aed1b86b8a34aea86103751a932c9dce9">endpoint</a>, NULL, ...)) <span class="comment">// try again</span></div><div class="line">    <a class="code" href="group__group__fault.html#ga931a4ab6df2553b48a0c270f8a0a88af">soap_print_fault</a>(soap, stderr);</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    ... <span class="comment">// success</span></div><div class="line">}</div><div class="line"><span class="keywordflow">else</span></div><div class="line">{</div><div class="line">  ... <span class="comment">// success</span></div><div class="line">}</div><div class="line"><a class="code" href="group__group__context.html#gaf7d0176161e9def36981e24faa1913d9">soap_destroy</a>(soap);</div><div class="line"><a class="code" href="group__group__context.html#ga81a009ae1ea825a05e5241e2b7a8ece9">soap_end</a>(soap);</div><div class="line"><a class="code" href="group__group__context.html#ga57108ca4681186e58b5b189c3528f10a">soap_free</a>(soap);</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;soapH.h&quot;</span></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keyword">struct </span>soap *soap = <a class="code" href="group__group__context.html#ga87c20488b2dc680aaa7689b1d024989c">soap_new</a>();</div><div class="line">  <span class="keywordflow">if</span> (<a class="code" href="group__group__ssl.html#ga3492465cdd8aa71fe746199d3842cac7">soap_ssl_server_context</a>(soap, ...))</div><div class="line">    exit(EXIT_FAILURE);</div><div class="line">  ... <span class="comment">// serve requests with soap_bind, soap_accept, soap_ssl_accept, and soap_serve</span></div><div class="line">}</div><div class="line"><span class="keywordtype">int</span> ns__webmethod(<span class="keyword">struct</span> soap *soap, ...)</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> (!soap-&gt;<a class="code" href="structsoap.html#a2ede02095d98942f4c220fd17b495703">userid</a> ||</div><div class="line">      !soap-&gt;<a class="code" href="structsoap.html#a22d219c98f0fcf456641277cc64174a3">passwd</a> ||</div><div class="line">      !soap-&gt;<a class="code" href="structsoap.html#a8dbe57d59f683d99305a44b4d7939bfd">authrealm</a> ||</div><div class="line">      strcmp(soap-&gt;<a class="code" href="structsoap.html#a2ede02095d98942f4c220fd17b495703">userid</a>, <span class="stringliteral">&quot;user-id&quot;</span>) ||</div><div class="line">      strcmp(soap-&gt;<a class="code" href="structsoap.html#a22d219c98f0fcf456641277cc64174a3">passwd</a>, <span class="stringliteral">&quot;user-pw&quot;</span>) ||</div><div class="line">      strcmp(soap-&gt;<a class="code" href="structsoap.html#a8dbe57d59f683d99305a44b4d7939bfd">authrealm</a>, <span class="stringliteral">&quot;server-domain&quot;</span>))</div><div class="line">    <span class="keywordflow">return</span> 401; <span class="comment">// Unauthorized</span></div><div class="line">  ... <span class="comment">// process the request data and populate the response data</span></div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="group__group__errors.html#ga3b10a68f354f39cbb0fe0d043ad4c7c0">SOAP_OK</a>;</div><div class="line">}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><code><a class="el" href="structsoap.html#a22d219c98f0fcf456641277cc64174a3" title="User-definable HTTP and NTLM authorization password string required for HTTP basic and NTLM authentic...">soap::passwd</a></code>, <code><a class="el" href="structsoap.html#a8dbe57d59f683d99305a44b4d7939bfd" title="The HTTP and NTLM authorization realm/domain string received by the client with the WWW-Authenticate ...">soap::authrealm</a></code>, <code><a class="el" href="group__group__ssl.html#ga269c7732b1cda9dc79db08fcbf1d5438" title="Initialize the client-side SSL/TLS context. ">soap_ssl_client_context</a></code>, <code><a class="el" href="structsoap.html#a5213a5328b44244689fd3c2937cc8b92" title="User-definable HTTP authorization bearer token value to be sent by the client, server side receives t...">soap::bearer</a></code>, <code><a class="el" href="structsoap.html#af2c9e77616c132831ebf041d9e4d18b1" title="User-definable NTLM authentication challenge key string. ">soap::ntlm_challenge</a></code>, <code><a class="el" href="structsoap.html#afb22ae0a494a35268914286bd00446ab" title="User-definable string that specifies an extra HTTP header or headers when separated by CRLF...">soap::http_extra_header</a></code>, <code><a class="el" href="structsoap.html#a7e7e9e9d65bba6237298cf2ed7cec599" title="User-definable proxy authorization user id string to authenticate and connect to an HTTP proxy...">soap::proxy_userid</a></code>, <code><a class="el" href="structsoap.html#ad75a4abe119a1a74a26d06401fa11c3a" title="User-definable proxy authorization password string to authenticate and connect to an HTTP proxy...">soap::proxy_passwd</a></code> and the <a href="../../httpda/html/httpda.html">HTTP digest plugin</a> documentation. </dd></dl>

</div>
</div>
<a class="anchor" id="a39daa19f039aebc76b8c4b6bf933570a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">short soap::version</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SOAP version (0 = no SOAP, 1 = SOAP 1.1, 2 = SOAP 1.2) </p>
<p>The SOAP version is determined from the SOAP or XML message received. The version is automatically set before sending messages when SOAP 1.1 or SOAP 1.2 namespaces are defined in the <code><a class="el" href="struct_namespace.html" title="Structure of each row in a namespace table. ">Namespace</a></code> table or when SOAP namespaces are omitted from the table. The version can be explicitly set or overruled by calling <code><a class="el" href="group__group__context.html#ga7c0a034b54cd46ee06ce1253e5a40467" title="Set SOAP version (0 = no SOAP, 1 = SOAP 1.1, 2 = SOAP 1.2) ">soap_set_version</a></code>.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="structsoap.html#a6b86360871d347d0a5f18a231fa82dc8" title="User-definable SOAP-ENV:encodingStyle URI value. ">soap::encodingStyle</a></code>, <code><a class="el" href="group__group__context.html#ga7c0a034b54cd46ee06ce1253e5a40467" title="Set SOAP version (0 = no SOAP, 1 = SOAP 1.1, 2 = SOAP 1.2) ">soap_set_version</a></code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a9fae46446ebcb1a51417f2c0c1db31f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned short soap::z_level</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User-definable compression level for gzip compression (0=none, 1=fast to 9=best) default level is 6. </p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__group__with.html#gad30a07ea604aea8cb00f41f6310cf30f" title="When this macro is defined at compile time (undefined by default), enables linkage with the zlib libr...">WITH_GZIP</a></code>, <code><a class="el" href="group__group__with.html#gad2cdc1f87f3fc46b92e957d9e251797c" title="When this macro is defined at compile time (undefined by default), enables linking the zlib library f...">WITH_ZLIB</a></code>, <code><a class="el" href="group__group__flags.html#gafa62be7ba46b50d58608a066f442c2a8" title="soap_mode ENC output flag value to compress messages sent, requires zlib enabled with compile-time fl...">SOAP_ENC_ZLIB</a></code>, <code><a class="el" href="structsoap.html#a6cc15a11a897cde81f4303866df747ac" title="The compression ratio = compressed.size/uncompressed.size of the compressed message received...">soap::z_ratio_in</a></code>, <code><a class="el" href="structsoap.html#ab9d0aab0f89e2109ba02ca460c219541" title="The compression ratio = compressed.size/uncompressed.size of the compressed message sent...">soap::z_ratio_out</a></code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a6cc15a11a897cde81f4303866df747ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float soap::z_ratio_in</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The compression ratio = compressed.size/uncompressed.size of the compressed message received. </p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__group__with.html#gad30a07ea604aea8cb00f41f6310cf30f" title="When this macro is defined at compile time (undefined by default), enables linkage with the zlib libr...">WITH_GZIP</a></code>, <code><a class="el" href="group__group__with.html#gad2cdc1f87f3fc46b92e957d9e251797c" title="When this macro is defined at compile time (undefined by default), enables linking the zlib library f...">WITH_ZLIB</a></code>, <code><a class="el" href="group__group__flags.html#gafa62be7ba46b50d58608a066f442c2a8" title="soap_mode ENC output flag value to compress messages sent, requires zlib enabled with compile-time fl...">SOAP_ENC_ZLIB</a></code>, <code><a class="el" href="structsoap.html#a9fae46446ebcb1a51417f2c0c1db31f8" title="User-definable compression level for gzip compression (0=none, 1=fast to 9=best) default level is 6...">soap::z_level</a></code>, <code><a class="el" href="structsoap.html#ab9d0aab0f89e2109ba02ca460c219541" title="The compression ratio = compressed.size/uncompressed.size of the compressed message sent...">soap::z_ratio_out</a></code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ab9d0aab0f89e2109ba02ca460c219541"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float soap::z_ratio_out</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The compression ratio = compressed.size/uncompressed.size of the compressed message sent. </p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__group__with.html#gad30a07ea604aea8cb00f41f6310cf30f" title="When this macro is defined at compile time (undefined by default), enables linkage with the zlib libr...">WITH_GZIP</a></code>, <code><a class="el" href="group__group__with.html#gad2cdc1f87f3fc46b92e957d9e251797c" title="When this macro is defined at compile time (undefined by default), enables linking the zlib library f...">WITH_ZLIB</a></code>, <code><a class="el" href="group__group__flags.html#gafa62be7ba46b50d58608a066f442c2a8" title="soap_mode ENC output flag value to compress messages sent, requires zlib enabled with compile-time fl...">SOAP_ENC_ZLIB</a></code>, <code><a class="el" href="structsoap.html#a9fae46446ebcb1a51417f2c0c1db31f8" title="User-definable compression level for gzip compression (0=none, 1=fast to 9=best) default level is 6...">soap::z_level</a></code>, <code><a class="el" href="structsoap.html#a6cc15a11a897cde81f4303866df747ac" title="The compression ratio = compressed.size/uncompressed.size of the compressed message received...">soap::z_ratio_in</a></code>. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<hr class="footer">
<address class="footer">
Copyright (C) 2018, Robert van Engelen, Genivia Inc., All Rights Reserved.
</address>
<address class="footer"><small>
Converted on Tue Dec 11 2018 14:04:26 by <a target="_blank" href="http://www.doxygen.org/index.html">Doxygen</a> 1.8.11</small></address>
<br>
<div style="height: 246px; background: #DBDBDB;">
</body>
</html>
