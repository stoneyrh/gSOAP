<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8">
<meta http-equiv="cache-control" content="no-cache">
<title>Genivia - Context with engine state</title>
<link href="genivia_tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="genivia_content.css" rel="stylesheet" type="text/css">
</head>
<body>
<div id="top">
 <div id="titlearea">
  <table height="72px" width="100%" cellspacing="0" cellpadding="0">
   <tbody>
    <tr>
     <td width="10%">&nbsp;</td>
     <td width="175px"><a href="https://www.genivia.com"><img alt="Genivia" src="GeniviaLogo2_trans_noslogan.png"/></a></td>
     <td class="tab_home"><a href="https://www.genivia.com">Home</a></td>
     <td class="tab_home"><a href="https://www.genivia.com/docs.html">Documentation</a></td>
     <td>
      <div style="float: right; font-size: 18px; font-weight: bold;">Context with engine state</div>
      <br>
      <div style="float: right; font-size: 10px;">updated Tue Apr 20 2021 by Robert van Engelen</div>
     </td>
     <td width="10%">&nbsp;</td>
    </tr>
   </tbody>
  </table>
 </div>
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__group__context.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Context with engine state</div>  </div>
</div><!--header-->
<div class="contents">

<p>This module defines the <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> <a class="el" href="structsoap.html">context structure with the engine state</a> and functions to allocate, initialize, copy and delete contexts.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsoap.html">soap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Context with the engine state.  <a href="structsoap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga5c62d26b4823b76c5b4ef29e7865d3f0"><td class="memItemLeft" align="right" valign="top">typedef char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__context.html#ga5c62d26b4823b76c5b4ef29e7865d3f0">_XML</a></td></tr>
<tr class="memdesc:ga5c62d26b4823b76c5b4ef29e7865d3f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A built-in string type containing literal XML content in UTF-8 format.  <a href="#ga5c62d26b4823b76c5b4ef29e7865d3f0">More...</a><br /></td></tr>
<tr class="separator:ga5c62d26b4823b76c5b4ef29e7865d3f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa178a46d0cf703ff226a5c148483286d"><td class="memItemLeft" align="right" valign="top">typedef char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__context.html#gaa178a46d0cf703ff226a5c148483286d">_QName</a></td></tr>
<tr class="memdesc:gaa178a46d0cf703ff226a5c148483286d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A built-in string type containing normalized QName contents.  <a href="#gaa178a46d0cf703ff226a5c148483286d">More...</a><br /></td></tr>
<tr class="separator:gaa178a46d0cf703ff226a5c148483286d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga87c20488b2dc680aaa7689b1d024989c"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structsoap.html">soap</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__context.html#ga87c20488b2dc680aaa7689b1d024989c">soap_new</a> ()</td></tr>
<tr class="memdesc:ga87c20488b2dc680aaa7689b1d024989c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate and initialize a new <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context.  <a href="#ga87c20488b2dc680aaa7689b1d024989c">More...</a><br /></td></tr>
<tr class="separator:ga87c20488b2dc680aaa7689b1d024989c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51cde138234ed7ec8c4e25bdf6418658"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structsoap.html">soap</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__context.html#ga51cde138234ed7ec8c4e25bdf6418658">soap_new1</a> (<a class="el" href="group__group__flags.html#ga72b0491c9cbf2071f0c96c7d29b719bb">soap_mode</a> input_and_output_mode)</td></tr>
<tr class="memdesc:ga51cde138234ed7ec8c4e25bdf6418658"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate and initialize a new <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context with input and output <code><a class="el" href="group__group__flags.html#ga72b0491c9cbf2071f0c96c7d29b719bb" title="The soap_mode flags to initialize the soap context, flags can be combined with | (bit-wise or) ...">soap_mode</a></code> flags.  <a href="#ga51cde138234ed7ec8c4e25bdf6418658">More...</a><br /></td></tr>
<tr class="separator:ga51cde138234ed7ec8c4e25bdf6418658"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12a87f6795b62b05164edc392b2adb1d"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structsoap.html">soap</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__context.html#ga12a87f6795b62b05164edc392b2adb1d">soap_new2</a> (<a class="el" href="group__group__flags.html#ga72b0491c9cbf2071f0c96c7d29b719bb">soap_mode</a> input_mode, <a class="el" href="group__group__flags.html#ga72b0491c9cbf2071f0c96c7d29b719bb">soap_mode</a> output_mode)</td></tr>
<tr class="memdesc:ga12a87f6795b62b05164edc392b2adb1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate and initialize a new <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context with separate input and output <code><a class="el" href="group__group__flags.html#ga72b0491c9cbf2071f0c96c7d29b719bb" title="The soap_mode flags to initialize the soap context, flags can be combined with | (bit-wise or) ...">soap_mode</a></code> flags.  <a href="#ga12a87f6795b62b05164edc392b2adb1d">More...</a><br /></td></tr>
<tr class="separator:ga12a87f6795b62b05164edc392b2adb1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e034e1a7d6093eaddc11b647179657c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__context.html#ga8e034e1a7d6093eaddc11b647179657c">soap_init</a> (struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>)</td></tr>
<tr class="memdesc:ga8e034e1a7d6093eaddc11b647179657c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a stack-allocated <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context.  <a href="#ga8e034e1a7d6093eaddc11b647179657c">More...</a><br /></td></tr>
<tr class="separator:ga8e034e1a7d6093eaddc11b647179657c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac87126c3e45d2fda488e9832c2dd5be1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__context.html#gac87126c3e45d2fda488e9832c2dd5be1">soap_init1</a> (struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, <a class="el" href="group__group__flags.html#ga72b0491c9cbf2071f0c96c7d29b719bb">soap_mode</a> input_and_output_mode)</td></tr>
<tr class="memdesc:gac87126c3e45d2fda488e9832c2dd5be1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a stack-allocated <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context with input and output <code><a class="el" href="group__group__flags.html#ga72b0491c9cbf2071f0c96c7d29b719bb" title="The soap_mode flags to initialize the soap context, flags can be combined with | (bit-wise or) ...">soap_mode</a></code> flags.  <a href="#gac87126c3e45d2fda488e9832c2dd5be1">More...</a><br /></td></tr>
<tr class="separator:gac87126c3e45d2fda488e9832c2dd5be1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c70b587fc4f65553cfe69751d1a157e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__context.html#ga3c70b587fc4f65553cfe69751d1a157e">soap_init2</a> (struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, <a class="el" href="group__group__flags.html#ga72b0491c9cbf2071f0c96c7d29b719bb">soap_mode</a> input_mode, <a class="el" href="group__group__flags.html#ga72b0491c9cbf2071f0c96c7d29b719bb">soap_mode</a> output_mode)</td></tr>
<tr class="memdesc:ga3c70b587fc4f65553cfe69751d1a157e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a stack-allocated <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context with input and output <code><a class="el" href="group__group__flags.html#ga72b0491c9cbf2071f0c96c7d29b719bb" title="The soap_mode flags to initialize the soap context, flags can be combined with | (bit-wise or) ...">soap_mode</a></code> flags.  <a href="#ga3c70b587fc4f65553cfe69751d1a157e">More...</a><br /></td></tr>
<tr class="separator:ga3c70b587fc4f65553cfe69751d1a157e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84f52a67a41009b260ff2c036df7f6ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__context.html#ga84f52a67a41009b260ff2c036df7f6ab">soap_set_mode</a> (struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, <a class="el" href="group__group__flags.html#ga72b0491c9cbf2071f0c96c7d29b719bb">soap_mode</a> input_and_output_mode)</td></tr>
<tr class="memdesc:ga84f52a67a41009b260ff2c036df7f6ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set input and output <code><a class="el" href="group__group__flags.html#ga72b0491c9cbf2071f0c96c7d29b719bb" title="The soap_mode flags to initialize the soap context, flags can be combined with | (bit-wise or) ...">soap_mode</a></code> flags of the given <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context.  <a href="#ga84f52a67a41009b260ff2c036df7f6ab">More...</a><br /></td></tr>
<tr class="separator:ga84f52a67a41009b260ff2c036df7f6ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9b0819dae844b848bcd8a3598a301aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__context.html#gaa9b0819dae844b848bcd8a3598a301aa">soap_set_imode</a> (struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, <a class="el" href="group__group__flags.html#ga72b0491c9cbf2071f0c96c7d29b719bb">soap_mode</a> input_mode)</td></tr>
<tr class="memdesc:gaa9b0819dae844b848bcd8a3598a301aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set input <code><a class="el" href="group__group__flags.html#ga72b0491c9cbf2071f0c96c7d29b719bb" title="The soap_mode flags to initialize the soap context, flags can be combined with | (bit-wise or) ...">soap_mode</a></code> flags of the given <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context.  <a href="#gaa9b0819dae844b848bcd8a3598a301aa">More...</a><br /></td></tr>
<tr class="separator:gaa9b0819dae844b848bcd8a3598a301aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6fa6e197f360834eae124fa37e68cf7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__context.html#gaf6fa6e197f360834eae124fa37e68cf7">soap_set_omode</a> (struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, <a class="el" href="group__group__flags.html#ga72b0491c9cbf2071f0c96c7d29b719bb">soap_mode</a> output_mode)</td></tr>
<tr class="memdesc:gaf6fa6e197f360834eae124fa37e68cf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set output <code><a class="el" href="group__group__flags.html#ga72b0491c9cbf2071f0c96c7d29b719bb" title="The soap_mode flags to initialize the soap context, flags can be combined with | (bit-wise or) ...">soap_mode</a></code> flags of the given <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context.  <a href="#gaf6fa6e197f360834eae124fa37e68cf7">More...</a><br /></td></tr>
<tr class="separator:gaf6fa6e197f360834eae124fa37e68cf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06f769f80bcea7beb2ebffd0a40fc521"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__context.html#ga06f769f80bcea7beb2ebffd0a40fc521">soap_clr_mode</a> (struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, <a class="el" href="group__group__flags.html#ga72b0491c9cbf2071f0c96c7d29b719bb">soap_mode</a> input_and_output_mode)</td></tr>
<tr class="memdesc:ga06f769f80bcea7beb2ebffd0a40fc521"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear input and output <code><a class="el" href="group__group__flags.html#ga72b0491c9cbf2071f0c96c7d29b719bb" title="The soap_mode flags to initialize the soap context, flags can be combined with | (bit-wise or) ...">soap_mode</a></code> flags of the given <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context.  <a href="#ga06f769f80bcea7beb2ebffd0a40fc521">More...</a><br /></td></tr>
<tr class="separator:ga06f769f80bcea7beb2ebffd0a40fc521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e789bd6c2f76609aec0c9f93d121e4c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__context.html#ga0e789bd6c2f76609aec0c9f93d121e4c">soap_clr_imode</a> (struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, <a class="el" href="group__group__flags.html#ga72b0491c9cbf2071f0c96c7d29b719bb">soap_mode</a> input_mode)</td></tr>
<tr class="memdesc:ga0e789bd6c2f76609aec0c9f93d121e4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear input <code><a class="el" href="group__group__flags.html#ga72b0491c9cbf2071f0c96c7d29b719bb" title="The soap_mode flags to initialize the soap context, flags can be combined with | (bit-wise or) ...">soap_mode</a></code> flags of the given <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context.  <a href="#ga0e789bd6c2f76609aec0c9f93d121e4c">More...</a><br /></td></tr>
<tr class="separator:ga0e789bd6c2f76609aec0c9f93d121e4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c28d2943bee7aa5c3ffaf32803b31bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__context.html#ga8c28d2943bee7aa5c3ffaf32803b31bd">soap_clr_omode</a> (struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, <a class="el" href="group__group__flags.html#ga72b0491c9cbf2071f0c96c7d29b719bb">soap_mode</a> output_mode)</td></tr>
<tr class="memdesc:ga8c28d2943bee7aa5c3ffaf32803b31bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear output <code><a class="el" href="group__group__flags.html#ga72b0491c9cbf2071f0c96c7d29b719bb" title="The soap_mode flags to initialize the soap context, flags can be combined with | (bit-wise or) ...">soap_mode</a></code> flags of the given <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context.  <a href="#ga8c28d2943bee7aa5c3ffaf32803b31bd">More...</a><br /></td></tr>
<tr class="separator:ga8c28d2943bee7aa5c3ffaf32803b31bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4c3f8ce80baf0f1fec8c86f0bb5788a"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structsoap.html">soap</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__context.html#gab4c3f8ce80baf0f1fec8c86f0bb5788a">soap_copy</a> (struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>)</td></tr>
<tr class="memdesc:gab4c3f8ce80baf0f1fec8c86f0bb5788a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate and initialize a new <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context as a copy of the given <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context.  <a href="#gab4c3f8ce80baf0f1fec8c86f0bb5788a">More...</a><br /></td></tr>
<tr class="separator:gab4c3f8ce80baf0f1fec8c86f0bb5788a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabcb00978a07439254c4dd44c6332b2bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__context.html#gabcb00978a07439254c4dd44c6332b2bf">soap_copy_context</a> (struct <a class="el" href="structsoap.html">soap</a> *soap_destination, struct <a class="el" href="structsoap.html">soap</a> *soap_source)</td></tr>
<tr class="memdesc:gabcb00978a07439254c4dd44c6332b2bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a given <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context to an uninitialized destination <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context.  <a href="#gabcb00978a07439254c4dd44c6332b2bf">More...</a><br /></td></tr>
<tr class="separator:gabcb00978a07439254c4dd44c6332b2bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3f0f1ab9bdd15a2db5cff3534ccd5cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__context.html#gad3f0f1ab9bdd15a2db5cff3534ccd5cc">soap_copy_stream</a> (struct <a class="el" href="structsoap.html">soap</a> *soap_destination, struct <a class="el" href="structsoap.html">soap</a> *soap_source)</td></tr>
<tr class="memdesc:gad3f0f1ab9bdd15a2db5cff3534ccd5cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the input/output stream state of the given <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context to another context.  <a href="#gad3f0f1ab9bdd15a2db5cff3534ccd5cc">More...</a><br /></td></tr>
<tr class="separator:gad3f0f1ab9bdd15a2db5cff3534ccd5cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7eade923b1556d7e947681e16a09aaa3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__context.html#ga7eade923b1556d7e947681e16a09aaa3">soap_free_stream</a> (struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>)</td></tr>
<tr class="memdesc:ga7eade923b1556d7e947681e16a09aaa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the input/output stream state of the given <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context.  <a href="#ga7eade923b1556d7e947681e16a09aaa3">More...</a><br /></td></tr>
<tr class="separator:ga7eade923b1556d7e947681e16a09aaa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57108ca4681186e58b5b189c3528f10a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__context.html#ga57108ca4681186e58b5b189c3528f10a">soap_free</a> (struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>)</td></tr>
<tr class="memdesc:ga57108ca4681186e58b5b189c3528f10a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize and free the given <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context from unmanaged heap memory.  <a href="#ga57108ca4681186e58b5b189c3528f10a">More...</a><br /></td></tr>
<tr class="separator:ga57108ca4681186e58b5b189c3528f10a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28ee8fdcf500443e0e51750324aa6a1a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__context.html#ga28ee8fdcf500443e0e51750324aa6a1a">soap_done</a> (struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>)</td></tr>
<tr class="memdesc:ga28ee8fdcf500443e0e51750324aa6a1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize the given <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context, i.e. when the <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context is stack allocated, automatically invoked in C++ by the <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> destructor on the <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context to delete.  <a href="#ga28ee8fdcf500443e0e51750324aa6a1a">More...</a><br /></td></tr>
<tr class="separator:ga28ee8fdcf500443e0e51750324aa6a1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba556710e010feeb2211ed43b5bf059c"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__context.html#gaba556710e010feeb2211ed43b5bf059c">soap_malloc</a> (struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, size_t len)</td></tr>
<tr class="memdesc:gaba556710e010feeb2211ed43b5bf059c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a block of heap memory managed by the specified <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context.  <a href="#gaba556710e010feeb2211ed43b5bf059c">More...</a><br /></td></tr>
<tr class="separator:gaba556710e010feeb2211ed43b5bf059c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41747ef145667bdff9c66cdd2bc86653"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__context.html#ga41747ef145667bdff9c66cdd2bc86653">soap_strdup</a> (struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, const char *string)</td></tr>
<tr class="memdesc:ga41747ef145667bdff9c66cdd2bc86653"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a string to managed memory.  <a href="#ga41747ef145667bdff9c66cdd2bc86653">More...</a><br /></td></tr>
<tr class="separator:ga41747ef145667bdff9c66cdd2bc86653"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fe9c27b0f0eac077bc13caf816fbba8"><td class="memItemLeft" align="right" valign="top">wchar_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__context.html#ga7fe9c27b0f0eac077bc13caf816fbba8">soap_wstrdup</a> (struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, const wchar_t *string)</td></tr>
<tr class="memdesc:ga7fe9c27b0f0eac077bc13caf816fbba8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a wide string to managed memory.  <a href="#ga7fe9c27b0f0eac077bc13caf816fbba8">More...</a><br /></td></tr>
<tr class="separator:ga7fe9c27b0f0eac077bc13caf816fbba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga643bb3cdc192ec0dc1a8448498dab401"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__context.html#ga643bb3cdc192ec0dc1a8448498dab401">soap_unlink</a> (struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, const void *ptr)</td></tr>
<tr class="memdesc:ga643bb3cdc192ec0dc1a8448498dab401"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlink a block of heap memory managed by the specified <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context, to release the memory explicitly later.  <a href="#ga643bb3cdc192ec0dc1a8448498dab401">More...</a><br /></td></tr>
<tr class="separator:ga643bb3cdc192ec0dc1a8448498dab401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7d0176161e9def36981e24faa1913d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__context.html#gaf7d0176161e9def36981e24faa1913d9">soap_destroy</a> (struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>)</td></tr>
<tr class="memdesc:gaf7d0176161e9def36981e24faa1913d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete all dynamically-allocated C++ objects managed by the specified <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context.  <a href="#gaf7d0176161e9def36981e24faa1913d9">More...</a><br /></td></tr>
<tr class="separator:gaf7d0176161e9def36981e24faa1913d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacdc44bad1fbf1851f3664b887e807c85"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__context.html#gacdc44bad1fbf1851f3664b887e807c85">soap_dealloc</a> (struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, void *ptr)</td></tr>
<tr class="memdesc:gacdc44bad1fbf1851f3664b887e807c85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly dealllocates a block of managed memory that is managed by the specified <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context and release the free memory back to the heap.  <a href="#gacdc44bad1fbf1851f3664b887e807c85">More...</a><br /></td></tr>
<tr class="separator:gacdc44bad1fbf1851f3664b887e807c85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace16239b47adccf9e4dc307cebe6a323"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__context.html#gace16239b47adccf9e4dc307cebe6a323">soap_free_temp</a> (struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>)</td></tr>
<tr class="memdesc:gace16239b47adccf9e4dc307cebe6a323"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete temporary data.  <a href="#gace16239b47adccf9e4dc307cebe6a323">More...</a><br /></td></tr>
<tr class="separator:gace16239b47adccf9e4dc307cebe6a323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81a009ae1ea825a05e5241e2b7a8ece9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__context.html#ga81a009ae1ea825a05e5241e2b7a8ece9">soap_end</a> (struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>)</td></tr>
<tr class="memdesc:ga81a009ae1ea825a05e5241e2b7a8ece9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete all data from heap memory managed by the specified <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context and release the freed memory back to the heap.  <a href="#ga81a009ae1ea825a05e5241e2b7a8ece9">More...</a><br /></td></tr>
<tr class="separator:ga81a009ae1ea825a05e5241e2b7a8ece9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa959ff61609f7b324527e88655c2377f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__context.html#gaa959ff61609f7b324527e88655c2377f">soap_delegate_deletion</a> (struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, struct <a class="el" href="structsoap.html">soap</a> *soap_to)</td></tr>
<tr class="memdesc:gaa959ff61609f7b324527e88655c2377f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delegate the deletion of all managed objects and data from the specified <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context to another <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context.  <a href="#gaa959ff61609f7b324527e88655c2377f">More...</a><br /></td></tr>
<tr class="separator:gaa959ff61609f7b324527e88655c2377f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c0a034b54cd46ee06ce1253e5a40467"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__context.html#ga7c0a034b54cd46ee06ce1253e5a40467">soap_set_version</a> (struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, short version)</td></tr>
<tr class="memdesc:ga7c0a034b54cd46ee06ce1253e5a40467"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set SOAP version (0 = no SOAP, 1 = SOAP 1.1, 2 = SOAP 1.2)  <a href="#ga7c0a034b54cd46ee06ce1253e5a40467">More...</a><br /></td></tr>
<tr class="separator:ga7c0a034b54cd46ee06ce1253e5a40467"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>This module defines the <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> <a class="el" href="structsoap.html">context structure with the engine state</a> and functions to allocate, initialize, copy and delete contexts. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="gaa178a46d0cf703ff226a5c148483286d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef char* <a class="el" href="group__group__context.html#gaa178a46d0cf703ff226a5c148483286d">_QName</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A built-in string type containing normalized QName contents. </p>

</div>
</div>
<a class="anchor" id="ga5c62d26b4823b76c5b4ef29e7865d3f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef char* <a class="el" href="group__group__context.html#ga5c62d26b4823b76c5b4ef29e7865d3f0">_XML</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A built-in string type containing literal XML content in UTF-8 format. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga0e789bd6c2f76609aec0c9f93d121e4c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void soap_clr_imode </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsoap.html">soap</a> *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__flags.html#ga72b0491c9cbf2071f0c96c7d29b719bb">soap_mode</a>&#160;</td>
          <td class="paramname"><em>input_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear input <code><a class="el" href="group__group__flags.html#ga72b0491c9cbf2071f0c96c7d29b719bb" title="The soap_mode flags to initialize the soap context, flags can be combined with | (bit-wise or) ...">soap_mode</a></code> flags of the given <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td><code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context </td></tr>
    <tr><td class="paramname">input_mode</td><td>input <code><a class="el" href="group__group__flags.html#ga72b0491c9cbf2071f0c96c7d29b719bb" title="The soap_mode flags to initialize the soap context, flags can be combined with | (bit-wise or) ...">soap_mode</a></code> flags </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga06f769f80bcea7beb2ebffd0a40fc521"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void soap_clr_mode </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsoap.html">soap</a> *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__flags.html#ga72b0491c9cbf2071f0c96c7d29b719bb">soap_mode</a>&#160;</td>
          <td class="paramname"><em>input_and_output_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear input and output <code><a class="el" href="group__group__flags.html#ga72b0491c9cbf2071f0c96c7d29b719bb" title="The soap_mode flags to initialize the soap context, flags can be combined with | (bit-wise or) ...">soap_mode</a></code> flags of the given <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td><code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context </td></tr>
    <tr><td class="paramname">input_and_output_mode</td><td>input and output <code><a class="el" href="group__group__flags.html#ga72b0491c9cbf2071f0c96c7d29b719bb" title="The soap_mode flags to initialize the soap context, flags can be combined with | (bit-wise or) ...">soap_mode</a></code> flags </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8c28d2943bee7aa5c3ffaf32803b31bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void soap_clr_omode </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsoap.html">soap</a> *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__flags.html#ga72b0491c9cbf2071f0c96c7d29b719bb">soap_mode</a>&#160;</td>
          <td class="paramname"><em>output_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear output <code><a class="el" href="group__group__flags.html#ga72b0491c9cbf2071f0c96c7d29b719bb" title="The soap_mode flags to initialize the soap context, flags can be combined with | (bit-wise or) ...">soap_mode</a></code> flags of the given <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td><code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context </td></tr>
    <tr><td class="paramname">output_mode</td><td>output <code><a class="el" href="group__group__flags.html#ga72b0491c9cbf2071f0c96c7d29b719bb" title="The soap_mode flags to initialize the soap context, flags can be combined with | (bit-wise or) ...">soap_mode</a></code> flags </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab4c3f8ce80baf0f1fec8c86f0bb5788a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structsoap.html">soap</a>* soap_copy </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsoap.html">soap</a> *&#160;</td>
          <td class="paramname"><em>soap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate and initialize a new <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context as a copy of the given <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context. </p>
<p>This function allocates a new context and copies the state of the specified context except for the heap-allocated data managed by the specified context. After the copy the contexts do not share any data and can therefore be used by separate threads without requiring synchronization or mutex locking.</p>
<dl class="section note"><dt>Note</dt><dd>C++ proxy and service classes generated by <b><code>soapcpp2 -j</code></b> option <b><code>-j</code></b> or option <b><code>-i</code></b> have an internal <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context that is either a base class (option <b><code>-i</code></b>) or a member variable pointing to a <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context (option <b><code>-j</code></b>). For convenience, use the <code>copy</code> member function instead of <code><a class="el" href="group__group__context.html#gab4c3f8ce80baf0f1fec8c86f0bb5788a" title="Allocate and initialize a new soap context as a copy of the given soap context. ">soap_copy</a></code> and delete the copied instance with <code>delete</code>. For example: <div class="fragment"><div class="line"><span class="preprocessor">#include &quot;soapexampleService.h&quot;</span> <span class="comment">// generated by soapcpp2 option -j</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  exampleService service(<a class="code" href="group__group__flags.html#ga0bfffccff8ea0245f4de6670a0b36e69">SOAP_XML_INDENT</a>);</div><div class="line">  service.soap-&gt;bind_flags = SO_REUSEADDR; <span class="comment">// immediate port reuse</span></div><div class="line">  service.soap-&gt;accept_timeout = 3600;     <span class="comment">// let soap_accept time out after 1 hour</span></div><div class="line">  ... <span class="comment">// further initialize service.soap</span></div><div class="line">  <span class="keywordflow">if</span> (<a class="code" href="group__group__soap.html#gaaae8747f4cdacee575875c3a2488d99c">soap_valid_socket</a>(service.bind(NULL, PORTNUM, BACKLOG)))</div><div class="line">  {</div><div class="line">    <span class="keywordflow">while</span> (1)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">if</span> (<a class="code" href="group__group__soap.html#gaaae8747f4cdacee575875c3a2488d99c">soap_valid_socket</a>(service.accept()))</div><div class="line">      {</div><div class="line">        <a class="code" href="group__group__threads.html#ga53ca774b0fc84afe282a5419d2d7239a">THREAD_TYPE</a> tid;</div><div class="line">        exampleService *tservice = service.copy();</div><div class="line">        <span class="keywordflow">if</span> (!tservice)</div><div class="line">          <a class="code" href="group__group__io.html#ga06d59094afa3df6b1b9f6b2bb484207c">soap_closesock</a>(service.soap);</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          <span class="keywordflow">while</span> (<a class="code" href="group__group__threads.html#gabee88cce937a2709b4799ed8df36d486">THREAD_CREATE</a>(&amp;tid, (<span class="keywordtype">void</span>*(*)(<span class="keywordtype">void</span>*))&amp;process_request, (<span class="keywordtype">void</span>*)tservice))</div><div class="line">            sleep(1); <span class="comment">// failed, try again</span></div><div class="line">      }</div><div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (service.soap-&gt;errnum) <span class="comment">// accept failed, try again after 1 second</span></div><div class="line">      {</div><div class="line">        service.soap_print_fault(stderr);</div><div class="line">        sleep(1);</div><div class="line">      }</div><div class="line">      <span class="keywordflow">else</span> <span class="comment">// accept timed out, quit looping</span></div><div class="line">      {</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">      }</div><div class="line">      service.destroy();</div><div class="line">    }</div><div class="line">  }</div><div class="line">}</div><div class="line"><span class="keywordtype">void</span> *process_request(exampleService *service)</div><div class="line">{</div><div class="line">  <a class="code" href="group__group__threads.html#ga5848fc7adb50b3a15e40955dce7f8f53">THREAD_DETACH</a>(<a class="code" href="group__group__threads.html#ga9ab5a77b8cf2b98f7d6c1b48bb421f69">THREAD_ID</a>);</div><div class="line">  service.serve();</div><div class="line">  service.destroy();</div><div class="line">  <span class="keyword">delete</span> service;</div><div class="line">  <span class="keywordflow">return</span> NULL;</div><div class="line">}</div></div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Example:</dt><dd></dd></dl>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;soapH.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;plugin/threads.h&quot;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keyword">struct </span><a class="code" href="structsoap.html">soap</a> *<a class="code" href="structsoap.html">soap</a> = <a class="code" href="group__group__context.html#ga51cde138234ed7ec8c4e25bdf6418658">soap_new1</a>(<a class="code" href="group__group__flags.html#ga0bfffccff8ea0245f4de6670a0b36e69">SOAP_XML_INDENT</a>);</div><div class="line">  soap-&gt;<a class="code" href="structsoap.html#a6b18b017ce2c77ac2b6331469094de59">bind_flags</a> = SO_REUSEADDR;            <span class="comment">// immediate port reuse</span></div><div class="line">  soap-&gt;<a class="code" href="structsoap.html#a78199a81c504833047224a0ceff6f906">accept_timeout</a> = 3600;                <span class="comment">// exit loop when no request arrives in one hour</span></div><div class="line">  soap-&gt;<a class="code" href="structsoap.html#a711bb3a53de7cc62429e4d3a2e0b5474">send_timeout</a> = soap_recv_timeout = 5; <span class="comment">// 5 seconds max socket stall time (unlimited by default)</span></div><div class="line">  soap-&gt;<a class="code" href="structsoap.html#afcf1d236d052579122f785d7639c43c7">transfer_timeout</a> = 30;                <span class="comment">// 30 seconds max message transfer time (unlimited by default)</span></div><div class="line">  soap-&gt;<a class="code" href="structsoap.html#a345900c2db67e915ceb02bfa21ecbcbd">recv_maxlength</a> = 1048576;             <span class="comment">// limit messages received to 1MB (2GB by default)</span></div><div class="line">  <span class="keywordflow">if</span> (<a class="code" href="group__group__soap.html#gaaae8747f4cdacee575875c3a2488d99c">soap_valid_socket</a>(<a class="code" href="group__group__io.html#ga0a9725a3edbc27b97456190fee47cc18">soap_bind</a>(soap, NULL, PORTNUM, BACKLOG)))</div><div class="line">  {</div><div class="line">    <span class="keywordflow">while</span> (1)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">if</span> (<a class="code" href="group__group__soap.html#gaaae8747f4cdacee575875c3a2488d99c">soap_valid_socket</a>(<a class="code" href="group__group__io.html#gaec0e1aecc2d5479d8099762feb4713c6">soap_accept</a>(soap)))</div><div class="line">      {</div><div class="line">        <a class="code" href="group__group__threads.html#ga53ca774b0fc84afe282a5419d2d7239a">THREAD_TYPE</a> tid;</div><div class="line">        <span class="keyword">struct </span>soap *tsoap = <a class="code" href="group__group__context.html#gab4c3f8ce80baf0f1fec8c86f0bb5788a">soap_copy</a>(soap);</div><div class="line">        <span class="keywordflow">if</span> (!tsoap)</div><div class="line">          <a class="code" href="group__group__io.html#ga0ca0c64dc76af8617956a62cf117db94">soap_force_closesock</a>(soap);</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          <span class="keywordflow">while</span> (<a class="code" href="group__group__threads.html#gabee88cce937a2709b4799ed8df36d486">THREAD_CREATE</a>(&amp;tid, (<span class="keywordtype">void</span>*(*)(<span class="keywordtype">void</span>*))&amp;process_request, (<span class="keywordtype">void</span>*)tsoap))</div><div class="line">            sleep(1); <span class="comment">// failed, try again</span></div><div class="line">      }</div><div class="line">      <span class="keywordflow">else</span> <span class="comment">// accept failed, try again after 1 second</span></div><div class="line">      {</div><div class="line">        <a class="code" href="group__group__fault.html#ga931a4ab6df2553b48a0c270f8a0a88af">soap_print_fault</a>(soap, stderr);</div><div class="line">        sleep(1);</div><div class="line">      }</div><div class="line">      <span class="keywordflow">else</span> <span class="comment">// accept timed out, quit looping</span></div><div class="line">      {</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">      }</div><div class="line">      <a class="code" href="group__group__context.html#gaf7d0176161e9def36981e24faa1913d9">soap_destroy</a>(soap);</div><div class="line">      <a class="code" href="group__group__context.html#ga81a009ae1ea825a05e5241e2b7a8ece9">soap_end</a>(soap);</div><div class="line">    }</div><div class="line">  }</div><div class="line">  <a class="code" href="group__group__context.html#ga57108ca4681186e58b5b189c3528f10a">soap_free</a>(soap);</div><div class="line">}</div><div class="line"><span class="keywordtype">void</span> *process_request(<span class="keyword">struct</span> soap *soap)</div><div class="line">{</div><div class="line">  <a class="code" href="group__group__threads.html#ga5848fc7adb50b3a15e40955dce7f8f53">THREAD_DETACH</a>(<a class="code" href="group__group__threads.html#ga9ab5a77b8cf2b98f7d6c1b48bb421f69">THREAD_ID</a>);</div><div class="line">  <a class="code" href="group__group__io.html#ga51dba7706a505240bd8935c0b28e419d">soap_serve</a>(soap);</div><div class="line">  <a class="code" href="group__group__context.html#gaf7d0176161e9def36981e24faa1913d9">soap_destroy</a>(soap);</div><div class="line">  <a class="code" href="group__group__context.html#ga81a009ae1ea825a05e5241e2b7a8ece9">soap_end</a>(soap);</div><div class="line">  <a class="code" href="group__group__context.html#ga57108ca4681186e58b5b189c3528f10a">soap_free</a>(soap);</div><div class="line">  <span class="keywordflow">return</span> NULL;</div><div class="line">}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__group__context.html#gabcb00978a07439254c4dd44c6332b2bf" title="Copy a given soap context to an uninitialized destination soap context. ">soap_copy_context</a></code>, <code><a class="el" href="group__group__context.html#gad3f0f1ab9bdd15a2db5cff3534ccd5cc" title="Copy the input/output stream state of the given soap context to another context. ">soap_copy_stream</a></code>, <code><a class="el" href="group__group__context.html#ga7eade923b1556d7e947681e16a09aaa3" title="Free the input/output stream state of the given soap context. ">soap_free_stream</a></code>, <code><a class="el" href="group__group__context.html#gaa959ff61609f7b324527e88655c2377f" title="Delegate the deletion of all managed objects and data from the specified soap context to another soap...">soap_delegate_deletion</a></code>, <code><a class="el" href="group__group__context.html#gaf7d0176161e9def36981e24faa1913d9" title="Delete all dynamically-allocated C++ objects managed by the specified soap context. ">soap_destroy</a></code>, <code><a class="el" href="group__group__context.html#ga81a009ae1ea825a05e5241e2b7a8ece9" title="Delete all data from heap memory managed by the specified soap context and release the freed memory b...">soap_end</a></code>, <code><a class="el" href="group__group__context.html#ga57108ca4681186e58b5b189c3528f10a" title="Finalize and free the given soap context from unmanaged heap memory. ">soap_free</a></code>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to allocated and initialized <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context or NULL when out of heap memory </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td><code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context to copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gabcb00978a07439254c4dd44c6332b2bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void soap_copy_context </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsoap.html">soap</a> *&#160;</td>
          <td class="paramname"><em>soap_destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structsoap.html">soap</a> *&#160;</td>
          <td class="paramname"><em>soap_source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy a given <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context to an uninitialized destination <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context. </p>
<p>This function copies the state of the specified context to another uninitialized context (i.e. overriding it). If the destination context is initialized or active then call <code><a class="el" href="group__group__context.html#ga28ee8fdcf500443e0e51750324aa6a1a" title="Finalize the given soap context, i.e. when the soap context is stack allocated, automatically invoked...">soap_done</a></code> first to clean it up before overriding it. The entire state is copied except for the heap-allocated data managed by the specified context. After the copy the contexts do not share any data and can therefore be used by separate threads without requiring synchronization or mutex locking.</p>
<dl class="section user"><dt>Example:</dt><dd></dd></dl>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;soapH.h&quot;</span></div><div class="line"></div><div class="line"><span class="keyword">struct </span>soap *soap = <a class="code" href="group__group__context.html#ga87c20488b2dc680aaa7689b1d024989c">soap_new</a>();</div><div class="line">... <span class="comment">// send and receive messages etc.</span></div><div class="line"><span class="keyword">struct </span>soap temp;</div><div class="line"><a class="code" href="group__group__context.html#gabcb00978a07439254c4dd44c6332b2bf">soap_copy_context</a>(&amp;temp, soap); </div><div class="line">...</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__group__context.html#gab4c3f8ce80baf0f1fec8c86f0bb5788a" title="Allocate and initialize a new soap context as a copy of the given soap context. ">soap_copy</a></code>, <code><a class="el" href="group__group__context.html#gad3f0f1ab9bdd15a2db5cff3534ccd5cc" title="Copy the input/output stream state of the given soap context to another context. ">soap_copy_stream</a></code>, <code><a class="el" href="group__group__context.html#ga7eade923b1556d7e947681e16a09aaa3" title="Free the input/output stream state of the given soap context. ">soap_free_stream</a></code>, <code><a class="el" href="group__group__context.html#gaa959ff61609f7b324527e88655c2377f" title="Delegate the deletion of all managed objects and data from the specified soap context to another soap...">soap_delegate_deletion</a></code>, <code><a class="el" href="group__group__context.html#gaf7d0176161e9def36981e24faa1913d9" title="Delete all dynamically-allocated C++ objects managed by the specified soap context. ">soap_destroy</a></code>, <code><a class="el" href="group__group__context.html#ga81a009ae1ea825a05e5241e2b7a8ece9" title="Delete all data from heap memory managed by the specified soap context and release the freed memory b...">soap_end</a></code>, <code><a class="el" href="group__group__context.html#ga57108ca4681186e58b5b189c3528f10a" title="Finalize and free the given soap context from unmanaged heap memory. ">soap_free</a></code>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soap_destination</td><td>destination <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context to initialize </td></tr>
    <tr><td class="paramname">soap_source</td><td>source <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context to copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad3f0f1ab9bdd15a2db5cff3534ccd5cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void soap_copy_stream </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsoap.html">soap</a> *&#160;</td>
          <td class="paramname"><em>soap_destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structsoap.html">soap</a> *&#160;</td>
          <td class="paramname"><em>soap_source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy the input/output stream state of the given <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context to another context. </p>
<p>This function copies the input/output state of the specified source context to the specified destination context. Both contexts will share the same input/output streams , i.e. <code><a class="el" href="structsoap.html#a285e8a3584ffb1cea07a700c951e436d" title="The source to read data from when non-NULL, which in C++ is a std::istream object and in C is a 0-ter...">soap::is</a></code>, <code><a class="el" href="structsoap.html#a27b166e404c7c98cfa45d6d7a5da90c0" title="The sink to write data to when non-NULL, which in C++ is a std::ostream object and in C is a pointer ...">soap::os</a></code>, <code><a class="el" href="structsoap.html#a1579bd8bd106afc9a906a673ca473046" title="The socket set by soap_accept (or the C++ service class accept method) or soap_connect or soap_connec...">soap::socket</a></code>, <code><a class="el" href="structsoap.html#a192c25cc206668600212fd34f6541f34" title="The file descriptor to read data from when no socket communications are set (soap::socket == SOAP_INV...">soap::recvfd</a></code> and <code><a class="el" href="structsoap.html#a200d71a901cdc5c9aa02140e9d2369b9" title="The file descriptor to write data to when no socket communications are set (soap::socket == SOAP_INVA...">soap::sendfd</a></code> are shared and the current message buffer <code><a class="el" href="structsoap.html#acda1736fbaac07261226befe165a5681" title="Internal buffer with partial data received or partial data to be sent, where the data occupies soap::...">soap::buf</a></code> content is copied. The destination context is set to the source context <code><a class="el" href="group__group__flags.html#ga72b0491c9cbf2071f0c96c7d29b719bb" title="The soap_mode flags to initialize the soap context, flags can be combined with | (bit-wise or) ...">soap_mode</a></code> flags and timeouts. To move the input/output state of one context to another, use this function and then call <code><a class="el" href="group__group__context.html#ga7eade923b1556d7e947681e16a09aaa3" title="Free the input/output stream state of the given soap context. ">soap_free_stream</a></code> on the source context to clear its input/output state.</p>
<dl class="section user"><dt>Example:</dt><dd></dd></dl>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;soapH.h&quot;</span></div><div class="line"></div><div class="line"><span class="keyword">struct </span>soap *soap = <a class="code" href="group__group__context.html#ga87c20488b2dc680aaa7689b1d024989c">soap_new</a>();</div><div class="line"><span class="keyword">struct </span>soap *temp = <a class="code" href="group__group__context.html#ga87c20488b2dc680aaa7689b1d024989c">soap_new</a>();</div><div class="line">... <span class="comment">// send and receive messages etc.</span></div><div class="line"><span class="comment">// move the input/output state to another context</span></div><div class="line"><a class="code" href="group__group__context.html#gad3f0f1ab9bdd15a2db5cff3534ccd5cc">soap_copy_stream</a>(temp, soap); </div><div class="line"><a class="code" href="group__group__context.html#ga7eade923b1556d7e947681e16a09aaa3">soap_free_stream</a>(soap);</div><div class="line"><a class="code" href="group__group__io.html#ga06d59094afa3df6b1b9f6b2bb484207c">soap_closesock</a>(soap); <span class="comment">// has no effect</span></div><div class="line">... <span class="comment">// send and receive messages etc.</span></div><div class="line"><a class="code" href="group__group__io.html#ga06d59094afa3df6b1b9f6b2bb484207c">soap_closesock</a>(temp); <span class="comment">// closes socket, if open</span></div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__group__context.html#ga7eade923b1556d7e947681e16a09aaa3" title="Free the input/output stream state of the given soap context. ">soap_free_stream</a></code>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soap_destination</td><td>destination <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context </td></tr>
    <tr><td class="paramname">soap_source</td><td>source <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gacdc44bad1fbf1851f3664b887e807c85"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void soap_dealloc </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsoap.html">soap</a> *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Explicitly dealllocates a block of managed memory that is managed by the specified <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context and release the free memory back to the heap. </p>
<p>This function deallocates a managed block of memory from the managing <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context and releases the free memory back to the heap. This frees data allocated with <code><a class="el" href="group__group__context.html#gaba556710e010feeb2211ed43b5bf059c" title="Allocate a block of heap memory managed by the specified soap context. ">soap_malloc</a></code> and C++ objects allocated and instantiated with the <code>soap_new_T</code> functions. Normally this function should not be used to individually deallocate managed objects and data but rather <code><a class="el" href="group__group__context.html#gaf7d0176161e9def36981e24faa1913d9" title="Delete all dynamically-allocated C++ objects managed by the specified soap context. ">soap_destroy</a></code> and <code><a class="el" href="group__group__context.html#ga81a009ae1ea825a05e5241e2b7a8ece9" title="Delete all data from heap memory managed by the specified soap context and release the freed memory b...">soap_end</a></code> should be used to deallocate all objects and data managed by the context, which is much more efficient. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td><code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context </td></tr>
    <tr><td class="paramname">ptr</td><td>pointer to the block of managed heap memory to deallocate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa959ff61609f7b324527e88655c2377f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void soap_delegate_deletion </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsoap.html">soap</a> *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structsoap.html">soap</a> *&#160;</td>
          <td class="paramname"><em>soap_to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delegate the deletion of all managed objects and data from the specified <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context to another <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context. </p>
<p>This function moves all dynamically-allocated data managed by the specified <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context to the target context <code>soap_to</code> for deletion by the target context using <code><a class="el" href="group__group__context.html#gaf7d0176161e9def36981e24faa1913d9" title="Delete all dynamically-allocated C++ objects managed by the specified soap context. ">soap_destroy</a></code> and <code><a class="el" href="group__group__context.html#ga81a009ae1ea825a05e5241e2b7a8ece9" title="Delete all data from heap memory managed by the specified soap context and release the freed memory b...">soap_end</a></code>.</p>
<dl class="section user"><dt>Example:</dt><dd></dd></dl>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;soapH.h&quot;</span></div><div class="line"></div><div class="line"><span class="keyword">struct </span>soap *soap = <a class="code" href="group__group__context.html#ga87c20488b2dc680aaa7689b1d024989c">soap_new</a>();</div><div class="line"><span class="keyword">struct </span>soap *temp = <a class="code" href="group__group__context.html#ga87c20488b2dc680aaa7689b1d024989c">soap_new</a>(); <span class="comment">// temp context to manage data</span></div><div class="line"><span class="keywordflow">if</span> (soap_call_ns__webmethod(soap, <a class="code" href="structsoap.html#aed1b86b8a34aea86103751a932c9dce9">endpoint</a>, NULL, ...))</div><div class="line">{</div><div class="line">  <a class="code" href="group__group__fault.html#ga931a4ab6df2553b48a0c270f8a0a88af">soap_print_fault</a>(soap, stderr);</div><div class="line">}</div><div class="line"><span class="keywordflow">else</span></div><div class="line">{</div><div class="line">  <span class="comment">// success, response contains deserialized data</span></div><div class="line">  <a class="code" href="group__group__context.html#gaa959ff61609f7b324527e88655c2377f">soap_delegate_deletion</a>(soap, temp); <span class="comment">// deserialized data is managed by temp context</span></div><div class="line">}</div><div class="line"><a class="code" href="group__group__context.html#gaf7d0176161e9def36981e24faa1913d9">soap_destroy</a>(soap); <span class="comment">// clean up &#39;soap&#39; context</span></div><div class="line"><a class="code" href="group__group__context.html#ga81a009ae1ea825a05e5241e2b7a8ece9">soap_end</a>(soap);     <span class="comment">// clean up &#39;soap&#39; context</span></div><div class="line">... <span class="comment">// use deserialized data managed by &#39;temp&#39; context, reuse &#39;soap&#39; context as needed</span></div><div class="line"><a class="code" href="group__group__context.html#gaf7d0176161e9def36981e24faa1913d9">soap_destroy</a>(temp); <span class="comment">// clean up &#39;temp&#39; context, deletes deserialized data</span></div><div class="line"><a class="code" href="group__group__context.html#ga81a009ae1ea825a05e5241e2b7a8ece9">soap_end</a>(temp);     <span class="comment">// clean up &#39;temp&#39; context, deletes deserialized data</span></div><div class="line"><a class="code" href="group__group__context.html#ga57108ca4681186e58b5b189c3528f10a">soap_free</a>(temp);</div><div class="line"><a class="code" href="group__group__context.html#ga57108ca4681186e58b5b189c3528f10a">soap_free</a>(soap);</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__group__context.html#gab4c3f8ce80baf0f1fec8c86f0bb5788a" title="Allocate and initialize a new soap context as a copy of the given soap context. ">soap_copy</a></code>, <code><a class="el" href="group__group__context.html#gabcb00978a07439254c4dd44c6332b2bf" title="Copy a given soap context to an uninitialized destination soap context. ">soap_copy_context</a></code>, <code><a class="el" href="group__group__context.html#gaf7d0176161e9def36981e24faa1913d9" title="Delete all dynamically-allocated C++ objects managed by the specified soap context. ">soap_destroy</a></code>, <code><a class="el" href="group__group__context.html#ga81a009ae1ea825a05e5241e2b7a8ece9" title="Delete all data from heap memory managed by the specified soap context and release the freed memory b...">soap_end</a></code>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td>source <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context </td></tr>
    <tr><td class="paramname">soap_to</td><td>target <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf7d0176161e9def36981e24faa1913d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void soap_destroy </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsoap.html">soap</a> *&#160;</td>
          <td class="paramname"><em>soap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete all dynamically-allocated C++ objects managed by the specified <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context. </p>
<p>This function deletes all dynamically-allocated C++ objects managed by the specified <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context, i.e. data allocated with <code>soap_new_T</code> calls. This call should be followed by <code><a class="el" href="group__group__context.html#ga81a009ae1ea825a05e5241e2b7a8ece9" title="Delete all data from heap memory managed by the specified soap context and release the freed memory b...">soap_end</a></code> to delete all other dynamically-allocated data managed by the <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context. Or just invoke <code><a class="el" href="structsoap.html#a0c714b6ed5245dbe34cf7b747aa226ac" title="Delete all dynamically-allocated objects and data managed by this soap context (C++ only...">soap::destroy</a></code> to delete objects and data and release the freed memory back to the heap.</p>
<dl class="section note"><dt>Note</dt><dd>C++ proxy and service classes generated by <b><code>soapcpp2 -j</code></b> option <b><code>-j</code></b> or option <b><code>-i</code></b> have an internal <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context that is either a base class (option <b><code>-i</code></b>) or a member variable pointing to a <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context (option <b><code>-j</code></b>). For convenience, use the <code>destroy</code> member function instead of <code><a class="el" href="group__group__context.html#gaf7d0176161e9def36981e24faa1913d9" title="Delete all dynamically-allocated C++ objects managed by the specified soap context. ">soap_destroy</a></code> and <code><a class="el" href="group__group__context.html#ga81a009ae1ea825a05e5241e2b7a8ece9" title="Delete all data from heap memory managed by the specified soap context and release the freed memory b...">soap_end</a></code>. For example: <div class="fragment"><div class="line"><span class="preprocessor">#include &quot;soapexampleProxy.h&quot;</span></div><div class="line"></div><div class="line">exampleProxy proxy(<a class="code" href="group__group__flags.html#ga0bfffccff8ea0245f4de6670a0b36e69">SOAP_XML_INDENT</a>);</div><div class="line">... <span class="comment">// use proxy or proxy.soap (option -j)</span></div><div class="line">proxy.destroy(); <span class="comment">// delete managed C++ objects and memory</span></div></div><!-- fragment --> <div class="fragment"><div class="line"><span class="preprocessor">#include &quot;soapexampleService.h&quot;</span></div><div class="line"></div><div class="line">exampleService service(<a class="code" href="group__group__flags.html#ga0bfffccff8ea0245f4de6670a0b36e69">SOAP_XML_INDENT</a>);</div><div class="line">... <span class="comment">// use service or service.soap (option -j)</span></div><div class="line">service.destroy(); <span class="comment">// delete managed C++ objects and memory</span></div></div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Example:</dt><dd></dd></dl>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;soapH.h&quot;</span></div><div class="line"></div><div class="line"><span class="keyword">struct </span>soap *soap = <a class="code" href="group__group__context.html#ga87c20488b2dc680aaa7689b1d024989c">soap_new</a>();</div><div class="line">... <span class="comment">// send and receive messages etc.</span></div><div class="line"><a class="code" href="group__group__context.html#gaf7d0176161e9def36981e24faa1913d9">soap_destroy</a>(soap); <span class="comment">// delete managed C++ objects</span></div><div class="line"><a class="code" href="group__group__context.html#ga81a009ae1ea825a05e5241e2b7a8ece9">soap_end</a>(soap);     <span class="comment">// delete managed memory</span></div><div class="line"><a class="code" href="group__group__context.html#ga57108ca4681186e58b5b189c3528f10a">soap_free</a>(soap);    <span class="comment">// free the context</span></div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__group__context.html#gaba556710e010feeb2211ed43b5bf059c" title="Allocate a block of heap memory managed by the specified soap context. ">soap_malloc</a></code>, <code><a class="el" href="group__group__context.html#ga81a009ae1ea825a05e5241e2b7a8ece9" title="Delete all data from heap memory managed by the specified soap context and release the freed memory b...">soap_end</a></code>, <code><a class="el" href="structsoap.html#a0c714b6ed5245dbe34cf7b747aa226ac" title="Delete all dynamically-allocated objects and data managed by this soap context (C++ only...">soap::destroy</a></code>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td><code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga28ee8fdcf500443e0e51750324aa6a1a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void soap_done </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsoap.html">soap</a> *&#160;</td>
          <td class="paramname"><em>soap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalize the given <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context, i.e. when the <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context is stack allocated, automatically invoked in C++ by the <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> destructor on the <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context to delete. </p>
<p>This function finalizes the specified context. This function does not free memory managed by the context. To free memory managed by the context use <code><a class="el" href="group__group__context.html#gaf7d0176161e9def36981e24faa1913d9" title="Delete all dynamically-allocated C++ objects managed by the specified soap context. ">soap_destroy</a></code> and <code><a class="el" href="group__group__context.html#ga81a009ae1ea825a05e5241e2b7a8ece9" title="Delete all data from heap memory managed by the specified soap context and release the freed memory b...">soap_end</a></code>, or <code><a class="el" href="structsoap.html#a0c714b6ed5245dbe34cf7b747aa226ac" title="Delete all dynamically-allocated objects and data managed by this soap context (C++ only...">soap::destroy</a></code> to call both.</p>
<dl class="section user"><dt>Example:</dt><dd></dd></dl>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;soapH.h&quot;</span></div><div class="line"></div><div class="line"><span class="keyword">struct </span>soap soap;</div><div class="line"><a class="code" href="group__group__context.html#ga8e034e1a7d6093eaddc11b647179657c">soap_init</a>(&amp;soap);</div><div class="line">... <span class="comment">// send and receive messages etc.</span></div><div class="line"><a class="code" href="group__group__context.html#gaf7d0176161e9def36981e24faa1913d9">soap_destroy</a>(&amp;soap);</div><div class="line"><a class="code" href="group__group__context.html#ga81a009ae1ea825a05e5241e2b7a8ece9">soap_end</a>(&amp;soap);</div><div class="line"><a class="code" href="group__group__context.html#ga28ee8fdcf500443e0e51750324aa6a1a">soap_done</a>(&amp;soap);</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__group__context.html#ga57108ca4681186e58b5b189c3528f10a" title="Finalize and free the given soap context from unmanaged heap memory. ">soap_free</a></code>, <code><a class="el" href="group__group__context.html#gaf7d0176161e9def36981e24faa1913d9" title="Delete all dynamically-allocated C++ objects managed by the specified soap context. ">soap_destroy</a></code>, <code><a class="el" href="group__group__context.html#ga81a009ae1ea825a05e5241e2b7a8ece9" title="Delete all data from heap memory managed by the specified soap context and release the freed memory b...">soap_end</a></code>, <code><a class="el" href="structsoap.html#a0c714b6ed5245dbe34cf7b747aa226ac" title="Delete all dynamically-allocated objects and data managed by this soap context (C++ only...">soap::destroy</a></code>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td><code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context to finalize </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga81a009ae1ea825a05e5241e2b7a8ece9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void soap_end </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsoap.html">soap</a> *&#160;</td>
          <td class="paramname"><em>soap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete all data from heap memory managed by the specified <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context and release the freed memory back to the heap. </p>
<p>This function deletes all dynamically-allocated data managed by the specified <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context, i.e. data allocated with <code><a class="el" href="group__group__context.html#gaba556710e010feeb2211ed43b5bf059c" title="Allocate a block of heap memory managed by the specified soap context. ">soap_malloc</a></code>. This call suffices to delete all managed data from C applications and release the freed memory back to the heap. C++ applications however should call <code><a class="el" href="group__group__context.html#gaf7d0176161e9def36981e24faa1913d9" title="Delete all dynamically-allocated C++ objects managed by the specified soap context. ">soap_destroy</a></code> first before <code><a class="el" href="group__group__context.html#ga81a009ae1ea825a05e5241e2b7a8ece9" title="Delete all data from heap memory managed by the specified soap context and release the freed memory b...">soap_end</a></code> or just invoke <code><a class="el" href="structsoap.html#a0c714b6ed5245dbe34cf7b747aa226ac" title="Delete all dynamically-allocated objects and data managed by this soap context (C++ only...">soap::destroy</a></code> (or C++ proxy and service class member function <code>destroy</code>) to delete objects and data and release the freed memory back to the heap.</p>
<dl class="section note"><dt>Note</dt><dd>C++ proxy and service classes generated by <b><code>soapcpp2 -j</code></b> option <b><code>-j</code></b> or option <b><code>-i</code></b> have an internal <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context that is either a base class (option <b><code>-i</code></b>) or a member variable pointing to a <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context (option <b><code>-j</code></b>). For convenience, use the <code>destroy</code> member function instead of <code><a class="el" href="group__group__context.html#gaf7d0176161e9def36981e24faa1913d9" title="Delete all dynamically-allocated C++ objects managed by the specified soap context. ">soap_destroy</a></code> and <code><a class="el" href="group__group__context.html#ga81a009ae1ea825a05e5241e2b7a8ece9" title="Delete all data from heap memory managed by the specified soap context and release the freed memory b...">soap_end</a></code>. For example: <div class="fragment"><div class="line"><span class="preprocessor">#include &quot;soapexampleProxy.h&quot;</span></div><div class="line"></div><div class="line">exampleProxy proxy(<a class="code" href="group__group__flags.html#ga0bfffccff8ea0245f4de6670a0b36e69">SOAP_XML_INDENT</a>);</div><div class="line">... <span class="comment">// use proxy or proxy.soap (option -j)</span></div><div class="line">proxy.destroy(); <span class="comment">// delete managed C++ objects and memory</span></div></div><!-- fragment --> <div class="fragment"><div class="line"><span class="preprocessor">#include &quot;soapexampleService.h&quot;</span></div><div class="line"></div><div class="line">exampleService service(<a class="code" href="group__group__flags.html#ga0bfffccff8ea0245f4de6670a0b36e69">SOAP_XML_INDENT</a>);</div><div class="line">... <span class="comment">// use service or service.soap (option -j)</span></div><div class="line">service.destroy(); <span class="comment">// delete managed C++ objects and memory</span></div></div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Example:</dt><dd></dd></dl>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;soapH.h&quot;</span></div><div class="line"></div><div class="line"><span class="keyword">struct </span>soap *soap = <a class="code" href="group__group__context.html#ga87c20488b2dc680aaa7689b1d024989c">soap_new</a>();</div><div class="line">... <span class="comment">// send and receive messages etc.</span></div><div class="line"><a class="code" href="group__group__context.html#gaf7d0176161e9def36981e24faa1913d9">soap_destroy</a>(soap); <span class="comment">// delete managed C++ objects</span></div><div class="line"><a class="code" href="group__group__context.html#ga81a009ae1ea825a05e5241e2b7a8ece9">soap_end</a>(soap);     <span class="comment">// delete managed memory</span></div><div class="line"><a class="code" href="group__group__context.html#ga57108ca4681186e58b5b189c3528f10a">soap_free</a>(soap);    <span class="comment">// free the context</span></div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__group__context.html#gaba556710e010feeb2211ed43b5bf059c" title="Allocate a block of heap memory managed by the specified soap context. ">soap_malloc</a></code>, <code><a class="el" href="group__group__context.html#gaf7d0176161e9def36981e24faa1913d9" title="Delete all dynamically-allocated C++ objects managed by the specified soap context. ">soap_destroy</a></code>, <code><a class="el" href="structsoap.html#a0c714b6ed5245dbe34cf7b747aa226ac" title="Delete all dynamically-allocated objects and data managed by this soap context (C++ only...">soap::destroy</a></code>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td><code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga57108ca4681186e58b5b189c3528f10a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void soap_free </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsoap.html">soap</a> *&#160;</td>
          <td class="paramname"><em>soap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalize and free the given <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context from unmanaged heap memory. </p>
<p>This function finalizes and frees the specified context. The finalization is done with <code><a class="el" href="group__group__context.html#ga28ee8fdcf500443e0e51750324aa6a1a" title="Finalize the given soap context, i.e. when the soap context is stack allocated, automatically invoked...">soap_done</a></code> before releasing its memory. This function does not free memory managed by the context. To free memory managed by the context use <code><a class="el" href="group__group__context.html#gaf7d0176161e9def36981e24faa1913d9" title="Delete all dynamically-allocated C++ objects managed by the specified soap context. ">soap_destroy</a></code> and <code><a class="el" href="group__group__context.html#ga81a009ae1ea825a05e5241e2b7a8ece9" title="Delete all data from heap memory managed by the specified soap context and release the freed memory b...">soap_end</a></code>, or <code><a class="el" href="structsoap.html#a0c714b6ed5245dbe34cf7b747aa226ac" title="Delete all dynamically-allocated objects and data managed by this soap context (C++ only...">soap::destroy</a></code> to call both.</p>
<dl class="section note"><dt>Note</dt><dd>C++ proxy and service classes generated by <b><code>soapcpp2 -j</code></b> option <b><code>-j</code></b> or option <b><code>-i</code></b> have an internal <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context that is either a base class (option <b><code>-i</code></b>) or a member variable pointing to a <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context (option <b><code>-j</code></b>). The C++ proxy and service classes allocate and deallocate this context, which means that <code><a class="el" href="group__group__context.html#ga87c20488b2dc680aaa7689b1d024989c" title="Allocate and initialize a new soap context. ">soap_new</a></code> and <code><a class="el" href="group__group__context.html#ga57108ca4681186e58b5b189c3528f10a" title="Finalize and free the given soap context from unmanaged heap memory. ">soap_free</a></code> are not required. For example: <div class="fragment"><div class="line"><span class="preprocessor">#include &quot;soapexampleProxy.h&quot;</span></div><div class="line"></div><div class="line">exampleProxy proxy(<a class="code" href="group__group__flags.html#ga0bfffccff8ea0245f4de6670a0b36e69">SOAP_XML_INDENT</a>);</div><div class="line">... <span class="comment">// use proxy or proxy.soap (option -j)</span></div><div class="line">proxy.destroy(); <span class="comment">// delete managed C++ objects and memory</span></div></div><!-- fragment --> <div class="fragment"><div class="line"><span class="preprocessor">#include &quot;soapexampleService.h&quot;</span></div><div class="line"></div><div class="line">exampleService service(<a class="code" href="group__group__flags.html#ga0bfffccff8ea0245f4de6670a0b36e69">SOAP_XML_INDENT</a>);</div><div class="line">... <span class="comment">// use service or service.soap (option -j)</span></div><div class="line">service.destroy(); <span class="comment">// delete managed C++ objects and memory</span></div></div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Example:</dt><dd></dd></dl>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;soapH.h&quot;</span></div><div class="line"></div><div class="line"><span class="keyword">struct </span>soap *soap = <a class="code" href="group__group__context.html#ga87c20488b2dc680aaa7689b1d024989c">soap_new</a>();</div><div class="line">... <span class="comment">// send and receive messages etc.</span></div><div class="line"><a class="code" href="group__group__context.html#gaf7d0176161e9def36981e24faa1913d9">soap_destroy</a>(soap);</div><div class="line"><a class="code" href="group__group__context.html#ga81a009ae1ea825a05e5241e2b7a8ece9">soap_end</a>(soap);</div><div class="line"><a class="code" href="group__group__context.html#ga57108ca4681186e58b5b189c3528f10a">soap_free</a>(soap);</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__group__context.html#ga87c20488b2dc680aaa7689b1d024989c" title="Allocate and initialize a new soap context. ">soap_new</a></code>, <code><a class="el" href="group__group__context.html#ga51cde138234ed7ec8c4e25bdf6418658" title="Allocate and initialize a new soap context with input and output soap_mode flags. ...">soap_new1</a></code>, <code><a class="el" href="group__group__context.html#ga12a87f6795b62b05164edc392b2adb1d" title="Allocate and initialize a new soap context with separate input and output soap_mode flags...">soap_new2</a></code>, <code><a class="el" href="group__group__context.html#ga28ee8fdcf500443e0e51750324aa6a1a" title="Finalize the given soap context, i.e. when the soap context is stack allocated, automatically invoked...">soap_done</a></code>, <code><a class="el" href="group__group__context.html#gaf7d0176161e9def36981e24faa1913d9" title="Delete all dynamically-allocated C++ objects managed by the specified soap context. ">soap_destroy</a></code>, <code><a class="el" href="group__group__context.html#ga81a009ae1ea825a05e5241e2b7a8ece9" title="Delete all data from heap memory managed by the specified soap context and release the freed memory b...">soap_end</a></code>, <code><a class="el" href="structsoap.html#a0c714b6ed5245dbe34cf7b747aa226ac" title="Delete all dynamically-allocated objects and data managed by this soap context (C++ only...">soap::destroy</a></code>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td><code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context to free </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7eade923b1556d7e947681e16a09aaa3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void soap_free_stream </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsoap.html">soap</a> *&#160;</td>
          <td class="paramname"><em>soap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free the input/output stream state of the given <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context. </p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__group__context.html#gad3f0f1ab9bdd15a2db5cff3534ccd5cc" title="Copy the input/output stream state of the given soap context to another context. ">soap_copy_stream</a></code>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td><code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gace16239b47adccf9e4dc307cebe6a323"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void soap_free_temp </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsoap.html">soap</a> *&#160;</td>
          <td class="paramname"><em>soap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete temporary data. </p>
<p>This function deallocates temporary data such as buffers and hash tables but leaves deserialized managed data intact. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td><code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8e034e1a7d6093eaddc11b647179657c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void soap_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsoap.html">soap</a> *&#160;</td>
          <td class="paramname"><em>soap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a stack-allocated <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context. </p>
<p>This function initializes a context.</p>
<dl class="section user"><dt>Examples:</dt><dd></dd></dl>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;soapH.h&quot;</span></div><div class="line"></div><div class="line"><span class="keyword">struct </span>soap soap;</div><div class="line"><a class="code" href="group__group__context.html#ga8e034e1a7d6093eaddc11b647179657c">soap_init</a>(&amp;soap);</div><div class="line">... <span class="comment">// send and receive messages etc.</span></div><div class="line"><a class="code" href="group__group__context.html#gaf7d0176161e9def36981e24faa1913d9">soap_destroy</a>(&amp;soap); <span class="comment">// delete managed C++ objects</span></div><div class="line"><a class="code" href="group__group__context.html#ga81a009ae1ea825a05e5241e2b7a8ece9">soap_end</a>(s&amp;oap);     <span class="comment">// delete managed memory</span></div><div class="line"><a class="code" href="group__group__context.html#ga28ee8fdcf500443e0e51750324aa6a1a">soap_done</a>(&amp;soap);    <span class="comment">// finalize the context</span></div></div><!-- fragment --><p>The context can be re-initialized for reuse after <code><a class="el" href="group__group__context.html#ga28ee8fdcf500443e0e51750324aa6a1a" title="Finalize the given soap context, i.e. when the soap context is stack allocated, automatically invoked...">soap_done</a></code> by calling <code><a class="el" href="group__group__context.html#ga8e034e1a7d6093eaddc11b647179657c" title="Initialize a stack-allocated soap context. ">soap_init</a></code>.</p>
<dl class="section note"><dt>Note</dt><dd>Initialization should be done at most once before calling <code><a class="el" href="group__group__context.html#ga28ee8fdcf500443e0e51750324aa6a1a" title="Finalize the given soap context, i.e. when the soap context is stack allocated, automatically invoked...">soap_done</a></code>. To change the input/output mode flags, use <code><a class="el" href="group__group__context.html#ga84f52a67a41009b260ff2c036df7f6ab" title="Set input and output soap_mode flags of the given soap context. ">soap_set_mode</a></code> and <code><a class="el" href="group__group__context.html#ga06f769f80bcea7beb2ebffd0a40fc521" title="Clear input and output soap_mode flags of the given soap context. ">soap_clr_mode</a></code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__group__context.html#gac87126c3e45d2fda488e9832c2dd5be1" title="Initialize a stack-allocated soap context with input and output soap_mode flags. ">soap_init1</a></code>, <code><a class="el" href="group__group__context.html#ga87c20488b2dc680aaa7689b1d024989c" title="Allocate and initialize a new soap context. ">soap_new</a></code>, <code><a class="el" href="group__group__context.html#gab4c3f8ce80baf0f1fec8c86f0bb5788a" title="Allocate and initialize a new soap context as a copy of the given soap context. ">soap_copy</a></code>, <code><a class="el" href="group__group__context.html#gaf7d0176161e9def36981e24faa1913d9" title="Delete all dynamically-allocated C++ objects managed by the specified soap context. ">soap_destroy</a></code>, <code><a class="el" href="group__group__context.html#ga81a009ae1ea825a05e5241e2b7a8ece9" title="Delete all data from heap memory managed by the specified soap context and release the freed memory b...">soap_end</a></code>, <code><a class="el" href="group__group__context.html#ga28ee8fdcf500443e0e51750324aa6a1a" title="Finalize the given soap context, i.e. when the soap context is stack allocated, automatically invoked...">soap_done</a></code>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td><code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context to initialize </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac87126c3e45d2fda488e9832c2dd5be1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void soap_init1 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsoap.html">soap</a> *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__flags.html#ga72b0491c9cbf2071f0c96c7d29b719bb">soap_mode</a>&#160;</td>
          <td class="paramname"><em>input_and_output_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a stack-allocated <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context with input and output <code><a class="el" href="group__group__flags.html#ga72b0491c9cbf2071f0c96c7d29b719bb" title="The soap_mode flags to initialize the soap context, flags can be combined with | (bit-wise or) ...">soap_mode</a></code> flags. </p>
<p>This function initializes a context with the specified input and output <code><a class="el" href="group__group__flags.html#ga72b0491c9cbf2071f0c96c7d29b719bb" title="The soap_mode flags to initialize the soap context, flags can be combined with | (bit-wise or) ...">soap_mode</a></code> flags.</p>
<dl class="section user"><dt>Examples:</dt><dd></dd></dl>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;soapH.h&quot;</span></div><div class="line"></div><div class="line"><span class="keyword">struct </span>soap soap;</div><div class="line"><a class="code" href="group__group__context.html#gac87126c3e45d2fda488e9832c2dd5be1">soap_init1</a>(&amp;soap, <a class="code" href="group__group__flags.html#ga0bfffccff8ea0245f4de6670a0b36e69">SOAP_XML_INDENT</a>);</div><div class="line">... <span class="comment">// send and receive messages etc.</span></div><div class="line"><a class="code" href="group__group__context.html#gaf7d0176161e9def36981e24faa1913d9">soap_destroy</a>(&amp;soap); <span class="comment">// delete managed C++ objects</span></div><div class="line"><a class="code" href="group__group__context.html#ga81a009ae1ea825a05e5241e2b7a8ece9">soap_end</a>(s&amp;oap);     <span class="comment">// delete managed memory</span></div><div class="line"><a class="code" href="group__group__context.html#ga28ee8fdcf500443e0e51750324aa6a1a">soap_done</a>(&amp;soap);    <span class="comment">// finalize the context</span></div></div><!-- fragment --><p>The context can be re-initialized for reuse after <code><a class="el" href="group__group__context.html#ga28ee8fdcf500443e0e51750324aa6a1a" title="Finalize the given soap context, i.e. when the soap context is stack allocated, automatically invoked...">soap_done</a></code> by calling <code><a class="el" href="group__group__context.html#ga8e034e1a7d6093eaddc11b647179657c" title="Initialize a stack-allocated soap context. ">soap_init</a></code>.</p>
<dl class="section note"><dt>Note</dt><dd>Initialization should be done at most once before calling <code><a class="el" href="group__group__context.html#ga28ee8fdcf500443e0e51750324aa6a1a" title="Finalize the given soap context, i.e. when the soap context is stack allocated, automatically invoked...">soap_done</a></code>. To change the input/output mode flags, use <code><a class="el" href="group__group__context.html#ga84f52a67a41009b260ff2c036df7f6ab" title="Set input and output soap_mode flags of the given soap context. ">soap_set_mode</a></code> and <code><a class="el" href="group__group__context.html#ga06f769f80bcea7beb2ebffd0a40fc521" title="Clear input and output soap_mode flags of the given soap context. ">soap_clr_mode</a></code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__group__context.html#ga8e034e1a7d6093eaddc11b647179657c" title="Initialize a stack-allocated soap context. ">soap_init</a></code>, <code><a class="el" href="group__group__context.html#ga87c20488b2dc680aaa7689b1d024989c" title="Allocate and initialize a new soap context. ">soap_new</a></code>, <code><a class="el" href="group__group__context.html#gab4c3f8ce80baf0f1fec8c86f0bb5788a" title="Allocate and initialize a new soap context as a copy of the given soap context. ">soap_copy</a></code>, <code><a class="el" href="group__group__context.html#gaf7d0176161e9def36981e24faa1913d9" title="Delete all dynamically-allocated C++ objects managed by the specified soap context. ">soap_destroy</a></code>, <code><a class="el" href="group__group__context.html#ga81a009ae1ea825a05e5241e2b7a8ece9" title="Delete all data from heap memory managed by the specified soap context and release the freed memory b...">soap_end</a></code>, <code><a class="el" href="group__group__context.html#ga28ee8fdcf500443e0e51750324aa6a1a" title="Finalize the given soap context, i.e. when the soap context is stack allocated, automatically invoked...">soap_done</a></code>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td><code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context to initialize </td></tr>
    <tr><td class="paramname">input_and_output_mode</td><td>input and output <code><a class="el" href="group__group__flags.html#ga72b0491c9cbf2071f0c96c7d29b719bb" title="The soap_mode flags to initialize the soap context, flags can be combined with | (bit-wise or) ...">soap_mode</a></code> flags </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3c70b587fc4f65553cfe69751d1a157e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void soap_init2 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsoap.html">soap</a> *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__flags.html#ga72b0491c9cbf2071f0c96c7d29b719bb">soap_mode</a>&#160;</td>
          <td class="paramname"><em>input_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__flags.html#ga72b0491c9cbf2071f0c96c7d29b719bb">soap_mode</a>&#160;</td>
          <td class="paramname"><em>output_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a stack-allocated <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context with input and output <code><a class="el" href="group__group__flags.html#ga72b0491c9cbf2071f0c96c7d29b719bb" title="The soap_mode flags to initialize the soap context, flags can be combined with | (bit-wise or) ...">soap_mode</a></code> flags. </p>
<p>This function initializes a context with the specified input and output <code><a class="el" href="group__group__flags.html#ga72b0491c9cbf2071f0c96c7d29b719bb" title="The soap_mode flags to initialize the soap context, flags can be combined with | (bit-wise or) ...">soap_mode</a></code> flags.</p>
<dl class="section note"><dt>Note</dt><dd>Initialization should be done at most once before calling <code><a class="el" href="group__group__context.html#ga28ee8fdcf500443e0e51750324aa6a1a" title="Finalize the given soap context, i.e. when the soap context is stack allocated, automatically invoked...">soap_done</a></code>. To change the input/output mode flags, use <code><a class="el" href="group__group__context.html#ga84f52a67a41009b260ff2c036df7f6ab" title="Set input and output soap_mode flags of the given soap context. ">soap_set_mode</a></code> and <code><a class="el" href="group__group__context.html#ga06f769f80bcea7beb2ebffd0a40fc521" title="Clear input and output soap_mode flags of the given soap context. ">soap_clr_mode</a></code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__group__context.html#ga8e034e1a7d6093eaddc11b647179657c" title="Initialize a stack-allocated soap context. ">soap_init</a></code>, <code><a class="el" href="group__group__context.html#ga87c20488b2dc680aaa7689b1d024989c" title="Allocate and initialize a new soap context. ">soap_new</a></code>, <code><a class="el" href="group__group__context.html#gab4c3f8ce80baf0f1fec8c86f0bb5788a" title="Allocate and initialize a new soap context as a copy of the given soap context. ">soap_copy</a></code>, <code><a class="el" href="group__group__context.html#gaf7d0176161e9def36981e24faa1913d9" title="Delete all dynamically-allocated C++ objects managed by the specified soap context. ">soap_destroy</a></code>, <code><a class="el" href="group__group__context.html#ga81a009ae1ea825a05e5241e2b7a8ece9" title="Delete all data from heap memory managed by the specified soap context and release the freed memory b...">soap_end</a></code>, <code><a class="el" href="group__group__context.html#ga28ee8fdcf500443e0e51750324aa6a1a" title="Finalize the given soap context, i.e. when the soap context is stack allocated, automatically invoked...">soap_done</a></code>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td><code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context to initialize </td></tr>
    <tr><td class="paramname">input_mode</td><td>input <code><a class="el" href="group__group__flags.html#ga72b0491c9cbf2071f0c96c7d29b719bb" title="The soap_mode flags to initialize the soap context, flags can be combined with | (bit-wise or) ...">soap_mode</a></code> flags </td></tr>
    <tr><td class="paramname">output_mode</td><td>output <code><a class="el" href="group__group__flags.html#ga72b0491c9cbf2071f0c96c7d29b719bb" title="The soap_mode flags to initialize the soap context, flags can be combined with | (bit-wise or) ...">soap_mode</a></code> flags </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaba556710e010feeb2211ed43b5bf059c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* soap_malloc </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsoap.html">soap</a> *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a block of heap memory managed by the specified <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context. </p>
<p>This function allocates a block of memory from the heap managed by the specified <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context. All such blocks allocated are deleted with a single call to <code><a class="el" href="group__group__context.html#ga81a009ae1ea825a05e5241e2b7a8ece9" title="Delete all data from heap memory managed by the specified soap context and release the freed memory b...">soap_end</a></code>. Returns a pointer to the allocated block of memory or NULL when out of memory without setting <code><a class="el" href="structsoap.html#ab85f5d42702963d13ea540bd9876e6d2" title="The soap context soap_status (int) error code of the last operation or SOAP_OK (zero) ...">soap::error</a></code>.</p>
<dl class="section note"><dt>Note</dt><dd>The soapcpp2 tool generates <code>soap_new_T</code> functions for all serialiable types <code>T</code>. The <code>soap_new_T</code> functions allocate and default initializes the type <code>T</code> or an array of items of type <code>T</code>. Recommended is to use these more powerful <code>soap_new_T</code> functions instead of <code><a class="el" href="group__group__context.html#gaba556710e010feeb2211ed43b5bf059c" title="Allocate a block of heap memory managed by the specified soap context. ">soap_malloc</a></code>. For example: <div class="fragment"><div class="line"><span class="preprocessor">#include &quot;soapH.h&quot;</span></div><div class="line"></div><div class="line"><span class="keyword">struct </span>soap *soap = <a class="code" href="group__group__context.html#ga87c20488b2dc680aaa7689b1d024989c">soap_new</a>();</div><div class="line"><span class="keyword">struct </span>ns__someElement *data = soap_new_ns__someElement(soap);       <span class="comment">// allocate managed object</span></div><div class="line"><span class="keyword">struct </span>ns__someElement *array = soap_new_ns__someElement(soap, 100); <span class="comment">// allocate array of 100 managed objects</span></div><div class="line">... <span class="comment">// send and receive messages etc.</span></div><div class="line"><a class="code" href="group__group__context.html#gaf7d0176161e9def36981e24faa1913d9">soap_destroy</a>(soap); <span class="comment">// deletes data, array, and other managed C++ objects</span></div><div class="line"><a class="code" href="group__group__context.html#ga81a009ae1ea825a05e5241e2b7a8ece9">soap_end</a>(soap);     <span class="comment">// delete managed memory</span></div><div class="line"><a class="code" href="group__group__context.html#ga57108ca4681186e58b5b189c3528f10a">soap_free</a>(soap);    <span class="comment">// free the context</span></div></div><!-- fragment --> The soapcpp2 tool also generates <code>soap_default_T</code> functions to default initialize the type <code>T</code>. For example: <div class="fragment"><div class="line"><span class="preprocessor">#include &quot;soapH.h&quot;</span></div><div class="line"></div><div class="line"><span class="keyword">struct </span>soap *soap = <a class="code" href="group__group__context.html#ga87c20488b2dc680aaa7689b1d024989c">soap_new</a>();</div><div class="line"><span class="keyword">struct </span>ns__someElement data;</div><div class="line">soap_default_ns__someElement(soap, &amp;data); <span class="comment">// default initializes all public members</span></div><div class="line">...</div></div><!-- fragment --> but objects of classes should use their <code>soap_default</code> method instead of the <code>soap_default_T</code> function.</dd></dl>
<dl class="section user"><dt>Example:</dt><dd></dd></dl>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;soapH.h&quot;</span></div><div class="line"></div><div class="line"><span class="keyword">struct </span>soap *soap = <a class="code" href="group__group__context.html#ga87c20488b2dc680aaa7689b1d024989c">soap_new</a>();</div><div class="line"><span class="keywordtype">char</span> *s = (<span class="keywordtype">char</span>*)<a class="code" href="group__group__context.html#gaba556710e010feeb2211ed43b5bf059c">soap_malloc</a>(soap, 80); <span class="comment">// allocate 80 bytes of memory managed by the context</span></div><div class="line">strcpy(s, <span class="stringliteral">&quot;Hello&quot;</span>);                     <span class="comment">// copy a string into it</span></div><div class="line">... <span class="comment">// send and receive messages etc.</span></div><div class="line"><a class="code" href="group__group__context.html#gaf7d0176161e9def36981e24faa1913d9">soap_destroy</a>(soap); <span class="comment">// delete managed C++ objects</span></div><div class="line"><a class="code" href="group__group__context.html#ga81a009ae1ea825a05e5241e2b7a8ece9">soap_end</a>(soap);     <span class="comment">// delete managed memory</span></div><div class="line"><a class="code" href="group__group__context.html#ga57108ca4681186e58b5b189c3528f10a">soap_free</a>(soap);    <span class="comment">// free the context</span></div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__group__context.html#ga41747ef145667bdff9c66cdd2bc86653" title="Copy a string to managed memory. ">soap_strdup</a></code>, <code><a class="el" href="group__group__context.html#ga7fe9c27b0f0eac077bc13caf816fbba8" title="Copy a wide string to managed memory. ">soap_wstrdup</a></code>, <code><a class="el" href="group__group__context.html#ga643bb3cdc192ec0dc1a8448498dab401" title="Unlink a block of heap memory managed by the specified soap context, to release the memory explicitly...">soap_unlink</a></code>, <code><a class="el" href="group__group__context.html#gaa959ff61609f7b324527e88655c2377f" title="Delegate the deletion of all managed objects and data from the specified soap context to another soap...">soap_delegate_deletion</a></code>, <code><a class="el" href="group__group__context.html#gaf7d0176161e9def36981e24faa1913d9" title="Delete all dynamically-allocated C++ objects managed by the specified soap context. ">soap_destroy</a></code>, <code><a class="el" href="group__group__context.html#ga81a009ae1ea825a05e5241e2b7a8ece9" title="Delete all data from heap memory managed by the specified soap context and release the freed memory b...">soap_end</a></code>, and the <a href="../../databinding/html/index.html">C and C++ XML data bindings</a> documentation.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the allocated block of memory or NULL on failure to allocate (out of memory) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td><code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context </td></tr>
    <tr><td class="paramname">len</td><td>length of the block to allocate in number of bytes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga87c20488b2dc680aaa7689b1d024989c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structsoap.html">soap</a>* soap_new </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate and initialize a new <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context. </p>
<p>This function allocates and initializes a new context.</p>
<p>There is no need to call <code><a class="el" href="group__group__context.html#ga8e034e1a7d6093eaddc11b647179657c" title="Initialize a stack-allocated soap context. ">soap_init</a></code> to initialize the context allocated with <code><a class="el" href="group__group__context.html#ga87c20488b2dc680aaa7689b1d024989c" title="Allocate and initialize a new soap context. ">soap_new</a></code>, since <code><a class="el" href="group__group__context.html#ga87c20488b2dc680aaa7689b1d024989c" title="Allocate and initialize a new soap context. ">soap_new</a></code> initializes the allocated context. To change the input/output mode flags, use <code><a class="el" href="group__group__context.html#ga84f52a67a41009b260ff2c036df7f6ab" title="Set input and output soap_mode flags of the given soap context. ">soap_set_mode</a></code> and <code><a class="el" href="group__group__context.html#ga06f769f80bcea7beb2ebffd0a40fc521" title="Clear input and output soap_mode flags of the given soap context. ">soap_clr_mode</a></code>.</p>
<dl class="section note"><dt>Note</dt><dd>C++ proxy and service classes generated by <b><code>soapcpp2 -j</code></b> option <b><code>-j</code></b> or option <b><code>-i</code></b> have an internal <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context that is either a base class (option <b><code>-i</code></b>) or a member variable pointing to a <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context (option <b><code>-j</code></b>). The C++ proxy and service classes allocate and deallocate this context, which means that <code><a class="el" href="group__group__context.html#ga87c20488b2dc680aaa7689b1d024989c" title="Allocate and initialize a new soap context. ">soap_new</a></code> and <code><a class="el" href="group__group__context.html#ga57108ca4681186e58b5b189c3528f10a" title="Finalize and free the given soap context from unmanaged heap memory. ">soap_free</a></code> are not required. For example: <div class="fragment"><div class="line"><span class="preprocessor">#include &quot;soapexampleProxy.h&quot;</span></div><div class="line"></div><div class="line">exampleProxy proxy(<a class="code" href="group__group__flags.html#ga0bfffccff8ea0245f4de6670a0b36e69">SOAP_XML_INDENT</a>);</div><div class="line">... <span class="comment">// use proxy or proxy.soap (option -j)</span></div><div class="line">proxy.destroy(); <span class="comment">// delete managed C++ objects and memory</span></div></div><!-- fragment --> <div class="fragment"><div class="line"><span class="preprocessor">#include &quot;soapexampleService.h&quot;</span></div><div class="line"></div><div class="line">exampleService service(<a class="code" href="group__group__flags.html#ga0bfffccff8ea0245f4de6670a0b36e69">SOAP_XML_INDENT</a>);</div><div class="line">... <span class="comment">// use service or service.soap (option -j)</span></div><div class="line">service.destroy(); <span class="comment">// delete managed C++ objects and memory</span></div></div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Example:</dt><dd></dd></dl>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;soapH.h&quot;</span></div><div class="line"></div><div class="line"><span class="keyword">struct </span>soap *soap = <a class="code" href="group__group__context.html#ga87c20488b2dc680aaa7689b1d024989c">soap_new</a>();</div><div class="line">... <span class="comment">// send and receive messages etc.</span></div><div class="line"><a class="code" href="group__group__context.html#gaf7d0176161e9def36981e24faa1913d9">soap_destroy</a>(soap); <span class="comment">// delete managed C++ objects</span></div><div class="line"><a class="code" href="group__group__context.html#ga81a009ae1ea825a05e5241e2b7a8ece9">soap_end</a>(soap);     <span class="comment">// delete managed memory</span></div><div class="line"><a class="code" href="group__group__context.html#ga57108ca4681186e58b5b189c3528f10a">soap_free</a>(soap);    <span class="comment">// free the context</span></div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__group__context.html#ga51cde138234ed7ec8c4e25bdf6418658" title="Allocate and initialize a new soap context with input and output soap_mode flags. ...">soap_new1</a></code>, <code><a class="el" href="group__group__context.html#ga12a87f6795b62b05164edc392b2adb1d" title="Allocate and initialize a new soap context with separate input and output soap_mode flags...">soap_new2</a></code>, <code><a class="el" href="group__group__context.html#gab4c3f8ce80baf0f1fec8c86f0bb5788a" title="Allocate and initialize a new soap context as a copy of the given soap context. ">soap_copy</a></code>, <code><a class="el" href="group__group__context.html#gaf7d0176161e9def36981e24faa1913d9" title="Delete all dynamically-allocated C++ objects managed by the specified soap context. ">soap_destroy</a></code>, <code><a class="el" href="group__group__context.html#ga81a009ae1ea825a05e5241e2b7a8ece9" title="Delete all data from heap memory managed by the specified soap context and release the freed memory b...">soap_end</a></code>, <code><a class="el" href="group__group__context.html#ga57108ca4681186e58b5b189c3528f10a" title="Finalize and free the given soap context from unmanaged heap memory. ">soap_free</a></code>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to allocated and initialized <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context or NULL when out of heap memory </dd></dl>

</div>
</div>
<a class="anchor" id="ga51cde138234ed7ec8c4e25bdf6418658"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structsoap.html">soap</a>* soap_new1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__flags.html#ga72b0491c9cbf2071f0c96c7d29b719bb">soap_mode</a>&#160;</td>
          <td class="paramname"><em>input_and_output_mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate and initialize a new <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context with input and output <code><a class="el" href="group__group__flags.html#ga72b0491c9cbf2071f0c96c7d29b719bb" title="The soap_mode flags to initialize the soap context, flags can be combined with | (bit-wise or) ...">soap_mode</a></code> flags. </p>
<p>This function allocates and initializes a new context with the specified input and output <code><a class="el" href="group__group__flags.html#ga72b0491c9cbf2071f0c96c7d29b719bb" title="The soap_mode flags to initialize the soap context, flags can be combined with | (bit-wise or) ...">soap_mode</a></code> flags.</p>
<dl class="section user"><dt>Example:</dt><dd></dd></dl>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;soapH.h&quot;</span></div><div class="line"></div><div class="line"><span class="keyword">struct </span>soap *soap = <a class="code" href="group__group__context.html#ga51cde138234ed7ec8c4e25bdf6418658">soap_new1</a>(<a class="code" href="group__group__flags.html#ga0bfffccff8ea0245f4de6670a0b36e69">SOAP_XML_INDENT</a>);</div><div class="line">... <span class="comment">// send and receive messages etc.</span></div><div class="line"><a class="code" href="group__group__context.html#gaf7d0176161e9def36981e24faa1913d9">soap_destroy</a>(soap); <span class="comment">// delete managed C++ objects</span></div><div class="line"><a class="code" href="group__group__context.html#ga81a009ae1ea825a05e5241e2b7a8ece9">soap_end</a>(soap);     <span class="comment">// delete managed memory</span></div><div class="line"><a class="code" href="group__group__context.html#ga57108ca4681186e58b5b189c3528f10a">soap_free</a>(soap);    <span class="comment">// free the context</span></div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>There is no need to call <code><a class="el" href="group__group__context.html#ga8e034e1a7d6093eaddc11b647179657c" title="Initialize a stack-allocated soap context. ">soap_init</a></code> to initialize the context allocated with <code><a class="el" href="group__group__context.html#ga51cde138234ed7ec8c4e25bdf6418658" title="Allocate and initialize a new soap context with input and output soap_mode flags. ...">soap_new1</a></code>. To change the input/output mode flags, use <code><a class="el" href="group__group__context.html#ga84f52a67a41009b260ff2c036df7f6ab" title="Set input and output soap_mode flags of the given soap context. ">soap_set_mode</a></code> and <code><a class="el" href="group__group__context.html#ga06f769f80bcea7beb2ebffd0a40fc521" title="Clear input and output soap_mode flags of the given soap context. ">soap_clr_mode</a></code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__group__context.html#ga87c20488b2dc680aaa7689b1d024989c" title="Allocate and initialize a new soap context. ">soap_new</a></code>, <code><a class="el" href="group__group__context.html#ga12a87f6795b62b05164edc392b2adb1d" title="Allocate and initialize a new soap context with separate input and output soap_mode flags...">soap_new2</a></code>, <code><a class="el" href="group__group__context.html#gab4c3f8ce80baf0f1fec8c86f0bb5788a" title="Allocate and initialize a new soap context as a copy of the given soap context. ">soap_copy</a></code>, <code><a class="el" href="group__group__context.html#gaf7d0176161e9def36981e24faa1913d9" title="Delete all dynamically-allocated C++ objects managed by the specified soap context. ">soap_destroy</a></code>, <code><a class="el" href="group__group__context.html#ga81a009ae1ea825a05e5241e2b7a8ece9" title="Delete all data from heap memory managed by the specified soap context and release the freed memory b...">soap_end</a></code>, <code><a class="el" href="group__group__context.html#ga57108ca4681186e58b5b189c3528f10a" title="Finalize and free the given soap context from unmanaged heap memory. ">soap_free</a></code>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to allocated and initialized <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context or NULL when out of heap memory </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input_and_output_mode</td><td>input and output <code><a class="el" href="group__group__flags.html#ga72b0491c9cbf2071f0c96c7d29b719bb" title="The soap_mode flags to initialize the soap context, flags can be combined with | (bit-wise or) ...">soap_mode</a></code> flags </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga12a87f6795b62b05164edc392b2adb1d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structsoap.html">soap</a>* soap_new2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__flags.html#ga72b0491c9cbf2071f0c96c7d29b719bb">soap_mode</a>&#160;</td>
          <td class="paramname"><em>input_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__flags.html#ga72b0491c9cbf2071f0c96c7d29b719bb">soap_mode</a>&#160;</td>
          <td class="paramname"><em>output_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate and initialize a new <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context with separate input and output <code><a class="el" href="group__group__flags.html#ga72b0491c9cbf2071f0c96c7d29b719bb" title="The soap_mode flags to initialize the soap context, flags can be combined with | (bit-wise or) ...">soap_mode</a></code> flags. </p>
<p>This function allocates and initializes a new context with the specified input and output <code><a class="el" href="group__group__flags.html#ga72b0491c9cbf2071f0c96c7d29b719bb" title="The soap_mode flags to initialize the soap context, flags can be combined with | (bit-wise or) ...">soap_mode</a></code> flags. The separation of input and output mode flags is only useful for the <code><a class="el" href="group__group__flags.html#gaa631be9579f581f96ea5ecf91b837493" title="soap_mode XML input/output flag value to serialize C/C++ data structures as XML trees without id-href...">SOAP_XML_TREE</a></code> flag that affects both input and output behaviors.</p>
<dl class="section note"><dt>Note</dt><dd>There is no need to call <code><a class="el" href="group__group__context.html#ga8e034e1a7d6093eaddc11b647179657c" title="Initialize a stack-allocated soap context. ">soap_init</a></code> to initialize the context allocated with <code><a class="el" href="group__group__context.html#ga12a87f6795b62b05164edc392b2adb1d" title="Allocate and initialize a new soap context with separate input and output soap_mode flags...">soap_new2</a></code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__group__context.html#ga87c20488b2dc680aaa7689b1d024989c" title="Allocate and initialize a new soap context. ">soap_new</a></code>, <code><a class="el" href="group__group__context.html#ga51cde138234ed7ec8c4e25bdf6418658" title="Allocate and initialize a new soap context with input and output soap_mode flags. ...">soap_new1</a></code>, <code><a class="el" href="group__group__context.html#gab4c3f8ce80baf0f1fec8c86f0bb5788a" title="Allocate and initialize a new soap context as a copy of the given soap context. ">soap_copy</a></code>, <code><a class="el" href="group__group__context.html#gaf7d0176161e9def36981e24faa1913d9" title="Delete all dynamically-allocated C++ objects managed by the specified soap context. ">soap_destroy</a></code>, <code><a class="el" href="group__group__context.html#ga81a009ae1ea825a05e5241e2b7a8ece9" title="Delete all data from heap memory managed by the specified soap context and release the freed memory b...">soap_end</a></code>, <code><a class="el" href="group__group__context.html#ga57108ca4681186e58b5b189c3528f10a" title="Finalize and free the given soap context from unmanaged heap memory. ">soap_free</a></code>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to allocated and initialized <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context or NULL when out of heap memory </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input_mode</td><td>input <code><a class="el" href="group__group__flags.html#ga72b0491c9cbf2071f0c96c7d29b719bb" title="The soap_mode flags to initialize the soap context, flags can be combined with | (bit-wise or) ...">soap_mode</a></code> flags </td></tr>
    <tr><td class="paramname">output_mode</td><td>output <code><a class="el" href="group__group__flags.html#ga72b0491c9cbf2071f0c96c7d29b719bb" title="The soap_mode flags to initialize the soap context, flags can be combined with | (bit-wise or) ...">soap_mode</a></code> flags </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa9b0819dae844b848bcd8a3598a301aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void soap_set_imode </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsoap.html">soap</a> *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__flags.html#ga72b0491c9cbf2071f0c96c7d29b719bb">soap_mode</a>&#160;</td>
          <td class="paramname"><em>input_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set input <code><a class="el" href="group__group__flags.html#ga72b0491c9cbf2071f0c96c7d29b719bb" title="The soap_mode flags to initialize the soap context, flags can be combined with | (bit-wise or) ...">soap_mode</a></code> flags of the given <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td><code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context </td></tr>
    <tr><td class="paramname">input_mode</td><td>input <code><a class="el" href="group__group__flags.html#ga72b0491c9cbf2071f0c96c7d29b719bb" title="The soap_mode flags to initialize the soap context, flags can be combined with | (bit-wise or) ...">soap_mode</a></code> flags </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga84f52a67a41009b260ff2c036df7f6ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void soap_set_mode </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsoap.html">soap</a> *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__flags.html#ga72b0491c9cbf2071f0c96c7d29b719bb">soap_mode</a>&#160;</td>
          <td class="paramname"><em>input_and_output_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set input and output <code><a class="el" href="group__group__flags.html#ga72b0491c9cbf2071f0c96c7d29b719bb" title="The soap_mode flags to initialize the soap context, flags can be combined with | (bit-wise or) ...">soap_mode</a></code> flags of the given <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td><code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context </td></tr>
    <tr><td class="paramname">input_and_output_mode</td><td>input and output <code><a class="el" href="group__group__flags.html#ga72b0491c9cbf2071f0c96c7d29b719bb" title="The soap_mode flags to initialize the soap context, flags can be combined with | (bit-wise or) ...">soap_mode</a></code> flags </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf6fa6e197f360834eae124fa37e68cf7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void soap_set_omode </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsoap.html">soap</a> *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__flags.html#ga72b0491c9cbf2071f0c96c7d29b719bb">soap_mode</a>&#160;</td>
          <td class="paramname"><em>output_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set output <code><a class="el" href="group__group__flags.html#ga72b0491c9cbf2071f0c96c7d29b719bb" title="The soap_mode flags to initialize the soap context, flags can be combined with | (bit-wise or) ...">soap_mode</a></code> flags of the given <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td><code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context </td></tr>
    <tr><td class="paramname">output_mode</td><td>output <code><a class="el" href="group__group__flags.html#ga72b0491c9cbf2071f0c96c7d29b719bb" title="The soap_mode flags to initialize the soap context, flags can be combined with | (bit-wise or) ...">soap_mode</a></code> flags </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7c0a034b54cd46ee06ce1253e5a40467"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void soap_set_version </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsoap.html">soap</a> *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set SOAP version (0 = no SOAP, 1 = SOAP 1.1, 2 = SOAP 1.2) </p>
<p>This function sets (or overrides) the SOAP version to use when sending a message. This function can be used prior to a client-side call to select the SOAP version to use for the request message (assuming the generated code does not fix the version already) or in a service operation to select the SOAP version of the response message. The response message of a service operation normally uses the same SOAP version of the SOAP request message received. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td><code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> contexr </td></tr>
    <tr><td class="paramname">version</td><td>SOAP version (0 = REST (no SOAP), 1 = SOAP 1.1, 2 = SOAP 1.2) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga41747ef145667bdff9c66cdd2bc86653"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* soap_strdup </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsoap.html">soap</a> *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy a string to managed memory. </p>
<p>This function copies the specified wide string to memory managed by the specified context. Returns a copy of the string or NULL when the specified string is NULL or when the function failed to allocate memory.</p>
<dl class="section user"><dt>Example:</dt><dd></dd></dl>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;soapH.h&quot;</span></div><div class="line"></div><div class="line"><span class="keyword">struct </span>soap *soap = <a class="code" href="group__group__context.html#ga87c20488b2dc680aaa7689b1d024989c">soap_new</a>();</div><div class="line"><span class="comment">// allocate and assign a string in memory managed by the context</span></div><div class="line"><span class="keywordtype">char</span> *s = <a class="code" href="group__group__context.html#ga41747ef145667bdff9c66cdd2bc86653">soap_strdup</a>(soap, <span class="stringliteral">&quot;Hello&quot;</span>);</div><div class="line">... <span class="comment">// send and receive messages etc.</span></div><div class="line"><a class="code" href="group__group__context.html#gaf7d0176161e9def36981e24faa1913d9">soap_destroy</a>(soap); <span class="comment">// delete managed C++ objects</span></div><div class="line"><a class="code" href="group__group__context.html#ga81a009ae1ea825a05e5241e2b7a8ece9">soap_end</a>(soap);     <span class="comment">// delete managed memory</span></div><div class="line"><a class="code" href="group__group__context.html#ga57108ca4681186e58b5b189c3528f10a">soap_free</a>(soap);    <span class="comment">// free the context</span></div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__group__context.html#gaba556710e010feeb2211ed43b5bf059c" title="Allocate a block of heap memory managed by the specified soap context. ">soap_malloc</a></code>, <code><a class="el" href="group__group__context.html#ga7fe9c27b0f0eac077bc13caf816fbba8" title="Copy a wide string to managed memory. ">soap_wstrdup</a></code>, <code><a class="el" href="group__group__context.html#ga643bb3cdc192ec0dc1a8448498dab401" title="Unlink a block of heap memory managed by the specified soap context, to release the memory explicitly...">soap_unlink</a></code>, <code><a class="el" href="group__group__context.html#gaa959ff61609f7b324527e88655c2377f" title="Delegate the deletion of all managed objects and data from the specified soap context to another soap...">soap_delegate_deletion</a></code>, <code><a class="el" href="group__group__context.html#gaf7d0176161e9def36981e24faa1913d9" title="Delete all dynamically-allocated C++ objects managed by the specified soap context. ">soap_destroy</a></code>, <code><a class="el" href="group__group__context.html#ga81a009ae1ea825a05e5241e2b7a8ece9" title="Delete all data from heap memory managed by the specified soap context and release the freed memory b...">soap_end</a></code>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>copy of string or NULL when the specified string is NULL or on failure to allocate (out of memory) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td><code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context </td></tr>
    <tr><td class="paramname">string</td><td>string to copy to managed memory </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga643bb3cdc192ec0dc1a8448498dab401"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soap_unlink </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsoap.html">soap</a> *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unlink a block of heap memory managed by the specified <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context, to release the memory explicitly later. </p>
<p>This function removes a managed block of memory from the managing <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context. This memory is not released but rather should be released explicitly later by the application logic using <code>free</code> or <code>delete</code>. Returns <code><a class="el" href="group__group__errors.html#ga3b10a68f354f39cbb0fe0d043ad4c7c0" title="The soap_status code for no error (zero) ">SOAP_OK</a></code> when successful or <code><a class="el" href="group__group__errors.html#ga1273756841a728f037ee5328e217eb6e" title="A soap_status error code: an unspecified error occurred. ">SOAP_ERR</a></code> when the block is not managed by the specified context.</p><dl class="section return"><dt>Returns</dt><dd><code><a class="el" href="group__group__errors.html#ga3b10a68f354f39cbb0fe0d043ad4c7c0" title="The soap_status code for no error (zero) ">SOAP_OK</a></code> when successful or <code><a class="el" href="group__group__errors.html#ga1273756841a728f037ee5328e217eb6e" title="A soap_status error code: an unspecified error occurred. ">SOAP_ERR</a></code> when the block is not managed by the specified context </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td><code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context </td></tr>
    <tr><td class="paramname">ptr</td><td>pointer to the block of managed heap memory to unlink </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7fe9c27b0f0eac077bc13caf816fbba8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">wchar_t* soap_wstrdup </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsoap.html">soap</a> *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wchar_t *&#160;</td>
          <td class="paramname"><em>string</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy a wide string to managed memory. </p>
<p>This function copies the specified wide string to managed memory. Returns a copy of the wide string or NULL when the specified wide string is NULL or when the function failed to allocate memory.</p>
<dl class="section user"><dt>Example:</dt><dd></dd></dl>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;soapH.h&quot;</span></div><div class="line"></div><div class="line"><span class="keyword">struct </span>soap *soap = <a class="code" href="group__group__context.html#ga87c20488b2dc680aaa7689b1d024989c">soap_new</a>();</div><div class="line"><span class="comment">// allocate and assign a wide string in memory managed by the context</span></div><div class="line"><span class="keywordtype">wchar_t</span> *s = <a class="code" href="group__group__context.html#ga7fe9c27b0f0eac077bc13caf816fbba8">soap_wstrdup</a>(soap, L<span class="stringliteral">&quot;Hello&quot;</span>);</div><div class="line">... <span class="comment">// send and receive messages etc.</span></div><div class="line"><a class="code" href="group__group__context.html#gaf7d0176161e9def36981e24faa1913d9">soap_destroy</a>(soap); <span class="comment">// delete managed C++ objects</span></div><div class="line"><a class="code" href="group__group__context.html#ga81a009ae1ea825a05e5241e2b7a8ece9">soap_end</a>(soap);     <span class="comment">// delete managed memory</span></div><div class="line"><a class="code" href="group__group__context.html#ga57108ca4681186e58b5b189c3528f10a">soap_free</a>(soap);    <span class="comment">// free the context</span></div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__group__context.html#gaba556710e010feeb2211ed43b5bf059c" title="Allocate a block of heap memory managed by the specified soap context. ">soap_malloc</a></code>, <code><a class="el" href="group__group__context.html#ga41747ef145667bdff9c66cdd2bc86653" title="Copy a string to managed memory. ">soap_strdup</a></code>, <code><a class="el" href="group__group__context.html#ga643bb3cdc192ec0dc1a8448498dab401" title="Unlink a block of heap memory managed by the specified soap context, to release the memory explicitly...">soap_unlink</a></code>, <code><a class="el" href="group__group__context.html#gaa959ff61609f7b324527e88655c2377f" title="Delegate the deletion of all managed objects and data from the specified soap context to another soap...">soap_delegate_deletion</a></code>, <code><a class="el" href="group__group__context.html#gaf7d0176161e9def36981e24faa1913d9" title="Delete all dynamically-allocated C++ objects managed by the specified soap context. ">soap_destroy</a></code>, <code><a class="el" href="group__group__context.html#ga81a009ae1ea825a05e5241e2b7a8ece9" title="Delete all data from heap memory managed by the specified soap context and release the freed memory b...">soap_end</a></code>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>copy of wide string or NULL when the specified wide string is NULL or on failure to allocate (out of memory) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td><code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context </td></tr>
    <tr><td class="paramname">string</td><td>wide string to copy to managed memory or NULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<hr class="footer">
<address class="footer">
Copyright (C) 2021, Robert van Engelen, Genivia Inc., All Rights Reserved.
</address>
<address class="footer"><small>
Converted on Tue Apr 20 2021 19:48:13 by <a target="_blank" href="http://www.doxygen.org/index.html">Doxygen</a> 1.8.11</small></address>
<br>
<div style="height: 246px; background: #DBDBDB;">
</body>
</html>
