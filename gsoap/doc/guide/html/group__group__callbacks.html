<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8">
<meta http-equiv="cache-control" content="no-cache">
<title>Genivia - Callback functions</title>
<link href="genivia_tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="genivia_content.css" rel="stylesheet" type="text/css">
</head>
<body>
<div id="top">
 <div id="titlearea">
  <table height="72px" width="100%" cellspacing="0" cellpadding="0">
   <tbody>
    <tr>
     <td width="10%">&nbsp;</td>
     <td width="175px"><a href="https://www.genivia.com"><img alt="Genivia" src="GeniviaLogo2_trans_noslogan.png"/></a></td>
     <td class="tab_home"><a href="https://www.genivia.com">Home</a></td>
     <td class="tab_home"><a href="https://www.genivia.com/docs.html">Documentation</a></td>
     <td>
      <div style="float: right; font-size: 18px; font-weight: bold;">Callback functions</div>
      <br>
      <div style="float: right; font-size: 10px;">updated Wed Mar 22 2023 by Robert van Engelen</div>
     </td>
     <td width="10%">&nbsp;</td>
    </tr>
   </tbody>
  </table>
 </div>
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__group__callbacks.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Callback functions</div>  </div>
</div><!--header-->
<div class="contents">

<p>This module defines the callback functions of the <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context to modify its behavior, as is done by plugins.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga78d2b5440b33d3882b595ca8cfdec425"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__callbacks.html#ga78d2b5440b33d3882b595ca8cfdec425">soap::fpost</a> )(struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, const char *endpoint, const char *host, int port, const char *path, const char *action, <a class="el" href="group__group__soap.html#ga7c6e38d209f60a18e362172dca1a3b6e">ULONG64</a> count)</td></tr>
<tr class="memdesc:ga78d2b5440b33d3882b595ca8cfdec425"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback that populates and then sends HTTP headers from the client-side to a connected HTTP server.  <a href="#ga78d2b5440b33d3882b595ca8cfdec425">More...</a><br /></td></tr>
<tr class="separator:ga78d2b5440b33d3882b595ca8cfdec425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d8e8e2b7ad7f1ac995c287b3a9f67a9"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__callbacks.html#ga3d8e8e2b7ad7f1ac995c287b3a9f67a9">soap::fresponse</a> )(struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, int status, <a class="el" href="group__group__soap.html#ga7c6e38d209f60a18e362172dca1a3b6e">ULONG64</a> count)</td></tr>
<tr class="memdesc:ga3d8e8e2b7ad7f1ac995c287b3a9f67a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback that populates and then sends HTTP headers from the server-side to a connected client.  <a href="#ga3d8e8e2b7ad7f1ac995c287b3a9f67a9">More...</a><br /></td></tr>
<tr class="separator:ga3d8e8e2b7ad7f1ac995c287b3a9f67a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab836b5b06024279f4ee190e69d7ccf75"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__callbacks.html#gab836b5b06024279f4ee190e69d7ccf75">soap::fposthdr</a> )(struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, const char *key, const char *val)</td></tr>
<tr class="memdesc:gab836b5b06024279f4ee190e69d7ccf75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback that sends a single HTTP header given a key-value pair.  <a href="#gab836b5b06024279f4ee190e69d7ccf75">More...</a><br /></td></tr>
<tr class="separator:gab836b5b06024279f4ee190e69d7ccf75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9cb05ce98f845f16c920c44426ac35a5"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__callbacks.html#ga9cb05ce98f845f16c920c44426ac35a5">soap::fparse</a> )(struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>)</td></tr>
<tr class="memdesc:ga9cb05ce98f845f16c920c44426ac35a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback that reads and parses HTTP and MIME headers.  <a href="#ga9cb05ce98f845f16c920c44426ac35a5">More...</a><br /></td></tr>
<tr class="separator:ga9cb05ce98f845f16c920c44426ac35a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70b75026b5fb1a9a2d5779f72454f082"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__callbacks.html#ga70b75026b5fb1a9a2d5779f72454f082">soap::fparsehdr</a> )(struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, const char *key, const char *val)</td></tr>
<tr class="memdesc:ga70b75026b5fb1a9a2d5779f72454f082"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback that consumes an HTTP header that consists of a key-value pair.  <a href="#ga70b75026b5fb1a9a2d5779f72454f082">More...</a><br /></td></tr>
<tr class="separator:ga70b75026b5fb1a9a2d5779f72454f082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae022204ff7004df2d5ac9e083cbb5b16"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__callbacks.html#gae022204ff7004df2d5ac9e083cbb5b16">soap::fget</a> )(struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>)</td></tr>
<tr class="memdesc:gae022204ff7004df2d5ac9e083cbb5b16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to implement logic at the server-side to serve responses to HTTP GET requests from clients.  <a href="#gae022204ff7004df2d5ac9e083cbb5b16">More...</a><br /></td></tr>
<tr class="separator:gae022204ff7004df2d5ac9e083cbb5b16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf263ffe14d8c2508ce4c734d4f33a854"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__callbacks.html#gaf263ffe14d8c2508ce4c734d4f33a854">soap::fput</a> )(struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>)</td></tr>
<tr class="memdesc:gaf263ffe14d8c2508ce4c734d4f33a854"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to implement logic at the server-side to serve responses to HTTP PUT requests from clients.  <a href="#gaf263ffe14d8c2508ce4c734d4f33a854">More...</a><br /></td></tr>
<tr class="separator:gaf263ffe14d8c2508ce4c734d4f33a854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga808a6a9b7e6d17e039fb53a5e8a9b84a"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__callbacks.html#ga808a6a9b7e6d17e039fb53a5e8a9b84a">soap::fpatch</a> )(struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>)</td></tr>
<tr class="memdesc:ga808a6a9b7e6d17e039fb53a5e8a9b84a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to implement logic at the server-side to serve responses to HTTP PATCH requests from clients.  <a href="#ga808a6a9b7e6d17e039fb53a5e8a9b84a">More...</a><br /></td></tr>
<tr class="separator:ga808a6a9b7e6d17e039fb53a5e8a9b84a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2bda0187489c8f2b9857f61b96ad0e0"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__callbacks.html#gaf2bda0187489c8f2b9857f61b96ad0e0">soap::fdel</a> )(struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>)</td></tr>
<tr class="memdesc:gaf2bda0187489c8f2b9857f61b96ad0e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to implement logic at the server-side to serve responses to HTTP DELETE requests from clients.  <a href="#gaf2bda0187489c8f2b9857f61b96ad0e0">More...</a><br /></td></tr>
<tr class="separator:gaf2bda0187489c8f2b9857f61b96ad0e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65272c1ecb5ed9925a5a670cf7e77d10"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__callbacks.html#ga65272c1ecb5ed9925a5a670cf7e77d10">soap::fopt</a> )(struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>)</td></tr>
<tr class="memdesc:ga65272c1ecb5ed9925a5a670cf7e77d10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to implement logic at the server-side to serve responses to HTTP OPTION requests from clients.  <a href="#ga65272c1ecb5ed9925a5a670cf7e77d10">More...</a><br /></td></tr>
<tr class="separator:ga65272c1ecb5ed9925a5a670cf7e77d10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadff52b7b3ecc16379eb2d7b1ff361978"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__callbacks.html#gadff52b7b3ecc16379eb2d7b1ff361978">soap::fhead</a> )(struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>)</td></tr>
<tr class="memdesc:gadff52b7b3ecc16379eb2d7b1ff361978"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to implement logic at the server-side to serve responses to HTTP HEAD requests from clients.  <a href="#gadff52b7b3ecc16379eb2d7b1ff361978">More...</a><br /></td></tr>
<tr class="separator:gadff52b7b3ecc16379eb2d7b1ff361978"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga052cdf13e382b4af3d16128955546671"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__callbacks.html#ga052cdf13e382b4af3d16128955546671">soap::fform</a> )(struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>)</td></tr>
<tr class="memdesc:ga052cdf13e382b4af3d16128955546671"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to implement logic at the server-side to handle HTML forms, such as done by the callbacks provided by the HTTP FORM handler plugin.  <a href="#ga052cdf13e382b4af3d16128955546671">More...</a><br /></td></tr>
<tr class="separator:ga052cdf13e382b4af3d16128955546671"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae88b674df5fdcfa866c04e4330fe0afe"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__callbacks.html#gae88b674df5fdcfa866c04e4330fe0afe">soap::fheader</a> )(struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>)</td></tr>
<tr class="memdesc:gae88b674df5fdcfa866c04e4330fe0afe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to inspect the SOAP Header received before the rest of the message with the SOAP Body is consumed.  <a href="#gae88b674df5fdcfa866c04e4330fe0afe">More...</a><br /></td></tr>
<tr class="separator:gae88b674df5fdcfa866c04e4330fe0afe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6662bdcf10ff0ba101adfbef3a4c17d4"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__callbacks.html#ga6662bdcf10ff0ba101adfbef3a4c17d4">soap::fencoding</a> )(struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, const char *encoding)</td></tr>
<tr class="memdesc:ga6662bdcf10ff0ba101adfbef3a4c17d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to catch unrecognized XML encoding formats.  <a href="#ga6662bdcf10ff0ba101adfbef3a4c17d4">More...</a><br /></td></tr>
<tr class="separator:ga6662bdcf10ff0ba101adfbef3a4c17d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c2e1a0b5a5197128af1acc48662b1bd"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__callbacks.html#ga0c2e1a0b5a5197128af1acc48662b1bd">soap::fignore</a> )(struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, const char *tag)</td></tr>
<tr class="memdesc:ga0c2e1a0b5a5197128af1acc48662b1bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to catch unrecognized XML elements and overrides <code><a class="el" href="group__group__flags.html#ga5faa29a69a247642495846d69ec8b90d" title="soap_mode XML input flag value to enable strict XML validation of messages received ...">SOAP_XML_STRICT</a></code> validation errors for these.  <a href="#ga0c2e1a0b5a5197128af1acc48662b1bd">More...</a><br /></td></tr>
<tr class="separator:ga0c2e1a0b5a5197128af1acc48662b1bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a5e29b860d28f855c8d9a67c096d311"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__callbacks.html#ga6a5e29b860d28f855c8d9a67c096d311">soap::fsvalidate</a> )(struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, const char *pattern, const char *string)</td></tr>
<tr class="memdesc:ga6a5e29b860d28f855c8d9a67c096d311"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to validate strings against XML regex patterns.  <a href="#ga6a5e29b860d28f855c8d9a67c096d311">More...</a><br /></td></tr>
<tr class="separator:ga6a5e29b860d28f855c8d9a67c096d311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a38366b5b84730713c45ccada84e3ca"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__callbacks.html#ga1a38366b5b84730713c45ccada84e3ca">soap::fwvalidate</a> )(struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, const char *pattern, const wchar_t *string)</td></tr>
<tr class="memdesc:ga1a38366b5b84730713c45ccada84e3ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to validate wide strings against XML regex patterns.  <a href="#ga1a38366b5b84730713c45ccada84e3ca">More...</a><br /></td></tr>
<tr class="separator:ga1a38366b5b84730713c45ccada84e3ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4523d86587b4181a138850b92498f5b7"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__callbacks.html#ga4523d86587b4181a138850b92498f5b7">soap::fseterror</a> )(struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, const char **faultcode, const char **faultstring)</td></tr>
<tr class="memdesc:ga4523d86587b4181a138850b92498f5b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to inspect or override fault code or fault string messages.  <a href="#ga4523d86587b4181a138850b92498f5b7">More...</a><br /></td></tr>
<tr class="separator:ga4523d86587b4181a138850b92498f5b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b4985eb5a588f4c16ad88ef7ca329dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__soap.html#ga6eb1bde7cecc2fbadbcbbc6395227439">SOAP_SOCKET</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__callbacks.html#ga9b4985eb5a588f4c16ad88ef7ca329dc">soap::fopen</a> )(struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, const char *endpoint, const char *host, int port)</td></tr>
<tr class="memdesc:ga9b4985eb5a588f4c16ad88ef7ca329dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback that opens a socket connection to a server endpoint.  <a href="#ga9b4985eb5a588f4c16ad88ef7ca329dc">More...</a><br /></td></tr>
<tr class="separator:ga9b4985eb5a588f4c16ad88ef7ca329dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8249b4c23f662dbe680ad0deef274ae8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__soap.html#ga6eb1bde7cecc2fbadbcbbc6395227439">SOAP_SOCKET</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__callbacks.html#ga8249b4c23f662dbe680ad0deef274ae8">soap::faccept</a> )(struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, <a class="el" href="group__group__soap.html#ga6eb1bde7cecc2fbadbcbbc6395227439">SOAP_SOCKET</a> sock, struct sockaddr *addr, int *len)</td></tr>
<tr class="memdesc:ga8249b4c23f662dbe680ad0deef274ae8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback that waits for and accepts a socket connection requested by a client.  <a href="#ga8249b4c23f662dbe680ad0deef274ae8">More...</a><br /></td></tr>
<tr class="separator:ga8249b4c23f662dbe680ad0deef274ae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9591dd80dbb0e571784bad5421b2202"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__callbacks.html#gab9591dd80dbb0e571784bad5421b2202">soap::fclose</a> )(struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>)</td></tr>
<tr class="memdesc:gab9591dd80dbb0e571784bad5421b2202"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback that closes the current socket connection.  <a href="#gab9591dd80dbb0e571784bad5421b2202">More...</a><br /></td></tr>
<tr class="separator:gab9591dd80dbb0e571784bad5421b2202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ae800fa60c5e65a867e5d0e3ce7223e"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__callbacks.html#ga0ae800fa60c5e65a867e5d0e3ce7223e">soap::fresolve</a> )(struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, const char *name, struct in_addr *inaddr)</td></tr>
<tr class="memdesc:ga0ae800fa60c5e65a867e5d0e3ce7223e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback that resolves a host name by address translation.  <a href="#ga0ae800fa60c5e65a867e5d0e3ce7223e">More...</a><br /></td></tr>
<tr class="separator:ga0ae800fa60c5e65a867e5d0e3ce7223e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a0d27154b0e9e32d9adbcc4efc92b5c"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__callbacks.html#ga0a0d27154b0e9e32d9adbcc4efc92b5c">soap::fconnect</a> )(struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, const char *endpoint, const char *host, int port)</td></tr>
<tr class="memdesc:ga0a0d27154b0e9e32d9adbcc4efc92b5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback that overrides the client-side connecting operations.  <a href="#ga0a0d27154b0e9e32d9adbcc4efc92b5c">More...</a><br /></td></tr>
<tr class="separator:ga0a0d27154b0e9e32d9adbcc4efc92b5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2de194075f645d77c15f78c52ca24858"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__callbacks.html#ga2de194075f645d77c15f78c52ca24858">soap::fdisconnect</a> )(struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>)</td></tr>
<tr class="memdesc:ga2de194075f645d77c15f78c52ca24858"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback that executes disconnect logic before closing.  <a href="#ga2de194075f645d77c15f78c52ca24858">More...</a><br /></td></tr>
<tr class="separator:ga2de194075f645d77c15f78c52ca24858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21edadcbd081c7f37822d04bb05a9d29"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__callbacks.html#ga21edadcbd081c7f37822d04bb05a9d29">soap::fclosesocket</a> )(struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, <a class="el" href="group__group__soap.html#ga6eb1bde7cecc2fbadbcbbc6395227439">SOAP_SOCKET</a> sock)</td></tr>
<tr class="memdesc:ga21edadcbd081c7f37822d04bb05a9d29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback that closes a given socket.  <a href="#ga21edadcbd081c7f37822d04bb05a9d29">More...</a><br /></td></tr>
<tr class="separator:ga21edadcbd081c7f37822d04bb05a9d29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51e09ddf769a2ddcd874fb6e6fb5289d"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__callbacks.html#ga51e09ddf769a2ddcd874fb6e6fb5289d">soap::fshutdownsocket</a> )(struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, <a class="el" href="group__group__soap.html#ga6eb1bde7cecc2fbadbcbbc6395227439">SOAP_SOCKET</a> sock, int how)</td></tr>
<tr class="memdesc:ga51e09ddf769a2ddcd874fb6e6fb5289d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback that shuts down a given socket.  <a href="#ga51e09ddf769a2ddcd874fb6e6fb5289d">More...</a><br /></td></tr>
<tr class="separator:ga51e09ddf769a2ddcd874fb6e6fb5289d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20210aa171019b27ef182d853e2d6e2f"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__callbacks.html#ga20210aa171019b27ef182d853e2d6e2f">soap::fpoll</a> )(struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>)</td></tr>
<tr class="memdesc:ga20210aa171019b27ef182d853e2d6e2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback that blocks until activity is detected on the <code><a class="el" href="structsoap.html#a1579bd8bd106afc9a906a673ca473046" title="The socket set by soap_accept (or the C++ service class accept method) or soap_connect or soap_connec...">soap::socket</a></code> or <code><a class="el" href="structsoap.html#ab649b8f3b71081d14ec6350ab4b06794" title="The socket set by soap_bind (or the C++ service class bind method) to serve as the master socket boun...">soap::master</a></code> socket, times out when <code><a class="el" href="structsoap.html#a711bb3a53de7cc62429e4d3a2e0b5474" title="User-definable timeout to send a packet of data, positive timeout values are seconds, negative timeout values are microseconds, zero means no timeout (the value is 0 by default) ">soap::send_timeout</a></code> or <code><a class="el" href="structsoap.html#ac5d5fb92fffda724ccb3b038d2bb2388" title="User-definable timeout to receive a packet of data, positive timeout values are seconds, negative timeout values are microseconds, zero means no timeout (the value is 0 by default) ">soap::recv_timeout</a></code> are set.  <a href="#ga20210aa171019b27ef182d853e2d6e2f">More...</a><br /></td></tr>
<tr class="separator:ga20210aa171019b27ef182d853e2d6e2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c218cd5552045745cc640998e25ed72"><td class="memItemLeft" align="right" valign="top">size_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__callbacks.html#ga0c218cd5552045745cc640998e25ed72">soap::frecv</a> )(struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, char *buf, size_t len)</td></tr>
<tr class="memdesc:ga0c218cd5552045745cc640998e25ed72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback that receives bytes of data into the given buffer.  <a href="#ga0c218cd5552045745cc640998e25ed72">More...</a><br /></td></tr>
<tr class="separator:ga0c218cd5552045745cc640998e25ed72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd52b80655e4f1021edd6c55b8dfedff"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__callbacks.html#gafd52b80655e4f1021edd6c55b8dfedff">soap::fsend</a> )(struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, const char *data, size_t len)</td></tr>
<tr class="memdesc:gafd52b80655e4f1021edd6c55b8dfedff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback that sends the given bytes of data.  <a href="#gafd52b80655e4f1021edd6c55b8dfedff">More...</a><br /></td></tr>
<tr class="separator:gafd52b80655e4f1021edd6c55b8dfedff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76024ad8bab31b591432a5dbdcf3a0a4"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__callbacks.html#ga76024ad8bab31b591432a5dbdcf3a0a4">soap::fserveloop</a> )(struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>)</td></tr>
<tr class="memdesc:ga76024ad8bab31b591432a5dbdcf3a0a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback executed by the engine at the server side immediately after a server operation successfully completed.  <a href="#ga76024ad8bab31b591432a5dbdcf3a0a4">More...</a><br /></td></tr>
<tr class="separator:ga76024ad8bab31b591432a5dbdcf3a0a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2a9bb5e497817ef2af6f2c8fc1089d9"><td class="memItemLeft" align="right" valign="top">void *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__callbacks.html#gae2a9bb5e497817ef2af6f2c8fc1089d9">soap::fmalloc</a> )(struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, size_t size)</td></tr>
<tr class="memdesc:gae2a9bb5e497817ef2af6f2c8fc1089d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to override dynamic memory allocation and management.  <a href="#gae2a9bb5e497817ef2af6f2c8fc1089d9">More...</a><br /></td></tr>
<tr class="separator:gae2a9bb5e497817ef2af6f2c8fc1089d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga068455ce417bddb1636d4d565e0ebf56"><td class="memItemLeft" align="right" valign="top">void *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__callbacks.html#ga068455ce417bddb1636d4d565e0ebf56">soap::fdimereadopen</a> )(struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, void *handle, const char *id, const char *type, const char *options)</td></tr>
<tr class="memdesc:ga068455ce417bddb1636d4d565e0ebf56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to open a streaming DIME attachment for reading.  <a href="#ga068455ce417bddb1636d4d565e0ebf56">More...</a><br /></td></tr>
<tr class="separator:ga068455ce417bddb1636d4d565e0ebf56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48270ad98961c3ff48c7b56484ebb3fa"><td class="memItemLeft" align="right" valign="top">size_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__callbacks.html#ga48270ad98961c3ff48c7b56484ebb3fa">soap::fdimeread</a> )(struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, void *handle, char *buf, size_t len)</td></tr>
<tr class="memdesc:ga48270ad98961c3ff48c7b56484ebb3fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to read data in a DIME attachment stream.  <a href="#ga48270ad98961c3ff48c7b56484ebb3fa">More...</a><br /></td></tr>
<tr class="separator:ga48270ad98961c3ff48c7b56484ebb3fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga154752e553be41ed3b10fe3a1273ac71"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__callbacks.html#ga154752e553be41ed3b10fe3a1273ac71">soap::fdimereadclose</a> )(struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, void *handle)</td></tr>
<tr class="memdesc:ga154752e553be41ed3b10fe3a1273ac71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to close a DIME attachment stream after reading.  <a href="#ga154752e553be41ed3b10fe3a1273ac71">More...</a><br /></td></tr>
<tr class="separator:ga154752e553be41ed3b10fe3a1273ac71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b1e4aa046b683535110a34fc46ab1eb"><td class="memItemLeft" align="right" valign="top">void *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__callbacks.html#ga3b1e4aa046b683535110a34fc46ab1eb">soap::fdimewriteopen</a> )(struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, const char *id, const char *type, const char *options)</td></tr>
<tr class="memdesc:ga3b1e4aa046b683535110a34fc46ab1eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to open a streaming DIME attachment for writing.  <a href="#ga3b1e4aa046b683535110a34fc46ab1eb">More...</a><br /></td></tr>
<tr class="separator:ga3b1e4aa046b683535110a34fc46ab1eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f3214caa607f74505f11c76ade85cce"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__callbacks.html#ga0f3214caa607f74505f11c76ade85cce">soap::fdimewrite</a> )(struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, void *, const char *, size_t)</td></tr>
<tr class="memdesc:ga0f3214caa607f74505f11c76ade85cce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to write data in a DIME attachment stream.  <a href="#ga0f3214caa607f74505f11c76ade85cce">More...</a><br /></td></tr>
<tr class="separator:ga0f3214caa607f74505f11c76ade85cce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ea0ca0526c4ccba02ec52f62e0678a9"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__callbacks.html#ga1ea0ca0526c4ccba02ec52f62e0678a9">soap::fdimewriteclose</a> )(struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, void *handle)</td></tr>
<tr class="memdesc:ga1ea0ca0526c4ccba02ec52f62e0678a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to close a DIME attachment stream after writing.  <a href="#ga1ea0ca0526c4ccba02ec52f62e0678a9">More...</a><br /></td></tr>
<tr class="separator:ga1ea0ca0526c4ccba02ec52f62e0678a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga610f2a6a56d5ad04cb5124440a5de1dc"><td class="memItemLeft" align="right" valign="top">void *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__callbacks.html#ga610f2a6a56d5ad04cb5124440a5de1dc">soap::fmimereadopen</a> )(struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, void *, const char *, const char *, const char *)</td></tr>
<tr class="memdesc:ga610f2a6a56d5ad04cb5124440a5de1dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to open a streaming MIME/MTOM attachment for reading.  <a href="#ga610f2a6a56d5ad04cb5124440a5de1dc">More...</a><br /></td></tr>
<tr class="separator:ga610f2a6a56d5ad04cb5124440a5de1dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff40a1ca6fbf075b54ccbf479009ce74"><td class="memItemLeft" align="right" valign="top">size_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__callbacks.html#gaff40a1ca6fbf075b54ccbf479009ce74">soap::fmimeread</a> )(struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, void *handle, char *buf, size_t len)</td></tr>
<tr class="memdesc:gaff40a1ca6fbf075b54ccbf479009ce74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to read data in a MIME/MTOM attachment stream.  <a href="#gaff40a1ca6fbf075b54ccbf479009ce74">More...</a><br /></td></tr>
<tr class="separator:gaff40a1ca6fbf075b54ccbf479009ce74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga884e94e8450f56049ba5071786170dd5"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__callbacks.html#ga884e94e8450f56049ba5071786170dd5">soap::fmimereadclose</a> )(struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, void *handle)</td></tr>
<tr class="memdesc:ga884e94e8450f56049ba5071786170dd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to close a MIME/MTOM attachment stream after reading.  <a href="#ga884e94e8450f56049ba5071786170dd5">More...</a><br /></td></tr>
<tr class="separator:ga884e94e8450f56049ba5071786170dd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef809b275fd65e57991a80663288fa72"><td class="memItemLeft" align="right" valign="top">void *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__callbacks.html#gaef809b275fd65e57991a80663288fa72">soap::fmimewriteopen</a> )(struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, void *handle, const char *id, const char *type, const char *description, enum <a class="el" href="group__group__mime.html#ga3fec7633da07bff2bf5fd6330bef1844">soap_mime_encoding</a> encoding)</td></tr>
<tr class="memdesc:gaef809b275fd65e57991a80663288fa72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to open a streaming MIME/MTOM attachment for writing.  <a href="#gaef809b275fd65e57991a80663288fa72">More...</a><br /></td></tr>
<tr class="separator:gaef809b275fd65e57991a80663288fa72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9084f0392e4a54287366121d30bc4830"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__callbacks.html#ga9084f0392e4a54287366121d30bc4830">soap::fmimewrite</a> )(struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, void *handle, const char *buf, size_t len)</td></tr>
<tr class="memdesc:ga9084f0392e4a54287366121d30bc4830"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to write data in a MIME attachment stream.  <a href="#ga9084f0392e4a54287366121d30bc4830">More...</a><br /></td></tr>
<tr class="separator:ga9084f0392e4a54287366121d30bc4830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8af884096b21cea1b69133843131a47b"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__callbacks.html#ga8af884096b21cea1b69133843131a47b">soap::fmimewriteclose</a> )(struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, void *handle)</td></tr>
<tr class="memdesc:ga8af884096b21cea1b69133843131a47b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to close a MIME/MTOM attachment stream after writing.  <a href="#ga8af884096b21cea1b69133843131a47b">More...</a><br /></td></tr>
<tr class="separator:ga8af884096b21cea1b69133843131a47b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec56697005ded17d4d19705013f908ee"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__callbacks.html#gaec56697005ded17d4d19705013f908ee">soap::fsslauth</a> )(struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>)</td></tr>
<tr class="memdesc:gaec56697005ded17d4d19705013f908ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to initialize the OpenSSL library.  <a href="#gaec56697005ded17d4d19705013f908ee">More...</a><br /></td></tr>
<tr class="separator:gaec56697005ded17d4d19705013f908ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49fee9ca4a78f9a681afbdfbc0194bf0"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__callbacks.html#ga49fee9ca4a78f9a681afbdfbc0194bf0">soap::fsslverify</a> )(int ok, X509_STORE_CTX *store)</td></tr>
<tr class="memdesc:ga49fee9ca4a78f9a681afbdfbc0194bf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to manage the verification of the certificate provided by a peer (typically a server)  <a href="#ga49fee9ca4a78f9a681afbdfbc0194bf0">More...</a><br /></td></tr>
<tr class="separator:ga49fee9ca4a78f9a681afbdfbc0194bf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>This module defines the callback functions of the <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context to modify its behavior, as is done by plugins. </p>
<p>HTTP callbacks:</p><ul>
<li><code><a class="el" href="group__group__callbacks.html#ga78d2b5440b33d3882b595ca8cfdec425" title="Callback that populates and then sends HTTP headers from the client-side to a connected HTTP server...">soap::fpost</a></code></li>
<li><code><a class="el" href="group__group__callbacks.html#ga3d8e8e2b7ad7f1ac995c287b3a9f67a9" title="Callback that populates and then sends HTTP headers from the server-side to a connected client...">soap::fresponse</a></code></li>
<li><code><a class="el" href="group__group__callbacks.html#gab836b5b06024279f4ee190e69d7ccf75" title="Callback that sends a single HTTP header given a key-value pair. ">soap::fposthdr</a></code></li>
<li><code><a class="el" href="group__group__callbacks.html#ga9cb05ce98f845f16c920c44426ac35a5" title="Callback that reads and parses HTTP and MIME headers. ">soap::fparse</a></code></li>
<li><code><a class="el" href="group__group__callbacks.html#ga70b75026b5fb1a9a2d5779f72454f082" title="Callback that consumes an HTTP header that consists of a key-value pair. ">soap::fparsehdr</a></code></li>
<li><code><a class="el" href="group__group__callbacks.html#gae022204ff7004df2d5ac9e083cbb5b16" title="Callback to implement logic at the server-side to serve responses to HTTP GET requests from clients...">soap::fget</a></code></li>
<li><code><a class="el" href="group__group__callbacks.html#gaf263ffe14d8c2508ce4c734d4f33a854" title="Callback to implement logic at the server-side to serve responses to HTTP PUT requests from clients...">soap::fput</a></code></li>
<li><code><a class="el" href="group__group__callbacks.html#gaf2bda0187489c8f2b9857f61b96ad0e0" title="Callback to implement logic at the server-side to serve responses to HTTP DELETE requests from client...">soap::fdel</a></code></li>
<li><code><a class="el" href="group__group__callbacks.html#ga65272c1ecb5ed9925a5a670cf7e77d10" title="Callback to implement logic at the server-side to serve responses to HTTP OPTION requests from client...">soap::fopt</a></code></li>
<li><code><a class="el" href="group__group__callbacks.html#gadff52b7b3ecc16379eb2d7b1ff361978" title="Callback to implement logic at the server-side to serve responses to HTTP HEAD requests from clients...">soap::fhead</a></code></li>
<li><code><a class="el" href="group__group__callbacks.html#ga052cdf13e382b4af3d16128955546671" title="Callback to implement logic at the server-side to handle HTML forms, such as done by the callbacks pr...">soap::fform</a></code></li>
</ul>
<p>XML and SOAP callbacks:</p><ul>
<li><code><a class="el" href="group__group__callbacks.html#gae88b674df5fdcfa866c04e4330fe0afe" title="Callback to inspect the SOAP Header received before the rest of the message with the SOAP Body is con...">soap::fheader</a></code></li>
<li><code><a class="el" href="group__group__callbacks.html#ga0c2e1a0b5a5197128af1acc48662b1bd" title="Callback to catch unrecognized XML elements and overrides SOAP_XML_STRICT validation errors for these...">soap::fignore</a></code></li>
<li><code><a class="el" href="group__group__callbacks.html#ga6a5e29b860d28f855c8d9a67c096d311" title="Callback to validate strings against XML regex patterns. ">soap::fsvalidate</a></code></li>
<li><code><a class="el" href="group__group__callbacks.html#ga1a38366b5b84730713c45ccada84e3ca" title="Callback to validate wide strings against XML regex patterns. ">soap::fwvalidate</a></code></li>
<li><code><a class="el" href="group__group__callbacks.html#ga4523d86587b4181a138850b92498f5b7" title="Callback to inspect or override fault code or fault string messages. ">soap::fseterror</a></code></li>
</ul>
<p>Socket connection callbacks:</p><ul>
<li><code><a class="el" href="group__group__callbacks.html#ga9b4985eb5a588f4c16ad88ef7ca329dc" title="Callback that opens a socket connection to a server endpoint. ">soap::fopen</a></code></li>
<li><code><a class="el" href="group__group__callbacks.html#ga8249b4c23f662dbe680ad0deef274ae8" title="Callback that waits for and accepts a socket connection requested by a client. ">soap::faccept</a></code></li>
<li><code><a class="el" href="group__group__callbacks.html#gab9591dd80dbb0e571784bad5421b2202" title="Callback that closes the current socket connection. ">soap::fclose</a></code></li>
<li><code><a class="el" href="group__group__callbacks.html#ga0ae800fa60c5e65a867e5d0e3ce7223e" title="Callback that resolves a host name by address translation. ">soap::fresolve</a></code></li>
<li><code><a class="el" href="group__group__callbacks.html#ga0a0d27154b0e9e32d9adbcc4efc92b5c" title="Callback that overrides the client-side connecting operations. ">soap::fconnect</a></code></li>
<li><code><a class="el" href="group__group__callbacks.html#ga2de194075f645d77c15f78c52ca24858" title="Callback that executes disconnect logic before closing. ">soap::fdisconnect</a></code></li>
<li><code><a class="el" href="group__group__callbacks.html#ga21edadcbd081c7f37822d04bb05a9d29" title="Callback that closes a given socket. ">soap::fclosesocket</a></code></li>
<li><code><a class="el" href="group__group__callbacks.html#ga51e09ddf769a2ddcd874fb6e6fb5289d" title="Callback that shuts down a given socket. ">soap::fshutdownsocket</a></code></li>
<li><code><a class="el" href="group__group__callbacks.html#ga20210aa171019b27ef182d853e2d6e2f" title="Callback that blocks until activity is detected on the soap::socket or soap::master socket...">soap::fpoll</a></code></li>
</ul>
<p>IO callbacks:</p><ul>
<li><code><a class="el" href="group__group__callbacks.html#ga0c218cd5552045745cc640998e25ed72" title="Callback that receives bytes of data into the given buffer. ">soap::frecv</a></code></li>
<li><code><a class="el" href="group__group__callbacks.html#gafd52b80655e4f1021edd6c55b8dfedff" title="Callback that sends the given bytes of data. ">soap::fsend</a></code></li>
</ul>
<p>Server keep-alive loop callback:</p><ul>
<li><code><a class="el" href="group__group__callbacks.html#ga76024ad8bab31b591432a5dbdcf3a0a4" title="Callback executed by the engine at the server side immediately after a server operation successfully ...">soap::fserveloop</a></code></li>
</ul>
<p>Memory allocation callback:</p><ul>
<li><code><a class="el" href="group__group__callbacks.html#gae2a9bb5e497817ef2af6f2c8fc1089d9" title="Callback to override dynamic memory allocation and management. ">soap::fmalloc</a></code></li>
</ul>
<p>Streaming DIME attachment callbacks:</p><ul>
<li><code><a class="el" href="group__group__callbacks.html#ga068455ce417bddb1636d4d565e0ebf56" title="Callback to open a streaming DIME attachment for reading. ">soap::fdimereadopen</a></code></li>
<li><code><a class="el" href="group__group__callbacks.html#ga48270ad98961c3ff48c7b56484ebb3fa" title="Callback to read data in a DIME attachment stream. ">soap::fdimeread</a></code></li>
<li><code><a class="el" href="group__group__callbacks.html#ga154752e553be41ed3b10fe3a1273ac71" title="Callback to close a DIME attachment stream after reading. ">soap::fdimereadclose</a></code></li>
<li><code><a class="el" href="group__group__callbacks.html#ga3b1e4aa046b683535110a34fc46ab1eb" title="Callback to open a streaming DIME attachment for writing. ">soap::fdimewriteopen</a></code></li>
<li><code><a class="el" href="group__group__callbacks.html#ga0f3214caa607f74505f11c76ade85cce" title="Callback to write data in a DIME attachment stream. ">soap::fdimewrite</a></code></li>
<li><code><a class="el" href="group__group__callbacks.html#ga1ea0ca0526c4ccba02ec52f62e0678a9" title="Callback to close a DIME attachment stream after writing. ">soap::fdimewriteclose</a></code></li>
</ul>
<p>Streaming MIME/MTOM attachment callbacks:</p><ul>
<li><code><a class="el" href="group__group__callbacks.html#ga610f2a6a56d5ad04cb5124440a5de1dc" title="Callback to open a streaming MIME/MTOM attachment for reading. ">soap::fmimereadopen</a></code></li>
<li><code><a class="el" href="group__group__callbacks.html#gaff40a1ca6fbf075b54ccbf479009ce74" title="Callback to read data in a MIME/MTOM attachment stream. ">soap::fmimeread</a></code></li>
<li><code><a class="el" href="group__group__callbacks.html#ga884e94e8450f56049ba5071786170dd5" title="Callback to close a MIME/MTOM attachment stream after reading. ">soap::fmimereadclose</a></code></li>
<li><code><a class="el" href="group__group__callbacks.html#gaef809b275fd65e57991a80663288fa72" title="Callback to open a streaming MIME/MTOM attachment for writing. ">soap::fmimewriteopen</a></code></li>
<li><code><a class="el" href="group__group__callbacks.html#ga9084f0392e4a54287366121d30bc4830" title="Callback to write data in a MIME attachment stream. ">soap::fmimewrite</a></code></li>
<li><code><a class="el" href="group__group__callbacks.html#ga8af884096b21cea1b69133843131a47b" title="Callback to close a MIME/MTOM attachment stream after writing. ">soap::fmimewriteclose</a></code></li>
</ul>
<p>OpenSSL, GNUTLS and WolfSSL client-side SSL/TLS certificate verification callbacks:</p><ul>
<li><code><a class="el" href="group__group__callbacks.html#gaec56697005ded17d4d19705013f908ee" title="Callback to initialize the OpenSSL library. ">soap::fsslauth</a></code></li>
<li><code><a class="el" href="group__group__callbacks.html#ga49fee9ca4a78f9a681afbdfbc0194bf0" title="Callback to manage the verification of the certificate provided by a peer (typically a server) ...">soap::fsslverify</a></code></li>
</ul>
<p>To pass user-specified data to callbacks and plugins, assign a value to the <code><a class="el" href="structsoap.html#a8eb35c04359a567c0b5e2664f3f94d5b" title="User-definable variable that may point to user-specified data of any type to pass the data through to...">soap::user</a></code> variable of the context which can be accessed within the callback or plugin. </p>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="ga8249b4c23f662dbe680ad0deef274ae8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__soap.html#ga6eb1bde7cecc2fbadbcbbc6395227439">SOAP_SOCKET</a>(* soap::faccept) (struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, <a class="el" href="group__group__soap.html#ga6eb1bde7cecc2fbadbcbbc6395227439">SOAP_SOCKET</a> sock, struct sockaddr *addr, int *len)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback that waits for and accepts a socket connection requested by a client. </p>
<p>This callback is called by <code><a class="el" href="group__group__io.html#gaec0e1aecc2d5479d8099762feb4713c6" title="Accept a connection with a client. ">soap_accept</a></code> (or the C++ service class <code>accept</code> method) to wait for and accept a socket connection requested by a client. Returns a valid socket or <code><a class="el" href="group__group__soap.html#gab9e77b1557780293eec0b269ef191472" title="Macro that defines a portable invalid socket value (usually -1, but the value depends on the OS) ...">SOAP_INVALID_SOCKET</a></code> when an error occurred and sets <code><a class="el" href="structsoap.html#ab85f5d42702963d13ea540bd9876e6d2" title="The soap context soap_status (int) error code of the last operation or SOAP_OK (zero) ...">soap::error</a></code> to a <code><a class="el" href="group__group__errors.html#gac0eadf8f72bacb5b41b750beaeca0444" title="Status and error codes are int values, a zero value or SOAP_OK (0) means no error, nonzero means error. ">soap_status</a></code> value. The built-in function assigned to <code><a class="el" href="group__group__callbacks.html#ga8249b4c23f662dbe680ad0deef274ae8" title="Callback that waits for and accepts a socket connection requested by a client. ">soap::faccept</a></code> is <code>tcp_accept</code>.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__group__callbacks.html#ga9b4985eb5a588f4c16ad88ef7ca329dc" title="Callback that opens a socket connection to a server endpoint. ">soap::fopen</a></code>, <code><a class="el" href="structsoap.html#a8eb35c04359a567c0b5e2664f3f94d5b" title="User-definable variable that may point to user-specified data of any type to pass the data through to...">soap::user</a></code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td><code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context </td></tr>
    <tr><td class="paramname">sock</td><td>master socket </td></tr>
    <tr><td class="paramname">addr</td><td>points to a <code>sockaddr</code> structure to be populated </td></tr>
    <tr><td class="paramname">len</td><td>points to the length of the <code>sockaddr</code> structure, the length may be reduced by the callback function with the actual size of the <code>sockaddr</code> structure populated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>socket or <code><a class="el" href="group__group__soap.html#gab9e77b1557780293eec0b269ef191472" title="Macro that defines a portable invalid socket value (usually -1, but the value depends on the OS) ...">SOAP_INVALID_SOCKET</a></code> if an error occurred </dd></dl>

</div>
</div>
<a class="anchor" id="gab9591dd80dbb0e571784bad5421b2202"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* soap::fclose) (struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback that closes the current socket connection. </p>
<p>This callback is called by the engine at the client-side to close the current socket connection before a new socket connection is established. This callback may be called multiple times (e.g. by the engine and by plugins) to close the same socket <code><a class="el" href="structsoap.html#a1579bd8bd106afc9a906a673ca473046" title="The socket set by soap_accept (or the C++ service class accept method) or soap_connect or soap_connec...">soap::socket</a></code>. Checks internally if <code><a class="el" href="structsoap.html#a1579bd8bd106afc9a906a673ca473046" title="The socket set by soap_accept (or the C++ service class accept method) or soap_connect or soap_connec...">soap::socket</a></code> == <code><a class="el" href="group__group__soap.html#gab9e77b1557780293eec0b269ef191472" title="Macro that defines a portable invalid socket value (usually -1, but the value depends on the OS) ...">SOAP_INVALID_SOCKET</a></code> before closing, which means that the socket was already closed. Returns <code><a class="el" href="group__group__errors.html#ga3b10a68f354f39cbb0fe0d043ad4c7c0" title="The soap_status code for no error (zero) ">SOAP_OK</a></code> or a <code><a class="el" href="group__group__errors.html#gac0eadf8f72bacb5b41b750beaeca0444" title="Status and error codes are int values, a zero value or SOAP_OK (0) means no error, nonzero means error. ">soap_status</a></code> (int) error code. The built-in function assigned to <code><a class="el" href="group__group__callbacks.html#gab9591dd80dbb0e571784bad5421b2202" title="Callback that closes the current socket connection. ">soap::fclose</a></code> is <code>tcp_disconnect</code>.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__group__callbacks.html#ga9b4985eb5a588f4c16ad88ef7ca329dc" title="Callback that opens a socket connection to a server endpoint. ">soap::fopen</a></code>, <code><a class="el" href="group__group__callbacks.html#ga8249b4c23f662dbe680ad0deef274ae8" title="Callback that waits for and accepts a socket connection requested by a client. ">soap::faccept</a></code>, <code><a class="el" href="structsoap.html#a8eb35c04359a567c0b5e2664f3f94d5b" title="User-definable variable that may point to user-specified data of any type to pass the data through to...">soap::user</a></code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td><code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>socket or <code><a class="el" href="group__group__soap.html#gab9e77b1557780293eec0b269ef191472" title="Macro that defines a portable invalid socket value (usually -1, but the value depends on the OS) ...">SOAP_INVALID_SOCKET</a></code> if an error occurred </dd></dl>

</div>
</div>
<a class="anchor" id="ga21edadcbd081c7f37822d04bb05a9d29"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* soap::fclosesocket) (struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, <a class="el" href="group__group__soap.html#ga6eb1bde7cecc2fbadbcbbc6395227439">SOAP_SOCKET</a> sock)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback that closes a given socket. </p>
<p>This callback is called to close a socket by the engine. Returns <code><a class="el" href="group__group__errors.html#ga3b10a68f354f39cbb0fe0d043ad4c7c0" title="The soap_status code for no error (zero) ">SOAP_OK</a></code> or a <code><a class="el" href="group__group__errors.html#gac0eadf8f72bacb5b41b750beaeca0444" title="Status and error codes are int values, a zero value or SOAP_OK (0) means no error, nonzero means error. ">soap_status</a></code> (int) error code. The built-in function assigned to <code><a class="el" href="group__group__callbacks.html#ga21edadcbd081c7f37822d04bb05a9d29" title="Callback that closes a given socket. ">soap::fclosesocket</a></code> is <code>tcp_closesocket</code>.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="structsoap.html#a8eb35c04359a567c0b5e2664f3f94d5b" title="User-definable variable that may point to user-specified data of any type to pass the data through to...">soap::user</a></code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td><code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context </td></tr>
    <tr><td class="paramname">sock</td><td>socket to close </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code><a class="el" href="group__group__errors.html#ga3b10a68f354f39cbb0fe0d043ad4c7c0" title="The soap_status code for no error (zero) ">SOAP_OK</a></code> or a <code><a class="el" href="group__group__errors.html#gac0eadf8f72bacb5b41b750beaeca0444" title="Status and error codes are int values, a zero value or SOAP_OK (0) means no error, nonzero means error. ">soap_status</a></code> error code </dd></dl>

</div>
</div>
<a class="anchor" id="ga0a0d27154b0e9e32d9adbcc4efc92b5c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* soap::fconnect) (struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, const char *endpoint, const char *host, int port)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback that overrides the client-side connecting operations. </p>
<p>This callback is called by the engine to optionally override client-side connecting. The parameters <code>host</code> and <code>port</code> were micro-parsed from the <code>endpoint</code> prior to passing them to this callback. Returns <code><a class="el" href="group__group__errors.html#ga3b10a68f354f39cbb0fe0d043ad4c7c0" title="The soap_status code for no error (zero) ">SOAP_OK</a></code> or a <code><a class="el" href="group__group__errors.html#gac0eadf8f72bacb5b41b750beaeca0444" title="Status and error codes are int values, a zero value or SOAP_OK (0) means no error, nonzero means error. ">soap_status</a></code> (int) error code. No built-in function is assigned to <code><a class="el" href="group__group__callbacks.html#ga0a0d27154b0e9e32d9adbcc4efc92b5c" title="Callback that overrides the client-side connecting operations. ">soap::fconnect</a></code>.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="structsoap.html#a8eb35c04359a567c0b5e2664f3f94d5b" title="User-definable variable that may point to user-specified data of any type to pass the data through to...">soap::user</a></code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td><code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context </td></tr>
    <tr><td class="paramname">endpoint</td><td>URL of the endpoint connected to (string) </td></tr>
    <tr><td class="paramname">host</td><td>URL host of the endpoint connected to (string) </td></tr>
    <tr><td class="paramname">port</td><td>URL port of the endpoint connected to (int) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code><a class="el" href="group__group__errors.html#ga3b10a68f354f39cbb0fe0d043ad4c7c0" title="The soap_status code for no error (zero) ">SOAP_OK</a></code> or a <code><a class="el" href="group__group__errors.html#gac0eadf8f72bacb5b41b750beaeca0444" title="Status and error codes are int values, a zero value or SOAP_OK (0) means no error, nonzero means error. ">soap_status</a></code> error code </dd></dl>

</div>
</div>
<a class="anchor" id="gaf2bda0187489c8f2b9857f61b96ad0e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* soap::fdel) (struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback to implement logic at the server-side to serve responses to HTTP DELETE requests from clients. </p>
<p>This callback is called by the service dispatcher when an HTTP DELETE request is pending. Redefine this callback to respond to HTTP DELETE requests, see the <code><a class="el" href="group__group__io.html#ga4c08d5ef28bc0dc37eee4633acdd1140" title="The HTTP POST plugin registration function. ">http_post</a></code> HTTP POST plugin for more details. Returns <code><a class="el" href="group__group__errors.html#ga3b10a68f354f39cbb0fe0d043ad4c7c0" title="The soap_status code for no error (zero) ">SOAP_OK</a></code> or a <code><a class="el" href="group__group__errors.html#gac0eadf8f72bacb5b41b750beaeca0444" title="Status and error codes are int values, a zero value or SOAP_OK (0) means no error, nonzero means error. ">soap_status</a></code> (int) error code. The built-in function assigned to <code><a class="el" href="group__group__callbacks.html#gaf2bda0187489c8f2b9857f61b96ad0e0" title="Callback to implement logic at the server-side to serve responses to HTTP DELETE requests from client...">soap::fdel</a></code> is the internal static function <code>http_del</code> that returns the <code><a class="el" href="group__group__errors.html#ga122216a634ba30e3cc6e7ba53218dd97" title="A soap_status error code: an HTTP DELETE request was received by the service but the DELETE request c...">SOAP_DEL_METHOD</a></code> error.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__group__io.html#ga4c08d5ef28bc0dc37eee4633acdd1140" title="The HTTP POST plugin registration function. ">http_post</a></code>, <code><a class="el" href="structsoap.html#a8eb35c04359a567c0b5e2664f3f94d5b" title="User-definable variable that may point to user-specified data of any type to pass the data through to...">soap::user</a></code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td><code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code><a class="el" href="group__group__errors.html#ga3b10a68f354f39cbb0fe0d043ad4c7c0" title="The soap_status code for no error (zero) ">SOAP_OK</a></code> or a <code><a class="el" href="group__group__errors.html#gac0eadf8f72bacb5b41b750beaeca0444" title="Status and error codes are int values, a zero value or SOAP_OK (0) means no error, nonzero means error. ">soap_status</a></code> error code </dd></dl>

</div>
</div>
<a class="anchor" id="ga48270ad98961c3ff48c7b56484ebb3fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t(* soap::fdimeread) (struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, void *handle, char *buf, size_t len)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback to read data in a DIME attachment stream. </p>
<p>This callback is called by the engine to read a chunk of attachment data to transmit. The <code>handle</code> parameter contains the handle returned by the <code><a class="el" href="group__group__callbacks.html#ga068455ce417bddb1636d4d565e0ebf56" title="Callback to open a streaming DIME attachment for reading. ">soap::fdimereadopen</a></code> callback. The <code>buf</code> parameter is the buffer of length <code>len</code> into which a chunk of data should be written by the callback. The actual amount of data written into the buffer may be less than <code>len</code> and this actual amount should be returned by the callback. A return value of zero indicates an error and <code><a class="el" href="structsoap.html#ab85f5d42702963d13ea540bd9876e6d2" title="The soap context soap_status (int) error code of the last operation or SOAP_OK (zero) ...">soap::error</a></code> should be set. The <code>__size</code> member variable of the attachment struct/class with data (e.g. <code><a class="el" href="structxsd____base64_binary.html" title="XSD base64Binary structure with attachment data. ">xsd__base64Binary</a></code> or <code><a class="el" href="struct__xop_____include.html" title="XOP include structure with attachment data. ">_xop__Include</a></code> with <code>__ptr</code>, <code>__size</code>, <code>id</code>, <code>type</code> and <code>options</code> members) should be set by the application prior to the serialization of the message with attachments. The value of <code>__size</code> indicates the total size of the attachment data to be transmitted. If the <code>__size</code> member variable is zero and HTTP chunking is enabled (with <code><a class="el" href="group__group__flags.html#gaea7443dc67c979b06cf347ed16db1b51" title="soap_mode IO output flag value to send HTTP chunked messages, buffers the message in packets of size ...">SOAP_IO_CHUNK</a></code>), then DIME chunked transfers are activated by the engine, which is more flexible since the attachment data size does not need to be determined in adance. To use DIME chunked transfers, enable HTTP chunking with <code><a class="el" href="group__group__flags.html#gaea7443dc67c979b06cf347ed16db1b51" title="soap_mode IO output flag value to send HTTP chunked messages, buffers the message in packets of size ...">SOAP_IO_CHUNK</a></code> (also <code><a class="el" href="group__group__flags.html#gaf7cbb692f85f8633c4efc66dfae41e9e" title="soap_mode IO output flag value to store messages temporarily before transmission, e...">SOAP_IO_STORE</a></code> can be used, but this buffers the entire message in memory before transmission) and set the <code>__size</code> member variable of the attachment struct/class to zero. When DIME attachment chunking is enabled, this callback should completely fill the <code>buf</code> buffer with <code>len</code> bytes unless the last data chunk is reached and fewer bytes are returned.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__group__flags.html#gafaa6a1c2684babe91bea2e181b1f77e6" title="soap_mode ENC output flag value to enable DIME attachments (for internal use only) ...">SOAP_ENC_DIME</a></code>, <code><a class="el" href="structsoap.html#a8eb35c04359a567c0b5e2664f3f94d5b" title="User-definable variable that may point to user-specified data of any type to pass the data through to...">soap::user</a></code>.</dd></dl>
<dl class="section user"><dt>Example:</dt><dd></dd></dl>
<p>See the example provided with the documentation for <code><a class="el" href="group__group__callbacks.html#ga068455ce417bddb1636d4d565e0ebf56" title="Callback to open a streaming DIME attachment for reading. ">soap::fdimereadopen</a></code>. To enable chunked DIME attachments, replace the last part of the example with:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>soap *soap = <a class="code" href="group__group__context.html#ga51cde138234ed7ec8c4e25bdf6418658">soap_new1</a>(<a class="code" href="group__group__flags.html#gaea7443dc67c979b06cf347ed16db1b51">SOAP_IO_CHUNK</a>);</div><div class="line"></div><div class="line"><span class="keyword">struct </span><a class="code" href="struct__xop_____include.html">_xop__Include</a> data;                                  <span class="comment">// here we&#39;re using gsoap/import/xop.h to store a blob of raw data</span></div><div class="line">data.<a class="code" href="struct__xop_____include.html#ab4388e79bc98595fefbde2fbcf5489ba">__ptr</a> = <span class="stringliteral">&quot;Picture.png&quot;</span>;                                 <span class="comment">// file name to open for streaming with dime_read_open</span></div><div class="line">data.__size = 0;                                            <span class="comment">// zero size means chunked DIME attachments are sent</span></div><div class="line">data.id = <a class="code" href="group__group__context.html#ga41747ef145667bdff9c66cdd2bc86653">soap_strdup</a>(soap, <a class="code" href="group__group__misc.html#ga5fcf3c8f6f4bc6d5e6efd7a92ceaf399">soap_rand_uuid</a>(soap, <span class="stringliteral">&quot;uuid:&quot;</span>)); <span class="comment">// attachment id (optional, can use NULL)</span></div><div class="line">data.type = <span class="stringliteral">&quot;image/png&quot;</span>;                                    <span class="comment">// attachment type</span></div><div class="line">data.options = <a class="code" href="group__group__dime.html#ga4829f833abe74febcb8e5fe9360ab591">soap_dime_option</a>(soap, 0, <span class="stringliteral">&quot;Picture.png&quot;</span>);    <span class="comment">// DIME option 0 = &quot;Picture.png&quot; to store file name</span></div><div class="line">... <span class="comment">// add data to the message and then send it, which will stream the DIME attachment content from Picture.png</span></div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td><code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context </td></tr>
    <tr><td class="paramname">handle</td><td>the value of the handle returned by <code><a class="el" href="group__group__callbacks.html#ga068455ce417bddb1636d4d565e0ebf56" title="Callback to open a streaming DIME attachment for reading. ">soap::fdimereadopen</a></code> </td></tr>
    <tr><td class="paramname">buf</td><td>buffer to fill </td></tr>
    <tr><td class="paramname">len</td><td>length of the buffer in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes written to the buffer </dd></dl>

</div>
</div>
<a class="anchor" id="ga154752e553be41ed3b10fe3a1273ac71"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* soap::fdimereadclose) (struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, void *handle)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback to close a DIME attachment stream after reading. </p>
<p>This callback is called by the engine to close the DIME attachment stream after reading. The <code>handle</code> parameter contains the handle returned by the <code><a class="el" href="group__group__callbacks.html#ga068455ce417bddb1636d4d565e0ebf56" title="Callback to open a streaming DIME attachment for reading. ">soap::fdimereadopen</a></code> callback.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__group__flags.html#gafaa6a1c2684babe91bea2e181b1f77e6" title="soap_mode ENC output flag value to enable DIME attachments (for internal use only) ...">SOAP_ENC_DIME</a></code>, <code><a class="el" href="group__group__callbacks.html#ga068455ce417bddb1636d4d565e0ebf56" title="Callback to open a streaming DIME attachment for reading. ">soap::fdimereadopen</a></code>, <code><a class="el" href="group__group__callbacks.html#ga48270ad98961c3ff48c7b56484ebb3fa" title="Callback to read data in a DIME attachment stream. ">soap::fdimeread</a></code>, <code><a class="el" href="structsoap.html#a8eb35c04359a567c0b5e2664f3f94d5b" title="User-definable variable that may point to user-specified data of any type to pass the data through to...">soap::user</a></code>.</dd></dl>
<dl class="section user"><dt>Example:</dt><dd></dd></dl>
<p>See the examples provided with the documentation for <code><a class="el" href="group__group__callbacks.html#ga068455ce417bddb1636d4d565e0ebf56" title="Callback to open a streaming DIME attachment for reading. ">soap::fdimereadopen</a></code> and <code><a class="el" href="group__group__callbacks.html#ga48270ad98961c3ff48c7b56484ebb3fa" title="Callback to read data in a DIME attachment stream. ">soap::fdimeread</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td><code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context </td></tr>
    <tr><td class="paramname">handle</td><td>the value of the of the handle returned by <code><a class="el" href="group__group__callbacks.html#ga068455ce417bddb1636d4d565e0ebf56" title="Callback to open a streaming DIME attachment for reading. ">soap::fdimereadopen</a></code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga068455ce417bddb1636d4d565e0ebf56"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void*(* soap::fdimereadopen) (struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, void *handle, const char *id, const char *type, const char *options)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback to open a streaming DIME attachment for reading. </p>
<p>This callback is called by the engine to start sending a streaming DIME attachment. This callback opens a stream to start reading the attachment data to send. The actual data stream will be read in chunks using the <code><a class="el" href="group__group__callbacks.html#ga48270ad98961c3ff48c7b56484ebb3fa" title="Callback to read data in a DIME attachment stream. ">soap::fdimeread</a></code> callback until no more data is available and the <code><a class="el" href="group__group__callbacks.html#ga154752e553be41ed3b10fe3a1273ac71" title="Callback to close a DIME attachment stream after reading. ">soap::fdimereadclose</a></code> callback is called to close the stream. The <code>handle</code> parameter contains the value of the <code>__ptr</code> member variable of the attachment struct/class with data (e.g. <code><a class="el" href="structxsd____base64_binary.html" title="XSD base64Binary structure with attachment data. ">xsd__base64Binary</a></code> or <code><a class="el" href="struct__xop_____include.html" title="XOP include structure with attachment data. ">_xop__Include</a></code> with <code>__ptr</code>, <code>__size</code>, <code>id</code>, <code>type</code> and <code>options</code> members), which should be a pointer to specific information such as a file descriptor or a pointer to a some application-specific data to be passed to this callback. Both the <code>__ptr</code> and <code>__size</code> members of the attachment struct/class should have been set by the application prior to the serialization of the message with attachments. If the <code>__size</code> is zero and HTTP chunking is enabled (with <code><a class="el" href="group__group__flags.html#gaea7443dc67c979b06cf347ed16db1b51" title="soap_mode IO output flag value to send HTTP chunked messages, buffers the message in packets of size ...">SOAP_IO_CHUNK</a></code>), then chunked DIME attachments are sent, see <code><a class="el" href="group__group__callbacks.html#ga48270ad98961c3ff48c7b56484ebb3fa" title="Callback to read data in a DIME attachment stream. ">soap::fdimeread</a></code>. The <code>id</code>, <code>type</code> and <code>options</code> parameters are the <code>id</code> (optional ID), <code>type</code> (a MIME type) and <code>options</code> (DIME options are set with <code><a class="el" href="group__group__dime.html#ga4829f833abe74febcb8e5fe9360ab591" title="Creates a DIME option. ">soap_dime_option</a></code>) of the attachment struct/class, respectively, of which at least one member should be non-NULL. The callback should return the <code>handle</code> parameter value or another pointer value, which is passed as the new <code>handle</code> parameter to <code><a class="el" href="group__group__callbacks.html#ga48270ad98961c3ff48c7b56484ebb3fa" title="Callback to read data in a DIME attachment stream. ">soap::fdimeread</a></code> and <code><a class="el" href="group__group__callbacks.html#ga154752e553be41ed3b10fe3a1273ac71" title="Callback to close a DIME attachment stream after reading. ">soap::fdimereadclose</a></code> callbacks. When an error occurred in this callback, the callback should return NULL and set <code><a class="el" href="structsoap.html#ab85f5d42702963d13ea540bd9876e6d2" title="The soap context soap_status (int) error code of the last operation or SOAP_OK (zero) ...">soap::error</a></code> to an error code, e.g. using <code><a class="el" href="group__group__fault.html#ga91dc6bcc3c5f35e023b78a6f46a79ed6" title="Set SOAP 1.1 server fault / SOAP 1.2 receiver fault string and detail. ">soap_receiver_fault</a></code>. The callback may return NULL and set <code><a class="el" href="structsoap.html#ab85f5d42702963d13ea540bd9876e6d2" title="The soap context soap_status (int) error code of the last operation or SOAP_OK (zero) ...">soap::error</a></code> to <code><a class="el" href="group__group__errors.html#ga3b10a68f354f39cbb0fe0d043ad4c7c0" title="The soap_status code for no error (zero) ">SOAP_OK</a></code> when this specific DIME attachment should not to be streamed and the engine will simply skip it.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__group__flags.html#gafaa6a1c2684babe91bea2e181b1f77e6" title="soap_mode ENC output flag value to enable DIME attachments (for internal use only) ...">SOAP_ENC_DIME</a></code>, <code><a class="el" href="structsoap.html#a8eb35c04359a567c0b5e2664f3f94d5b" title="User-definable variable that may point to user-specified data of any type to pass the data through to...">soap::user</a></code>.</dd></dl>
<dl class="section user"><dt>Example:</dt><dd></dd></dl>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> * dime_read_open(<span class="keyword">struct</span> soap *soap, <span class="keywordtype">void</span> *handle, <span class="keyword">const</span> <span class="keywordtype">char</span> *<span class="keywordtype">id</span>, <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="struct__xop_____include.html#a0d70af0d2c123766ce188cf2dd15833a">type</a>, <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="struct__xop_____include.html#a894a54df2d052989ff2c20d344f56c91">options</a>)</div><div class="line">{</div><div class="line">  <span class="keywordflow">return</span> (<span class="keywordtype">void</span>*)<a class="code" href="group__group__callbacks.html#ga9b4985eb5a588f4c16ad88ef7ca329dc">fopen</a>((<span class="keywordtype">char</span>*)handle, <span class="stringliteral">&quot;rb&quot;</span>);</div><div class="line">}</div><div class="line"><span class="keywordtype">size_t</span> dime_read(<span class="keyword">struct</span> soap *soap, <span class="keywordtype">void</span> *handle, <span class="keywordtype">char</span> *<a class="code" href="structsoap.html#acda1736fbaac07261226befe165a5681">buf</a>, <span class="keywordtype">size_t</span> len)</div><div class="line">{</div><div class="line">  <span class="keywordflow">return</span> fread(buf, 1, len, (FILE*)handle);</div><div class="line">}</div><div class="line"><span class="keywordtype">void</span> dime_read_close(<span class="keyword">struct</span> soap *soap, <span class="keywordtype">void</span> *handle)</div><div class="line">{</div><div class="line">  <a class="code" href="group__group__callbacks.html#gab9591dd80dbb0e571784bad5421b2202">fclose</a>((FILE*)handle);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">struct </span>soap *soap = <a class="code" href="group__group__context.html#ga87c20488b2dc680aaa7689b1d024989c">soap_new</a>();</div><div class="line">soap-&gt;<a class="code" href="group__group__callbacks.html#ga068455ce417bddb1636d4d565e0ebf56">fdimereadopen</a> = dime_read_open;</div><div class="line">soap-&gt;<a class="code" href="group__group__callbacks.html#ga48270ad98961c3ff48c7b56484ebb3fa">fdimeread</a> = dime_read;</div><div class="line">soap-&gt;<a class="code" href="group__group__callbacks.html#ga154752e553be41ed3b10fe3a1273ac71">fdimereadclose</a> = dime_read_close;</div><div class="line"></div><div class="line"><span class="keyword">struct </span><a class="code" href="struct__xop_____include.html">_xop__Include</a> data;                                  <span class="comment">// here we&#39;re using gsoap/import/xop.h to store a blob of raw data</span></div><div class="line">data.<a class="code" href="struct__xop_____include.html#ab4388e79bc98595fefbde2fbcf5489ba">__ptr</a> = <span class="stringliteral">&quot;Picture.png&quot;</span>;                                 <span class="comment">// file name to open for streaming with dime_read_open</span></div><div class="line">data.__size = 1024;                                         <span class="comment">// file has 1024 bytes of data</span></div><div class="line">data.id = <a class="code" href="group__group__context.html#ga41747ef145667bdff9c66cdd2bc86653">soap_strdup</a>(soap, <a class="code" href="group__group__misc.html#ga5fcf3c8f6f4bc6d5e6efd7a92ceaf399">soap_rand_uuid</a>(soap, <span class="stringliteral">&quot;uuid:&quot;</span>)); <span class="comment">// attachment id (optional, can use NULL)</span></div><div class="line">data.type = <span class="stringliteral">&quot;image/png&quot;</span>;                                    <span class="comment">// attachment type</span></div><div class="line">data.options = <a class="code" href="group__group__dime.html#ga4829f833abe74febcb8e5fe9360ab591">soap_dime_option</a>(soap, 0, <span class="stringliteral">&quot;Picture.png&quot;</span>);    <span class="comment">// DIME option 0 = &quot;Picture.png&quot; to store file name</span></div><div class="line">... <span class="comment">// add data to the message and then send it, which will stream the DIME attachment content from Picture.png</span></div></div><!-- fragment --><p>This mechanism also works for DIME attachments attached with <code><a class="el" href="group__group__dime.html#ga742f96848174e27bfc8df7425b870f4b" title="Add a DIME attachment to the SOAP/XML message. ">soap_set_dime_attachment</a></code>.</p>
<p>The maximum size of DIME attachments that the engine allows to be received is limited to <code><a class="el" href="group__group__soap.html#gad4c2ca8c2293fc75075aec4a09f4dc38" title="User-definable maximum length of DIME attachments received (the value is 8 MB by default) ...">SOAP_MAXDIMESIZE</a></code>. Increase this size as necessary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td><code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context </td></tr>
    <tr><td class="paramname">handle</td><td>the value of the <code>__ptr</code> member variable of the attachment struct/class with data </td></tr>
    <tr><td class="paramname">id</td><td>the value of the <code>id</code> member variable of the attachment struct/class with data </td></tr>
    <tr><td class="paramname">type</td><td>the value of the <code>type</code> member variable of the attachment struct/class with data </td></tr>
    <tr><td class="paramname">options</td><td>the value of the <code>options</code> member variable of the attachment struct/class with data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a handle or NULL when an error occurred (<code><a class="el" href="structsoap.html#ab85f5d42702963d13ea540bd9876e6d2" title="The soap context soap_status (int) error code of the last operation or SOAP_OK (zero) ...">soap::error</a></code> is nonzero) or when the attachment should be skipped (<code><a class="el" href="structsoap.html#ab85f5d42702963d13ea540bd9876e6d2" title="The soap context soap_status (int) error code of the last operation or SOAP_OK (zero) ...">soap::error</a></code> is <code><a class="el" href="group__group__errors.html#ga3b10a68f354f39cbb0fe0d043ad4c7c0" title="The soap_status code for no error (zero) ">SOAP_OK</a></code>) </dd></dl>

</div>
</div>
<a class="anchor" id="ga0f3214caa607f74505f11c76ade85cce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* soap::fdimewrite) (struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, void *, const char *, size_t)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback to write data in a DIME attachment stream. </p>
<p>This callback is called by the engine to write a chunk of attachment data received. The <code>handle</code> parameter contains the handle returned by the <code><a class="el" href="group__group__callbacks.html#ga3b1e4aa046b683535110a34fc46ab1eb" title="Callback to open a streaming DIME attachment for writing. ">soap::fdimewriteopen</a></code> callback. The <code>buf</code> parameter contains the data of length <code>len</code>. Returns <code><a class="el" href="group__group__errors.html#ga3b10a68f354f39cbb0fe0d043ad4c7c0" title="The soap_status code for no error (zero) ">SOAP_OK</a></code> or a <code><a class="el" href="group__group__errors.html#gac0eadf8f72bacb5b41b750beaeca0444" title="Status and error codes are int values, a zero value or SOAP_OK (0) means no error, nonzero means error. ">soap_status</a></code> (int) error code.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__group__flags.html#gafaa6a1c2684babe91bea2e181b1f77e6" title="soap_mode ENC output flag value to enable DIME attachments (for internal use only) ...">SOAP_ENC_DIME</a></code>, <code><a class="el" href="structsoap.html#a8eb35c04359a567c0b5e2664f3f94d5b" title="User-definable variable that may point to user-specified data of any type to pass the data through to...">soap::user</a></code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td><code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context </td></tr>
    <tr><td class="paramname">handle</td><td>the value of the handle returned by <code><a class="el" href="group__group__callbacks.html#ga3b1e4aa046b683535110a34fc46ab1eb" title="Callback to open a streaming DIME attachment for writing. ">soap::fdimewriteopen</a></code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code><a class="el" href="group__group__errors.html#ga3b10a68f354f39cbb0fe0d043ad4c7c0" title="The soap_status code for no error (zero) ">SOAP_OK</a></code> or a <code><a class="el" href="group__group__errors.html#gac0eadf8f72bacb5b41b750beaeca0444" title="Status and error codes are int values, a zero value or SOAP_OK (0) means no error, nonzero means error. ">soap_status</a></code> error code </dd></dl>

</div>
</div>
<a class="anchor" id="ga1ea0ca0526c4ccba02ec52f62e0678a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* soap::fdimewriteclose) (struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, void *handle)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback to close a DIME attachment stream after writing. </p>
<p>This callback is called by the engine to close the DIME attachment stream after writing. The <code>handle</code> parameter contains the handle returned by the <code><a class="el" href="group__group__callbacks.html#ga3b1e4aa046b683535110a34fc46ab1eb" title="Callback to open a streaming DIME attachment for writing. ">soap::fdimewriteopen</a></code> callback.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__group__flags.html#gafaa6a1c2684babe91bea2e181b1f77e6" title="soap_mode ENC output flag value to enable DIME attachments (for internal use only) ...">SOAP_ENC_DIME</a></code>, <code><a class="el" href="structsoap.html#a8eb35c04359a567c0b5e2664f3f94d5b" title="User-definable variable that may point to user-specified data of any type to pass the data through to...">soap::user</a></code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td><code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context </td></tr>
    <tr><td class="paramname">handle</td><td>the value of the of the handle returned by <code><a class="el" href="group__group__callbacks.html#ga3b1e4aa046b683535110a34fc46ab1eb" title="Callback to open a streaming DIME attachment for writing. ">soap::fdimewriteopen</a></code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3b1e4aa046b683535110a34fc46ab1eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void*(* soap::fdimewriteopen) (struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, const char *id, const char *type, const char *options)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback to open a streaming DIME attachment for writing. </p>
<p>Called by the to start receiving a streaming DIME attachment. This callback opens a stream to start writing the attachment data received. The actual data stream will be written in chunks using the <code><a class="el" href="group__group__callbacks.html#ga0f3214caa607f74505f11c76ade85cce" title="Callback to write data in a DIME attachment stream. ">soap::fdimewrite</a></code> callback until no more data is available and the <code><a class="el" href="group__group__callbacks.html#ga1ea0ca0526c4ccba02ec52f62e0678a9" title="Callback to close a DIME attachment stream after writing. ">soap::fdimewriteclose</a></code> callback is called to close the stream. The <code>id</code>, <code>type</code> and <code>options</code> parameters are the <code>id</code>, <code>type</code> and <code>options</code> of the attachment struct/class (e.g. <code><a class="el" href="structxsd____base64_binary.html" title="XSD base64Binary structure with attachment data. ">xsd__base64Binary</a></code> or <code><a class="el" href="struct__xop_____include.html" title="XOP include structure with attachment data. ">_xop__Include</a></code> with <code>__ptr</code>, <code>__size</code>, <code>id</code>, <code>type</code> and <code>options</code> members), respectively. The callback should return a handle, which is passed to the <code><a class="el" href="group__group__callbacks.html#ga0f3214caa607f74505f11c76ade85cce" title="Callback to write data in a DIME attachment stream. ">soap::fdimewrite</a></code> and <code><a class="el" href="group__group__callbacks.html#ga1ea0ca0526c4ccba02ec52f62e0678a9" title="Callback to close a DIME attachment stream after writing. ">soap::fdimewriteclose</a></code> callbacks. The <code>__ptr</code> member variable of the attachment struct/class is set by the engine to the value of this handle. The <code>__size</code> member variable is set to the size of the attachment received. The maximum DIME attachment size received is limited by <code><a class="el" href="group__group__soap.html#gad4c2ca8c2293fc75075aec4a09f4dc38" title="User-definable maximum length of DIME attachments received (the value is 8 MB by default) ...">SOAP_MAXDIMESIZE</a></code>.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__group__flags.html#gafaa6a1c2684babe91bea2e181b1f77e6" title="soap_mode ENC output flag value to enable DIME attachments (for internal use only) ...">SOAP_ENC_DIME</a></code>, <code><a class="el" href="structsoap.html#a8eb35c04359a567c0b5e2664f3f94d5b" title="User-definable variable that may point to user-specified data of any type to pass the data through to...">soap::user</a></code>.</dd></dl>
<dl class="section user"><dt>Example:</dt><dd></dd></dl>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> * dime_write_open(<span class="keyword">struct</span> soap *soap, <span class="keyword">const</span> <span class="keywordtype">char</span> *<span class="keywordtype">id</span>, <span class="keyword">const</span> <span class="keywordtype">char</span> *type, <span class="keyword">const</span> <span class="keywordtype">char</span> *options)</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> (options)</div><div class="line">  {</div><div class="line">    FILE *handle = NULL;</div><div class="line">    <span class="keywordtype">char</span> *name;</div><div class="line">    <span class="keywordtype">size_t</span> len = ((<span class="keywordtype">unsigned</span> char)options[2] &lt;&lt; 8) | ((<span class="keywordtype">unsigned</span> char)options[3]); <span class="comment">// get option string length</span></div><div class="line">    name = (<span class="keywordtype">char</span>*)<a class="code" href="group__group__context.html#gaba556710e010feeb2211ed43b5bf059c">soap_malloc</a>(soap, len + 1);</div><div class="line">    strncpy(name, options + 4, len); <span class="comment">// get file name from options (as an example)</span></div><div class="line">    name[len] = <span class="charliteral">&#39;\0&#39;</span>;</div><div class="line">    handle = <a class="code" href="group__group__callbacks.html#ga9b4985eb5a588f4c16ad88ef7ca329dc">fopen</a>(name, <span class="stringliteral">&quot;wb&quot;</span>);</div><div class="line">    <span class="keywordflow">if</span> (!handle)</div><div class="line">    {</div><div class="line">      soap-&gt;<a class="code" href="structsoap.html#ab85f5d42702963d13ea540bd9876e6d2">error</a> = <a class="code" href="group__group__errors.html#ga224b2c2b830135f12b53536f189b4ebd">SOAP_EOF</a>; <span class="comment">// could not open file for writing</span></div><div class="line">      soap-&gt;<a class="code" href="structsoap.html#a10b66d6d489690b7d0f591ae2633dd13">errnum</a> = errno;   <span class="comment">// to report errno value</span></div><div class="line">      <span class="keywordflow">return</span> NULL;</div><div class="line">    }</div><div class="line">  }</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">  {</div><div class="line">    soap-&gt;<a class="code" href="structsoap.html#ab85f5d42702963d13ea540bd9876e6d2">error</a> = <a class="code" href="group__group__fault.html#ga91dc6bcc3c5f35e023b78a6f46a79ed6">soap_receiver_fault</a>(soap, <span class="stringliteral">&quot;Cannot save to file: no file name was present in the attachment&quot;</span>, NULL);</div><div class="line">  }</div><div class="line">  <span class="keywordflow">return</span> (<span class="keywordtype">void</span>*)handle;</div><div class="line">}</div><div class="line"><span class="keywordtype">int</span> dime_write(<span class="keyword">struct</span> soap *soap, <span class="keywordtype">void</span> *handle, <span class="keyword">const</span> <span class="keywordtype">char</span> *buf, <span class="keywordtype">size_t</span> len)</div><div class="line">{</div><div class="line">  <span class="keywordflow">while</span> (len)</div><div class="line">  {</div><div class="line">    <span class="keywordtype">size_t</span> nwritten = fwrite(buf, 1, len, (FILE*)handle);</div><div class="line">    <span class="keywordflow">if</span> (!nwritten)</div><div class="line">    {</div><div class="line">      soap-&gt;<a class="code" href="structsoap.html#a10b66d6d489690b7d0f591ae2633dd13">errnum</a> = errno;</div><div class="line">      <span class="keywordflow">return</span> <a class="code" href="group__group__errors.html#ga224b2c2b830135f12b53536f189b4ebd">SOAP_EOF</a>;</div><div class="line">    }</div><div class="line">    len -= nwritten;</div><div class="line">    buf += nwritten;</div><div class="line">  }</div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="group__group__errors.html#ga3b10a68f354f39cbb0fe0d043ad4c7c0">SOAP_OK</a>;</div><div class="line">}</div><div class="line"><span class="keywordtype">void</span> dime_write_close(<span class="keyword">struct</span> soap *soap, <span class="keywordtype">void</span> *handle)</div><div class="line">{</div><div class="line">  <a class="code" href="group__group__callbacks.html#gab9591dd80dbb0e571784bad5421b2202">fclose</a>((FILE*)handle);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">struct </span>soap *soap = <a class="code" href="group__group__context.html#ga87c20488b2dc680aaa7689b1d024989c">soap_new</a>();</div><div class="line">soap-&gt;<a class="code" href="group__group__callbacks.html#ga3b1e4aa046b683535110a34fc46ab1eb">fdimewriteopen</a> = dime_write_open;</div><div class="line">soap-&gt;<a class="code" href="group__group__callbacks.html#ga0f3214caa607f74505f11c76ade85cce">fdimewrite</a> = dime_write;</div><div class="line">soap-&gt;<a class="code" href="group__group__callbacks.html#ga1ea0ca0526c4ccba02ec52f62e0678a9">fdimewriteclose</a> = dime_write_close;</div><div class="line"></div><div class="line">... <span class="comment">// when a service responds to the client request with DIME attachment(s), the attachment data is saved via the callbacks</span></div></div><!-- fragment --><p>The maximum size of DIME attachments that the engine allows to be received is limited to <code><a class="el" href="group__group__soap.html#gad4c2ca8c2293fc75075aec4a09f4dc38" title="User-definable maximum length of DIME attachments received (the value is 8 MB by default) ...">SOAP_MAXDIMESIZE</a></code>. Increase this size as necessary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td><code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context </td></tr>
    <tr><td class="paramname">id</td><td>the value of the <code>id</code> member variable of the attachment struct/class with data </td></tr>
    <tr><td class="paramname">type</td><td>the value of the <code>type</code> member variable of the attachment struct/class with data </td></tr>
    <tr><td class="paramname">options</td><td>the value of the <code>options</code> member variable of the attachment struct/class with data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a handle or NULL when an error occurred (<code><a class="el" href="structsoap.html#ab85f5d42702963d13ea540bd9876e6d2" title="The soap context soap_status (int) error code of the last operation or SOAP_OK (zero) ...">soap::error</a></code> should be nonzero) </dd></dl>

</div>
</div>
<a class="anchor" id="ga2de194075f645d77c15f78c52ca24858"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* soap::fdisconnect) (struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback that executes disconnect logic before closing. </p>
<p>This callback is called by the engine <code><a class="el" href="group__group__io.html#ga06d59094afa3df6b1b9f6b2bb484207c" title="Close the socket connection. ">soap_closesock</a></code> before the <code><a class="el" href="group__group__callbacks.html#gab9591dd80dbb0e571784bad5421b2202" title="Callback that closes the current socket connection. ">soap::fclose</a></code> callback is called to shutdown/disconnect. Returns <code><a class="el" href="group__group__errors.html#ga3b10a68f354f39cbb0fe0d043ad4c7c0" title="The soap_status code for no error (zero) ">SOAP_OK</a></code> or a <code><a class="el" href="group__group__errors.html#gac0eadf8f72bacb5b41b750beaeca0444" title="Status and error codes are int values, a zero value or SOAP_OK (0) means no error, nonzero means error. ">soap_status</a></code> (int) error code. No built-in function is assigned to <code><a class="el" href="group__group__callbacks.html#ga2de194075f645d77c15f78c52ca24858" title="Callback that executes disconnect logic before closing. ">soap::fdisconnect</a></code>.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="structsoap.html#a8eb35c04359a567c0b5e2664f3f94d5b" title="User-definable variable that may point to user-specified data of any type to pass the data through to...">soap::user</a></code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td><code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code><a class="el" href="group__group__errors.html#ga3b10a68f354f39cbb0fe0d043ad4c7c0" title="The soap_status code for no error (zero) ">SOAP_OK</a></code> or a <code><a class="el" href="group__group__errors.html#gac0eadf8f72bacb5b41b750beaeca0444" title="Status and error codes are int values, a zero value or SOAP_OK (0) means no error, nonzero means error. ">soap_status</a></code> error code </dd></dl>

</div>
</div>
<a class="anchor" id="ga6662bdcf10ff0ba101adfbef3a4c17d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* soap::fencoding) (struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, const char *encoding)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback to catch unrecognized XML encoding formats. </p>
<p>This callback is called when an unrecognized XML encoding format is encountered in an XML PI. Supported encoding formats are latin (ASCII) and UTF-8. Other encoding formats can be rejected or supported by setting this callback. To reject the encoding, return a nonzero error code. To accept the encoding without further action, return <code><a class="el" href="group__group__errors.html#ga3b10a68f354f39cbb0fe0d043ad4c7c0" title="The soap_status code for no error (zero) ">SOAP_OK</a></code>. To decode the encoding, the input stream should be redictected through a decoder, for example by overriding the <code><a class="el" href="group__group__callbacks.html#ga0c218cd5552045745cc640998e25ed72" title="Callback that receives bytes of data into the given buffer. ">soap::frecv</a></code> callback with a specific handler to convert the encoding.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="structsoap.html#a8eb35c04359a567c0b5e2664f3f94d5b" title="User-definable variable that may point to user-specified data of any type to pass the data through to...">soap::user</a></code> and <code><a class="el" href="group__group__callbacks.html#ga0c218cd5552045745cc640998e25ed72" title="Callback that receives bytes of data into the given buffer. ">soap::frecv</a></code>.</dd></dl>
<dl class="section user"><dt>Example:</dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td><code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context </td></tr>
    <tr><td class="paramname">encoding</td><td>XML encoding extracted from the XML PI header </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code><a class="el" href="group__group__errors.html#ga3b10a68f354f39cbb0fe0d043ad4c7c0" title="The soap_status code for no error (zero) ">SOAP_OK</a></code> or a <code><a class="el" href="group__group__errors.html#gac0eadf8f72bacb5b41b750beaeca0444" title="Status and error codes are int values, a zero value or SOAP_OK (0) means no error, nonzero means error. ">soap_status</a></code> error code </dd></dl>

</div>
</div>
<a class="anchor" id="ga052cdf13e382b4af3d16128955546671"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* soap::fform) (struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback to implement logic at the server-side to handle HTML forms, such as done by the callbacks provided by the HTTP FORM handler plugin. </p>
<p>This callback is called by the HTTP FORM handler plugin to parse HTML forms received with HTTP POST and PUT requests, see the <em><code>;:http_form</code></em> HTTP FORM plugin for more details. The HTTP body with the form data should be parsed by this callback, otherwise HTTP keep-alive messages will end up out of sync as a result of the current position not being advanced to the end of the HTTP body. Returns <code><a class="el" href="group__group__errors.html#ga3b10a68f354f39cbb0fe0d043ad4c7c0" title="The soap_status code for no error (zero) ">SOAP_OK</a></code> or a <code><a class="el" href="group__group__errors.html#gac0eadf8f72bacb5b41b750beaeca0444" title="Status and error codes are int values, a zero value or SOAP_OK (0) means no error, nonzero means error. ">soap_status</a></code> (int) error code. No built-in function is assigned to <code><a class="el" href="group__group__callbacks.html#ga052cdf13e382b4af3d16128955546671" title="Callback to implement logic at the server-side to handle HTML forms, such as done by the callbacks pr...">soap::fform</a></code>.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__group__io.html#ga4c08d5ef28bc0dc37eee4633acdd1140" title="The HTTP POST plugin registration function. ">http_post</a></code>, <code><a class="el" href="structsoap.html#a8eb35c04359a567c0b5e2664f3f94d5b" title="User-definable variable that may point to user-specified data of any type to pass the data through to...">soap::user</a></code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td><code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code><a class="el" href="group__group__errors.html#ga3b10a68f354f39cbb0fe0d043ad4c7c0" title="The soap_status code for no error (zero) ">SOAP_OK</a></code> or a <code><a class="el" href="group__group__errors.html#gac0eadf8f72bacb5b41b750beaeca0444" title="Status and error codes are int values, a zero value or SOAP_OK (0) means no error, nonzero means error. ">soap_status</a></code> error code </dd></dl>

</div>
</div>
<a class="anchor" id="gae022204ff7004df2d5ac9e083cbb5b16"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* soap::fget) (struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback to implement logic at the server-side to serve responses to HTTP GET requests from clients. </p>
<p>This callback is called by the service dispatcher when an HTTP GET request is pending. Redefine this callback to respond to HTTP GET requests with content, see the <code><a class="el" href="group__group__io.html#ga0ecdc43a53e494edc4f84e8c135659ba" title="The HTTP GET plugin registration function. ">http_get</a></code> HTTP GET plugin for more details. Returns <code><a class="el" href="group__group__errors.html#ga3b10a68f354f39cbb0fe0d043ad4c7c0" title="The soap_status code for no error (zero) ">SOAP_OK</a></code> or a <code><a class="el" href="group__group__errors.html#gac0eadf8f72bacb5b41b750beaeca0444" title="Status and error codes are int values, a zero value or SOAP_OK (0) means no error, nonzero means error. ">soap_status</a></code> (int) error code. The built-in function assigned to <code><a class="el" href="group__group__callbacks.html#gae022204ff7004df2d5ac9e083cbb5b16" title="Callback to implement logic at the server-side to serve responses to HTTP GET requests from clients...">soap::fget</a></code> is the internal static function <code>http_get</code> that returns the <code><a class="el" href="group__group__errors.html#gac62f5f70e545ea8fbcbb181e88750d56" title="A soap_status error code: an HTTP GET request was received by the service but the GET request callbac...">SOAP_GET_METHOD</a></code> error.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__group__io.html#ga0ecdc43a53e494edc4f84e8c135659ba" title="The HTTP GET plugin registration function. ">http_get</a></code>, <code><a class="el" href="structsoap.html#a8eb35c04359a567c0b5e2664f3f94d5b" title="User-definable variable that may point to user-specified data of any type to pass the data through to...">soap::user</a></code>.</dd></dl>
<dl class="section user"><dt>Example</dt><dd></dd></dl>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keyword">struct </span>soap *soap = <a class="code" href="group__group__context.html#ga87c20488b2dc680aaa7689b1d024989c">soap_new</a>();</div><div class="line">  soap-&gt;<a class="code" href="structsoap.html#a8eb35c04359a567c0b5e2664f3f94d5b">user</a> = ... <span class="comment">// set this to pass data to the callback</span></div><div class="line">  soap-&gt;<a class="code" href="group__group__callbacks.html#gae022204ff7004df2d5ac9e083cbb5b16">fget</a> = <a class="code" href="group__group__io.html#ga0ecdc43a53e494edc4f84e8c135659ba">http_get</a>;</div><div class="line">  ... <span class="comment">//</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// return a service.wsdl WSDL document on HTTP GET service path ending in ?wsdl</span></div><div class="line"><span class="keywordtype">int</span> <a class="code" href="group__group__io.html#ga0ecdc43a53e494edc4f84e8c135659ba">http_get</a>(<span class="keyword">struct</span> soap * soap)</div><div class="line">{</div><div class="line">  FILE *fd = NULL;</div><div class="line">  <span class="keywordtype">char</span> *s = strchr(soap-&gt;<a class="code" href="structsoap.html#a3c2bd2822146a8ccca20f8f217c2f309">path</a>, <span class="charliteral">&#39;?&#39;</span>); <span class="comment">// soap-&gt;path has the URL path of soap-&gt;endpoint</span></div><div class="line">  <span class="keywordflow">if</span> (s == NULL || strcmp(s, <span class="stringliteral">&quot;?wsdl&quot;</span>) != 0) </div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="group__group__errors.html#gac62f5f70e545ea8fbcbb181e88750d56">SOAP_GET_METHOD</a>;  <span class="comment">// return GET method not available error</span></div><div class="line">  fd = <a class="code" href="group__group__callbacks.html#ga9b4985eb5a588f4c16ad88ef7ca329dc">fopen</a>(<span class="stringliteral">&quot;service.wsdl&quot;</span>, <span class="stringliteral">&quot;r&quot;</span>); <span class="comment">// open WSDL file to copy </span></div><div class="line">  <span class="keywordflow">if</span> (!fd) </div><div class="line">    <span class="keywordflow">return</span> 404; <span class="comment">// return HTTP not found error </span></div><div class="line">  soap-&gt;<a class="code" href="structsoap.html#ae5e98733a4349b5e1466a9e0ccc22c11">http_content</a> = <span class="stringliteral">&quot;text/xml&quot;</span>; <span class="comment">// HTTP header with text/xml content </span></div><div class="line">  <a class="code" href="group__group__io.html#ga0390e58bd2a3ebe6fe3a46de0534a614">soap_response</a>(soap, <a class="code" href="group__group__io.html#ga05be99343f556fe70940145e874cdb99">SOAP_FILE</a>); </div><div class="line">  <span class="keywordflow">while</span> (1)</div><div class="line">  {</div><div class="line">    <span class="keywordtype">size_t</span> r = fread(soap-&gt;<a class="code" href="structsoap.html#a194bcafed0c3e368b92f452fc80b2d31">tmpbuf</a>, 1, <span class="keyword">sizeof</span>(soap-&gt;<a class="code" href="structsoap.html#a194bcafed0c3e368b92f452fc80b2d31">tmpbuf</a>), fd); </div><div class="line">    <span class="keywordflow">if</span> (r == 0) </div><div class="line">      <span class="keywordflow">break</span>; </div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group__group__io.html#gab3b1ba631a0c47d67fe31474982bde86">soap_send_raw</a>(soap, soap-&gt;<a class="code" href="structsoap.html#a194bcafed0c3e368b92f452fc80b2d31">tmpbuf</a>, r)) </div><div class="line">      <span class="keywordflow">break</span>; <span class="comment">// can&#39;t send</span></div><div class="line">  } </div><div class="line">  <a class="code" href="group__group__callbacks.html#gab9591dd80dbb0e571784bad5421b2202">fclose</a>(fd); </div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="group__group__io.html#ga290ddb46afdbf5ec6669b6ac8daca5c9">soap_end_send</a>(soap); </div><div class="line">}</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td><code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code><a class="el" href="group__group__errors.html#ga3b10a68f354f39cbb0fe0d043ad4c7c0" title="The soap_status code for no error (zero) ">SOAP_OK</a></code> or a <code><a class="el" href="group__group__errors.html#gac0eadf8f72bacb5b41b750beaeca0444" title="Status and error codes are int values, a zero value or SOAP_OK (0) means no error, nonzero means error. ">soap_status</a></code> error code </dd></dl>

</div>
</div>
<a class="anchor" id="gadff52b7b3ecc16379eb2d7b1ff361978"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* soap::fhead) (struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback to implement logic at the server-side to serve responses to HTTP HEAD requests from clients. </p>
<p>This callback is called by the service dispatcher when an HTTP HEAD request is pending. Redefine this callback to respond to HTTP HEAD requests more specifically. Returns <code><a class="el" href="group__group__errors.html#ga3b10a68f354f39cbb0fe0d043ad4c7c0" title="The soap_status code for no error (zero) ">SOAP_OK</a></code> or a <code><a class="el" href="group__group__errors.html#gac0eadf8f72bacb5b41b750beaeca0444" title="Status and error codes are int values, a zero value or SOAP_OK (0) means no error, nonzero means error. ">soap_status</a></code> (int) error code. The built-in function assigned to <code><a class="el" href="group__group__callbacks.html#gadff52b7b3ecc16379eb2d7b1ff361978" title="Callback to implement logic at the server-side to serve responses to HTTP HEAD requests from clients...">soap::fhead</a></code> is the internal static function <code>http_200</code> that returns HTTP 200 OK.</p>
<dl class="section see"><dt>See also</dt><dd><code>::http_opt</code>, <code><a class="el" href="structsoap.html#a8eb35c04359a567c0b5e2664f3f94d5b" title="User-definable variable that may point to user-specified data of any type to pass the data through to...">soap::user</a></code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td><code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code><a class="el" href="group__group__errors.html#ga3b10a68f354f39cbb0fe0d043ad4c7c0" title="The soap_status code for no error (zero) ">SOAP_OK</a></code> or a <code><a class="el" href="group__group__errors.html#gac0eadf8f72bacb5b41b750beaeca0444" title="Status and error codes are int values, a zero value or SOAP_OK (0) means no error, nonzero means error. ">soap_status</a></code> error code </dd></dl>

</div>
</div>
<a class="anchor" id="gae88b674df5fdcfa866c04e4330fe0afe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* soap::fheader) (struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback to inspect the SOAP Header received before the rest of the message with the SOAP Body is consumed. </p>
<p>This callback is called immediately after parsing a SOAP Header into the <code><a class="el" href="structsoap.html#ac091dfe4e01b6a082d916c381e7006ba" title="The soap::header points to a SOAP_ENV__Header structure with the SOAP Header that was received or tha...">soap::header</a></code> structure. The SOAP Header structure <code><a class="el" href="structsoap.html#ac091dfe4e01b6a082d916c381e7006ba" title="The soap::header points to a SOAP_ENV__Header structure with the SOAP Header that was received or tha...">soap::header</a></code> can be inspected by this function and verified or rejected before the rest of the message with the SOAP Body is consumed. Returns <code><a class="el" href="group__group__errors.html#ga3b10a68f354f39cbb0fe0d043ad4c7c0" title="The soap_status code for no error (zero) ">SOAP_OK</a></code> or a <code><a class="el" href="group__group__errors.html#gac0eadf8f72bacb5b41b750beaeca0444" title="Status and error codes are int values, a zero value or SOAP_OK (0) means no error, nonzero means error. ">soap_status</a></code> (int) error code. No built-in function is assigned to <code><a class="el" href="group__group__callbacks.html#gae88b674df5fdcfa866c04e4330fe0afe" title="Callback to inspect the SOAP Header received before the rest of the message with the SOAP Body is con...">soap::fheader</a></code>.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__group__io.html#ga85c7fe6ae796534e2f54678c014c507c" title="The HTTP POST form plugin registration function. ">http_form</a></code>, <code><a class="el" href="structsoap.html#a8eb35c04359a567c0b5e2664f3f94d5b" title="User-definable variable that may point to user-specified data of any type to pass the data through to...">soap::user</a></code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td><code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code><a class="el" href="group__group__errors.html#ga3b10a68f354f39cbb0fe0d043ad4c7c0" title="The soap_status code for no error (zero) ">SOAP_OK</a></code> or a <code><a class="el" href="group__group__errors.html#gac0eadf8f72bacb5b41b750beaeca0444" title="Status and error codes are int values, a zero value or SOAP_OK (0) means no error, nonzero means error. ">soap_status</a></code> error code </dd></dl>

</div>
</div>
<a class="anchor" id="ga0c2e1a0b5a5197128af1acc48662b1bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* soap::fignore) (struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, const char *tag)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback to catch unrecognized XML elements and overrides <code><a class="el" href="group__group__flags.html#ga5faa29a69a247642495846d69ec8b90d" title="soap_mode XML input flag value to enable strict XML validation of messages received ...">SOAP_XML_STRICT</a></code> validation errors for these. </p>
<p>This callback is called when an unrecognized XML element was encountered on the input that could be ignored depending on some specified logic. The <code>tag</code> parameter is the offending XML element tag name string. The callback should return <code><a class="el" href="group__group__errors.html#ga3b10a68f354f39cbb0fe0d043ad4c7c0" title="The soap_status code for no error (zero) ">SOAP_OK</a></code> to ignore the element or return an <code><a class="el" href="group__group__errors.html#gac0eadf8f72bacb5b41b750beaeca0444" title="Status and error codes are int values, a zero value or SOAP_OK (0) means no error, nonzero means error. ">soap_status</a></code> error code such as <code><a class="el" href="group__group__errors.html#ga7f4d934410ea4dd2ffa5ad7fcaae7e70" title="A soap_status error code: XML element tag parsed does not match anything that is expected. ">SOAP_TAG_MISMATCH</a></code> to trigger a validation error. This callback also overrides <code>mustUnderstand</code> attributes on unrecognized SOAP Header elements that normally raise faults. It is strongly recommended that the callback returns <code><a class="el" href="group__group__errors.html#ga6e6849f52e3641ffba443df668d55168" title="A soap_status error code: an XML element is present with a mustUnderstand attribute which must be und...">SOAP_MUSTUNDERSTAND</a></code> when <code><a class="el" href="structsoap.html#a17c750f20dab579a6a23c30199ed1263" title="The soap::mustUnderstand flag is set when a SOAP Header element carries a SOAP-ENV:mustUnderstand att...">soap::mustUnderstand</a></code> != <code>0</code>. Returns <code><a class="el" href="group__group__errors.html#ga3b10a68f354f39cbb0fe0d043ad4c7c0" title="The soap_status code for no error (zero) ">SOAP_OK</a></code> or a <code><a class="el" href="group__group__errors.html#gac0eadf8f72bacb5b41b750beaeca0444" title="Status and error codes are int values, a zero value or SOAP_OK (0) means no error, nonzero means error. ">soap_status</a></code> (int) error code. No built-in function is assigned to <code><a class="el" href="group__group__callbacks.html#ga0c2e1a0b5a5197128af1acc48662b1bd" title="Callback to catch unrecognized XML elements and overrides SOAP_XML_STRICT validation errors for these...">soap::fignore</a></code>.</p>
<dl class="section note"><dt>Note</dt><dd>This callback was not called in gSOAP versions prior to 2.8.54 when <code><a class="el" href="group__group__flags.html#ga5faa29a69a247642495846d69ec8b90d" title="soap_mode XML input flag value to enable strict XML validation of messages received ...">SOAP_XML_STRICT</a></code> is set.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="structsoap.html#a8eb35c04359a567c0b5e2664f3f94d5b" title="User-definable variable that may point to user-specified data of any type to pass the data through to...">soap::user</a></code>.</dd></dl>
<dl class="section user"><dt>Example:</dt><dd></dd></dl>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keyword">struct </span>soap *soap = <a class="code" href="group__group__context.html#ga87c20488b2dc680aaa7689b1d024989c">soap_new</a>();</div><div class="line">  soap-&gt;<a class="code" href="group__group__callbacks.html#ga0c2e1a0b5a5197128af1acc48662b1bd">fignore</a> = ignore;</div><div class="line">  ... <span class="comment">//</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> ignore(<span class="keyword">struct</span> soap *soap, <span class="keyword">const</span> <span class="keywordtype">char</span> *tag) </div><div class="line">{ </div><div class="line">  <span class="comment">// do not ignore mustUnderstand=&quot;true&quot; </span></div><div class="line">  <span class="keywordflow">if</span> (!soap-&gt;<a class="code" href="structsoap.html#a17c750f20dab579a6a23c30199ed1263">mustUnderstand</a>)</div><div class="line">  {</div><div class="line">    <span class="comment">// tags &lt;ns:someElement&gt; can be safely ignored</span></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group__group__misc.html#ga91a35d2f67eeea8dc31fd23a3cea65d4">soap_match_tag</a>(soap, tag, <span class="stringliteral">&quot;ns:someElement&quot;</span>) == <a class="code" href="group__group__errors.html#ga3b10a68f354f39cbb0fe0d043ad4c7c0">SOAP_OK</a>)</div><div class="line">      <span class="keywordflow">return</span> <a class="code" href="group__group__errors.html#ga3b10a68f354f39cbb0fe0d043ad4c7c0">SOAP_OK</a>;</div><div class="line">  }</div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="group__group__errors.html#ga6e6849f52e3641ffba443df668d55168">SOAP_MUSTUNDERSTAND</a>; </div><div class="line">}</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td><code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context </td></tr>
    <tr><td class="paramname">tag</td><td>XML tag name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code><a class="el" href="group__group__errors.html#ga3b10a68f354f39cbb0fe0d043ad4c7c0" title="The soap_status code for no error (zero) ">SOAP_OK</a></code> or a <code><a class="el" href="group__group__errors.html#gac0eadf8f72bacb5b41b750beaeca0444" title="Status and error codes are int values, a zero value or SOAP_OK (0) means no error, nonzero means error. ">soap_status</a></code> error code </dd></dl>

</div>
</div>
<a class="anchor" id="gae2a9bb5e497817ef2af6f2c8fc1089d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void*(* soap::fmalloc) (struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, size_t size)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback to override dynamic memory allocation and management. </p>
<p>This callback can be used to override memory allocation and management done by <code><a class="el" href="group__group__context.html#gaba556710e010feeb2211ed43b5bf059c" title="Allocate a block of heap memory managed by the specified soap context. ">soap_malloc</a></code> in C. Memory allocated via this callback will not be managed and not be automatically released by the engine. Instead, the application using this callback should release allocated memory. All allocations done by <code><a class="el" href="group__group__context.html#gaba556710e010feeb2211ed43b5bf059c" title="Allocate a block of heap memory managed by the specified soap context. ">soap_malloc</a></code> are replaced with a call to <code><a class="el" href="group__group__callbacks.html#gae2a9bb5e497817ef2af6f2c8fc1089d9" title="Callback to override dynamic memory allocation and management. ">soap::fmalloc</a></code>. However, no other allocations, such as <code><a class="el" href="group__group__context.html#ga87c20488b2dc680aaa7689b1d024989c" title="Allocate and initialize a new soap context. ">soap_new</a></code> and <code>soap_new_T</code> for C++ classes, are affected. This callback is therefore not useful for C++ applications. Returns a pointer to dynamically allocated memory or NULL on failure to allocate. No built-in function is assigned to <code><a class="el" href="group__group__callbacks.html#gae2a9bb5e497817ef2af6f2c8fc1089d9" title="Callback to override dynamic memory allocation and management. ">soap::fmalloc</a></code>.</p>
<dl class="section warning"><dt>Warning</dt><dd>Deprecated since 2.8.72. Define <code><a class="el" href="group__group__soap.html#gae230c94899bda500324e3d93105ec0d6" title="User-definable macro to override malloc() for context-managed heap allocation (excluding C++ class in...">SOAP_MALLOC</a></code> and <code><a class="el" href="group__group__soap.html#gaf24c3943fa576663cd8495ce80138cde" title="User-definable macro to override free() for context-managed heap allocation (excluding C++ class inst...">SOAP_FREE</a></code> instead.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="structsoap.html#a8eb35c04359a567c0b5e2664f3f94d5b" title="User-definable variable that may point to user-specified data of any type to pass the data through to...">soap::user</a></code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td><code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context </td></tr>
    <tr><td class="paramname">size</td><td>number of bytes to allocate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to allocated memory or NULL on failure to allocate (out of memory) </dd></dl>

</div>
</div>
<a class="anchor" id="gaff40a1ca6fbf075b54ccbf479009ce74"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t(* soap::fmimeread) (struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, void *handle, char *buf, size_t len)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback to read data in a MIME/MTOM attachment stream. </p>
<p>This callback is called by the engine to read a chunk of attachment data to transmit. The <code>handle</code> parameter contains the handle returned by the <code><a class="el" href="group__group__callbacks.html#ga610f2a6a56d5ad04cb5124440a5de1dc" title="Callback to open a streaming MIME/MTOM attachment for reading. ">soap::fmimereadopen</a></code> callback. The <code>buf</code> parameter is the buffer of length <code>len</code> into which a chunk of data should be written by the callback. The actual amount of data written into the buffer may be less than <code>len</code> and this actual amount should be returned by the callback. A return value of zero indicates an error and <code><a class="el" href="structsoap.html#ab85f5d42702963d13ea540bd9876e6d2" title="The soap context soap_status (int) error code of the last operation or SOAP_OK (zero) ...">soap::error</a></code> should be set. The <code>__size</code> member variable of the attachment struct/class with data (e.g. <code><a class="el" href="structxsd____base64_binary.html" title="XSD base64Binary structure with attachment data. ">xsd__base64Binary</a></code> or <code><a class="el" href="struct__xop_____include.html" title="XOP include structure with attachment data. ">_xop__Include</a></code> with <code>__ptr</code>, <code>__size</code>, <code>id</code>, <code>type</code> and <code>options</code> members) should be set by the application prior to the serialization of the message with attachments. The value of <code>__size</code> indicates the total size of the attachment data to be transmitted. If the <code>__size</code> member variable is zero and HTTP chunking is enabled (with <code><a class="el" href="group__group__flags.html#gaea7443dc67c979b06cf347ed16db1b51" title="soap_mode IO output flag value to send HTTP chunked messages, buffers the message in packets of size ...">SOAP_IO_CHUNK</a></code>), then MIME/MTOM chunked transfers are activated by the engine, which is more flexible since the attachment data size does not need to be determined in advance. To use MIME/MTOM chunked transfers, enable HTTP chunking with <code><a class="el" href="group__group__flags.html#gaea7443dc67c979b06cf347ed16db1b51" title="soap_mode IO output flag value to send HTTP chunked messages, buffers the message in packets of size ...">SOAP_IO_CHUNK</a></code> (also <code><a class="el" href="group__group__flags.html#gaf7cbb692f85f8633c4efc66dfae41e9e" title="soap_mode IO output flag value to store messages temporarily before transmission, e...">SOAP_IO_STORE</a></code> can be used, but this buffers the entire message in memory before transmission) and set the <code>__size</code> member variable of the attachment struct/class to zero. When MIME/MTOM attachment chunking is enabled, this callback should completely fill the <code>buf</code> buffer with <code>len</code> bytes unless the last data chunk is reached and fewer bytes are returned.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__group__flags.html#ga988c0f4d52bf6f5cdac8c0e197ebe62a" title="soap_mode ENC output flag value to enable MIME attachments in messages to be sent, receiving is automatic ">SOAP_ENC_MIME</a></code>, <code><a class="el" href="group__group__flags.html#gac510f1f7c80fa8a3f20afa2dcfb53fb3" title="soap_mode ENC output flag value to enable MTOM XOP attachments in messages to be sent, receiving is automatic ">SOAP_ENC_MTOM</a></code>, <code><a class="el" href="group__group__callbacks.html#ga610f2a6a56d5ad04cb5124440a5de1dc" title="Callback to open a streaming MIME/MTOM attachment for reading. ">soap::fmimereadopen</a></code>, <code><a class="el" href="structsoap.html#a8eb35c04359a567c0b5e2664f3f94d5b" title="User-definable variable that may point to user-specified data of any type to pass the data through to...">soap::user</a></code>.</dd></dl>
<dl class="section user"><dt>Example:</dt><dd></dd></dl>
<p>See the example provided with the documentation for <code><a class="el" href="group__group__callbacks.html#ga610f2a6a56d5ad04cb5124440a5de1dc" title="Callback to open a streaming MIME/MTOM attachment for reading. ">soap::fmimereadopen</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td><code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context </td></tr>
    <tr><td class="paramname">handle</td><td>the value of the handle returned by <code><a class="el" href="group__group__callbacks.html#ga610f2a6a56d5ad04cb5124440a5de1dc" title="Callback to open a streaming MIME/MTOM attachment for reading. ">soap::fmimereadopen</a></code> </td></tr>
    <tr><td class="paramname">buf</td><td>buffer to fill </td></tr>
    <tr><td class="paramname">len</td><td>length of the buffer in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes written to the buffer </dd></dl>

</div>
</div>
<a class="anchor" id="ga884e94e8450f56049ba5071786170dd5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* soap::fmimereadclose) (struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, void *handle)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback to close a MIME/MTOM attachment stream after reading. </p>
<p>This callback is called by the engine to close the MIME/MTOM attachment stream after reading. The <code>handle</code> parameter contains the handle returned by the <code><a class="el" href="group__group__callbacks.html#ga610f2a6a56d5ad04cb5124440a5de1dc" title="Callback to open a streaming MIME/MTOM attachment for reading. ">soap::fmimereadopen</a></code> callback.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__group__flags.html#ga988c0f4d52bf6f5cdac8c0e197ebe62a" title="soap_mode ENC output flag value to enable MIME attachments in messages to be sent, receiving is automatic ">SOAP_ENC_MIME</a></code>, <code><a class="el" href="group__group__flags.html#gac510f1f7c80fa8a3f20afa2dcfb53fb3" title="soap_mode ENC output flag value to enable MTOM XOP attachments in messages to be sent, receiving is automatic ">SOAP_ENC_MTOM</a></code>, <code><a class="el" href="group__group__callbacks.html#ga610f2a6a56d5ad04cb5124440a5de1dc" title="Callback to open a streaming MIME/MTOM attachment for reading. ">soap::fmimereadopen</a></code>, <code><a class="el" href="structsoap.html#a8eb35c04359a567c0b5e2664f3f94d5b" title="User-definable variable that may point to user-specified data of any type to pass the data through to...">soap::user</a></code>.</dd></dl>
<dl class="section user"><dt>Example:</dt><dd></dd></dl>
<p>See the example provided with the documentation for <code><a class="el" href="group__group__callbacks.html#ga610f2a6a56d5ad04cb5124440a5de1dc" title="Callback to open a streaming MIME/MTOM attachment for reading. ">soap::fmimereadopen</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td><code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context </td></tr>
    <tr><td class="paramname">handle</td><td>the value of the of the handle returned by <code><a class="el" href="group__group__callbacks.html#ga610f2a6a56d5ad04cb5124440a5de1dc" title="Callback to open a streaming MIME/MTOM attachment for reading. ">soap::fmimereadopen</a></code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga610f2a6a56d5ad04cb5124440a5de1dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void*(* soap::fmimereadopen) (struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, void *, const char *, const char *, const char *)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback to open a streaming MIME/MTOM attachment for reading. </p>
<p>This callback is called by the engine to start sending a streaming MIME/MTOM attachment. This callback opens a stream to start reading the attachment data to send. The actual data stream will be read in chunks using the <code><a class="el" href="group__group__callbacks.html#gaff40a1ca6fbf075b54ccbf479009ce74" title="Callback to read data in a MIME/MTOM attachment stream. ">soap::fmimeread</a></code> callback until no more data is available and the <code><a class="el" href="group__group__callbacks.html#ga884e94e8450f56049ba5071786170dd5" title="Callback to close a MIME/MTOM attachment stream after reading. ">soap::fmimereadclose</a></code> callback is called to close the stream. The <code>handle</code> parameter contains the value of the <code>__ptr</code> member variable of the attachment struct/class with data (e.g. <code><a class="el" href="structxsd____base64_binary.html" title="XSD base64Binary structure with attachment data. ">xsd__base64Binary</a></code> or <code><a class="el" href="struct__xop_____include.html" title="XOP include structure with attachment data. ">_xop__Include</a></code> with <code>__ptr</code>, <code>__size</code>, <code>id</code>, <code>type</code> and <code>options</code> members), which should be a pointer to specific information such as a file descriptor or a pointer to a some application-specific data to be passed to this callback. Both the <code>__ptr</code> and <code>__size</code> members of the attachment struct/class should have been set by the application prior to the serialization of the message with attachments. If the <code>__size</code> is zero and HTTP chunking is enabled (with <code><a class="el" href="group__group__flags.html#gaea7443dc67c979b06cf347ed16db1b51" title="soap_mode IO output flag value to send HTTP chunked messages, buffers the message in packets of size ...">SOAP_IO_CHUNK</a></code>), then chunked MIME/MTOM attachments are sent, see <code><a class="el" href="group__group__callbacks.html#gaff40a1ca6fbf075b54ccbf479009ce74" title="Callback to read data in a MIME/MTOM attachment stream. ">soap::fmimeread</a></code>. The <code>id</code>, <code>type</code> and <code>options</code> parameters are the <code>id</code> (an optional ID), <code>type</code> (a MIME type) and <code>options</code> (a descriptive string) of the attachment struct/class, respectively, of which at least one member should be non-NULL. The callback should return the <code>handle</code> parameter value or another pointer value, which is passed as the new <code>handle</code> parameter to <code><a class="el" href="group__group__callbacks.html#gaff40a1ca6fbf075b54ccbf479009ce74" title="Callback to read data in a MIME/MTOM attachment stream. ">soap::fmimeread</a></code> and <code><a class="el" href="group__group__callbacks.html#ga884e94e8450f56049ba5071786170dd5" title="Callback to close a MIME/MTOM attachment stream after reading. ">soap::fmimereadclose</a></code> callbacks. When an error occurred in this callback, the callback should return NULL and set <code><a class="el" href="structsoap.html#ab85f5d42702963d13ea540bd9876e6d2" title="The soap context soap_status (int) error code of the last operation or SOAP_OK (zero) ...">soap::error</a></code> to an error code, e.g. using <code><a class="el" href="group__group__fault.html#ga91dc6bcc3c5f35e023b78a6f46a79ed6" title="Set SOAP 1.1 server fault / SOAP 1.2 receiver fault string and detail. ">soap_receiver_fault</a></code>. The callback may return NULL and set <code><a class="el" href="structsoap.html#ab85f5d42702963d13ea540bd9876e6d2" title="The soap context soap_status (int) error code of the last operation or SOAP_OK (zero) ...">soap::error</a></code> to <code><a class="el" href="group__group__errors.html#ga3b10a68f354f39cbb0fe0d043ad4c7c0" title="The soap_status code for no error (zero) ">SOAP_OK</a></code> when this specific MIME/MTOM attachment should not to be streamed and the engine will simply skip it.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__group__flags.html#gafaa6a1c2684babe91bea2e181b1f77e6" title="soap_mode ENC output flag value to enable DIME attachments (for internal use only) ...">SOAP_ENC_DIME</a></code>, <code><a class="el" href="structsoap.html#a8eb35c04359a567c0b5e2664f3f94d5b" title="User-definable variable that may point to user-specified data of any type to pass the data through to...">soap::user</a></code>.</dd></dl>
<dl class="section user"><dt>Example:</dt><dd></dd></dl>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> * mime_read_open(<span class="keyword">struct</span> soap *soap, <span class="keywordtype">void</span> *handle, <span class="keyword">const</span> <span class="keywordtype">char</span> *<span class="keywordtype">id</span>, <span class="keyword">const</span> <span class="keywordtype">char</span> *type, <span class="keyword">const</span> <span class="keywordtype">char</span> *options)</div><div class="line">{</div><div class="line">  <span class="keywordflow">return</span> (<span class="keywordtype">void</span>*)<a class="code" href="group__group__callbacks.html#ga9b4985eb5a588f4c16ad88ef7ca329dc">fopen</a>((<span class="keywordtype">char</span>*)handle, <span class="stringliteral">&quot;rb&quot;</span>);</div><div class="line">}</div><div class="line"><span class="keywordtype">size_t</span> mime_read(<span class="keyword">struct</span> soap *soap, <span class="keywordtype">void</span> *handle, <span class="keywordtype">char</span> *buf, <span class="keywordtype">size_t</span> len)</div><div class="line">{</div><div class="line">  <span class="keywordflow">return</span> fread(buf, 1, len, (FILE*)handle);</div><div class="line">}</div><div class="line"><span class="keywordtype">void</span> mime_read_close(<span class="keyword">struct</span> soap *soap, <span class="keywordtype">void</span> *handle)</div><div class="line">{</div><div class="line">  <a class="code" href="group__group__callbacks.html#gab9591dd80dbb0e571784bad5421b2202">fclose</a>((FILE*)handle);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">struct </span>soap *soap = <a class="code" href="group__group__context.html#ga51cde138234ed7ec8c4e25bdf6418658">soap_new1</a>(<a class="code" href="group__group__flags.html#gac510f1f7c80fa8a3f20afa2dcfb53fb3">SOAP_ENC_MTOM</a>);</div><div class="line">soap-&gt;<a class="code" href="group__group__callbacks.html#ga610f2a6a56d5ad04cb5124440a5de1dc">fmimereadopen</a> = mime_read_open;</div><div class="line">soap-&gt;<a class="code" href="group__group__callbacks.html#gaff40a1ca6fbf075b54ccbf479009ce74">fmimeread</a> = mime_read;</div><div class="line">soap-&gt;<a class="code" href="group__group__callbacks.html#ga884e94e8450f56049ba5071786170dd5">fmimereadclose</a> = mime_read_close;</div><div class="line"></div><div class="line"><span class="keyword">struct </span><a class="code" href="struct__xop_____include.html">_xop__Include</a> data;                                  <span class="comment">// here we&#39;re using gsoap/import/xop.h to store a blob of raw data</span></div><div class="line">data.<a class="code" href="struct__xop_____include.html#ab4388e79bc98595fefbde2fbcf5489ba">__ptr</a> = <span class="stringliteral">&quot;Picture.png&quot;</span>;                                 <span class="comment">// file name to open for streaming with mime_read_open</span></div><div class="line">data.__size = 1024;                                         <span class="comment">// file has 1024 bytes of data</span></div><div class="line">data.id = <a class="code" href="group__group__context.html#ga41747ef145667bdff9c66cdd2bc86653">soap_strdup</a>(soap, <a class="code" href="group__group__misc.html#ga5fcf3c8f6f4bc6d5e6efd7a92ceaf399">soap_rand_uuid</a>(soap, <span class="stringliteral">&quot;uuid:&quot;</span>)); <span class="comment">// attachment id (optional, can use NULL)</span></div><div class="line">data.type = <span class="stringliteral">&quot;image/png&quot;</span>;                                    <span class="comment">// attachment type</span></div><div class="line">data.options = <span class="stringliteral">&quot;Picture.png&quot;</span>;                               <span class="comment">// we store the file name with the attachment description</span></div><div class="line">... <span class="comment">// add data to the message and then send it, which will stream the MIME/MTOM attachment content from Picture.png</span></div></div><!-- fragment --><p>To enable chunked MIME/MTOM attachments, replace the last part of the example with:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>soap *soap = <a class="code" href="group__group__context.html#ga51cde138234ed7ec8c4e25bdf6418658">soap_new1</a>(<a class="code" href="group__group__flags.html#gaea7443dc67c979b06cf347ed16db1b51">SOAP_IO_CHUNK</a>);</div><div class="line"></div><div class="line"><span class="keyword">struct </span><a class="code" href="struct__xop_____include.html">_xop__Include</a> data;                                  <span class="comment">// here we&#39;re using gsoap/import/xop.h to store a blob of raw data</span></div><div class="line">data.<a class="code" href="struct__xop_____include.html#ab4388e79bc98595fefbde2fbcf5489ba">__ptr</a> = <span class="stringliteral">&quot;Picture.png&quot;</span>;                                 <span class="comment">// file name to open for streaming with dime_read_open</span></div><div class="line">data.__size = 0;                                            <span class="comment">// zero size means chunked MIME/MTOM attachments are sent</span></div><div class="line">data.id = <a class="code" href="group__group__context.html#ga41747ef145667bdff9c66cdd2bc86653">soap_strdup</a>(soap, <a class="code" href="group__group__misc.html#ga5fcf3c8f6f4bc6d5e6efd7a92ceaf399">soap_rand_uuid</a>(soap, <span class="stringliteral">&quot;uuid:&quot;</span>)); <span class="comment">// attachment id (optional, can use NULL)</span></div><div class="line">data.type = <span class="stringliteral">&quot;image/png&quot;</span>;                                    <span class="comment">// attachment type</span></div><div class="line">data.options = <span class="stringliteral">&quot;Picture.png&quot;</span>;                               <span class="comment">// we store the file name with the attachment description</span></div><div class="line">... <span class="comment">// add data to the message and then send it, which will stream the MIME/MTOM attachment content from Picture.png</span></div></div><!-- fragment --><p>This mechanism also works for MIME/MTOM attachments that are explicitly attached with <code><a class="el" href="group__group__mime.html#ga39e5da4f375e8030b8cbddaf0a2a8e6e" title="Add a MIME attachment to the SOAP/XML message. ">soap_set_mime_attachment</a></code>.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__group__flags.html#ga988c0f4d52bf6f5cdac8c0e197ebe62a" title="soap_mode ENC output flag value to enable MIME attachments in messages to be sent, receiving is automatic ">SOAP_ENC_MIME</a></code>, <code><a class="el" href="group__group__flags.html#gac510f1f7c80fa8a3f20afa2dcfb53fb3" title="soap_mode ENC output flag value to enable MTOM XOP attachments in messages to be sent, receiving is automatic ">SOAP_ENC_MTOM</a></code>, <code><a class="el" href="group__group__mime.html#ga39e5da4f375e8030b8cbddaf0a2a8e6e" title="Add a MIME attachment to the SOAP/XML message. ">soap_set_mime_attachment</a></code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td><code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context </td></tr>
    <tr><td class="paramname">handle</td><td>the value of the <code>__ptr</code> member variable of the attachment struct/class with data </td></tr>
    <tr><td class="paramname">id</td><td>the value of the <code>id</code> member variable of the attachment struct/class with data </td></tr>
    <tr><td class="paramname">type</td><td>the value of the <code>type</code> member variable of the attachment struct/class with data </td></tr>
    <tr><td class="paramname">options</td><td>the value of the <code>options</code> member variable of the attachment struct/class with data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a handle or NULL when an error occurred (<code><a class="el" href="structsoap.html#ab85f5d42702963d13ea540bd9876e6d2" title="The soap context soap_status (int) error code of the last operation or SOAP_OK (zero) ...">soap::error</a></code> is nonzero) or when the attachment should be skipped (<code><a class="el" href="structsoap.html#ab85f5d42702963d13ea540bd9876e6d2" title="The soap context soap_status (int) error code of the last operation or SOAP_OK (zero) ...">soap::error</a></code> is <code><a class="el" href="group__group__errors.html#ga3b10a68f354f39cbb0fe0d043ad4c7c0" title="The soap_status code for no error (zero) ">SOAP_OK</a></code>) </dd></dl>

</div>
</div>
<a class="anchor" id="ga9084f0392e4a54287366121d30bc4830"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* soap::fmimewrite) (struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, void *handle, const char *buf, size_t len)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback to write data in a MIME attachment stream. </p>
<p>This callback is called by the engine to write a chunk of attachment data received. The <code>handle</code> parameter contains the handle returned by the <code><a class="el" href="group__group__callbacks.html#gaef809b275fd65e57991a80663288fa72" title="Callback to open a streaming MIME/MTOM attachment for writing. ">soap::fmimewriteopen</a></code> callback. The <code>buf</code> parameter contains the data of length <code>len</code>. Returns <code><a class="el" href="group__group__errors.html#ga3b10a68f354f39cbb0fe0d043ad4c7c0" title="The soap_status code for no error (zero) ">SOAP_OK</a></code> or a <code><a class="el" href="group__group__errors.html#gac0eadf8f72bacb5b41b750beaeca0444" title="Status and error codes are int values, a zero value or SOAP_OK (0) means no error, nonzero means error. ">soap_status</a></code> (int) error code. </p><dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__group__flags.html#ga988c0f4d52bf6f5cdac8c0e197ebe62a" title="soap_mode ENC output flag value to enable MIME attachments in messages to be sent, receiving is automatic ">SOAP_ENC_MIME</a></code>, <code><a class="el" href="group__group__flags.html#gac510f1f7c80fa8a3f20afa2dcfb53fb3" title="soap_mode ENC output flag value to enable MTOM XOP attachments in messages to be sent, receiving is automatic ">SOAP_ENC_MTOM</a></code>, <code><a class="el" href="structsoap.html#a8eb35c04359a567c0b5e2664f3f94d5b" title="User-definable variable that may point to user-specified data of any type to pass the data through to...">soap::user</a></code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td><code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context </td></tr>
    <tr><td class="paramname">handle</td><td>the value of the handle returned by <code><a class="el" href="group__group__callbacks.html#gaef809b275fd65e57991a80663288fa72" title="Callback to open a streaming MIME/MTOM attachment for writing. ">soap::fmimewriteopen</a></code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code><a class="el" href="group__group__errors.html#ga3b10a68f354f39cbb0fe0d043ad4c7c0" title="The soap_status code for no error (zero) ">SOAP_OK</a></code> or a <code><a class="el" href="group__group__errors.html#gac0eadf8f72bacb5b41b750beaeca0444" title="Status and error codes are int values, a zero value or SOAP_OK (0) means no error, nonzero means error. ">soap_status</a></code> error code </dd></dl>

</div>
</div>
<a class="anchor" id="ga8af884096b21cea1b69133843131a47b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* soap::fmimewriteclose) (struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, void *handle)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback to close a MIME/MTOM attachment stream after writing. </p>
<p>This callback is called by the engine to close the MIME/MTOM attachment stream after writing. The <code>handle</code> parameter contains the handle returned by the <code><a class="el" href="group__group__callbacks.html#gaef809b275fd65e57991a80663288fa72" title="Callback to open a streaming MIME/MTOM attachment for writing. ">soap::fmimewriteopen</a></code> callback.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__group__flags.html#ga988c0f4d52bf6f5cdac8c0e197ebe62a" title="soap_mode ENC output flag value to enable MIME attachments in messages to be sent, receiving is automatic ">SOAP_ENC_MIME</a></code>, <code><a class="el" href="group__group__flags.html#gac510f1f7c80fa8a3f20afa2dcfb53fb3" title="soap_mode ENC output flag value to enable MTOM XOP attachments in messages to be sent, receiving is automatic ">SOAP_ENC_MTOM</a></code>, <code><a class="el" href="structsoap.html#a8eb35c04359a567c0b5e2664f3f94d5b" title="User-definable variable that may point to user-specified data of any type to pass the data through to...">soap::user</a></code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td><code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context </td></tr>
    <tr><td class="paramname">handle</td><td>the value of the of the handle returned by <code><a class="el" href="group__group__callbacks.html#gaef809b275fd65e57991a80663288fa72" title="Callback to open a streaming MIME/MTOM attachment for writing. ">soap::fmimewriteopen</a></code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaef809b275fd65e57991a80663288fa72"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void*(* soap::fmimewriteopen) (struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, void *handle, const char *id, const char *type, const char *description, enum <a class="el" href="group__group__mime.html#ga3fec7633da07bff2bf5fd6330bef1844">soap_mime_encoding</a> encoding)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback to open a streaming MIME/MTOM attachment for writing. </p>
<p>Called by the to start receiving a streaming MIME/MTOM attachment. This callback opens a stream to start writing the attachment data received. The actual data stream will be written in chunks using the <code><a class="el" href="group__group__callbacks.html#ga9084f0392e4a54287366121d30bc4830" title="Callback to write data in a MIME attachment stream. ">soap::fmimewrite</a></code> callback until no more data is available and the <code><a class="el" href="group__group__callbacks.html#ga8af884096b21cea1b69133843131a47b" title="Callback to close a MIME/MTOM attachment stream after writing. ">soap::fmimewriteclose</a></code> callback is called to close the stream. The <code>id</code>, <code>type</code> and <code>options</code> parameters are the <code>id</code>, <code>type</code> and <code>options</code> of the attachment struct/class (e.g. <code><a class="el" href="structxsd____base64_binary.html" title="XSD base64Binary structure with attachment data. ">xsd__base64Binary</a></code> or <code><a class="el" href="struct__xop_____include.html" title="XOP include structure with attachment data. ">_xop__Include</a></code> with <code>__ptr</code>, <code>__size</code>, <code>id</code>, <code>type</code> and <code>options</code> members), respectively. The callback should return a handle, which is passed to the <code><a class="el" href="group__group__callbacks.html#ga9084f0392e4a54287366121d30bc4830" title="Callback to write data in a MIME attachment stream. ">soap::fmimewrite</a></code> and <code><a class="el" href="group__group__callbacks.html#ga8af884096b21cea1b69133843131a47b" title="Callback to close a MIME/MTOM attachment stream after writing. ">soap::fmimewriteclose</a></code> callbacks. The <code>__ptr</code> member variable of the attachment struct/class is set by the engine to the value of this handle. The <code>__size</code> member variable is set to the size of the attachment received.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__group__flags.html#ga988c0f4d52bf6f5cdac8c0e197ebe62a" title="soap_mode ENC output flag value to enable MIME attachments in messages to be sent, receiving is automatic ">SOAP_ENC_MIME</a></code>, <code><a class="el" href="group__group__flags.html#gac510f1f7c80fa8a3f20afa2dcfb53fb3" title="soap_mode ENC output flag value to enable MTOM XOP attachments in messages to be sent, receiving is automatic ">SOAP_ENC_MTOM</a></code>, <code><a class="el" href="group__group__callbacks.html#ga610f2a6a56d5ad04cb5124440a5de1dc" title="Callback to open a streaming MIME/MTOM attachment for reading. ">soap::fmimereadopen</a></code>, <code><a class="el" href="structsoap.html#a8eb35c04359a567c0b5e2664f3f94d5b" title="User-definable variable that may point to user-specified data of any type to pass the data through to...">soap::user</a></code>.</dd></dl>
<dl class="section user"><dt>Example:</dt><dd></dd></dl>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> * mime_write_open(<span class="keyword">struct</span> soap *soap, <span class="keyword">const</span> <span class="keywordtype">char</span> *<span class="keywordtype">id</span>, <span class="keyword">const</span> <span class="keywordtype">char</span> *type, <span class="keyword">const</span> <span class="keywordtype">char</span> *options)</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> (options)</div><div class="line">  {</div><div class="line">    FILE *handle = NULL;</div><div class="line">    <span class="keywordtype">char</span> *name;</div><div class="line">    <span class="keywordtype">size_t</span> len = ((<span class="keywordtype">unsigned</span> char)options[2] &lt;&lt; 8) | ((<span class="keywordtype">unsigned</span> char)options[3]); <span class="comment">// get option string length</span></div><div class="line">    name = (<span class="keywordtype">char</span>*)<a class="code" href="group__group__context.html#gaba556710e010feeb2211ed43b5bf059c">soap_malloc</a>(soap, len + 1);</div><div class="line">    strncpy(name, options + 4, len); <span class="comment">// get file name from options (as an example)</span></div><div class="line">    name[len] = <span class="charliteral">&#39;\0&#39;</span>;</div><div class="line">    handle = <a class="code" href="group__group__callbacks.html#ga9b4985eb5a588f4c16ad88ef7ca329dc">fopen</a>(name, <span class="stringliteral">&quot;wb&quot;</span>);</div><div class="line">    <span class="keywordflow">if</span> (!handle)</div><div class="line">    {</div><div class="line">      soap-&gt;<a class="code" href="structsoap.html#ab85f5d42702963d13ea540bd9876e6d2">error</a> = <a class="code" href="group__group__errors.html#ga224b2c2b830135f12b53536f189b4ebd">SOAP_EOF</a>; <span class="comment">// could not open file for writing</span></div><div class="line">      soap-&gt;<a class="code" href="structsoap.html#a10b66d6d489690b7d0f591ae2633dd13">errnum</a> = errno;   <span class="comment">// to report errno value</span></div><div class="line">      <span class="keywordflow">return</span> NULL;</div><div class="line">    }</div><div class="line">  }</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">  {</div><div class="line">    soap-&gt;<a class="code" href="structsoap.html#ab85f5d42702963d13ea540bd9876e6d2">error</a> = <a class="code" href="group__group__fault.html#ga91dc6bcc3c5f35e023b78a6f46a79ed6">soap_receiver_fault</a>(soap, <span class="stringliteral">&quot;Cannot save to file: no file name was present in the attachment&quot;</span>, NULL);</div><div class="line">  }</div><div class="line">  <span class="keywordflow">return</span> (<span class="keywordtype">void</span>*)handle;</div><div class="line">}</div><div class="line"><span class="keywordtype">int</span> mime_write(<span class="keyword">struct</span> soap *soap, <span class="keywordtype">void</span> *handle, <span class="keyword">const</span> <span class="keywordtype">char</span> *buf, <span class="keywordtype">size_t</span> len)</div><div class="line">{</div><div class="line">  <span class="keywordflow">while</span> (len)</div><div class="line">  {</div><div class="line">    <span class="keywordtype">size_t</span> nwritten = fwrite(buf, 1, len, (FILE*)handle);</div><div class="line">    <span class="keywordflow">if</span> (!nwritten)</div><div class="line">    {</div><div class="line">      soap-&gt;<a class="code" href="structsoap.html#a10b66d6d489690b7d0f591ae2633dd13">errnum</a> = errno;</div><div class="line">      <span class="keywordflow">return</span> <a class="code" href="group__group__errors.html#ga224b2c2b830135f12b53536f189b4ebd">SOAP_EOF</a>;</div><div class="line">    }</div><div class="line">    len -= nwritten;</div><div class="line">    buf += nwritten;</div><div class="line">  }</div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="group__group__errors.html#ga3b10a68f354f39cbb0fe0d043ad4c7c0">SOAP_OK</a>;</div><div class="line">}</div><div class="line"><span class="keywordtype">void</span> mime_write_close(<span class="keyword">struct</span> soap *soap, <span class="keywordtype">void</span> *handle)</div><div class="line">{</div><div class="line">  <a class="code" href="group__group__callbacks.html#gab9591dd80dbb0e571784bad5421b2202">fclose</a>((FILE*)handle);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">struct </span>soap *soap = <a class="code" href="group__group__context.html#ga87c20488b2dc680aaa7689b1d024989c">soap_new</a>();</div><div class="line">soap-&gt;<a class="code" href="group__group__callbacks.html#gaef809b275fd65e57991a80663288fa72">fmimewriteopen</a> = mime_write_open;</div><div class="line">soap-&gt;<a class="code" href="group__group__callbacks.html#ga9084f0392e4a54287366121d30bc4830">fmimewrite</a> = mime_write;</div><div class="line">soap-&gt;<a class="code" href="group__group__callbacks.html#ga8af884096b21cea1b69133843131a47b">fmimewriteclose</a> = mime_write_close;</div><div class="line"></div><div class="line">... <span class="comment">// when a service responds to the client request with MIME/MTOM attachment(s), the attachment data is saved via the callbacks</span></div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td><code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context </td></tr>
    <tr><td class="paramname">id</td><td>the value of the <code>id</code> member variable of the attachment struct/class with data </td></tr>
    <tr><td class="paramname">type</td><td>the value of the <code>type</code> member variable of the attachment struct/class with data </td></tr>
    <tr><td class="paramname">options</td><td>the value of the <code>options</code> member variable of the attachment struct/class with data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a handle or NULL when an error occurred (<code><a class="el" href="structsoap.html#ab85f5d42702963d13ea540bd9876e6d2" title="The soap context soap_status (int) error code of the last operation or SOAP_OK (zero) ...">soap::error</a></code> should be nonzero) </dd></dl>

</div>
</div>
<a class="anchor" id="ga9b4985eb5a588f4c16ad88ef7ca329dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__soap.html#ga6eb1bde7cecc2fbadbcbbc6395227439">SOAP_SOCKET</a>(* soap::fopen) (struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, const char *endpoint, const char *host, int port)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback that opens a socket connection to a server endpoint. </p>
<p>This callback is called by the engine at the client-side by <code><a class="el" href="group__group__io.html#ga5c87e9d0a43fe18cc349c724f198f64a" title="Connect to a server using HTTP POST. ">soap_connect</a></code> or <code><a class="el" href="group__group__io.html#ga315b6e1d5888780bf4ef320c50f23796" title="Connect to a server. ">soap_connect_command</a></code> to open a TCP or UDP connection to a server specified at an endpoint. Parameters <code>host</code> and <code>port</code> are micro-parsed from <code>endpoint</code> before being passed to <code><a class="el" href="group__group__callbacks.html#ga9b4985eb5a588f4c16ad88ef7ca329dc" title="Callback that opens a socket connection to a server endpoint. ">soap::fopen</a></code>. Returns a valid socket or <code><a class="el" href="group__group__soap.html#gab9e77b1557780293eec0b269ef191472" title="Macro that defines a portable invalid socket value (usually -1, but the value depends on the OS) ...">SOAP_INVALID_SOCKET</a></code> with a <code><a class="el" href="structsoap.html#ab85f5d42702963d13ea540bd9876e6d2" title="The soap context soap_status (int) error code of the last operation or SOAP_OK (zero) ...">soap::error</a></code> set to a <code><a class="el" href="group__group__errors.html#gac0eadf8f72bacb5b41b750beaeca0444" title="Status and error codes are int values, a zero value or SOAP_OK (0) means no error, nonzero means error. ">soap_status</a></code> (int) error code and <code><a class="el" href="structsoap.html#a10b66d6d489690b7d0f591ae2633dd13" title="The errno value of the last failed IO operation. ">soap::errnum</a></code> set to <code>errno</code> of the connection failure. The built-in function assigned to <code><a class="el" href="group__group__callbacks.html#ga9b4985eb5a588f4c16ad88ef7ca329dc" title="Callback that opens a socket connection to a server endpoint. ">soap::fopen</a></code> is <code>tcp_connect</code>.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__group__callbacks.html#ga8249b4c23f662dbe680ad0deef274ae8" title="Callback that waits for and accepts a socket connection requested by a client. ">soap::faccept</a></code>, <code><a class="el" href="structsoap.html#a8eb35c04359a567c0b5e2664f3f94d5b" title="User-definable variable that may point to user-specified data of any type to pass the data through to...">soap::user</a></code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td><code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context </td></tr>
    <tr><td class="paramname">endpoint</td><td>URL of the endpoint to connect to (string) </td></tr>
    <tr><td class="paramname">host</td><td>URL host of the endpoint to connect to (string) </td></tr>
    <tr><td class="paramname">port</td><td>URL port of the endpoint to connect to (int) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code><a class="el" href="group__group__errors.html#ga3b10a68f354f39cbb0fe0d043ad4c7c0" title="The soap_status code for no error (zero) ">SOAP_OK</a></code> or a <code><a class="el" href="group__group__errors.html#gac0eadf8f72bacb5b41b750beaeca0444" title="Status and error codes are int values, a zero value or SOAP_OK (0) means no error, nonzero means error. ">soap_status</a></code> error code </dd></dl>

</div>
</div>
<a class="anchor" id="ga65272c1ecb5ed9925a5a670cf7e77d10"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* soap::fopt) (struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback to implement logic at the server-side to serve responses to HTTP OPTION requests from clients. </p>
<p>Called by the service dispatcher when an HTTP OPTION request is pending. Redefine this callback to respond to HTTP OPTION requests, see the <code><a class="el" href="group__group__io.html#ga4c08d5ef28bc0dc37eee4633acdd1140" title="The HTTP POST plugin registration function. ">http_post</a></code> HTTP POST plugin for more details. Returns <code><a class="el" href="group__group__errors.html#ga3b10a68f354f39cbb0fe0d043ad4c7c0" title="The soap_status code for no error (zero) ">SOAP_OK</a></code> or a <code><a class="el" href="group__group__errors.html#gac0eadf8f72bacb5b41b750beaeca0444" title="Status and error codes are int values, a zero value or SOAP_OK (0) means no error, nonzero means error. ">soap_status</a></code> (int) error code. The built-in function assigned to <code><a class="el" href="group__group__callbacks.html#ga65272c1ecb5ed9925a5a670cf7e77d10" title="Callback to implement logic at the server-side to serve responses to HTTP OPTION requests from client...">soap::fopt</a></code> is the internal static function <code>http_200</code> that returns HTTP 200 OK.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__group__io.html#ga4c08d5ef28bc0dc37eee4633acdd1140" title="The HTTP POST plugin registration function. ">http_post</a></code>, <code><a class="el" href="structsoap.html#a8eb35c04359a567c0b5e2664f3f94d5b" title="User-definable variable that may point to user-specified data of any type to pass the data through to...">soap::user</a></code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td><code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code><a class="el" href="group__group__errors.html#ga3b10a68f354f39cbb0fe0d043ad4c7c0" title="The soap_status code for no error (zero) ">SOAP_OK</a></code> or a <code><a class="el" href="group__group__errors.html#gac0eadf8f72bacb5b41b750beaeca0444" title="Status and error codes are int values, a zero value or SOAP_OK (0) means no error, nonzero means error. ">soap_status</a></code> error code </dd></dl>

</div>
</div>
<a class="anchor" id="ga9cb05ce98f845f16c920c44426ac35a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* soap::fparse) (struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback that reads and parses HTTP and MIME headers. </p>
<p>This callback is called by the engine (as a client or server) to read and parse HTTP headers or MIME headers. When redefined, this function should read or skip the entire HTTP header to reach the message body. Function <code><a class="el" href="group__group__io.html#ga3f54c5916c6f6ddffec5d7120a230f46" title="Get a header line. ">soap_getline</a></code> is used by this callback to read each header line into an internal buffer <code><a class="el" href="structsoap.html#a58350076d9fa133bacca27424fe0feff" title="Internal buffer to hold short messages, URLs and HTTP/MIME header lines, must have at least SOAP_TMPL...">soap::msgbuf</a></code> with <code><a class="el" href="group__group__io.html#ga3f54c5916c6f6ddffec5d7120a230f46" title="Get a header line. ">soap_getline</a>(soap, soap-&gt;msgbuf, sizeof(soap-&gt;msgbuf))</code>. Returns <code><a class="el" href="group__group__errors.html#ga3b10a68f354f39cbb0fe0d043ad4c7c0" title="The soap_status code for no error (zero) ">SOAP_OK</a></code>, or a gSOAP error code. The built-in function assigned to <code><a class="el" href="group__group__callbacks.html#ga9cb05ce98f845f16c920c44426ac35a5" title="Callback that reads and parses HTTP and MIME headers. ">soap::fparse</a></code> is <code>http_parse</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td><code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code><a class="el" href="group__group__errors.html#ga3b10a68f354f39cbb0fe0d043ad4c7c0" title="The soap_status code for no error (zero) ">SOAP_OK</a></code> or a <code><a class="el" href="group__group__errors.html#gac0eadf8f72bacb5b41b750beaeca0444" title="Status and error codes are int values, a zero value or SOAP_OK (0) means no error, nonzero means error. ">soap_status</a></code> error code</dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__group__callbacks.html#ga70b75026b5fb1a9a2d5779f72454f082" title="Callback that consumes an HTTP header that consists of a key-value pair. ">soap::fparsehdr</a></code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga70b75026b5fb1a9a2d5779f72454f082"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* soap::fparsehdr) (struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, const char *key, const char *val)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback that consumes an HTTP header that consists of a key-value pair. </p>
<p>This callback is called by <code><a class="el" href="group__group__callbacks.html#ga9cb05ce98f845f16c920c44426ac35a5" title="Callback that reads and parses HTTP and MIME headers. ">soap::fparse</a></code>, consumes an HTTP header that is split in a key-value pair and updates the <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context state accordingly. The context is updated with the HTTP header information received, but HTTP headers are not literally retained by the engine. Returns <code><a class="el" href="group__group__errors.html#ga3b10a68f354f39cbb0fe0d043ad4c7c0" title="The soap_status code for no error (zero) ">SOAP_OK</a></code> or <code><a class="el" href="group__group__errors.html#gaa03308d50b94828cbc49724d049d9d2d" title="An internal soap_status error code to signal that an HTTP response must not be produced. ">SOAP_STOP</a></code> to prevent further reading of the HTTP body, or a <code><a class="el" href="group__group__errors.html#gac0eadf8f72bacb5b41b750beaeca0444" title="Status and error codes are int values, a zero value or SOAP_OK (0) means no error, nonzero means error. ">soap_status</a></code> (int) error code. The built-in function assigned to <code><a class="el" href="group__group__callbacks.html#ga70b75026b5fb1a9a2d5779f72454f082" title="Callback that consumes an HTTP header that consists of a key-value pair. ">soap::fparsehdr</a></code> is <code>http_parse_header</code>.</p>
<dl class="section note"><dt>Note</dt><dd>This callback can be used to parse (custom) HTTP headers, which is typically done by plugins.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__group__callbacks.html#ga9cb05ce98f845f16c920c44426ac35a5" title="Callback that reads and parses HTTP and MIME headers. ">soap::fparse</a></code>, <code><a class="el" href="structsoap.html#afb22ae0a494a35268914286bd00446ab" title="User-definable string that specifies an extra HTTP header or headers when separated by CRLF...">soap::http_extra_header</a></code>, <code><a class="el" href="structsoap.html#a8eb35c04359a567c0b5e2664f3f94d5b" title="User-definable variable that may point to user-specified data of any type to pass the data through to...">soap::user</a></code>.</dd></dl>
<dl class="section user"><dt>Example:</dt><dd></dd></dl>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keyword">struct </span>soap *soap = <a class="code" href="group__group__context.html#ga87c20488b2dc680aaa7689b1d024989c">soap_new</a>();</div><div class="line">  soap-&gt;<a class="code" href="structsoap.html#a8eb35c04359a567c0b5e2664f3f94d5b">user</a> = (<span class="keywordtype">void</span>*)soap-&gt;<a class="code" href="group__group__callbacks.html#ga70b75026b5fb1a9a2d5779f72454f082">fparsehdr</a>; <span class="comment">// to call the engine&#39;s fparsehdr()</span></div><div class="line">  soap-&gt;<a class="code" href="group__group__callbacks.html#ga70b75026b5fb1a9a2d5779f72454f082">fparsehdr</a> = parse_header;</div><div class="line">  ... <span class="comment">//</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> parse_header(<span class="keyword">struct</span> soap *soap, <span class="keyword">const</span> <span class="keywordtype">char</span> *key, <span class="keyword">const</span> <span class="keywordtype">char</span> *val)</div><div class="line">{</div><div class="line">  ... <span class="comment">// use key and val, then pass the key-val to the engine:</span></div><div class="line">  <span class="keywordflow">return</span> ((<span class="keywordtype">int</span>(*)(<span class="keyword">struct</span> soap*, <span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">char</span>*))(soap-&gt;<a class="code" href="structsoap.html#a8eb35c04359a567c0b5e2664f3f94d5b">user</a>))(<a class="code" href="structsoap.html#a740f8760f6ee4c6584e25c612f585d70">soap</a>, key, val);</div><div class="line">}</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td><code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context </td></tr>
    <tr><td class="paramname">key</td><td>HTTP header key received (non-NULL string) </td></tr>
    <tr><td class="paramname">val</td><td>HTTP header value received (non-NULL string) or an empty string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code><a class="el" href="group__group__errors.html#ga3b10a68f354f39cbb0fe0d043ad4c7c0" title="The soap_status code for no error (zero) ">SOAP_OK</a></code>, <code><a class="el" href="group__group__errors.html#gaa03308d50b94828cbc49724d049d9d2d" title="An internal soap_status error code to signal that an HTTP response must not be produced. ">SOAP_STOP</a></code> or a <code><a class="el" href="group__group__errors.html#gac0eadf8f72bacb5b41b750beaeca0444" title="Status and error codes are int values, a zero value or SOAP_OK (0) means no error, nonzero means error. ">soap_status</a></code> error code </dd></dl>

</div>
</div>
<a class="anchor" id="ga808a6a9b7e6d17e039fb53a5e8a9b84a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* soap::fpatch) (struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback to implement logic at the server-side to serve responses to HTTP PATCH requests from clients. </p>
<p>This callback is called by the service dispatcher when an HTTP PATCH request is pending. Redefine this callback to respond to HTTP PATCH requests, see the <code><a class="el" href="group__group__io.html#ga4c08d5ef28bc0dc37eee4633acdd1140" title="The HTTP POST plugin registration function. ">http_post</a></code> HTTP POST plugin for more details. Returns <code><a class="el" href="group__group__errors.html#ga3b10a68f354f39cbb0fe0d043ad4c7c0" title="The soap_status code for no error (zero) ">SOAP_OK</a></code> or a <code><a class="el" href="group__group__errors.html#gac0eadf8f72bacb5b41b750beaeca0444" title="Status and error codes are int values, a zero value or SOAP_OK (0) means no error, nonzero means error. ">soap_status</a></code> error code. The built-in function assigned to <code><a class="el" href="group__group__callbacks.html#ga808a6a9b7e6d17e039fb53a5e8a9b84a" title="Callback to implement logic at the server-side to serve responses to HTTP PATCH requests from clients...">soap::fpatch</a></code> is the internal static function <code>http_patch</code> that returns the <code><a class="el" href="group__group__errors.html#gaf8d3f932c1d555c2cbca899c1095d40e" title="A soap_status error code: an HTTP PATCH request was received by the service but the PATCH request cal...">SOAP_PATCH_METHOD</a></code> error.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__group__io.html#ga4c08d5ef28bc0dc37eee4633acdd1140" title="The HTTP POST plugin registration function. ">http_post</a></code>, <code><a class="el" href="structsoap.html#a8eb35c04359a567c0b5e2664f3f94d5b" title="User-definable variable that may point to user-specified data of any type to pass the data through to...">soap::user</a></code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td><code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code><a class="el" href="group__group__errors.html#ga3b10a68f354f39cbb0fe0d043ad4c7c0" title="The soap_status code for no error (zero) ">SOAP_OK</a></code> or a <code><a class="el" href="group__group__errors.html#gac0eadf8f72bacb5b41b750beaeca0444" title="Status and error codes are int values, a zero value or SOAP_OK (0) means no error, nonzero means error. ">soap_status</a></code> error code </dd></dl>

</div>
</div>
<a class="anchor" id="ga20210aa171019b27ef182d853e2d6e2f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* soap::fpoll) (struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback that blocks until activity is detected on the <code><a class="el" href="structsoap.html#a1579bd8bd106afc9a906a673ca473046" title="The socket set by soap_accept (or the C++ service class accept method) or soap_connect or soap_connec...">soap::socket</a></code> or <code><a class="el" href="structsoap.html#ab649b8f3b71081d14ec6350ab4b06794" title="The socket set by soap_bind (or the C++ service class bind method) to serve as the master socket boun...">soap::master</a></code> socket, times out when <code><a class="el" href="structsoap.html#a711bb3a53de7cc62429e4d3a2e0b5474" title="User-definable timeout to send a packet of data, positive timeout values are seconds, negative timeout values are microseconds, zero means no timeout (the value is 0 by default) ">soap::send_timeout</a></code> or <code><a class="el" href="structsoap.html#ac5d5fb92fffda724ccb3b038d2bb2388" title="User-definable timeout to receive a packet of data, positive timeout values are seconds, negative timeout values are microseconds, zero means no timeout (the value is 0 by default) ">soap::recv_timeout</a></code> are set. </p>
<p>This callback is called by the engine to wait for activity on the <code><a class="el" href="structsoap.html#a1579bd8bd106afc9a906a673ca473046" title="The socket set by soap_accept (or the C++ service class accept method) or soap_connect or soap_connec...">soap::socket</a></code> or <code><a class="el" href="structsoap.html#ab649b8f3b71081d14ec6350ab4b06794" title="The socket set by soap_bind (or the C++ service class bind method) to serve as the master socket boun...">soap::master</a></code> socket using <code>poll</code> or <code>select</code>. Times out when <code><a class="el" href="structsoap.html#a711bb3a53de7cc62429e4d3a2e0b5474" title="User-definable timeout to send a packet of data, positive timeout values are seconds, negative timeout values are microseconds, zero means no timeout (the value is 0 by default) ">soap::send_timeout</a></code> or <code><a class="el" href="structsoap.html#ac5d5fb92fffda724ccb3b038d2bb2388" title="User-definable timeout to receive a packet of data, positive timeout values are seconds, negative timeout values are microseconds, zero means no timeout (the value is 0 by default) ">soap::recv_timeout</a></code> are nonzero. Returns <code><a class="el" href="group__group__errors.html#ga3b10a68f354f39cbb0fe0d043ad4c7c0" title="The soap_status code for no error (zero) ">SOAP_OK</a></code> or a <code><a class="el" href="group__group__errors.html#gac0eadf8f72bacb5b41b750beaeca0444" title="Status and error codes are int values, a zero value or SOAP_OK (0) means no error, nonzero means error. ">soap_status</a></code> (int) error code. The built-in function assigned to <code><a class="el" href="group__group__callbacks.html#ga20210aa171019b27ef182d853e2d6e2f" title="Callback that blocks until activity is detected on the soap::socket or soap::master socket...">soap::fpoll</a></code> is <code><a class="el" href="group__group__io.html#gab331e9628197f71adb4caabacd20315e" title="Poll the connection. ">soap_poll</a></code>.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="structsoap.html#a8eb35c04359a567c0b5e2664f3f94d5b" title="User-definable variable that may point to user-specified data of any type to pass the data through to...">soap::user</a></code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td><code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code><a class="el" href="group__group__errors.html#ga3b10a68f354f39cbb0fe0d043ad4c7c0" title="The soap_status code for no error (zero) ">SOAP_OK</a></code> or a <code><a class="el" href="group__group__errors.html#gac0eadf8f72bacb5b41b750beaeca0444" title="Status and error codes are int values, a zero value or SOAP_OK (0) means no error, nonzero means error. ">soap_status</a></code> error code </dd></dl>

</div>
</div>
<a class="anchor" id="ga78d2b5440b33d3882b595ca8cfdec425"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* soap::fpost) (struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, const char *endpoint, const char *host, int port, const char *path, const char *action, <a class="el" href="group__group__soap.html#ga7c6e38d209f60a18e362172dca1a3b6e">ULONG64</a> count)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback that populates and then sends HTTP headers from the client-side to a connected HTTP server. </p>
<p>This callback is called at the client side by the engine to send HTTP headers to the connected server. The parameters <code>host</code>, <code>port</code>, and <code>path</code> were micro-parsed from the <code>endpoint</code> prior to passing them to this callback. Parameter <code>action</code> is the SOAP Action header. Parameter <code>count</code> is the length of the HTTP body with the message or 0 when HTTP chunking is used. This callback sends the headers with POST by default, or when <code><a class="el" href="structsoap.html#aec65c0198db5df4bef7afd2df29ff88d" title="The soap context HTTP status code received at the client side (100 to 599), HTTP header method receiv...">soap::status</a></code> == <code><a class="el" href="group__group__io.html#ga41f39e73106f1a2283ae3aa65698050f" title="HTTP POST command code. ">SOAP_POST</a></code> or <code><a class="el" href="structsoap.html#aec65c0198db5df4bef7afd2df29ff88d" title="The soap context HTTP status code received at the client side (100 to 599), HTTP header method receiv...">soap::status</a></code> == <code><a class="el" href="group__group__io.html#ga4c291263eadcefa290e90c64e632ae47" title="HTTP POST command code with custom content type. ">SOAP_POST_FILE</a></code>. Alternatively, sends the HTTP headers with GET when <code><a class="el" href="structsoap.html#aec65c0198db5df4bef7afd2df29ff88d" title="The soap context HTTP status code received at the client side (100 to 599), HTTP header method receiv...">soap::status</a></code> == <code><a class="el" href="group__group__io.html#ga3abcdd760843c4bdc56c19b85453ed04" title="HTTP GET command code. ">SOAP_GET</a></code>, PATCH when <code><a class="el" href="structsoap.html#aec65c0198db5df4bef7afd2df29ff88d" title="The soap context HTTP status code received at the client side (100 to 599), HTTP header method receiv...">soap::status</a></code> == <code><a class="el" href="group__group__io.html#ga0f6661cfe8eff845600e7a75a2f46701" title="HTTP PATCH command code with custom content type. ">SOAP_PATCH</a></code>, PUT when <code><a class="el" href="structsoap.html#aec65c0198db5df4bef7afd2df29ff88d" title="The soap context HTTP status code received at the client side (100 to 599), HTTP header method receiv...">soap::status</a></code> == <code><a class="el" href="group__group__io.html#ga32a114ef8df190363b9c3ad37bcb6335" title="HTTP PUT command code with custom content type. ">SOAP_PUT</a></code>, DELETE when <code><a class="el" href="structsoap.html#aec65c0198db5df4bef7afd2df29ff88d" title="The soap context HTTP status code received at the client side (100 to 599), HTTP header method receiv...">soap::status</a></code> == <code><a class="el" href="group__group__io.html#ga6e1b491acf772e88f64909ee5baae18d" title="HTTP DEL command code. ">SOAP_DEL</a></code>, CONNECT when <code><a class="el" href="structsoap.html#aec65c0198db5df4bef7afd2df29ff88d" title="The soap context HTTP status code received at the client side (100 to 599), HTTP header method receiv...">soap::status</a></code> == <code><a class="el" href="group__group__io.html#gaaf0409312a4af954ee5b183b92967e0b" title="HTTP CONNECT command code. ">SOAP_CONNECT</a></code>, HEAD when <code><a class="el" href="structsoap.html#aec65c0198db5df4bef7afd2df29ff88d" title="The soap context HTTP status code received at the client side (100 to 599), HTTP header method receiv...">soap::status</a></code> == <code><a class="el" href="group__group__io.html#ga31ba86b35e83440e4047b021add6fe2c" title="HTTP HEAD command code. ">SOAP_HEAD</a></code> or OPTIONS when <code><a class="el" href="structsoap.html#aec65c0198db5df4bef7afd2df29ff88d" title="The soap context HTTP status code received at the client side (100 to 599), HTTP header method receiv...">soap::status</a></code> == <code><a class="el" href="group__group__io.html#gab85d36efa8017c3d328289e25318fb18" title="HTTP OPTIONS command code. ">SOAP_OPTIONS</a></code>. Extra HTTP headers are added when <code><a class="el" href="structsoap.html#afb22ae0a494a35268914286bd00446ab" title="User-definable string that specifies an extra HTTP header or headers when separated by CRLF...">soap::http_extra_header</a></code> is set to one or more header lines separated by CRLF. When redefining this callback, use function <code><a class="el" href="group__group__io.html#ga7712f5bc36127050a11ad995d0593bdc" title="Send a string. ">soap_send</a></code> to write the header contents. Returns <code><a class="el" href="group__group__errors.html#ga3b10a68f354f39cbb0fe0d043ad4c7c0" title="The soap_status code for no error (zero) ">SOAP_OK</a></code> or a <code><a class="el" href="group__group__errors.html#gac0eadf8f72bacb5b41b750beaeca0444" title="Status and error codes are int values, a zero value or SOAP_OK (0) means no error, nonzero means error. ">soap_status</a></code> (int) error code. The built-in function assigned to <code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a>:fpost</code> is <code>http_post</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td><code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context </td></tr>
    <tr><td class="paramname">endpoint</td><td>URL of the endpoint connected to (string) </td></tr>
    <tr><td class="paramname">host</td><td>URL host of the endpoint connected to (string) </td></tr>
    <tr><td class="paramname">port</td><td>URL port of the endpoint connected to (int) </td></tr>
    <tr><td class="paramname">path</td><td>URL path of the endpoint connected to (string) </td></tr>
    <tr><td class="paramname">action</td><td>SOAP Action or NULL (string) </td></tr>
    <tr><td class="paramname">count</td><td>HTTP content-length or 0 for HTTP chunked transfers (size_t) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code><a class="el" href="group__group__errors.html#ga3b10a68f354f39cbb0fe0d043ad4c7c0" title="The soap_status code for no error (zero) ">SOAP_OK</a></code> or a <code><a class="el" href="group__group__errors.html#gac0eadf8f72bacb5b41b750beaeca0444" title="Status and error codes are int values, a zero value or SOAP_OK (0) means no error, nonzero means error. ">soap_status</a></code> error code </dd></dl>

</div>
</div>
<a class="anchor" id="gab836b5b06024279f4ee190e69d7ccf75"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* soap::fposthdr) (struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, const char *key, const char *val)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback that sends a single HTTP header given a key-value pair. </p>
<p>This callback is called by <code><a class="el" href="group__group__callbacks.html#ga78d2b5440b33d3882b595ca8cfdec425" title="Callback that populates and then sends HTTP headers from the client-side to a connected HTTP server...">soap::fpost</a></code> and <code><a class="el" href="group__group__callbacks.html#ga3d8e8e2b7ad7f1ac995c287b3a9f67a9" title="Callback that populates and then sends HTTP headers from the server-side to a connected client...">soap::fresponse</a></code> to send an HTTP header with a key and an optional value. Returns <code><a class="el" href="group__group__errors.html#ga3b10a68f354f39cbb0fe0d043ad4c7c0" title="The soap_status code for no error (zero) ">SOAP_OK</a></code> or a <code><a class="el" href="group__group__errors.html#gac0eadf8f72bacb5b41b750beaeca0444" title="Status and error codes are int values, a zero value or SOAP_OK (0) means no error, nonzero means error. ">soap_status</a></code> (int) error code. The built-in function assigned to <code><a class="el" href="group__group__callbacks.html#gab836b5b06024279f4ee190e69d7ccf75" title="Callback that sends a single HTTP header given a key-value pair. ">soap::fposthdr</a></code> is <code>http_post_header</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td><code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context </td></tr>
    <tr><td class="paramname">key</td><td>HTTP header key (string) </td></tr>
    <tr><td class="paramname">val</td><td>optional HTTP header value (string), omitted when NULL </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code><a class="el" href="group__group__errors.html#ga3b10a68f354f39cbb0fe0d043ad4c7c0" title="The soap_status code for no error (zero) ">SOAP_OK</a></code> or a <code><a class="el" href="group__group__errors.html#gac0eadf8f72bacb5b41b750beaeca0444" title="Status and error codes are int values, a zero value or SOAP_OK (0) means no error, nonzero means error. ">soap_status</a></code> error code </dd></dl>

</div>
</div>
<a class="anchor" id="gaf263ffe14d8c2508ce4c734d4f33a854"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* soap::fput) (struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback to implement logic at the server-side to serve responses to HTTP PUT requests from clients. </p>
<p>This callback is called by the service dispatcher when an HTTP PUT request is pending. Redefine this callback to respond to HTTP PUT requests, see the <code><a class="el" href="group__group__io.html#ga4c08d5ef28bc0dc37eee4633acdd1140" title="The HTTP POST plugin registration function. ">http_post</a></code> HTTP POST plugin for more details. Returns <code><a class="el" href="group__group__errors.html#ga3b10a68f354f39cbb0fe0d043ad4c7c0" title="The soap_status code for no error (zero) ">SOAP_OK</a></code> or a <code><a class="el" href="group__group__errors.html#gac0eadf8f72bacb5b41b750beaeca0444" title="Status and error codes are int values, a zero value or SOAP_OK (0) means no error, nonzero means error. ">soap_status</a></code> error code. The built-in function assigned to <code><a class="el" href="group__group__callbacks.html#gaf263ffe14d8c2508ce4c734d4f33a854" title="Callback to implement logic at the server-side to serve responses to HTTP PUT requests from clients...">soap::fput</a></code> is the internal static function <code>http_put</code> that returns the <code><a class="el" href="group__group__errors.html#gad8fb6bd54608a32e89ddef0b33575bb5" title="A soap_status error code: an HTTP PUT request was received by the service but the PUT request callbac...">SOAP_PUT_METHOD</a></code> error.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__group__io.html#ga4c08d5ef28bc0dc37eee4633acdd1140" title="The HTTP POST plugin registration function. ">http_post</a></code>, <code><a class="el" href="structsoap.html#a8eb35c04359a567c0b5e2664f3f94d5b" title="User-definable variable that may point to user-specified data of any type to pass the data through to...">soap::user</a></code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td><code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code><a class="el" href="group__group__errors.html#ga3b10a68f354f39cbb0fe0d043ad4c7c0" title="The soap_status code for no error (zero) ">SOAP_OK</a></code> or a <code><a class="el" href="group__group__errors.html#gac0eadf8f72bacb5b41b750beaeca0444" title="Status and error codes are int values, a zero value or SOAP_OK (0) means no error, nonzero means error. ">soap_status</a></code> error code </dd></dl>

</div>
</div>
<a class="anchor" id="ga0c218cd5552045745cc640998e25ed72"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t(* soap::frecv) (struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, char *buf, size_t len)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback that receives bytes of data into the given buffer. </p>
<p>This callback is called by the engine to receive (or read) data into a specified buffer <code>buf</code> and <code>len</code>. The source for the data to read by this callback is <code><a class="el" href="structsoap.html#a285e8a3584ffb1cea07a700c951e436d" title="The source to read data from when non-NULL, which in C++ is a std::istream object and in C is a 0-ter...">soap::is</a></code> when non-NULL, <code><a class="el" href="structsoap.html#a1579bd8bd106afc9a906a673ca473046" title="The socket set by soap_accept (or the C++ service class accept method) or soap_connect or soap_connec...">soap::socket</a></code> when valid, or <code><a class="el" href="structsoap.html#a192c25cc206668600212fd34f6541f34" title="The file descriptor to read data from when no socket communications are set (soap::socket == SOAP_INV...">soap::recvfd</a></code>. Returns <code><a class="el" href="group__group__errors.html#ga3b10a68f354f39cbb0fe0d043ad4c7c0" title="The soap_status code for no error (zero) ">SOAP_OK</a></code> or a <code><a class="el" href="group__group__errors.html#gac0eadf8f72bacb5b41b750beaeca0444" title="Status and error codes are int values, a zero value or SOAP_OK (0) means no error, nonzero means error. ">soap_status</a></code> (int) error code. The built-in function assigned to <code><a class="el" href="group__group__callbacks.html#ga0c218cd5552045745cc640998e25ed72" title="Callback that receives bytes of data into the given buffer. ">soap::frecv</a></code> is <code>frecv</code>.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="structsoap.html#a8eb35c04359a567c0b5e2664f3f94d5b" title="User-definable variable that may point to user-specified data of any type to pass the data through to...">soap::user</a></code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td><code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context </td></tr>
    <tr><td class="paramname">buf</td><td>buffer to fill with bytes to be read (string) </td></tr>
    <tr><td class="paramname">len</td><td>maximum size of the buffer (size_t) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the nonzero number of bytes that were placed in the buffer or 0 to indicate EOF was reached (size_t) </dd></dl>

</div>
</div>
<a class="anchor" id="ga0ae800fa60c5e65a867e5d0e3ce7223e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* soap::fresolve) (struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, const char *name, struct in_addr *inaddr)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback that resolves a host name by address translation. </p>
<p>This callback is called by <code><a class="el" href="group__group__io.html#ga0a9725a3edbc27b97456190fee47cc18" title="Bind and listen to a port. ">soap_bind</a></code> (or the C++ service class <code>bind</code> method) at the server-side and by <code><a class="el" href="group__group__io.html#ga5c87e9d0a43fe18cc349c724f198f64a" title="Connect to a server using HTTP POST. ">soap_connect</a></code> or <code><a class="el" href="group__group__io.html#ga315b6e1d5888780bf4ef320c50f23796" title="Connect to a server. ">soap_connect_command</a></code> at the client-side with a host <code>name</code> parameter to resolve to address <code>inaddr</code> by address translation. When successful sets parameter <code>inaddr</code> and returns <code><a class="el" href="group__group__errors.html#ga3b10a68f354f39cbb0fe0d043ad4c7c0" title="The soap_status code for no error (zero) ">SOAP_OK</a></code> or a <code><a class="el" href="group__group__errors.html#gac0eadf8f72bacb5b41b750beaeca0444" title="Status and error codes are int values, a zero value or SOAP_OK (0) means no error, nonzero means error. ">soap_status</a></code> (int) error code. The built-in function assigned to <code><a class="el" href="group__group__callbacks.html#ga0ae800fa60c5e65a867e5d0e3ce7223e" title="Callback that resolves a host name by address translation. ">soap::fresolve</a></code> is <code>tcp_gethost</code>.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="structsoap.html#a8eb35c04359a567c0b5e2664f3f94d5b" title="User-definable variable that may point to user-specified data of any type to pass the data through to...">soap::user</a></code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td><code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context </td></tr>
    <tr><td class="paramname">name</td><td>host name (string) </td></tr>
    <tr><td class="paramname">inaddr</td><td>points to in_addr structure to set </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code><a class="el" href="group__group__errors.html#ga3b10a68f354f39cbb0fe0d043ad4c7c0" title="The soap_status code for no error (zero) ">SOAP_OK</a></code> or a <code><a class="el" href="group__group__errors.html#gac0eadf8f72bacb5b41b750beaeca0444" title="Status and error codes are int values, a zero value or SOAP_OK (0) means no error, nonzero means error. ">soap_status</a></code> error code </dd></dl>

</div>
</div>
<a class="anchor" id="ga3d8e8e2b7ad7f1ac995c287b3a9f67a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* soap::fresponse) (struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, int status, <a class="el" href="group__group__soap.html#ga7c6e38d209f60a18e362172dca1a3b6e">ULONG64</a> count)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback that populates and then sends HTTP headers from the server-side to a connected client. </p>
<p>This callback is called at the server side by the engine to send the HTTP headers to the connected client. The parameter <code>status</code> should be an HTTP status error code or <code><a class="el" href="group__group__errors.html#ga3b10a68f354f39cbb0fe0d043ad4c7c0" title="The soap_status code for no error (zero) ">SOAP_OK</a></code> (200 OK) or <code><a class="el" href="group__group__io.html#ga17cdc287dd916e5d2b3467ccec177d5a" title="A special soap_status error code to signal that a custom HTTP response is present and no HTTP respons...">SOAP_HTML</a></code> or <code><a class="el" href="group__group__io.html#ga05be99343f556fe70940145e874cdb99" title="A special soap_status error code to signal that a custom file-based HTTP response is present and no H...">SOAP_FILE</a></code>. Using <code><a class="el" href="group__group__io.html#ga17cdc287dd916e5d2b3467ccec177d5a" title="A special soap_status error code to signal that a custom HTTP response is present and no HTTP respons...">SOAP_HTML</a></code> sets the content-type header to <code>text/html; charset=utf-8</code>. Using <code><a class="el" href="group__group__io.html#ga05be99343f556fe70940145e874cdb99" title="A special soap_status error code to signal that a custom file-based HTTP response is present and no H...">SOAP_FILE</a></code> sets the content-type header to the value of <code><a class="el" href="structsoap.html#ae5e98733a4349b5e1466a9e0ccc22c11" title="String with HTTP content type header value received, can also be assigned to specify a content type h...">soap::http_content</a></code>. Extra HTTP headers are added when <code><a class="el" href="structsoap.html#afb22ae0a494a35268914286bd00446ab" title="User-definable string that specifies an extra HTTP header or headers when separated by CRLF...">soap::http_extra_header</a></code> is set to one or more header lines separated by CRLF. When redefining this callback, use function <code><a class="el" href="group__group__io.html#ga7712f5bc36127050a11ad995d0593bdc" title="Send a string. ">soap_send</a></code> to write the header contents. Returns <code><a class="el" href="group__group__errors.html#ga3b10a68f354f39cbb0fe0d043ad4c7c0" title="The soap_status code for no error (zero) ">SOAP_OK</a></code> or a <code><a class="el" href="group__group__errors.html#gac0eadf8f72bacb5b41b750beaeca0444" title="Status and error codes are int values, a zero value or SOAP_OK (0) means no error, nonzero means error. ">soap_status</a></code> error code. The built-in function assigned to <code><a class="el" href="group__group__callbacks.html#ga3d8e8e2b7ad7f1ac995c287b3a9f67a9" title="Callback that populates and then sends HTTP headers from the server-side to a connected client...">soap::fresponse</a></code> is <code>http_response</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td><code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context </td></tr>
    <tr><td class="paramname">status</td><td>HTTP status code (&gt; 100) or <code><a class="el" href="group__group__errors.html#ga3b10a68f354f39cbb0fe0d043ad4c7c0" title="The soap_status code for no error (zero) ">SOAP_OK</a></code> (200 OK), or <code><a class="el" href="group__group__io.html#ga17cdc287dd916e5d2b3467ccec177d5a" title="A special soap_status error code to signal that a custom HTTP response is present and no HTTP respons...">SOAP_HTML</a></code> or <code><a class="el" href="group__group__io.html#ga05be99343f556fe70940145e874cdb99" title="A special soap_status error code to signal that a custom file-based HTTP response is present and no H...">SOAP_FILE</a></code> </td></tr>
    <tr><td class="paramname">count</td><td>HTTP content-length or 0 for HTTP chunked transfers </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code><a class="el" href="group__group__errors.html#ga3b10a68f354f39cbb0fe0d043ad4c7c0" title="The soap_status code for no error (zero) ">SOAP_OK</a></code> or a <code><a class="el" href="group__group__errors.html#gac0eadf8f72bacb5b41b750beaeca0444" title="Status and error codes are int values, a zero value or SOAP_OK (0) means no error, nonzero means error. ">soap_status</a></code> error code </dd></dl>

</div>
</div>
<a class="anchor" id="gafd52b80655e4f1021edd6c55b8dfedff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* soap::fsend) (struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, const char *data, size_t len)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback that sends the given bytes of data. </p>
<p>This callback is called by the engine to send (or write) data specified by <code>data</code> bytes of length <code>len</code>. The sink for the data to be sent to is typically <code><a class="el" href="structsoap.html#a1579bd8bd106afc9a906a673ca473046" title="The socket set by soap_accept (or the C++ service class accept method) or soap_connect or soap_connec...">soap::socket</a></code>, <code><a class="el" href="structsoap.html#a200d71a901cdc5c9aa02140e9d2369b9" title="The file descriptor to write data to when no socket communications are set (soap::socket == SOAP_INVA...">soap::sendfd</a></code> or <code><a class="el" href="structsoap.html#a27b166e404c7c98cfa45d6d7a5da90c0" title="The sink to write data to when non-NULL, which in C++ is a std::ostream object and in C is a pointer ...">soap::os</a></code>. Returns <code><a class="el" href="group__group__errors.html#ga3b10a68f354f39cbb0fe0d043ad4c7c0" title="The soap_status code for no error (zero) ">SOAP_OK</a></code> or a <code><a class="el" href="group__group__errors.html#gac0eadf8f72bacb5b41b750beaeca0444" title="Status and error codes are int values, a zero value or SOAP_OK (0) means no error, nonzero means error. ">soap_status</a></code> (int) error code. The built-in function assigned to <code><a class="el" href="group__group__callbacks.html#gafd52b80655e4f1021edd6c55b8dfedff" title="Callback that sends the given bytes of data. ">soap::fsend</a></code> is <code>fsend</code>.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="structsoap.html#a8eb35c04359a567c0b5e2664f3f94d5b" title="User-definable variable that may point to user-specified data of any type to pass the data through to...">soap::user</a></code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td><code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context </td></tr>
    <tr><td class="paramname">data</td><td>bytes to be send (string) </td></tr>
    <tr><td class="paramname">len</td><td>number of bytes to be send (size_t) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code><a class="el" href="group__group__errors.html#ga3b10a68f354f39cbb0fe0d043ad4c7c0" title="The soap_status code for no error (zero) ">SOAP_OK</a></code> or a <code><a class="el" href="group__group__errors.html#gac0eadf8f72bacb5b41b750beaeca0444" title="Status and error codes are int values, a zero value or SOAP_OK (0) means no error, nonzero means error. ">soap_status</a></code> error code </dd></dl>

</div>
</div>
<a class="anchor" id="ga76024ad8bab31b591432a5dbdcf3a0a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* soap::fserveloop) (struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback executed by the engine at the server side immediately after a server operation successfully completed. </p>
<p>This callback is called after each successful completion of a server operation in the server loop. Executes immediately after sending the response to a client and before the next keep-alive server loop iteration when enabled with <code><a class="el" href="group__group__flags.html#ga0a4635737732c912058ff4dba668c1b2" title="soap_mode IO input and output flag value to keep the socket connection alive for SOAP_MAXKEEPALIVE me...">SOAP_IO_KEEPALIVE</a></code>. This callback can be used to reclaim resources in the keep-alive server loop, for example managed memory can be reclaimed by calling <code><a class="el" href="group__group__context.html#gaf7d0176161e9def36981e24faa1913d9" title="Delete all dynamically-allocated C++ objects managed by the specified soap context. ">soap_destroy</a></code> and <code><a class="el" href="group__group__context.html#ga81a009ae1ea825a05e5241e2b7a8ece9" title="Delete all data from heap memory managed by the specified soap context and release the freed memory b...">soap_end</a></code> in that order and all deserialized and other dynamically-allocated data managed by the context will be deallocated. Returns <code><a class="el" href="group__group__errors.html#ga3b10a68f354f39cbb0fe0d043ad4c7c0" title="The soap_status code for no error (zero) ">SOAP_OK</a></code> or a <code><a class="el" href="group__group__errors.html#gac0eadf8f72bacb5b41b750beaeca0444" title="Status and error codes are int values, a zero value or SOAP_OK (0) means no error, nonzero means error. ">soap_status</a></code> (int) error code. No built-in function is assigned to <code><a class="el" href="group__group__callbacks.html#ga76024ad8bab31b591432a5dbdcf3a0a4" title="Callback executed by the engine at the server side immediately after a server operation successfully ...">soap::fserveloop</a></code>.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="structsoap.html#a8eb35c04359a567c0b5e2664f3f94d5b" title="User-definable variable that may point to user-specified data of any type to pass the data through to...">soap::user</a></code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td><code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code><a class="el" href="group__group__errors.html#ga3b10a68f354f39cbb0fe0d043ad4c7c0" title="The soap_status code for no error (zero) ">SOAP_OK</a></code> or a <code><a class="el" href="group__group__errors.html#gac0eadf8f72bacb5b41b750beaeca0444" title="Status and error codes are int values, a zero value or SOAP_OK (0) means no error, nonzero means error. ">soap_status</a></code> error code </dd></dl>

</div>
</div>
<a class="anchor" id="ga4523d86587b4181a138850b92498f5b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* soap::fseterror) (struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, const char **faultcode, const char **faultstring)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback to inspect or override fault code or fault string messages. </p>
<p>This callback is called by the engine when an error is raised to allow inspection or overriding of the fault code or fault string messages before the error is reported or transmitted. No built-in function is assigned to <code><a class="el" href="group__group__callbacks.html#ga4523d86587b4181a138850b92498f5b7" title="Callback to inspect or override fault code or fault string messages. ">soap::fseterror</a></code>.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="structsoap.html#a8eb35c04359a567c0b5e2664f3f94d5b" title="User-definable variable that may point to user-specified data of any type to pass the data through to...">soap::user</a></code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td><code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context </td></tr>
    <tr><td class="paramname">faultcode</td><td>pointer to a string with the fault code message or NULL, can be reassigned </td></tr>
    <tr><td class="paramname">faultstring</td><td>pointer to a string with the fault string message or NULL, can be reassigned </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga51e09ddf769a2ddcd874fb6e6fb5289d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* soap::fshutdownsocket) (struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, <a class="el" href="group__group__soap.html#ga6eb1bde7cecc2fbadbcbbc6395227439">SOAP_SOCKET</a> sock, int how)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback that shuts down a given socket. </p>
<p>This callback is called to shut down a socket by the engine. Returns <code><a class="el" href="group__group__errors.html#ga3b10a68f354f39cbb0fe0d043ad4c7c0" title="The soap_status code for no error (zero) ">SOAP_OK</a></code> or a <code><a class="el" href="group__group__errors.html#gac0eadf8f72bacb5b41b750beaeca0444" title="Status and error codes are int values, a zero value or SOAP_OK (0) means no error, nonzero means error. ">soap_status</a></code> (int) error code. The built-in function assigned to <code><a class="el" href="group__group__callbacks.html#ga51e09ddf769a2ddcd874fb6e6fb5289d" title="Callback that shuts down a given socket. ">soap::fshutdownsocket</a></code> is <code>tcp_shutdownsocket</code>.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="structsoap.html#a8eb35c04359a567c0b5e2664f3f94d5b" title="User-definable variable that may point to user-specified data of any type to pass the data through to...">soap::user</a></code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td><code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context </td></tr>
    <tr><td class="paramname">sock</td><td>socket to shut down </td></tr>
    <tr><td class="paramname">how</td><td><code>SHUT_RD</code> (=0), <code>SHUT_WR</code> (=1) or <code>SHUT_RDWR</code> (=2) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code><a class="el" href="group__group__errors.html#ga3b10a68f354f39cbb0fe0d043ad4c7c0" title="The soap_status code for no error (zero) ">SOAP_OK</a></code> or a <code><a class="el" href="group__group__errors.html#gac0eadf8f72bacb5b41b750beaeca0444" title="Status and error codes are int values, a zero value or SOAP_OK (0) means no error, nonzero means error. ">soap_status</a></code> error code </dd></dl>

</div>
</div>
<a class="anchor" id="gaec56697005ded17d4d19705013f908ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* soap::fsslauth) (struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback to initialize the OpenSSL library. </p>
<p>This callback is called to initialize the OpenSSL, GNUTLS, or WolfSSL context for HTTPS connections configured with the parameters passed to <code><a class="el" href="group__group__ssl.html#ga269c7732b1cda9dc79db08fcbf1d5438" title="Initialize the client-side SSL/TLS context. ">soap_ssl_client_context</a></code> and <code><a class="el" href="group__group__ssl.html#ga3492465cdd8aa71fe746199d3842cac7" title="Initialize the server-side SSL/TLS context. ">soap_ssl_server_context</a></code>. Returns <code><a class="el" href="group__group__errors.html#ga3b10a68f354f39cbb0fe0d043ad4c7c0" title="The soap_status code for no error (zero) ">SOAP_OK</a></code> or a <code><a class="el" href="group__group__errors.html#gac0eadf8f72bacb5b41b750beaeca0444" title="Status and error codes are int values, a zero value or SOAP_OK (0) means no error, nonzero means error. ">soap_status</a></code> (int) error code. The built-in function assigned to <code><a class="el" href="group__group__callbacks.html#gaec56697005ded17d4d19705013f908ee" title="Callback to initialize the OpenSSL library. ">soap::fsslauth</a></code> is <code>ssl_auth_init</code>.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="structsoap.html#a8eb35c04359a567c0b5e2664f3f94d5b" title="User-definable variable that may point to user-specified data of any type to pass the data through to...">soap::user</a></code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td><code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code><a class="el" href="group__group__errors.html#ga3b10a68f354f39cbb0fe0d043ad4c7c0" title="The soap_status code for no error (zero) ">SOAP_OK</a></code> or a <code><a class="el" href="group__group__errors.html#gac0eadf8f72bacb5b41b750beaeca0444" title="Status and error codes are int values, a zero value or SOAP_OK (0) means no error, nonzero means error. ">soap_status</a></code> error code </dd></dl>

</div>
</div>
<a class="anchor" id="ga49fee9ca4a78f9a681afbdfbc0194bf0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* soap::fsslverify) (int ok, X509_STORE_CTX *store)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback to manage the verification of the certificate provided by a peer (typically a server) </p>
<p>This callback is called by the engine to manage the verification of the certificate provided by a peer, such as the certificate provided by a server connected over HTTPS or to verify the certificate included with a WS-Security message. To require certificate verification of a server connected via HTTPS, use <code><a class="el" href="group__group__ssl.html#ga269c7732b1cda9dc79db08fcbf1d5438" title="Initialize the client-side SSL/TLS context. ">soap_ssl_client_context</a></code> with <code><a class="el" href="group__group__ssl.html#ga8c9f87b34ff34020349d4fe7300c47bc" title="soap_ssl_flags flag for clients to require servers to authenticate to clients during the HTTPS handsh...">SOAP_SSL_REQUIRE_SERVER_AUTHENTICATION</a></code>. To require certificate verification of a client connected to a server, use <code><a class="el" href="group__group__ssl.html#ga3492465cdd8aa71fe746199d3842cac7" title="Initialize the server-side SSL/TLS context. ">soap_ssl_server_context</a></code> with <code><a class="el" href="group__group__ssl.html#ga4ab5e7f3fbb00fa2669e29e9ca000d12" title="soap_ssl_flags flag for servers to require clients to authenticate to servers during the HTTPS handsh...">SOAP_SSL_REQUIRE_CLIENT_AUTHENTICATION</a></code>. The <code>ok</code> parameter of this callback indicates whether the verification of the certificate in question passed (<code>ok</code> == 1) or failed (<code>ok</code> == 0) as determined by the OpenSSL library based on the <code><a class="el" href="group__group__ssl.html#ga269c7732b1cda9dc79db08fcbf1d5438" title="Initialize the client-side SSL/TLS context. ">soap_ssl_client_context</a></code> or <code><a class="el" href="group__group__ssl.html#ga3492465cdd8aa71fe746199d3842cac7" title="Initialize the server-side SSL/TLS context. ">soap_ssl_server_context</a></code> configuration. If the callback returns 1 then the handshake is continued and the connection maybe established. To return 1 when <code>ok</code> == 0 requires resetting the error state with <code>X509_STORE_CTX_set_error(store, X509_V_OK)</code>. If the callback returns 0 then the handshake is immediately terminated with "verification failed" and a verification failure alert is sent to the peer. The built-in function assigned to <code><a class="el" href="group__group__callbacks.html#ga49fee9ca4a78f9a681afbdfbc0194bf0" title="Callback to manage the verification of the certificate provided by a peer (typically a server) ...">soap::fsslverify</a></code> is <code>ssl_verify_callback</code> or when <code><a class="el" href="group__group__ssl.html#gaa78c27c03ccd2fb47afda6b83a3fd01c" title="soap_ssl_flags flag value to allow self-signed and expired certificates and those without CRL to be u...">SOAP_SSL_ALLOW_EXPIRED_CERTIFICATE</a></code> is used <code>ssl_verify_callback_allow_expired_certificate</code>.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="structsoap.html#a8eb35c04359a567c0b5e2664f3f94d5b" title="User-definable variable that may point to user-specified data of any type to pass the data through to...">soap::user</a></code>.</dd></dl>
<dl class="section user"><dt>Example:</dt><dd></dd></dl>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> ssl_verify_callback_allow_self_signed_cert(<span class="keywordtype">int</span> ok, X509_STORE_CTX *store)</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> (!ok &amp;&amp; X509_STORE_CTX_get_error(store) == X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN)</div><div class="line">  {</div><div class="line">    X509_STORE_CTX_set_error(store, X509_V_OK);</div><div class="line">    ok = 1;</div><div class="line">  }</div><div class="line">  <span class="keywordflow">return</span> ok;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">struct </span>soap *soap = <a class="code" href="group__group__context.html#ga87c20488b2dc680aaa7689b1d024989c">soap_new</a>();</div><div class="line">soap-&gt;<a class="code" href="group__group__callbacks.html#ga49fee9ca4a78f9a681afbdfbc0194bf0">fsslverify</a> = ssl_verify_callback_allow_self_signed_cert;</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ok</td><td>when 1: the certificate passed, when 0: the certificate did not pass </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 to pass and 0 to fail</dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__group__ssl.html#ga269c7732b1cda9dc79db08fcbf1d5438" title="Initialize the client-side SSL/TLS context. ">soap_ssl_client_context</a></code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6a5e29b860d28f855c8d9a67c096d311"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* soap::fsvalidate) (struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, const char *pattern, const char *string)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback to validate strings against XML regex patterns. </p>
<p>This callback is called to validate a string against an XML regex pattern. Patterns use XML schema regex syntax. This callback allows user-defined pattern validation that is normally disabled. Returns <code><a class="el" href="group__group__errors.html#ga3b10a68f354f39cbb0fe0d043ad4c7c0" title="The soap_status code for no error (zero) ">SOAP_OK</a></code> when the string matches the pattern or <code><a class="el" href="group__group__errors.html#gafea66c256bdaa8376e12106e36307c02" title="A soap_status error code: XML element or attribute has a mismatching type or value that is causing a ...">SOAP_TYPE</a></code> when the string does not match. No built-in function is assigned to <code><a class="el" href="group__group__callbacks.html#ga6a5e29b860d28f855c8d9a67c096d311" title="Callback to validate strings against XML regex patterns. ">soap::fsvalidate</a></code>.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__group__callbacks.html#ga1a38366b5b84730713c45ccada84e3ca" title="Callback to validate wide strings against XML regex patterns. ">soap::fwvalidate</a></code>,<code><a class="el" href="structsoap.html#a8eb35c04359a567c0b5e2664f3f94d5b" title="User-definable variable that may point to user-specified data of any type to pass the data through to...">soap::user</a></code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td><code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context </td></tr>
    <tr><td class="paramname">pattern</td><td>regex in XML schema syntax </td></tr>
    <tr><td class="paramname">string</td><td>to match pattern against </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code><a class="el" href="group__group__errors.html#ga3b10a68f354f39cbb0fe0d043ad4c7c0" title="The soap_status code for no error (zero) ">SOAP_OK</a></code> (match) or <code><a class="el" href="group__group__errors.html#gafea66c256bdaa8376e12106e36307c02" title="A soap_status error code: XML element or attribute has a mismatching type or value that is causing a ...">SOAP_TYPE</a></code> (mismatch) or a <code><a class="el" href="group__group__errors.html#gac0eadf8f72bacb5b41b750beaeca0444" title="Status and error codes are int values, a zero value or SOAP_OK (0) means no error, nonzero means error. ">soap_status</a></code> error code </dd></dl>

</div>
</div>
<a class="anchor" id="ga1a38366b5b84730713c45ccada84e3ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* soap::fwvalidate) (struct <a class="el" href="structsoap.html">soap</a> *<a class="el" href="structsoap.html">soap</a>, const char *pattern, const wchar_t *string)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback to validate wide strings against XML regex patterns. </p>
<p>This callback is called to validate a wide string against an XML regex pattern. Patterns use XML schema regex syntax. This callback allows user-defined pattern validation that is normally disabled. Returns <code><a class="el" href="group__group__errors.html#ga3b10a68f354f39cbb0fe0d043ad4c7c0" title="The soap_status code for no error (zero) ">SOAP_OK</a></code> when the string matches the pattern or <code><a class="el" href="group__group__errors.html#gafea66c256bdaa8376e12106e36307c02" title="A soap_status error code: XML element or attribute has a mismatching type or value that is causing a ...">SOAP_TYPE</a></code> when the string does not match. No built-in function is assigned to <code><a class="el" href="group__group__callbacks.html#ga1a38366b5b84730713c45ccada84e3ca" title="Callback to validate wide strings against XML regex patterns. ">soap::fwvalidate</a></code>.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__group__callbacks.html#ga6a5e29b860d28f855c8d9a67c096d311" title="Callback to validate strings against XML regex patterns. ">soap::fsvalidate</a></code>, <code><a class="el" href="structsoap.html#a8eb35c04359a567c0b5e2664f3f94d5b" title="User-definable variable that may point to user-specified data of any type to pass the data through to...">soap::user</a></code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td><code><a class="el" href="structsoap.html" title="Context with the engine state. ">soap</a></code> context </td></tr>
    <tr><td class="paramname">pattern</td><td>regex in XML schema syntax </td></tr>
    <tr><td class="paramname">string</td><td>to match pattern against </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code><a class="el" href="group__group__errors.html#ga3b10a68f354f39cbb0fe0d043ad4c7c0" title="The soap_status code for no error (zero) ">SOAP_OK</a></code> (match) or <code><a class="el" href="group__group__errors.html#gafea66c256bdaa8376e12106e36307c02" title="A soap_status error code: XML element or attribute has a mismatching type or value that is causing a ...">SOAP_TYPE</a></code> (mismatch) or a <code><a class="el" href="group__group__errors.html#gac0eadf8f72bacb5b41b750beaeca0444" title="Status and error codes are int values, a zero value or SOAP_OK (0) means no error, nonzero means error. ">soap_status</a></code> error code </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<hr class="footer">
<address class="footer">
Copyright (C) 2023, Robert van Engelen, Genivia Inc., All Rights Reserved.
</address>
<address class="footer"><small>
Converted on Wed Mar 22 2023 12:01:20 by <a target="_blank" href="http://www.doxygen.org/index.html">Doxygen</a> 1.8.11</small></address>
<br>
<div style="height: 246px; background: #DBDBDB;">
</body>
</html>
