<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8">
<meta http-equiv="cache-control" content="no-cache">
<title>Genivia - guide.md Source File</title>
<link href="genivia_tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="genivia_content.css" rel="stylesheet" type="text/css">
</head>
<body>
<div id="top">
 <div id="titlearea">
  <table height="72px" width="100%" cellspacing="0" cellpadding="0">
   <tbody>
    <tr>
     <td width="10%">&nbsp;</td>
     <td width="175px"><a href="https://www.genivia.com"><img alt="Genivia" src="GeniviaLogo2_trans_noslogan.png"/></a></td>
     <td class="tab_home"><a href="https://www.genivia.com">Home</a></td>
     <td class="tab_home"><a href="https://www.genivia.com/docs.html">Documentation</a></td>
     <td>
      <div style="float: right; font-size: 18px; font-weight: bold;">guide.md Source File</div>
      <br>
      <div style="float: right; font-size: 10px;">updated Tue Jul 4 2017 by Robert van Engelen</div>
     </td>
     <td width="10%">&nbsp;</td>
    </tr>
   </tbody>
  </table>
 </div>
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('guide_8md.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">guide.md</div>  </div>
</div><!--header-->
<div class="contents">
<a href="guide_8md.html">Go to the documentation of this file.</a><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;gSOAP user guide                                                    {#mainpage}</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;================</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;[TOC]</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;# Introduction                                                         {#intro}</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;The gSOAP tools provide an automated SOAP and XML data binding for C and C++</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;based on compiler technologies.  The tools simplify the development of SOAP/XML</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;Web services and XML application in C and C++ using autocode generation and</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;advanced mapping methods. Most toolkits for Web services adopt a</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;WSDL/SOAP-centric view and offer APIs that require the use of class libraries</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;for XML-specific data structures. This forces a user to adapt the application</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;logic to these libraries because users have to write code to populate XML and</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;extract data from XML using a vendor-specific API. This often leads to fragile</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;solutions with little or no assurances for data consistency, type safety, and</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;XML validation. By contrast, gSOAP provides a type-safe and transparent</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;solution through the use of compiler technology that hides irrelevant WSDL-,</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;SOAP-, REST-, and XML-specific protocol details from the user, while</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;automatically ensuring XML validity checking, memory management, and type-safe</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;serialization. The gSOAP tools automatically map native and user-defined C and</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;C++ data types to semantically equivalent XML data types and vice-versa.  As a</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;result, full SOAP/REST XML interoperability is achieved with a simple API</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;relieving the user from the burden of WSDL/SOAP/XML details, thus enabling him</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;or her to concentrate on the application-essential logic.</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;The gSOAP tools support the integration of (legacy) C/C++ codes (and other</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;programming languages when a C interface is available), embedded systems, and</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;real-time software in SOAP/XML  applications that share computational resources</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;and information with other SOAP applications, possibly across different</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;platforms, language environments, and disparate organizations located behind</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;firewalls.</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;The gSOAP tools are also popular to implement XML data binding in C and C++.</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;This means that application-native data structures can be encoded in XML</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;automatically, without the need to write conversion code. The tools also</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;produce XML schemas for the XML data binding, so external applications can</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;consume the XML data based on the schemas.</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;üîù [Back to table of contents](#)</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;# Getting Started                                                      {#start}</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;To start building Web services applications or automate XML data bindings with</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;gSOAP, you will need:</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;* The gSOAP software from &lt;https://www.genivia.com/Products/downloads.html&gt; and</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;  select the gSOAP toolkit commercial edition, or download the GPL open source</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;  version from SourceForge &lt;https://sourceforge.net/projects/gsoap2&gt;.</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;* A C or C++ compiler.</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;* You may want to install OpenSSL and the Zlib libraries to enable SSL (HTTPS)</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;  and compression. These libraries are available for most platforms and are</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;  often already installed.</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;The gSOAP software is self-contained, so there is no need to download any</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;third-party software, except when you want to use OpenSSL for HTTPS and/or Zlib</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;compression.</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;The gSOAP distribution package includes:</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;*  The `wsdl2h` WSDL/schema converter and data binding tool.</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;*  The `soapcpp2` stub/skeleton compiler and code generator.</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;Binaries of these two tools are included in the gSOAP package in `gsoap/bin`</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;for Windows and Mac OS plarforms, see also the README files in the package for</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;more details.</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;Although gSOAP tools are available in binary format for several platforms, the</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;code generated by these tools are all equivalent. This means that the generated</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;source codes can be transferred to other platforms and locally compiled.</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;If you don&#39;t have the binaries or if you want to rebuild them, you need</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;*  Bison (or Yacc) to build `soapcpp2`.</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;*  Flex (or Lex) to build `soapcpp2`.</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;*  A C++ compiler to build `wsdl2h`.</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;Bison and Flex are preferred. Both are released under open source licenses that</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;are compatible with gSOAP&#39;s licenses:</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;*  Bison is available from &lt;http://www.gnu.org/software/bison&gt;</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;*  Flex is available from &lt;http://flex.sourceforge.net&gt;</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;You can also build `soapcpp2` without Bison and Flex installed, see</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;installation instructions on the gSOAP web site.</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;The gSOAP engine is built as a library `libgsoap.a` and `libgsoap++.a` with</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;separate versions of these two `libgsoapssl.a` and `libgsoapssl++.a` that</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;support SSL. See the `README.txt` instructions on how to build these libraries</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;with the platform-independent gSOAP package&#39;s autoconf and automake.</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;Alternatively, you can compile and link the engine&#39;s source code `stdsoap2.c`</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;(or `stdsoap2.cpp` for C++) directly with your code.</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;The gSOAP packages contain numerous examples in the `samples` directory.  Run</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;`make` to build the example applications. The examples are also meant to</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;demonstrate different features of gSOAP.  A streaming MTOM attachment server</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;and client application demonstrate efficient file exchanges in</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;`samples/mtom-stream`. An SSL-secure Web server application demonstrates the</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;generation of dynamic content for Web browsing and Web services functionality</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;at the same time, see `samples/webservice`. And much more.</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;## Creating a client app                                        {#start-client}</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;The gSOAP tools minimize application adaptation efforts for building Web</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;Services by using a XML data binding for C and C++ implemented by advanced XML</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;schema analyzers and source-to-source code generation tools.  The gSOAP</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;`wsdl2h` tool imports one or more WSDLs and XML schemas and generates a gSOAP</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;header file with familiar C/C++ syntax to define the Web service operations and</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;the C/C++ data types. The gSOAP `soapcpp2` compiler then takes this header file</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;and generates XML serializers for the data types (`soapH.h` and `soapC.cpp`),</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;the client-side stubs (`soapClient.cpp`), and server-side skeletons</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;(`soapServer.cpp`).</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;</div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;The gSOAP `soapcpp2` compiler can also generate WSDL definitions for</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;implementing a service from scratch, i.e. without defining a WSDL first. This</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;&quot;closes the loop&quot; in that it enables Web services development from WSDL or</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;directly from a set op C/C++ operations in a header file without the need for</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;users to analyze Web service details.</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;You only need to follow a few steps to execute the tools from the command line</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;or Makefile (see also MSVC++ project examples in the `samples` directory</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;with tool integration in the MSVC++ IDE). For example, to generate code for the</div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;calculator Web service, we run the `wsdl2h` tool from the</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;command line on the URL of the WSDL and use option `-o` to specify the</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;output file:</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;    &gt; wsdl2h -o calc.h http://www.genivia.com/calc.wsdl</div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;</div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;This generates the `calc.h` service definition header file with service</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;operation definitions and types for the operation&#39;s data. This header file is</div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;then to be processed with `soapcpp2` to generate the stub and/or skeleton code</div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;and XML serialization routines. The `calc.h` file includes all documentation,</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;so you can use Doxygen (&lt;http://www.doxygen.org&gt;) to automatically generate the</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;documentation pages for your development.</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;The `wsdl2h`-generated service definitions header file also contains information on the use of the service, such as WS-Policy assertions when applicable.</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;In this example we are developing a C++ API for the calculator service. By</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;default, gSOAP assumes you will use C++ with STL.  To build without STL, use option</div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;`-s`:</div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;</div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;    &gt; wsdl2h -s -o calc.h http://www.genivia.com/calc.wsdl</div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;</div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;To build a pure C application, use option `-c`:</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;</div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;    &gt; wsdl2h -c -o calc.h http://www.genivia.com/calc.wsdl</div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;@note Visual Studio users shopuld make sure to compile all gSOAP</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;source files in C++ compilation mode. If you migrate to a project file</div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;`.vcproj`, please set *`CompileAs=&quot;2&quot;`* in your `.vcproj` file.</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;</div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;We have not yet generated the stubs for the C/C++ API. To do so, run the `soapcpp2` compiler:</div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;</div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;    &gt; soapcpp2 -i -C -Iimport calc.h</div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;</div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;Option `-i` (and alternatively option `-j`) indicates that we want C++ proxy and server objects that</div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;include the client (and server) code, `-C` indicates client-side only files</div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;(`soapcpp2` generates both client and server stubs and skeletons by</div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;default). Option `-I` is needed to import the `stlvector.h` file from the `import` directory in the gSOAP package to support serialization of STL vectors.</div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;</div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;Suppose we develop a C++ client for the calculator service using `wsdl2h -o calc.h http://www.genivia.com/calc.wsdl` and `soapcpp2 -i -C calc.h`.</div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;</div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;We use the generated `soapcalcProxy` class and</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;`calc.nsmap` XML namespace mapping table to access the Web</div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;service. The `soapcalcProxy` class is a proxy to invoke the</div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;service:</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;```cpp</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;#include &quot;soapcalcProxy.h&quot; </div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;#include &quot;calc.nsmap&quot; </div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;int main() </div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;{ </div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;   calcProxy service; </div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;   double result; </div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;   if (service.add(1.0, 2.0, result) == SOAP_OK) </div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;     std::cout &lt;&lt; &quot;The sum of 1.0 and 2.0 is &quot; &lt;&lt; result &lt;&lt; std::endl; </div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;   else </div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;     service.soap_stream_fault(std::cerr); </div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;   service.destroy(); // delete data and release memory </div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;}</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;```</div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;</div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;To complete the build, compile the code above and compile and link this with the generated `soapC.cpp`,</div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;`soapcalcProxy.cpp`, and the run-time gSOAP engine `-lgsoap++` (or use source `stdsoap2.cpp` in case `libgsoap++.a` is not installed) with your code.</div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;</div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;Suppose we develop a client in C using `wsdl2h -c -o calc.h http://www.genivia.com/calc.wsdl` and `soapcpp2 -C calc.h`. In this case our code uses a simple C function call to invoke the service and we also need to explicitly delete data and the context with `soap_end` and `soap_free`:</div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;</div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;```cpp</div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;#include &quot;soapH.h&quot; </div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;#include &quot;calc.nsmap&quot; </div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;int main() </div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;{ </div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;   struct soap *soap = soap_new(); </div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;   double result; </div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;   if (soap_call_ns__add(soap, 1.0, 2.0, &amp;result) == SOAP_OK) </div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;     printf(&quot;The sum of 1.0 and 2.0 is %lg\n&quot;, result); </div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;   else </div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;     soap_print_fault(soap, stderr); </div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;   soap_end(soap); </div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;   soap_free(soap); </div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;}</div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;```</div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;</div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;The calculator example is fairly simple and used here to illustrate the</div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;development process. The development process for large-scale XML applications</div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;is similar. More extensive examples can be found in the `samples` directory</div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;in the gSOAP package.</div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;</div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;## Creating a service app                                      {#start-service}</div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;</div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;Developing a service application is easy too. We will use CGI here because it</div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;is a simple mechanism. This is not the preferred deployment mechanism. Because</div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;CGI is slow and stateless. Faster services can be developed as a stand-alone</div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;gSOAP HTTP/HTTPS server (but see comments at the end of this section) or, as</div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;preferred, the use of Apache module or IIS with the mod_gsoap ISAPI extension (included in the gSOAP package under</div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;`gsoap/mod_gsoap` with instructions).</div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;</div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;Suppose we implement a CGI-based service that returns the time in GMT. The</div><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;Common Gateway Interface (CGI) is a simple mechanism to publish services on</div><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;your Web site.</div><div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;</div><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;For this example we start with a gSOAP header file, `currentTime.h` which contains the service definitions. Such a file can be obtained from a WSDL using `wsdl2h` when a WSDL is available. When a WSDL is not available, you can define the service in C/C++ definitions in a newly created header file and let the gSOAP tools generate the source code and WSDL for you.</div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;</div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;Our `currentTime` service only has an output parameter, which is the</div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;current time defined in our `currentTime.h` gSOAP service specification:</div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;</div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;```cpp</div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;// File: currentTime.h </div><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;//gsoap ns service name: currentTime </div><div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;//gsoap ns service namespace: urn:currentTime </div><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;//gsoap ns service location: http://www.yourdomain.com/currentTime.cgi </div><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;int ns__currentTime(time_t&amp; response);</div><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;```</div><div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;</div><div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;Note that we associate an XML namespace prefix `ns` and namespace name `urn:currentTime` with the service WSDL and SOAP/XML messages. The gSOAP tools</div><div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;use a special convention for identifier names that are part of a namespace: a</div><div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;namespace prefix (`ns` in this case) followed by a double underscore</div><div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;`__`. This convention is used to resolve namespaces and to avoid name</div><div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;clashes. The `ns` namespace prefix is bound to the `urn:currentTime`</div><div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;namespace name with the `//gsoap` directive. The `//gsoap` directives</div><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;are used to set the properties of the service, in this case the name,</div><div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;namespace, and location endpoint.</div><div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;</div><div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;The service implementation for CGI requires a `soap_serve` call on a soap context created with `soap_new`. The service operations are implemented as functions, which are called by the RPC dispatcher `soap_serve`:</div><div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;</div><div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;```cpp</div><div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;// File: currentTime.cpp </div><div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;#include &quot;soapH.h&quot; // include the generated declarations </div><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;#include &quot;currentTime.nsmap&quot; // include the XML namespace mappings </div><div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;int main() </div><div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;{ </div><div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;   // create soap context and serve one CGI-based request: </div><div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;   return soap_serve(soap_new()); </div><div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;}</div><div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;</div><div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;int ns__currentTime(struct soap *soap, time_t&amp; response) </div><div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;{ </div><div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;   response = time(0); </div><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;   return SOAP_OK; </div><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;}</div><div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;```</div><div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;</div><div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;Note that we pass the soap struct with the gSOAP context information to the</div><div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;service routine. This can come in handy to determine properties of the connection</div><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;and to dynamically allocate data with `soap_malloc(soap, num_bytes)` that</div><div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;will be automatically deleted when the service is finished.</div><div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;</div><div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;We run the `soapcpp2` compiler on the header file to generate the</div><div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;server-side code:</div><div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;</div><div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;    &gt; soapcpp2 -S currentTime.h</div><div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;</div><div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;and then compile the CGI binary:</div><div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;</div><div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;    &gt; c++ -o currentTime.cgi currentTime.cpp soapC.cpp soapServer.cpp stdsoap2.cpp</div><div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;</div><div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;You will find `stdsoap2.cpp` in the `gsoap` dir. Or after installation</div><div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;you can link with `libgsoap++` instead of using the `stdsoap2.cpp`</div><div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;source:</div><div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;</div><div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;    &gt; c++ -o currentTime.cgi currentTime.cpp soapC.cpp soapServer.cpp -lgsoap++</div><div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;</div><div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;To activate the service, copy the `currentTime.cgi` binary to your</div><div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;`bin-cgi` directory using the proper file permissions.</div><div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;</div><div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;The `soapcpp2` tool generated the WSDL definitions</div><div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;`currentTime.wsdl`. You can use the WSDL to advertize your service.</div><div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;You don&#39;t need to use this WSDL to develop a gSOAP client. You can use the</div><div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;`currentTime.h` file with `soapcpp2` option ` -C` to generate</div><div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;client-side code.</div><div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;</div><div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;A convenient aspect of CGI is that it exchanges messages over standard</div><div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;input/output. Therefore, you can run the CGI binary on the auto-generated</div><div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;example request XML file to test your server:</div><div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;</div><div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;    &gt; ./currentTime.cgi &lt; currentTime.currentTime.req.xml</div><div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;</div><div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;and this displays the server response in SOAP XML.</div><div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;</div><div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;The above approach works also for C. Just use `soapcpp2` option `-c` in</div><div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;addition to the `-S` option to generate ANSI C code. Of course, in C we use</div><div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;pointers instead of references and the `currentTime.h` file should be</div><div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;adjusted to use C-only types.</div><div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;</div><div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;A more elegant server implementation in C++ can be obtained by using the</div><div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;`soapcpp2` option `-i` (or `-j`) to generate C++ client-side proxy and</div><div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;server-side service objects as classes that you can use to build clients and</div><div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;services in C++. The option removes the generation of `soapClient.cpp` and</div><div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;`soapServer.cpp`, since these are no longer needed when we have classes</div><div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;that implement the client and server logic:</div><div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;</div><div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;    &gt; soapcpp2 -i -S currentTime.h</div><div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;</div><div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;This generates `soapcurrentTimeService.h` and</div><div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;`soapcurrentTimeService.cpp` files, as well as auxiliary files</div><div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;`soapStub.h` (included by default by all codes) and `currentTime.nsmap`.</div><div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;</div><div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;Using the `currentTimeService` object we rewrite the CGI server as:</div><div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;</div><div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;```cpp</div><div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;// File: currentTime.cpp </div><div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;#include &quot;soapcurrentTimeService.h&quot; // include the proxy declarations </div><div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;#include &quot;currentTime.nsmap&quot; // include the XML namespace mappings </div><div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;int main() </div><div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;{ </div><div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;   // create server and serve one CGI-based request: </div><div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;   currentTimeService server; </div><div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;   server.serve(); </div><div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;   server.destroy(); </div><div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;}</div><div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;</div><div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;int currentTimeService::currentTime(time_t&amp; response) </div><div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;{ </div><div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;   response = time(0); </div><div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;   return SOAP_OK; </div><div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;}</div><div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;```</div><div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;</div><div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;Compile with</div><div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;</div><div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;    &gt; c++ -o currentTime.cgi currentTime.cpp soapC.cpp soapcurrentTimeService.cpp -lgsoap++</div><div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;</div><div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;and install the binary as CGI. To install the CGI binary please consult your</div><div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;Web server documentation on how to deploy CGI applications.</div><div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;</div><div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;To run the server as a stand-alone iterative (non-multithreaded) server on port 8080:</div><div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;```cpp</div><div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;while (server.run(8080) != SOAP_TCP_ERROR) </div><div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;   server.soap_stream_fault(std::cerr); </div><div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;```</div><div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;</div><div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;To implement threaded services, please see Section \ref mt . These</div><div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;stand-alone Web Services that handle multiple SOAP requests by spawning a</div><div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;thread for each request. Thread pooling is also an option. The use of Apache</div><div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;and IIS modules to deploy gSOAP services is preferred to ensure load balancing, access control, tracing, and so on.</div><div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;</div><div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;For more information on server-side service classes, see</div><div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;Section \ref object . For more information on client-side proxy classes,</div><div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;see Section \ref proxy .</div><div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;</div><div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;# XML data bindings                                             {#databindings}</div><div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;</div><div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;Or in other words, how to map schemas (XSD files) to C/C++ bindings for</div><div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;automatically reading and writing XML data.</div><div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;</div><div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;The XML C/C++ data binding in gSOAP provides and automated mechanism to encode</div><div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;any C and C++ data type in XML (and decode XML back to C/C++ data). An XML</div><div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;schema (XSD file) can be transformed into a set of C or C++ definitions</div><div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;that can be readily incorporated into your application to manipulate XML with</div><div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;much more ease than DOM or SAX. Essentially, each XML component definition in</div><div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;an XML schema has a C/C++ data type representation that has equivalent type</div><div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;properties. The advantage of this approach is immediately apparent when we look</div><div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;at an XSD complexType that maps to a class as shown:</div><div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;</div><div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;```xml</div><div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;&lt;complexType name=&quot;Address&quot;&gt;                                  class ns__Address {</div><div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;   &lt;sequence&gt;                                                  public: </div><div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;     &lt;element name=&quot;name&quot; type=&quot;string&quot;/&gt;                       std::string name; </div><div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;     &lt;element name=&quot;home&quot; type=&quot;tns:Location&quot; minOccurs=&quot;0&quot;/&gt;   ns__Location *home; </div><div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;     &lt;element name=&quot;phone&quot; type=&quot;unsignedLong&quot;/&gt;                ULONG64 phone;  </div><div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;     &lt;element name=&quot;dob&quot; type=&quot;dateTime&quot;/&gt;                      time_t dob; </div><div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;   &lt;/sequence&gt; </div><div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;   &lt;attribute name=&quot;ID&quot; type=&quot;int&quot; use=&quot;required&quot;/&gt;             @ int ID; </div><div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;&lt;/complexType&gt;                                                }</div><div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;```</div><div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;</div><div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;In this way, an automatic mapping</div><div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;between XML elements of the XML schema and members of a class is created.</div><div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;No DOM traversals and SAX events are needed.</div><div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;In addition, the XML C/C++ data binding makes XML manipulation type safe. That</div><div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;is, the type safety of C/C++ ensures that only valid XML documents can be</div><div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;parsed and generated.</div><div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;</div><div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;The `wsdl2h` tool performs the mapping of WSDL and XML schemas to C and/or C++ automatically. The output of `wsdl2h` is an annotated header file that includes comments and documentation on the use of the C/C++ declarations in a SOAP/XML client/server or in a generic application for reading and writing XML using the auto-generated serializers.</div><div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;</div><div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;We will illustrate this further with an example. Suppose we have an XML document with a book record:</div><div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;</div><div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;```xml</div><div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;&lt;book isbn=&quot;1234567890&quot;&gt; </div><div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;   &lt;title&gt;Farewell John Doe&lt;/title&gt; </div><div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;   &lt;publisher&gt;ABC&#39;s is our Name&lt;/publisher&gt; </div><div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;&lt;/book&gt;</div><div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;```</div><div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;</div><div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;An example XML schema that defines the book element and type could be</div><div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;</div><div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;```xml</div><div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;&lt;schema ...&gt; </div><div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;   &lt;element name=&quot;book&quot;&gt; </div><div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;     &lt;complexType&gt; </div><div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;       &lt;sequence&gt; </div><div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;         &lt;element name=&quot;title&quot; type=&quot;string&quot; minOccurs=&quot;1&quot;/&gt; </div><div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;         &lt;element name=&quot;publisher&quot; type=&quot;string&quot; minOccurs=&quot;1&quot;/&gt; </div><div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;       &lt;/sequence&gt; </div><div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;       &lt;attribute name=&quot;isbn&quot; type=&quot;unsignedLong&quot; use=&quot;required&quot;/&gt; </div><div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;     &lt;/complexType&gt; </div><div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;   &lt;/element&gt; </div><div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;&lt;/schema&gt;</div><div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;```</div><div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;</div><div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;Using `wsdl2h` we translate the XML schema that defines the book type and root element to a class definition:</div><div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;</div><div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;  ```cpp</div><div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;class book </div><div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;{ </div><div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160; public:</div><div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;  @ ULONG64 isbn; </div><div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;  std::string title; </div><div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;  std::string publisher; </div><div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;}</div><div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;```</div><div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;</div><div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;Note that annotations such as `@` are used to distinguish attributes</div><div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;from elements. These annotations are gSOAP-specific and are handled by the `soapcpp2` tool to generate serializers for the data type(s) for reading and writing XML.</div><div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;</div><div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;The `soapcpp2` tool generates all</div><div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;the necessary code to parse and generate XML for `book` objects. Validation</div><div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;constraints such as *`minOccurs=&quot;1&quot;`* and *`use=&quot;required&quot;`* are included</div><div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;in the generated code as checks.</div><div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;</div><div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;To write the XML representation of a book, we first create a `soap` engine context and use it with `soap_write_book` (generated by `soapcpp2`) to write the object in XML to standard output:</div><div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;</div><div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;```cpp</div><div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;soap *ctx = soap_new1(SOAP_XML_INDENT); // new context with option </div><div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;book bk; </div><div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;bk.isbn = 1234567890; </div><div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;bk.title = &quot;Farewell John Doe&quot;; </div><div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;bk.publisher = &quot;ABC&#39;s is our Name&quot;; </div><div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;if (soap_write_book(ctx, &amp;bk) != SOAP_OK) </div><div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;   ... error ...</div><div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;</div><div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;</div><div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;</div><div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;soap_destroy(ctx); // clean up allocated class instances </div><div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;soap_end(ctx); // clean up allocated temporaries </div><div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;soap_free(ctx); // delete context</div><div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;```</div><div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;</div><div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;The `ctx` gSOAP engine context (type `struct soap`) controls settings</div><div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;and holds state, such as XML formatting, (e.g. `SOAP_XML_INDENT`),</div><div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;serialization options, current state, and I/O settings. Simply set the output</div><div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;stream (std::ostream) `ctx-&gt;os` of the context to redirect the</div><div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;content, e.g. to a file or string. Also, when serializing a graph rather than an XML tree (`SOAP_XML_TREE` option forces trees) the XML output conforms to SOAP encoding for object graphs based on id-ref, see Section \ref bindings  for details.</div><div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;</div><div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;To read the XML representation from standard input into a book object, use:</div><div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;</div><div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;```cpp</div><div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;soap *ctx = soap_new1(SOAP_XML_STRICT); // new context with option </div><div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;book bk; </div><div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;if (soap_read_book(ctx, &amp;bk) != SOAP_OK)</div><div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;</div><div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;</div><div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;</div><div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;   ... error ...</div><div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;else </div><div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;   cout &lt;&lt; bk.isbn &lt;&lt; &quot;, &quot; &lt;&lt; bk.title &lt;&lt; &quot;, &quot; &lt;&lt; bk.publisher &lt;&lt; endl; </div><div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;... further use of bk ...</div><div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;</div><div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;soap_destroy(ctx); // delete deserialized objects </div><div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;soap_end(ctx); // delete temporaries </div><div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;soap_free(ctx); // delete context</div><div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;```</div><div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;</div><div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;Automatic built-in strict XML validation (enabled with `SOAP_XML_STRICT`)</div><div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;ensures that data members are present so we can safely print them in this</div><div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;example, thus ensuring consistency of data with the XML schema. Set the</div><div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;`ctx-&gt;is` input stream to read from a file/string stream</div><div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;instead of stdin.</div><div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;</div><div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;The `soap_destroy` and `soap_end` calls deallocate the deserialized</div><div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;content, so use with care. In general, memory management is automatic in gSOAP</div><div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;to avoid leaks.</div><div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;</div><div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;The above uses a very simple example schema. The gSOAP toolkit handles all XML schema constructs defined by the XML schema standard. The toolkit is also able to (de)serialize pointer-based C/C++</div><div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;data structures (including cyclic graphs), structs/classes, unions, enums, STL</div><div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;containers, and even special data types such as `struct tm`. Therefore, the toolkit works in two directions: from WSDL/schema to C/C++ and from C/C++ to WSDL/schema.</div><div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;</div><div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;The gSOAP toolkit also handles multiple schemas defined in multiple namespaces. Normally the namespace prefixes of XML namespaces are added to the C/C++ type</div><div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;definitions to ensure type uniqueness. For example, if we would combine two</div><div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;schemas in the same application where both schemas define a `book` object,</div><div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;we need to resolve this conflict. In gSOAP this is done using namespace</div><div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;prefixes, rather than C++ namespaces (research has pointed out that XML</div><div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;namespaces are not equivalent to C++ namespaces). Thus, the `book` class</div><div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;might actually be bound to an XML namespace and the class would be named</div><div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;`ns__book`, where `ns` is bound to the corresponding namespace.</div><div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160;</div><div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;The following options are available to control serialization:</div><div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160;</div><div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;```cpp</div><div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160;soap-&gt;encodingStyle = NULL; // to remove SOAP 1.1/1.2 encodingStyle</div><div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;soap_mode(soap, SOAP_XML_TREE); // XML without id-ref (no cycles!)</div><div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;soap_mode(soap, SOAP_XML_GRAPH); // XML with id-ref (including cycles)</div><div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;soap_set_namespaces(soap, struct Namespace *nsmap); //to set xmlns bindings</div><div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;```</div><div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160;</div><div class="line"><a name="l00528"></a><span class="lineno">  528</span>&#160;Other flags can be used to format XML, see Section \ref flags .</div><div class="line"><a name="l00529"></a><span class="lineno">  529</span>&#160;</div><div class="line"><a name="l00530"></a><span class="lineno">  530</span>&#160;For more details on XML databinding support for C and C++, see</div><div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160;Section \ref bindings .</div><div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160;</div><div class="line"><a name="l00533"></a><span class="lineno">  533</span>&#160;## Feature Overview</div><div class="line"><a name="l00534"></a><span class="lineno">  534</span>&#160;</div><div class="line"><a name="l00535"></a><span class="lineno">  535</span>&#160;The highlights of gSOAP are:</div><div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;</div><div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;* Unique interoperability features: the tools generate type-safe SOAP marshalling</div><div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160;routines to (de)serialize native and user-defined C and C++ data structures. </div><div class="line"><a name="l00539"></a><span class="lineno">  539</span>&#160;</div><div class="line"><a name="l00540"></a><span class="lineno">  540</span>&#160;</div><div class="line"><a name="l00541"></a><span class="lineno">  541</span>&#160;* Support WSDL 1.1, WSDL 2.0, REST, SOAP 1.1, SOAP 1.2, SOAP RPC encoding style, and document/literal style.</div><div class="line"><a name="l00542"></a><span class="lineno">  542</span>&#160;gSOAP is one of the few SOAP toolkits that support the **full** range of SOAP 1.1</div><div class="line"><a name="l00543"></a><span class="lineno">  543</span>&#160;RPC encoding features including sparse multi-dimensional arrays and polymorphic</div><div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160;types. For example, a service operation with a base class parameter may accept</div><div class="line"><a name="l00545"></a><span class="lineno">  545</span>&#160;derived class instances from a client. Derived class instances keep their</div><div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160;identity through dynamic binding. The toolkit also supports **all XSD</div><div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;1.0 and 1.1 schema type** constructs and has been tested against the W3C XML</div><div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;Schema Patterns for Databinding Interoperability working group and of gSOAP</div><div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;release 2.8.x passes all tests.</div><div class="line"><a name="l00550"></a><span class="lineno">  550</span>&#160;</div><div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;</div><div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160;* Supports WS-Security, WS-Addressing, WS-ReliableMessaging, C14N exclusive</div><div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160;canonicalization. The protocols are implemented using code generation with</div><div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160;wsdl2h and soapcpp2. The gSOAP tools can be used to generate messaging</div><div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;protocols for other WS-* protocols.</div><div class="line"><a name="l00556"></a><span class="lineno">  556</span>&#160;</div><div class="line"><a name="l00557"></a><span class="lineno">  557</span>&#160;</div><div class="line"><a name="l00558"></a><span class="lineno">  558</span>&#160;* gSOAP supports XML-RPC and RSS protocols. Examples are provided.</div><div class="line"><a name="l00559"></a><span class="lineno">  559</span>&#160;</div><div class="line"><a name="l00560"></a><span class="lineno">  560</span>&#160;</div><div class="line"><a name="l00561"></a><span class="lineno">  561</span>&#160;*  JSON support is included in the XML-RPC library to switch between XML-RPC</div><div class="line"><a name="l00562"></a><span class="lineno">  562</span>&#160;and JSON protocols. For more details, see the `samples/xml-rpc-json` folder in the package.</div><div class="line"><a name="l00563"></a><span class="lineno">  563</span>&#160;</div><div class="line"><a name="l00564"></a><span class="lineno">  564</span>&#160;</div><div class="line"><a name="l00565"></a><span class="lineno">  565</span>&#160;* The `wsdl2h` tool supports WS-Policy. Policy assertions are included in</div><div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160;the generated service description header file with recommendations and usage</div><div class="line"><a name="l00567"></a><span class="lineno">  567</span>&#160;hints.</div><div class="line"><a name="l00568"></a><span class="lineno">  568</span>&#160;</div><div class="line"><a name="l00569"></a><span class="lineno">  569</span>&#160;</div><div class="line"><a name="l00570"></a><span class="lineno">  570</span>&#160;* gSOAP supports MIME (SwA), DIME, and MTOM attachments and has streaming</div><div class="line"><a name="l00571"></a><span class="lineno">  571</span>&#160;capabilities to direct the data stream to/from resources.</div><div class="line"><a name="l00572"></a><span class="lineno">  572</span>&#160;gSOAP is the only toolkit that supports *streaming* MIME, DIME, and MTOM</div><div class="line"><a name="l00573"></a><span class="lineno">  573</span>&#160;attachment transfers, which allows you to exchange binary data of practically</div><div class="line"><a name="l00574"></a><span class="lineno">  574</span>&#160;unlimited size in the fastest possible way (streaming) while ensuring the</div><div class="line"><a name="l00575"></a><span class="lineno">  575</span>&#160;usefulness of XML interoperability.</div><div class="line"><a name="l00576"></a><span class="lineno">  576</span>&#160;</div><div class="line"><a name="l00577"></a><span class="lineno">  577</span>&#160;</div><div class="line"><a name="l00578"></a><span class="lineno">  578</span>&#160;* gSOAP supports SOAP-over-UDP.</div><div class="line"><a name="l00579"></a><span class="lineno">  579</span>&#160;</div><div class="line"><a name="l00580"></a><span class="lineno">  580</span>&#160;</div><div class="line"><a name="l00581"></a><span class="lineno">  581</span>&#160;* gSOAP supports IPv4 and IPv6.</div><div class="line"><a name="l00582"></a><span class="lineno">  582</span>&#160;</div><div class="line"><a name="l00583"></a><span class="lineno">  583</span>&#160;</div><div class="line"><a name="l00584"></a><span class="lineno">  584</span>&#160;* gSOAP supports Zlib deflate and gzip compression (for HTTP, TCP/IP, and XML file storage).</div><div class="line"><a name="l00585"></a><span class="lineno">  585</span>&#160;</div><div class="line"><a name="l00586"></a><span class="lineno">  586</span>&#160;</div><div class="line"><a name="l00587"></a><span class="lineno">  587</span>&#160;* gSOAP supports SSL (HTTPS) using OpenSSL and optionally using GNUTLS.</div><div class="line"><a name="l00588"></a><span class="lineno">  588</span>&#160;</div><div class="line"><a name="l00589"></a><span class="lineno">  589</span>&#160;</div><div class="line"><a name="l00590"></a><span class="lineno">  590</span>&#160;* gSOAP supports HTTP/1.0, HTTP/1.1 keep-alive, chunking, basic authentication, and digest authentication using a plugin.</div><div class="line"><a name="l00591"></a><span class="lineno">  591</span>&#160;</div><div class="line"><a name="l00592"></a><span class="lineno">  592</span>&#160;</div><div class="line"><a name="l00593"></a><span class="lineno">  593</span>&#160;* gSOAP supports SOAP one-way messaging.</div><div class="line"><a name="l00594"></a><span class="lineno">  594</span>&#160;</div><div class="line"><a name="l00595"></a><span class="lineno">  595</span>&#160;</div><div class="line"><a name="l00596"></a><span class="lineno">  596</span>&#160;* The schema-specific XML pull parser is fast and efficient and does not require intermediate data storage for</div><div class="line"><a name="l00597"></a><span class="lineno">  597</span>&#160;demarshalling to save space and time.</div><div class="line"><a name="l00598"></a><span class="lineno">  598</span>&#160;</div><div class="line"><a name="l00599"></a><span class="lineno">  599</span>&#160;</div><div class="line"><a name="l00600"></a><span class="lineno">  600</span>&#160;* The `soapcpp2` compiler includes a WSDL and schema generator for convenient</div><div class="line"><a name="l00601"></a><span class="lineno">  601</span>&#160;Web Service publishing.</div><div class="line"><a name="l00602"></a><span class="lineno">  602</span>&#160;</div><div class="line"><a name="l00603"></a><span class="lineno">  603</span>&#160;</div><div class="line"><a name="l00604"></a><span class="lineno">  604</span>&#160;* The `soapcpp2` compiler generates sample input and output messages</div><div class="line"><a name="l00605"></a><span class="lineno">  605</span>&#160;for verification and testing (before writing any code). An option (`-T`)</div><div class="line"><a name="l00606"></a><span class="lineno">  606</span>&#160;can be used to automatically implement echo message services for testing.</div><div class="line"><a name="l00607"></a><span class="lineno">  607</span>&#160;</div><div class="line"><a name="l00608"></a><span class="lineno">  608</span>&#160;</div><div class="line"><a name="l00609"></a><span class="lineno">  609</span>&#160;* The `wsdl2h` tool converts WSDL and XSD files to gSOAP header files for automated client and server development.</div><div class="line"><a name="l00610"></a><span class="lineno">  610</span>&#160;</div><div class="line"><a name="l00611"></a><span class="lineno">  611</span>&#160;</div><div class="line"><a name="l00612"></a><span class="lineno">  612</span>&#160;* Generates source code for stand-alone Web Services and client applications.</div><div class="line"><a name="l00613"></a><span class="lineno">  613</span>&#160;</div><div class="line"><a name="l00614"></a><span class="lineno">  614</span>&#160;</div><div class="line"><a name="l00615"></a><span class="lineno">  615</span>&#160;* Ideal for small devices such as Palm OS, Symbian, Pocket PC, because the memory footprint is small.</div><div class="line"><a name="l00616"></a><span class="lineno">  616</span>&#160;</div><div class="line"><a name="l00617"></a><span class="lineno">  617</span>&#160;</div><div class="line"><a name="l00618"></a><span class="lineno">  618</span>&#160;* Ideal for building web services that are compute-intensive and are therefore best written in C and C++.</div><div class="line"><a name="l00619"></a><span class="lineno">  619</span>&#160;</div><div class="line"><a name="l00620"></a><span class="lineno">  620</span>&#160;</div><div class="line"><a name="l00621"></a><span class="lineno">  621</span>&#160;* Platform independent: Windows, Unix, Linux, Mac OS X, Pocket PC, Palm OS, Symbian, VXWorks, etc.</div><div class="line"><a name="l00622"></a><span class="lineno">  622</span>&#160;</div><div class="line"><a name="l00623"></a><span class="lineno">  623</span>&#160;</div><div class="line"><a name="l00624"></a><span class="lineno">  624</span>&#160;* Supports serializing of application&#39;s native C and C++ data structures, which allows you to save and load XML serialized data structures to and from files.</div><div class="line"><a name="l00625"></a><span class="lineno">  625</span>&#160;</div><div class="line"><a name="l00626"></a><span class="lineno">  626</span>&#160;</div><div class="line"><a name="l00627"></a><span class="lineno">  627</span>&#160;* Selective input and output buffering is used to increase efficiency, but full message buffering to determine HTTP message length</div><div class="line"><a name="l00628"></a><span class="lineno">  628</span>&#160;is not used. Instead, a three-phase serialization method is used to determine message length. As a result, large data sets</div><div class="line"><a name="l00629"></a><span class="lineno">  629</span>&#160;such as base64-encoded images can be transmitted with or without DIME attachments by small-memory devices such as PDAs.</div><div class="line"><a name="l00630"></a><span class="lineno">  630</span>&#160;</div><div class="line"><a name="l00631"></a><span class="lineno">  631</span>&#160;</div><div class="line"><a name="l00632"></a><span class="lineno">  632</span>&#160;* Supports C++ single class inheritance, dynamic binding, overloading, arbitrary pointer structures such as lists, trees, graphs,</div><div class="line"><a name="l00633"></a><span class="lineno">  633</span>&#160;cyclic graphs, fixed-size arrays, (multi-dimensional) dynamic arrays, enumerations, built-in XSD Schema types including</div><div class="line"><a name="l00634"></a><span class="lineno">  634</span>&#160;base64Binary encoding, and hexBinary encoding.</div><div class="line"><a name="l00635"></a><span class="lineno">  635</span>&#160;</div><div class="line"><a name="l00636"></a><span class="lineno">  636</span>&#160;</div><div class="line"><a name="l00637"></a><span class="lineno">  637</span>&#160;* No need to rewrite existing C/C++ applications for Web service deployment. However, parts of an application that use unions,</div><div class="line"><a name="l00638"></a><span class="lineno">  638</span>&#160;pointers to sequences of elements in memory, and `void*` need to be modified, but **only** if the data structures that</div><div class="line"><a name="l00639"></a><span class="lineno">  639</span>&#160;adopt them are required to be serialized or deserialized as part of a service operation invocation.</div><div class="line"><a name="l00640"></a><span class="lineno">  640</span>&#160;</div><div class="line"><a name="l00641"></a><span class="lineno">  641</span>&#160;</div><div class="line"><a name="l00642"></a><span class="lineno">  642</span>&#160;* Three-phase marshalling: 1) analysis of pointers, single-reference, multi-reference, and cyclic data structures, 2) HTTP</div><div class="line"><a name="l00643"></a><span class="lineno">  643</span>&#160;message-length determination, and 3) serialization as per SOAP 1.1 encoding style or user-defined encoding styles.</div><div class="line"><a name="l00644"></a><span class="lineno">  644</span>&#160;</div><div class="line"><a name="l00645"></a><span class="lineno">  645</span>&#160;</div><div class="line"><a name="l00646"></a><span class="lineno">  646</span>&#160;* Two-phase demarshalling: 1) SOAP parsing and decoding, which involves the reconstruction of multi-reference and cyclic data</div><div class="line"><a name="l00647"></a><span class="lineno">  647</span>&#160;structures from the payload, and 2) resolution of &quot;forward&quot; pointers (i.e. resolution of the forward *`href`* attributes in SOAP).</div><div class="line"><a name="l00648"></a><span class="lineno">  648</span>&#160;</div><div class="line"><a name="l00649"></a><span class="lineno">  649</span>&#160;</div><div class="line"><a name="l00650"></a><span class="lineno">  650</span>&#160;* Full and customizable SOAP Fault processing (client receive and service send).</div><div class="line"><a name="l00651"></a><span class="lineno">  651</span>&#160;</div><div class="line"><a name="l00652"></a><span class="lineno">  652</span>&#160;</div><div class="line"><a name="l00653"></a><span class="lineno">  653</span>&#160;* Customizable SOAP Header processing (send and receive), which for example enables easy transaction processing for the service to</div><div class="line"><a name="l00654"></a><span class="lineno">  654</span>&#160;keep state information.</div><div class="line"><a name="l00655"></a><span class="lineno">  655</span>&#160;</div><div class="line"><a name="l00656"></a><span class="lineno">  656</span>&#160;# Notational Conventions</div><div class="line"><a name="l00657"></a><span class="lineno">  657</span>&#160;</div><div class="line"><a name="l00658"></a><span class="lineno">  658</span>&#160;The typographical conventions used by this document are:</div><div class="line"><a name="l00659"></a><span class="lineno">  659</span>&#160;</div><div class="line"><a name="l00660"></a><span class="lineno">  660</span>&#160;* `Courier` denotes C and C++ source code, XML data, JSON data, file names, and shell/batch commands.</div><div class="line"><a name="l00661"></a><span class="lineno">  661</span>&#160;</div><div class="line"><a name="l00662"></a><span class="lineno">  662</span>&#160;* `[optional: ...]` denotes an optional construct.</div><div class="line"><a name="l00663"></a><span class="lineno">  663</span>&#160;</div><div class="line"><a name="l00664"></a><span class="lineno">  664</span>&#160;The keywords &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;MAY&quot;, and</div><div class="line"><a name="l00665"></a><span class="lineno">  665</span>&#160;&quot;OPTIONAL&quot; in this document are to be interpreted as described in RFC-2119.</div><div class="line"><a name="l00666"></a><span class="lineno">  666</span>&#160;</div><div class="line"><a name="l00667"></a><span class="lineno">  667</span>&#160;# Differences Between gSOAP Versions 2.4 (and Earlier) and 2.5</div><div class="line"><a name="l00668"></a><span class="lineno">  668</span>&#160;</div><div class="line"><a name="l00669"></a><span class="lineno">  669</span>&#160;To comply with WS-I Basic Profile 1.0a, gSOAP 2.5 and higher adopts SOAP document/literal by default.</div><div class="line"><a name="l00670"></a><span class="lineno">  670</span>&#160;There is no need for concern, because the WSDL parser `wsdl2h` automatically takes care of the differences when you provide a WSDL document, because SOAP RPC encoding, literal, and document style are supported.</div><div class="line"><a name="l00671"></a><span class="lineno">  671</span>&#160;A new soapcpp2 compiler option was added `-e` for backward compatibility with gSOAP 2.4 and earlier to adopt SOAP RPC encoding by default in case you want to develop a service that uses SOAP encoding. You can also use the gSOAP `soapcpp2` compiler directives to specify SOAP encoding for individual operarations, when desired.</div><div class="line"><a name="l00672"></a><span class="lineno">  672</span>&#160;</div><div class="line"><a name="l00673"></a><span class="lineno">  673</span>&#160;# Differences Between gSOAP Versions 2.1 (and Earlier) and 2.2</div><div class="line"><a name="l00674"></a><span class="lineno">  674</span>&#160;</div><div class="line"><a name="l00675"></a><span class="lineno">  675</span>&#160;You should read this section only if you are upgrading from gSOAP 2.1 to 2.2 and later.</div><div class="line"><a name="l00676"></a><span class="lineno">  676</span>&#160;</div><div class="line"><a name="l00677"></a><span class="lineno">  677</span>&#160;Run-time options and flags have been changed to enable separate recv/send</div><div class="line"><a name="l00678"></a><span class="lineno">  678</span>&#160;settings for transport, content encodings, and mappings.  The flags are divided</div><div class="line"><a name="l00679"></a><span class="lineno">  679</span>&#160;into four classes: transport (IO), content encoding (ENC), XML marshalling</div><div class="line"><a name="l00680"></a><span class="lineno">  680</span>&#160;(XML), and C/C++ data mapping (C).  The old-style flags `soap_disable_X`</div><div class="line"><a name="l00681"></a><span class="lineno">  681</span>&#160;and `soap_enable_X`, where `X` is a particular feature, are</div><div class="line"><a name="l00682"></a><span class="lineno">  682</span>&#160;deprecated.  See Section \ref flags  for more details.</div><div class="line"><a name="l00683"></a><span class="lineno">  683</span>&#160;</div><div class="line"><a name="l00684"></a><span class="lineno">  684</span>&#160;Before a client can invoke service operations or before a service can accept requests, a runtime context needs to be allocated and</div><div class="line"><a name="l00685"></a><span class="lineno">  685</span>&#160;initialized.</div><div class="line"><a name="l00686"></a><span class="lineno">  686</span>&#160;</div><div class="line"><a name="l00687"></a><span class="lineno">  687</span>&#160;* `soap_init(struct soap *soap)` &amp; Initializes a context (required only once) </div><div class="line"><a name="l00688"></a><span class="lineno">  688</span>&#160;</div><div class="line"><a name="l00689"></a><span class="lineno">  689</span>&#160;* `struct soap *soap_new()` &amp; Allocates, initializes, and returns a pointer to a runtime context </div><div class="line"><a name="l00690"></a><span class="lineno">  690</span>&#160;</div><div class="line"><a name="l00691"></a><span class="lineno">  691</span>&#160;* `struct soap *soap_copy(struct soap *soap)` &amp; Allocates a new runtime context and copies contents of</div><div class="line"><a name="l00692"></a><span class="lineno">  692</span>&#160;  the context such that the new environment does not share any data with the</div><div class="line"><a name="l00693"></a><span class="lineno">  693</span>&#160;  original context </div><div class="line"><a name="l00694"></a><span class="lineno">  694</span>&#160;</div><div class="line"><a name="l00695"></a><span class="lineno">  695</span>&#160;A context can be reused as many times as necessary and does not need to be</div><div class="line"><a name="l00696"></a><span class="lineno">  696</span>&#160;reinitialized in doing so. A dynamically allocated context is deallocated</div><div class="line"><a name="l00697"></a><span class="lineno">  697</span>&#160;with `soap_free(soap)`.</div><div class="line"><a name="l00698"></a><span class="lineno">  698</span>&#160;</div><div class="line"><a name="l00699"></a><span class="lineno">  699</span>&#160;A new context is only required for each new thread to guarantee exclusive access</div><div class="line"><a name="l00700"></a><span class="lineno">  700</span>&#160;to a new runtime context by each thread.</div><div class="line"><a name="l00701"></a><span class="lineno">  701</span>&#160;For example, the following code stack-allocates the runtime context which is used for multiple service operation calls:</div><div class="line"><a name="l00702"></a><span class="lineno">  702</span>&#160;</div><div class="line"><a name="l00703"></a><span class="lineno">  703</span>&#160;```cpp</div><div class="line"><a name="l00704"></a><span class="lineno">  704</span>&#160;int main() </div><div class="line"><a name="l00705"></a><span class="lineno">  705</span>&#160;{ </div><div class="line"><a name="l00706"></a><span class="lineno">  706</span>&#160;   struct soap soap; </div><div class="line"><a name="l00707"></a><span class="lineno">  707</span>&#160;   ... </div><div class="line"><a name="l00708"></a><span class="lineno">  708</span>&#160;   soap_init(&amp;soap); // initialize runtime context </div><div class="line"><a name="l00709"></a><span class="lineno">  709</span>&#160;   ... </div><div class="line"><a name="l00710"></a><span class="lineno">  710</span>&#160;   soap_call_ns__method1(&amp;soap, ...); // make a remote call </div><div class="line"><a name="l00711"></a><span class="lineno">  711</span>&#160;   ... </div><div class="line"><a name="l00712"></a><span class="lineno">  712</span>&#160;   soap_call_ns__method2(&amp;soap, ...); // make another remote call </div><div class="line"><a name="l00713"></a><span class="lineno">  713</span>&#160;   ... </div><div class="line"><a name="l00714"></a><span class="lineno">  714</span>&#160;   soap_destroy(&amp;soap); // remove deserialized class instances (C++ only) </div><div class="line"><a name="l00715"></a><span class="lineno">  715</span>&#160;   soap_end(&amp;soap); // clean up and remove deserialized data </div><div class="line"><a name="l00716"></a><span class="lineno">  716</span>&#160;   soap_done(&amp;soap); // detach context (last use and no longer in scope)</div><div class="line"><a name="l00717"></a><span class="lineno">  717</span>&#160;   ... </div><div class="line"><a name="l00718"></a><span class="lineno">  718</span>&#160;}</div><div class="line"><a name="l00719"></a><span class="lineno">  719</span>&#160;```</div><div class="line"><a name="l00720"></a><span class="lineno">  720</span>&#160;</div><div class="line"><a name="l00721"></a><span class="lineno">  721</span>&#160;The runtime context can also be heap allocated:</div><div class="line"><a name="l00722"></a><span class="lineno">  722</span>&#160;</div><div class="line"><a name="l00723"></a><span class="lineno">  723</span>&#160;```cpp</div><div class="line"><a name="l00724"></a><span class="lineno">  724</span>&#160;int main() </div><div class="line"><a name="l00725"></a><span class="lineno">  725</span>&#160;{ </div><div class="line"><a name="l00726"></a><span class="lineno">  726</span>&#160;   struct soap *soap; </div><div class="line"><a name="l00727"></a><span class="lineno">  727</span>&#160;   ... </div><div class="line"><a name="l00728"></a><span class="lineno">  728</span>&#160;   soap = soap_new(); // allocate and initialize runtime context </div><div class="line"><a name="l00729"></a><span class="lineno">  729</span>&#160;   if (!soap) // couldn&#39;t allocate: stop </div><div class="line"><a name="l00730"></a><span class="lineno">  730</span>&#160;   ... </div><div class="line"><a name="l00731"></a><span class="lineno">  731</span>&#160;   soap_call_ns__method1(soap, ...); // make a remote call </div><div class="line"><a name="l00732"></a><span class="lineno">  732</span>&#160;   ... </div><div class="line"><a name="l00733"></a><span class="lineno">  733</span>&#160;   soap_call_ns__method2(soap, ...); // make another remote call </div><div class="line"><a name="l00734"></a><span class="lineno">  734</span>&#160;   ... </div><div class="line"><a name="l00735"></a><span class="lineno">  735</span>&#160;   soap_destroy(soap); // remove deserialized class instances (C++ only) </div><div class="line"><a name="l00736"></a><span class="lineno">  736</span>&#160;   soap_end(soap); // clean up and remove deserialized data </div><div class="line"><a name="l00737"></a><span class="lineno">  737</span>&#160;   soap_free(soap); // detach and free runtime context </div><div class="line"><a name="l00738"></a><span class="lineno">  738</span>&#160;}</div><div class="line"><a name="l00739"></a><span class="lineno">  739</span>&#160;```</div><div class="line"><a name="l00740"></a><span class="lineno">  740</span>&#160;</div><div class="line"><a name="l00741"></a><span class="lineno">  741</span>&#160;A service needs to allocate and initialize an context before calling `soap_serve`:</div><div class="line"><a name="l00742"></a><span class="lineno">  742</span>&#160;</div><div class="line"><a name="l00743"></a><span class="lineno">  743</span>&#160;```cpp</div><div class="line"><a name="l00744"></a><span class="lineno">  744</span>&#160;int main() </div><div class="line"><a name="l00745"></a><span class="lineno">  745</span>&#160;{ </div><div class="line"><a name="l00746"></a><span class="lineno">  746</span>&#160;   struct soap soap; </div><div class="line"><a name="l00747"></a><span class="lineno">  747</span>&#160;   soap_init(&amp;soap); </div><div class="line"><a name="l00748"></a><span class="lineno">  748</span>&#160;   soap_serve(&amp;soap); </div><div class="line"><a name="l00749"></a><span class="lineno">  749</span>&#160;}</div><div class="line"><a name="l00750"></a><span class="lineno">  750</span>&#160;```</div><div class="line"><a name="l00751"></a><span class="lineno">  751</span>&#160;</div><div class="line"><a name="l00752"></a><span class="lineno">  752</span>&#160;Or alternatively:</div><div class="line"><a name="l00753"></a><span class="lineno">  753</span>&#160;</div><div class="line"><a name="l00754"></a><span class="lineno">  754</span>&#160;```cpp</div><div class="line"><a name="l00755"></a><span class="lineno">  755</span>&#160;int main() </div><div class="line"><a name="l00756"></a><span class="lineno">  756</span>&#160;{ </div><div class="line"><a name="l00757"></a><span class="lineno">  757</span>&#160;   soap_serve(soap_new()); </div><div class="line"><a name="l00758"></a><span class="lineno">  758</span>&#160;}</div><div class="line"><a name="l00759"></a><span class="lineno">  759</span>&#160;```</div><div class="line"><a name="l00760"></a><span class="lineno">  760</span>&#160;</div><div class="line"><a name="l00761"></a><span class="lineno">  761</span>&#160;The `soap_serve` dispatcher handles one request or multiple requests when HTTP keep-alive is enabled (with the `SOAP_IO_KEEPALIVE` flag see Section \ref keepalive ).</div><div class="line"><a name="l00762"></a><span class="lineno">  762</span>&#160;</div><div class="line"><a name="l00763"></a><span class="lineno">  763</span>&#160;A service can use multi-threading to handle requests while running some other code that invokes service operations:</div><div class="line"><a name="l00764"></a><span class="lineno">  764</span>&#160;</div><div class="line"><a name="l00765"></a><span class="lineno">  765</span>&#160;```cpp</div><div class="line"><a name="l00766"></a><span class="lineno">  766</span>&#160;int main() </div><div class="line"><a name="l00767"></a><span class="lineno">  767</span>&#160;{ </div><div class="line"><a name="l00768"></a><span class="lineno">  768</span>&#160;   struct soap soap1, soap2; </div><div class="line"><a name="l00769"></a><span class="lineno">  769</span>&#160;   pthread_t tid; </div><div class="line"><a name="l00770"></a><span class="lineno">  770</span>&#160;   ... </div><div class="line"><a name="l00771"></a><span class="lineno">  771</span>&#160;   soap_init(&amp;soap1); </div><div class="line"><a name="l00772"></a><span class="lineno">  772</span>&#160;   if (soap_bind(&amp;soap1, host, port, backlog) &lt; 0) exit(1); </div><div class="line"><a name="l00773"></a><span class="lineno">  773</span>&#160;   if (soap_accept(&amp;soap1) &lt; 0) exit(1); </div><div class="line"><a name="l00774"></a><span class="lineno">  774</span>&#160;   pthread_create(&amp;tid, NULL, (void*(*)(void*))soap_serve, (void*)&amp;soap1); </div><div class="line"><a name="l00775"></a><span class="lineno">  775</span>&#160;   ... </div><div class="line"><a name="l00776"></a><span class="lineno">  776</span>&#160;   soap_init(&amp;soap2); </div><div class="line"><a name="l00777"></a><span class="lineno">  777</span>&#160;   soap_call_ns__method(&amp;soap2, ...); // make a remote call </div><div class="line"><a name="l00778"></a><span class="lineno">  778</span>&#160;   ... </div><div class="line"><a name="l00779"></a><span class="lineno">  779</span>&#160;   soap_end(&amp;soap2); </div><div class="line"><a name="l00780"></a><span class="lineno">  780</span>&#160;   ... </div><div class="line"><a name="l00781"></a><span class="lineno">  781</span>&#160;   pthread_join(tid, NULL); // wait for thread to terminate </div><div class="line"><a name="l00782"></a><span class="lineno">  782</span>&#160;   soap_end(&amp;soap1); // release its data </div><div class="line"><a name="l00783"></a><span class="lineno">  783</span>&#160;}</div><div class="line"><a name="l00784"></a><span class="lineno">  784</span>&#160;```</div><div class="line"><a name="l00785"></a><span class="lineno">  785</span>&#160;</div><div class="line"><a name="l00786"></a><span class="lineno">  786</span>&#160;In the example above, two runtime contexts are required.</div><div class="line"><a name="l00787"></a><span class="lineno">  787</span>&#160;In comparison, gSOAP 1.X statically allocates the runtime context, which prohibits multi-threading (only one thread can invoke</div><div class="line"><a name="l00788"></a><span class="lineno">  788</span>&#160;service operations and/or accept requests due to the single runtime context).</div><div class="line"><a name="l00789"></a><span class="lineno">  789</span>&#160;</div><div class="line"><a name="l00790"></a><span class="lineno">  790</span>&#160;Section \ref mt  presents a multi-threaded stand-alone Web Service that handles multiple SOAP requests by spawning a thread for each request.</div><div class="line"><a name="l00791"></a><span class="lineno">  791</span>&#160;</div><div class="line"><a name="l00792"></a><span class="lineno">  792</span>&#160;# Interoperability</div><div class="line"><a name="l00793"></a><span class="lineno">  793</span>&#160;</div><div class="line"><a name="l00794"></a><span class="lineno">  794</span>&#160;gSOAP interoperability has been verified with the following SOAP implementations and toolkits:</div><div class="line"><a name="l00795"></a><span class="lineno">  795</span>&#160;</div><div class="line"><a name="l00796"></a><span class="lineno">  796</span>&#160;Apache 2.2, Apache Axis, ASP.NET, Cape Connect, Delphi, easySOAP++, eSOAP, Frontier, GLUE, Iona XMLBus, kSOAP, MS SOAP, Phalanx, SIM, SOAP::Lite, SOAP4R, Spray, SQLData, WCF, White Mesa, xSOAP, ZSI </div><div class="line"><a name="l00797"></a><span class="lineno">  797</span>&#160;</div><div class="line"><a name="l00798"></a><span class="lineno">  798</span>&#160;# Quick User Guide</div><div class="line"><a name="l00799"></a><span class="lineno">  799</span>&#160;</div><div class="line"><a name="l00800"></a><span class="lineno">  800</span>&#160;This user guide offers a quick way to get started with gSOAP.  This section</div><div class="line"><a name="l00801"></a><span class="lineno">  801</span>&#160;requires a basic understanding of the SOAP protocol and some familiarity</div><div class="line"><a name="l00802"></a><span class="lineno">  802</span>&#160;with C and/or C++. In principle, SOAP clients and SOAP Web services can be</div><div class="line"><a name="l00803"></a><span class="lineno">  803</span>&#160;developed in C and C++ with the gSOAP `soapcpp2` compiler without a detailed understanding</div><div class="line"><a name="l00804"></a><span class="lineno">  804</span>&#160;of the SOAP protocol when gSOAP client-server applications are built as an</div><div class="line"><a name="l00805"></a><span class="lineno">  805</span>&#160;ensamble and only communicate within this group (i.e. meaning that you don&#39;t</div><div class="line"><a name="l00806"></a><span class="lineno">  806</span>&#160;have to worry about interoperability with other SOAP implementations).  This</div><div class="line"><a name="l00807"></a><span class="lineno">  807</span>&#160;section is intended to illustrate the implementation of gSOAP Web services and</div><div class="line"><a name="l00808"></a><span class="lineno">  808</span>&#160;clients that connect to and interoperate with other SOAP implementations such</div><div class="line"><a name="l00809"></a><span class="lineno">  809</span>&#160;as Apache Axis, SOAP::Lite, and .NET.  This requires some details of the SOAP</div><div class="line"><a name="l00810"></a><span class="lineno">  810</span>&#160;and WSDL protocols to be understood.</div><div class="line"><a name="l00811"></a><span class="lineno">  811</span>&#160;</div><div class="line"><a name="l00812"></a><span class="lineno">  812</span>&#160;## How to Build SOAP/XML Clients        {#client}</div><div class="line"><a name="l00813"></a><span class="lineno">  813</span>&#160;</div><div class="line"><a name="l00814"></a><span class="lineno">  814</span>&#160;In general, the implementation of a SOAP client application requires a</div><div class="line"><a name="l00815"></a><span class="lineno">  815</span>&#160;*stub* (also called *service proxy*) for each service operation that the client invokes. The primary stub&#39;s responsibility is to marshall the parameter data,</div><div class="line"><a name="l00816"></a><span class="lineno">  816</span>&#160;send the request with the parameters to the designated SOAP service over the</div><div class="line"><a name="l00817"></a><span class="lineno">  817</span>&#160;wire, to wait for the</div><div class="line"><a name="l00818"></a><span class="lineno">  818</span>&#160;response, and to demarshall the parameter data of the response when it arrives. The client</div><div class="line"><a name="l00819"></a><span class="lineno">  819</span>&#160;application invokes the stub routine for a service operation as if it would invoke</div><div class="line"><a name="l00820"></a><span class="lineno">  820</span>&#160;a local function. To write a stub routine in C or C++ by hand is a tedious task,</div><div class="line"><a name="l00821"></a><span class="lineno">  821</span>&#160;especially if the input and/or output parameters of a service operation contain</div><div class="line"><a name="l00822"></a><span class="lineno">  822</span>&#160;elaborate data structures such as objects, structs, containers, arrays, and pointer-linked graph structures. Fortunately, the</div><div class="line"><a name="l00823"></a><span class="lineno">  823</span>&#160;gSOAP `wsdl2h` WSDL parser tool and `soapcpp2` stub/skeleton and serialization code generator tool automate the</div><div class="line"><a name="l00824"></a><span class="lineno">  824</span>&#160;development of SOAP/XML Web service client and server applications.</div><div class="line"><a name="l00825"></a><span class="lineno">  825</span>&#160; </div><div class="line"><a name="l00826"></a><span class="lineno">  826</span>&#160;The `soapcpp2` tool generates the necessary gluing code (also called stubs and skeletons) to build web service clients and services. The input to the `soapcpp2`</div><div class="line"><a name="l00827"></a><span class="lineno">  827</span>&#160;tool consists of an service definition-annotated C/C++ **header file**. The</div><div class="line"><a name="l00828"></a><span class="lineno">  828</span>&#160;header file can be generated from a WSDL (Web Service Description Language)</div><div class="line"><a name="l00829"></a><span class="lineno">  829</span>&#160;documentation of a service with the gSOAP `wsdl2h` WSDL parser tool.</div><div class="line"><a name="l00830"></a><span class="lineno">  830</span>&#160;</div><div class="line"><a name="l00831"></a><span class="lineno">  831</span>&#160;Consider the following command (entered at the Linux/Unix/Windows command line prompt):</div><div class="line"><a name="l00832"></a><span class="lineno">  832</span>&#160;</div><div class="line"><a name="l00833"></a><span class="lineno">  833</span>&#160;    &gt; wsdl2h -o calc.h http://www.genivia.com/calc.wsdl</div><div class="line"><a name="l00834"></a><span class="lineno">  834</span>&#160;</div><div class="line"><a name="l00835"></a><span class="lineno">  835</span>&#160;This generates the file Web service description `calc.h` in an annotated C++ header file.</div><div class="line"><a name="l00836"></a><span class="lineno">  836</span>&#160;The WSDL specification (possibly consisting of multiple imported WSDL files and XSD schema files) is mapped to C++ using C++ databindings for</div><div class="line"><a name="l00837"></a><span class="lineno">  837</span>&#160;SOAP/XML. The generated header file contains data types and messages to operate</div><div class="line"><a name="l00838"></a><span class="lineno">  838</span>&#160;the service, and meta information related to WSDL and XML schemas.</div><div class="line"><a name="l00839"></a><span class="lineno">  839</span>&#160;</div><div class="line"><a name="l00840"></a><span class="lineno">  840</span>&#160;To generate a service definition header file to develop a pure C client application, use the `-c` option:</div><div class="line"><a name="l00841"></a><span class="lineno">  841</span>&#160;</div><div class="line"><a name="l00842"></a><span class="lineno">  842</span>&#160;    &gt; wsdl2h -c -o calc.h http://www.genivia.com/calc.wsdl</div><div class="line"><a name="l00843"></a><span class="lineno">  843</span>&#160;</div><div class="line"><a name="l00844"></a><span class="lineno">  844</span>&#160;For more details on the WSDL parser and its options, see \ref wsdlin .</div><div class="line"><a name="l00845"></a><span class="lineno">  845</span>&#160;</div><div class="line"><a name="l00846"></a><span class="lineno">  846</span>&#160;The service definition `calc.h` header file is further processed by the</div><div class="line"><a name="l00847"></a><span class="lineno">  847</span>&#160;gSOAP `soapcpp2` compiler to generate the gluing code&#39;s logic to invoke</div><div class="line"><a name="l00848"></a><span class="lineno">  848</span>&#160;the Web service from a client.</div><div class="line"><a name="l00849"></a><span class="lineno">  849</span>&#160;</div><div class="line"><a name="l00850"></a><span class="lineno">  850</span>&#160;Looking into the file `calc.h` we see that the SOAP service methods are</div><div class="line"><a name="l00851"></a><span class="lineno">  851</span>&#160;specified as **function prototypes**. For example, the `add` function to add two double floats:</div><div class="line"><a name="l00852"></a><span class="lineno">  852</span>&#160;</div><div class="line"><a name="l00853"></a><span class="lineno">  853</span>&#160;```cpp</div><div class="line"><a name="l00854"></a><span class="lineno">  854</span>&#160;int ns2__add(double a, double b, double&amp; result);</div><div class="line"><a name="l00855"></a><span class="lineno">  855</span>&#160;```</div><div class="line"><a name="l00856"></a><span class="lineno">  856</span>&#160;</div><div class="line"><a name="l00857"></a><span class="lineno">  857</span>&#160;The `ns2__add` function uses an XML namespace prefix to distinguish it</div><div class="line"><a name="l00858"></a><span class="lineno">  858</span>&#160;from operations defined in other namespaces, thus preventing name clashes. The</div><div class="line"><a name="l00859"></a><span class="lineno">  859</span>&#160;convention to add an XML namespace prefix to the names of operations, types,</div><div class="line"><a name="l00860"></a><span class="lineno">  860</span>&#160;and `struct` and `class` members is universally used by the gSOAP</div><div class="line"><a name="l00861"></a><span class="lineno">  861</span>&#160;tools and automatically created by `wsdl2h`, but it is not mandatory when</div><div class="line"><a name="l00862"></a><span class="lineno">  862</span>&#160;translating existing C/C++ types and operations to web services. Thus, the</div><div class="line"><a name="l00863"></a><span class="lineno">  863</span>&#160;prefix notation can be omitted from type names defined in an header file with</div><div class="line"><a name="l00864"></a><span class="lineno">  864</span>&#160;to run `soapcpp2` to create clients and services that exchange existing</div><div class="line"><a name="l00865"></a><span class="lineno">  865</span>&#160;(i.e. application-native) data types.</div><div class="line"><a name="l00866"></a><span class="lineno">  866</span>&#160;</div><div class="line"><a name="l00867"></a><span class="lineno">  867</span>&#160;These function prototypes are translated by the gSOAP `soapcpp2` tool to stubs and proxies for remote calls:</div><div class="line"><a name="l00868"></a><span class="lineno">  868</span>&#160;</div><div class="line"><a name="l00869"></a><span class="lineno">  869</span>&#160;* `soapStub.h` annotated copy of the input definitions </div><div class="line"><a name="l00870"></a><span class="lineno">  870</span>&#160;</div><div class="line"><a name="l00871"></a><span class="lineno">  871</span>&#160;* `soapH.h` serializers </div><div class="line"><a name="l00872"></a><span class="lineno">  872</span>&#160;</div><div class="line"><a name="l00873"></a><span class="lineno">  873</span>&#160;* `soapC.cpp` serializers </div><div class="line"><a name="l00874"></a><span class="lineno">  874</span>&#160;</div><div class="line"><a name="l00875"></a><span class="lineno">  875</span>&#160;* `soapClient.cpp` client calling stubs</div><div class="line"><a name="l00876"></a><span class="lineno">  876</span>&#160;</div><div class="line"><a name="l00877"></a><span class="lineno">  877</span>&#160;Thus, the logic of the generated stub routines allow C and</div><div class="line"><a name="l00878"></a><span class="lineno">  878</span>&#160;C++ client applications to seamlessly interact with existing SOAP Web services as illustrated by the client code example in the next section.</div><div class="line"><a name="l00879"></a><span class="lineno">  879</span>&#160;</div><div class="line"><a name="l00880"></a><span class="lineno">  880</span>&#160;The input and output parameters of a SOAP service operation may be primitive data</div><div class="line"><a name="l00881"></a><span class="lineno">  881</span>&#160;types or complex compound data types such as containers and pointer-based linked data structures. These are defined in the header file that is either generated by the WSDL parser or specified by hand.</div><div class="line"><a name="l00882"></a><span class="lineno">  882</span>&#160;The gSOAP `soapcpp2` tool automatically generates</div><div class="line"><a name="l00883"></a><span class="lineno">  883</span>&#160;**XML serializers** and **XML deserializers** for the data types to enable the generated</div><div class="line"><a name="l00884"></a><span class="lineno">  884</span>&#160;stub routines to encode and decode the contents of the parameters of the service operations </div><div class="line"><a name="l00885"></a><span class="lineno">  885</span>&#160;in SOAP/XML.</div><div class="line"><a name="l00886"></a><span class="lineno">  886</span>&#160;</div><div class="line"><a name="l00887"></a><span class="lineno">  887</span>&#160;Note that the gSOAP `soapcpp2` tool also generates **skeleton**</div><div class="line"><a name="l00888"></a><span class="lineno">  888</span>&#160;routines `soapServer.cpp` for each of the service operations specified in the header file. The</div><div class="line"><a name="l00889"></a><span class="lineno">  889</span>&#160;skeleton routines</div><div class="line"><a name="l00890"></a><span class="lineno">  890</span>&#160;can be readily used to implement one or more of the service operations in a new</div><div class="line"><a name="l00891"></a><span class="lineno">  891</span>&#160;SOAP Web service. These skeleton routines are not used for building SOAP</div><div class="line"><a name="l00892"></a><span class="lineno">  892</span>&#160;clients in C++, although they can be used to build mixed SOAP client/server</div><div class="line"><a name="l00893"></a><span class="lineno">  893</span>&#160;applications (peer applications).</div><div class="line"><a name="l00894"></a><span class="lineno">  894</span>&#160;</div><div class="line"><a name="l00895"></a><span class="lineno">  895</span>&#160;### Example        {#example1}</div><div class="line"><a name="l00896"></a><span class="lineno">  896</span>&#160;</div><div class="line"><a name="l00897"></a><span class="lineno">  897</span>&#160;The `add` service operation (declared in the `calc.h` file obtained</div><div class="line"><a name="l00898"></a><span class="lineno">  898</span>&#160;with the `wsdl2h` tool in the previous section) adds two float values.</div><div class="line"><a name="l00899"></a><span class="lineno">  899</span>&#160;The WSDL description of the service provides the endpoint to invoke the service operations and the XML namespace used by the operations:</div><div class="line"><a name="l00900"></a><span class="lineno">  900</span>&#160;</div><div class="line"><a name="l00901"></a><span class="lineno">  901</span>&#160;* Endpoint URL: *`http://websrv.cs.fsu.edu/~engelen/calcserver.cgi`* </div><div class="line"><a name="l00902"></a><span class="lineno">  902</span>&#160;</div><div class="line"><a name="l00903"></a><span class="lineno">  903</span>&#160;* XML namespace: *`urn:calc`*</div><div class="line"><a name="l00904"></a><span class="lineno">  904</span>&#160;</div><div class="line"><a name="l00905"></a><span class="lineno">  905</span>&#160;Each service operation has a SOAP action, which is an optional string to</div><div class="line"><a name="l00906"></a><span class="lineno">  906</span>&#160;identify the operation (mainly used with WS-Addressing), an operation request</div><div class="line"><a name="l00907"></a><span class="lineno">  907</span>&#160;message and a response message. The request and response messages for SOAP</div><div class="line"><a name="l00908"></a><span class="lineno">  908</span>&#160;RPC-encoded services are simply represented by C functions with input and</div><div class="line"><a name="l00909"></a><span class="lineno">  909</span>&#160;output parameters. For the `add` operation, the SOAP binding details are:</div><div class="line"><a name="l00910"></a><span class="lineno">  910</span>&#160;</div><div class="line"><a name="l00911"></a><span class="lineno">  911</span>&#160;* SOAP style: RPC </div><div class="line"><a name="l00912"></a><span class="lineno">  912</span>&#160;</div><div class="line"><a name="l00913"></a><span class="lineno">  913</span>&#160;* SOAP encoding: encoded </div><div class="line"><a name="l00914"></a><span class="lineno">  914</span>&#160;</div><div class="line"><a name="l00915"></a><span class="lineno">  915</span>&#160;* SOAP action: *`&quot;&quot;`* (empty string)</div><div class="line"><a name="l00916"></a><span class="lineno">  916</span>&#160;</div><div class="line"><a name="l00917"></a><span class="lineno">  917</span>&#160;This information is translated to the `wsdl2h`-generated header file with the service definitions.</div><div class="line"><a name="l00918"></a><span class="lineno">  918</span>&#160;The `calc.h` header file for C++ generated by `wsdl2h` contains the following directives and declarations:</div><div class="line"><a name="l00919"></a><span class="lineno">  919</span>&#160;(the actual contents may vary depending on the release version and the options used to control the output):</div><div class="line"><a name="l00920"></a><span class="lineno">  920</span>&#160;</div><div class="line"><a name="l00921"></a><span class="lineno">  921</span>&#160;```cpp</div><div class="line"><a name="l00922"></a><span class="lineno">  922</span>&#160;//gsoap ns2 service name:       calc</div><div class="line"><a name="l00923"></a><span class="lineno">  923</span>&#160;//gsoap ns2 service type:       calcPortType</div><div class="line"><a name="l00924"></a><span class="lineno">  924</span>&#160;//gsoap ns2 service port:       http://websrv.cs.fsu.edu/~engelen/calcserver.cgi </div><div class="line"><a name="l00925"></a><span class="lineno">  925</span>&#160;//gsoap ns2 service namespace:  urn:calc </div><div class="line"><a name="l00926"></a><span class="lineno">  926</span>&#160;</div><div class="line"><a name="l00927"></a><span class="lineno">  927</span>&#160;//gsoap ns2 service method-protocol:    add SOAP </div><div class="line"><a name="l00928"></a><span class="lineno">  928</span>&#160;//gsoap ns2 service method-style:       add rpc </div><div class="line"><a name="l00929"></a><span class="lineno">  929</span>&#160;//gsoap ns2 service method-encoding:    add http://schemas.xmlsoap.org/soap/encoding/ </div><div class="line"><a name="l00930"></a><span class="lineno">  930</span>&#160;//gsoap ns2 service method-action:      add &quot;&quot; </div><div class="line"><a name="l00931"></a><span class="lineno">  931</span>&#160;int ns2__add(double a, double b, double&amp; result);</div><div class="line"><a name="l00932"></a><span class="lineno">  932</span>&#160;```</div><div class="line"><a name="l00933"></a><span class="lineno">  933</span>&#160;</div><div class="line"><a name="l00934"></a><span class="lineno">  934</span>&#160;The other calculator operations are similar and elided here for clarity.</div><div class="line"><a name="l00935"></a><span class="lineno">  935</span>&#160;</div><div class="line"><a name="l00936"></a><span class="lineno">  936</span>&#160;The `//gsoap` directives are required for the</div><div class="line"><a name="l00937"></a><span class="lineno">  937</span>&#160;`soapcpp2` tool to generate code that is compliant to the SOAP protocol. For this service the SOAP protocol with the common &quot;RPC encoding style&quot; is used. For `//gsoap` directive details, see Section \ref directives .</div><div class="line"><a name="l00938"></a><span class="lineno">  938</span>&#160;</div><div class="line"><a name="l00939"></a><span class="lineno">  939</span>&#160;The service operations are declared as</div><div class="line"><a name="l00940"></a><span class="lineno">  940</span>&#160;function prototypes, with all non-primitive parameter types needed by the</div><div class="line"><a name="l00941"></a><span class="lineno">  941</span>&#160;operation declared in the header file (all parameter types are primitive in</div><div class="line"><a name="l00942"></a><span class="lineno">  942</span>&#160;this case).</div><div class="line"><a name="l00943"></a><span class="lineno">  943</span>&#160;</div><div class="line"><a name="l00944"></a><span class="lineno">  944</span>&#160;The calculator `add` operation takes two double floats `a` and `b`,</div><div class="line"><a name="l00945"></a><span class="lineno">  945</span>&#160;and returns the sum in `result`. By convention, **all parameters are input</div><div class="line"><a name="l00946"></a><span class="lineno">  946</span>&#160;parameters except the last**. The last parameter is al**ways the output parameter.</div><div class="line"><a name="l00947"></a><span class="lineno">  947</span>&#160;A `struct` or `class` is used to wrap multiple output parameters, see</div><div class="line"><a name="l00948"></a><span class="lineno">  948</span>&#160;also Section \ref multiple . This last parameter must be a pointer or</div><div class="line"><a name="l00949"></a><span class="lineno">  949</span>&#160;reference. By contrast, the input parameters support pass by value or by</div><div class="line"><a name="l00950"></a><span class="lineno">  950</span>&#160;pointer, but not pass by C++ reference.</div><div class="line"><a name="l00951"></a><span class="lineno">  951</span>&#160;</div><div class="line"><a name="l00952"></a><span class="lineno">  952</span>&#160;The function prototype associated with a service operation always returns an</div><div class="line"><a name="l00953"></a><span class="lineno">  953</span>&#160;`int`. The value indicates success (`0` or equivalently</div><div class="line"><a name="l00954"></a><span class="lineno">  954</span>&#160;`SOAP_OK`) or failure (any nonzero value). See Section \ref errcodes </div><div class="line"><a name="l00955"></a><span class="lineno">  955</span>&#160;for the nonzero error codes. </div><div class="line"><a name="l00956"></a><span class="lineno">  956</span>&#160;</div><div class="line"><a name="l00957"></a><span class="lineno">  957</span>&#160;The role of the namespace prefix (`ns2__`) in the service operation name in the</div><div class="line"><a name="l00958"></a><span class="lineno">  958</span>&#160;function prototype declaration is discussed in detail in \ref namespace .</div><div class="line"><a name="l00959"></a><span class="lineno">  959</span>&#160;Basically, a namespace prefix is added to a function name or type name with a **pair of underscores**,</div><div class="line"><a name="l00960"></a><span class="lineno">  960</span>&#160;as in `ns2__add`, where `ns2` is the</div><div class="line"><a name="l00961"></a><span class="lineno">  961</span>&#160;namespace prefix and `add` is the service operation name. This mechanism ensures uniqueness of operations and types associated with a service.</div><div class="line"><a name="l00962"></a><span class="lineno">  962</span>&#160;</div><div class="line"><a name="l00963"></a><span class="lineno">  963</span>&#160;It is strongly recommended to set the namespace prefix to a name of your</div><div class="line"><a name="l00964"></a><span class="lineno">  964</span>&#160;choice. This avoids problems when running `wsdl2h` on multiple WSDLs where</div><div class="line"><a name="l00965"></a><span class="lineno">  965</span>&#160;the sequence of prefixes `ns1`, `ns2`, and so on are arbitrarily</div><div class="line"><a name="l00966"></a><span class="lineno">  966</span>&#160;assigned to the services. To choose a prefix name for all the operations and types of a service, say prefix `c__` for the calculator service, add the following line to `typemap.dat`:</div><div class="line"><a name="l00967"></a><span class="lineno">  967</span>&#160;</div><div class="line"><a name="l00968"></a><span class="lineno">  968</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l00969"></a><span class="lineno">  969</span>&#160;```xml</div><div class="line"><a name="l00970"></a><span class="lineno">  970</span>&#160;c = &quot;urn:calc&quot;</div><div class="line"><a name="l00971"></a><span class="lineno">  971</span>&#160;```</div><div class="line"><a name="l00972"></a><span class="lineno">  972</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l00973"></a><span class="lineno">  973</span>&#160;</div><div class="line"><a name="l00974"></a><span class="lineno">  974</span>&#160;and rerun `wsdl2h`. The `typemap.dat` configures `wsdl2h` to use</div><div class="line"><a name="l00975"></a><span class="lineno">  975</span>&#160;specific bindings and data types for services. The result is that `c__add` is used to uniquely identify the operation rather than the more arbitrary name `ns2__add`.</div><div class="line"><a name="l00976"></a><span class="lineno">  976</span>&#160;</div><div class="line"><a name="l00977"></a><span class="lineno">  977</span>&#160;Note on the use of underscores in names: a single</div><div class="line"><a name="l00978"></a><span class="lineno">  978</span>&#160;underscore in an identifier name will be translated into a dash in XML, because</div><div class="line"><a name="l00979"></a><span class="lineno">  979</span>&#160;dashes are more frequently used in XML compared to underscores, see</div><div class="line"><a name="l00980"></a><span class="lineno">  980</span>&#160;Section \ref idtrans .</div><div class="line"><a name="l00981"></a><span class="lineno">  981</span>&#160;</div><div class="line"><a name="l00982"></a><span class="lineno">  982</span>&#160;Next, the gSOAP `soapcpp2` tool is invoked from the command line to process the `calc.h` service definitions:</div><div class="line"><a name="l00983"></a><span class="lineno">  983</span>&#160;</div><div class="line"><a name="l00984"></a><span class="lineno">  984</span>&#160;    &gt; soapcpp2 calc.h</div><div class="line"><a name="l00985"></a><span class="lineno">  985</span>&#160;</div><div class="line"><a name="l00986"></a><span class="lineno">  986</span>&#160;The tool generates the stub routines for the service operations.</div><div class="line"><a name="l00987"></a><span class="lineno">  987</span>&#160;Stub routines can be invoked</div><div class="line"><a name="l00988"></a><span class="lineno">  988</span>&#160;by a client program to invoke the remote service operations.</div><div class="line"><a name="l00989"></a><span class="lineno">  989</span>&#160;The interface of the generated stub routine is identical to the function prototype in the `calc.h` service defintion file, but with additional parameters to pass the gSOAP engine&#39;s runtime context `soap`, an endpoint URL (or NULL for the default), and a SOAP action (or NULL for the default):</div><div class="line"><a name="l00990"></a><span class="lineno">  990</span>&#160;</div><div class="line"><a name="l00991"></a><span class="lineno">  991</span>&#160;```cpp</div><div class="line"><a name="l00992"></a><span class="lineno">  992</span>&#160;int soap_call_c__add(struct soap *soap, char *URL, char *action, double a, double b, double&amp; result);</div><div class="line"><a name="l00993"></a><span class="lineno">  993</span>&#160;```</div><div class="line"><a name="l00994"></a><span class="lineno">  994</span>&#160;</div><div class="line"><a name="l00995"></a><span class="lineno">  995</span>&#160;This stub routine is saved in `soapClient.cpp`. The file `soapC.cpp`</div><div class="line"><a name="l00996"></a><span class="lineno">  996</span>&#160;contains the **serializer** and **deserializer** routines for the data</div><div class="line"><a name="l00997"></a><span class="lineno">  997</span>&#160;types used by the stub. You can use option `-c` for the `soapcpp2` tool to</div><div class="line"><a name="l00998"></a><span class="lineno">  998</span>&#160;generate pure C code, when needed.</div><div class="line"><a name="l00999"></a><span class="lineno">  999</span>&#160;</div><div class="line"><a name="l01000"></a><span class="lineno"> 1000</span>&#160;Note: the `soap` parameter must be a valid pointer to a gSOAP runtime</div><div class="line"><a name="l01001"></a><span class="lineno"> 1001</span>&#160;context. The `URL` can be set to override the default endpoint address (the endpoint defined by the WSDL).</div><div class="line"><a name="l01002"></a><span class="lineno"> 1002</span>&#160;The `action` parameter can be set to override the default SOAP action.</div><div class="line"><a name="l01003"></a><span class="lineno"> 1003</span>&#160;</div><div class="line"><a name="l01004"></a><span class="lineno"> 1004</span>&#160;The following example C/C++ client program uses the stub:</div><div class="line"><a name="l01005"></a><span class="lineno"> 1005</span>&#160;</div><div class="line"><a name="l01006"></a><span class="lineno"> 1006</span>&#160;```cpp</div><div class="line"><a name="l01007"></a><span class="lineno"> 1007</span>&#160;#include &quot;soapH.h&quot; // include all interfaces (library and generated) </div><div class="line"><a name="l01008"></a><span class="lineno"> 1008</span>&#160;#include &quot;calc.nsmap&quot; // import the generated namespace mapping table </div><div class="line"><a name="l01009"></a><span class="lineno"> 1009</span>&#160;int main() </div><div class="line"><a name="l01010"></a><span class="lineno"> 1010</span>&#160;{ </div><div class="line"><a name="l01011"></a><span class="lineno"> 1011</span>&#160;  double sum; </div><div class="line"><a name="l01012"></a><span class="lineno"> 1012</span>&#160;  struct soap soap; // the gSOAP runtime context </div><div class="line"><a name="l01013"></a><span class="lineno"> 1013</span>&#160;   soap_init(&amp;soap); // initialize the context (only once!) </div><div class="line"><a name="l01014"></a><span class="lineno"> 1014</span>&#160;  if (soap_call_c__add(&amp;soap, NULL, NULL, 1.0, 2.0, &amp;sum) == SOAP_OK) </div><div class="line"><a name="l01015"></a><span class="lineno"> 1015</span>&#160;     std::cout &lt;&lt; &quot;Sum = &quot; &lt;&lt; sum &lt;&lt; std::endl; </div><div class="line"><a name="l01016"></a><span class="lineno"> 1016</span>&#160;  else // an error occurred </div><div class="line"><a name="l01017"></a><span class="lineno"> 1017</span>&#160;     soap_print_fault(&amp;soap, stderr); // display the SOAP fault message on the stderr stream </div><div class="line"><a name="l01018"></a><span class="lineno"> 1018</span>&#160;   soap_destroy(&amp;soap); // delete deserialized class instances (for C++) </div><div class="line"><a name="l01019"></a><span class="lineno"> 1019</span>&#160;   soap_end(&amp;soap); // remove deserialized data and clean up </div><div class="line"><a name="l01020"></a><span class="lineno"> 1020</span>&#160;   soap_done(&amp;soap); // detach the gSOAP context </div><div class="line"><a name="l01021"></a><span class="lineno"> 1021</span>&#160;   return 0; </div><div class="line"><a name="l01022"></a><span class="lineno"> 1022</span>&#160;}</div><div class="line"><a name="l01023"></a><span class="lineno"> 1023</span>&#160;```</div><div class="line"><a name="l01024"></a><span class="lineno"> 1024</span>&#160;</div><div class="line"><a name="l01025"></a><span class="lineno"> 1025</span>&#160;The call returns `SOAP_OK` (zero) on success and a nonzero error on</div><div class="line"><a name="l01026"></a><span class="lineno"> 1026</span>&#160;failure.  When an error occurred the fault is displayed with the</div><div class="line"><a name="l01027"></a><span class="lineno"> 1027</span>&#160;`soap_print_fault` function. Use `soap_sprint_fault(struct soap*, char *buf, size_t len)` to print the error to a string, and use `soap_stream_fault(struct soap*, std::ostream&amp;)` to send it to a stream (C++ only).</div><div class="line"><a name="l01028"></a><span class="lineno"> 1028</span>&#160;</div><div class="line"><a name="l01029"></a><span class="lineno"> 1029</span>&#160;The following functions can be used to explicitly setup a gSOAP runtime context (`struct soap`):</div><div class="line"><a name="l01030"></a><span class="lineno"> 1030</span>&#160;</div><div class="line"><a name="l01031"></a><span class="lineno"> 1031</span>&#160;* `soap_init(struct soap *soap)` Initializes a runtime context </div><div class="line"><a name="l01032"></a><span class="lineno"> 1032</span>&#160;</div><div class="line"><a name="l01033"></a><span class="lineno"> 1033</span>&#160;* `soap_init1(struct soap *soap, soap_mode iomode)` Initializes a runtime context and set in/out mode flags </div><div class="line"><a name="l01034"></a><span class="lineno"> 1034</span>&#160;</div><div class="line"><a name="l01035"></a><span class="lineno"> 1035</span>&#160;* `soap_init2(struct soap *soap, soap_mode imode, soap_mode omode)` Initializes a runtime context and set in/out mode flags </div><div class="line"><a name="l01036"></a><span class="lineno"> 1036</span>&#160;</div><div class="line"><a name="l01037"></a><span class="lineno"> 1037</span>&#160;* `struct soap *soap_new()` Allocates, initializes, and returns a pointer to a runtime context </div><div class="line"><a name="l01038"></a><span class="lineno"> 1038</span>&#160;</div><div class="line"><a name="l01039"></a><span class="lineno"> 1039</span>&#160;* `struct soap *soap_new1(soap_mode iomode)` Allocates, initializes, and returns a pointer to a runtime context and set in/out mode flags </div><div class="line"><a name="l01040"></a><span class="lineno"> 1040</span>&#160;</div><div class="line"><a name="l01041"></a><span class="lineno"> 1041</span>&#160;* `struct soap *soap_new2(soap_mode imode, soap_mode omode)` Allocates, initializes, and returns a pointer to a runtime context and set in/out mode flags </div><div class="line"><a name="l01042"></a><span class="lineno"> 1042</span>&#160;</div><div class="line"><a name="l01043"></a><span class="lineno"> 1043</span>&#160;* `struct soap *soap_copy(struct soap *soap)` Allocates a new runtime context and copies a context (deep copy, i.e. the new context does not share any data with the other context) </div><div class="line"><a name="l01044"></a><span class="lineno"> 1044</span>&#160;</div><div class="line"><a name="l01045"></a><span class="lineno"> 1045</span>&#160;* `soap_done(struct soap *soap)` Reset, close communications, and remove callbacks </div><div class="line"><a name="l01046"></a><span class="lineno"> 1046</span>&#160;</div><div class="line"><a name="l01047"></a><span class="lineno"> 1047</span>&#160;* `soap_free(struct soap *soap)` Reset and deallocate the context created with `soap_new` or `soap_copy` </div><div class="line"><a name="l01048"></a><span class="lineno"> 1048</span>&#160;</div><div class="line"><a name="l01049"></a><span class="lineno"> 1049</span>&#160;A runtime context can be reused as many times as necessary for client-side remote calls and does not need to be reinitialized in doing so.</div><div class="line"><a name="l01050"></a><span class="lineno"> 1050</span>&#160;A new context is required for each new thread to guarantee exclusive access</div><div class="line"><a name="l01051"></a><span class="lineno"> 1051</span>&#160;to runtime context by threads.  Also the use of any client calls within an active service method requires a new context.</div><div class="line"><a name="l01052"></a><span class="lineno"> 1052</span>&#160;</div><div class="line"><a name="l01053"></a><span class="lineno"> 1053</span>&#160;The `soapcpp2` code generator tool also generates a service proxy class for C++ client applications (and service objects for server applications) with the `-i` (or `-j`) option:</div><div class="line"><a name="l01054"></a><span class="lineno"> 1054</span>&#160;</div><div class="line"><a name="l01055"></a><span class="lineno"> 1055</span>&#160;    &gt; soapcpp2 -i calc.h</div><div class="line"><a name="l01056"></a><span class="lineno"> 1056</span>&#160;</div><div class="line"><a name="l01057"></a><span class="lineno"> 1057</span>&#160;The proxy is defined in:</div><div class="line"><a name="l01058"></a><span class="lineno"> 1058</span>&#160;</div><div class="line"><a name="l01059"></a><span class="lineno"> 1059</span>&#160;* `soapcalcProxy.h` client proxy class </div><div class="line"><a name="l01060"></a><span class="lineno"> 1060</span>&#160;</div><div class="line"><a name="l01061"></a><span class="lineno"> 1061</span>&#160;* `soapcalcProxy.cpp` client proxy class</div><div class="line"><a name="l01062"></a><span class="lineno"> 1062</span>&#160;</div><div class="line"><a name="l01063"></a><span class="lineno"> 1063</span>&#160;Note: without the `-i` option only old-style service proxies and objects</div><div class="line"><a name="l01064"></a><span class="lineno"> 1064</span>&#160;are generated, which are less flexible and no longer recommended. Use `-j`</div><div class="line"><a name="l01065"></a><span class="lineno"> 1065</span>&#160;as an alternative to `-i` to generate classes with the same functionality,</div><div class="line"><a name="l01066"></a><span class="lineno"> 1066</span>&#160;but that are not inherited from `struct soap` and use a pointer to a</div><div class="line"><a name="l01067"></a><span class="lineno"> 1067</span>&#160;`struct soap` engine context that can be shared with other proxy and</div><div class="line"><a name="l01068"></a><span class="lineno"> 1068</span>&#160;service class instances. This choice is also important when services are chained, see Section \ref chaining .</div><div class="line"><a name="l01069"></a><span class="lineno"> 1069</span>&#160;</div><div class="line"><a name="l01070"></a><span class="lineno"> 1070</span>&#160;The generated C++ proxy class initializes the gSOAP runtime context and offers the service interface as a collection of methods:</div><div class="line"><a name="l01071"></a><span class="lineno"> 1071</span>&#160;</div><div class="line"><a name="l01072"></a><span class="lineno"> 1072</span>&#160;```cpp</div><div class="line"><a name="l01073"></a><span class="lineno"> 1073</span>&#160;#include &quot;soapcalcProxy.h&quot; // get proxy </div><div class="line"><a name="l01074"></a><span class="lineno"> 1074</span>&#160;#include &quot;calc.nsmap&quot; // import the generated namespace mapping table </div><div class="line"><a name="l01075"></a><span class="lineno"> 1075</span>&#160;int main() </div><div class="line"><a name="l01076"></a><span class="lineno"> 1076</span>&#160;{ </div><div class="line"><a name="l01077"></a><span class="lineno"> 1077</span>&#160;   calcProxy calc(SOAP_XML_INDENT); </div><div class="line"><a name="l01078"></a><span class="lineno"> 1078</span>&#160;   double sum; </div><div class="line"><a name="l01079"></a><span class="lineno"> 1079</span>&#160;   if (calc.add(1.0, 2.0, sum) == SOAP_OK) </div><div class="line"><a name="l01080"></a><span class="lineno"> 1080</span>&#160;     std::cout &lt;&lt; &quot;Sum = &quot; &lt;&lt; sum &lt;&lt; std::endl; </div><div class="line"><a name="l01081"></a><span class="lineno"> 1081</span>&#160;   else </div><div class="line"><a name="l01082"></a><span class="lineno"> 1082</span>&#160;     calc.soap_stream_fault(std::cerr); </div><div class="line"><a name="l01083"></a><span class="lineno"> 1083</span>&#160;   return calc.error; // nonzero when error </div><div class="line"><a name="l01084"></a><span class="lineno"> 1084</span>&#160;}</div><div class="line"><a name="l01085"></a><span class="lineno"> 1085</span>&#160;```</div><div class="line"><a name="l01086"></a><span class="lineno"> 1086</span>&#160;</div><div class="line"><a name="l01087"></a><span class="lineno"> 1087</span>&#160;The proxy class is derived from the gSOAP runtime context structure</div><div class="line"><a name="l01088"></a><span class="lineno"> 1088</span>&#160;`struct soap` and thus inherits (option `-i`) all state information</div><div class="line"><a name="l01089"></a><span class="lineno"> 1089</span>&#160;of the runtime. The proxy constructor takes context mode parameters to initialize the context, e.g. `SOAP_XML_INDENT` in this example.</div><div class="line"><a name="l01090"></a><span class="lineno"> 1090</span>&#160;</div><div class="line"><a name="l01091"></a><span class="lineno"> 1091</span>&#160;The code is compiled and linked with `soapcalcProxy.cpp`, `soapC.cpp`,</div><div class="line"><a name="l01092"></a><span class="lineno"> 1092</span>&#160;and `stdsoap2.cpp` (or use `libgsoap++.a`).</div><div class="line"><a name="l01093"></a><span class="lineno"> 1093</span>&#160;</div><div class="line"><a name="l01094"></a><span class="lineno"> 1094</span>&#160;The proxy class name is extracted from the WSDL content and may not always be in a short format. Feel free to change the entry</div><div class="line"><a name="l01095"></a><span class="lineno"> 1095</span>&#160;</div><div class="line"><a name="l01096"></a><span class="lineno"> 1096</span>&#160;```cpp</div><div class="line"><a name="l01097"></a><span class="lineno"> 1097</span>&#160;//gsoap ns2 service name: calc</div><div class="line"><a name="l01098"></a><span class="lineno"> 1098</span>&#160;```</div><div class="line"><a name="l01099"></a><span class="lineno"> 1099</span>&#160;</div><div class="line"><a name="l01100"></a><span class="lineno"> 1100</span>&#160;and rerun `soapcpp2` to generate code that uses the new name.</div><div class="line"><a name="l01101"></a><span class="lineno"> 1101</span>&#160;</div><div class="line"><a name="l01102"></a><span class="lineno"> 1102</span>&#160;When the example client application is invoked, a SOAP request is performed:</div><div class="line"><a name="l01103"></a><span class="lineno"> 1103</span>&#160;</div><div class="line"><a name="l01104"></a><span class="lineno"> 1104</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l01105"></a><span class="lineno"> 1105</span>&#160;```xml</div><div class="line"><a name="l01106"></a><span class="lineno"> 1106</span>&#160;POST /~engelen/calcserver.cgi HTTP/1.1 </div><div class="line"><a name="l01107"></a><span class="lineno"> 1107</span>&#160;Host: websrv.cs.fsu.edu </div><div class="line"><a name="l01108"></a><span class="lineno"> 1108</span>&#160;User-Agent: gSOAP/2.7 </div><div class="line"><a name="l01109"></a><span class="lineno"> 1109</span>&#160;Content-Type: text/xml; charset=utf-8 </div><div class="line"><a name="l01110"></a><span class="lineno"> 1110</span>&#160;Content-Length: 464 </div><div class="line"><a name="l01111"></a><span class="lineno"> 1111</span>&#160;Connection: close </div><div class="line"><a name="l01112"></a><span class="lineno"> 1112</span>&#160;SOAPAction: &quot;&quot; </div><div class="line"><a name="l01113"></a><span class="lineno"> 1113</span>&#160; </div><div class="line"><a name="l01114"></a><span class="lineno"> 1114</span>&#160;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; </div><div class="line"><a name="l01115"></a><span class="lineno"> 1115</span>&#160;&lt;SOAP-ENV:Envelope </div><div class="line"><a name="l01116"></a><span class="lineno"> 1116</span>&#160;  xmlns:SOAP-ENV=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; </div><div class="line"><a name="l01117"></a><span class="lineno"> 1117</span>&#160;  xmlns:SOAP-ENC=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot; </div><div class="line"><a name="l01118"></a><span class="lineno"> 1118</span>&#160;  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; </div><div class="line"><a name="l01119"></a><span class="lineno"> 1119</span>&#160;  xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; </div><div class="line"><a name="l01120"></a><span class="lineno"> 1120</span>&#160;  xmlns:c=&quot;urn:calc&quot;&gt; </div><div class="line"><a name="l01121"></a><span class="lineno"> 1121</span>&#160;  &lt;SOAP-ENV:Body SOAP-ENV:encodingStyle=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;&gt; </div><div class="line"><a name="l01122"></a><span class="lineno"> 1122</span>&#160;    &lt;c:add&gt; </div><div class="line"><a name="l01123"></a><span class="lineno"> 1123</span>&#160;      &lt;a&gt;1&lt;/a&gt; </div><div class="line"><a name="l01124"></a><span class="lineno"> 1124</span>&#160;      &lt;b&gt;2&lt;/b&gt; </div><div class="line"><a name="l01125"></a><span class="lineno"> 1125</span>&#160;    &lt;/c:add&gt; </div><div class="line"><a name="l01126"></a><span class="lineno"> 1126</span>&#160;  &lt;/SOAP-ENV:Body&gt; </div><div class="line"><a name="l01127"></a><span class="lineno"> 1127</span>&#160;&lt;/SOAP-ENV:Envelope&gt;</div><div class="line"><a name="l01128"></a><span class="lineno"> 1128</span>&#160;```</div><div class="line"><a name="l01129"></a><span class="lineno"> 1129</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l01130"></a><span class="lineno"> 1130</span>&#160;</div><div class="line"><a name="l01131"></a><span class="lineno"> 1131</span>&#160;The SOAP response message:</div><div class="line"><a name="l01132"></a><span class="lineno"> 1132</span>&#160;</div><div class="line"><a name="l01133"></a><span class="lineno"> 1133</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l01134"></a><span class="lineno"> 1134</span>&#160;```xml</div><div class="line"><a name="l01135"></a><span class="lineno"> 1135</span>&#160;HTTP/1.1 200 OK </div><div class="line"><a name="l01136"></a><span class="lineno"> 1136</span>&#160;Date: Wed, 05 May 2010 16:02:21 GMT </div><div class="line"><a name="l01137"></a><span class="lineno"> 1137</span>&#160;Server: Apache/2.0.52 (Scientific Linux) </div><div class="line"><a name="l01138"></a><span class="lineno"> 1138</span>&#160;Content-Length: 463 </div><div class="line"><a name="l01139"></a><span class="lineno"> 1139</span>&#160;Connection: close </div><div class="line"><a name="l01140"></a><span class="lineno"> 1140</span>&#160;Content-Type: text/xml; charset=utf-8 </div><div class="line"><a name="l01141"></a><span class="lineno"> 1141</span>&#160; </div><div class="line"><a name="l01142"></a><span class="lineno"> 1142</span>&#160;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; </div><div class="line"><a name="l01143"></a><span class="lineno"> 1143</span>&#160;&lt;SOAP-ENV:Envelope </div><div class="line"><a name="l01144"></a><span class="lineno"> 1144</span>&#160;   xmlns:SOAP-ENV=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; </div><div class="line"><a name="l01145"></a><span class="lineno"> 1145</span>&#160;   xmlns:SOAP-ENC=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot; </div><div class="line"><a name="l01146"></a><span class="lineno"> 1146</span>&#160;   xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; </div><div class="line"><a name="l01147"></a><span class="lineno"> 1147</span>&#160;   xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; </div><div class="line"><a name="l01148"></a><span class="lineno"> 1148</span>&#160;   xmlns:ns=&quot;urn:calc&quot;&gt; </div><div class="line"><a name="l01149"></a><span class="lineno"> 1149</span>&#160;   &lt;SOAP-ENV:Body SOAP-ENV:encodingStyle=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;&gt; </div><div class="line"><a name="l01150"></a><span class="lineno"> 1150</span>&#160;     &lt;ns:addResponse&gt; </div><div class="line"><a name="l01151"></a><span class="lineno"> 1151</span>&#160;       &lt;result&gt;3&lt;/result&gt; </div><div class="line"><a name="l01152"></a><span class="lineno"> 1152</span>&#160;     &lt;/ns:addResponse&gt; </div><div class="line"><a name="l01153"></a><span class="lineno"> 1153</span>&#160;   &lt;/SOAP-ENV:Body&gt; </div><div class="line"><a name="l01154"></a><span class="lineno"> 1154</span>&#160;&lt;/SOAP-ENV:Envelope&gt;</div><div class="line"><a name="l01155"></a><span class="lineno"> 1155</span>&#160;```</div><div class="line"><a name="l01156"></a><span class="lineno"> 1156</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l01157"></a><span class="lineno"> 1157</span>&#160;</div><div class="line"><a name="l01158"></a><span class="lineno"> 1158</span>&#160;A client can invoke a sequence of service operations:</div><div class="line"><a name="l01159"></a><span class="lineno"> 1159</span>&#160;</div><div class="line"><a name="l01160"></a><span class="lineno"> 1160</span>&#160;```cpp</div><div class="line"><a name="l01161"></a><span class="lineno"> 1161</span>&#160;#include &quot;soapcalcProxy.h&quot; // get proxy </div><div class="line"><a name="l01162"></a><span class="lineno"> 1162</span>&#160;#include &quot;calc.nsmap&quot; // import the generated namespace mapping table </div><div class="line"><a name="l01163"></a><span class="lineno"> 1163</span>&#160;int main() </div><div class="line"><a name="l01164"></a><span class="lineno"> 1164</span>&#160;{ </div><div class="line"><a name="l01165"></a><span class="lineno"> 1165</span>&#160;   calcProxy calc(SOAP_IO_KEEPALIVE); // keep-alive improves connection performance </div><div class="line"><a name="l01166"></a><span class="lineno"> 1166</span>&#160;   double sum = 0.0; </div><div class="line"><a name="l01167"></a><span class="lineno"> 1167</span>&#160;   double val[] = { 5.0, 3.5, 7.1, 1.2 }; </div><div class="line"><a name="l01168"></a><span class="lineno"> 1168</span>&#160;   for (int i = 0; i &lt; 4; i++) </div><div class="line"><a name="l01169"></a><span class="lineno"> 1169</span>&#160;     if (calc.add(sum, val[i], sum)) </div><div class="line"><a name="l01170"></a><span class="lineno"> 1170</span>&#160;       return calc.error; </div><div class="line"><a name="l01171"></a><span class="lineno"> 1171</span>&#160;   std::cout &lt;&lt; &quot;Sum = &quot; &lt;&lt; sum &lt;&lt; std::endl; </div><div class="line"><a name="l01172"></a><span class="lineno"> 1172</span>&#160;   return 0; </div><div class="line"><a name="l01173"></a><span class="lineno"> 1173</span>&#160;}</div><div class="line"><a name="l01174"></a><span class="lineno"> 1174</span>&#160;```</div><div class="line"><a name="l01175"></a><span class="lineno"> 1175</span>&#160;</div><div class="line"><a name="l01176"></a><span class="lineno"> 1176</span>&#160;In the above, no data is deallocated until the proxy is deleted. To deallocate deserialized data between the calls, use:</div><div class="line"><a name="l01177"></a><span class="lineno"> 1177</span>&#160;</div><div class="line"><a name="l01178"></a><span class="lineno"> 1178</span>&#160;```cpp</div><div class="line"><a name="l01179"></a><span class="lineno"> 1179</span>&#160;   for (int i = 0; i &lt; 4; i++) </div><div class="line"><a name="l01180"></a><span class="lineno"> 1180</span>&#160;   { </div><div class="line"><a name="l01181"></a><span class="lineno"> 1181</span>&#160;     if (calc.add(sum, val[i], sum)) </div><div class="line"><a name="l01182"></a><span class="lineno"> 1182</span>&#160;       return calc.error; </div><div class="line"><a name="l01183"></a><span class="lineno"> 1183</span>&#160;     calc.destroy(); </div><div class="line"><a name="l01184"></a><span class="lineno"> 1184</span>&#160;   }</div><div class="line"><a name="l01185"></a><span class="lineno"> 1185</span>&#160;```</div><div class="line"><a name="l01186"></a><span class="lineno"> 1186</span>&#160;</div><div class="line"><a name="l01187"></a><span class="lineno"> 1187</span>&#160;Deallocation is safe here, since the float values were copied and saved in</div><div class="line"><a name="l01188"></a><span class="lineno"> 1188</span>&#160;`sum`. In other scenarios one must make sure data is copied or removed from</div><div class="line"><a name="l01189"></a><span class="lineno"> 1189</span>&#160;the deallocation chain with:</div><div class="line"><a name="l01190"></a><span class="lineno"> 1190</span>&#160;</div><div class="line"><a name="l01191"></a><span class="lineno"> 1191</span>&#160;```cpp</div><div class="line"><a name="l01192"></a><span class="lineno"> 1192</span>&#160;soap_unlink(struct soap *soap, const void *data)</div><div class="line"><a name="l01193"></a><span class="lineno"> 1193</span>&#160;```</div><div class="line"><a name="l01194"></a><span class="lineno"> 1194</span>&#160;</div><div class="line"><a name="l01195"></a><span class="lineno"> 1195</span>&#160;which is to be invoked on each data item to be preserved, before destroying deallocated data. When the proxy is deleted, also all deserialized data is deleted. To delegate deletion to another runtime context for later removal, use:</div><div class="line"><a name="l01196"></a><span class="lineno"> 1196</span>&#160;</div><div class="line"><a name="l01197"></a><span class="lineno"> 1197</span>&#160;```cpp</div><div class="line"><a name="l01198"></a><span class="lineno"> 1198</span>&#160;soap_delegate_deletion(struct soap *soap_from, struct soap *soap_to)</div><div class="line"><a name="l01199"></a><span class="lineno"> 1199</span>&#160;```</div><div class="line"><a name="l01200"></a><span class="lineno"> 1200</span>&#160;</div><div class="line"><a name="l01201"></a><span class="lineno"> 1201</span>&#160;For example</div><div class="line"><a name="l01202"></a><span class="lineno"> 1202</span>&#160;</div><div class="line"><a name="l01203"></a><span class="lineno"> 1203</span>&#160;```cpp</div><div class="line"><a name="l01204"></a><span class="lineno"> 1204</span>&#160;struct soap soap; </div><div class="line"><a name="l01205"></a><span class="lineno"> 1205</span>&#160;soap_init(&amp;soap); </div><div class="line"><a name="l01206"></a><span class="lineno"> 1206</span>&#160;{ // create proxy </div><div class="line"><a name="l01207"></a><span class="lineno"> 1207</span>&#160;   calcProxy calc; </div><div class="line"><a name="l01208"></a><span class="lineno"> 1208</span>&#160;   ... data generated ... </div><div class="line"><a name="l01209"></a><span class="lineno"> 1209</span>&#160;   soap_delegate_deletion(&amp;calc, &amp;soap); </div><div class="line"><a name="l01210"></a><span class="lineno"> 1210</span>&#160;} // proxy deleted </div><div class="line"><a name="l01211"></a><span class="lineno"> 1211</span>&#160;... data used ... </div><div class="line"><a name="l01212"></a><span class="lineno"> 1212</span>&#160;soap_destroy(&amp;soap); </div><div class="line"><a name="l01213"></a><span class="lineno"> 1213</span>&#160;soap_end(&amp;soap); </div><div class="line"><a name="l01214"></a><span class="lineno"> 1214</span>&#160;soap_done(&amp;soap);</div><div class="line"><a name="l01215"></a><span class="lineno"> 1215</span>&#160;```</div><div class="line"><a name="l01216"></a><span class="lineno"> 1216</span>&#160;</div><div class="line"><a name="l01217"></a><span class="lineno"> 1217</span>&#160;In C (use `wsdl2h -c`) the example program would be written as:</div><div class="line"><a name="l01218"></a><span class="lineno"> 1218</span>&#160;</div><div class="line"><a name="l01219"></a><span class="lineno"> 1219</span>&#160;```cpp</div><div class="line"><a name="l01220"></a><span class="lineno"> 1220</span>&#160;#include &quot;soapH.h&quot; </div><div class="line"><a name="l01221"></a><span class="lineno"> 1221</span>&#160;#include &quot;calc.nsmap&quot; </div><div class="line"><a name="l01222"></a><span class="lineno"> 1222</span>&#160;int main() </div><div class="line"><a name="l01223"></a><span class="lineno"> 1223</span>&#160;{ </div><div class="line"><a name="l01224"></a><span class="lineno"> 1224</span>&#160;   struct soap soap; </div><div class="line"><a name="l01225"></a><span class="lineno"> 1225</span>&#160;   double sum = 0.0; </div><div class="line"><a name="l01226"></a><span class="lineno"> 1226</span>&#160;   double val[] = { 5.0, 3.5, 7.1, 1.2 }; </div><div class="line"><a name="l01227"></a><span class="lineno"> 1227</span>&#160;   int i; </div><div class="line"><a name="l01228"></a><span class="lineno"> 1228</span>&#160;   for (i = 0; i &lt; 4; i++) </div><div class="line"><a name="l01229"></a><span class="lineno"> 1229</span>&#160;   soap_init1(&amp;soap, SOAP_IO_KEEPALIVE); </div><div class="line"><a name="l01230"></a><span class="lineno"> 1230</span>&#160;     if (soap_call_c__add(&amp;soap, NULL, NULL, sum, val[i], &amp;sum)) </div><div class="line"><a name="l01231"></a><span class="lineno"> 1231</span>&#160;       return soap.error; </div><div class="line"><a name="l01232"></a><span class="lineno"> 1232</span>&#160;   printf(&quot;Sum = %lg\n&quot;, sum); </div><div class="line"><a name="l01233"></a><span class="lineno"> 1233</span>&#160;   soap_end(&amp;soap); </div><div class="line"><a name="l01234"></a><span class="lineno"> 1234</span>&#160;   soap_done(&amp;soap); </div><div class="line"><a name="l01235"></a><span class="lineno"> 1235</span>&#160;   return 0; </div><div class="line"><a name="l01236"></a><span class="lineno"> 1236</span>&#160;}</div><div class="line"><a name="l01237"></a><span class="lineno"> 1237</span>&#160;```</div><div class="line"><a name="l01238"></a><span class="lineno"> 1238</span>&#160;</div><div class="line"><a name="l01239"></a><span class="lineno"> 1239</span>&#160;The code above is compiled and linked with `soapClient.c`, `soapC.c`,</div><div class="line"><a name="l01240"></a><span class="lineno"> 1240</span>&#160;and `stdsoap2.c` (or use `libgsoap.a`).</div><div class="line"><a name="l01241"></a><span class="lineno"> 1241</span>&#160;</div><div class="line"><a name="l01242"></a><span class="lineno"> 1242</span>&#160;### XML Namespace Considerations        {#namespace}</div><div class="line"><a name="l01243"></a><span class="lineno"> 1243</span>&#160;</div><div class="line"><a name="l01244"></a><span class="lineno"> 1244</span>&#160;The declaration of the `ns2__add` function prototype (discussed in the previous section) uses the namespace prefix</div><div class="line"><a name="l01245"></a><span class="lineno"> 1245</span>&#160;`ns2__` of the service operation namespace, which is distinguished by a **pair of underscores** in the function name to</div><div class="line"><a name="l01246"></a><span class="lineno"> 1246</span>&#160;separate the namespace prefix from the service operation name.  The purpose of a namespace prefix is to associate a service</div><div class="line"><a name="l01247"></a><span class="lineno"> 1247</span>&#160;operation name with a service in order to prevent naming conflicts, e.g. to distinguish identical service operation names used</div><div class="line"><a name="l01248"></a><span class="lineno"> 1248</span>&#160;by different services.</div><div class="line"><a name="l01249"></a><span class="lineno"> 1249</span>&#160;</div><div class="line"><a name="l01250"></a><span class="lineno"> 1250</span>&#160;Note that the XML response of the service example uses a **namespace prefix** that may be different (e.g. *`ns`*) as long as it bound to the same **namespace name** *`urn:calc`* through the *`xmlns:ns=&quot;{`*urn:calc}</div><div class="line"><a name="l01251"></a><span class="lineno"> 1251</span>&#160;binding.  The use of namespace prefixes and namespace names is also required to enable SOAP applications to validate the content of</div><div class="line"><a name="l01252"></a><span class="lineno"> 1252</span>&#160;SOAP messages.  The namespace name in the service response is verified by the stub routine by using the</div><div class="line"><a name="l01253"></a><span class="lineno"> 1253</span>&#160;information supplied in a **namespace mapping table** that is required to be part of gSOAP client and service application codes.  The table is accessed</div><div class="line"><a name="l01254"></a><span class="lineno"> 1254</span>&#160;at run time to resolve namespace bindings, both by the generated stub&#39;s data structure serializer for encoding the client request</div><div class="line"><a name="l01255"></a><span class="lineno"> 1255</span>&#160;and by the generated stub&#39;s data structure deserializer to decode and validate the service response. The namespace mapping table</div><div class="line"><a name="l01256"></a><span class="lineno"> 1256</span>&#160;should **not** be part of the header file input to the gSOAP `soapcpp2` tool. Service details including namespace bindings may be provided with gSOAP directives in a header file, see Section \ref directives .</div><div class="line"><a name="l01257"></a><span class="lineno"> 1257</span>&#160;</div><div class="line"><a name="l01258"></a><span class="lineno"> 1258</span>&#160;The namespace mapping table is:</div><div class="line"><a name="l01259"></a><span class="lineno"> 1259</span>&#160;</div><div class="line"><a name="l01260"></a><span class="lineno"> 1260</span>&#160;```cpp</div><div class="line"><a name="l01261"></a><span class="lineno"> 1261</span>&#160;struct Namespace namespaces[] = </div><div class="line"><a name="l01262"></a><span class="lineno"> 1262</span>&#160;{   // {&quot;ns-prefix&quot;, &quot;ns-name&quot;} </div><div class="line"><a name="l01263"></a><span class="lineno"> 1263</span>&#160;  {&quot;SOAP-ENV&quot;, &quot;http://schemas.xmlsoap.org/soap/envelope/&quot;}, // MUST be first </div><div class="line"><a name="l01264"></a><span class="lineno"> 1264</span>&#160;  {&quot;SOAP-ENC&quot;, &quot;http://schemas.xmlsoap.org/soap/encoding/&quot;}, // MUST be second </div><div class="line"><a name="l01265"></a><span class="lineno"> 1265</span>&#160;  {&quot;xsi&quot;,      &quot;http://www.w3.org/2001/XMLSchema-instance&quot;}, // MUST be third </div><div class="line"><a name="l01266"></a><span class="lineno"> 1266</span>&#160;  {&quot;xsd&quot;,      &quot;http://www.w3.org/2001/XMLSchema&quot;}, // 2001 XML Schema </div><div class="line"><a name="l01267"></a><span class="lineno"> 1267</span>&#160;  {&quot;ns2&quot;,      &quot;urn:calc&quot;}, // given by the service description </div><div class="line"><a name="l01268"></a><span class="lineno"> 1268</span>&#160;  {NULL, NULL} // end of table </div><div class="line"><a name="l01269"></a><span class="lineno"> 1269</span>&#160;};</div><div class="line"><a name="l01270"></a><span class="lineno"> 1270</span>&#160;``` </div><div class="line"><a name="l01271"></a><span class="lineno"> 1271</span>&#160;</div><div class="line"><a name="l01272"></a><span class="lineno"> 1272</span>&#160;The first four namespace entries in the table consist of the standard namespaces used by the SOAP 1.1 protocol. In fact, the</div><div class="line"><a name="l01273"></a><span class="lineno"> 1273</span>&#160;namespace mapping table is explicitly declared to enable a programmer to specify the SOAP encoding style and to allow the</div><div class="line"><a name="l01274"></a><span class="lineno"> 1274</span>&#160;inclusion of namespace-prefix with namespace-name bindings to comply to the namespace requirements of a specific SOAP service. For</div><div class="line"><a name="l01275"></a><span class="lineno"> 1275</span>&#160;example, the namespace prefix *`ns2`*, which is bound to *`urn:calc`* by the namespace mapping table shown</div><div class="line"><a name="l01276"></a><span class="lineno"> 1276</span>&#160;above, is used by the generated stub routine to encode the `add` request. This is performed automatically by the gSOAP `soapcpp2`</div><div class="line"><a name="l01277"></a><span class="lineno"> 1277</span>&#160;tool by using the `ns2` prefix of the `ns2__add` method name specified in the `calc.h` header file. In</div><div class="line"><a name="l01278"></a><span class="lineno"> 1278</span>&#160;general, if a function name of a service operation, `struct` name, `class` name, `enum` name, or field name of a</div><div class="line"><a name="l01279"></a><span class="lineno"> 1279</span>&#160;`struct` or `class` has a pair of underscores, the name has a namespace prefix that must be defined in the namespace</div><div class="line"><a name="l01280"></a><span class="lineno"> 1280</span>&#160;mapping table.</div><div class="line"><a name="l01281"></a><span class="lineno"> 1281</span>&#160;</div><div class="line"><a name="l01282"></a><span class="lineno"> 1282</span>&#160;The namespace mapping table will be output as part of the SOAP Envelope by the stub routine. For example:</div><div class="line"><a name="l01283"></a><span class="lineno"> 1283</span>&#160;</div><div class="line"><a name="l01284"></a><span class="lineno"> 1284</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l01285"></a><span class="lineno"> 1285</span>&#160;```xml</div><div class="line"><a name="l01286"></a><span class="lineno"> 1286</span>&#160;... </div><div class="line"><a name="l01287"></a><span class="lineno"> 1287</span>&#160;&lt;SOAP-ENV:Envelope xmlns:SOAP-ENV=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; </div><div class="line"><a name="l01288"></a><span class="lineno"> 1288</span>&#160;   xmlns:SOAP-ENC=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot; </div><div class="line"><a name="l01289"></a><span class="lineno"> 1289</span>&#160;   xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; </div><div class="line"><a name="l01290"></a><span class="lineno"> 1290</span>&#160;   xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; </div><div class="line"><a name="l01291"></a><span class="lineno"> 1291</span>&#160;   xmlns:ns2=&quot;urn:calc&quot; </div><div class="line"><a name="l01292"></a><span class="lineno"> 1292</span>&#160;   SOAP-ENV:encodingStyle=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;&gt; </div><div class="line"><a name="l01293"></a><span class="lineno"> 1293</span>&#160;...</div><div class="line"><a name="l01294"></a><span class="lineno"> 1294</span>&#160;```</div><div class="line"><a name="l01295"></a><span class="lineno"> 1295</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l01296"></a><span class="lineno"> 1296</span>&#160;</div><div class="line"><a name="l01297"></a><span class="lineno"> 1297</span>&#160;The namespace bindings will be used by a SOAP service to validate the SOAP request.</div><div class="line"><a name="l01298"></a><span class="lineno"> 1298</span>&#160;</div><div class="line"><a name="l01299"></a><span class="lineno"> 1299</span>&#160;### Example        {#example2}</div><div class="line"><a name="l01300"></a><span class="lineno"> 1300</span>&#160;</div><div class="line"><a name="l01301"></a><span class="lineno"> 1301</span>&#160;The incorporation of namespace prefixes into C++ identifier names is necessary to distinguish service operations that</div><div class="line"><a name="l01302"></a><span class="lineno"> 1302</span>&#160;share the same name but are provided by separate Web services and/or</div><div class="line"><a name="l01303"></a><span class="lineno"> 1303</span>&#160;organizations. It avoids potential name clashes, while sticking to the C</div><div class="line"><a name="l01304"></a><span class="lineno"> 1304</span>&#160;syntax. The C++ proxy classes generated with `soapcpp2 -i` (or `-j`) drop the</div><div class="line"><a name="l01305"></a><span class="lineno"> 1305</span>&#160;namespace prefix from the method names</div><div class="line"><a name="l01306"></a><span class="lineno"> 1306</span>&#160;</div><div class="line"><a name="l01307"></a><span class="lineno"> 1307</span>&#160;The namespace prefix convention is also be applied to non-primitive types. For example, `class` names are prefixed to avoid name clashes when the same name is used by multiple XML schemas. This ensures that the XML databinding never suffers from conflicting schema content. For example:</div><div class="line"><a name="l01308"></a><span class="lineno"> 1308</span>&#160;</div><div class="line"><a name="l01309"></a><span class="lineno"> 1309</span>&#160;```cpp</div><div class="line"><a name="l01310"></a><span class="lineno"> 1310</span>&#160;class e__Address // an electronic address from schema &#39;e&#39; </div><div class="line"><a name="l01311"></a><span class="lineno"> 1311</span>&#160;{ </div><div class="line"><a name="l01312"></a><span class="lineno"> 1312</span>&#160;   char *email; </div><div class="line"><a name="l01313"></a><span class="lineno"> 1313</span>&#160;   char *url; </div><div class="line"><a name="l01314"></a><span class="lineno"> 1314</span>&#160;}; </div><div class="line"><a name="l01315"></a><span class="lineno"> 1315</span>&#160;class s__Address // a street address from schema &#39;s&#39; </div><div class="line"><a name="l01316"></a><span class="lineno"> 1316</span>&#160;{ </div><div class="line"><a name="l01317"></a><span class="lineno"> 1317</span>&#160;   char *street; </div><div class="line"><a name="l01318"></a><span class="lineno"> 1318</span>&#160;   int number; </div><div class="line"><a name="l01319"></a><span class="lineno"> 1319</span>&#160;   char *city; </div><div class="line"><a name="l01320"></a><span class="lineno"> 1320</span>&#160;};</div><div class="line"><a name="l01321"></a><span class="lineno"> 1321</span>&#160;```</div><div class="line"><a name="l01322"></a><span class="lineno"> 1322</span>&#160;</div><div class="line"><a name="l01323"></a><span class="lineno"> 1323</span>&#160;The namespace prefix is separated from the name of a data type by a pair of underscores (`__`).</div><div class="line"><a name="l01324"></a><span class="lineno"> 1324</span>&#160;</div><div class="line"><a name="l01325"></a><span class="lineno"> 1325</span>&#160;An instance of `e__Address` is encoded by the generated serializer for this type as an Address element with namespace prefix `e`:</div><div class="line"><a name="l01326"></a><span class="lineno"> 1326</span>&#160;</div><div class="line"><a name="l01327"></a><span class="lineno"> 1327</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l01328"></a><span class="lineno"> 1328</span>&#160;```xml</div><div class="line"><a name="l01329"></a><span class="lineno"> 1329</span>&#160;&lt;e:Address xsi:type=&quot;e:Address&quot;&gt; </div><div class="line"><a name="l01330"></a><span class="lineno"> 1330</span>&#160;   &lt;email xsi:type=&quot;string&quot;&gt;me@home&lt;/email&gt; </div><div class="line"><a name="l01331"></a><span class="lineno"> 1331</span>&#160;   &lt;url xsi:type=&quot;string&quot;&gt;www.me.com&lt;/url&gt; </div><div class="line"><a name="l01332"></a><span class="lineno"> 1332</span>&#160;&lt;/e:Address&gt;</div><div class="line"><a name="l01333"></a><span class="lineno"> 1333</span>&#160;```</div><div class="line"><a name="l01334"></a><span class="lineno"> 1334</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l01335"></a><span class="lineno"> 1335</span>&#160;</div><div class="line"><a name="l01336"></a><span class="lineno"> 1336</span>&#160;While an instance of `s__Address` is encoded by the generated serializer for this type as an Address element with namespace prefix `s`:</div><div class="line"><a name="l01337"></a><span class="lineno"> 1337</span>&#160;</div><div class="line"><a name="l01338"></a><span class="lineno"> 1338</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l01339"></a><span class="lineno"> 1339</span>&#160;```xml</div><div class="line"><a name="l01340"></a><span class="lineno"> 1340</span>&#160;&lt;s:Address xsi:type=&quot;s:Address&quot;&gt; </div><div class="line"><a name="l01341"></a><span class="lineno"> 1341</span>&#160;   &lt;street xsi:type=&quot;string&quot;&gt;Technology Drive&lt;/street&gt; </div><div class="line"><a name="l01342"></a><span class="lineno"> 1342</span>&#160;   &lt;number xsi:type=&quot;int&quot;&gt;5&lt;/number&gt; </div><div class="line"><a name="l01343"></a><span class="lineno"> 1343</span>&#160;   &lt;city xsi:type=&quot;string&quot;&gt;Softcity&lt;/city&gt; </div><div class="line"><a name="l01344"></a><span class="lineno"> 1344</span>&#160;&lt;/s:Address&gt;</div><div class="line"><a name="l01345"></a><span class="lineno"> 1345</span>&#160;```</div><div class="line"><a name="l01346"></a><span class="lineno"> 1346</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l01347"></a><span class="lineno"> 1347</span>&#160;</div><div class="line"><a name="l01348"></a><span class="lineno"> 1348</span>&#160;The namespace mapping table of the client program must have entries for `e` and `s` that refer to the XML Schemas of the data types:</div><div class="line"><a name="l01349"></a><span class="lineno"> 1349</span>&#160;</div><div class="line"><a name="l01350"></a><span class="lineno"> 1350</span>&#160;```cpp</div><div class="line"><a name="l01351"></a><span class="lineno"> 1351</span>&#160;struct Namespace namespaces[] = </div><div class="line"><a name="l01352"></a><span class="lineno"> 1352</span>&#160;{ ... </div><div class="line"><a name="l01353"></a><span class="lineno"> 1353</span>&#160;  {&quot;e&quot;, &quot;http://www.me.com/schemas/electronic-address&quot;}, </div><div class="line"><a name="l01354"></a><span class="lineno"> 1354</span>&#160;  {&quot;s&quot;, &quot;http://www.me.com/schemas/street-address&quot;}, </div><div class="line"><a name="l01355"></a><span class="lineno"> 1355</span>&#160;...</div><div class="line"><a name="l01356"></a><span class="lineno"> 1356</span>&#160;``` </div><div class="line"><a name="l01357"></a><span class="lineno"> 1357</span>&#160;</div><div class="line"><a name="l01358"></a><span class="lineno"> 1358</span>&#160;This table is required to be part of the client application to allow access by the serializers and deserializers of the data types at run time.</div><div class="line"><a name="l01359"></a><span class="lineno"> 1359</span>&#160;</div><div class="line"><a name="l01360"></a><span class="lineno"> 1360</span>&#160;### How to Generate C++ Client Proxy Classes        {#proxy}</div><div class="line"><a name="l01361"></a><span class="lineno"> 1361</span>&#160;</div><div class="line"><a name="l01362"></a><span class="lineno"> 1362</span>&#160;Proxy classes for C++ client applications are automatically generated by the gSOAP `soapcpp2` tool, as was shown in Section \ref example1 .</div><div class="line"><a name="l01363"></a><span class="lineno"> 1363</span>&#160;</div><div class="line"><a name="l01364"></a><span class="lineno"> 1364</span>&#160;There is a new and improved code generation capability for proxy classes, which</div><div class="line"><a name="l01365"></a><span class="lineno"> 1365</span>&#160;is activated with the `soapcpp2 -i` (or `j`) option. These new proxy classes are</div><div class="line"><a name="l01366"></a><span class="lineno"> 1366</span>&#160;derived from the soap structure, have a cleaner interface and offer more</div><div class="line"><a name="l01367"></a><span class="lineno"> 1367</span>&#160;capabilites.</div><div class="line"><a name="l01368"></a><span class="lineno"> 1368</span>&#160;</div><div class="line"><a name="l01369"></a><span class="lineno"> 1369</span>&#160;With C++, you can also use `wsdl2h` option `-q`*name* to generate</div><div class="line"><a name="l01370"></a><span class="lineno"> 1370</span>&#160;the proxy in a C++ namespace *name*. This is very useful if you want to</div><div class="line"><a name="l01371"></a><span class="lineno"> 1371</span>&#160;create multiple proxies for services by repeated use of `wsdl2h` and</div><div class="line"><a name="l01372"></a><span class="lineno"> 1372</span>&#160;combine them in one code.  Alternatively, you can run `wsdl2h` just once on</div><div class="line"><a name="l01373"></a><span class="lineno"> 1373</span>&#160;all service WSDLs and have `soapcpp2` generate multiple proxies for you.</div><div class="line"><a name="l01374"></a><span class="lineno"> 1374</span>&#160;The latter approach does not use C++ namespaces and may reduce the overall</div><div class="line"><a name="l01375"></a><span class="lineno"> 1375</span>&#160;amount of code.</div><div class="line"><a name="l01376"></a><span class="lineno"> 1376</span>&#160;</div><div class="line"><a name="l01377"></a><span class="lineno"> 1377</span>&#160;To illustrate the generation of a &quot;standard&quot; (old-style) proxy class, the</div><div class="line"><a name="l01378"></a><span class="lineno"> 1378</span>&#160;`calc.h` header file example of the previous section is augmented with</div><div class="line"><a name="l01379"></a><span class="lineno"> 1379</span>&#160;the appropriate directives to enable the gSOAP `soapcpp2` tool to generate the proxy</div><div class="line"><a name="l01380"></a><span class="lineno"> 1380</span>&#160;class. Directives are included in the generated header file by the `wsdl2h` WSDL importer:</div><div class="line"><a name="l01381"></a><span class="lineno"> 1381</span>&#160;</div><div class="line"><a name="l01382"></a><span class="lineno"> 1382</span>&#160;```cpp</div><div class="line"><a name="l01383"></a><span class="lineno"> 1383</span>&#160;// Content of file &quot;calc.h&quot;: </div><div class="line"><a name="l01384"></a><span class="lineno"> 1384</span>&#160;//gsoap ns2 service name: calc </div><div class="line"><a name="l01385"></a><span class="lineno"> 1385</span>&#160;//gsoap ns2 service port: http://websrv.cs.fsu.edu/~engelen/calcserver.cgi </div><div class="line"><a name="l01386"></a><span class="lineno"> 1386</span>&#160;//gsoap ns2 service protocol: SOAP1.1 </div><div class="line"><a name="l01387"></a><span class="lineno"> 1387</span>&#160;//gsoap ns2 service style: rpc </div><div class="line"><a name="l01388"></a><span class="lineno"> 1388</span>&#160;//gsoap ns2 service encoding: encoded </div><div class="line"><a name="l01389"></a><span class="lineno"> 1389</span>&#160;//gsoap ns2 service namespace: urn:calc </div><div class="line"><a name="l01390"></a><span class="lineno"> 1390</span>&#160;</div><div class="line"><a name="l01391"></a><span class="lineno"> 1391</span>&#160;//gsoap ns2 service method-protocol: add SOAP </div><div class="line"><a name="l01392"></a><span class="lineno"> 1392</span>&#160;//gsoap ns2 service method-style: add rpc </div><div class="line"><a name="l01393"></a><span class="lineno"> 1393</span>&#160;//gsoap ns2 service method-encoding: add encoded </div><div class="line"><a name="l01394"></a><span class="lineno"> 1394</span>&#160;//gsoap ns2 service method-action: add &quot;&quot; </div><div class="line"><a name="l01395"></a><span class="lineno"> 1395</span>&#160;int ns2__add(double a, double b, double&amp; result); </div><div class="line"><a name="l01396"></a><span class="lineno"> 1396</span>&#160;</div><div class="line"><a name="l01397"></a><span class="lineno"> 1397</span>&#160;//gsoap ns2 service method-protocol: sub SOAP </div><div class="line"><a name="l01398"></a><span class="lineno"> 1398</span>&#160;//gsoap ns2 service method-style: sub rpc </div><div class="line"><a name="l01399"></a><span class="lineno"> 1399</span>&#160;//gsoap ns2 service method-encoding: sub encoded </div><div class="line"><a name="l01400"></a><span class="lineno"> 1400</span>&#160;//gsoap ns2 service method-action: sub &quot;&quot; </div><div class="line"><a name="l01401"></a><span class="lineno"> 1401</span>&#160;int ns2__sub(double a, double b, double&amp; result); </div><div class="line"><a name="l01402"></a><span class="lineno"> 1402</span>&#160;</div><div class="line"><a name="l01403"></a><span class="lineno"> 1403</span>&#160;//gsoap ns2 service method-protocol: mul SOAP </div><div class="line"><a name="l01404"></a><span class="lineno"> 1404</span>&#160;//gsoap ns2 service method-style: mul rpc </div><div class="line"><a name="l01405"></a><span class="lineno"> 1405</span>&#160;//gsoap ns2 service method-encoding: mul encoded </div><div class="line"><a name="l01406"></a><span class="lineno"> 1406</span>&#160;//gsoap ns2 service method-action: mul &quot;&quot; </div><div class="line"><a name="l01407"></a><span class="lineno"> 1407</span>&#160;int ns2__mul(double a, double b, double&amp; result); </div><div class="line"><a name="l01408"></a><span class="lineno"> 1408</span>&#160;</div><div class="line"><a name="l01409"></a><span class="lineno"> 1409</span>&#160;...</div><div class="line"><a name="l01410"></a><span class="lineno"> 1410</span>&#160;```</div><div class="line"><a name="l01411"></a><span class="lineno"> 1411</span>&#160;</div><div class="line"><a name="l01412"></a><span class="lineno"> 1412</span>&#160;The first three directives provide the service details, which is used to name the proxy class, the service location port (endpoint), and</div><div class="line"><a name="l01413"></a><span class="lineno"> 1413</span>&#160;the XML namespace. The subsequent groups of three directives per method define the operation&#39;s SOAP style (RPC) and encoding (SOAP encoded), and SOAP action string. </div><div class="line"><a name="l01414"></a><span class="lineno"> 1414</span>&#160;These directives can be provided for each service operation when the SOAPAction is required, such as with SOAP1.1 RPC encoded and when WS-Addressing is used.</div><div class="line"><a name="l01415"></a><span class="lineno"> 1415</span>&#160;In this example, the service protocol is set by default for all operations to use SOAP 1.1 RPC encoding.</div><div class="line"><a name="l01416"></a><span class="lineno"> 1416</span>&#160;For `//gsoap` directive details, see Section \ref directives .</div><div class="line"><a name="l01417"></a><span class="lineno"> 1417</span>&#160;</div><div class="line"><a name="l01418"></a><span class="lineno"> 1418</span>&#160;The `soapcpp2` tool takes this header file and generates a proxy `soapcalcProxy.h` with the</div><div class="line"><a name="l01419"></a><span class="lineno"> 1419</span>&#160;following contents (not using option `-i`):</div><div class="line"><a name="l01420"></a><span class="lineno"> 1420</span>&#160;</div><div class="line"><a name="l01421"></a><span class="lineno"> 1421</span>&#160;```cpp</div><div class="line"><a name="l01422"></a><span class="lineno"> 1422</span>&#160;#include &quot;soapH.h&quot; </div><div class="line"><a name="l01423"></a><span class="lineno"> 1423</span>&#160;class calc </div><div class="line"><a name="l01424"></a><span class="lineno"> 1424</span>&#160;{ public: </div><div class="line"><a name="l01425"></a><span class="lineno"> 1425</span>&#160;   struct soap *soap; </div><div class="line"><a name="l01426"></a><span class="lineno"> 1426</span>&#160;   const char *endpoint; </div><div class="line"><a name="l01427"></a><span class="lineno"> 1427</span>&#160;   calc() { ... }; </div><div class="line"><a name="l01428"></a><span class="lineno"> 1428</span>&#160;   ~calc() { ... }; </div><div class="line"><a name="l01429"></a><span class="lineno"> 1429</span>&#160;   virtual int ns2__add(double a, double b, double&amp; result) { return soap ? soap_call_ns2__add(soap, endpoint, NULL, a, b, result) : SOAP_EOM; }; </div><div class="line"><a name="l01430"></a><span class="lineno"> 1430</span>&#160;   virtual int ns2__sub(double a, double b, double&amp; result) { return soap ? soap_call_ns2__sub(soap, endpoint, NULL, a, b, result) : SOAP_EOM; }; </div><div class="line"><a name="l01431"></a><span class="lineno"> 1431</span>&#160;   virtual int ns2__mul(double a, double b, double&amp; result) { return soap ? soap_call_ns2__mul(soap, endpoint, NULL, a, b, result) : SOAP_EOM; }; </div><div class="line"><a name="l01432"></a><span class="lineno"> 1432</span>&#160;   ... </div><div class="line"><a name="l01433"></a><span class="lineno"> 1433</span>&#160;};</div><div class="line"><a name="l01434"></a><span class="lineno"> 1434</span>&#160;```</div><div class="line"><a name="l01435"></a><span class="lineno"> 1435</span>&#160;</div><div class="line"><a name="l01436"></a><span class="lineno"> 1436</span>&#160;The gSOAP context and endpoint are declared public to enable access.</div><div class="line"><a name="l01437"></a><span class="lineno"> 1437</span>&#160;</div><div class="line"><a name="l01438"></a><span class="lineno"> 1438</span>&#160;This generated proxy class can be included into a client application together with the generated namespace table as shown in this example:</div><div class="line"><a name="l01439"></a><span class="lineno"> 1439</span>&#160;</div><div class="line"><a name="l01440"></a><span class="lineno"> 1440</span>&#160;```cpp</div><div class="line"><a name="l01441"></a><span class="lineno"> 1441</span>&#160;#include &quot;soapcalcProxy.h&quot;      // get proxy </div><div class="line"><a name="l01442"></a><span class="lineno"> 1442</span>&#160;#include &quot;calc.nsmap&quot;           // get namespace bindings </div><div class="line"><a name="l01443"></a><span class="lineno"> 1443</span>&#160;int main() </div><div class="line"><a name="l01444"></a><span class="lineno"> 1444</span>&#160;{ </div><div class="line"><a name="l01445"></a><span class="lineno"> 1445</span>&#160;   calc s; </div><div class="line"><a name="l01446"></a><span class="lineno"> 1446</span>&#160;   double r; </div><div class="line"><a name="l01447"></a><span class="lineno"> 1447</span>&#160;   if (s.ns2__add(1.0, 2.0, r) == SOAP_OK) </div><div class="line"><a name="l01448"></a><span class="lineno"> 1448</span>&#160;     std::cout &lt;&lt; r &lt;&lt; std::endl; </div><div class="line"><a name="l01449"></a><span class="lineno"> 1449</span>&#160;   else </div><div class="line"><a name="l01450"></a><span class="lineno"> 1450</span>&#160;     soap_print_fault(s.soap, stderr); </div><div class="line"><a name="l01451"></a><span class="lineno"> 1451</span>&#160;   return 0; </div><div class="line"><a name="l01452"></a><span class="lineno"> 1452</span>&#160;}</div><div class="line"><a name="l01453"></a><span class="lineno"> 1453</span>&#160;```</div><div class="line"><a name="l01454"></a><span class="lineno"> 1454</span>&#160;</div><div class="line"><a name="l01455"></a><span class="lineno"> 1455</span>&#160;The constructor allocates and initializes a gSOAP context for the instance.</div><div class="line"><a name="l01456"></a><span class="lineno"> 1456</span>&#160;</div><div class="line"><a name="l01457"></a><span class="lineno"> 1457</span>&#160;You can use `soapcpp2` option `-n` together with `-p` to create</div><div class="line"><a name="l01458"></a><span class="lineno"> 1458</span>&#160;a local namespaces table to avoid link conflicts when you need multiple</div><div class="line"><a name="l01459"></a><span class="lineno"> 1459</span>&#160;namespace tables or need to combine multiple clients, see also</div><div class="line"><a name="l01460"></a><span class="lineno"> 1460</span>&#160;Sections \ref options  and \ref dylibs , and you can use a C++ code</div><div class="line"><a name="l01461"></a><span class="lineno"> 1461</span>&#160;`namespace` to create a namespace qualified proxy class, see</div><div class="line"><a name="l01462"></a><span class="lineno"> 1462</span>&#160;Section \ref codenamespace .</div><div class="line"><a name="l01463"></a><span class="lineno"> 1463</span>&#160;</div><div class="line"><a name="l01464"></a><span class="lineno"> 1464</span>&#160;The `soapcpp2 -i` option to generate proxy classes</div><div class="line"><a name="l01465"></a><span class="lineno"> 1465</span>&#160;derived from the base soap structure. In addition, these classes offer more</div><div class="line"><a name="l01466"></a><span class="lineno"> 1466</span>&#160;functionality as illustrated in Section \ref example1 .</div><div class="line"><a name="l01467"></a><span class="lineno"> 1467</span>&#160;</div><div class="line"><a name="l01468"></a><span class="lineno"> 1468</span>&#160;### XSD Type Encoding Considerations        {#encoding}</div><div class="line"><a name="l01469"></a><span class="lineno"> 1469</span>&#160;</div><div class="line"><a name="l01470"></a><span class="lineno"> 1470</span>&#160;Many SOAP services require the explicit use of XML Schema types in the SOAP payload. The default encoding, which is also adopted</div><div class="line"><a name="l01471"></a><span class="lineno"> 1471</span>&#160;by the gSOAP `soapcpp2` tool, assumes SOAP RPC encoding which only requires the use of types to handle polymorphic cases.</div><div class="line"><a name="l01472"></a><span class="lineno"> 1472</span>&#160;Nevertheless, the use of XSD typed messages is advised to improve interoperability.</div><div class="line"><a name="l01473"></a><span class="lineno"> 1473</span>&#160;XSD types are introduced with `typedef` definitions in</div><div class="line"><a name="l01474"></a><span class="lineno"> 1474</span>&#160;the header file input to the gSOAP `soapcpp2` tool. The type name defined by a `typedef` definition corresponds to an XML Schema</div><div class="line"><a name="l01475"></a><span class="lineno"> 1475</span>&#160;type (XSD type). For example, the following `typedef` declarations</div><div class="line"><a name="l01476"></a><span class="lineno"> 1476</span>&#160;define various built-in XSD types implemented as primitive C/C++ types:</div><div class="line"><a name="l01477"></a><span class="lineno"> 1477</span>&#160;</div><div class="line"><a name="l01478"></a><span class="lineno"> 1478</span>&#160;```cpp</div><div class="line"><a name="l01479"></a><span class="lineno"> 1479</span>&#160;// Contents of header file: </div><div class="line"><a name="l01480"></a><span class="lineno"> 1480</span>&#160;... </div><div class="line"><a name="l01481"></a><span class="lineno"> 1481</span>&#160;typedef char *xsd__string; // encode xsd__string value as the *`xsd:string`* schema type </div><div class="line"><a name="l01482"></a><span class="lineno"> 1482</span>&#160;typedef char *xsd__anyURI; // encode xsd__anyURI value as the *`xsd:anyURI`* schema type </div><div class="line"><a name="l01483"></a><span class="lineno"> 1483</span>&#160;typedef float xsd__float; // encode xsd__float value as the *`xsd:float`* schema type </div><div class="line"><a name="l01484"></a><span class="lineno"> 1484</span>&#160;typedef long xsd__int; // encode xsd__int value as the *`xsd:int`* schema type </div><div class="line"><a name="l01485"></a><span class="lineno"> 1485</span>&#160;typedef bool xsd__boolean; // encode xsd__boolean value as the *`xsd:boolean`* schema type </div><div class="line"><a name="l01486"></a><span class="lineno"> 1486</span>&#160;typedef unsigned long long xsd__positiveInteger; // encode xsd__positiveInteger value as the *`xsd:positiveInteger`*  schema type</div><div class="line"><a name="l01487"></a><span class="lineno"> 1487</span>&#160;...</div><div class="line"><a name="l01488"></a><span class="lineno"> 1488</span>&#160;```</div><div class="line"><a name="l01489"></a><span class="lineno"> 1489</span>&#160;</div><div class="line"><a name="l01490"></a><span class="lineno"> 1490</span>&#160;This easy-to-use mechanism informs the gSOAP `soapcpp2` tool to generate serializers and deserializers that explicitly encode and decode the</div><div class="line"><a name="l01491"></a><span class="lineno"> 1491</span>&#160;primitive C++ types as built-in primitive XSD types when the `typedef`ed type is used in the parameter signature of a</div><div class="line"><a name="l01492"></a><span class="lineno"> 1492</span>&#160;service operation (or when used nested within structs, classes, and arrays).  At the same time, the use of `typedef` </div><div class="line"><a name="l01493"></a><span class="lineno"> 1493</span>&#160;does not force any recoding of a C++ client or Web service application as the internal C++ types used by the application</div><div class="line"><a name="l01494"></a><span class="lineno"> 1494</span>&#160;are not required to be changed (but still have to be primitive C++ types, see Section \ref primclass  for alternative class</div><div class="line"><a name="l01495"></a><span class="lineno"> 1495</span>&#160;implementations of primitive XSD types which allows for the marshalling of polymorphic primitive types).</div><div class="line"><a name="l01496"></a><span class="lineno"> 1496</span>&#160;</div><div class="line"><a name="l01497"></a><span class="lineno"> 1497</span>&#160;### Example        {#example3}</div><div class="line"><a name="l01498"></a><span class="lineno"> 1498</span>&#160;</div><div class="line"><a name="l01499"></a><span class="lineno"> 1499</span>&#160;Reconsider the calculator example, now rewritten with explicit XSD types to illustrate the effect:</div><div class="line"><a name="l01500"></a><span class="lineno"> 1500</span>&#160;</div><div class="line"><a name="l01501"></a><span class="lineno"> 1501</span>&#160;```cpp</div><div class="line"><a name="l01502"></a><span class="lineno"> 1502</span>&#160;// Contents of file &quot;calc.h&quot;: </div><div class="line"><a name="l01503"></a><span class="lineno"> 1503</span>&#160;typedef double xsd__double; </div><div class="line"><a name="l01504"></a><span class="lineno"> 1504</span>&#160;int ns2__add(xsd__string a, xsd__double b, xsd__double &amp;Result);</div><div class="line"><a name="l01505"></a><span class="lineno"> 1505</span>&#160;```</div><div class="line"><a name="l01506"></a><span class="lineno"> 1506</span>&#160;</div><div class="line"><a name="l01507"></a><span class="lineno"> 1507</span>&#160;When processed by the gSOAP `soapcpp2` tool it generates source code for the function</div><div class="line"><a name="l01508"></a><span class="lineno"> 1508</span>&#160;`soap_call_ns2__add`, which is identical to the C-style SOAP call:</div><div class="line"><a name="l01509"></a><span class="lineno"> 1509</span>&#160;</div><div class="line"><a name="l01510"></a><span class="lineno"> 1510</span>&#160;```cpp</div><div class="line"><a name="l01511"></a><span class="lineno"> 1511</span>&#160;int soap_call_ns2__add(struct soap *soap, char *URL, char *action, double a, double b, double&amp; result);</div><div class="line"><a name="l01512"></a><span class="lineno"> 1512</span>&#160;```</div><div class="line"><a name="l01513"></a><span class="lineno"> 1513</span>&#160;</div><div class="line"><a name="l01514"></a><span class="lineno"> 1514</span>&#160;The client application does not need to be rewritten and can still call the proxy using the &quot;old&quot; C-style function signatures. In contrast to</div><div class="line"><a name="l01515"></a><span class="lineno"> 1515</span>&#160;the previous implementation of the stub however, the encoding and decoding of the data types by the stub has been changed to</div><div class="line"><a name="l01516"></a><span class="lineno"> 1516</span>&#160;explicitly use the XSD types in the message payload.</div><div class="line"><a name="l01517"></a><span class="lineno"> 1517</span>&#160;</div><div class="line"><a name="l01518"></a><span class="lineno"> 1518</span>&#160;For example, when the client application calls the proxy, the proxy produces a SOAP request with an *`xsd:double`* (the *`xsi:type`* is shown when the `soapcpp2 -t` option is used):</div><div class="line"><a name="l01519"></a><span class="lineno"> 1519</span>&#160;</div><div class="line"><a name="l01520"></a><span class="lineno"> 1520</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l01521"></a><span class="lineno"> 1521</span>&#160;```xml</div><div class="line"><a name="l01522"></a><span class="lineno"> 1522</span>&#160;... </div><div class="line"><a name="l01523"></a><span class="lineno"> 1523</span>&#160;&lt;SOAP-ENV:Body&gt; </div><div class="line"><a name="l01524"></a><span class="lineno"> 1524</span>&#160;   &lt;ns2:add&gt; </div><div class="line"><a name="l01525"></a><span class="lineno"> 1525</span>&#160;      &lt;a xsi:type=&quot;xsd:string&quot;&gt;1.0&lt;/a&gt; </div><div class="line"><a name="l01526"></a><span class="lineno"> 1526</span>&#160;      &lt;b xsi:type=&quot;xsd:string&quot;&gt;2.0&lt;/b&gt; </div><div class="line"><a name="l01527"></a><span class="lineno"> 1527</span>&#160;   &lt;/ns2:add&gt; </div><div class="line"><a name="l01528"></a><span class="lineno"> 1528</span>&#160;&lt;/SOAP-ENV:Body&gt; </div><div class="line"><a name="l01529"></a><span class="lineno"> 1529</span>&#160;...</div><div class="line"><a name="l01530"></a><span class="lineno"> 1530</span>&#160;```</div><div class="line"><a name="l01531"></a><span class="lineno"> 1531</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l01532"></a><span class="lineno"> 1532</span>&#160;</div><div class="line"><a name="l01533"></a><span class="lineno"> 1533</span>&#160;The service response is:</div><div class="line"><a name="l01534"></a><span class="lineno"> 1534</span>&#160;</div><div class="line"><a name="l01535"></a><span class="lineno"> 1535</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l01536"></a><span class="lineno"> 1536</span>&#160;```xml</div><div class="line"><a name="l01537"></a><span class="lineno"> 1537</span>&#160;... </div><div class="line"><a name="l01538"></a><span class="lineno"> 1538</span>&#160;&lt;soap:Body&gt; </div><div class="line"><a name="l01539"></a><span class="lineno"> 1539</span>&#160;   &lt;n:addResponse xmlns:n=&quot;urn:calc&quot;&gt; </div><div class="line"><a name="l01540"></a><span class="lineno"> 1540</span>&#160;      &lt;result xsi:type=&quot;xsd:double&quot;&gt;3.0&lt;/result&gt; </div><div class="line"><a name="l01541"></a><span class="lineno"> 1541</span>&#160;   &lt;/n:addResponse&gt; </div><div class="line"><a name="l01542"></a><span class="lineno"> 1542</span>&#160;&lt;/soap:Body&gt; </div><div class="line"><a name="l01543"></a><span class="lineno"> 1543</span>&#160;...</div><div class="line"><a name="l01544"></a><span class="lineno"> 1544</span>&#160;```</div><div class="line"><a name="l01545"></a><span class="lineno"> 1545</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l01546"></a><span class="lineno"> 1546</span>&#160;</div><div class="line"><a name="l01547"></a><span class="lineno"> 1547</span>&#160;The validation of this service response by the stub routine takes place by matching the namespace names (URIs) that are bound to the</div><div class="line"><a name="l01548"></a><span class="lineno"> 1548</span>&#160;*`xsd`* namespace prefix. The stub also expects the *`addResponse`* element to be associated with URI</div><div class="line"><a name="l01549"></a><span class="lineno"> 1549</span>&#160;*`urn:calc`* through the binding of the namespace prefix *`ns2`* in the namespace mapping table. The</div><div class="line"><a name="l01550"></a><span class="lineno"> 1550</span>&#160;service response uses namespace prefix *`n`* for the *`addResponse`* element. This namespace prefix is bound to the same</div><div class="line"><a name="l01551"></a><span class="lineno"> 1551</span>&#160;URI *`urn:calc`* and therefore the service response is valid.  When the XML is not well formed or does not pass validation, the response is</div><div class="line"><a name="l01552"></a><span class="lineno"> 1552</span>&#160;rejected and a SOAP fault is generated. The validation level can be increased with the `SOAP_XML_STRICT` flag, but this is not advised for SOAP RPC encoded messaging.</div><div class="line"><a name="l01553"></a><span class="lineno"> 1553</span>&#160;</div><div class="line"><a name="l01554"></a><span class="lineno"> 1554</span>&#160;### How to Change the Response Element Name        {#response}</div><div class="line"><a name="l01555"></a><span class="lineno"> 1555</span>&#160;</div><div class="line"><a name="l01556"></a><span class="lineno"> 1556</span>&#160;There is no standardized convention for the response element name in a SOAP RPC encoded response message, although it is recommended that the response</div><div class="line"><a name="l01557"></a><span class="lineno"> 1557</span>&#160;element name is the method name ending with &quot;*`Response`*&quot;. For example, the response element of *`add`* is</div><div class="line"><a name="l01558"></a><span class="lineno"> 1558</span>&#160;*`addResponse`*.</div><div class="line"><a name="l01559"></a><span class="lineno"> 1559</span>&#160;</div><div class="line"><a name="l01560"></a><span class="lineno"> 1560</span>&#160;The response element name can be specified explicitly using a `struct` or</div><div class="line"><a name="l01561"></a><span class="lineno"> 1561</span>&#160;`class` declaration in the header file. This name must be qualified by a</div><div class="line"><a name="l01562"></a><span class="lineno"> 1562</span>&#160;namespace prefix, just as the operation name should use a namespace prefix. The</div><div class="line"><a name="l01563"></a><span class="lineno"> 1563</span>&#160;`struct` or `class` name represents the SOAP response element name</div><div class="line"><a name="l01564"></a><span class="lineno"> 1564</span>&#160;used by the service. Consequently, the output</div><div class="line"><a name="l01565"></a><span class="lineno"> 1565</span>&#160;parameter of the service operation must be declared as a field of the `struct` or `class`.  The use of a `struct` or a</div><div class="line"><a name="l01566"></a><span class="lineno"> 1566</span>&#160;`class` for the service response is fully SOAP 1.1 compliant. In fact, the absence of a `struct` or `class`</div><div class="line"><a name="l01567"></a><span class="lineno"> 1567</span>&#160;indicates to the `soapcpp2` tool to automatically generate a `struct` for the response which is internally used by a stub.</div><div class="line"><a name="l01568"></a><span class="lineno"> 1568</span>&#160;</div><div class="line"><a name="l01569"></a><span class="lineno"> 1569</span>&#160;### Example        {#example4}</div><div class="line"><a name="l01570"></a><span class="lineno"> 1570</span>&#160;</div><div class="line"><a name="l01571"></a><span class="lineno"> 1571</span>&#160;Reconsider the calculator service operation specification which can be rewritten with an explicit declaration of a SOAP response</div><div class="line"><a name="l01572"></a><span class="lineno"> 1572</span>&#160;element as follows:</div><div class="line"><a name="l01573"></a><span class="lineno"> 1573</span>&#160;</div><div class="line"><a name="l01574"></a><span class="lineno"> 1574</span>&#160;```cpp</div><div class="line"><a name="l01575"></a><span class="lineno"> 1575</span>&#160;// Contents of &quot;calc.h&quot;: </div><div class="line"><a name="l01576"></a><span class="lineno"> 1576</span>&#160;typedef double xsd__double; </div><div class="line"><a name="l01577"></a><span class="lineno"> 1577</span>&#160;struct ns2__addResponse {xsd__double result;}; </div><div class="line"><a name="l01578"></a><span class="lineno"> 1578</span>&#160;int ns2__add(xsd__string a, xsd__double b, struct ns2__addResponse &amp;r);</div><div class="line"><a name="l01579"></a><span class="lineno"> 1579</span>&#160;```</div><div class="line"><a name="l01580"></a><span class="lineno"> 1580</span>&#160;</div><div class="line"><a name="l01581"></a><span class="lineno"> 1581</span>&#160;The SOAP request and response messages are the same as before:</div><div class="line"><a name="l01582"></a><span class="lineno"> 1582</span>&#160;</div><div class="line"><a name="l01583"></a><span class="lineno"> 1583</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l01584"></a><span class="lineno"> 1584</span>&#160;```xml</div><div class="line"><a name="l01585"></a><span class="lineno"> 1585</span>&#160;... </div><div class="line"><a name="l01586"></a><span class="lineno"> 1586</span>&#160;&lt;SOAP-ENV:Body&gt; </div><div class="line"><a name="l01587"></a><span class="lineno"> 1587</span>&#160;   &lt;ns2:add&gt; </div><div class="line"><a name="l01588"></a><span class="lineno"> 1588</span>&#160;      &lt;a xsi:type=&quot;xsd:string&quot;&gt;1.0&lt;/a&gt; </div><div class="line"><a name="l01589"></a><span class="lineno"> 1589</span>&#160;      &lt;b xsi:type=&quot;xsd:string&quot;&gt;2.0&lt;/b&gt; </div><div class="line"><a name="l01590"></a><span class="lineno"> 1590</span>&#160;   &lt;/ns2:add&gt; </div><div class="line"><a name="l01591"></a><span class="lineno"> 1591</span>&#160;&lt;/SOAP-ENV:Body&gt; </div><div class="line"><a name="l01592"></a><span class="lineno"> 1592</span>&#160;...</div><div class="line"><a name="l01593"></a><span class="lineno"> 1593</span>&#160;```</div><div class="line"><a name="l01594"></a><span class="lineno"> 1594</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l01595"></a><span class="lineno"> 1595</span>&#160;</div><div class="line"><a name="l01596"></a><span class="lineno"> 1596</span>&#160;The difference is that the service response is required to match the specified `addResponse` name and its namespace URI:</div><div class="line"><a name="l01597"></a><span class="lineno"> 1597</span>&#160;</div><div class="line"><a name="l01598"></a><span class="lineno"> 1598</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l01599"></a><span class="lineno"> 1599</span>&#160;```xml</div><div class="line"><a name="l01600"></a><span class="lineno"> 1600</span>&#160;... </div><div class="line"><a name="l01601"></a><span class="lineno"> 1601</span>&#160;&lt;soap:Body&gt; </div><div class="line"><a name="l01602"></a><span class="lineno"> 1602</span>&#160;   &lt;n:addResponse xmlns:n=&#39;urn:calc&#39;&gt; </div><div class="line"><a name="l01603"></a><span class="lineno"> 1603</span>&#160;      &lt;result xsi:type=&quot;xsd:double&quot;&gt;3.0&lt;/result&gt; </div><div class="line"><a name="l01604"></a><span class="lineno"> 1604</span>&#160;   &lt;/n:addResponse&gt; </div><div class="line"><a name="l01605"></a><span class="lineno"> 1605</span>&#160;&lt;/soap:Body&gt; </div><div class="line"><a name="l01606"></a><span class="lineno"> 1606</span>&#160;...</div><div class="line"><a name="l01607"></a><span class="lineno"> 1607</span>&#160;```</div><div class="line"><a name="l01608"></a><span class="lineno"> 1608</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l01609"></a><span class="lineno"> 1609</span>&#160;</div><div class="line"><a name="l01610"></a><span class="lineno"> 1610</span>&#160;This use of a `struct` or `class` enables the adaptation of the default SOAP response element name and/or namespace URI when required.</div><div class="line"><a name="l01611"></a><span class="lineno"> 1611</span>&#160;</div><div class="line"><a name="l01612"></a><span class="lineno"> 1612</span>&#160;### How to Specify Multiple Output Parameters        {#multiple}</div><div class="line"><a name="l01613"></a><span class="lineno"> 1613</span>&#160;</div><div class="line"><a name="l01614"></a><span class="lineno"> 1614</span>&#160;The gSOAP `soapcpp2` tool compiler uses the convention that the </div><div class="line"><a name="l01615"></a><span class="lineno"> 1615</span>&#160;**last parameter** of the function prototype declaration of a service operation in a header file</div><div class="line"><a name="l01616"></a><span class="lineno"> 1616</span>&#160;is also the **only single output parameter** of the method.</div><div class="line"><a name="l01617"></a><span class="lineno"> 1617</span>&#160;All other parameters are considered input parameters of the service operation. To specify a service operation</div><div class="line"><a name="l01618"></a><span class="lineno"> 1618</span>&#160;with **multiple output parameters**, a `struct` or `class` must be declared for the service operation response, see</div><div class="line"><a name="l01619"></a><span class="lineno"> 1619</span>&#160;also \ref response .  The name of the `struct` or `class` must have a namespace prefix, just as the service method name. The fields of the `struct` or `class` are the output parameters of the service operation.</div><div class="line"><a name="l01620"></a><span class="lineno"> 1620</span>&#160;Both the order of the input parameters in the function prototype and the order of the output parameters (the fields in the</div><div class="line"><a name="l01621"></a><span class="lineno"> 1621</span>&#160;`struct` or `class`) is not significant. However, the SOAP 1.1 specification states that input and output parameters may be</div><div class="line"><a name="l01622"></a><span class="lineno"> 1622</span>&#160;treated as having anonymous parameter names which requires a particular ordering, see Section \ref anonymous .</div><div class="line"><a name="l01623"></a><span class="lineno"> 1623</span>&#160;</div><div class="line"><a name="l01624"></a><span class="lineno"> 1624</span>&#160;### Example        {#example5}</div><div class="line"><a name="l01625"></a><span class="lineno"> 1625</span>&#160;</div><div class="line"><a name="l01626"></a><span class="lineno"> 1626</span>&#160;As an example, consider a hypothetical service operation `getNames` with a single input parameter `SSN` </div><div class="line"><a name="l01627"></a><span class="lineno"> 1627</span>&#160;and two output parameters `first` and `last`. This can be specified as:</div><div class="line"><a name="l01628"></a><span class="lineno"> 1628</span>&#160;</div><div class="line"><a name="l01629"></a><span class="lineno"> 1629</span>&#160;```cpp</div><div class="line"><a name="l01630"></a><span class="lineno"> 1630</span>&#160;// Contents of file &quot;getNames.h&quot;: </div><div class="line"><a name="l01631"></a><span class="lineno"> 1631</span>&#160;int ns3__getNames(char *SSN, struct ns3__getNamesResponse {char *first; char *last;} &amp;r);</div><div class="line"><a name="l01632"></a><span class="lineno"> 1632</span>&#160;```</div><div class="line"><a name="l01633"></a><span class="lineno"> 1633</span>&#160;</div><div class="line"><a name="l01634"></a><span class="lineno"> 1634</span>&#160;The gSOAP `soapcpp2` tool takes this header file as input and generates source code for the function `soap_call_ns3__getNames`. When invoked by a client application, the proxy produces the SOAP request:</div><div class="line"><a name="l01635"></a><span class="lineno"> 1635</span>&#160;</div><div class="line"><a name="l01636"></a><span class="lineno"> 1636</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l01637"></a><span class="lineno"> 1637</span>&#160;```xml</div><div class="line"><a name="l01638"></a><span class="lineno"> 1638</span>&#160;... </div><div class="line"><a name="l01639"></a><span class="lineno"> 1639</span>&#160;&lt;SOAP-ENV:Envelope ... xmlns:ns3=&quot;urn:names&quot; ...&gt; </div><div class="line"><a name="l01640"></a><span class="lineno"> 1640</span>&#160;... </div><div class="line"><a name="l01641"></a><span class="lineno"> 1641</span>&#160;&lt;ns3:getNames&gt; </div><div class="line"><a name="l01642"></a><span class="lineno"> 1642</span>&#160;&lt;SSN&gt;999 99 9999&lt;/SSN&gt; </div><div class="line"><a name="l01643"></a><span class="lineno"> 1643</span>&#160;&lt;/ns3:getNames&gt; </div><div class="line"><a name="l01644"></a><span class="lineno"> 1644</span>&#160;...</div><div class="line"><a name="l01645"></a><span class="lineno"> 1645</span>&#160;```</div><div class="line"><a name="l01646"></a><span class="lineno"> 1646</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l01647"></a><span class="lineno"> 1647</span>&#160;</div><div class="line"><a name="l01648"></a><span class="lineno"> 1648</span>&#160;The response by a SOAP service:</div><div class="line"><a name="l01649"></a><span class="lineno"> 1649</span>&#160;</div><div class="line"><a name="l01650"></a><span class="lineno"> 1650</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l01651"></a><span class="lineno"> 1651</span>&#160;```xml</div><div class="line"><a name="l01652"></a><span class="lineno"> 1652</span>&#160;... </div><div class="line"><a name="l01653"></a><span class="lineno"> 1653</span>&#160;&lt;m:getNamesResponse xmlns:m=&quot;urn:names&quot;&gt; </div><div class="line"><a name="l01654"></a><span class="lineno"> 1654</span>&#160;&lt;first&gt;John&lt;/first&gt; </div><div class="line"><a name="l01655"></a><span class="lineno"> 1655</span>&#160;&lt;last&gt;Doe&lt;/last&gt; </div><div class="line"><a name="l01656"></a><span class="lineno"> 1656</span>&#160;&lt;/m:getNamesResponse&gt; </div><div class="line"><a name="l01657"></a><span class="lineno"> 1657</span>&#160;...</div><div class="line"><a name="l01658"></a><span class="lineno"> 1658</span>&#160;```</div><div class="line"><a name="l01659"></a><span class="lineno"> 1659</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l01660"></a><span class="lineno"> 1660</span>&#160;</div><div class="line"><a name="l01661"></a><span class="lineno"> 1661</span>&#160;where *`first`* and *`last`* are the output parameters of the `getNames` service operation of the service.</div><div class="line"><a name="l01662"></a><span class="lineno"> 1662</span>&#160;</div><div class="line"><a name="l01663"></a><span class="lineno"> 1663</span>&#160;As another example, consider a service operation `copy` with an input parameter and an output parameter with identical</div><div class="line"><a name="l01664"></a><span class="lineno"> 1664</span>&#160;parameter names (this is not prohibited by the SOAP 1.1 protocol). This can be specified as well using a response `struct`:</div><div class="line"><a name="l01665"></a><span class="lineno"> 1665</span>&#160;</div><div class="line"><a name="l01666"></a><span class="lineno"> 1666</span>&#160;```cpp</div><div class="line"><a name="l01667"></a><span class="lineno"> 1667</span>&#160;// Content of file &quot;copy.h&quot;: </div><div class="line"><a name="l01668"></a><span class="lineno"> 1668</span>&#160;int X_rox__copy_name(char *name, struct X_rox__copy_nameResponse {char *name;} &amp;r);</div><div class="line"><a name="l01669"></a><span class="lineno"> 1669</span>&#160;```</div><div class="line"><a name="l01670"></a><span class="lineno"> 1670</span>&#160;</div><div class="line"><a name="l01671"></a><span class="lineno"> 1671</span>&#160;The use of a `struct` or `class` for the service operation response enables the declaration of service operations that have</div><div class="line"><a name="l01672"></a><span class="lineno"> 1672</span>&#160;parameters that are passed both as input and output parameters.</div><div class="line"><a name="l01673"></a><span class="lineno"> 1673</span>&#160;</div><div class="line"><a name="l01674"></a><span class="lineno"> 1674</span>&#160;The gSOAP `soapcpp2` compiler takes the `copy.h` header file as input and generates the `soap_call_X_rox__copy_name` proxy. When invoked by a client application, the proxy produces the SOAP request:</div><div class="line"><a name="l01675"></a><span class="lineno"> 1675</span>&#160;</div><div class="line"><a name="l01676"></a><span class="lineno"> 1676</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l01677"></a><span class="lineno"> 1677</span>&#160;```xml</div><div class="line"><a name="l01678"></a><span class="lineno"> 1678</span>&#160;... </div><div class="line"><a name="l01679"></a><span class="lineno"> 1679</span>&#160;&lt;SOAP-ENV:Envelope ... xmlns:X-rox=&quot;urn:copy&quot; ...&gt; </div><div class="line"><a name="l01680"></a><span class="lineno"> 1680</span>&#160;... </div><div class="line"><a name="l01681"></a><span class="lineno"> 1681</span>&#160;&lt;X-rox:copy-name&gt; </div><div class="line"><a name="l01682"></a><span class="lineno"> 1682</span>&#160;&lt;name&gt;SOAP&lt;/name&gt; </div><div class="line"><a name="l01683"></a><span class="lineno"> 1683</span>&#160;&lt;/X-rox:copy-name&gt; </div><div class="line"><a name="l01684"></a><span class="lineno"> 1684</span>&#160;...</div><div class="line"><a name="l01685"></a><span class="lineno"> 1685</span>&#160;```</div><div class="line"><a name="l01686"></a><span class="lineno"> 1686</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l01687"></a><span class="lineno"> 1687</span>&#160;</div><div class="line"><a name="l01688"></a><span class="lineno"> 1688</span>&#160;The response by a SOAP copy service could be something like:</div><div class="line"><a name="l01689"></a><span class="lineno"> 1689</span>&#160;</div><div class="line"><a name="l01690"></a><span class="lineno"> 1690</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l01691"></a><span class="lineno"> 1691</span>&#160;```xml</div><div class="line"><a name="l01692"></a><span class="lineno"> 1692</span>&#160;... </div><div class="line"><a name="l01693"></a><span class="lineno"> 1693</span>&#160;&lt;m:copy-nameResponse xmlns:m=&quot;urn:copy&quot;&gt; </div><div class="line"><a name="l01694"></a><span class="lineno"> 1694</span>&#160;&lt;name&gt;SOAP&lt;/name&gt; </div><div class="line"><a name="l01695"></a><span class="lineno"> 1695</span>&#160;&lt;/m:copy-nameResponse&gt; </div><div class="line"><a name="l01696"></a><span class="lineno"> 1696</span>&#160;...</div><div class="line"><a name="l01697"></a><span class="lineno"> 1697</span>&#160;```</div><div class="line"><a name="l01698"></a><span class="lineno"> 1698</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l01699"></a><span class="lineno"> 1699</span>&#160;</div><div class="line"><a name="l01700"></a><span class="lineno"> 1700</span>&#160;The name will be parsed and decoded by the proxy and returned in the `name` field of the `struct X_rox__copy_nameResponse &amp;r` parameter.</div><div class="line"><a name="l01701"></a><span class="lineno"> 1701</span>&#160;</div><div class="line"><a name="l01702"></a><span class="lineno"> 1702</span>&#160;### How to Specify Output Parameters With struct/class Compound Data Types        {#compound}</div><div class="line"><a name="l01703"></a><span class="lineno"> 1703</span>&#160;</div><div class="line"><a name="l01704"></a><span class="lineno"> 1704</span>&#160;If the single output parameter of a service operation is a complex data type such as a `struct` or `class` it is necessary to</div><div class="line"><a name="l01705"></a><span class="lineno"> 1705</span>&#160;specify the response element of the service operation as a `struct` or `class` **at all times**.</div><div class="line"><a name="l01706"></a><span class="lineno"> 1706</span>&#160;Otherwise, the output parameter will</div><div class="line"><a name="l01707"></a><span class="lineno"> 1707</span>&#160;be considered the response element (!), because of the response element specification convention used by gSOAP,</div><div class="line"><a name="l01708"></a><span class="lineno"> 1708</span>&#160;as discussed in \ref response .</div><div class="line"><a name="l01709"></a><span class="lineno"> 1709</span>&#160;</div><div class="line"><a name="l01710"></a><span class="lineno"> 1710</span>&#160;### Example        {#example6}</div><div class="line"><a name="l01711"></a><span class="lineno"> 1711</span>&#160;</div><div class="line"><a name="l01712"></a><span class="lineno"> 1712</span>&#160;This is best illustrated with an example. The Flighttracker service by ObjectSpace provides real time flight information for</div><div class="line"><a name="l01713"></a><span class="lineno"> 1713</span>&#160;flights in the air. It requires an airline code and flight number as parameters.</div><div class="line"><a name="l01714"></a><span class="lineno"> 1714</span>&#160;The service operation name is `getFlightInfo` and</div><div class="line"><a name="l01715"></a><span class="lineno"> 1715</span>&#160;the method has two string parameters: the airline code and flight number, both of which must be encoded as *`xsd:string`* types.</div><div class="line"><a name="l01716"></a><span class="lineno"> 1716</span>&#160;The method returns a `getFlightResponse` response element with a `return` output parameter that is of complex type</div><div class="line"><a name="l01717"></a><span class="lineno"> 1717</span>&#160;`FlightInfo`. The type `FlightInfo` is represented by a `class` in the header file, whose field names correspond to</div><div class="line"><a name="l01718"></a><span class="lineno"> 1718</span>&#160;the `FlightInfo` accessors:</div><div class="line"><a name="l01719"></a><span class="lineno"> 1719</span>&#160;</div><div class="line"><a name="l01720"></a><span class="lineno"> 1720</span>&#160;```cpp</div><div class="line"><a name="l01721"></a><span class="lineno"> 1721</span>&#160;// Contents of file &quot;flight.h&quot;: </div><div class="line"><a name="l01722"></a><span class="lineno"> 1722</span>&#160;typedef char *xsd__string; </div><div class="line"><a name="l01723"></a><span class="lineno"> 1723</span>&#160;class ns2__FlightInfo </div><div class="line"><a name="l01724"></a><span class="lineno"> 1724</span>&#160;{ </div><div class="line"><a name="l01725"></a><span class="lineno"> 1725</span>&#160;   public: </div><div class="line"><a name="l01726"></a><span class="lineno"> 1726</span>&#160;   xsd__string airline; </div><div class="line"><a name="l01727"></a><span class="lineno"> 1727</span>&#160;   xsd__string flightNumber; </div><div class="line"><a name="l01728"></a><span class="lineno"> 1728</span>&#160;   xsd__string altitude; </div><div class="line"><a name="l01729"></a><span class="lineno"> 1729</span>&#160;   xsd__string currentLocation; </div><div class="line"><a name="l01730"></a><span class="lineno"> 1730</span>&#160;   xsd__string equipment; </div><div class="line"><a name="l01731"></a><span class="lineno"> 1731</span>&#160;   xsd__string speed; </div><div class="line"><a name="l01732"></a><span class="lineno"> 1732</span>&#160;}; </div><div class="line"><a name="l01733"></a><span class="lineno"> 1733</span>&#160;struct ns1__getFlightInfoResponse {ns2__FlightInfo return_;}; </div><div class="line"><a name="l01734"></a><span class="lineno"> 1734</span>&#160;int ns1__getFlightInfo(xsd__string param1, xsd__string param2, struct ns1__getFlightInfoResponse &amp;r);</div><div class="line"><a name="l01735"></a><span class="lineno"> 1735</span>&#160;```</div><div class="line"><a name="l01736"></a><span class="lineno"> 1736</span>&#160;</div><div class="line"><a name="l01737"></a><span class="lineno"> 1737</span>&#160;The response element `ns1__getFlightInfoResponse` is explicitly declared and it has one field: `return_` of type</div><div class="line"><a name="l01738"></a><span class="lineno"> 1738</span>&#160;`ns2__FlightInfo`.  Note that `return_` has a trailing underscore to avoid a name clash with the `\return` keyword,</div><div class="line"><a name="l01739"></a><span class="lineno"> 1739</span>&#160;see Section \ref idtrans  for details on the translation of C++ identifiers to XML element names.</div><div class="line"><a name="l01740"></a><span class="lineno"> 1740</span>&#160;</div><div class="line"><a name="l01741"></a><span class="lineno"> 1741</span>&#160;The gSOAP `soapcpp2` compiler generates the `soap_call_ns1__getFlightInfo` proxy. Here is an example fragment of a client application that uses this proxy to request flight information:</div><div class="line"><a name="l01742"></a><span class="lineno"> 1742</span>&#160;</div><div class="line"><a name="l01743"></a><span class="lineno"> 1743</span>&#160;```cpp</div><div class="line"><a name="l01744"></a><span class="lineno"> 1744</span>&#160;struct soap soap; </div><div class="line"><a name="l01745"></a><span class="lineno"> 1745</span>&#160;... </div><div class="line"><a name="l01746"></a><span class="lineno"> 1746</span>&#160;soap_init(&amp;soap); </div><div class="line"><a name="l01747"></a><span class="lineno"> 1747</span>&#160;... </div><div class="line"><a name="l01748"></a><span class="lineno"> 1748</span>&#160;soap_call_ns1__getFlightInfo(&amp;soap, &quot;testvger.objectspace.com/soap/servlet/rpcrouter&quot;, </div><div class="line"><a name="l01749"></a><span class="lineno"> 1749</span>&#160;  &quot;urn:galdemo:flighttracker&quot;, &quot;UAL&quot;, &quot;184&quot;, r); </div><div class="line"><a name="l01750"></a><span class="lineno"> 1750</span>&#160;... </div><div class="line"><a name="l01751"></a><span class="lineno"> 1751</span>&#160;struct Namespace namespaces[] = </div><div class="line"><a name="l01752"></a><span class="lineno"> 1752</span>&#160;{ </div><div class="line"><a name="l01753"></a><span class="lineno"> 1753</span>&#160;  {&quot;SOAP-ENV&quot;, &quot;http://schemas.xmlsoap.org/soap/envelope/&quot;}, </div><div class="line"><a name="l01754"></a><span class="lineno"> 1754</span>&#160;  {&quot;SOAP-ENC&quot;,&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;}, </div><div class="line"><a name="l01755"></a><span class="lineno"> 1755</span>&#160;  {&quot;xsi&quot;, &quot;http://www.w3.org/2001/XMLSchema-instance&quot;}, </div><div class="line"><a name="l01756"></a><span class="lineno"> 1756</span>&#160;  {&quot;xsd&quot;, &quot;http://www.w3.org/2001/XMLSchema&quot;}, </div><div class="line"><a name="l01757"></a><span class="lineno"> 1757</span>&#160;  {&quot;ns1&quot;, &quot;urn:galdemo:flighttracker&quot;}, </div><div class="line"><a name="l01758"></a><span class="lineno"> 1758</span>&#160;  {&quot;ns2&quot;, &quot;http://galdemo.flighttracker.com&quot;}, </div><div class="line"><a name="l01759"></a><span class="lineno"> 1759</span>&#160;  {NULL, NULL} </div><div class="line"><a name="l01760"></a><span class="lineno"> 1760</span>&#160;};</div><div class="line"><a name="l01761"></a><span class="lineno"> 1761</span>&#160;```</div><div class="line"><a name="l01762"></a><span class="lineno"> 1762</span>&#160;</div><div class="line"><a name="l01763"></a><span class="lineno"> 1763</span>&#160;When invoked by a client application, the proxy produces the SOAP request:</div><div class="line"><a name="l01764"></a><span class="lineno"> 1764</span>&#160;</div><div class="line"><a name="l01765"></a><span class="lineno"> 1765</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l01766"></a><span class="lineno"> 1766</span>&#160;```xml</div><div class="line"><a name="l01767"></a><span class="lineno"> 1767</span>&#160;POST /soap/servlet/rpcrouter HTTP/1.1 </div><div class="line"><a name="l01768"></a><span class="lineno"> 1768</span>&#160;Host: testvger.objectspace.com </div><div class="line"><a name="l01769"></a><span class="lineno"> 1769</span>&#160;Content-Type: text/xml </div><div class="line"><a name="l01770"></a><span class="lineno"> 1770</span>&#160;Content-Length: 634 </div><div class="line"><a name="l01771"></a><span class="lineno"> 1771</span>&#160;SOAPAction: &quot;urn:galdemo:flighttracker&quot; </div><div class="line"><a name="l01772"></a><span class="lineno"> 1772</span>&#160;</div><div class="line"><a name="l01773"></a><span class="lineno"> 1773</span>&#160;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; </div><div class="line"><a name="l01774"></a><span class="lineno"> 1774</span>&#160;&lt;SOAP-ENV:Envelope xmlns:SOAP-ENV=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; </div><div class="line"><a name="l01775"></a><span class="lineno"> 1775</span>&#160;  xmlns:SOAP-ENC=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot; </div><div class="line"><a name="l01776"></a><span class="lineno"> 1776</span>&#160;  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; </div><div class="line"><a name="l01777"></a><span class="lineno"> 1777</span>&#160;  xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; </div><div class="line"><a name="l01778"></a><span class="lineno"> 1778</span>&#160;  xmlns:ns1=&quot;urn:galdemo:flighttracker&quot; </div><div class="line"><a name="l01779"></a><span class="lineno"> 1779</span>&#160;  xmlns:ns2=&quot;http://galdemo.flighttracker.com&quot; </div><div class="line"><a name="l01780"></a><span class="lineno"> 1780</span>&#160;  SOAP-ENV:encodingStyle=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;&gt; </div><div class="line"><a name="l01781"></a><span class="lineno"> 1781</span>&#160;  &lt;SOAP-ENV:Body&gt; </div><div class="line"><a name="l01782"></a><span class="lineno"> 1782</span>&#160;    &lt;ns1:getFlightInfo xsi:type=&quot;ns1:getFlightInfo&quot;&gt; </div><div class="line"><a name="l01783"></a><span class="lineno"> 1783</span>&#160;      &lt;param1 xsi:type=&quot;xsd:string&quot;&gt;UAL&lt;/param1&gt; </div><div class="line"><a name="l01784"></a><span class="lineno"> 1784</span>&#160;      &lt;param2 xsi:type=&quot;xsd:string&quot;&gt;184&lt;/param2&gt; </div><div class="line"><a name="l01785"></a><span class="lineno"> 1785</span>&#160;    &lt;/ns1:getFlightInfo&gt; </div><div class="line"><a name="l01786"></a><span class="lineno"> 1786</span>&#160;  &lt;/SOAP-ENV:Body&gt; </div><div class="line"><a name="l01787"></a><span class="lineno"> 1787</span>&#160;&lt;/SOAP-ENV:Envelope&gt;</div><div class="line"><a name="l01788"></a><span class="lineno"> 1788</span>&#160;```</div><div class="line"><a name="l01789"></a><span class="lineno"> 1789</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l01790"></a><span class="lineno"> 1790</span>&#160;</div><div class="line"><a name="l01791"></a><span class="lineno"> 1791</span>&#160;The Flighttracker service responds with:</div><div class="line"><a name="l01792"></a><span class="lineno"> 1792</span>&#160;</div><div class="line"><a name="l01793"></a><span class="lineno"> 1793</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l01794"></a><span class="lineno"> 1794</span>&#160;```xml</div><div class="line"><a name="l01795"></a><span class="lineno"> 1795</span>&#160;HTTP/1.1 200 ok </div><div class="line"><a name="l01796"></a><span class="lineno"> 1796</span>&#160;Date: Thu, 30 Aug 2001 00:34:17 GMT </div><div class="line"><a name="l01797"></a><span class="lineno"> 1797</span>&#160;Server: IBM_HTTP_Server/1.3.12.3 Apache/1.3.12 (Win32) </div><div class="line"><a name="l01798"></a><span class="lineno"> 1798</span>&#160;Set-Cookie: sesessionid=2GFVTOGC30D0LGRGU2L4HFA;Path=/ </div><div class="line"><a name="l01799"></a><span class="lineno"> 1799</span>&#160;Cache-Control: no-cache=&quot;set-cookie,set-cookie2&quot; </div><div class="line"><a name="l01800"></a><span class="lineno"> 1800</span>&#160;Expires: Thu, 01 Dec 1994 16:00:00 GMT </div><div class="line"><a name="l01801"></a><span class="lineno"> 1801</span>&#160;Content-Length: 861 </div><div class="line"><a name="l01802"></a><span class="lineno"> 1802</span>&#160;Content-Type: text/xml; charset=utf-8 </div><div class="line"><a name="l01803"></a><span class="lineno"> 1803</span>&#160;Content-Language: en </div><div class="line"><a name="l01804"></a><span class="lineno"> 1804</span>&#160;</div><div class="line"><a name="l01805"></a><span class="lineno"> 1805</span>&#160;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; </div><div class="line"><a name="l01806"></a><span class="lineno"> 1806</span>&#160;&lt;SOAP-ENV:Envelope xmlns:SOAP-ENV=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; </div><div class="line"><a name="l01807"></a><span class="lineno"> 1807</span>&#160;   xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; </div><div class="line"><a name="l01808"></a><span class="lineno"> 1808</span>&#160;   xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt; </div><div class="line"><a name="l01809"></a><span class="lineno"> 1809</span>&#160;&lt;SOAP-ENV:Body&gt; </div><div class="line"><a name="l01810"></a><span class="lineno"> 1810</span>&#160;&lt;ns1:getFlightInfoResponse xmlns:ns1=&quot;urn:galdemo:flighttracker&quot; </div><div class="line"><a name="l01811"></a><span class="lineno"> 1811</span>&#160;   SOAP-ENV:encodingStyle=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;&gt; </div><div class="line"><a name="l01812"></a><span class="lineno"> 1812</span>&#160;&lt;return xmlns:ns2=&quot;http://galdemo.flighttracker.com&quot; xsi:type=&quot;ns2:FlightInfo&quot;&gt; </div><div class="line"><a name="l01813"></a><span class="lineno"> 1813</span>&#160;&lt;equipment xsi:type=&quot;xsd:string&quot;&gt;A320&lt;/equipment&gt; </div><div class="line"><a name="l01814"></a><span class="lineno"> 1814</span>&#160;&lt;airline xsi:type=&quot;xsd:string&quot;&gt;UAL&lt;/airline&gt; </div><div class="line"><a name="l01815"></a><span class="lineno"> 1815</span>&#160;&lt;currentLocation xsi:type=&quot;xsd:string&quot;&gt;188 mi W of Lincoln, NE&lt;/currentLocation&gt; </div><div class="line"><a name="l01816"></a><span class="lineno"> 1816</span>&#160;&lt;altitude xsi:type=&quot;xsd:string&quot;&gt;37000&lt;/altitude&gt; </div><div class="line"><a name="l01817"></a><span class="lineno"> 1817</span>&#160;&lt;speed xsi:type=&quot;xsd:string&quot;&gt;497&lt;/speed&gt; </div><div class="line"><a name="l01818"></a><span class="lineno"> 1818</span>&#160;&lt;flightNumber xsi:type=&quot;xsd:string&quot;&gt;184&lt;/flightNumber&gt; </div><div class="line"><a name="l01819"></a><span class="lineno"> 1819</span>&#160;&lt;/return&gt; </div><div class="line"><a name="l01820"></a><span class="lineno"> 1820</span>&#160;&lt;/ns1:getFlightInfoResponse&gt; </div><div class="line"><a name="l01821"></a><span class="lineno"> 1821</span>&#160;&lt;/SOAP-ENV:Body&gt; </div><div class="line"><a name="l01822"></a><span class="lineno"> 1822</span>&#160;&lt;/SOAP-ENV:Envelope&gt;</div><div class="line"><a name="l01823"></a><span class="lineno"> 1823</span>&#160;```</div><div class="line"><a name="l01824"></a><span class="lineno"> 1824</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l01825"></a><span class="lineno"> 1825</span>&#160;</div><div class="line"><a name="l01826"></a><span class="lineno"> 1826</span>&#160;The proxy returns the service response in variable `r` of type `struct ns1__getFlightInfoResponse` and this information can be displayed by the client application with the following code fragment:</div><div class="line"><a name="l01827"></a><span class="lineno"> 1827</span>&#160;</div><div class="line"><a name="l01828"></a><span class="lineno"> 1828</span>&#160;```cpp</div><div class="line"><a name="l01829"></a><span class="lineno"> 1829</span>&#160;cout &lt;&lt; r.return_.equipment &lt;&lt; &quot; flight &quot; &lt;&lt; r.return_.airline &lt;&lt; r.return_.flightNumber </div><div class="line"><a name="l01830"></a><span class="lineno"> 1830</span>&#160;   &lt;&lt; &quot; traveling &quot; &lt;&lt; r.return_.speed &lt;&lt; &quot; mph &quot; &lt;&lt; &quot; at &quot; &lt;&lt; r.return_.altitude </div><div class="line"><a name="l01831"></a><span class="lineno"> 1831</span>&#160;   &lt;&lt; &quot; ft, is located &quot; &lt;&lt; r.return_.currentLocation &lt;&lt; endl;</div><div class="line"><a name="l01832"></a><span class="lineno"> 1832</span>&#160;```</div><div class="line"><a name="l01833"></a><span class="lineno"> 1833</span>&#160;</div><div class="line"><a name="l01834"></a><span class="lineno"> 1834</span>&#160;This code displays the service response as:</div><div class="line"><a name="l01835"></a><span class="lineno"> 1835</span>&#160;</div><div class="line"><a name="l01836"></a><span class="lineno"> 1836</span>&#160;    A320 flight UAL184 traveling 497 mph at 37000 ft, is located 188 mi W of Lincoln, NE</div><div class="line"><a name="l01837"></a><span class="lineno"> 1837</span>&#160;</div><div class="line"><a name="l01838"></a><span class="lineno"> 1838</span>&#160;Note: the flight tracker service is no longer available since 9/11/2001. It is kept in the documentation as an example to illustrate the use of structs/classes and response types.</div><div class="line"><a name="l01839"></a><span class="lineno"> 1839</span>&#160;</div><div class="line"><a name="l01840"></a><span class="lineno"> 1840</span>&#160;### How to Specify Anonymous Parameter Names        {#anonymous}</div><div class="line"><a name="l01841"></a><span class="lineno"> 1841</span>&#160;</div><div class="line"><a name="l01842"></a><span class="lineno"> 1842</span>&#160;The SOAP RPC encoding protocol allows parameter names to be anonymous.  That is, the name(s) of the output</div><div class="line"><a name="l01843"></a><span class="lineno"> 1843</span>&#160;parameters of a service operation are not strictly required to match a client&#39;s view of the parameters names.  Also, the</div><div class="line"><a name="l01844"></a><span class="lineno"> 1844</span>&#160;input parameter names of a service operation are not strictly required to match a service&#39;s view of the parameter names. </div><div class="line"><a name="l01845"></a><span class="lineno"> 1845</span>&#160;The gSOAP `soapcpp2` compiler can generate stub and skeleton</div><div class="line"><a name="l01846"></a><span class="lineno"> 1846</span>&#160;routines that support anonymous parameters.  Parameter names are implicitly</div><div class="line"><a name="l01847"></a><span class="lineno"> 1847</span>&#160;anonymous by omitting the parameter names in the function prototype of the</div><div class="line"><a name="l01848"></a><span class="lineno"> 1848</span>&#160;service operation. For example:</div><div class="line"><a name="l01849"></a><span class="lineno"> 1849</span>&#160;</div><div class="line"><a name="l01850"></a><span class="lineno"> 1850</span>&#160;```cpp</div><div class="line"><a name="l01851"></a><span class="lineno"> 1851</span>&#160;// Contents of &quot;calc.h&quot;: </div><div class="line"><a name="l01852"></a><span class="lineno"> 1852</span>&#160;typedef double xsd__double; </div><div class="line"><a name="l01853"></a><span class="lineno"> 1853</span>&#160;int ns2__add(xsd__string, xsd__double, xsd__double &amp;);</div><div class="line"><a name="l01854"></a><span class="lineno"> 1854</span>&#160;```</div><div class="line"><a name="l01855"></a><span class="lineno"> 1855</span>&#160;</div><div class="line"><a name="l01856"></a><span class="lineno"> 1856</span>&#160;To make parameter names explicitly anonymous on the receiving side (client or service),</div><div class="line"><a name="l01857"></a><span class="lineno"> 1857</span>&#160;the parameter names should start with an underscore (`_`) in the function prototype in the header file.</div><div class="line"><a name="l01858"></a><span class="lineno"> 1858</span>&#160;</div><div class="line"><a name="l01859"></a><span class="lineno"> 1859</span>&#160;For example:</div><div class="line"><a name="l01860"></a><span class="lineno"> 1860</span>&#160;</div><div class="line"><a name="l01861"></a><span class="lineno"> 1861</span>&#160;```cpp</div><div class="line"><a name="l01862"></a><span class="lineno"> 1862</span>&#160;// Contents of &quot;calc.h&quot;: </div><div class="line"><a name="l01863"></a><span class="lineno"> 1863</span>&#160;typedef double xsd__double; </div><div class="line"><a name="l01864"></a><span class="lineno"> 1864</span>&#160;int ns2__add(xsd__string _a, xsd__double _b, xsd__double &amp; _return);</div><div class="line"><a name="l01865"></a><span class="lineno"> 1865</span>&#160;```</div><div class="line"><a name="l01866"></a><span class="lineno"> 1866</span>&#160;</div><div class="line"><a name="l01867"></a><span class="lineno"> 1867</span>&#160;In this example, the `_a`, `_b`, and `_return` are anonymous parameters.</div><div class="line"><a name="l01868"></a><span class="lineno"> 1868</span>&#160;As a consequence, the service response to a request made by a client created with gSOAP using this header file specification</div><div class="line"><a name="l01869"></a><span class="lineno"> 1869</span>&#160;may include any name for the output parameter in the SOAP payload.</div><div class="line"><a name="l01870"></a><span class="lineno"> 1870</span>&#160;The input parameters may also be anonymous. This affects the implementation of Web services in gSOAP</div><div class="line"><a name="l01871"></a><span class="lineno"> 1871</span>&#160;and the matching of parameter names by the service.</div><div class="line"><a name="l01872"></a><span class="lineno"> 1872</span>&#160;</div><div class="line"><a name="l01873"></a><span class="lineno"> 1873</span>&#160;@warning when anonymous parameter names are used, the order of the parameters in the function prototype of a service operation is</div><div class="line"><a name="l01874"></a><span class="lineno"> 1874</span>&#160;significant.</div><div class="line"><a name="l01875"></a><span class="lineno"> 1875</span>&#160;</div><div class="line"><a name="l01876"></a><span class="lineno"> 1876</span>&#160;### How to Specify a Method with No Input Parameters</div><div class="line"><a name="l01877"></a><span class="lineno"> 1877</span>&#160;</div><div class="line"><a name="l01878"></a><span class="lineno"> 1878</span>&#160;To specify a service operation that has no input parameters, just provide a function prototype with one parameter which is the output</div><div class="line"><a name="l01879"></a><span class="lineno"> 1879</span>&#160;parameter (some C/C++ compilers will not compile and complain about an empty</div><div class="line"><a name="l01880"></a><span class="lineno"> 1880</span>&#160;`struct`: use compile flag `-DWITH_NOEMPTYSTRUCT` to compile the generated code for these cases). This `struct` is generated by gSOAP to contain the SOAP request message.  To fix this, provide one input</div><div class="line"><a name="l01881"></a><span class="lineno"> 1881</span>&#160;parameter of type `void*` (gSOAP can not serialize `void*` data).  For example:</div><div class="line"><a name="l01882"></a><span class="lineno"> 1882</span>&#160;</div><div class="line"><a name="l01883"></a><span class="lineno"> 1883</span>&#160;```cpp</div><div class="line"><a name="l01884"></a><span class="lineno"> 1884</span>&#160;struct ns3__SOAPService </div><div class="line"><a name="l01885"></a><span class="lineno"> 1885</span>&#160;{ </div><div class="line"><a name="l01886"></a><span class="lineno"> 1886</span>&#160;  public: </div><div class="line"><a name="l01887"></a><span class="lineno"> 1887</span>&#160;  int ID; </div><div class="line"><a name="l01888"></a><span class="lineno"> 1888</span>&#160;  char *name; </div><div class="line"><a name="l01889"></a><span class="lineno"> 1889</span>&#160;  char *owner; </div><div class="line"><a name="l01890"></a><span class="lineno"> 1890</span>&#160;  char *description; </div><div class="line"><a name="l01891"></a><span class="lineno"> 1891</span>&#160;  char *homepageURL; </div><div class="line"><a name="l01892"></a><span class="lineno"> 1892</span>&#160;  char *endpoint; </div><div class="line"><a name="l01893"></a><span class="lineno"> 1893</span>&#160;  char *SOAPAction; </div><div class="line"><a name="l01894"></a><span class="lineno"> 1894</span>&#160;  char *methodNamespaceURI; </div><div class="line"><a name="l01895"></a><span class="lineno"> 1895</span>&#160;  char *serviceStatus; </div><div class="line"><a name="l01896"></a><span class="lineno"> 1896</span>&#160;  char *methodName; </div><div class="line"><a name="l01897"></a><span class="lineno"> 1897</span>&#160;  char *dateCreated; </div><div class="line"><a name="l01898"></a><span class="lineno"> 1898</span>&#160;  char *downloadURL; </div><div class="line"><a name="l01899"></a><span class="lineno"> 1899</span>&#160;  char *wsdlURL; </div><div class="line"><a name="l01900"></a><span class="lineno"> 1900</span>&#160;  char *instructions; </div><div class="line"><a name="l01901"></a><span class="lineno"> 1901</span>&#160;  char *contactEmail; </div><div class="line"><a name="l01902"></a><span class="lineno"> 1902</span>&#160;  char *serverImplementation; </div><div class="line"><a name="l01903"></a><span class="lineno"> 1903</span>&#160;}; </div><div class="line"><a name="l01904"></a><span class="lineno"> 1904</span>&#160;struct ArrayOfSOAPService {struct ns3__SOAPService *__ptr; int __size;}; </div><div class="line"><a name="l01905"></a><span class="lineno"> 1905</span>&#160;int ns__getAllSOAPServices(void *_, struct ArrayOfSOAPService &amp;_return);</div><div class="line"><a name="l01906"></a><span class="lineno"> 1906</span>&#160;```</div><div class="line"><a name="l01907"></a><span class="lineno"> 1907</span>&#160;</div><div class="line"><a name="l01908"></a><span class="lineno"> 1908</span>&#160;The `ns__getAllSOAPServices` method has one `void*` input parameter which is ignored by the serializer to produce the</div><div class="line"><a name="l01909"></a><span class="lineno"> 1909</span>&#160;request message.</div><div class="line"><a name="l01910"></a><span class="lineno"> 1910</span>&#160;</div><div class="line"><a name="l01911"></a><span class="lineno"> 1911</span>&#160;Most C/C++ compilers allow empty `struct`s and therefore the `void*` parameter is not required.</div><div class="line"><a name="l01912"></a><span class="lineno"> 1912</span>&#160;</div><div class="line"><a name="l01913"></a><span class="lineno"> 1913</span>&#160;### How to Specify a Method with No Output Parameters</div><div class="line"><a name="l01914"></a><span class="lineno"> 1914</span>&#160;</div><div class="line"><a name="l01915"></a><span class="lineno"> 1915</span>&#160;To specify a service operation that has no output parameters, just define a function prototype with a response struct that is</div><div class="line"><a name="l01916"></a><span class="lineno"> 1916</span>&#160;empty. For example:</div><div class="line"><a name="l01917"></a><span class="lineno"> 1917</span>&#160;</div><div class="line"><a name="l01918"></a><span class="lineno"> 1918</span>&#160;```cpp</div><div class="line"><a name="l01919"></a><span class="lineno"> 1919</span>&#160;enum ns__event { off, on, stand_by }; </div><div class="line"><a name="l01920"></a><span class="lineno"> 1920</span>&#160;int ns__signal(enum ns__event in, struct ns__signalResponse { } *out);</div><div class="line"><a name="l01921"></a><span class="lineno"> 1921</span>&#160;```</div><div class="line"><a name="l01922"></a><span class="lineno"> 1922</span>&#160;</div><div class="line"><a name="l01923"></a><span class="lineno"> 1923</span>&#160;Since the response struct is empty, no output parameters are specified.</div><div class="line"><a name="l01924"></a><span class="lineno"> 1924</span>&#160;</div><div class="line"><a name="l01925"></a><span class="lineno"> 1925</span>&#160;Some SOAP resources refer to SOAP RPC with empty responses as **one way** SOAP messaging. However, we refer to one-way massaging</div><div class="line"><a name="l01926"></a><span class="lineno"> 1926</span>&#160;by asynchronous explicit send and receive operations as described in Section \ref oneway1 .  The latter view of one-way SOAP messaging is also in line with Basic Profile 1.0.</div><div class="line"><a name="l01927"></a><span class="lineno"> 1927</span>&#160;</div><div class="line"><a name="l01928"></a><span class="lineno"> 1928</span>&#160;## How to Build SOAP/XML Web Services</div><div class="line"><a name="l01929"></a><span class="lineno"> 1929</span>&#160;</div><div class="line"><a name="l01930"></a><span class="lineno"> 1930</span>&#160;The gSOAP `soapcpp2` compiler generates **skeleton** routines in C++ source form for each of the service operations specified</div><div class="line"><a name="l01931"></a><span class="lineno"> 1931</span>&#160;as function prototypes in the header file processed by the gSOAP `soapcpp2` compiler.  The skeleton routines can be readily used to implement</div><div class="line"><a name="l01932"></a><span class="lineno"> 1932</span>&#160;the service operations in a new SOAP Web service. The compound data types used by the input and output parameters of service operations</div><div class="line"><a name="l01933"></a><span class="lineno"> 1933</span>&#160;must be declared in the header file, such as structs, classes, arrays, and pointer-based data structures (graphs) that are</div><div class="line"><a name="l01934"></a><span class="lineno"> 1934</span>&#160;used as the data types of the parameters of a service operation. The gSOAP `soapcpp2` compiler automatically generates serializers and</div><div class="line"><a name="l01935"></a><span class="lineno"> 1935</span>&#160;deserializers for the data types to enable the generated skeleton routines to encode and decode the contents of the parameters of</div><div class="line"><a name="l01936"></a><span class="lineno"> 1936</span>&#160;the service operations.  The gSOAP `soapcpp2` compiler also generates a service operation request dispatcher routine that will serve requests by</div><div class="line"><a name="l01937"></a><span class="lineno"> 1937</span>&#160;calling the appropriate skeleton when the SOAP service application is installed as a CGI application on a Web server.</div><div class="line"><a name="l01938"></a><span class="lineno"> 1938</span>&#160;</div><div class="line"><a name="l01939"></a><span class="lineno"> 1939</span>&#160;### Example        {#example7}</div><div class="line"><a name="l01940"></a><span class="lineno"> 1940</span>&#160;</div><div class="line"><a name="l01941"></a><span class="lineno"> 1941</span>&#160;The following example specifies three service operations to be implemented by a new SOAP Web service:</div><div class="line"><a name="l01942"></a><span class="lineno"> 1942</span>&#160;</div><div class="line"><a name="l01943"></a><span class="lineno"> 1943</span>&#160;```cpp</div><div class="line"><a name="l01944"></a><span class="lineno"> 1944</span>&#160;// Contents of file &quot;calc.h&quot;: </div><div class="line"><a name="l01945"></a><span class="lineno"> 1945</span>&#160;typedef double xsd__double; </div><div class="line"><a name="l01946"></a><span class="lineno"> 1946</span>&#160;int ns__add(xsd__double a, xsd__double b, xsd__double &amp;result); </div><div class="line"><a name="l01947"></a><span class="lineno"> 1947</span>&#160;int ns__sub(xsd__double a, xsd__double b, xsd__double &amp;result); </div><div class="line"><a name="l01948"></a><span class="lineno"> 1948</span>&#160;int ns__sqrt(xsd__double a, xsd__double &amp;result); </div><div class="line"><a name="l01949"></a><span class="lineno"> 1949</span>&#160;```</div><div class="line"><a name="l01950"></a><span class="lineno"> 1950</span>&#160;</div><div class="line"><a name="l01951"></a><span class="lineno"> 1951</span>&#160;The `add` and `sub` methods are intended to add and subtract two double floating point numbers stored in input parameters</div><div class="line"><a name="l01952"></a><span class="lineno"> 1952</span>&#160;`a` and `b` and should return the result of the operation in the `result` output parameter. The `sqrt` method is</div><div class="line"><a name="l01953"></a><span class="lineno"> 1953</span>&#160;intended to take the square root of input parameter `a` and to return the result in the output parameter `result`.</div><div class="line"><a name="l01954"></a><span class="lineno"> 1954</span>&#160;The `xsd__double` type is recognized by the gSOAP `soapcpp2` compiler as the *`xsd:double`* XSD Schema data type.</div><div class="line"><a name="l01955"></a><span class="lineno"> 1955</span>&#160;The use of `typedef` is a convenient way to associate primitive C types with primitive XML Schema data types.</div><div class="line"><a name="l01956"></a><span class="lineno"> 1956</span>&#160;</div><div class="line"><a name="l01957"></a><span class="lineno"> 1957</span>&#160;To generate the skeleton routines, the gSOAP `soapcpp2` compiler is invoked from the command line with:</div><div class="line"><a name="l01958"></a><span class="lineno"> 1958</span>&#160;</div><div class="line"><a name="l01959"></a><span class="lineno"> 1959</span>&#160;    &gt; soapcpp2 calc.h</div><div class="line"><a name="l01960"></a><span class="lineno"> 1960</span>&#160;</div><div class="line"><a name="l01961"></a><span class="lineno"> 1961</span>&#160;The compiler generates the skeleton routines for the `add`, `sub`, and `sqrt` service operations specified in the</div><div class="line"><a name="l01962"></a><span class="lineno"> 1962</span>&#160;`calc.h` header file. The skeleton routines are respectively, `soap_serve_ns__add`, `soap_serve_ns__sub`, and</div><div class="line"><a name="l01963"></a><span class="lineno"> 1963</span>&#160;`soap_serve_ns__sqrt` and saved in the file `soapServer.cpp`. The generated file `soapC.cpp` contains serializers</div><div class="line"><a name="l01964"></a><span class="lineno"> 1964</span>&#160;and deserializers for the skeleton. The compiler also generates a service dispatcher: the `soap_serve` function handles</div><div class="line"><a name="l01965"></a><span class="lineno"> 1965</span>&#160;client requests on the standard input stream and dispatches the service operation requests to the appropriate skeletons to serve the</div><div class="line"><a name="l01966"></a><span class="lineno"> 1966</span>&#160;requests. The skeleton in turn calls the service operation implementation function. The function prototype of the service operation</div><div class="line"><a name="l01967"></a><span class="lineno"> 1967</span>&#160;implementation function is specified in the header file that is input to the gSOAP `soapcpp2` compiler.</div><div class="line"><a name="l01968"></a><span class="lineno"> 1968</span>&#160;</div><div class="line"><a name="l01969"></a><span class="lineno"> 1969</span>&#160;Here is an example Calculator service application that uses the generated `soap_serve` routine to handle client requests:</div><div class="line"><a name="l01970"></a><span class="lineno"> 1970</span>&#160;</div><div class="line"><a name="l01971"></a><span class="lineno"> 1971</span>&#160;```cpp</div><div class="line"><a name="l01972"></a><span class="lineno"> 1972</span>&#160;// Contents of file &quot;calc.cpp&quot;: </div><div class="line"><a name="l01973"></a><span class="lineno"> 1973</span>&#160;#include &quot;soapH.h&quot; </div><div class="line"><a name="l01974"></a><span class="lineno"> 1974</span>&#160;#include &lt;math.h&gt; // for sqrt() </div><div class="line"><a name="l01975"></a><span class="lineno"> 1975</span>&#160;int main() </div><div class="line"><a name="l01976"></a><span class="lineno"> 1976</span>&#160;{ </div><div class="line"><a name="l01977"></a><span class="lineno"> 1977</span>&#160;   return soap_serve(soap_new()); // use the service operation request dispatcher </div><div class="line"><a name="l01978"></a><span class="lineno"> 1978</span>&#160;} </div><div class="line"><a name="l01979"></a><span class="lineno"> 1979</span>&#160;// Implementation of the &quot;add&quot; service operation: </div><div class="line"><a name="l01980"></a><span class="lineno"> 1980</span>&#160;int ns__add(struct soap *soap, double a, double b, double &amp;result) </div><div class="line"><a name="l01981"></a><span class="lineno"> 1981</span>&#160;{ </div><div class="line"><a name="l01982"></a><span class="lineno"> 1982</span>&#160;   result = a + b; </div><div class="line"><a name="l01983"></a><span class="lineno"> 1983</span>&#160;   return SOAP_OK; </div><div class="line"><a name="l01984"></a><span class="lineno"> 1984</span>&#160;} </div><div class="line"><a name="l01985"></a><span class="lineno"> 1985</span>&#160;// Implementation of the &quot;sub&quot; service operation: </div><div class="line"><a name="l01986"></a><span class="lineno"> 1986</span>&#160;int ns__sub(struct soap *soap, double a, double b, double &amp;result) </div><div class="line"><a name="l01987"></a><span class="lineno"> 1987</span>&#160;{ </div><div class="line"><a name="l01988"></a><span class="lineno"> 1988</span>&#160;   result = a - b; </div><div class="line"><a name="l01989"></a><span class="lineno"> 1989</span>&#160;   return SOAP_OK; </div><div class="line"><a name="l01990"></a><span class="lineno"> 1990</span>&#160;} </div><div class="line"><a name="l01991"></a><span class="lineno"> 1991</span>&#160;// Implementation of the &quot;sqrt&quot; service operation: </div><div class="line"><a name="l01992"></a><span class="lineno"> 1992</span>&#160;int ns__sqrt(struct soap *soap, double a, double &amp;result) </div><div class="line"><a name="l01993"></a><span class="lineno"> 1993</span>&#160;{ </div><div class="line"><a name="l01994"></a><span class="lineno"> 1994</span>&#160;   if (a &gt;= 0) </div><div class="line"><a name="l01995"></a><span class="lineno"> 1995</span>&#160;   { </div><div class="line"><a name="l01996"></a><span class="lineno"> 1996</span>&#160;     result = sqrt(a); </div><div class="line"><a name="l01997"></a><span class="lineno"> 1997</span>&#160;     return SOAP_OK; </div><div class="line"><a name="l01998"></a><span class="lineno"> 1998</span>&#160;   } </div><div class="line"><a name="l01999"></a><span class="lineno"> 1999</span>&#160;   else </div><div class="line"><a name="l02000"></a><span class="lineno"> 2000</span>&#160;     return soap_receiver_fault(soap, &quot;Square root of negative number&quot;, &quot;I can only take the square root of a non-negative number&quot;); </div><div class="line"><a name="l02001"></a><span class="lineno"> 2001</span>&#160;} </div><div class="line"><a name="l02002"></a><span class="lineno"> 2002</span>&#160;// As always, a namespace mapping table is needed: </div><div class="line"><a name="l02003"></a><span class="lineno"> 2003</span>&#160;struct Namespace namespaces[] = </div><div class="line"><a name="l02004"></a><span class="lineno"> 2004</span>&#160;{   // {&quot;ns-prefix&quot;, &quot;ns-name&quot;} </div><div class="line"><a name="l02005"></a><span class="lineno"> 2005</span>&#160;  {&quot;SOAP-ENV&quot;, &quot;http://schemas.xmlsoap.org/soap/envelope/&quot;}, </div><div class="line"><a name="l02006"></a><span class="lineno"> 2006</span>&#160;  {&quot;SOAP-ENC&quot;, &quot;http://schemas.xmlsoap.org/soap/encoding/&quot;}, </div><div class="line"><a name="l02007"></a><span class="lineno"> 2007</span>&#160;  {&quot;xsi&quot;,      &quot;http://www.w3.org/2001/XMLSchema-instance&quot;}, </div><div class="line"><a name="l02008"></a><span class="lineno"> 2008</span>&#160;  {&quot;xsd&quot;,      &quot;http://www.w3.org/2001/XMLSchema&quot;}, </div><div class="line"><a name="l02009"></a><span class="lineno"> 2009</span>&#160;  {&quot;ns&quot;,       &quot;urn:simple-calc&quot;}, // bind &quot;ns&quot; namespace prefix </div><div class="line"><a name="l02010"></a><span class="lineno"> 2010</span>&#160;  {NULL, NULL} </div><div class="line"><a name="l02011"></a><span class="lineno"> 2011</span>&#160;};</div><div class="line"><a name="l02012"></a><span class="lineno"> 2012</span>&#160;```</div><div class="line"><a name="l02013"></a><span class="lineno"> 2013</span>&#160;</div><div class="line"><a name="l02014"></a><span class="lineno"> 2014</span>&#160;Note that the service operations have an extra input parameter which is a pointer to the gSOAP runtime context.</div><div class="line"><a name="l02015"></a><span class="lineno"> 2015</span>&#160;The implementation of the service operations MUST return a SOAP error code. The code `SOAP_OK` denotes success, while</div><div class="line"><a name="l02016"></a><span class="lineno"> 2016</span>&#160;`SOAP_FAULT` denotes an exception with details that can be defined by the user. The exception description can be assigned to</div><div class="line"><a name="l02017"></a><span class="lineno"> 2017</span>&#160;the `soap-&gt;fault-&gt;faultstring` string and details can be assigned to the</div><div class="line"><a name="l02018"></a><span class="lineno"> 2018</span>&#160;`soap-&gt;fault-&gt;detail` string. This is SOAP 1.1 specific. SOAP 1.2 requires</div><div class="line"><a name="l02019"></a><span class="lineno"> 2019</span>&#160;the `soap-&gt;fault-&gt;SOAP_ENV__Reason` and the</div><div class="line"><a name="l02020"></a><span class="lineno"> 2020</span>&#160;`soap-&gt;fault-&gt;SOAP_ENV__Detail` strings to be assigned.</div><div class="line"><a name="l02021"></a><span class="lineno"> 2021</span>&#160;Better is to use the</div><div class="line"><a name="l02022"></a><span class="lineno"> 2022</span>&#160;`soap_receiver_fault` function that allocates a fault struct and sets the SOAP Fault string and details</div><div class="line"><a name="l02023"></a><span class="lineno"> 2023</span>&#160;regardless of the SOAP 1.1 or SOAP 1.2 version used. The `soap_receiver_fault` function returns</div><div class="line"><a name="l02024"></a><span class="lineno"> 2024</span>&#160;`SOAP_FAULT`, i.e. an application-specific fault. The fault exception will be passed on to the client of this service.</div><div class="line"><a name="l02025"></a><span class="lineno"> 2025</span>&#160;</div><div class="line"><a name="l02026"></a><span class="lineno"> 2026</span>&#160;This service application can be readily installed as a CGI application. The service description would be:</div><div class="line"><a name="l02027"></a><span class="lineno"> 2027</span>&#160;</div><div class="line"><a name="l02028"></a><span class="lineno"> 2028</span>&#160;* Endpoint URL: the URL of the CGI application </div><div class="line"><a name="l02029"></a><span class="lineno"> 2029</span>&#160;</div><div class="line"><a name="l02030"></a><span class="lineno"> 2030</span>&#160;* SOAP action: &quot;&quot; (2 quotes) </div><div class="line"><a name="l02031"></a><span class="lineno"> 2031</span>&#160;</div><div class="line"><a name="l02032"></a><span class="lineno"> 2032</span>&#160;* Remote method namespace: *`urn:simple-calc`* </div><div class="line"><a name="l02033"></a><span class="lineno"> 2033</span>&#160;</div><div class="line"><a name="l02034"></a><span class="lineno"> 2034</span>&#160;* Remote method name: *`add`* </div><div class="line"><a name="l02035"></a><span class="lineno"> 2035</span>&#160;   * Input parameters: *`a`* of type *`xsd:double`* and *`b`* of type *`xsd:double`* </div><div class="line"><a name="l02036"></a><span class="lineno"> 2036</span>&#160;   * Output parameter: *`result`* of type *`xsd:double`* </div><div class="line"><a name="l02037"></a><span class="lineno"> 2037</span>&#160;</div><div class="line"><a name="l02038"></a><span class="lineno"> 2038</span>&#160;* Remote method name: *`sub`* </div><div class="line"><a name="l02039"></a><span class="lineno"> 2039</span>&#160;   * Input parameters: *`a`* of type *`xsd:double`* and *`b`* of type *`xsd:double`* </div><div class="line"><a name="l02040"></a><span class="lineno"> 2040</span>&#160;   * Output parameter: *`result`* of type *`xsd:double`* </div><div class="line"><a name="l02041"></a><span class="lineno"> 2041</span>&#160;</div><div class="line"><a name="l02042"></a><span class="lineno"> 2042</span>&#160;* Remote method name: *`sqrt`* </div><div class="line"><a name="l02043"></a><span class="lineno"> 2043</span>&#160;   * Input parameter: *`a`* of type *`xsd:double`* </div><div class="line"><a name="l02044"></a><span class="lineno"> 2044</span>&#160;   * Output parameter: *`result`* of type *`xsd:double`* or a SOAP Fault</div><div class="line"><a name="l02045"></a><span class="lineno"> 2045</span>&#160;</div><div class="line"><a name="l02046"></a><span class="lineno"> 2046</span>&#160;The `soapcpp2` compile generates a WSDL file for this service, see Section \ref wsdl .</div><div class="line"><a name="l02047"></a><span class="lineno"> 2047</span>&#160;</div><div class="line"><a name="l02048"></a><span class="lineno"> 2048</span>&#160;Unless the CGI application inspects and checks the environment variable `SOAPAction` which contains the SOAP action request by</div><div class="line"><a name="l02049"></a><span class="lineno"> 2049</span>&#160;a client, the SOAP action is ignored by the CGI application.  SOAP actions are specific to the SOAP protocol and provide a means</div><div class="line"><a name="l02050"></a><span class="lineno"> 2050</span>&#160;for routing requests and for security reasons (e.g. firewall software can inspect SOAP action headers to grant or deny the</div><div class="line"><a name="l02051"></a><span class="lineno"> 2051</span>&#160;SOAP request. Note that this requires the SOAP service to check the SOAP action header as well to match it with the service operation.)</div><div class="line"><a name="l02052"></a><span class="lineno"> 2052</span>&#160;</div><div class="line"><a name="l02053"></a><span class="lineno"> 2053</span>&#160;The header file input to the gSOAP `soapcpp2` compiler does not need to be modified to generate client stubs for accessing this</div><div class="line"><a name="l02054"></a><span class="lineno"> 2054</span>&#160;service.  Client applications can be developed by using the same header file as for which the service application</div><div class="line"><a name="l02055"></a><span class="lineno"> 2055</span>&#160;was developed.  For example, the `soap_call_ns__add` stub routine is available from the `soapClient.cpp` file after invoking</div><div class="line"><a name="l02056"></a><span class="lineno"> 2056</span>&#160;the gSOAP `soapcpp2` compiler on the `calc.h` header file. As a result, client and service applications can be developed without</div><div class="line"><a name="l02057"></a><span class="lineno"> 2057</span>&#160;the need to know the details of the SOAP encoding used.</div><div class="line"><a name="l02058"></a><span class="lineno"> 2058</span>&#160;</div><div class="line"><a name="l02059"></a><span class="lineno"> 2059</span>&#160;### MSVC++ Builds</div><div class="line"><a name="l02060"></a><span class="lineno"> 2060</span>&#160;</div><div class="line"><a name="l02061"></a><span class="lineno"> 2061</span>&#160;</div><div class="line"><a name="l02062"></a><span class="lineno"> 2062</span>&#160;</div><div class="line"><a name="l02063"></a><span class="lineno"> 2063</span>&#160;*  Win32 builds need winsock2 (MS Visual C++ &quot;ws2_32.lib&quot;)</div><div class="line"><a name="l02064"></a><span class="lineno"> 2064</span>&#160;To do this in Visual C++ 6.0, go to &quot;Project&quot;, &quot;settings&quot;, select the &quot;Link&quot;</div><div class="line"><a name="l02065"></a><span class="lineno"> 2065</span>&#160;tab (the project file needs to be selected in the file view) and add</div><div class="line"><a name="l02066"></a><span class="lineno"> 2066</span>&#160;&quot;`ws2_32.lib`&quot; to the &quot;`Object/library modules`&quot; entry.</div><div class="line"><a name="l02067"></a><span class="lineno"> 2067</span>&#160;</div><div class="line"><a name="l02068"></a><span class="lineno"> 2068</span>&#160;</div><div class="line"><a name="l02069"></a><span class="lineno"> 2069</span>&#160;*  Use files with extension .cpp only (don&#39;t mix .c with .cpp).</div><div class="line"><a name="l02070"></a><span class="lineno"> 2070</span>&#160;</div><div class="line"><a name="l02071"></a><span class="lineno"> 2071</span>&#160;</div><div class="line"><a name="l02072"></a><span class="lineno"> 2072</span>&#160;*  Turn pre-compiled headers off.</div><div class="line"><a name="l02073"></a><span class="lineno"> 2073</span>&#160;</div><div class="line"><a name="l02074"></a><span class="lineno"> 2074</span>&#160;</div><div class="line"><a name="l02075"></a><span class="lineno"> 2075</span>&#160;*  When creating a new project, you can specify a custom build step to automatically invoke the gSOAP `soapcpp2` compiler on a gSOAP header file. In this way you can incrementally build a new service by adding new operations and data types to the header file. To specify a custom build step, select the &quot;Project&quot; menu item &quot;Settings&quot; and select the header file in the File view pane. Select the &quot;Custom Build&quot; tab and enter &#39;`soapcpp2.exe &quot;$(inputPath)&quot;`&#39; in the &quot;Command&quot; pane. Enter &#39;`soapStub.h soapH.h soapC.cpp soapClient.cpp soapServer.cpp`&#39;. Don&#39;t forget to add the `soapXYZProxy.h soapXYZObject.h` files that are generated for C++ class proxies and server objects named XYZ. Click &quot;OK&quot;. Run `soapcpp2` once to generate these files (you can simply do this by selecting your header file and select &quot;Compile&quot;). Add the files to your project. Each time you make a change to the header file, the project sources are updated automatically.</div><div class="line"><a name="l02076"></a><span class="lineno"> 2076</span>&#160;</div><div class="line"><a name="l02077"></a><span class="lineno"> 2077</span>&#160;</div><div class="line"><a name="l02078"></a><span class="lineno"> 2078</span>&#160;*  You may want to use the WinInet interface available in the `mod_gsoap` directory of the gSOAP package to simplify Internet access and deal with encryption, proxies, and authentication. API instructions are included in the source.</div><div class="line"><a name="l02079"></a><span class="lineno"> 2079</span>&#160;</div><div class="line"><a name="l02080"></a><span class="lineno"> 2080</span>&#160;</div><div class="line"><a name="l02081"></a><span class="lineno"> 2081</span>&#160;*  For the PocketPC, run the `wsdl2h` WSDL parser with option `-s` to prevent the generation of STL code. In addition, `time_t` serialization is not supported, which means that you should add the following line to `typemap.dat` indicating a mapping of `xsd__dateTime` to `char*`: *`xsd__dateTime = | char* | char*`*.</div><div class="line"><a name="l02082"></a><span class="lineno"> 2082</span>&#160;</div><div class="line"><a name="l02083"></a><span class="lineno"> 2083</span>&#160;</div><div class="line"><a name="l02084"></a><span class="lineno"> 2084</span>&#160;</div><div class="line"><a name="l02085"></a><span class="lineno"> 2085</span>&#160;### How to Create a Stand-Alone Server        {#stand-alone}</div><div class="line"><a name="l02086"></a><span class="lineno"> 2086</span>&#160;</div><div class="line"><a name="l02087"></a><span class="lineno"> 2087</span>&#160;The deployment of a Web service as a CGI application is an easy means to</div><div class="line"><a name="l02088"></a><span class="lineno"> 2088</span>&#160;provide your service on the Internet. However, the performance of CGI is not</div><div class="line"><a name="l02089"></a><span class="lineno"> 2089</span>&#160;great.  Also, gSOAP services can be run as stand-alone services on any port by</div><div class="line"><a name="l02090"></a><span class="lineno"> 2090</span>&#160;utilizing the built-in HTTP and TCP/IP stacks.  However, the preferred</div><div class="line"><a name="l02091"></a><span class="lineno"> 2091</span>&#160;mechanism to deploy a service is through an Apache module or IIS module. These</div><div class="line"><a name="l02092"></a><span class="lineno"> 2092</span>&#160;servers and modules are designed for server load balancing and access control.</div><div class="line"><a name="l02093"></a><span class="lineno"> 2093</span>&#160;</div><div class="line"><a name="l02094"></a><span class="lineno"> 2094</span>&#160;To create a stand-alone service, only the `main` routine of the service needs to be modified as follows.  Instead of just calling the</div><div class="line"><a name="l02095"></a><span class="lineno"> 2095</span>&#160;`soap_serve` routine, the `main` routine is changed into:</div><div class="line"><a name="l02096"></a><span class="lineno"> 2096</span>&#160;</div><div class="line"><a name="l02097"></a><span class="lineno"> 2097</span>&#160;```cpp</div><div class="line"><a name="l02098"></a><span class="lineno"> 2098</span>&#160;int main() </div><div class="line"><a name="l02099"></a><span class="lineno"> 2099</span>&#160;{</div><div class="line"><a name="l02100"></a><span class="lineno"> 2100</span>&#160;   struct soap soap; </div><div class="line"><a name="l02101"></a><span class="lineno"> 2101</span>&#160;   int m, s; // master and slave sockets </div><div class="line"><a name="l02102"></a><span class="lineno"> 2102</span>&#160;   soap_init(&amp;soap); </div><div class="line"><a name="l02103"></a><span class="lineno"> 2103</span>&#160;   m = soap_bind(&amp;soap, &quot;machine.genivia.com&quot;, 18083, 100); </div><div class="line"><a name="l02104"></a><span class="lineno"> 2104</span>&#160;   if (m &lt; 0) </div><div class="line"><a name="l02105"></a><span class="lineno"> 2105</span>&#160;     soap_print_fault(&amp;soap, stderr); </div><div class="line"><a name="l02106"></a><span class="lineno"> 2106</span>&#160;   else </div><div class="line"><a name="l02107"></a><span class="lineno"> 2107</span>&#160;  { </div><div class="line"><a name="l02108"></a><span class="lineno"> 2108</span>&#160;     fprintf(stderr, &quot;Socket connection successful: master socket = %d\n&quot;, m); </div><div class="line"><a name="l02109"></a><span class="lineno"> 2109</span>&#160;     for (int i = 1; ; i++) </div><div class="line"><a name="l02110"></a><span class="lineno"> 2110</span>&#160;     {</div><div class="line"><a name="l02111"></a><span class="lineno"> 2111</span>&#160;       s = soap_accept(&amp;soap); </div><div class="line"><a name="l02112"></a><span class="lineno"> 2112</span>&#160;       if (s &lt; 0) </div><div class="line"><a name="l02113"></a><span class="lineno"> 2113</span>&#160;       { </div><div class="line"><a name="l02114"></a><span class="lineno"> 2114</span>&#160;         soap_print_fault(&amp;soap, stderr); </div><div class="line"><a name="l02115"></a><span class="lineno"> 2115</span>&#160;         break; </div><div class="line"><a name="l02116"></a><span class="lineno"> 2116</span>&#160;       } </div><div class="line"><a name="l02117"></a><span class="lineno"> 2117</span>&#160;       fprintf(stderr, &quot;%d: accepted connection from IP=%d.%d.%d.%d socket=%d&quot;, i, </div><div class="line"><a name="l02118"></a><span class="lineno"> 2118</span>&#160;         (soap.ip&gt;&gt;24)&amp;0xFF, (soap.ip&gt;&gt;16)&amp;0xFF, (soap.ip&gt;&gt;8)&amp;0xFF, soap.ip&amp;0xFF, s); </div><div class="line"><a name="l02119"></a><span class="lineno"> 2119</span>&#160;       if (soap_serve(&amp;soap) != SOAP_OK)        // process RPC request </div><div class="line"><a name="l02120"></a><span class="lineno"> 2120</span>&#160;         soap_print_fault(&amp;soap, stderr); // print error </div><div class="line"><a name="l02121"></a><span class="lineno"> 2121</span>&#160;       fprintf(stderr, &quot;request served\n&quot;); </div><div class="line"><a name="l02122"></a><span class="lineno"> 2122</span>&#160;       soap_destroy(&amp;soap);     // clean up class instances </div><div class="line"><a name="l02123"></a><span class="lineno"> 2123</span>&#160;       soap_end(&amp;soap); // clean up everything and close socket </div><div class="line"><a name="l02124"></a><span class="lineno"> 2124</span>&#160;     } </div><div class="line"><a name="l02125"></a><span class="lineno"> 2125</span>&#160;   } </div><div class="line"><a name="l02126"></a><span class="lineno"> 2126</span>&#160;   soap_done(&amp;soap); // close master socket and detach context </div><div class="line"><a name="l02127"></a><span class="lineno"> 2127</span>&#160;}</div><div class="line"><a name="l02128"></a><span class="lineno"> 2128</span>&#160;```</div><div class="line"><a name="l02129"></a><span class="lineno"> 2129</span>&#160;</div><div class="line"><a name="l02130"></a><span class="lineno"> 2130</span>&#160;The `soap_serve` dispatcher handles one request or multiple requests when HTTP keep-alive is enabled (with the `SOAP_IO_KEEPALIVE` flag see Section \ref keepalive ).</div><div class="line"><a name="l02131"></a><span class="lineno"> 2131</span>&#160;</div><div class="line"><a name="l02132"></a><span class="lineno"> 2132</span>&#160;The gSOAP functions that are frequently used for server-side coding are:</div><div class="line"><a name="l02133"></a><span class="lineno"> 2133</span>&#160;</div><div class="line"><a name="l02134"></a><span class="lineno"> 2134</span>&#160;* `soap_new()` Allocates and Initializes gSOAP context </div><div class="line"><a name="l02135"></a><span class="lineno"> 2135</span>&#160;</div><div class="line"><a name="l02136"></a><span class="lineno"> 2136</span>&#160;* `soap_init(struct soap *soap)` Initializes a stack-allocated gSOAP context (required once) </div><div class="line"><a name="l02137"></a><span class="lineno"> 2137</span>&#160;</div><div class="line"><a name="l02138"></a><span class="lineno"> 2138</span>&#160;* `soap_bind(struct soap *soap, char *host, int port, int backlog)` Returns master socket (backlog = max. queue</div><div class="line"><a name="l02139"></a><span class="lineno"> 2139</span>&#160;</div><div class="line"><a name="l02140"></a><span class="lineno"> 2140</span>&#160;* size for requests). When `host==NULL`: host is the machine on which the service runs </div><div class="line"><a name="l02141"></a><span class="lineno"> 2141</span>&#160;</div><div class="line"><a name="l02142"></a><span class="lineno"> 2142</span>&#160;* `soap_accept(struct soap *soap)` Returns slave socket </div><div class="line"><a name="l02143"></a><span class="lineno"> 2143</span>&#160;</div><div class="line"><a name="l02144"></a><span class="lineno"> 2144</span>&#160;* `soap_end(struct soap *soap)` Clean up deserialized data (except class instances) and temporary data </div><div class="line"><a name="l02145"></a><span class="lineno"> 2145</span>&#160;</div><div class="line"><a name="l02146"></a><span class="lineno"> 2146</span>&#160;* `soap_free_temp(struct soap *soap)` Clean up temporary data only </div><div class="line"><a name="l02147"></a><span class="lineno"> 2147</span>&#160;</div><div class="line"><a name="l02148"></a><span class="lineno"> 2148</span>&#160;* `soap_destroy(struct soap *soap)` Clean up deserialized class instances (note: this function will be renamed with option `-n` </div><div class="line"><a name="l02149"></a><span class="lineno"> 2149</span>&#160;</div><div class="line"><a name="l02150"></a><span class="lineno"> 2150</span>&#160;* `soap_done(struct soap *soap)` Reset and detach context: close master/slave sockets and remove callbacks </div><div class="line"><a name="l02151"></a><span class="lineno"> 2151</span>&#160;</div><div class="line"><a name="l02152"></a><span class="lineno"> 2152</span>&#160;* `soap_free(struct soap *soap)` Detach and deallocate context (`soap_new`()) </div><div class="line"><a name="l02153"></a><span class="lineno"> 2153</span>&#160;</div><div class="line"><a name="l02154"></a><span class="lineno"> 2154</span>&#160;The *host* name in `soap_bind` may be NULL to indicate that the current host should be used.</div><div class="line"><a name="l02155"></a><span class="lineno"> 2155</span>&#160;</div><div class="line"><a name="l02156"></a><span class="lineno"> 2156</span>&#160;The `soap.accept_timeout` context attribute of the gSOAP runtime context specifies the timeout value for a non-blocking</div><div class="line"><a name="l02157"></a><span class="lineno"> 2157</span>&#160;`soap_accept(&amp;soap)` call. See Section \ref timeout  for more details on timeout management.</div><div class="line"><a name="l02158"></a><span class="lineno"> 2158</span>&#160;</div><div class="line"><a name="l02159"></a><span class="lineno"> 2159</span>&#160;See Section \ref memory  for more details on memory management.</div><div class="line"><a name="l02160"></a><span class="lineno"> 2160</span>&#160;</div><div class="line"><a name="l02161"></a><span class="lineno"> 2161</span>&#160;A client application connects to this stand-alone service with the endpoint</div><div class="line"><a name="l02162"></a><span class="lineno"> 2162</span>&#160;`machine.genivia.com:18083`.</div><div class="line"><a name="l02163"></a><span class="lineno"> 2163</span>&#160;A client may use the `http://` prefix. When absent, no HTTP header is sent</div><div class="line"><a name="l02164"></a><span class="lineno"> 2164</span>&#160;and no HTTP-based information will be communicated to the service.</div><div class="line"><a name="l02165"></a><span class="lineno"> 2165</span>&#160;</div><div class="line"><a name="l02166"></a><span class="lineno"> 2166</span>&#160;### How to Create a Multi-Threaded Stand-Alone Service        {#mt}</div><div class="line"><a name="l02167"></a><span class="lineno"> 2167</span>&#160;</div><div class="line"><a name="l02168"></a><span class="lineno"> 2168</span>&#160;Stand-alone multi-threading a Web Service is essential when the response times for handling requests by the service are (potentially) long or when keep-alive is enabled, see Section \ref keepalive .</div><div class="line"><a name="l02169"></a><span class="lineno"> 2169</span>&#160;In case of long response times, the latencies introduced by the unrelated</div><div class="line"><a name="l02170"></a><span class="lineno"> 2170</span>&#160;requests may become prohibitive for a successful deployment of a stand-alone</div><div class="line"><a name="l02171"></a><span class="lineno"> 2171</span>&#160;service. When HTTP keep-alive is enabled, a client may not close the socket on</div><div class="line"><a name="l02172"></a><span class="lineno"> 2172</span>&#160;time, thereby preventing other clients from connecting.</div><div class="line"><a name="l02173"></a><span class="lineno"> 2173</span>&#160;</div><div class="line"><a name="l02174"></a><span class="lineno"> 2174</span>&#160;However, the preferred mechanism to deploy a service is through an Apache</div><div class="line"><a name="l02175"></a><span class="lineno"> 2175</span>&#160;module or IIS module. These servers and modules are designed for server load</div><div class="line"><a name="l02176"></a><span class="lineno"> 2176</span>&#160;balancing and access control.</div><div class="line"><a name="l02177"></a><span class="lineno"> 2177</span>&#160;</div><div class="line"><a name="l02178"></a><span class="lineno"> 2178</span>&#160;The following example illustrates the use of threads to improve the quality of service by handling new requests in separate threads:</div><div class="line"><a name="l02179"></a><span class="lineno"> 2179</span>&#160;</div><div class="line"><a name="l02180"></a><span class="lineno"> 2180</span>&#160;```cpp</div><div class="line"><a name="l02181"></a><span class="lineno"> 2181</span>&#160;#include &quot;soapH.h&quot; </div><div class="line"><a name="l02182"></a><span class="lineno"> 2182</span>&#160;#include &lt;pthread.h&gt; </div><div class="line"><a name="l02183"></a><span class="lineno"> 2183</span>&#160;#define BACKLOG (100)   // Max. request backlog </div><div class="line"><a name="l02184"></a><span class="lineno"> 2184</span>&#160;int main(int argc, char **argv) </div><div class="line"><a name="l02185"></a><span class="lineno"> 2185</span>&#160;{ </div><div class="line"><a name="l02186"></a><span class="lineno"> 2186</span>&#160;   struct soap soap; </div><div class="line"><a name="l02187"></a><span class="lineno"> 2187</span>&#160;   soap_init(&amp;soap); </div><div class="line"><a name="l02188"></a><span class="lineno"> 2188</span>&#160;   if (argc &lt; 2) // no args: assume this is a CGI application </div><div class="line"><a name="l02189"></a><span class="lineno"> 2189</span>&#160;   { </div><div class="line"><a name="l02190"></a><span class="lineno"> 2190</span>&#160;     soap_serve(&amp;soap); // serve request, one thread, CGI style </div><div class="line"><a name="l02191"></a><span class="lineno"> 2191</span>&#160;     soap_destroy(&amp;soap); // dealloc C++ data </div><div class="line"><a name="l02192"></a><span class="lineno"> 2192</span>&#160;     soap_end(&amp;soap); // dealloc data and clean up </div><div class="line"><a name="l02193"></a><span class="lineno"> 2193</span>&#160;   } </div><div class="line"><a name="l02194"></a><span class="lineno"> 2194</span>&#160;   else </div><div class="line"><a name="l02195"></a><span class="lineno"> 2195</span>&#160;   { </div><div class="line"><a name="l02196"></a><span class="lineno"> 2196</span>&#160;     soap.send_timeout = 10; // 10 seconds max socket delay </div><div class="line"><a name="l02197"></a><span class="lineno"> 2197</span>&#160;     soap.recv_timeout = 10; // 10 seconds max socket delay </div><div class="line"><a name="l02198"></a><span class="lineno"> 2198</span>&#160;     soap.accept_timeout = 3600; // server stops after 1 hour of inactivity </div><div class="line"><a name="l02199"></a><span class="lineno"> 2199</span>&#160;     soap.max_keep_alive = 100; // max keep-alive sequence </div><div class="line"><a name="l02200"></a><span class="lineno"> 2200</span>&#160;     void *process_request(void*); </div><div class="line"><a name="l02201"></a><span class="lineno"> 2201</span>&#160;     struct soap *tsoap; </div><div class="line"><a name="l02202"></a><span class="lineno"> 2202</span>&#160;     pthread_t tid; </div><div class="line"><a name="l02203"></a><span class="lineno"> 2203</span>&#160;     int port = atoi(argv[1]); // first command-line arg is port </div><div class="line"><a name="l02204"></a><span class="lineno"> 2204</span>&#160;     SOAP_SOCKET m, s; </div><div class="line"><a name="l02205"></a><span class="lineno"> 2205</span>&#160;     m = soap_bind(&amp;soap, NULL, port, BACKLOG); </div><div class="line"><a name="l02206"></a><span class="lineno"> 2206</span>&#160;     if (!soap_valid_socket(m)) </div><div class="line"><a name="l02207"></a><span class="lineno"> 2207</span>&#160;       exit(1); </div><div class="line"><a name="l02208"></a><span class="lineno"> 2208</span>&#160;     fprintf(stderr, &quot;Socket connection successful %d\n&quot;, m); </div><div class="line"><a name="l02209"></a><span class="lineno"> 2209</span>&#160;     for (;;) </div><div class="line"><a name="l02210"></a><span class="lineno"> 2210</span>&#160;     { </div><div class="line"><a name="l02211"></a><span class="lineno"> 2211</span>&#160;       s = soap_accept(&amp;soap); </div><div class="line"><a name="l02212"></a><span class="lineno"> 2212</span>&#160;       if (!soap_valid_socket(s)) </div><div class="line"><a name="l02213"></a><span class="lineno"> 2213</span>&#160;       { </div><div class="line"><a name="l02214"></a><span class="lineno"> 2214</span>&#160;         if (soap.errnum) </div><div class="line"><a name="l02215"></a><span class="lineno"> 2215</span>&#160;         { </div><div class="line"><a name="l02216"></a><span class="lineno"> 2216</span>&#160;           soap_print_fault(&amp;soap, stderr); </div><div class="line"><a name="l02217"></a><span class="lineno"> 2217</span>&#160;           exit(1); </div><div class="line"><a name="l02218"></a><span class="lineno"> 2218</span>&#160;         } </div><div class="line"><a name="l02219"></a><span class="lineno"> 2219</span>&#160;         fprintf(stderr, &quot;server timed out\n&quot;); </div><div class="line"><a name="l02220"></a><span class="lineno"> 2220</span>&#160;         break; </div><div class="line"><a name="l02221"></a><span class="lineno"> 2221</span>&#160;       } </div><div class="line"><a name="l02222"></a><span class="lineno"> 2222</span>&#160;       fprintf(stderr, &quot;Thread %d accepts socket %d connection from IP %d.%d.%d.%d\n&quot;, i, s, (soap.ip&gt;&gt;24)&amp;0xFF,</div><div class="line"><a name="l02223"></a><span class="lineno"> 2223</span>&#160;(soap.ip&gt;&gt;16)&amp;0xFF, (soap.ip&gt;&gt;8)&amp;0xFF, soap.ip&amp;0xFF); </div><div class="line"><a name="l02224"></a><span class="lineno"> 2224</span>&#160;       tsoap = soap_copy(&amp;soap); // make a safe copy </div><div class="line"><a name="l02225"></a><span class="lineno"> 2225</span>&#160;       if (!tsoap) </div><div class="line"><a name="l02226"></a><span class="lineno"> 2226</span>&#160;         break; </div><div class="line"><a name="l02227"></a><span class="lineno"> 2227</span>&#160;       pthread_create(&amp;tid, NULL, (void*(*)(void*))process_request, (void*)tsoap); </div><div class="line"><a name="l02228"></a><span class="lineno"> 2228</span>&#160;     } </div><div class="line"><a name="l02229"></a><span class="lineno"> 2229</span>&#160;   } </div><div class="line"><a name="l02230"></a><span class="lineno"> 2230</span>&#160;   soap_done(&amp;soap); // detach soap struct </div><div class="line"><a name="l02231"></a><span class="lineno"> 2231</span>&#160;   return 0; </div><div class="line"><a name="l02232"></a><span class="lineno"> 2232</span>&#160;} </div><div class="line"><a name="l02233"></a><span class="lineno"> 2233</span>&#160;void *process_request(void *soap) </div><div class="line"><a name="l02234"></a><span class="lineno"> 2234</span>&#160;{ </div><div class="line"><a name="l02235"></a><span class="lineno"> 2235</span>&#160;   pthread_detach(pthread_self()); </div><div class="line"><a name="l02236"></a><span class="lineno"> 2236</span>&#160;   soap_serve((struct soap*)soap); </div><div class="line"><a name="l02237"></a><span class="lineno"> 2237</span>&#160;   soap_destroy((struct soap*)soap); // dealloc C++ data </div><div class="line"><a name="l02238"></a><span class="lineno"> 2238</span>&#160;   soap_end((struct soap*)soap); // dealloc data and clean up </div><div class="line"><a name="l02239"></a><span class="lineno"> 2239</span>&#160;   soap_done((struct soap*)soap); // detach soap struct </div><div class="line"><a name="l02240"></a><span class="lineno"> 2240</span>&#160;   free(soap); </div><div class="line"><a name="l02241"></a><span class="lineno"> 2241</span>&#160;   return NULL; </div><div class="line"><a name="l02242"></a><span class="lineno"> 2242</span>&#160;}</div><div class="line"><a name="l02243"></a><span class="lineno"> 2243</span>&#160;```</div><div class="line"><a name="l02244"></a><span class="lineno"> 2244</span>&#160;</div><div class="line"><a name="l02245"></a><span class="lineno"> 2245</span>&#160;Note: the code does not wait for threads to join the main thread upon program termination.</div><div class="line"><a name="l02246"></a><span class="lineno"> 2246</span>&#160;</div><div class="line"><a name="l02247"></a><span class="lineno"> 2247</span>&#160;The `soap_serve` dispatcher handles one request or multiple requests when</div><div class="line"><a name="l02248"></a><span class="lineno"> 2248</span>&#160;HTTP keep-alive is set with `SOAP_IO_KEEPALIVE`. The</div><div class="line"><a name="l02249"></a><span class="lineno"> 2249</span>&#160;`soap.max_keep_alive` value can be set to the maximum keep-alive calls</div><div class="line"><a name="l02250"></a><span class="lineno"> 2250</span>&#160;allowed, which is important to avoid a client from holding a thread</div><div class="line"><a name="l02251"></a><span class="lineno"> 2251</span>&#160;indefinitely. The send and receive timeouts are set to avoid (intentionally)</div><div class="line"><a name="l02252"></a><span class="lineno"> 2252</span>&#160;slow clients from holding a socket connection too long. The accept timeout is used</div><div class="line"><a name="l02253"></a><span class="lineno"> 2253</span>&#160;to let the server terminate automatically after a period of inactivity.</div><div class="line"><a name="l02254"></a><span class="lineno"> 2254</span>&#160;</div><div class="line"><a name="l02255"></a><span class="lineno"> 2255</span>&#160;The following example uses a pool of servers to limit the machine&#39;s resource utilization:</div><div class="line"><a name="l02256"></a><span class="lineno"> 2256</span>&#160;</div><div class="line"><a name="l02257"></a><span class="lineno"> 2257</span>&#160;```cpp</div><div class="line"><a name="l02258"></a><span class="lineno"> 2258</span>&#160;#include &quot;soapH.h&quot; </div><div class="line"><a name="l02259"></a><span class="lineno"> 2259</span>&#160;#include &lt;pthread.h&gt; </div><div class="line"><a name="l02260"></a><span class="lineno"> 2260</span>&#160;#define BACKLOG (100)   // Max. request backlog </div><div class="line"><a name="l02261"></a><span class="lineno"> 2261</span>&#160;#define MAX_THR (10)    // Max. threads to serve requests </div><div class="line"><a name="l02262"></a><span class="lineno"> 2262</span>&#160;int main(int argc, char **argv) </div><div class="line"><a name="l02263"></a><span class="lineno"> 2263</span>&#160;{ </div><div class="line"><a name="l02264"></a><span class="lineno"> 2264</span>&#160;   struct soap soap; </div><div class="line"><a name="l02265"></a><span class="lineno"> 2265</span>&#160;   soap_init(&amp;soap); </div><div class="line"><a name="l02266"></a><span class="lineno"> 2266</span>&#160;   if (argc &lt; 2) // no args: assume this is a CGI application </div><div class="line"><a name="l02267"></a><span class="lineno"> 2267</span>&#160;   { </div><div class="line"><a name="l02268"></a><span class="lineno"> 2268</span>&#160;     soap_serve(&amp;soap); // serve request, one thread, CGI style </div><div class="line"><a name="l02269"></a><span class="lineno"> 2269</span>&#160;     soap_destroy(&amp;soap); // dealloc C++ data </div><div class="line"><a name="l02270"></a><span class="lineno"> 2270</span>&#160;     soap_end(&amp;soap); // dealloc data and clean up </div><div class="line"><a name="l02271"></a><span class="lineno"> 2271</span>&#160;   } </div><div class="line"><a name="l02272"></a><span class="lineno"> 2272</span>&#160;   else </div><div class="line"><a name="l02273"></a><span class="lineno"> 2273</span>&#160;   { </div><div class="line"><a name="l02274"></a><span class="lineno"> 2274</span>&#160;     struct soap *soap_thr[MAX_THR]; // each thread needs a runtime context </div><div class="line"><a name="l02275"></a><span class="lineno"> 2275</span>&#160;     pthread_t tid[MAX_THR]; </div><div class="line"><a name="l02276"></a><span class="lineno"> 2276</span>&#160;     int port = atoi(argv[1]); // first command-line arg is port </div><div class="line"><a name="l02277"></a><span class="lineno"> 2277</span>&#160;     SOAP_SOCKET m, s; </div><div class="line"><a name="l02278"></a><span class="lineno"> 2278</span>&#160;     int i; </div><div class="line"><a name="l02279"></a><span class="lineno"> 2279</span>&#160;     m = soap_bind(&amp;soap, NULL, port, BACKLOG); </div><div class="line"><a name="l02280"></a><span class="lineno"> 2280</span>&#160;     if (!soap_valid_socket(m)) </div><div class="line"><a name="l02281"></a><span class="lineno"> 2281</span>&#160;       exit(1); </div><div class="line"><a name="l02282"></a><span class="lineno"> 2282</span>&#160;     fprintf(stderr, &quot;Socket connection successful %d\n&quot;, m); </div><div class="line"><a name="l02283"></a><span class="lineno"> 2283</span>&#160;     for (i = 0; i &lt; MAX_THR; i++) </div><div class="line"><a name="l02284"></a><span class="lineno"> 2284</span>&#160;       soap_thr[i] = NULL; </div><div class="line"><a name="l02285"></a><span class="lineno"> 2285</span>&#160;     for (;;) </div><div class="line"><a name="l02286"></a><span class="lineno"> 2286</span>&#160;     { </div><div class="line"><a name="l02287"></a><span class="lineno"> 2287</span>&#160;       for (i = 0; i &lt; MAX_THR; i++) </div><div class="line"><a name="l02288"></a><span class="lineno"> 2288</span>&#160;       { </div><div class="line"><a name="l02289"></a><span class="lineno"> 2289</span>&#160;         s = soap_accept(&amp;soap); </div><div class="line"><a name="l02290"></a><span class="lineno"> 2290</span>&#160;         if (!soap_valid_socket(s)) </div><div class="line"><a name="l02291"></a><span class="lineno"> 2291</span>&#160;         { </div><div class="line"><a name="l02292"></a><span class="lineno"> 2292</span>&#160;           if (soap.errnum) </div><div class="line"><a name="l02293"></a><span class="lineno"> 2293</span>&#160;           { </div><div class="line"><a name="l02294"></a><span class="lineno"> 2294</span>&#160;             soap_print_fault(&amp;soap, stderr); </div><div class="line"><a name="l02295"></a><span class="lineno"> 2295</span>&#160;             \continue; // retry</div><div class="line"><a name="l02296"></a><span class="lineno"> 2296</span>&#160;           } </div><div class="line"><a name="l02297"></a><span class="lineno"> 2297</span>&#160;           else </div><div class="line"><a name="l02298"></a><span class="lineno"> 2298</span>&#160;           { </div><div class="line"><a name="l02299"></a><span class="lineno"> 2299</span>&#160;             fprintf(stderr, &quot;Server timed out\n&quot;); </div><div class="line"><a name="l02300"></a><span class="lineno"> 2300</span>&#160;             break; </div><div class="line"><a name="l02301"></a><span class="lineno"> 2301</span>&#160;           } </div><div class="line"><a name="l02302"></a><span class="lineno"> 2302</span>&#160;         } </div><div class="line"><a name="l02303"></a><span class="lineno"> 2303</span>&#160;         fprintf(stderr, &quot;Thread %d accepts socket %d connection from IP %d.%d.%d.%d\n&quot;, i, s, (soap.ip&gt;&gt;24)&amp;0xFF,</div><div class="line"><a name="l02304"></a><span class="lineno"> 2304</span>&#160;(soap.ip&gt;&gt;16)&amp;0xFF, (soap.ip&gt;&gt;8)&amp;0xFF, soap.ip&amp;0xFF); </div><div class="line"><a name="l02305"></a><span class="lineno"> 2305</span>&#160;         if (!soap_thr[i]) // first time around </div><div class="line"><a name="l02306"></a><span class="lineno"> 2306</span>&#160;         { </div><div class="line"><a name="l02307"></a><span class="lineno"> 2307</span>&#160;           soap_thr[i] = soap_copy(&amp;soap); </div><div class="line"><a name="l02308"></a><span class="lineno"> 2308</span>&#160;           if (!soap_thr[i]) </div><div class="line"><a name="l02309"></a><span class="lineno"> 2309</span>&#160;           exit(1); // could not allocate </div><div class="line"><a name="l02310"></a><span class="lineno"> 2310</span>&#160;         } </div><div class="line"><a name="l02311"></a><span class="lineno"> 2311</span>&#160;         else // recycle soap context </div><div class="line"><a name="l02312"></a><span class="lineno"> 2312</span>&#160;         { </div><div class="line"><a name="l02313"></a><span class="lineno"> 2313</span>&#160;           pthread_join(tid[i], NULL); </div><div class="line"><a name="l02314"></a><span class="lineno"> 2314</span>&#160;           fprintf(stderr, &quot;Thread %d completed\n&quot;, i); </div><div class="line"><a name="l02315"></a><span class="lineno"> 2315</span>&#160;           soap_destroy(soap_thr[i]); // deallocate C++ data of old thread </div><div class="line"><a name="l02316"></a><span class="lineno"> 2316</span>&#160;           soap_end(soap_thr[i]); // deallocate data of old thread </div><div class="line"><a name="l02317"></a><span class="lineno"> 2317</span>&#160;         } </div><div class="line"><a name="l02318"></a><span class="lineno"> 2318</span>&#160;         soap_thr[i]-&gt;socket = s; // new socket fd </div><div class="line"><a name="l02319"></a><span class="lineno"> 2319</span>&#160;         pthread_create(&amp;tid[i], NULL, (void*(*)(void*))soap_serve, (void*)soap_thr[i]); </div><div class="line"><a name="l02320"></a><span class="lineno"> 2320</span>&#160;       } </div><div class="line"><a name="l02321"></a><span class="lineno"> 2321</span>&#160;     } </div><div class="line"><a name="l02322"></a><span class="lineno"> 2322</span>&#160;     for (i = 0; i &lt; MAX_THR; i++) </div><div class="line"><a name="l02323"></a><span class="lineno"> 2323</span>&#160;       if (soap_thr[i]) </div><div class="line"><a name="l02324"></a><span class="lineno"> 2324</span>&#160;       { </div><div class="line"><a name="l02325"></a><span class="lineno"> 2325</span>&#160;         soap_done(soap_thr[i]); // detach context </div><div class="line"><a name="l02326"></a><span class="lineno"> 2326</span>&#160;         free(soap_thr[i]); // free up </div><div class="line"><a name="l02327"></a><span class="lineno"> 2327</span>&#160;       } </div><div class="line"><a name="l02328"></a><span class="lineno"> 2328</span>&#160;   } </div><div class="line"><a name="l02329"></a><span class="lineno"> 2329</span>&#160;   return 0; </div><div class="line"><a name="l02330"></a><span class="lineno"> 2330</span>&#160;}</div><div class="line"><a name="l02331"></a><span class="lineno"> 2331</span>&#160;```</div><div class="line"><a name="l02332"></a><span class="lineno"> 2332</span>&#160;</div><div class="line"><a name="l02333"></a><span class="lineno"> 2333</span>&#160;The following functions can be used to setup a gSOAP runtime context (`struct soap`):</div><div class="line"><a name="l02334"></a><span class="lineno"> 2334</span>&#160;</div><div class="line"><a name="l02335"></a><span class="lineno"> 2335</span>&#160;* `soap_init(struct soap *soap)` Initializes a runtime context (required only once) </div><div class="line"><a name="l02336"></a><span class="lineno"> 2336</span>&#160;</div><div class="line"><a name="l02337"></a><span class="lineno"> 2337</span>&#160;* `struct soap *soap_new()` Allocates, initializes, and returns a pointer to a runtime context </div><div class="line"><a name="l02338"></a><span class="lineno"> 2338</span>&#160;</div><div class="line"><a name="l02339"></a><span class="lineno"> 2339</span>&#160;* `struct soap *soap_copy(struct soap *soap)` Allocates a new runtime context and copies a context (deep copy, i.e. the new context does not share any data with the other context) </div><div class="line"><a name="l02340"></a><span class="lineno"> 2340</span>&#160;</div><div class="line"><a name="l02341"></a><span class="lineno"> 2341</span>&#160;the argument context such that the new context does not share data with the argument context </div><div class="line"><a name="l02342"></a><span class="lineno"> 2342</span>&#160;* `soap_done(struct soap *soap)` Reset, close communications, and remove callbacks </div><div class="line"><a name="l02343"></a><span class="lineno"> 2343</span>&#160;</div><div class="line"><a name="l02344"></a><span class="lineno"> 2344</span>&#160;A new context is initiated for each thread to guarantee exclusive access</div><div class="line"><a name="l02345"></a><span class="lineno"> 2345</span>&#160;to runtime contexts.</div><div class="line"><a name="l02346"></a><span class="lineno"> 2346</span>&#160;</div><div class="line"><a name="l02347"></a><span class="lineno"> 2347</span>&#160;For clean termination of the server, the master socket can be closed and callbacks removed with `soap_done(struct soap *soap)`.</div><div class="line"><a name="l02348"></a><span class="lineno"> 2348</span>&#160;</div><div class="line"><a name="l02349"></a><span class="lineno"> 2349</span>&#160;The advantage of the code shown above is that the machine cannot be overloaded with requests, since the number of active services is limited. However, threads are still started and terminated. This overhead can be eliminated using a queue of requests (open sockets) as is shown in the code below.</div><div class="line"><a name="l02350"></a><span class="lineno"> 2350</span>&#160;</div><div class="line"><a name="l02351"></a><span class="lineno"> 2351</span>&#160;```cpp</div><div class="line"><a name="l02352"></a><span class="lineno"> 2352</span>&#160;#include &quot;soapH.h&quot; </div><div class="line"><a name="l02353"></a><span class="lineno"> 2353</span>&#160;#include &lt;pthread.h&gt; </div><div class="line"><a name="l02354"></a><span class="lineno"> 2354</span>&#160;#define BACKLOG (100)   // Max. request backlog </div><div class="line"><a name="l02355"></a><span class="lineno"> 2355</span>&#160;#define MAX_THR (10) // Size of thread pool </div><div class="line"><a name="l02356"></a><span class="lineno"> 2356</span>&#160;#define MAX_QUEUE (1000) // Max. size of request queue </div><div class="line"><a name="l02357"></a><span class="lineno"> 2357</span>&#160;SOAP_SOCKET queue[MAX_QUEUE]; // The global request queue of sockets </div><div class="line"><a name="l02358"></a><span class="lineno"> 2358</span>&#160;int head = 0, tail = 0; // Queue head and tail </div><div class="line"><a name="l02359"></a><span class="lineno"> 2359</span>&#160;void *process_queue(void*); </div><div class="line"><a name="l02360"></a><span class="lineno"> 2360</span>&#160;int enqueue(SOAP_SOCKET); </div><div class="line"><a name="l02361"></a><span class="lineno"> 2361</span>&#160;SOAP_SOCKET dequeue(); </div><div class="line"><a name="l02362"></a><span class="lineno"> 2362</span>&#160;pthread_mutex_t queue_cs; </div><div class="line"><a name="l02363"></a><span class="lineno"> 2363</span>&#160;pthread_cond_t queue_cv; </div><div class="line"><a name="l02364"></a><span class="lineno"> 2364</span>&#160;int main(int argc, char **argv) </div><div class="line"><a name="l02365"></a><span class="lineno"> 2365</span>&#160;{ </div><div class="line"><a name="l02366"></a><span class="lineno"> 2366</span>&#160;   struct soap soap; </div><div class="line"><a name="l02367"></a><span class="lineno"> 2367</span>&#160;   soap_init(&amp;soap); </div><div class="line"><a name="l02368"></a><span class="lineno"> 2368</span>&#160;   if (argc &lt; 2) // no args: assume this is a CGI application </div><div class="line"><a name="l02369"></a><span class="lineno"> 2369</span>&#160;   { </div><div class="line"><a name="l02370"></a><span class="lineno"> 2370</span>&#160;     soap_serve(&amp;soap); // serve request, one thread, CGI style </div><div class="line"><a name="l02371"></a><span class="lineno"> 2371</span>&#160;     soap_destroy(&amp;soap); // dealloc C++ data </div><div class="line"><a name="l02372"></a><span class="lineno"> 2372</span>&#160;     soap_end(&amp;soap); // dealloc data and clean up </div><div class="line"><a name="l02373"></a><span class="lineno"> 2373</span>&#160;   } </div><div class="line"><a name="l02374"></a><span class="lineno"> 2374</span>&#160;   else </div><div class="line"><a name="l02375"></a><span class="lineno"> 2375</span>&#160;   { </div><div class="line"><a name="l02376"></a><span class="lineno"> 2376</span>&#160;     struct soap *soap_thr[MAX_THR]; // each thread needs a runtime context </div><div class="line"><a name="l02377"></a><span class="lineno"> 2377</span>&#160;     pthread_t tid[MAX_THR]; </div><div class="line"><a name="l02378"></a><span class="lineno"> 2378</span>&#160;     int port = atoi(argv[1]); // first command-line arg is port </div><div class="line"><a name="l02379"></a><span class="lineno"> 2379</span>&#160;     SOAP_SOCKET m, s; </div><div class="line"><a name="l02380"></a><span class="lineno"> 2380</span>&#160;     int i; </div><div class="line"><a name="l02381"></a><span class="lineno"> 2381</span>&#160;     m = soap_bind(&amp;soap, NULL, port, BACKLOG); </div><div class="line"><a name="l02382"></a><span class="lineno"> 2382</span>&#160;     if (!soap_valid_socket(m)) </div><div class="line"><a name="l02383"></a><span class="lineno"> 2383</span>&#160;       exit(1); </div><div class="line"><a name="l02384"></a><span class="lineno"> 2384</span>&#160;     fprintf(stderr, &quot;Socket connection successful %d\n&quot;, m); </div><div class="line"><a name="l02385"></a><span class="lineno"> 2385</span>&#160;     pthread_mutex_init(&amp;queue_cs, NULL); </div><div class="line"><a name="l02386"></a><span class="lineno"> 2386</span>&#160;     pthread_cond_init(&amp;queue_cv, NULL); </div><div class="line"><a name="l02387"></a><span class="lineno"> 2387</span>&#160;     for (i = 0; i &lt; MAX_THR; i++) </div><div class="line"><a name="l02388"></a><span class="lineno"> 2388</span>&#160;     { </div><div class="line"><a name="l02389"></a><span class="lineno"> 2389</span>&#160;       soap_thr[i] = soap_copy(&amp;soap); </div><div class="line"><a name="l02390"></a><span class="lineno"> 2390</span>&#160;       fprintf(stderr, &quot;Starting thread %d\n&quot;, i); </div><div class="line"><a name="l02391"></a><span class="lineno"> 2391</span>&#160;       pthread_create(&amp;tid[i], NULL, (void*(*)(void*))process_queue, (void*)soap_thr[i]); </div><div class="line"><a name="l02392"></a><span class="lineno"> 2392</span>&#160;     } </div><div class="line"><a name="l02393"></a><span class="lineno"> 2393</span>&#160;     for (;;) </div><div class="line"><a name="l02394"></a><span class="lineno"> 2394</span>&#160;     { </div><div class="line"><a name="l02395"></a><span class="lineno"> 2395</span>&#160;       s = soap_accept(&amp;soap); </div><div class="line"><a name="l02396"></a><span class="lineno"> 2396</span>&#160;       if (!soap_valid_socket(s)) </div><div class="line"><a name="l02397"></a><span class="lineno"> 2397</span>&#160;       { </div><div class="line"><a name="l02398"></a><span class="lineno"> 2398</span>&#160;         if (soap.errnum) </div><div class="line"><a name="l02399"></a><span class="lineno"> 2399</span>&#160;         { </div><div class="line"><a name="l02400"></a><span class="lineno"> 2400</span>&#160;           soap_print_fault(&amp;soap, stderr); </div><div class="line"><a name="l02401"></a><span class="lineno"> 2401</span>&#160;           \continue; // retry </div><div class="line"><a name="l02402"></a><span class="lineno"> 2402</span>&#160;         } </div><div class="line"><a name="l02403"></a><span class="lineno"> 2403</span>&#160;         else </div><div class="line"><a name="l02404"></a><span class="lineno"> 2404</span>&#160;         { </div><div class="line"><a name="l02405"></a><span class="lineno"> 2405</span>&#160;           fprintf(stderr, &quot;Server timed out\n&quot;); </div><div class="line"><a name="l02406"></a><span class="lineno"> 2406</span>&#160;           break; </div><div class="line"><a name="l02407"></a><span class="lineno"> 2407</span>&#160;         } </div><div class="line"><a name="l02408"></a><span class="lineno"> 2408</span>&#160;       } </div><div class="line"><a name="l02409"></a><span class="lineno"> 2409</span>&#160;       fprintf(stderr, &quot;Thread %d accepts socket %d connection from IP %d.%d.%d.%d\n&quot;, i, s, (soap.ip&gt;&gt;24)&amp;0xFF, (soap.ip&gt;&gt;16)&amp;0xFF, (soap.ip&gt;&gt;8)&amp;0xFF, soap.ip&amp;0xFF); </div><div class="line"><a name="l02410"></a><span class="lineno"> 2410</span>&#160;       while (enqueue(s) == SOAP_EOM) </div><div class="line"><a name="l02411"></a><span class="lineno"> 2411</span>&#160;         sleep(1); </div><div class="line"><a name="l02412"></a><span class="lineno"> 2412</span>&#160;     } </div><div class="line"><a name="l02413"></a><span class="lineno"> 2413</span>&#160;     for (i = 0; i &lt; MAX_THR; i++) </div><div class="line"><a name="l02414"></a><span class="lineno"> 2414</span>&#160;     { </div><div class="line"><a name="l02415"></a><span class="lineno"> 2415</span>&#160;       while (enqueue(SOAP_INVALID_SOCKET) == SOAP_EOM) </div><div class="line"><a name="l02416"></a><span class="lineno"> 2416</span>&#160;         sleep(1); </div><div class="line"><a name="l02417"></a><span class="lineno"> 2417</span>&#160;     } </div><div class="line"><a name="l02418"></a><span class="lineno"> 2418</span>&#160;     for (i = 0; i &lt; MAX_THR; i++) </div><div class="line"><a name="l02419"></a><span class="lineno"> 2419</span>&#160;     { </div><div class="line"><a name="l02420"></a><span class="lineno"> 2420</span>&#160;       fprintf(stderr, &quot;Waiting for thread %d to terminate... &quot;, i); </div><div class="line"><a name="l02421"></a><span class="lineno"> 2421</span>&#160;       pthread_join(tid[i], NULL); </div><div class="line"><a name="l02422"></a><span class="lineno"> 2422</span>&#160;       fprintf(stderr, &quot;terminated\n&quot;); </div><div class="line"><a name="l02423"></a><span class="lineno"> 2423</span>&#160;       soap_done(soap_thr[i]); </div><div class="line"><a name="l02424"></a><span class="lineno"> 2424</span>&#160;       free(soap_thr[i]); </div><div class="line"><a name="l02425"></a><span class="lineno"> 2425</span>&#160;     } </div><div class="line"><a name="l02426"></a><span class="lineno"> 2426</span>&#160;     pthread_mutex_destroy(&amp;queue_cs); </div><div class="line"><a name="l02427"></a><span class="lineno"> 2427</span>&#160;     pthread_cond_destroy(&amp;queue_cv); </div><div class="line"><a name="l02428"></a><span class="lineno"> 2428</span>&#160;   } </div><div class="line"><a name="l02429"></a><span class="lineno"> 2429</span>&#160;   soap_done(&amp;soap); </div><div class="line"><a name="l02430"></a><span class="lineno"> 2430</span>&#160;   return 0; </div><div class="line"><a name="l02431"></a><span class="lineno"> 2431</span>&#160;} </div><div class="line"><a name="l02432"></a><span class="lineno"> 2432</span>&#160;void *process_queue(void *soap) </div><div class="line"><a name="l02433"></a><span class="lineno"> 2433</span>&#160;{ </div><div class="line"><a name="l02434"></a><span class="lineno"> 2434</span>&#160;   struct soap *tsoap = (struct soap*)soap; </div><div class="line"><a name="l02435"></a><span class="lineno"> 2435</span>&#160;   for (;;) </div><div class="line"><a name="l02436"></a><span class="lineno"> 2436</span>&#160;   { </div><div class="line"><a name="l02437"></a><span class="lineno"> 2437</span>&#160;     tsoap-&gt;socket = dequeue(); </div><div class="line"><a name="l02438"></a><span class="lineno"> 2438</span>&#160;     if (!soap_valid_socket(tsoap-&gt;socket)) </div><div class="line"><a name="l02439"></a><span class="lineno"> 2439</span>&#160;       break; </div><div class="line"><a name="l02440"></a><span class="lineno"> 2440</span>&#160;     soap_serve(tsoap); </div><div class="line"><a name="l02441"></a><span class="lineno"> 2441</span>&#160;     soap_destroy(tsoap); </div><div class="line"><a name="l02442"></a><span class="lineno"> 2442</span>&#160;     soap_end(tsoap); </div><div class="line"><a name="l02443"></a><span class="lineno"> 2443</span>&#160;     fprintf(stderr, &quot;served\n&quot;); </div><div class="line"><a name="l02444"></a><span class="lineno"> 2444</span>&#160;   } </div><div class="line"><a name="l02445"></a><span class="lineno"> 2445</span>&#160;   return NULL; </div><div class="line"><a name="l02446"></a><span class="lineno"> 2446</span>&#160;} </div><div class="line"><a name="l02447"></a><span class="lineno"> 2447</span>&#160;int enqueue(SOAP_SOCKET sock) </div><div class="line"><a name="l02448"></a><span class="lineno"> 2448</span>&#160;{ </div><div class="line"><a name="l02449"></a><span class="lineno"> 2449</span>&#160;   int status = SOAP_OK; </div><div class="line"><a name="l02450"></a><span class="lineno"> 2450</span>&#160;   int next; </div><div class="line"><a name="l02451"></a><span class="lineno"> 2451</span>&#160;   pthread_mutex_lock(&amp;queue_cs); </div><div class="line"><a name="l02452"></a><span class="lineno"> 2452</span>&#160;   next = tail + 1; </div><div class="line"><a name="l02453"></a><span class="lineno"> 2453</span>&#160;   if (next &gt;= MAX_QUEUE) </div><div class="line"><a name="l02454"></a><span class="lineno"> 2454</span>&#160;     next = 0; </div><div class="line"><a name="l02455"></a><span class="lineno"> 2455</span>&#160;   if (next == head) </div><div class="line"><a name="l02456"></a><span class="lineno"> 2456</span>&#160;     status = SOAP_EOM; </div><div class="line"><a name="l02457"></a><span class="lineno"> 2457</span>&#160;   else </div><div class="line"><a name="l02458"></a><span class="lineno"> 2458</span>&#160;   { </div><div class="line"><a name="l02459"></a><span class="lineno"> 2459</span>&#160;     queue[tail] = sock; </div><div class="line"><a name="l02460"></a><span class="lineno"> 2460</span>&#160;     tail = next; </div><div class="line"><a name="l02461"></a><span class="lineno"> 2461</span>&#160;     pthread_cond_signal(&amp;queue_cv); </div><div class="line"><a name="l02462"></a><span class="lineno"> 2462</span>&#160;   } </div><div class="line"><a name="l02463"></a><span class="lineno"> 2463</span>&#160;   pthread_mutex_unlock(&amp;queue_cs); </div><div class="line"><a name="l02464"></a><span class="lineno"> 2464</span>&#160;   return status; </div><div class="line"><a name="l02465"></a><span class="lineno"> 2465</span>&#160;} </div><div class="line"><a name="l02466"></a><span class="lineno"> 2466</span>&#160;SOAP_SOCKET dequeue() </div><div class="line"><a name="l02467"></a><span class="lineno"> 2467</span>&#160;{ </div><div class="line"><a name="l02468"></a><span class="lineno"> 2468</span>&#160;   SOAP_SOCKET sock; </div><div class="line"><a name="l02469"></a><span class="lineno"> 2469</span>&#160;   pthread_mutex_lock(&amp;queue_cs); </div><div class="line"><a name="l02470"></a><span class="lineno"> 2470</span>&#160;   while (head == tail) </div><div class="line"><a name="l02471"></a><span class="lineno"> 2471</span>&#160;     pthread_cond_wait(&amp;queue_cv, &amp;queue_cs); </div><div class="line"><a name="l02472"></a><span class="lineno"> 2472</span>&#160;   sock = queue[head++]; </div><div class="line"><a name="l02473"></a><span class="lineno"> 2473</span>&#160;   if (head &gt;= MAX_QUEUE) </div><div class="line"><a name="l02474"></a><span class="lineno"> 2474</span>&#160;     head = 0; </div><div class="line"><a name="l02475"></a><span class="lineno"> 2475</span>&#160;   pthread_mutex_unlock(&amp;queue_cs); </div><div class="line"><a name="l02476"></a><span class="lineno"> 2476</span>&#160;   return sock; </div><div class="line"><a name="l02477"></a><span class="lineno"> 2477</span>&#160;}</div><div class="line"><a name="l02478"></a><span class="lineno"> 2478</span>&#160;```</div><div class="line"><a name="l02479"></a><span class="lineno"> 2479</span>&#160;</div><div class="line"><a name="l02480"></a><span class="lineno"> 2480</span>&#160;Note: the `plugin/threads.h` and `plugin/threads.c` code can be used</div><div class="line"><a name="l02481"></a><span class="lineno"> 2481</span>&#160;for a portable implementation. Instead of POSIX calls, use `MUTEX_LOCK`,</div><div class="line"><a name="l02482"></a><span class="lineno"> 2482</span>&#160;`MUTEX_UNLOCK`, and `COND_WAIT`. These are wrappers for Win API calls</div><div class="line"><a name="l02483"></a><span class="lineno"> 2483</span>&#160;or POSIX calls.</div><div class="line"><a name="l02484"></a><span class="lineno"> 2484</span>&#160;</div><div class="line"><a name="l02485"></a><span class="lineno"> 2485</span>&#160;### How to Pass Application Data to Service Methods</div><div class="line"><a name="l02486"></a><span class="lineno"> 2486</span>&#160;</div><div class="line"><a name="l02487"></a><span class="lineno"> 2487</span>&#160;The `void *soap.user` field can be used to pass application data to</div><div class="line"><a name="l02488"></a><span class="lineno"> 2488</span>&#160;service methods. This field should be set before the `soap_serve()` call.</div><div class="line"><a name="l02489"></a><span class="lineno"> 2489</span>&#160;The service method can access this field to use the application-dependent data.</div><div class="line"><a name="l02490"></a><span class="lineno"> 2490</span>&#160;The following example shows how a non-static database handle is initialized and</div><div class="line"><a name="l02491"></a><span class="lineno"> 2491</span>&#160;passed to the service methods:</div><div class="line"><a name="l02492"></a><span class="lineno"> 2492</span>&#160;</div><div class="line"><a name="l02493"></a><span class="lineno"> 2493</span>&#160;```cpp</div><div class="line"><a name="l02494"></a><span class="lineno"> 2494</span>&#160;{ ... </div><div class="line"><a name="l02495"></a><span class="lineno"> 2495</span>&#160;   struct soap soap; </div><div class="line"><a name="l02496"></a><span class="lineno"> 2496</span>&#160;   database_handle_type database_handle; </div><div class="line"><a name="l02497"></a><span class="lineno"> 2497</span>&#160;   soap_init(&amp;soap);</div><div class="line"><a name="l02498"></a><span class="lineno"> 2498</span>&#160;   soap.user = (void*)database_handle; </div><div class="line"><a name="l02499"></a><span class="lineno"> 2499</span>&#160;   ... </div><div class="line"><a name="l02500"></a><span class="lineno"> 2500</span>&#160;   soap_serve(&amp;soap); // call the service operation dispatcher to handle request </div><div class="line"><a name="l02501"></a><span class="lineno"> 2501</span>&#160;   ... </div><div class="line"><a name="l02502"></a><span class="lineno"> 2502</span>&#160;} </div><div class="line"><a name="l02503"></a><span class="lineno"> 2503</span>&#160;int ns__myMethod(struct soap *soap, ...) </div><div class="line"><a name="l02504"></a><span class="lineno"> 2504</span>&#160;{ ... </div><div class="line"><a name="l02505"></a><span class="lineno"> 2505</span>&#160;   fetch((database_handle_type*)soap-&gt;user); // get data</div><div class="line"><a name="l02506"></a><span class="lineno"> 2506</span>&#160;   ... </div><div class="line"><a name="l02507"></a><span class="lineno"> 2507</span>&#160;   return SOAP_OK; </div><div class="line"><a name="l02508"></a><span class="lineno"> 2508</span>&#160;}</div><div class="line"><a name="l02509"></a><span class="lineno"> 2509</span>&#160;```</div><div class="line"><a name="l02510"></a><span class="lineno"> 2510</span>&#160;</div><div class="line"><a name="l02511"></a><span class="lineno"> 2511</span>&#160;Another way to pass application data around in a more organized way is accomplished with plugins, see Section \ref plugins .</div><div class="line"><a name="l02512"></a><span class="lineno"> 2512</span>&#160;</div><div class="line"><a name="l02513"></a><span class="lineno"> 2513</span>&#160;### Web Service Implementation Aspects</div><div class="line"><a name="l02514"></a><span class="lineno"> 2514</span>&#160;</div><div class="line"><a name="l02515"></a><span class="lineno"> 2515</span>&#160;The same client header file specification issues apply to the specification and implementation of a SOAP Web service. Refer to</div><div class="line"><a name="l02516"></a><span class="lineno"> 2516</span>&#160;</div><div class="line"><a name="l02517"></a><span class="lineno"> 2517</span>&#160;</div><div class="line"><a name="l02518"></a><span class="lineno"> 2518</span>&#160;*  \ref namespace  for namespace considerations.</div><div class="line"><a name="l02519"></a><span class="lineno"> 2519</span>&#160;</div><div class="line"><a name="l02520"></a><span class="lineno"> 2520</span>&#160;*  \ref encoding  for an explanation on how to change the encoding of the primitive types.</div><div class="line"><a name="l02521"></a><span class="lineno"> 2521</span>&#160;</div><div class="line"><a name="l02522"></a><span class="lineno"> 2522</span>&#160;*  \ref response  for a discussion on how the response element format can be controlled.</div><div class="line"><a name="l02523"></a><span class="lineno"> 2523</span>&#160;</div><div class="line"><a name="l02524"></a><span class="lineno"> 2524</span>&#160;*  \ref multiple  for details on how to pass multiple output parameters from a service operation.</div><div class="line"><a name="l02525"></a><span class="lineno"> 2525</span>&#160;</div><div class="line"><a name="l02526"></a><span class="lineno"> 2526</span>&#160;*  \ref compound  for passing complex data types as output parameters.</div><div class="line"><a name="l02527"></a><span class="lineno"> 2527</span>&#160;</div><div class="line"><a name="l02528"></a><span class="lineno"> 2528</span>&#160;*  \ref anonymous  for anonymizing the input and output parameter names.</div><div class="line"><a name="l02529"></a><span class="lineno"> 2529</span>&#160;</div><div class="line"><a name="l02530"></a><span class="lineno"> 2530</span>&#160;</div><div class="line"><a name="l02531"></a><span class="lineno"> 2531</span>&#160;### How to Generate C++ Server Object Classes        {#object}</div><div class="line"><a name="l02532"></a><span class="lineno"> 2532</span>&#160;</div><div class="line"><a name="l02533"></a><span class="lineno"> 2533</span>&#160;Server object classes for C++ server applications are automatically generated</div><div class="line"><a name="l02534"></a><span class="lineno"> 2534</span>&#160;by the gSOAP `soapcpp2` compiler.</div><div class="line"><a name="l02535"></a><span class="lineno"> 2535</span>&#160;</div><div class="line"><a name="l02536"></a><span class="lineno"> 2536</span>&#160;There are two modes for generating classes. Use `soapcpp2` option `-i`</div><div class="line"><a name="l02537"></a><span class="lineno"> 2537</span>&#160;(or `-j`) to generate improved class definitions where the class&#39; member</div><div class="line"><a name="l02538"></a><span class="lineno"> 2538</span>&#160;functions are the service methods.</div><div class="line"><a name="l02539"></a><span class="lineno"> 2539</span>&#160;</div><div class="line"><a name="l02540"></a><span class="lineno"> 2540</span>&#160;The older examples (without the use of `soapcpp2` option `-i` and</div><div class="line"><a name="l02541"></a><span class="lineno"> 2541</span>&#160;`-j`) use a C-like approach with globally defined service methods,</div><div class="line"><a name="l02542"></a><span class="lineno"> 2542</span>&#160;which is illustated here with a calculator example:</div><div class="line"><a name="l02543"></a><span class="lineno"> 2543</span>&#160;</div><div class="line"><a name="l02544"></a><span class="lineno"> 2544</span>&#160;```cpp</div><div class="line"><a name="l02545"></a><span class="lineno"> 2545</span>&#160;// Content of file &quot;calc.h&quot;: </div><div class="line"><a name="l02546"></a><span class="lineno"> 2546</span>&#160;//gsoap ns service name: Calculator </div><div class="line"><a name="l02547"></a><span class="lineno"> 2547</span>&#160;//gsoap ns service protocol: SOAP </div><div class="line"><a name="l02548"></a><span class="lineno"> 2548</span>&#160;//gsoap ns service style: rpc </div><div class="line"><a name="l02549"></a><span class="lineno"> 2549</span>&#160;//gsoap ns service encoding: encoded </div><div class="line"><a name="l02550"></a><span class="lineno"> 2550</span>&#160;//gsoap ns service location: http://www.cs.fsu.edu/~engelen/calc.cgi </div><div class="line"><a name="l02551"></a><span class="lineno"> 2551</span>&#160;//gsoap ns schema namespace: urn:calc </div><div class="line"><a name="l02552"></a><span class="lineno"> 2552</span>&#160;//gsoap ns service method-action: add &quot;&quot; </div><div class="line"><a name="l02553"></a><span class="lineno"> 2553</span>&#160;int ns__add(double a, double b, double &amp;result); </div><div class="line"><a name="l02554"></a><span class="lineno"> 2554</span>&#160;int ns__sub(double a, double b, double &amp;result); </div><div class="line"><a name="l02555"></a><span class="lineno"> 2555</span>&#160;int ns__mul(double a, double b, double &amp;result); </div><div class="line"><a name="l02556"></a><span class="lineno"> 2556</span>&#160;int ns__div(double a, double b, double &amp;result);</div><div class="line"><a name="l02557"></a><span class="lineno"> 2557</span>&#160;```</div><div class="line"><a name="l02558"></a><span class="lineno"> 2558</span>&#160;</div><div class="line"><a name="l02559"></a><span class="lineno"> 2559</span>&#160;The first three directives provide the service name which is used to name the service class, the service location (endpoint), and</div><div class="line"><a name="l02560"></a><span class="lineno"> 2560</span>&#160;the schema. The fourth directive defines the optional SOAPAction for the method, which is a string associated with SOAP 1.1 operations.</div><div class="line"><a name="l02561"></a><span class="lineno"> 2561</span>&#160;Compilation of this header file with `soapcpp2 -i` creates a new file `soapCalculatorObject.h` with the</div><div class="line"><a name="l02562"></a><span class="lineno"> 2562</span>&#160;following contents:</div><div class="line"><a name="l02563"></a><span class="lineno"> 2563</span>&#160;</div><div class="line"><a name="l02564"></a><span class="lineno"> 2564</span>&#160;```cpp</div><div class="line"><a name="l02565"></a><span class="lineno"> 2565</span>&#160;#include &quot;soapH.h&quot; </div><div class="line"><a name="l02566"></a><span class="lineno"> 2566</span>&#160;class CalculatorObject : public soap </div><div class="line"><a name="l02567"></a><span class="lineno"> 2567</span>&#160;{ public: </div><div class="line"><a name="l02568"></a><span class="lineno"> 2568</span>&#160;   Calculator() { ... }; </div><div class="line"><a name="l02569"></a><span class="lineno"> 2569</span>&#160;   ~Calculator() { ... }; </div><div class="line"><a name="l02570"></a><span class="lineno"> 2570</span>&#160;   int serve() { return soap_serve(\this); }; </div><div class="line"><a name="l02571"></a><span class="lineno"> 2571</span>&#160;};</div><div class="line"><a name="l02572"></a><span class="lineno"> 2572</span>&#160;```</div><div class="line"><a name="l02573"></a><span class="lineno"> 2573</span>&#160;</div><div class="line"><a name="l02574"></a><span class="lineno"> 2574</span>&#160;This generated server object class can be included into a server application together with the generated namespace table as shown in this example:</div><div class="line"><a name="l02575"></a><span class="lineno"> 2575</span>&#160;</div><div class="line"><a name="l02576"></a><span class="lineno"> 2576</span>&#160;```cpp</div><div class="line"><a name="l02577"></a><span class="lineno"> 2577</span>&#160;#include &quot;soapCalculatorObject.h&quot;       // get server object </div><div class="line"><a name="l02578"></a><span class="lineno"> 2578</span>&#160;#include &quot;Calculator.nsmap&quot;             // get namespace bindings </div><div class="line"><a name="l02579"></a><span class="lineno"> 2579</span>&#160;int main() </div><div class="line"><a name="l02580"></a><span class="lineno"> 2580</span>&#160;{ </div><div class="line"><a name="l02581"></a><span class="lineno"> 2581</span>&#160;   CalculatorObject c; </div><div class="line"><a name="l02582"></a><span class="lineno"> 2582</span>&#160;   return c.serve(); // calls `soap_serve` to serve as CGI application (using stdin/out) </div><div class="line"><a name="l02583"></a><span class="lineno"> 2583</span>&#160;} </div><div class="line"><a name="l02584"></a><span class="lineno"> 2584</span>&#160;// C-style global functions implement server operations (soapcpp2 w/o option -i)</div><div class="line"><a name="l02585"></a><span class="lineno"> 2585</span>&#160;int ns__add(struct soap *soap, double a, double b, double &amp;result) </div><div class="line"><a name="l02586"></a><span class="lineno"> 2586</span>&#160;{ </div><div class="line"><a name="l02587"></a><span class="lineno"> 2587</span>&#160;   result = a + b; </div><div class="line"><a name="l02588"></a><span class="lineno"> 2588</span>&#160;   return SOAP_OK; </div><div class="line"><a name="l02589"></a><span class="lineno"> 2589</span>&#160;} </div><div class="line"><a name="l02590"></a><span class="lineno"> 2590</span>&#160;... sub(), mul(), and div() implementations ...</div><div class="line"><a name="l02591"></a><span class="lineno"> 2591</span>&#160;```</div><div class="line"><a name="l02592"></a><span class="lineno"> 2592</span>&#160;</div><div class="line"><a name="l02593"></a><span class="lineno"> 2593</span>&#160;You can use `soapcpp2` option `-n` together with `-p` to create a</div><div class="line"><a name="l02594"></a><span class="lineno"> 2594</span>&#160;local namespace table to avoid link conflict when you need to combine multiple</div><div class="line"><a name="l02595"></a><span class="lineno"> 2595</span>&#160;tables and/or multiple servers, see also Sections \ref options </div><div class="line"><a name="l02596"></a><span class="lineno"> 2596</span>&#160;and \ref dylibs , and you can use a C++ code `namespace` to create a</div><div class="line"><a name="l02597"></a><span class="lineno"> 2597</span>&#160;namespace qualified server object class, see Section \ref codenamespace .</div><div class="line"><a name="l02598"></a><span class="lineno"> 2598</span>&#160;</div><div class="line"><a name="l02599"></a><span class="lineno"> 2599</span>&#160;The example above serves requests over stdin/out. Use the bind and accept calls</div><div class="line"><a name="l02600"></a><span class="lineno"> 2600</span>&#160;to create a stand-alone server to service inbound requests over sockets, see</div><div class="line"><a name="l02601"></a><span class="lineno"> 2601</span>&#160;also \ref stand-alone .</div><div class="line"><a name="l02602"></a><span class="lineno"> 2602</span>&#160;</div><div class="line"><a name="l02603"></a><span class="lineno"> 2603</span>&#160;A better alternative is to use the `soapcpp2` option `-i`. The C++ proxy and server objects are</div><div class="line"><a name="l02604"></a><span class="lineno"> 2604</span>&#160;derived from the soap context struct, which simplifies the proxy invocation and</div><div class="line"><a name="l02605"></a><span class="lineno"> 2605</span>&#160;service operation implementations.</div><div class="line"><a name="l02606"></a><span class="lineno"> 2606</span>&#160;</div><div class="line"><a name="l02607"></a><span class="lineno"> 2607</span>&#160;Compilation of the above header file with the gSOAP compiler `soapcpp2` option `-i` creates new files `soapCalculatorService.h` and `soapCalculatorService.cpp` (rather than the C-style `soapServer.cpp`).</div><div class="line"><a name="l02608"></a><span class="lineno"> 2608</span>&#160;</div><div class="line"><a name="l02609"></a><span class="lineno"> 2609</span>&#160;This generated server object class can be included into a server application together with the generated namespace table as shown in this example:</div><div class="line"><a name="l02610"></a><span class="lineno"> 2610</span>&#160;</div><div class="line"><a name="l02611"></a><span class="lineno"> 2611</span>&#160;```cpp</div><div class="line"><a name="l02612"></a><span class="lineno"> 2612</span>&#160;#include &quot;soapCalculatorService.h&quot;      // get server object </div><div class="line"><a name="l02613"></a><span class="lineno"> 2613</span>&#160;#include &quot;Calculator.nsmap&quot;             // get namespace bindings </div><div class="line"><a name="l02614"></a><span class="lineno"> 2614</span>&#160;int main() </div><div class="line"><a name="l02615"></a><span class="lineno"> 2615</span>&#160;{ </div><div class="line"><a name="l02616"></a><span class="lineno"> 2616</span>&#160;   soapCalculatorService c; </div><div class="line"><a name="l02617"></a><span class="lineno"> 2617</span>&#160;   return c.serve(); // calls `soap_serve` to serve as CGI application (using stdin/out) </div><div class="line"><a name="l02618"></a><span class="lineno"> 2618</span>&#160;} </div><div class="line"><a name="l02619"></a><span class="lineno"> 2619</span>&#160;// The &#39;add&#39; service method (soapcpp2 w/ option -i) </div><div class="line"><a name="l02620"></a><span class="lineno"> 2620</span>&#160;int soapCalculatorService::add(double a, double b, double &amp;result) </div><div class="line"><a name="l02621"></a><span class="lineno"> 2621</span>&#160;{ </div><div class="line"><a name="l02622"></a><span class="lineno"> 2622</span>&#160;   result = a + b; </div><div class="line"><a name="l02623"></a><span class="lineno"> 2623</span>&#160;   return SOAP_OK; </div><div class="line"><a name="l02624"></a><span class="lineno"> 2624</span>&#160;} </div><div class="line"><a name="l02625"></a><span class="lineno"> 2625</span>&#160;... sub(), mul(), and div() implementations ...</div><div class="line"><a name="l02626"></a><span class="lineno"> 2626</span>&#160;```</div><div class="line"><a name="l02627"></a><span class="lineno"> 2627</span>&#160;</div><div class="line"><a name="l02628"></a><span class="lineno"> 2628</span>&#160;Note that the service operation does not need a prefix (`ns__`) and there</div><div class="line"><a name="l02629"></a><span class="lineno"> 2629</span>&#160;is no soap context struct passed to the service operation since the service</div><div class="line"><a name="l02630"></a><span class="lineno"> 2630</span>&#160;object itself is the context (it is derived from the soap struct).</div><div class="line"><a name="l02631"></a><span class="lineno"> 2631</span>&#160;</div><div class="line"><a name="l02632"></a><span class="lineno"> 2632</span>&#160;### How to Chain C++ Server Classes to Accept Messages on the Same Port        {#chaining}</div><div class="line"><a name="l02633"></a><span class="lineno"> 2633</span>&#160;</div><div class="line"><a name="l02634"></a><span class="lineno"> 2634</span>&#160;When combining multiple services into one application, you can run `wsdl2h`</div><div class="line"><a name="l02635"></a><span class="lineno"> 2635</span>&#160;on multiple WSDLs to generate the single all-inclusive service definitions</div><div class="line"><a name="l02636"></a><span class="lineno"> 2636</span>&#160;header file. This header file is then processed with `soapcpp2`, for</div><div class="line"><a name="l02637"></a><span class="lineno"> 2637</span>&#160;example to generate server class objects with option `-i` and `-q` to separate the service codes with C++ namespaces, see Section \ref codenamespace .</div><div class="line"><a name="l02638"></a><span class="lineno"> 2638</span>&#160;</div><div class="line"><a name="l02639"></a><span class="lineno"> 2639</span>&#160;This works well, but the problem is that we end up with multiple classes, each</div><div class="line"><a name="l02640"></a><span class="lineno"> 2640</span>&#160;for a collection of service operations the class is supposed to implement. But</div><div class="line"><a name="l02641"></a><span class="lineno"> 2641</span>&#160;what if we need to provide one endpoint port for all services and operations?</div><div class="line"><a name="l02642"></a><span class="lineno"> 2642</span>&#160;In this case invoking the server object&#39;s `serve` method is not sufficient, since only one</div><div class="line"><a name="l02643"></a><span class="lineno"> 2643</span>&#160;service can accept requests while we want multiple services to listen to the</div><div class="line"><a name="l02644"></a><span class="lineno"> 2644</span>&#160;same port.</div><div class="line"><a name="l02645"></a><span class="lineno"> 2645</span>&#160;</div><div class="line"><a name="l02646"></a><span class="lineno"> 2646</span>&#160;The approach is to chain the service dispatchers, as shown below:</div><div class="line"><a name="l02647"></a><span class="lineno"> 2647</span>&#160;</div><div class="line"><a name="l02648"></a><span class="lineno"> 2648</span>&#160;```cpp</div><div class="line"><a name="l02649"></a><span class="lineno"> 2649</span>&#160;#include &quot;AbcABCService.h&quot; </div><div class="line"><a name="l02650"></a><span class="lineno"> 2650</span>&#160;#include &quot;UvwUVWService.h&quot; </div><div class="line"><a name="l02651"></a><span class="lineno"> 2651</span>&#160;#include &quot;XyzXYZService.h&quot; </div><div class="line"><a name="l02652"></a><span class="lineno"> 2652</span>&#160;#include &quot;envH.h&quot; // include this file last, if this file is needed </div><div class="line"><a name="l02653"></a><span class="lineno"> 2653</span>&#160;</div><div class="line"><a name="l02654"></a><span class="lineno"> 2654</span>&#160;Abc::soapABCService abc; // generated with soapcpp2 -i -S -qAbc </div><div class="line"><a name="l02655"></a><span class="lineno"> 2655</span>&#160;Uvw::soapUVWService uvw; // generated with soapcpp2 -i -S -qUvw </div><div class="line"><a name="l02656"></a><span class="lineno"> 2656</span>&#160;Xyz::soapXYZService xyz; // generated with soapcpp2 -i -S -qXyz </div><div class="line"><a name="l02657"></a><span class="lineno"> 2657</span>&#160;... </div><div class="line"><a name="l02658"></a><span class="lineno"> 2658</span>&#160;abc.bind(NULL, 8080, 100); </div><div class="line"><a name="l02659"></a><span class="lineno"> 2659</span>&#160;... </div><div class="line"><a name="l02660"></a><span class="lineno"> 2660</span>&#160;abc.accept(); </div><div class="line"><a name="l02661"></a><span class="lineno"> 2661</span>&#160;// when using SSL: ssl_accept(&amp;abc); </div><div class="line"><a name="l02662"></a><span class="lineno"> 2662</span>&#160;... </div><div class="line"><a name="l02663"></a><span class="lineno"> 2663</span>&#160;if (soap_begin_serve(&amp;abc)) // available in 2.8.2 and later </div><div class="line"><a name="l02664"></a><span class="lineno"> 2664</span>&#160;   abc.soap_stream_fault(std::cerr); </div><div class="line"><a name="l02665"></a><span class="lineno"> 2665</span>&#160;else if (abc.dispatch() == SOAP_NO_METHOD) </div><div class="line"><a name="l02666"></a><span class="lineno"> 2666</span>&#160;{ </div><div class="line"><a name="l02667"></a><span class="lineno"> 2667</span>&#160;   soap_copy_stream(&amp;uvw, &amp;abc); </div><div class="line"><a name="l02668"></a><span class="lineno"> 2668</span>&#160;   soap_free_stream(&amp;abc); // abc no longer uses this stream </div><div class="line"><a name="l02669"></a><span class="lineno"> 2669</span>&#160;   if (uvw.dispatch() == SOAP_NO_METHOD) </div><div class="line"><a name="l02670"></a><span class="lineno"> 2670</span>&#160;   { </div><div class="line"><a name="l02671"></a><span class="lineno"> 2671</span>&#160;     soap_copy_stream(&amp;xyz, &amp;uvw); </div><div class="line"><a name="l02672"></a><span class="lineno"> 2672</span>&#160;     soap_free_stream(&amp;uvw); // uvw no longer uses this stream </div><div class="line"><a name="l02673"></a><span class="lineno"> 2673</span>&#160;     if (xyz.dispatch()) </div><div class="line"><a name="l02674"></a><span class="lineno"> 2674</span>&#160;     { </div><div class="line"><a name="l02675"></a><span class="lineno"> 2675</span>&#160;       soap_send_fault(&amp;xyz); // send fault to client </div><div class="line"><a name="l02676"></a><span class="lineno"> 2676</span>&#160;       xyz.soap_stream_fault(std::cerr); </div><div class="line"><a name="l02677"></a><span class="lineno"> 2677</span>&#160;     } </div><div class="line"><a name="l02678"></a><span class="lineno"> 2678</span>&#160;     xyz.destroy(); </div><div class="line"><a name="l02679"></a><span class="lineno"> 2679</span>&#160;   } </div><div class="line"><a name="l02680"></a><span class="lineno"> 2680</span>&#160;   else </div><div class="line"><a name="l02681"></a><span class="lineno"> 2681</span>&#160;   { </div><div class="line"><a name="l02682"></a><span class="lineno"> 2682</span>&#160;     soap_send_fault(&amp;uvw); // send fault to client </div><div class="line"><a name="l02683"></a><span class="lineno"> 2683</span>&#160;     uvw.soap_stream_fault(std::cerr); </div><div class="line"><a name="l02684"></a><span class="lineno"> 2684</span>&#160;   } </div><div class="line"><a name="l02685"></a><span class="lineno"> 2685</span>&#160;   uvw.destroy(); </div><div class="line"><a name="l02686"></a><span class="lineno"> 2686</span>&#160;} </div><div class="line"><a name="l02687"></a><span class="lineno"> 2687</span>&#160;else </div><div class="line"><a name="l02688"></a><span class="lineno"> 2688</span>&#160;   abc.soap_stream_fault(std::cerr); </div><div class="line"><a name="l02689"></a><span class="lineno"> 2689</span>&#160;abc.destroy(); </div><div class="line"><a name="l02690"></a><span class="lineno"> 2690</span>&#160;...</div><div class="line"><a name="l02691"></a><span class="lineno"> 2691</span>&#160;```</div><div class="line"><a name="l02692"></a><span class="lineno"> 2692</span>&#160;</div><div class="line"><a name="l02693"></a><span class="lineno"> 2693</span>&#160;The `dispatch` method parses the SOAP/XML request and invokes the service</div><div class="line"><a name="l02694"></a><span class="lineno"> 2694</span>&#160;operations, unless there is no matching operation and `SOAP_NO_METHOD` is</div><div class="line"><a name="l02695"></a><span class="lineno"> 2695</span>&#160;returned. The `soap_copy_stream` ensures that the service object uses the</div><div class="line"><a name="l02696"></a><span class="lineno"> 2696</span>&#160;currently open socket. The copied streams are freed with</div><div class="line"><a name="l02697"></a><span class="lineno"> 2697</span>&#160;`soap_free_stream`. Do not enable keep-alive support, as the socket may</div><div class="line"><a name="l02698"></a><span class="lineno"> 2698</span>&#160;stay open indefinitely afterwards as a consequence. Also, the `dispatch`</div><div class="line"><a name="l02699"></a><span class="lineno"> 2699</span>&#160;method does not send a fault to the client, which has to be explicitly done</div><div class="line"><a name="l02700"></a><span class="lineno"> 2700</span>&#160;with the `soap_send_fault` operation when an error occurs.</div><div class="line"><a name="l02701"></a><span class="lineno"> 2701</span>&#160;</div><div class="line"><a name="l02702"></a><span class="lineno"> 2702</span>&#160;In this way, multiple services can be chained to accept messages on the same port. This approach also works with SSL for HTTPS services.</div><div class="line"><a name="l02703"></a><span class="lineno"> 2703</span>&#160;</div><div class="line"><a name="l02704"></a><span class="lineno"> 2704</span>&#160;However, this approach is not recommended for certain plugins, because plugins</div><div class="line"><a name="l02705"></a><span class="lineno"> 2705</span>&#160;must be registered with all service objects and some plugins require state</div><div class="line"><a name="l02706"></a><span class="lineno"> 2706</span>&#160;information to be used across the service objects, which will add significantly</div><div class="line"><a name="l02707"></a><span class="lineno"> 2707</span>&#160;to the complexity.</div><div class="line"><a name="l02708"></a><span class="lineno"> 2708</span>&#160;</div><div class="line"><a name="l02709"></a><span class="lineno"> 2709</span>&#160;When plugin complications arise, it is best to have all services share the same</div><div class="line"><a name="l02710"></a><span class="lineno"> 2710</span>&#160;context. This means that `soapcpp2` option `-j` should be used instead of option `-i`.</div><div class="line"><a name="l02711"></a><span class="lineno"> 2711</span>&#160;Each service class has a pointer member to a soap struct</div><div class="line"><a name="l02712"></a><span class="lineno"> 2712</span>&#160;context. This member pointer should point to the same soap context.</div><div class="line"><a name="l02713"></a><span class="lineno"> 2713</span>&#160;</div><div class="line"><a name="l02714"></a><span class="lineno"> 2714</span>&#160;With option `-j` and `-q` the code to chain the services is as follows, based on a single `struct soap` engine context:</div><div class="line"><a name="l02715"></a><span class="lineno"> 2715</span>&#160;</div><div class="line"><a name="l02716"></a><span class="lineno"> 2716</span>&#160;```cpp</div><div class="line"><a name="l02717"></a><span class="lineno"> 2717</span>&#160;#include &quot;AbcABCService.h&quot; </div><div class="line"><a name="l02718"></a><span class="lineno"> 2718</span>&#160;#include &quot;UvwUVWService.h&quot; </div><div class="line"><a name="l02719"></a><span class="lineno"> 2719</span>&#160;#include &quot;XyzXYZService.h&quot; </div><div class="line"><a name="l02720"></a><span class="lineno"> 2720</span>&#160;#include &quot;envH.h&quot; // include this file last, if it is needed </div><div class="line"><a name="l02721"></a><span class="lineno"> 2721</span>&#160;</div><div class="line"><a name="l02722"></a><span class="lineno"> 2722</span>&#160;struct soap *soap = soap_new(); </div><div class="line"><a name="l02723"></a><span class="lineno"> 2723</span>&#160;Abc::soapABCService abc(soap); // generated with soapcpp2 -j -S -qAbc </div><div class="line"><a name="l02724"></a><span class="lineno"> 2724</span>&#160;Uvw::soapUVWService uvw(soap); // generated with soapcpp2 -j -S -qUvw </div><div class="line"><a name="l02725"></a><span class="lineno"> 2725</span>&#160;Xyz::soapXYZService xyz(soap); // generated with soapcpp2 -j -S -qXyz </div><div class="line"><a name="l02726"></a><span class="lineno"> 2726</span>&#160;</div><div class="line"><a name="l02727"></a><span class="lineno"> 2727</span>&#160;soap_bind(soap, NULL, 8080, 100); </div><div class="line"><a name="l02728"></a><span class="lineno"> 2728</span>&#160;soap_accept(soap); </div><div class="line"><a name="l02729"></a><span class="lineno"> 2729</span>&#160;if (soap_begin_serve(soap)) </div><div class="line"><a name="l02730"></a><span class="lineno"> 2730</span>&#160;   ... error </div><div class="line"><a name="l02731"></a><span class="lineno"> 2731</span>&#160;else if (abc.dispatch() == SOAP_NO_METHOD) </div><div class="line"><a name="l02732"></a><span class="lineno"> 2732</span>&#160;{ </div><div class="line"><a name="l02733"></a><span class="lineno"> 2733</span>&#160;   if (uvw.dispatch() == SOAP_NO_METHOD) </div><div class="line"><a name="l02734"></a><span class="lineno"> 2734</span>&#160;   { </div><div class="line"><a name="l02735"></a><span class="lineno"> 2735</span>&#160;      if (xyz.dispatch() == SOAP_NO_METHOD) </div><div class="line"><a name="l02736"></a><span class="lineno"> 2736</span>&#160;         ... error </div><div class="line"><a name="l02737"></a><span class="lineno"> 2737</span>&#160;   } </div><div class="line"><a name="l02738"></a><span class="lineno"> 2738</span>&#160;} </div><div class="line"><a name="l02739"></a><span class="lineno"> 2739</span>&#160;soap_destroy(soap); </div><div class="line"><a name="l02740"></a><span class="lineno"> 2740</span>&#160;soap_end(soap); </div><div class="line"><a name="l02741"></a><span class="lineno"> 2741</span>&#160;soap_free(soap); // safe to delete when abc, uvw, xyz are also deleted</div><div class="line"><a name="l02742"></a><span class="lineno"> 2742</span>&#160;```</div><div class="line"><a name="l02743"></a><span class="lineno"> 2743</span>&#160;</div><div class="line"><a name="l02744"></a><span class="lineno"> 2744</span>&#160;</div><div class="line"><a name="l02745"></a><span class="lineno"> 2745</span>&#160;### How to Generate WSDL Service Descriptions        {#wsdl}</div><div class="line"><a name="l02746"></a><span class="lineno"> 2746</span>&#160;</div><div class="line"><a name="l02747"></a><span class="lineno"> 2747</span>&#160;The gSOAP stub and skeleton compiler `soapcpp2` generates WSDL (Web Service Description Language) service descriptions and XML Schema files</div><div class="line"><a name="l02748"></a><span class="lineno"> 2748</span>&#160;when processing a header file.  The tool produces one WSDL file for a set of service operations, which must be provided.  The names of the function</div><div class="line"><a name="l02749"></a><span class="lineno"> 2749</span>&#160;prototypes of the service operations must use the same namespace prefix and the namespace prefix is used to name the WSDL file.  If</div><div class="line"><a name="l02750"></a><span class="lineno"> 2750</span>&#160;multiple namespace prefixes are used to define service operations, multiple WSDL files will be created and each file describes the set</div><div class="line"><a name="l02751"></a><span class="lineno"> 2751</span>&#160;of service operations belonging to a namespace prefix.</div><div class="line"><a name="l02752"></a><span class="lineno"> 2752</span>&#160;</div><div class="line"><a name="l02753"></a><span class="lineno"> 2753</span>&#160;In addition to the generation of the *`ns.wsdl`* file, a file with a namespace mapping table is generated by the gSOAP</div><div class="line"><a name="l02754"></a><span class="lineno"> 2754</span>&#160;compiler. An example mapping table is shown below:</div><div class="line"><a name="l02755"></a><span class="lineno"> 2755</span>&#160;</div><div class="line"><a name="l02756"></a><span class="lineno"> 2756</span>&#160;```cpp</div><div class="line"><a name="l02757"></a><span class="lineno"> 2757</span>&#160;struct Namespace namespaces[] = </div><div class="line"><a name="l02758"></a><span class="lineno"> 2758</span>&#160;{ </div><div class="line"><a name="l02759"></a><span class="lineno"> 2759</span>&#160;  {&quot;SOAP-ENV&quot;, &quot;http://schemas.xmlsoap.org/soap/envelope/&quot;}, </div><div class="line"><a name="l02760"></a><span class="lineno"> 2760</span>&#160;  {&quot;SOAP-ENC&quot;, &quot;http://schemas.xmlsoap.org/soap/encoding/&quot;}, </div><div class="line"><a name="l02761"></a><span class="lineno"> 2761</span>&#160;  {&quot;xsi&quot;, &quot;http://www.w3.org/2001/XMLSchema-instance&quot;, \&quot;http://www.w3.org/*/XMLSchema-instance&quot;}, </div><div class="line"><a name="l02762"></a><span class="lineno"> 2762</span>&#160;  {&quot;xsd&quot;, &quot;http://www.w3.org/2001/XMLSchema&quot;, \&quot;http://www.w3.org/*/XMLSchema&quot;}, </div><div class="line"><a name="l02763"></a><span class="lineno"> 2763</span>&#160;  {&quot;ns&quot;, &quot;http://tempuri.org&quot;}, </div><div class="line"><a name="l02764"></a><span class="lineno"> 2764</span>&#160;  {NULL, NULL} </div><div class="line"><a name="l02765"></a><span class="lineno"> 2765</span>&#160;};</div><div class="line"><a name="l02766"></a><span class="lineno"> 2766</span>&#160;```</div><div class="line"><a name="l02767"></a><span class="lineno"> 2767</span>&#160;</div><div class="line"><a name="l02768"></a><span class="lineno"> 2768</span>&#160;This file can be incorporated in the</div><div class="line"><a name="l02769"></a><span class="lineno"> 2769</span>&#160;client/service application, see Section \ref nstable  for details on namespace mapping tables.</div><div class="line"><a name="l02770"></a><span class="lineno"> 2770</span>&#160;</div><div class="line"><a name="l02771"></a><span class="lineno"> 2771</span>&#160;To deploy a Web service, copy the compiled CGI service application to the designated CGI directory of your Web server.</div><div class="line"><a name="l02772"></a><span class="lineno"> 2772</span>&#160;Make sure the proper file permissions are set (*`chmod 755 calc.cgi`* for Unix/Linux).</div><div class="line"><a name="l02773"></a><span class="lineno"> 2773</span>&#160;You can then publish the WSDL file on the Web by placing it in the appropriate Web server directory.</div><div class="line"><a name="l02774"></a><span class="lineno"> 2774</span>&#160;</div><div class="line"><a name="l02775"></a><span class="lineno"> 2775</span>&#160;The gSOAP `soapcpp2` compiler also generates XML Schema files for all C/C++</div><div class="line"><a name="l02776"></a><span class="lineno"> 2776</span>&#160;complex types (e.g. `struct`s and `class`es) when declared with a namespace prefix.</div><div class="line"><a name="l02777"></a><span class="lineno"> 2777</span>&#160;These files are named *`ns.xsd`*, where *`ns`* is the namespace prefix used in the declaration of the complex type.</div><div class="line"><a name="l02778"></a><span class="lineno"> 2778</span>&#160;The XML Schema files do not have to be published as the WSDL file already contains the appropriate XML Schema definitions.</div><div class="line"><a name="l02779"></a><span class="lineno"> 2779</span>&#160;</div><div class="line"><a name="l02780"></a><span class="lineno"> 2780</span>&#160;To customize the WSDL output, it is essential to use `//gsoap` directives to declare the service name, the endpoint port, and namespace:</div><div class="line"><a name="l02781"></a><span class="lineno"> 2781</span>&#160;</div><div class="line"><a name="l02782"></a><span class="lineno"> 2782</span>&#160;```cpp</div><div class="line"><a name="l02783"></a><span class="lineno"> 2783</span>&#160;//gsoap ns service name: example </div><div class="line"><a name="l02784"></a><span class="lineno"> 2784</span>&#160;//gsoap ns servire port: http://www.mydomain.com/example </div><div class="line"><a name="l02785"></a><span class="lineno"> 2785</span>&#160;//gsoap ns service namespace: urn:example</div><div class="line"><a name="l02786"></a><span class="lineno"> 2786</span>&#160;```</div><div class="line"><a name="l02787"></a><span class="lineno"> 2787</span>&#160;</div><div class="line"><a name="l02788"></a><span class="lineno"> 2788</span>&#160;These are minimal settings. More details and settings for the service operations should be declared as well. See Section \ref directives  for more details.</div><div class="line"><a name="l02789"></a><span class="lineno"> 2789</span>&#160;</div><div class="line"><a name="l02790"></a><span class="lineno"> 2790</span>&#160;### Example        {#example8}</div><div class="line"><a name="l02791"></a><span class="lineno"> 2791</span>&#160;</div><div class="line"><a name="l02792"></a><span class="lineno"> 2792</span>&#160;For example, suppose the following methods are defined in the header file:</div><div class="line"><a name="l02793"></a><span class="lineno"> 2793</span>&#160;</div><div class="line"><a name="l02794"></a><span class="lineno"> 2794</span>&#160;```cpp</div><div class="line"><a name="l02795"></a><span class="lineno"> 2795</span>&#160;typedef double xsd__double; </div><div class="line"><a name="l02796"></a><span class="lineno"> 2796</span>&#160;int ns__add(xsd__double a, xsd__double b, xsd__double &amp;result); </div><div class="line"><a name="l02797"></a><span class="lineno"> 2797</span>&#160;int ns__sub(xsd__double a, xsd__double b, xsd__double &amp;result); </div><div class="line"><a name="l02798"></a><span class="lineno"> 2798</span>&#160;int ns__sqrt(xsd__double a, xsd__double &amp;result); </div><div class="line"><a name="l02799"></a><span class="lineno"> 2799</span>&#160;```</div><div class="line"><a name="l02800"></a><span class="lineno"> 2800</span>&#160;</div><div class="line"><a name="l02801"></a><span class="lineno"> 2801</span>&#160;Then, one WSDL file will be created with the file name *`ns.wsdl`* that describes all three service operations:</div><div class="line"><a name="l02802"></a><span class="lineno"> 2802</span>&#160;</div><div class="line"><a name="l02803"></a><span class="lineno"> 2803</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l02804"></a><span class="lineno"> 2804</span>&#160;```xml</div><div class="line"><a name="l02805"></a><span class="lineno"> 2805</span>&#160;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; </div><div class="line"><a name="l02806"></a><span class="lineno"> 2806</span>&#160;&lt;definitions name=&quot;Service&quot; </div><div class="line"><a name="l02807"></a><span class="lineno"> 2807</span>&#160;   xmlns=&quot;http://schemas.xmlsoap.org/wsdl/&quot; </div><div class="line"><a name="l02808"></a><span class="lineno"> 2808</span>&#160;   targetNamespace=&quot;http://location/Service.wsdl&quot; </div><div class="line"><a name="l02809"></a><span class="lineno"> 2809</span>&#160;   xmlns:SOAP-ENV=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; </div><div class="line"><a name="l02810"></a><span class="lineno"> 2810</span>&#160;   xmlns:SOAP-ENC=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot; </div><div class="line"><a name="l02811"></a><span class="lineno"> 2811</span>&#160;   xmlns:SOAP=&quot;http://schemas.xmlsoap.org/wsdl/soap/&quot; </div><div class="line"><a name="l02812"></a><span class="lineno"> 2812</span>&#160;   xmlns:WSDL=&quot;http://schemas.xmlsoap.org/wsdl/&quot; </div><div class="line"><a name="l02813"></a><span class="lineno"> 2813</span>&#160;   xmlns:xsd=&quot;http://www.w3.org/2000/10/XMLSchema&quot; </div><div class="line"><a name="l02814"></a><span class="lineno"> 2814</span>&#160;   xmlns:tns=&quot;http://location/Service.wsdl&quot; </div><div class="line"><a name="l02815"></a><span class="lineno"> 2815</span>&#160;   xmlns:ns=&quot;http://tempuri.org&quot;&gt; </div><div class="line"><a name="l02816"></a><span class="lineno"> 2816</span>&#160;&lt;types&gt; </div><div class="line"><a name="l02817"></a><span class="lineno"> 2817</span>&#160;  &lt;schema </div><div class="line"><a name="l02818"></a><span class="lineno"> 2818</span>&#160;     xmlns=&quot;http://www.w3.org/2000/10/XMLSchema&quot; </div><div class="line"><a name="l02819"></a><span class="lineno"> 2819</span>&#160;     targetNamespace=&quot;http://tempuri.org&quot; </div><div class="line"><a name="l02820"></a><span class="lineno"> 2820</span>&#160;     xmlns:SOAP-ENV=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; </div><div class="line"><a name="l02821"></a><span class="lineno"> 2821</span>&#160;     xmlns:SOAP-ENC=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;&gt; </div><div class="line"><a name="l02822"></a><span class="lineno"> 2822</span>&#160;    &lt;complexType name=&quot;addResponse&quot;&gt; </div><div class="line"><a name="l02823"></a><span class="lineno"> 2823</span>&#160;      &lt;all&gt; </div><div class="line"><a name="l02824"></a><span class="lineno"> 2824</span>&#160;        &lt;element name=&quot;result&quot; type=&quot;double&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;1&quot;/&gt; </div><div class="line"><a name="l02825"></a><span class="lineno"> 2825</span>&#160;      &lt;/all&gt; </div><div class="line"><a name="l02826"></a><span class="lineno"> 2826</span>&#160;      &lt;anyAttribute namespace=&quot;##other&quot;/&gt; </div><div class="line"><a name="l02827"></a><span class="lineno"> 2827</span>&#160;    &lt;/complexType&gt; </div><div class="line"><a name="l02828"></a><span class="lineno"> 2828</span>&#160;    &lt;complexType name=&quot;subResponse&quot;&gt; </div><div class="line"><a name="l02829"></a><span class="lineno"> 2829</span>&#160;      &lt;all&gt; </div><div class="line"><a name="l02830"></a><span class="lineno"> 2830</span>&#160;        &lt;element name=&quot;result&quot; type=&quot;double&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;1&quot;/&gt; </div><div class="line"><a name="l02831"></a><span class="lineno"> 2831</span>&#160;      &lt;/all&gt; </div><div class="line"><a name="l02832"></a><span class="lineno"> 2832</span>&#160;      &lt;anyAttribute namespace=&quot;##other&quot;/&gt; </div><div class="line"><a name="l02833"></a><span class="lineno"> 2833</span>&#160;    &lt;/complexType&gt; </div><div class="line"><a name="l02834"></a><span class="lineno"> 2834</span>&#160;    &lt;complexType name=&quot;sqrtResponse&quot;&gt; </div><div class="line"><a name="l02835"></a><span class="lineno"> 2835</span>&#160;      &lt;all&gt; </div><div class="line"><a name="l02836"></a><span class="lineno"> 2836</span>&#160;        &lt;element name=&quot;result&quot; type=&quot;double&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;1&quot;/&gt; </div><div class="line"><a name="l02837"></a><span class="lineno"> 2837</span>&#160;      &lt;/all&gt; </div><div class="line"><a name="l02838"></a><span class="lineno"> 2838</span>&#160;      &lt;anyAttribute namespace=&quot;##other&quot;/&gt; </div><div class="line"><a name="l02839"></a><span class="lineno"> 2839</span>&#160;    &lt;/complexType&gt; </div><div class="line"><a name="l02840"></a><span class="lineno"> 2840</span>&#160;  &lt;/schema&gt; </div><div class="line"><a name="l02841"></a><span class="lineno"> 2841</span>&#160;&lt;/types&gt; </div><div class="line"><a name="l02842"></a><span class="lineno"> 2842</span>&#160;&lt;message name=&quot;addRequest&quot;&gt; </div><div class="line"><a name="l02843"></a><span class="lineno"> 2843</span>&#160;  &lt;part name=&quot;a&quot; type=&quot;xsd:double&quot;/&gt; </div><div class="line"><a name="l02844"></a><span class="lineno"> 2844</span>&#160;  &lt;part name=&quot;b&quot; type=&quot;xsd:double&quot;/&gt; </div><div class="line"><a name="l02845"></a><span class="lineno"> 2845</span>&#160;&lt;/message&gt; </div><div class="line"><a name="l02846"></a><span class="lineno"> 2846</span>&#160;&lt;message name=&quot;addResponse&quot;&gt; </div><div class="line"><a name="l02847"></a><span class="lineno"> 2847</span>&#160;  &lt;part name=&quot;result&quot; type=&quot;xsd:double&quot;/&gt; </div><div class="line"><a name="l02848"></a><span class="lineno"> 2848</span>&#160;&lt;/message&gt; </div><div class="line"><a name="l02849"></a><span class="lineno"> 2849</span>&#160;&lt;message name=&quot;subRequest&quot;&gt; </div><div class="line"><a name="l02850"></a><span class="lineno"> 2850</span>&#160;  &lt;part name=&quot;a&quot; type=&quot;xsd:double&quot;/&gt; </div><div class="line"><a name="l02851"></a><span class="lineno"> 2851</span>&#160;  &lt;part name=&quot;b&quot; type=&quot;xsd:double&quot;/&gt; </div><div class="line"><a name="l02852"></a><span class="lineno"> 2852</span>&#160;&lt;/message&gt; </div><div class="line"><a name="l02853"></a><span class="lineno"> 2853</span>&#160;&lt;message name=&quot;subResponse&quot;&gt; </div><div class="line"><a name="l02854"></a><span class="lineno"> 2854</span>&#160;  &lt;part name=&quot;result&quot; type=&quot;xsd:double&quot;/&gt; </div><div class="line"><a name="l02855"></a><span class="lineno"> 2855</span>&#160;&lt;/message&gt; </div><div class="line"><a name="l02856"></a><span class="lineno"> 2856</span>&#160;&lt;message name=&quot;sqrtRequest&quot;&gt; </div><div class="line"><a name="l02857"></a><span class="lineno"> 2857</span>&#160;  &lt;part name=&quot;a&quot; type=&quot;xsd:double&quot;/&gt; </div><div class="line"><a name="l02858"></a><span class="lineno"> 2858</span>&#160;&lt;/message&gt; </div><div class="line"><a name="l02859"></a><span class="lineno"> 2859</span>&#160;&lt;message name=&quot;sqrtResponse&quot;&gt; </div><div class="line"><a name="l02860"></a><span class="lineno"> 2860</span>&#160;  &lt;part name=&quot;result&quot; type=&quot;xsd:double&quot;/&gt; </div><div class="line"><a name="l02861"></a><span class="lineno"> 2861</span>&#160;&lt;/message&gt; </div><div class="line"><a name="l02862"></a><span class="lineno"> 2862</span>&#160;&lt;portType name=&quot;ServicePortType&quot;&gt; </div><div class="line"><a name="l02863"></a><span class="lineno"> 2863</span>&#160;  &lt;operation name=&quot;add&quot;&gt; </div><div class="line"><a name="l02864"></a><span class="lineno"> 2864</span>&#160;    &lt;input message=&quot;tns:addRequest&quot;/&gt; </div><div class="line"><a name="l02865"></a><span class="lineno"> 2865</span>&#160;    &lt;output message=&quot;tns:addResponse&quot;/&gt; </div><div class="line"><a name="l02866"></a><span class="lineno"> 2866</span>&#160;  &lt;/operation&gt; </div><div class="line"><a name="l02867"></a><span class="lineno"> 2867</span>&#160;  &lt;operation name=&quot;sub&quot;&gt; </div><div class="line"><a name="l02868"></a><span class="lineno"> 2868</span>&#160;    &lt;input message=&quot;tns:subRequest&quot;/&gt; </div><div class="line"><a name="l02869"></a><span class="lineno"> 2869</span>&#160;    &lt;output message=&quot;tns:subResponse&quot;/&gt; </div><div class="line"><a name="l02870"></a><span class="lineno"> 2870</span>&#160;  &lt;/operation&gt; </div><div class="line"><a name="l02871"></a><span class="lineno"> 2871</span>&#160;  &lt;operation name=&quot;sqrt&quot;&gt; </div><div class="line"><a name="l02872"></a><span class="lineno"> 2872</span>&#160;    &lt;input message=&quot;tns:sqrtRequest&quot;/&gt; </div><div class="line"><a name="l02873"></a><span class="lineno"> 2873</span>&#160;    &lt;output message=&quot;tns:sqrtResponse&quot;/&gt; </div><div class="line"><a name="l02874"></a><span class="lineno"> 2874</span>&#160;  &lt;/operation&gt; </div><div class="line"><a name="l02875"></a><span class="lineno"> 2875</span>&#160;&lt;/portType&gt; </div><div class="line"><a name="l02876"></a><span class="lineno"> 2876</span>&#160;&lt;binding name=&quot;ServiceBinding&quot; type=&quot;tns:ServicePortType&quot;&gt; </div><div class="line"><a name="l02877"></a><span class="lineno"> 2877</span>&#160;  &lt;SOAP:binding style=&quot;rpc&quot; transport=&quot;http://schemas.xmlsoap.org/soap/http&quot;/&gt; </div><div class="line"><a name="l02878"></a><span class="lineno"> 2878</span>&#160;  &lt;operation name=&quot;add&quot;&gt; </div><div class="line"><a name="l02879"></a><span class="lineno"> 2879</span>&#160;    &lt;SOAP:operation soapAction=&quot;http://tempuri.org#add&quot;/&gt; </div><div class="line"><a name="l02880"></a><span class="lineno"> 2880</span>&#160;    &lt;input&gt; </div><div class="line"><a name="l02881"></a><span class="lineno"> 2881</span>&#160;      &lt;SOAP:body use=&quot;encoded&quot; namespace=&quot;http://tempuri.org&quot; </div><div class="line"><a name="l02882"></a><span class="lineno"> 2882</span>&#160;         encodingStyle=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;/&gt; </div><div class="line"><a name="l02883"></a><span class="lineno"> 2883</span>&#160;    &lt;/input&gt; </div><div class="line"><a name="l02884"></a><span class="lineno"> 2884</span>&#160;    &lt;output&gt; </div><div class="line"><a name="l02885"></a><span class="lineno"> 2885</span>&#160;      &lt;SOAP:body use=&quot;encoded&quot; namespace=&quot;http://tempuri.org&quot; </div><div class="line"><a name="l02886"></a><span class="lineno"> 2886</span>&#160;         encodingStyle=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;/&gt; </div><div class="line"><a name="l02887"></a><span class="lineno"> 2887</span>&#160;    &lt;/output&gt; </div><div class="line"><a name="l02888"></a><span class="lineno"> 2888</span>&#160;  &lt;/operation&gt; </div><div class="line"><a name="l02889"></a><span class="lineno"> 2889</span>&#160;  &lt;operation name=&quot;sub&quot;&gt; </div><div class="line"><a name="l02890"></a><span class="lineno"> 2890</span>&#160;    &lt;SOAP:operation soapAction=&quot;http://tempuri.org#sub&quot;/&gt; </div><div class="line"><a name="l02891"></a><span class="lineno"> 2891</span>&#160;    &lt;input&gt; </div><div class="line"><a name="l02892"></a><span class="lineno"> 2892</span>&#160;      &lt;SOAP:body use=&quot;encoded&quot; namespace=&quot;http://tempuri.org&quot; </div><div class="line"><a name="l02893"></a><span class="lineno"> 2893</span>&#160;         encodingStyle=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;/&gt; </div><div class="line"><a name="l02894"></a><span class="lineno"> 2894</span>&#160;    &lt;/input&gt; </div><div class="line"><a name="l02895"></a><span class="lineno"> 2895</span>&#160;    &lt;output&gt; </div><div class="line"><a name="l02896"></a><span class="lineno"> 2896</span>&#160;      &lt;SOAP:body use=&quot;encoded&quot; namespace=&quot;http://tempuri.org&quot; </div><div class="line"><a name="l02897"></a><span class="lineno"> 2897</span>&#160;         encodingStyle=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;/&gt; </div><div class="line"><a name="l02898"></a><span class="lineno"> 2898</span>&#160;    &lt;/output&gt; </div><div class="line"><a name="l02899"></a><span class="lineno"> 2899</span>&#160;  &lt;/operation&gt; </div><div class="line"><a name="l02900"></a><span class="lineno"> 2900</span>&#160;  &lt;operation name=&quot;sqrt&quot;&gt; </div><div class="line"><a name="l02901"></a><span class="lineno"> 2901</span>&#160;    &lt;SOAP:operation soapAction=&quot;http://tempuri.org#sqrt&quot;/&gt; </div><div class="line"><a name="l02902"></a><span class="lineno"> 2902</span>&#160;    &lt;input&gt; </div><div class="line"><a name="l02903"></a><span class="lineno"> 2903</span>&#160;      &lt;SOAP:body use=&quot;encoded&quot; namespace=&quot;http://tempuri.org&quot; </div><div class="line"><a name="l02904"></a><span class="lineno"> 2904</span>&#160;         encodingStyle=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;/&gt; </div><div class="line"><a name="l02905"></a><span class="lineno"> 2905</span>&#160;    &lt;/input&gt; </div><div class="line"><a name="l02906"></a><span class="lineno"> 2906</span>&#160;    &lt;output&gt; </div><div class="line"><a name="l02907"></a><span class="lineno"> 2907</span>&#160;      &lt;SOAP:body use=&quot;encoded&quot; namespace=&quot;http://tempuri.org&quot; </div><div class="line"><a name="l02908"></a><span class="lineno"> 2908</span>&#160;         encodingStyle=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;/&gt; </div><div class="line"><a name="l02909"></a><span class="lineno"> 2909</span>&#160;    &lt;/output&gt; </div><div class="line"><a name="l02910"></a><span class="lineno"> 2910</span>&#160;  &lt;/operation&gt; </div><div class="line"><a name="l02911"></a><span class="lineno"> 2911</span>&#160;&lt;/binding&gt; </div><div class="line"><a name="l02912"></a><span class="lineno"> 2912</span>&#160;&lt;service name=&quot;Service&quot;&gt; </div><div class="line"><a name="l02913"></a><span class="lineno"> 2913</span>&#160;  &lt;port name=&quot;ServicePort&quot; binding=&quot;tns:ServiceBinding&quot;&gt; </div><div class="line"><a name="l02914"></a><span class="lineno"> 2914</span>&#160;    &lt;SOAP:address location=&quot;http://location/Service.cgi&quot;/&gt; </div><div class="line"><a name="l02915"></a><span class="lineno"> 2915</span>&#160;  &lt;/port&gt; </div><div class="line"><a name="l02916"></a><span class="lineno"> 2916</span>&#160;&lt;/service&gt; </div><div class="line"><a name="l02917"></a><span class="lineno"> 2917</span>&#160;&lt;/definitions&gt;</div><div class="line"><a name="l02918"></a><span class="lineno"> 2918</span>&#160;```</div><div class="line"><a name="l02919"></a><span class="lineno"> 2919</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l02920"></a><span class="lineno"> 2920</span>&#160;</div><div class="line"><a name="l02921"></a><span class="lineno"> 2921</span>&#160;The above uses all default settings for the service name, port, and namespace which should be set in the header file with `//gsoap` directives (Section \ref directives ).</div><div class="line"><a name="l02922"></a><span class="lineno"> 2922</span>&#160;</div><div class="line"><a name="l02923"></a><span class="lineno"> 2923</span>&#160;### How to Use Client Functionalities Within a Service</div><div class="line"><a name="l02924"></a><span class="lineno"> 2924</span>&#160;</div><div class="line"><a name="l02925"></a><span class="lineno"> 2925</span>&#160;A gSOAP service implemented with CGI may make direct client calls to other services from within its service operations, without setting up a new context. A stand-alone service application must setup a new soap struct context, e.g. using `soap_copy` and delete it after the call.</div><div class="line"><a name="l02926"></a><span class="lineno"> 2926</span>&#160;</div><div class="line"><a name="l02927"></a><span class="lineno"> 2927</span>&#160;The server-side client call is best illustrated with an example.  The following example is a</div><div class="line"><a name="l02928"></a><span class="lineno"> 2928</span>&#160;more sophisticated example that combines the functionality of two Web services</div><div class="line"><a name="l02929"></a><span class="lineno"> 2929</span>&#160;into one new SOAP Web service.  The service provides a currency-converted stock</div><div class="line"><a name="l02930"></a><span class="lineno"> 2930</span>&#160;quote.  To serve a request, the service in turn requests the stock quote and</div><div class="line"><a name="l02931"></a><span class="lineno"> 2931</span>&#160;the currency-exchange rate from two XMethods services (these services are no longer available by XMethods, but are used here as an example).</div><div class="line"><a name="l02932"></a><span class="lineno"> 2932</span>&#160;</div><div class="line"><a name="l02933"></a><span class="lineno"> 2933</span>&#160;In addition to being a client of two XMethods services, this service</div><div class="line"><a name="l02934"></a><span class="lineno"> 2934</span>&#160;application can also be used as a client of itself to test the implementation.</div><div class="line"><a name="l02935"></a><span class="lineno"> 2935</span>&#160;As a client invoked from the command-line, it will return a currency-converted</div><div class="line"><a name="l02936"></a><span class="lineno"> 2936</span>&#160;stock quote by connecting to a copy of itself installed as a CGI application on</div><div class="line"><a name="l02937"></a><span class="lineno"> 2937</span>&#160;the Web to retrieve the quote after which it will print the quote on the</div><div class="line"><a name="l02938"></a><span class="lineno"> 2938</span>&#160;terminal.</div><div class="line"><a name="l02939"></a><span class="lineno"> 2939</span>&#160;</div><div class="line"><a name="l02940"></a><span class="lineno"> 2940</span>&#160;The header file input to the gSOAP `soapcpp2` compiler is given below. The example is for illustrative purposes only (the XMethods services are not operational):</div><div class="line"><a name="l02941"></a><span class="lineno"> 2941</span>&#160;</div><div class="line"><a name="l02942"></a><span class="lineno"> 2942</span>&#160;```cpp</div><div class="line"><a name="l02943"></a><span class="lineno"> 2943</span>&#160;// Contents of file &quot;quotex.h&quot;: </div><div class="line"><a name="l02944"></a><span class="lineno"> 2944</span>&#160;int ns1__getQuote(char *symbol, float &amp;result); // XMethods delayed stock quote service service operation </div><div class="line"><a name="l02945"></a><span class="lineno"> 2945</span>&#160;int ns2__getRate(char *country1, char *country2, float &amp;result); // XMethods currency-exchange service service operation </div><div class="line"><a name="l02946"></a><span class="lineno"> 2946</span>&#160;int ns3__getQuote(char *symbol, char *country, float &amp;result); // the new currency-converted stock quote service </div><div class="line"><a name="l02947"></a><span class="lineno"> 2947</span>&#160;```</div><div class="line"><a name="l02948"></a><span class="lineno"> 2948</span>&#160;</div><div class="line"><a name="l02949"></a><span class="lineno"> 2949</span>&#160;The `quotex.cpp` client/service application source is:</div><div class="line"><a name="l02950"></a><span class="lineno"> 2950</span>&#160;</div><div class="line"><a name="l02951"></a><span class="lineno"> 2951</span>&#160;```cpp</div><div class="line"><a name="l02952"></a><span class="lineno"> 2952</span>&#160;// Contents of file &quot;quotex.cpp&quot;: </div><div class="line"><a name="l02953"></a><span class="lineno"> 2953</span>&#160;#include &quot;soapH.h&quot;      // include generated proxy and SOAP support </div><div class="line"><a name="l02954"></a><span class="lineno"> 2954</span>&#160;int main(int argc, char **argv) </div><div class="line"><a name="l02955"></a><span class="lineno"> 2955</span>&#160;{ </div><div class="line"><a name="l02956"></a><span class="lineno"> 2956</span>&#160;  struct soap soap; </div><div class="line"><a name="l02957"></a><span class="lineno"> 2957</span>&#160;  float q; </div><div class="line"><a name="l02958"></a><span class="lineno"> 2958</span>&#160;   soap_init(&amp;soap); </div><div class="line"><a name="l02959"></a><span class="lineno"> 2959</span>&#160;   if (argc &lt;= 2) </div><div class="line"><a name="l02960"></a><span class="lineno"> 2960</span>&#160;     soap_serve(&amp;soap); </div><div class="line"><a name="l02961"></a><span class="lineno"> 2961</span>&#160;   else if (soap_call_ns3__getQuote(&amp;soap, &quot;http://www.cs.fsu.edu/~engelen/quotex.cgi&quot;, &quot;&quot;, argv[1], argv[2], q)) </div><div class="line"><a name="l02962"></a><span class="lineno"> 2962</span>&#160;     soap_print_fault(&amp;soap, stderr); </div><div class="line"><a name="l02963"></a><span class="lineno"> 2963</span>&#160;   else </div><div class="line"><a name="l02964"></a><span class="lineno"> 2964</span>&#160;     printf(&quot;\nCompany %s: %f (%s)\n&quot;, argv[1], q, argv[2]); </div><div class="line"><a name="l02965"></a><span class="lineno"> 2965</span>&#160;   return 0; </div><div class="line"><a name="l02966"></a><span class="lineno"> 2966</span>&#160;} </div><div class="line"><a name="l02967"></a><span class="lineno"> 2967</span>&#160;int ns3__getQuote(struct soap *soap, char *symbol, char *country, float &amp;result) </div><div class="line"><a name="l02968"></a><span class="lineno"> 2968</span>&#160;{ </div><div class="line"><a name="l02969"></a><span class="lineno"> 2969</span>&#160;   float q, r; </div><div class="line"><a name="l02970"></a><span class="lineno"> 2970</span>&#160;   int socket = soap-&gt;socket; // save socket (stand-alone service only, does not support keep-alive) </div><div class="line"><a name="l02971"></a><span class="lineno"> 2971</span>&#160;   if (soap_call_ns1__getQuote(soap, &quot;http://services.xmethods.net/soap&quot;, &quot;&quot;, symbol, &amp;q) == 0 &amp;&amp; </div><div class="line"><a name="l02972"></a><span class="lineno"> 2972</span>&#160;     soap_call_ns2__getRate(soap, &quot;http://services.xmethods.net/soap&quot;, NULL, &quot;us&quot;, country, &amp;r) == 0) </div><div class="line"><a name="l02973"></a><span class="lineno"> 2973</span>&#160;  { </div><div class="line"><a name="l02974"></a><span class="lineno"> 2974</span>&#160;     result = q*r; </div><div class="line"><a name="l02975"></a><span class="lineno"> 2975</span>&#160;     soap-&gt;socket = socket; </div><div class="line"><a name="l02976"></a><span class="lineno"> 2976</span>&#160;     return SOAP_OK; </div><div class="line"><a name="l02977"></a><span class="lineno"> 2977</span>&#160;  } </div><div class="line"><a name="l02978"></a><span class="lineno"> 2978</span>&#160;   soap-&gt;socket = socket; </div><div class="line"><a name="l02979"></a><span class="lineno"> 2979</span>&#160;   return SOAP_FAULT;   // pass soap fault messages on to the client of this app </div><div class="line"><a name="l02980"></a><span class="lineno"> 2980</span>&#160;} </div><div class="line"><a name="l02981"></a><span class="lineno"> 2981</span>&#160;/* Since this app is a combined client-server, it is put together with </div><div class="line"><a name="l02982"></a><span class="lineno"> 2982</span>&#160; * one header file that describes all service operations. However, as a consequence we </div><div class="line"><a name="l02983"></a><span class="lineno"> 2983</span>&#160; * have to implement the methods that are not ours. Since these implementations are </div><div class="line"><a name="l02984"></a><span class="lineno"> 2984</span>&#160; * never called (this code is client-side), we can make them dummies as below. </div><div class="line"><a name="l02985"></a><span class="lineno"> 2985</span>&#160; */ </div><div class="line"><a name="l02986"></a><span class="lineno"> 2986</span>&#160;int ns1__getQuote(struct soap *soap, char *symbol, float &amp;result) </div><div class="line"><a name="l02987"></a><span class="lineno"> 2987</span>&#160;{ return SOAP_NO_METHOD; } // dummy: will never be called </div><div class="line"><a name="l02988"></a><span class="lineno"> 2988</span>&#160;int ns2__getRate(struct soap *soap, char *country1, char *country2, float &amp;result) </div><div class="line"><a name="l02989"></a><span class="lineno"> 2989</span>&#160;{ return SOAP_NO_METHOD; } // dummy: will never be called </div><div class="line"><a name="l02990"></a><span class="lineno"> 2990</span>&#160; </div><div class="line"><a name="l02991"></a><span class="lineno"> 2991</span>&#160;struct Namespace namespaces[] = </div><div class="line"><a name="l02992"></a><span class="lineno"> 2992</span>&#160;{ </div><div class="line"><a name="l02993"></a><span class="lineno"> 2993</span>&#160;  {&quot;SOAP-ENV&quot;, &quot;http://schemas.xmlsoap.org/soap/envelope/&quot;}, </div><div class="line"><a name="l02994"></a><span class="lineno"> 2994</span>&#160;  {&quot;SOAP-ENC&quot;, &quot;http://schemas.xmlsoap.org/soap/encoding/&quot;}, </div><div class="line"><a name="l02995"></a><span class="lineno"> 2995</span>&#160;  {&quot;xsi&quot;, &quot;http://www.w3.org/2001/XMLSchema-instance&quot;, &quot;http://www.w3.org/*/XMLSchema-instance&quot;}, </div><div class="line"><a name="l02996"></a><span class="lineno"> 2996</span>&#160;  {&quot;xsd&quot;, &quot;http://www.w3.org/2001/XMLSchema&quot;,          &quot;http://www.w3.org/*/XMLSchema&quot;}, </div><div class="line"><a name="l02997"></a><span class="lineno"> 2997</span>&#160;  {&quot;ns1&quot;, &quot;urn:xmethods-delayed-quotes&quot;}, </div><div class="line"><a name="l02998"></a><span class="lineno"> 2998</span>&#160;  {&quot;ns2&quot;, &quot;urn:xmethods-CurrencyExchange&quot;}, </div><div class="line"><a name="l02999"></a><span class="lineno"> 2999</span>&#160;  {&quot;ns3&quot;, &quot;urn:quotex&quot;}, </div><div class="line"><a name="l03000"></a><span class="lineno"> 3000</span>&#160;  {NULL, NULL} </div><div class="line"><a name="l03001"></a><span class="lineno"> 3001</span>&#160;};</div><div class="line"><a name="l03002"></a><span class="lineno"> 3002</span>&#160;```</div><div class="line"><a name="l03003"></a><span class="lineno"> 3003</span>&#160;</div><div class="line"><a name="l03004"></a><span class="lineno"> 3004</span>&#160;To compile:</div><div class="line"><a name="l03005"></a><span class="lineno"> 3005</span>&#160;</div><div class="line"><a name="l03006"></a><span class="lineno"> 3006</span>&#160;&gt; soapcpp2 quotex.h</div><div class="line"><a name="l03007"></a><span class="lineno"> 3007</span>&#160;&gt; c++ -o quotex.cgi quotex.cpp soapC.cpp soapClient.cpp soapServer.cpp stdsoap2.cpp -lsocket -lxnet -lnsl</div><div class="line"><a name="l03008"></a><span class="lineno"> 3008</span>&#160;</div><div class="line"><a name="l03009"></a><span class="lineno"> 3009</span>&#160;Note: under Linux and Mac OS X you can often omit the *`-l`* libraries.</div><div class="line"><a name="l03010"></a><span class="lineno"> 3010</span>&#160;</div><div class="line"><a name="l03011"></a><span class="lineno"> 3011</span>&#160;The `quotex.cgi` executable is installed as a CGI application on the Web by</div><div class="line"><a name="l03012"></a><span class="lineno"> 3012</span>&#160;copying it in the designated directory specific to your Web server.  After</div><div class="line"><a name="l03013"></a><span class="lineno"> 3013</span>&#160;this, the executable can also serve to test the service.  For example</div><div class="line"><a name="l03014"></a><span class="lineno"> 3014</span>&#160;</div><div class="line"><a name="l03015"></a><span class="lineno"> 3015</span>&#160;    &gt; quotex.cgi IBM uk</div><div class="line"><a name="l03016"></a><span class="lineno"> 3016</span>&#160;</div><div class="line"><a name="l03017"></a><span class="lineno"> 3017</span>&#160;returns the quote of `IBM` in `uk` pounds by communicating the request</div><div class="line"><a name="l03018"></a><span class="lineno"> 3018</span>&#160;and response quote from the CGI application.  See</div><div class="line"><a name="l03019"></a><span class="lineno"> 3019</span>&#160;&lt;http://xmethods.com/detail.html?id=5&gt; for details on the currency</div><div class="line"><a name="l03020"></a><span class="lineno"> 3020</span>&#160;abbreviations.</div><div class="line"><a name="l03021"></a><span class="lineno"> 3021</span>&#160;</div><div class="line"><a name="l03022"></a><span class="lineno"> 3022</span>&#160;When combining clients and service functionalities, it is required to use one</div><div class="line"><a name="l03023"></a><span class="lineno"> 3023</span>&#160;header file input to the compiler.  As a consequence, however, stubs and</div><div class="line"><a name="l03024"></a><span class="lineno"> 3024</span>&#160;skeletons are available for **all** service operations, while the client part</div><div class="line"><a name="l03025"></a><span class="lineno"> 3025</span>&#160;will only use the stubs and the service part will use the skeletons.  Thus,</div><div class="line"><a name="l03026"></a><span class="lineno"> 3026</span>&#160;dummy implementations of the unused service operations need to be given which are</div><div class="line"><a name="l03027"></a><span class="lineno"> 3027</span>&#160;never called.</div><div class="line"><a name="l03028"></a><span class="lineno"> 3028</span>&#160;</div><div class="line"><a name="l03029"></a><span class="lineno"> 3029</span>&#160;Three WSDL files are created by gSOAP: *`ns1.wsdl`*, *`ns2.wsdl`*, and</div><div class="line"><a name="l03030"></a><span class="lineno"> 3030</span>&#160;*`ns3.wsdl`*. Only the *`ns3.wsdl`* file is required to be published as it</div><div class="line"><a name="l03031"></a><span class="lineno"> 3031</span>&#160;contains the description of the combined service, while the others are</div><div class="line"><a name="l03032"></a><span class="lineno"> 3032</span>&#160;generated as a side-effect (and in case you want to develop these separate</div><div class="line"><a name="l03033"></a><span class="lineno"> 3033</span>&#160;services).</div><div class="line"><a name="l03034"></a><span class="lineno"> 3034</span>&#160;</div><div class="line"><a name="l03035"></a><span class="lineno"> 3035</span>&#160;## Asynchronous One-Way Message Passing        {#oneway1}</div><div class="line"><a name="l03036"></a><span class="lineno"> 3036</span>&#160;</div><div class="line"><a name="l03037"></a><span class="lineno"> 3037</span>&#160;SOAP RPC client-server interaction is synchronous: the client blocks until the server responds to the request.</div><div class="line"><a name="l03038"></a><span class="lineno"> 3038</span>&#160;gSOAP also supports asynchronous one-way message passing and the interoperable synchronous one-way message passing over HTTP. The two styles are similar, but only the latter is interoperable and is compliant to Basic Profile 1.0. The interoperable synchronous one-way message passing style over HTTP is discussed in Section \ref oneway2  below.</div><div class="line"><a name="l03039"></a><span class="lineno"> 3039</span>&#160;</div><div class="line"><a name="l03040"></a><span class="lineno"> 3040</span>&#160;SOAP messaging routines are declared as function prototypes, just like service operations for SOAP RPC.  However, the output parameter is a</div><div class="line"><a name="l03041"></a><span class="lineno"> 3041</span>&#160;`void` type to indicate the absence of a return value.</div><div class="line"><a name="l03042"></a><span class="lineno"> 3042</span>&#160;</div><div class="line"><a name="l03043"></a><span class="lineno"> 3043</span>&#160;For example, the following header file specifies an event message for SOAP messaging:</div><div class="line"><a name="l03044"></a><span class="lineno"> 3044</span>&#160;</div><div class="line"><a name="l03045"></a><span class="lineno"> 3045</span>&#160;```cpp</div><div class="line"><a name="l03046"></a><span class="lineno"> 3046</span>&#160;int ns__event(int eventNo, void);</div><div class="line"><a name="l03047"></a><span class="lineno"> 3047</span>&#160;```</div><div class="line"><a name="l03048"></a><span class="lineno"> 3048</span>&#160;</div><div class="line"><a name="l03049"></a><span class="lineno"> 3049</span>&#160;The gSOAP `soapcpp2` tool generates the following functions in `soapClient.cpp`:</div><div class="line"><a name="l03050"></a><span class="lineno"> 3050</span>&#160;</div><div class="line"><a name="l03051"></a><span class="lineno"> 3051</span>&#160;```cpp</div><div class="line"><a name="l03052"></a><span class="lineno"> 3052</span>&#160;int soap_send_ns__event(struct soap *soap, const char URL, const char action, int event); </div><div class="line"><a name="l03053"></a><span class="lineno"> 3053</span>&#160;int soap_recv_ns__event(struct soap *soap, struct ns__event *dummy); </div><div class="line"><a name="l03054"></a><span class="lineno"> 3054</span>&#160;```</div><div class="line"><a name="l03055"></a><span class="lineno"> 3055</span>&#160;</div><div class="line"><a name="l03056"></a><span class="lineno"> 3056</span>&#160;The `soap_send_ns__event` function transmits the message to the destination URL by opening a socket and sending the SOAP encoded</div><div class="line"><a name="l03057"></a><span class="lineno"> 3057</span>&#160;message. The socket will remain</div><div class="line"><a name="l03058"></a><span class="lineno"> 3058</span>&#160;open after the send and has to be closed with `soap_closesock()`.  The open socket connection can also be used to obtain a service</div><div class="line"><a name="l03059"></a><span class="lineno"> 3059</span>&#160;response, e.g. with a `soap_recv` function call.</div><div class="line"><a name="l03060"></a><span class="lineno"> 3060</span>&#160;</div><div class="line"><a name="l03061"></a><span class="lineno"> 3061</span>&#160;The `soap_recv_ns__event` function waits for a SOAP message on the currently open socket (`soap.socket`) and fills the</div><div class="line"><a name="l03062"></a><span class="lineno"> 3062</span>&#160;`struct ns__event` with the `ns__event` parameters (e.g. `int eventNo`).</div><div class="line"><a name="l03063"></a><span class="lineno"> 3063</span>&#160;The `struct ns__event` is automatically created by gSOAP and is a mirror image of the `ns__event` parameters:</div><div class="line"><a name="l03064"></a><span class="lineno"> 3064</span>&#160;</div><div class="line"><a name="l03065"></a><span class="lineno"> 3065</span>&#160;```cpp</div><div class="line"><a name="l03066"></a><span class="lineno"> 3066</span>&#160;struct ns__event </div><div class="line"><a name="l03067"></a><span class="lineno"> 3067</span>&#160;{ int eventNo; </div><div class="line"><a name="l03068"></a><span class="lineno"> 3068</span>&#160;}</div><div class="line"><a name="l03069"></a><span class="lineno"> 3069</span>&#160;```</div><div class="line"><a name="l03070"></a><span class="lineno"> 3070</span>&#160;</div><div class="line"><a name="l03071"></a><span class="lineno"> 3071</span>&#160;The gSOAP generated `soapServer.cpp` code includes a skeleton routine to accept the message.</div><div class="line"><a name="l03072"></a><span class="lineno"> 3072</span>&#160;(The skeleton routine does not respond with a SOAP response message.)</div><div class="line"><a name="l03073"></a><span class="lineno"> 3073</span>&#160;</div><div class="line"><a name="l03074"></a><span class="lineno"> 3074</span>&#160;```cpp</div><div class="line"><a name="l03075"></a><span class="lineno"> 3075</span>&#160;int soap_serve_ns__event(struct soap *soap);</div><div class="line"><a name="l03076"></a><span class="lineno"> 3076</span>&#160;```</div><div class="line"><a name="l03077"></a><span class="lineno"> 3077</span>&#160;</div><div class="line"><a name="l03078"></a><span class="lineno"> 3078</span>&#160;The skeleton routine calls the user-implemented `ns__event(struct soap *soap, int eventNo)` routine (note the absence of the void</div><div class="line"><a name="l03079"></a><span class="lineno"> 3079</span>&#160;parameter!).</div><div class="line"><a name="l03080"></a><span class="lineno"> 3080</span>&#160;</div><div class="line"><a name="l03081"></a><span class="lineno"> 3081</span>&#160;As usual, the skeleton will be automatically called by the service operation request dispatcher that handles both the service operation</div><div class="line"><a name="l03082"></a><span class="lineno"> 3082</span>&#160;requests (RPCs) and messages:</div><div class="line"><a name="l03083"></a><span class="lineno"> 3083</span>&#160;</div><div class="line"><a name="l03084"></a><span class="lineno"> 3084</span>&#160;```cpp</div><div class="line"><a name="l03085"></a><span class="lineno"> 3085</span>&#160;int main() </div><div class="line"><a name="l03086"></a><span class="lineno"> 3086</span>&#160;{ soap_serve(soap_new()); </div><div class="line"><a name="l03087"></a><span class="lineno"> 3087</span>&#160;} </div><div class="line"><a name="l03088"></a><span class="lineno"> 3088</span>&#160;int ns__event(struct soap *soap, int eventNo) </div><div class="line"><a name="l03089"></a><span class="lineno"> 3089</span>&#160;{ </div><div class="line"><a name="l03090"></a><span class="lineno"> 3090</span>&#160;   ... // handle event </div><div class="line"><a name="l03091"></a><span class="lineno"> 3091</span>&#160;   return SOAP_OK; </div><div class="line"><a name="l03092"></a><span class="lineno"> 3092</span>&#160;}</div><div class="line"><a name="l03093"></a><span class="lineno"> 3093</span>&#160;```</div><div class="line"><a name="l03094"></a><span class="lineno"> 3094</span>&#160;</div><div class="line"><a name="l03095"></a><span class="lineno"> 3095</span>&#160;## Implementing Synchronous One-Way Message Passing over HTTP        {#oneway2}</div><div class="line"><a name="l03096"></a><span class="lineno"> 3096</span>&#160;</div><div class="line"><a name="l03097"></a><span class="lineno"> 3097</span>&#160;One-way SOAP message passing over HTTP as defined by the SOAP specification and</div><div class="line"><a name="l03098"></a><span class="lineno"> 3098</span>&#160;Basic Profile 1.0 is synchrounous, meaning that the server must respond with an</div><div class="line"><a name="l03099"></a><span class="lineno"> 3099</span>&#160;HTTP OK header (or HTTP 202 Accepted) and an empty body. To implement</div><div class="line"><a name="l03100"></a><span class="lineno"> 3100</span>&#160;synchrounous one-way messaging, the same setup for asynchrounous one-way</div><div class="line"><a name="l03101"></a><span class="lineno"> 3101</span>&#160;messaing discussed in Section \ref oneway1  is used, but with one simple</div><div class="line"><a name="l03102"></a><span class="lineno"> 3102</span>&#160;addition at the client and server side for HTTP transfer.</div><div class="line"><a name="l03103"></a><span class="lineno"> 3103</span>&#160;</div><div class="line"><a name="l03104"></a><span class="lineno"> 3104</span>&#160;At the server side, we have to return an empty HTTP OK response. Normally with</div><div class="line"><a name="l03105"></a><span class="lineno"> 3105</span>&#160;one-way messaging the gSOAP engine closes the socket when the service operation</div><div class="line"><a name="l03106"></a><span class="lineno"> 3106</span>&#160;is finished, which is not desirable for synchronous one-way message exchanges</div><div class="line"><a name="l03107"></a><span class="lineno"> 3107</span>&#160;over HTTP: an HTTP response should be send. This is accomplished as follows.</div><div class="line"><a name="l03108"></a><span class="lineno"> 3108</span>&#160;For each one-way operation implemented in C/C++, we</div><div class="line"><a name="l03109"></a><span class="lineno"> 3109</span>&#160;replace the `return SOAP_OK` with:</div><div class="line"><a name="l03110"></a><span class="lineno"> 3110</span>&#160;</div><div class="line"><a name="l03111"></a><span class="lineno"> 3111</span>&#160;```cpp</div><div class="line"><a name="l03112"></a><span class="lineno"> 3112</span>&#160;int ns__event(struct soap *soap, int eventNo) </div><div class="line"><a name="l03113"></a><span class="lineno"> 3113</span>&#160;{ </div><div class="line"><a name="l03114"></a><span class="lineno"> 3114</span>&#160;   ... // handle event </div><div class="line"><a name="l03115"></a><span class="lineno"> 3115</span>&#160;   return soap_send_empty_response(soap, SOAP_OK); // SOAP_OK: return HTTP 202 ACCEPTED </div><div class="line"><a name="l03116"></a><span class="lineno"> 3116</span>&#160;}</div><div class="line"><a name="l03117"></a><span class="lineno"> 3117</span>&#160;```</div><div class="line"><a name="l03118"></a><span class="lineno"> 3118</span>&#160;</div><div class="line"><a name="l03119"></a><span class="lineno"> 3119</span>&#160;At the client side, the empty response header must be parsed as follows:</div><div class="line"><a name="l03120"></a><span class="lineno"> 3120</span>&#160;</div><div class="line"><a name="l03121"></a><span class="lineno"> 3121</span>&#160;```cpp</div><div class="line"><a name="l03122"></a><span class="lineno"> 3122</span>&#160;if (soap_send_ns__event(soap, eventNo) != SOAP_OK </div><div class="line"><a name="l03123"></a><span class="lineno"> 3123</span>&#160;   || soap_recv_empty_response(soap) != SOAP_OK) </div><div class="line"><a name="l03124"></a><span class="lineno"> 3124</span>&#160;   soap_print_fault(soap, stderr); </div><div class="line"><a name="l03125"></a><span class="lineno"> 3125</span>&#160;...</div><div class="line"><a name="l03126"></a><span class="lineno"> 3126</span>&#160;```</div><div class="line"><a name="l03127"></a><span class="lineno"> 3127</span>&#160;</div><div class="line"><a name="l03128"></a><span class="lineno"> 3128</span>&#160;The synchronous (and asynchronous) one-way messaging supports HTTP keep-alive and chunking.</div><div class="line"><a name="l03129"></a><span class="lineno"> 3129</span>&#160;</div><div class="line"><a name="l03130"></a><span class="lineno"> 3130</span>&#160;Note: `soap_send_empty_response` returns the error code `SOAP_STOP`</div><div class="line"><a name="l03131"></a><span class="lineno"> 3131</span>&#160;to force the engine to stop producing a response message after the service</div><div class="line"><a name="l03132"></a><span class="lineno"> 3132</span>&#160;operation completed, which allows `soap_send_empty_response` to be used</div><div class="line"><a name="l03133"></a><span class="lineno"> 3133</span>&#160;with any service operation that should return HTTP 202.</div><div class="line"><a name="l03134"></a><span class="lineno"> 3134</span>&#160;</div><div class="line"><a name="l03135"></a><span class="lineno"> 3135</span>&#160;## How to Use the SOAP Serializers and Deserializers to Save and Load Application Data using XML Data Bindings        {#bindings}</div><div class="line"><a name="l03136"></a><span class="lineno"> 3136</span>&#160;</div><div class="line"><a name="l03137"></a><span class="lineno"> 3137</span>&#160;The gSOAP XML databindings for C and C++ allow a seamless integration of XML in</div><div class="line"><a name="l03138"></a><span class="lineno"> 3138</span>&#160;C and C++ applications. Data can be serialized in XML and vice versa. WSDL and</div><div class="line"><a name="l03139"></a><span class="lineno"> 3139</span>&#160;XML schema files can be converted to C or C++ definitions. C and C++</div><div class="line"><a name="l03140"></a><span class="lineno"> 3140</span>&#160;definitions can be translated to WSDL and schemas to support legacy ANSI C</div><div class="line"><a name="l03141"></a><span class="lineno"> 3141</span>&#160;applications for example.</div><div class="line"><a name="l03142"></a><span class="lineno"> 3142</span>&#160;</div><div class="line"><a name="l03143"></a><span class="lineno"> 3143</span>&#160;Learn more about XML data binding for C and C++ with gSOAP by visiting the</div><div class="line"><a name="l03144"></a><span class="lineno"> 3144</span>&#160;Developer Center &lt;https://www.genivia.com/dev.html&gt; and the new and most</div><div class="line"><a name="l03145"></a><span class="lineno"> 3145</span>&#160;up-to-date XML data binding documentation</div><div class="line"><a name="l03146"></a><span class="lineno"> 3146</span>&#160;&lt;https://www.genivia.com/doc/databinding/html&gt;.</div><div class="line"><a name="l03147"></a><span class="lineno"> 3147</span>&#160;</div><div class="line"><a name="l03148"></a><span class="lineno"> 3148</span>&#160;### Mapping XML Schema to C/C++ with wsdl2h</div><div class="line"><a name="l03149"></a><span class="lineno"> 3149</span>&#160;</div><div class="line"><a name="l03150"></a><span class="lineno"> 3150</span>&#160;Command:</div><div class="line"><a name="l03151"></a><span class="lineno"> 3151</span>&#160;</div><div class="line"><a name="l03152"></a><span class="lineno"> 3152</span>&#160;    &gt; wsdl2h [options] XSD and WSDL files ...</div><div class="line"><a name="l03153"></a><span class="lineno"> 3153</span>&#160;</div><div class="line"><a name="l03154"></a><span class="lineno"> 3154</span>&#160;The WSDL 1.1 and 2.0 standards are supported. If you have trouble</div><div class="line"><a name="l03155"></a><span class="lineno"> 3155</span>&#160;with WSDL 2.0 please contact the author. The entire XML schema 1.1 standard is</div><div class="line"><a name="l03156"></a><span class="lineno"> 3156</span>&#160;supported, except XPath expressions and assertions. This covers all of the</div><div class="line"><a name="l03157"></a><span class="lineno"> 3157</span>&#160;following schema components with their optional [ attributes ] shown:</div><div class="line"><a name="l03158"></a><span class="lineno"> 3158</span>&#160;</div><div class="line"><a name="l03159"></a><span class="lineno"> 3159</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l03160"></a><span class="lineno"> 3160</span>&#160;```xml</div><div class="line"><a name="l03161"></a><span class="lineno"> 3161</span>&#160;&lt;xs:any [minOccurs, maxOccurs] &gt; </div><div class="line"><a name="l03162"></a><span class="lineno"> 3162</span>&#160;&lt;xs:anyAttribute&gt; </div><div class="line"><a name="l03163"></a><span class="lineno"> 3163</span>&#160;&lt;xs:all&gt; </div><div class="line"><a name="l03164"></a><span class="lineno"> 3164</span>&#160;&lt;xs:choice [minOccurs, maxOccurs] &gt; </div><div class="line"><a name="l03165"></a><span class="lineno"> 3165</span>&#160;&lt;xs:sequence [minOccurs, maxOccurs] &gt; </div><div class="line"><a name="l03166"></a><span class="lineno"> 3166</span>&#160;&lt;xs:group [name, ref] &gt; </div><div class="line"><a name="l03167"></a><span class="lineno"> 3167</span>&#160;&lt;xs:attributeGroup [name, ref] &gt; </div><div class="line"><a name="l03168"></a><span class="lineno"> 3168</span>&#160;&lt;xs:attribute [name, ref, type, use, default, fixed, form, wsdl:arrayType] &gt; </div><div class="line"><a name="l03169"></a><span class="lineno"> 3169</span>&#160;&lt;xs:element [name, ref, type, default, fixed, form, nillable, abstract, substitutionGroup, minOccurs, maxOccurs] &gt; </div><div class="line"><a name="l03170"></a><span class="lineno"> 3170</span>&#160;&lt;xs:simpleType [name] &gt; </div><div class="line"><a name="l03171"></a><span class="lineno"> 3171</span>&#160;&lt;xs:complexType [name, abstract, mixed] &gt;</div><div class="line"><a name="l03172"></a><span class="lineno"> 3172</span>&#160;```</div><div class="line"><a name="l03173"></a><span class="lineno"> 3173</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l03174"></a><span class="lineno"> 3174</span>&#160;</div><div class="line"><a name="l03175"></a><span class="lineno"> 3175</span>&#160;The supported facets are:</div><div class="line"><a name="l03176"></a><span class="lineno"> 3176</span>&#160;</div><div class="line"><a name="l03177"></a><span class="lineno"> 3177</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l03178"></a><span class="lineno"> 3178</span>&#160;```xml</div><div class="line"><a name="l03179"></a><span class="lineno"> 3179</span>&#160;&lt;xs:enumeration&gt; </div><div class="line"><a name="l03180"></a><span class="lineno"> 3180</span>&#160;&lt;xs:simpleContent&gt; </div><div class="line"><a name="l03181"></a><span class="lineno"> 3181</span>&#160;&lt;xs:complexContent&gt; </div><div class="line"><a name="l03182"></a><span class="lineno"> 3182</span>&#160;&lt;xs:list&gt; </div><div class="line"><a name="l03183"></a><span class="lineno"> 3183</span>&#160;&lt;xs:extension&gt; </div><div class="line"><a name="l03184"></a><span class="lineno"> 3184</span>&#160;&lt;xs:restriction&gt; </div><div class="line"><a name="l03185"></a><span class="lineno"> 3185</span>&#160;&lt;xs:length&gt; </div><div class="line"><a name="l03186"></a><span class="lineno"> 3186</span>&#160;&lt;xs:minLength&gt; </div><div class="line"><a name="l03187"></a><span class="lineno"> 3187</span>&#160;&lt;xs:maxLength&gt; </div><div class="line"><a name="l03188"></a><span class="lineno"> 3188</span>&#160;&lt;xs:minInclusive&gt;       validated only for integer types </div><div class="line"><a name="l03189"></a><span class="lineno"> 3189</span>&#160;&lt;xs:maxInclusive&gt;       validated only for integer types </div><div class="line"><a name="l03190"></a><span class="lineno"> 3190</span>&#160;&lt;xs:minExclusive&gt;       validated only for integer types </div><div class="line"><a name="l03191"></a><span class="lineno"> 3191</span>&#160;&lt;xs:maxExclusive&gt;       validated only for integer types </div><div class="line"><a name="l03192"></a><span class="lineno"> 3192</span>&#160;&lt;xs:precision&gt;          maps to float/double with C formatted output </div><div class="line"><a name="l03193"></a><span class="lineno"> 3193</span>&#160;&lt;xs:scale&gt;              maps to float/double with C formatted output </div><div class="line"><a name="l03194"></a><span class="lineno"> 3194</span>&#160;&lt;xs:totalDigits&gt;        maps to float/double with C formatted output </div><div class="line"><a name="l03195"></a><span class="lineno"> 3195</span>&#160;&lt;xs:fractionDigits&gt;     maps to float/double with C formatted output </div><div class="line"><a name="l03196"></a><span class="lineno"> 3196</span>&#160;&lt;xs:pattern&gt;            not automatically validated, see note below </div><div class="line"><a name="l03197"></a><span class="lineno"> 3197</span>&#160;&lt;xs:union&gt;              maps to string, content not validated</div><div class="line"><a name="l03198"></a><span class="lineno"> 3198</span>&#160;```</div><div class="line"><a name="l03199"></a><span class="lineno"> 3199</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l03200"></a><span class="lineno"> 3200</span>&#160;</div><div class="line"><a name="l03201"></a><span class="lineno"> 3201</span>&#160;Other:</div><div class="line"><a name="l03202"></a><span class="lineno"> 3202</span>&#160;</div><div class="line"><a name="l03203"></a><span class="lineno"> 3203</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l03204"></a><span class="lineno"> 3204</span>&#160;```xml</div><div class="line"><a name="l03205"></a><span class="lineno"> 3205</span>&#160;&lt;xs:import&gt; </div><div class="line"><a name="l03206"></a><span class="lineno"> 3206</span>&#160;&lt;xs:include&gt; </div><div class="line"><a name="l03207"></a><span class="lineno"> 3207</span>&#160;&lt;xs:redefine&gt; </div><div class="line"><a name="l03208"></a><span class="lineno"> 3208</span>&#160;&lt;xs:override&gt; </div><div class="line"><a name="l03209"></a><span class="lineno"> 3209</span>&#160;&lt;xs:annotation&gt;</div><div class="line"><a name="l03210"></a><span class="lineno"> 3210</span>&#160;```</div><div class="line"><a name="l03211"></a><span class="lineno"> 3211</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l03212"></a><span class="lineno"> 3212</span>&#160;</div><div class="line"><a name="l03213"></a><span class="lineno"> 3213</span>&#160;All primitive XSD types are supported. A subset of the default type mappings is shown below.</div><div class="line"><a name="l03214"></a><span class="lineno"> 3214</span>&#160;User-defined mappings can be added to `typemap.dat` to let `wsdl2h`</div><div class="line"><a name="l03215"></a><span class="lineno"> 3215</span>&#160;(re)map XSD types to C/C++ types.</div><div class="line"><a name="l03216"></a><span class="lineno"> 3216</span>&#160;</div><div class="line"><a name="l03217"></a><span class="lineno"> 3217</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l03218"></a><span class="lineno"> 3218</span>&#160;```xml</div><div class="line"><a name="l03219"></a><span class="lineno"> 3219</span>&#160;xsd:string              maps to string (char*,wchar_t*,std::string,std::wstring)</div><div class="line"><a name="l03220"></a><span class="lineno"> 3220</span>&#160;xsd:boolean             maps to bool (C++) or enum xsd__boolean (C) </div><div class="line"><a name="l03221"></a><span class="lineno"> 3221</span>&#160;xsd:float               maps to float </div><div class="line"><a name="l03222"></a><span class="lineno"> 3222</span>&#160;xsd:double              maps to double </div><div class="line"><a name="l03223"></a><span class="lineno"> 3223</span>&#160;xsd:decimal             maps to string, or use #import &quot;custom/decimal.h&quot; </div><div class="line"><a name="l03224"></a><span class="lineno"> 3224</span>&#160;xsd:duration            maps to string, or use #import &quot;custom/duration.h&quot; </div><div class="line"><a name="l03225"></a><span class="lineno"> 3225</span>&#160;xsd:dateTime            maps to time_t, or use #import &quot;custom/struct_tm.h&quot; </div><div class="line"><a name="l03226"></a><span class="lineno"> 3226</span>&#160;xsd:time                maps to string (white space collapse applied)</div><div class="line"><a name="l03227"></a><span class="lineno"> 3227</span>&#160;xsd:date                maps to string (white space collapse applied)</div><div class="line"><a name="l03228"></a><span class="lineno"> 3228</span>&#160;xsd:gYearMonth          maps to string (white space collapse applied)</div><div class="line"><a name="l03229"></a><span class="lineno"> 3229</span>&#160;xsd:gYear               maps to string (white space collapse applied) </div><div class="line"><a name="l03230"></a><span class="lineno"> 3230</span>&#160;xsd:gMonth              maps to string (white space collapse applied) </div><div class="line"><a name="l03231"></a><span class="lineno"> 3231</span>&#160;xsd:hexBinary           maps to struct xsd__hexBinary </div><div class="line"><a name="l03232"></a><span class="lineno"> 3232</span>&#160;xsd:base64Bianry        maps to struct xsd__base64Binary </div><div class="line"><a name="l03233"></a><span class="lineno"> 3233</span>&#160;xsd:anyURI              maps to string (white space collapse applied)</div><div class="line"><a name="l03234"></a><span class="lineno"> 3234</span>&#160;xsd:anyType             maps to an XML string or DOM with wsdl2h -d</div><div class="line"><a name="l03235"></a><span class="lineno"> 3235</span>&#160;xsd:anyAtomicType       maps to string  </div><div class="line"><a name="l03236"></a><span class="lineno"> 3236</span>&#160;xsd:anySimpleType       maps to string  </div><div class="line"><a name="l03237"></a><span class="lineno"> 3237</span>&#160;xsd:QName               maps to _QName (QName normalization applied)</div><div class="line"><a name="l03238"></a><span class="lineno"> 3238</span>&#160;xsd:NOTATION            maps to string (white space collapse applied)</div><div class="line"><a name="l03239"></a><span class="lineno"> 3239</span>&#160;```</div><div class="line"><a name="l03240"></a><span class="lineno"> 3240</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l03241"></a><span class="lineno"> 3241</span>&#160;</div><div class="line"><a name="l03242"></a><span class="lineno"> 3242</span>&#160;Note: automatic validation of *`xs:pattern`* restricted content is possible with a hook to a regex pattern matching engine, see the `fsvalidate` and `fwvalidate` callbacks in Section \ref callback .</div><div class="line"><a name="l03243"></a><span class="lineno"> 3243</span>&#160;</div><div class="line"><a name="l03244"></a><span class="lineno"> 3244</span>&#160;Note: string targets are defined in the `typemap.dat` file used by</div><div class="line"><a name="l03245"></a><span class="lineno"> 3245</span>&#160;`wsdl2h` to map XSD types. This allows the use of `char*`,</div><div class="line"><a name="l03246"></a><span class="lineno"> 3246</span>&#160;`wsha_t*`, `std::string`, and `std::wstring` string types for</div><div class="line"><a name="l03247"></a><span class="lineno"> 3247</span>&#160;all XSD types mapped to strings.</div><div class="line"><a name="l03248"></a><span class="lineno"> 3248</span>&#160;</div><div class="line"><a name="l03249"></a><span class="lineno"> 3249</span>&#160;All non-primitive XSD types are supported (with the default mapping shown):</div><div class="line"><a name="l03250"></a><span class="lineno"> 3250</span>&#160;</div><div class="line"><a name="l03251"></a><span class="lineno"> 3251</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l03252"></a><span class="lineno"> 3252</span>&#160;```xml</div><div class="line"><a name="l03253"></a><span class="lineno"> 3253</span>&#160;xsd:normalizedString   maps to string </div><div class="line"><a name="l03254"></a><span class="lineno"> 3254</span>&#160;xsd:token   maps to string </div><div class="line"><a name="l03255"></a><span class="lineno"> 3255</span>&#160;xsd:language   maps to string </div><div class="line"><a name="l03256"></a><span class="lineno"> 3256</span>&#160;xsd:IDREFS   maps to string </div><div class="line"><a name="l03257"></a><span class="lineno"> 3257</span>&#160;xsd:ENTITIES   maps to string </div><div class="line"><a name="l03258"></a><span class="lineno"> 3258</span>&#160;xsd:NMTOKEN   maps to string </div><div class="line"><a name="l03259"></a><span class="lineno"> 3259</span>&#160;xsd:NMTOKENS   maps to string </div><div class="line"><a name="l03260"></a><span class="lineno"> 3260</span>&#160;xsd:Name   maps to string </div><div class="line"><a name="l03261"></a><span class="lineno"> 3261</span>&#160;xsd:NCName   maps to string </div><div class="line"><a name="l03262"></a><span class="lineno"> 3262</span>&#160;xsd:ID   maps to string </div><div class="line"><a name="l03263"></a><span class="lineno"> 3263</span>&#160;xsd:IDREF   maps to string </div><div class="line"><a name="l03264"></a><span class="lineno"> 3264</span>&#160;xsd:ENTITY   maps to string </div><div class="line"><a name="l03265"></a><span class="lineno"> 3265</span>&#160;xsd:integer   maps to string </div><div class="line"><a name="l03266"></a><span class="lineno"> 3266</span>&#160;xsd:nonPositiveInteger   maps to string</div><div class="line"><a name="l03267"></a><span class="lineno"> 3267</span>&#160;xsd:negativeInteger   maps to string</div><div class="line"><a name="l03268"></a><span class="lineno"> 3268</span>&#160;xsd:long                maps to LONG64 </div><div class="line"><a name="l03269"></a><span class="lineno"> 3269</span>&#160;xsd:int                 maps to int </div><div class="line"><a name="l03270"></a><span class="lineno"> 3270</span>&#160;xsd:short               maps to short </div><div class="line"><a name="l03271"></a><span class="lineno"> 3271</span>&#160;xsd:byte                maps to byte </div><div class="line"><a name="l03272"></a><span class="lineno"> 3272</span>&#160;xsd:nonNegativeInteger   maps to string</div><div class="line"><a name="l03273"></a><span class="lineno"> 3273</span>&#160;xsd:unsignedLong        maps to ULONG64 </div><div class="line"><a name="l03274"></a><span class="lineno"> 3274</span>&#160;xsd:unsignedInt         maps to unsigned int </div><div class="line"><a name="l03275"></a><span class="lineno"> 3275</span>&#160;xsd:unsignedShort       maps to unsigned short </div><div class="line"><a name="l03276"></a><span class="lineno"> 3276</span>&#160;xsd:unsignedByte        maps to unsigned byte </div><div class="line"><a name="l03277"></a><span class="lineno"> 3277</span>&#160;xsd:positiveInteger   maps to string</div><div class="line"><a name="l03278"></a><span class="lineno"> 3278</span>&#160;xsd:yearMonthDuration   maps to string</div><div class="line"><a name="l03279"></a><span class="lineno"> 3279</span>&#160;xsd:dayTimeDuration   maps to string</div><div class="line"><a name="l03280"></a><span class="lineno"> 3280</span>&#160;xsd:dateTimeStamp   maps to string</div><div class="line"><a name="l03281"></a><span class="lineno"> 3281</span>&#160;```</div><div class="line"><a name="l03282"></a><span class="lineno"> 3282</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l03283"></a><span class="lineno"> 3283</span>&#160;</div><div class="line"><a name="l03284"></a><span class="lineno"> 3284</span>&#160;There are several initialization flags to control XML serialization at runtime:</div><div class="line"><a name="l03285"></a><span class="lineno"> 3285</span>&#160;  </div><div class="line"><a name="l03286"></a><span class="lineno"> 3286</span>&#160;*  XML validation is more stricly enforced with `SOAP_XML_STRICT`.</div><div class="line"><a name="l03287"></a><span class="lineno"> 3287</span>&#160;  </div><div class="line"><a name="l03288"></a><span class="lineno"> 3288</span>&#160;*  XML namespaces are supported, unless disabled with `SOAP_XML_IGNORENS`.</div><div class="line"><a name="l03289"></a><span class="lineno"> 3289</span>&#160;  </div><div class="line"><a name="l03290"></a><span class="lineno"> 3290</span>&#160;*  XML exclusive canonicalization is enabled with `SOAP_XML_CANONICAL`.</div><div class="line"><a name="l03291"></a><span class="lineno"> 3291</span>&#160;  </div><div class="line"><a name="l03292"></a><span class="lineno"> 3292</span>&#160;*  XML default `xmlns=&quot;...&quot;` namespace bindings are enforced with `SOAP_XML_DEFAULTNS`.</div><div class="line"><a name="l03293"></a><span class="lineno"> 3293</span>&#160;  </div><div class="line"><a name="l03294"></a><span class="lineno"> 3294</span>&#160;*  XML is indented for enhanced readability with `SOAP_XML_INDENT`.</div><div class="line"><a name="l03295"></a><span class="lineno"> 3295</span>&#160;  </div><div class="line"><a name="l03296"></a><span class="lineno"> 3296</span>&#160;*  XML `xsi:nil` for NULL elements is serialized with `SOAP_XML_NIL`.</div><div class="line"><a name="l03297"></a><span class="lineno"> 3297</span>&#160;</div><div class="line"><a name="l03298"></a><span class="lineno"> 3298</span>&#160;Strict validation catches all **structural** XML validation violations. For</div><div class="line"><a name="l03299"></a><span class="lineno"> 3299</span>&#160;primitive type values, it depends on the C/C++ target type that XSD types are</div><div class="line"><a name="l03300"></a><span class="lineno"> 3300</span>&#160;mapped to, to catch primitive value content pattern violations. Primitive value</div><div class="line"><a name="l03301"></a><span class="lineno"> 3301</span>&#160;content validation is performed on non-string types such as numerical and time</div><div class="line"><a name="l03302"></a><span class="lineno"> 3302</span>&#160;values. String values are not automatocally validated, unless a</div><div class="line"><a name="l03303"></a><span class="lineno"> 3303</span>&#160;*`xs:pattern`* is given and the `fsvalidate` and `fwvalidate`</div><div class="line"><a name="l03304"></a><span class="lineno"> 3304</span>&#160;callbacks are implemented by the user. Alternatively, deserialized string</div><div class="line"><a name="l03305"></a><span class="lineno"> 3305</span>&#160;content can be checked at the application level.</div><div class="line"><a name="l03306"></a><span class="lineno"> 3306</span>&#160;</div><div class="line"><a name="l03307"></a><span class="lineno"> 3307</span>&#160;To obtain C and/or C++ type definitions for XML schema components, run</div><div class="line"><a name="l03308"></a><span class="lineno"> 3308</span>&#160;`wsdl2h` on the schemas to generate a header file. This header file defines</div><div class="line"><a name="l03309"></a><span class="lineno"> 3309</span>&#160;the C/C++ type representations of the XML schema components. The header file</div><div class="line"><a name="l03310"></a><span class="lineno"> 3310</span>&#160;is then processed by the `soapcpp2` tool to generate</div><div class="line"><a name="l03311"></a><span class="lineno"> 3311</span>&#160;the serializers for these types. See Section \ref databindings  for an overview to use `wsdl2h` and `soapcpp2` to map schemas to C/C++ types to obtain XML data bindings.</div><div class="line"><a name="l03312"></a><span class="lineno"> 3312</span>&#160;</div><div class="line"><a name="l03313"></a><span class="lineno"> 3313</span>&#160;### Mapping C/C++ to XML Schema with soapcpp2</div><div class="line"><a name="l03314"></a><span class="lineno"> 3314</span>&#160;</div><div class="line"><a name="l03315"></a><span class="lineno"> 3315</span>&#160;To generate serialization code, execute:</div><div class="line"><a name="l03316"></a><span class="lineno"> 3316</span>&#160;</div><div class="line"><a name="l03317"></a><span class="lineno"> 3317</span>&#160;    &gt; soapcpp2 [options] header_file.h</div><div class="line"><a name="l03318"></a><span class="lineno"> 3318</span>&#160;</div><div class="line"><a name="l03319"></a><span class="lineno"> 3319</span>&#160;The following C/C++ types are supported in the header file:</div><div class="line"><a name="l03320"></a><span class="lineno"> 3320</span>&#160;</div><div class="line"><a name="l03321"></a><span class="lineno"> 3321</span>&#160;```cpp</div><div class="line"><a name="l03322"></a><span class="lineno"> 3322</span>&#160;  bool </div><div class="line"><a name="l03323"></a><span class="lineno"> 3323</span>&#160;  enum, enum* (&#39;enum*&#39; indicates serialized as a bitmask) </div><div class="line"><a name="l03324"></a><span class="lineno"> 3324</span>&#160;  (unsigned) char, short, int, long, long long (also LONG64), size_t </div><div class="line"><a name="l03325"></a><span class="lineno"> 3325</span>&#160;  float, double, long double (#import &quot;custom/long_double.h&quot;) </div><div class="line"><a name="l03326"></a><span class="lineno"> 3326</span>&#160;  std::string, std::wstring, char[], char*, wchar_t* </div><div class="line"><a name="l03327"></a><span class="lineno"> 3327</span>&#160;  _XML (a char* type to hold literal XML string content) </div><div class="line"><a name="l03328"></a><span class="lineno"> 3328</span>&#160;  _QName (a char* type with normalized QName content of the form prefix:name) </div><div class="line"><a name="l03329"></a><span class="lineno"> 3329</span>&#160;  struct, class (with single inheritance) </div><div class="line"><a name="l03330"></a><span class="lineno"> 3330</span>&#160;  std::vector, std::list, std::deque, std::set (#import &quot;import/stl.h&quot;) </div><div class="line"><a name="l03331"></a><span class="lineno"> 3331</span>&#160;  union (requires preceding discriminant member field) </div><div class="line"><a name="l03332"></a><span class="lineno"> 3332</span>&#160;  typedef </div><div class="line"><a name="l03333"></a><span class="lineno"> 3333</span>&#160;  time_t </div><div class="line"><a name="l03334"></a><span class="lineno"> 3334</span>&#160;  template &lt;&gt; class (requires begin(), end(), size(), and insert() methods)  </div><div class="line"><a name="l03335"></a><span class="lineno"> 3335</span>&#160;  void* (requires a preceding __type field to indicate the object pointed to) </div><div class="line"><a name="l03336"></a><span class="lineno"> 3336</span>&#160;  struct xsd__hexBinary (special pre-defined type to hold binary content) </div><div class="line"><a name="l03337"></a><span class="lineno"> 3337</span>&#160;  struct xsd__base64Binary (special pre-defined type to hold binary content) </div><div class="line"><a name="l03338"></a><span class="lineno"> 3338</span>&#160;  struct tm (#import &quot;custom/struct_tm.h&quot;) </div><div class="line"><a name="l03339"></a><span class="lineno"> 3339</span>&#160;  struct timeval (#import &quot;custom/struct_timeval.h&quot;) </div><div class="line"><a name="l03340"></a><span class="lineno"> 3340</span>&#160;  pointers to any of the above (any pointer-linked structures are serializable, including cyclic graphs) </div><div class="line"><a name="l03341"></a><span class="lineno"> 3341</span>&#160;  fixed-size arrays of all of the above</div><div class="line"><a name="l03342"></a><span class="lineno"> 3342</span>&#160;```</div><div class="line"><a name="l03343"></a><span class="lineno"> 3343</span>&#160;</div><div class="line"><a name="l03344"></a><span class="lineno"> 3344</span>&#160;Additional features and C/C++ syntax requirements:</div><div class="line"><a name="l03345"></a><span class="lineno"> 3345</span>&#160;  </div><div class="line"><a name="l03346"></a><span class="lineno"> 3346</span>&#160;*  A header file should not include any code statements, only data type declarations.</div><div class="line"><a name="l03347"></a><span class="lineno"> 3347</span>&#160;  </div><div class="line"><a name="l03348"></a><span class="lineno"> 3348</span>&#160;*  Nested classes and nested types are unnested.</div><div class="line"><a name="l03349"></a><span class="lineno"> 3349</span>&#160;  </div><div class="line"><a name="l03350"></a><span class="lineno"> 3350</span>&#160;*  Use `#import &quot;file.h&quot;` instead of `#include` to import other header files. The</div><div class="line"><a name="l03351"></a><span class="lineno"> 3351</span>&#160;  `#include` and `#define` directives are accepted, but deferred to the generated</div><div class="line"><a name="l03352"></a><span class="lineno"> 3352</span>&#160;  code.</div><div class="line"><a name="l03353"></a><span class="lineno"> 3353</span>&#160;  </div><div class="line"><a name="l03354"></a><span class="lineno"> 3354</span>&#160;*  C++ namespaces are supported (must cover entire header file content)</div><div class="line"><a name="l03355"></a><span class="lineno"> 3355</span>&#160;  </div><div class="line"><a name="l03356"></a><span class="lineno"> 3356</span>&#160;*  Optional DOM support can be used to store mixed content or literal XML</div><div class="line"><a name="l03357"></a><span class="lineno"> 3357</span>&#160;  content. Otherwise, mixed content may be lost. Use soapcpp2 option -d for DOM</div><div class="line"><a name="l03358"></a><span class="lineno"> 3358</span>&#160;  support.  Learn more about the DOM API for C and C++ by visiting the</div><div class="line"><a name="l03359"></a><span class="lineno"> 3359</span>&#160;  Developer Center &lt;https://www.genivia.com/doc/dom/html&gt;.</div><div class="line"><a name="l03360"></a><span class="lineno"> 3360</span>&#160;  </div><div class="line"><a name="l03361"></a><span class="lineno"> 3361</span>&#160;*  Types are denoted transient using the &#39;extern&#39; qualifier, which prevents</div><div class="line"><a name="l03362"></a><span class="lineno"> 3362</span>&#160;  serialization as desired:</div><div class="line"><a name="l03363"></a><span class="lineno"> 3363</span>&#160;</div><div class="line"><a name="l03364"></a><span class="lineno"> 3364</span>&#160;```cpp</div><div class="line"><a name="l03365"></a><span class="lineno"> 3365</span>&#160;  extern class name; // class &#39;name&#39; is not serialized </div><div class="line"><a name="l03366"></a><span class="lineno"> 3366</span>&#160;  struct name { extern char *name; int num; }; // &#39;name&#39; is not serialized</div><div class="line"><a name="l03367"></a><span class="lineno"> 3367</span>&#160;```</div><div class="line"><a name="l03368"></a><span class="lineno"> 3368</span>&#160;  </div><div class="line"><a name="l03369"></a><span class="lineno"> 3369</span>&#160;*  Only public members of a class can be serialized:</div><div class="line"><a name="l03370"></a><span class="lineno"> 3370</span>&#160;</div><div class="line"><a name="l03371"></a><span class="lineno"> 3371</span>&#160;```cpp</div><div class="line"><a name="l03372"></a><span class="lineno"> 3372</span>&#160;  class name { private: char *secret; }; // &#39;secret&#39; is not serialized</div><div class="line"><a name="l03373"></a><span class="lineno"> 3373</span>&#160;```</div><div class="line"><a name="l03374"></a><span class="lineno"> 3374</span>&#160;  </div><div class="line"><a name="l03375"></a><span class="lineno"> 3375</span>&#160;*  Types declared &quot;volatile&quot; means that they are declared elsewhere</div><div class="line"><a name="l03376"></a><span class="lineno"> 3376</span>&#160;  in the project&#39;s code base and should not be redefined in the `soapcpp2`-generated code nor changed/augmented by the `soapcpp2` tool:</div><div class="line"><a name="l03377"></a><span class="lineno"> 3377</span>&#160;</div><div class="line"><a name="l03378"></a><span class="lineno"> 3378</span>&#160;```cpp</div><div class="line"><a name="l03379"></a><span class="lineno"> 3379</span>&#160;  volatile class name { ... }; // defined here just to generate the serializers</div><div class="line"><a name="l03380"></a><span class="lineno"> 3380</span>&#160;``` </div><div class="line"><a name="l03381"></a><span class="lineno"> 3381</span>&#160;  </div><div class="line"><a name="l03382"></a><span class="lineno"> 3382</span>&#160;*  Classes and structs declared &quot;mutable&quot; means that they can be augmented with additional members, rather than leading to a redefinition error:</div><div class="line"><a name="l03383"></a><span class="lineno"> 3383</span>&#160;</div><div class="line"><a name="l03384"></a><span class="lineno"> 3384</span>&#160;```cpp</div><div class="line"><a name="l03385"></a><span class="lineno"> 3385</span>&#160;  mutable class name { int n; }; // class has a member &#39;n&#39; </div><div class="line"><a name="l03386"></a><span class="lineno"> 3386</span>&#160;  mutable class name { float x; }; // and also a member &#39;x&#39;</div><div class="line"><a name="l03387"></a><span class="lineno"> 3387</span>&#160;``` </div><div class="line"><a name="l03388"></a><span class="lineno"> 3388</span>&#160;</div><div class="line"><a name="l03389"></a><span class="lineno"> 3389</span>&#160;  The `SOAP_ENV__Header` struct is mutable as well as the `SOAP_ENV__Fault`, `SOAP_ENV__Detail`, `SOAP_ENV__Reason`, and `SOAP_ENV__Code` structs.</div><div class="line"><a name="l03390"></a><span class="lineno"> 3390</span>&#160;  </div><div class="line"><a name="l03391"></a><span class="lineno"> 3391</span>&#160;*  struct/class members are serialized as attributes when qualified with &#39;@&#39;:</div><div class="line"><a name="l03392"></a><span class="lineno"> 3392</span>&#160;</div><div class="line"><a name="l03393"></a><span class="lineno"> 3393</span>&#160;```cpp</div><div class="line"><a name="l03394"></a><span class="lineno"> 3394</span>&#160;  struct record { @ char *name; int num; }; // attribute name, element num</div><div class="line"><a name="l03395"></a><span class="lineno"> 3395</span>&#160;```</div><div class="line"><a name="l03396"></a><span class="lineno"> 3396</span>&#160;  </div><div class="line"><a name="l03397"></a><span class="lineno"> 3397</span>&#160;*  Strings with 8-bit content can hold ASCII (default) or UTF8. The latter is</div><div class="line"><a name="l03398"></a><span class="lineno"> 3398</span>&#160;  possible by enabling the `SOAP_C_UTFSTRING` flag. When enabled, all `std::string` and `char*` strings MUST contain UTF8.</div><div class="line"><a name="l03399"></a><span class="lineno"> 3399</span>&#160;</div><div class="line"><a name="l03400"></a><span class="lineno"> 3400</span>&#160;The soapcpp2 tool generates serializers and deserializers</div><div class="line"><a name="l03401"></a><span class="lineno"> 3401</span>&#160;for all wsdl2h-generated or user-defined data structures that are specified in</div><div class="line"><a name="l03402"></a><span class="lineno"> 3402</span>&#160;the header file input to the compiler. The serializers and deserializers can be</div><div class="line"><a name="l03403"></a><span class="lineno"> 3403</span>&#160;found in the generated</div><div class="line"><a name="l03404"></a><span class="lineno"> 3404</span>&#160;`soapC.cpp` file. These serializers and deserializers can be used separately by an application without the need to build a</div><div class="line"><a name="l03405"></a><span class="lineno"> 3405</span>&#160;full client or service application.  This is useful for applications that need to save or export their data in XML or need to</div><div class="line"><a name="l03406"></a><span class="lineno"> 3406</span>&#160;import or load data stored in XML format.</div><div class="line"><a name="l03407"></a><span class="lineno"> 3407</span>&#160;</div><div class="line"><a name="l03408"></a><span class="lineno"> 3408</span>&#160;### Serializing C/C++ Data to XML        {#serialize}</div><div class="line"><a name="l03409"></a><span class="lineno"> 3409</span>&#160;</div><div class="line"><a name="l03410"></a><span class="lineno"> 3410</span>&#160;We assume that the `wsdl2h` tool was used to map XML schema types to C/C++ data types. The `soapcpp2` tool then generates the (de)serializers for the C/C++ types. You can also use `soapcpp2` directly on a header file that declares annotated C/C++ data types to serialize.</div><div class="line"><a name="l03411"></a><span class="lineno"> 3411</span>&#160;</div><div class="line"><a name="l03412"></a><span class="lineno"> 3412</span>&#160;The following context attributes can be set to control the destination and source for serialization and deserialization:</div><div class="line"><a name="l03413"></a><span class="lineno"> 3413</span>&#160;</div><div class="line"><a name="l03414"></a><span class="lineno"> 3414</span>&#160;* `int soap.socket` socket file descriptor for input and output (or set to `SOAP_INVALID_SOCKET`) </div><div class="line"><a name="l03415"></a><span class="lineno"> 3415</span>&#160;</div><div class="line"><a name="l03416"></a><span class="lineno"> 3416</span>&#160;* `ostream *soap.os`      C++ only: output stream used for send operations </div><div class="line"><a name="l03417"></a><span class="lineno"> 3417</span>&#160;</div><div class="line"><a name="l03418"></a><span class="lineno"> 3418</span>&#160;* `const char **soap.os`  C only: points to a string pointer to be set with the managed string content </div><div class="line"><a name="l03419"></a><span class="lineno"> 3419</span>&#160;</div><div class="line"><a name="l03420"></a><span class="lineno"> 3420</span>&#160;* `istream *soap.is`      C++ only: input stream used for receive operations </div><div class="line"><a name="l03421"></a><span class="lineno"> 3421</span>&#160;</div><div class="line"><a name="l03422"></a><span class="lineno"> 3422</span>&#160;* `const char *soap.is`   C only: string with input to parse (this pointer advances) </div><div class="line"><a name="l03423"></a><span class="lineno"> 3423</span>&#160;</div><div class="line"><a name="l03424"></a><span class="lineno"> 3424</span>&#160;* `int soap.sendfd` when `soap.socket`=`SOAP_INVALID_SOCKET`, this fd is used for send operations </div><div class="line"><a name="l03425"></a><span class="lineno"> 3425</span>&#160;</div><div class="line"><a name="l03426"></a><span class="lineno"> 3426</span>&#160;* `int soap.recvfd` when `soap.socket`=`SOAP_INVALID_SOCKET`, this fd is used for receive operations </div><div class="line"><a name="l03427"></a><span class="lineno"> 3427</span>&#160;</div><div class="line"><a name="l03428"></a><span class="lineno"> 3428</span>&#160;The following initializing and finalizing functions can be used:</div><div class="line"><a name="l03429"></a><span class="lineno"> 3429</span>&#160;</div><div class="line"><a name="l03430"></a><span class="lineno"> 3430</span>&#160;* `void soap_begin_send(struct soap*)`    start a send/write phase </div><div class="line"><a name="l03431"></a><span class="lineno"> 3431</span>&#160;</div><div class="line"><a name="l03432"></a><span class="lineno"> 3432</span>&#160;* `int soap_end_send(struct soap*)`       flush the buffer </div><div class="line"><a name="l03433"></a><span class="lineno"> 3433</span>&#160;</div><div class="line"><a name="l03434"></a><span class="lineno"> 3434</span>&#160;* `int soap_begin_recv(struct soap*)`     start a rec/read phase (if an HTTP header is present, parse it first) </div><div class="line"><a name="l03435"></a><span class="lineno"> 3435</span>&#160;</div><div class="line"><a name="l03436"></a><span class="lineno"> 3436</span>&#160;* `int soap_end_recv(struct soap*)`       perform a id/href consistency check on deserialized data </div><div class="line"><a name="l03437"></a><span class="lineno"> 3437</span>&#160;</div><div class="line"><a name="l03438"></a><span class="lineno"> 3438</span>&#160;These operations do not open or close the connections. The application should open and close connections or files and set the `soap.socket`, `soap.os` or `soap.sendfd`, `soap.is` or `soap.recvfd` streams or descriptors.</div><div class="line"><a name="l03439"></a><span class="lineno"> 3439</span>&#160;When `soap.socket`&lt;0 and none of the streams and descriptors are set, then the standard input and output will be used.</div><div class="line"><a name="l03440"></a><span class="lineno"> 3440</span>&#160;</div><div class="line"><a name="l03441"></a><span class="lineno"> 3441</span>&#160;The following options are available to control serialization:</div><div class="line"><a name="l03442"></a><span class="lineno"> 3442</span>&#160;</div><div class="line"><a name="l03443"></a><span class="lineno"> 3443</span>&#160;```cpp</div><div class="line"><a name="l03444"></a><span class="lineno"> 3444</span>&#160;soap-&gt;encodingStyle = NULL; // to remove SOAP 1.1/1.2 encodingStyle</div><div class="line"><a name="l03445"></a><span class="lineno"> 3445</span>&#160;soap_mode(soap, SOAP_XML_TREE); // XML without id-ref (no cycles!)</div><div class="line"><a name="l03446"></a><span class="lineno"> 3446</span>&#160;soap_mode(soap, SOAP_XML_GRAPH); // XML with id-ref (including cycles)</div><div class="line"><a name="l03447"></a><span class="lineno"> 3447</span>&#160;soap_set_namespaces(soap, struct Namespace *nsmap); //to set xmlns bindings</div><div class="line"><a name="l03448"></a><span class="lineno"> 3448</span>&#160;```</div><div class="line"><a name="l03449"></a><span class="lineno"> 3449</span>&#160;</div><div class="line"><a name="l03450"></a><span class="lineno"> 3450</span>&#160;See also Section \ref flags  to control the I/O buffering and content encoding such as compression and DIME encoding.</div><div class="line"><a name="l03451"></a><span class="lineno"> 3451</span>&#160;</div><div class="line"><a name="l03452"></a><span class="lineno"> 3452</span>&#160;We assume that the `wsdl2h` tool was used to map XML schema types to C/C++ data types. The `soapcpp2` tool then generates the (de)serializers for the C/C++ types.</div><div class="line"><a name="l03453"></a><span class="lineno"> 3453</span>&#160;</div><div class="line"><a name="l03454"></a><span class="lineno"> 3454</span>&#160;To serialize data to an XML stream, two functions should be called to prepare</div><div class="line"><a name="l03455"></a><span class="lineno"> 3455</span>&#160;for serialization of the data and to send the data, respectively.  The first function,</div><div class="line"><a name="l03456"></a><span class="lineno"> 3456</span>&#160;`soap_serialize`, analyzes pointers and determines if multi-references</div><div class="line"><a name="l03457"></a><span class="lineno"> 3457</span>&#160;are required to encode the data and if cycles are present the object graph.</div><div class="line"><a name="l03458"></a><span class="lineno"> 3458</span>&#160;The second function, `soap_put`, produces the XML output on a stream.</div><div class="line"><a name="l03459"></a><span class="lineno"> 3459</span>&#160;</div><div class="line"><a name="l03460"></a><span class="lineno"> 3460</span>&#160;The `soap_serialize` and `soap_put` (and both combined by `soap_write`) functions are statically generated specific to a</div><div class="line"><a name="l03461"></a><span class="lineno"> 3461</span>&#160;data type. For example, `soap_serialize_float(&amp;soap, &amp;d)` is called to</div><div class="line"><a name="l03462"></a><span class="lineno"> 3462</span>&#160;serialize an `float` value and `soap_put_float(&amp;soap, &amp;d, &quot;number&quot;, NULL)` is called to output the floating point value in SOAP tagged</div><div class="line"><a name="l03463"></a><span class="lineno"> 3463</span>&#160;with the name *`&lt;number&gt;`*. The `soap_write_float(&amp;soap, &amp;d)` conveniently combines the initialization of output, writing the data, and finalizing the output.</div><div class="line"><a name="l03464"></a><span class="lineno"> 3464</span>&#160;</div><div class="line"><a name="l03465"></a><span class="lineno"> 3465</span>&#160;To initialize data, the `soap_default`</div><div class="line"><a name="l03466"></a><span class="lineno"> 3466</span>&#160;function of a data type can be used.  For example,</div><div class="line"><a name="l03467"></a><span class="lineno"> 3467</span>&#160;`soap_default_float(&amp;soap, &amp;d)` initializes the float to 0.0.  The</div><div class="line"><a name="l03468"></a><span class="lineno"> 3468</span>&#160;`soap_default` functions are useful to initialize complex data types such</div><div class="line"><a name="l03469"></a><span class="lineno"> 3469</span>&#160;as arrays, `struct`s, and `class` instances.  Note that the</div><div class="line"><a name="l03470"></a><span class="lineno"> 3470</span>&#160;`soap_default` functions do not need the gSOAP runtime context as a</div><div class="line"><a name="l03471"></a><span class="lineno"> 3471</span>&#160;first parameter.</div><div class="line"><a name="l03472"></a><span class="lineno"> 3472</span>&#160;</div><div class="line"><a name="l03473"></a><span class="lineno"> 3473</span>&#160;The following table lists the type naming conventions used by gSOAP:</div><div class="line"><a name="l03474"></a><span class="lineno"> 3474</span>&#160;</div><div class="line"><a name="l03475"></a><span class="lineno"> 3475</span>&#160;Type | Name</div><div class="line"><a name="l03476"></a><span class="lineno"> 3476</span>&#160;---- | ----------</div><div class="line"><a name="l03477"></a><span class="lineno"> 3477</span>&#160;`char*`              | `string` </div><div class="line"><a name="l03478"></a><span class="lineno"> 3478</span>&#160;`wchar_t*`           | `wstring` </div><div class="line"><a name="l03479"></a><span class="lineno"> 3479</span>&#160;`std::string`        | `std__string` </div><div class="line"><a name="l03480"></a><span class="lineno"> 3480</span>&#160;`std::wstring`       | `std__wstring` </div><div class="line"><a name="l03481"></a><span class="lineno"> 3481</span>&#160;`char`               | `byte` </div><div class="line"><a name="l03482"></a><span class="lineno"> 3482</span>&#160;`bool`               | `bool` </div><div class="line"><a name="l03483"></a><span class="lineno"> 3483</span>&#160;`double`             | `double` </div><div class="line"><a name="l03484"></a><span class="lineno"> 3484</span>&#160;`int`                | `int` </div><div class="line"><a name="l03485"></a><span class="lineno"> 3485</span>&#160;`float`              | `float` </div><div class="line"><a name="l03486"></a><span class="lineno"> 3486</span>&#160;`long`               | `long` </div><div class="line"><a name="l03487"></a><span class="lineno"> 3487</span>&#160;`long long`          | `LONG64`</div><div class="line"><a name="l03488"></a><span class="lineno"> 3488</span>&#160;`short`              | `short` </div><div class="line"><a name="l03489"></a><span class="lineno"> 3489</span>&#160;`time_t`             | `time` </div><div class="line"><a name="l03490"></a><span class="lineno"> 3490</span>&#160;`unsigned char`      | `unsignedByte` </div><div class="line"><a name="l03491"></a><span class="lineno"> 3491</span>&#160;`unsigned int`       | `unsignedInt` </div><div class="line"><a name="l03492"></a><span class="lineno"> 3492</span>&#160;`unsigned long`      | `unsignedLong` </div><div class="line"><a name="l03493"></a><span class="lineno"> 3493</span>&#160;`unsigned long long` | `ULONG64`</div><div class="line"><a name="l03494"></a><span class="lineno"> 3494</span>&#160;`unsigned short`     | `unsignedShort` </div><div class="line"><a name="l03495"></a><span class="lineno"> 3495</span>&#160;`T`[N]               | `ArrayN`OfType where Type is the type name of T </div><div class="line"><a name="l03496"></a><span class="lineno"> 3496</span>&#160;`T`*                 | `PointerToType` where Type is the type name of T </div><div class="line"><a name="l03497"></a><span class="lineno"> 3497</span>&#160;`std::vector&lt;T&gt;`     | `TemplateOfType` where Type is the type name of T </div><div class="line"><a name="l03498"></a><span class="lineno"> 3498</span>&#160;`struct Name`        | `Name` </div><div class="line"><a name="l03499"></a><span class="lineno"> 3499</span>&#160;`class Name`         | `Name` </div><div class="line"><a name="l03500"></a><span class="lineno"> 3500</span>&#160;`enum Name`          | `Name` </div><div class="line"><a name="l03501"></a><span class="lineno"> 3501</span>&#160;</div><div class="line"><a name="l03502"></a><span class="lineno"> 3502</span>&#160;Consider for example the following C code with a declaration of `p` as a</div><div class="line"><a name="l03503"></a><span class="lineno"> 3503</span>&#160;pointer to a `struct ns__Person`:</div><div class="line"><a name="l03504"></a><span class="lineno"> 3504</span>&#160;</div><div class="line"><a name="l03505"></a><span class="lineno"> 3505</span>&#160;```cpp</div><div class="line"><a name="l03506"></a><span class="lineno"> 3506</span>&#160;struct ns__Person { char *name; } *p;</div><div class="line"><a name="l03507"></a><span class="lineno"> 3507</span>&#160;```</div><div class="line"><a name="l03508"></a><span class="lineno"> 3508</span>&#160;</div><div class="line"><a name="l03509"></a><span class="lineno"> 3509</span>&#160;To serialize `p`, its address is passed to the function</div><div class="line"><a name="l03510"></a><span class="lineno"> 3510</span>&#160;`soap_serialize_PointerTons__Person` generated for this type by the</div><div class="line"><a name="l03511"></a><span class="lineno"> 3511</span>&#160;gSOAP `soapcpp2` compiler:</div><div class="line"><a name="l03512"></a><span class="lineno"> 3512</span>&#160;</div><div class="line"><a name="l03513"></a><span class="lineno"> 3513</span>&#160;```cpp</div><div class="line"><a name="l03514"></a><span class="lineno"> 3514</span>&#160;soap_serialize_PointerTons__Person(&amp;soap, &amp;p);</div><div class="line"><a name="l03515"></a><span class="lineno"> 3515</span>&#160;```</div><div class="line"><a name="l03516"></a><span class="lineno"> 3516</span>&#160;</div><div class="line"><a name="l03517"></a><span class="lineno"> 3517</span>&#160;The **address of** `p` is passed, so the serializer can determine whether</div><div class="line"><a name="l03518"></a><span class="lineno"> 3518</span>&#160;`p` was already serialized and to discover co-referenced objects and cycles in graph data structures that require SOAP encoding with id-ref serialization.</div><div class="line"><a name="l03519"></a><span class="lineno"> 3519</span>&#160;To generate the output, the address of `p` is passed to the function</div><div class="line"><a name="l03520"></a><span class="lineno"> 3520</span>&#160;`soap_put_PointerTons__Person` together with the name of an XML element</div><div class="line"><a name="l03521"></a><span class="lineno"> 3521</span>&#160;and an optional type string (to omit a type, use `NULL`):</div><div class="line"><a name="l03522"></a><span class="lineno"> 3522</span>&#160;</div><div class="line"><a name="l03523"></a><span class="lineno"> 3523</span>&#160;```cpp</div><div class="line"><a name="l03524"></a><span class="lineno"> 3524</span>&#160;soap_begin_send(&amp;soap); </div><div class="line"><a name="l03525"></a><span class="lineno"> 3525</span>&#160;soap_put_PointerTons__Person(&amp;soap, &amp;p, &quot;ns:element-name&quot;, &quot;ns:type-name&quot;); </div><div class="line"><a name="l03526"></a><span class="lineno"> 3526</span>&#160;soap_end_send(&amp;soap);</div><div class="line"><a name="l03527"></a><span class="lineno"> 3527</span>&#160;```</div><div class="line"><a name="l03528"></a><span class="lineno"> 3528</span>&#160;</div><div class="line"><a name="l03529"></a><span class="lineno"> 3529</span>&#160;or the shorthand for the above (without the xsi type):</div><div class="line"><a name="l03530"></a><span class="lineno"> 3530</span>&#160;</div><div class="line"><a name="l03531"></a><span class="lineno"> 3531</span>&#160;```cpp</div><div class="line"><a name="l03532"></a><span class="lineno"> 3532</span>&#160;soap_write_PointerTons__Person(&amp;soap, &amp;p);</div><div class="line"><a name="l03533"></a><span class="lineno"> 3533</span>&#160;```</div><div class="line"><a name="l03534"></a><span class="lineno"> 3534</span>&#160;</div><div class="line"><a name="l03535"></a><span class="lineno"> 3535</span>&#160;This produces:</div><div class="line"><a name="l03536"></a><span class="lineno"> 3536</span>&#160;</div><div class="line"><a name="l03537"></a><span class="lineno"> 3537</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l03538"></a><span class="lineno"> 3538</span>&#160;```xml</div><div class="line"><a name="l03539"></a><span class="lineno"> 3539</span>&#160;&lt;ns:element-name xmlns:SOAP-ENV=&quot;...&quot; xmlns:SOAP-ENC=&quot;...&quot; xmlns:ns=&quot;...&quot; </div><div class="line"><a name="l03540"></a><span class="lineno"> 3540</span>&#160;   ... xsi:type=&quot;ns:type-name&quot;&gt; </div><div class="line"><a name="l03541"></a><span class="lineno"> 3541</span>&#160;&lt;name xsi:type=&quot;xsd:string&quot;&gt;...&lt;/name&gt; </div><div class="line"><a name="l03542"></a><span class="lineno"> 3542</span>&#160;&lt;/ns:element-name&gt;</div><div class="line"><a name="l03543"></a><span class="lineno"> 3543</span>&#160;```</div><div class="line"><a name="l03544"></a><span class="lineno"> 3544</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l03545"></a><span class="lineno"> 3545</span>&#160;</div><div class="line"><a name="l03546"></a><span class="lineno"> 3546</span>&#160;The serializer is initialized with the `soap_begin_send(soap)` function</div><div class="line"><a name="l03547"></a><span class="lineno"> 3547</span>&#160;and closed with `soap_end_send(soap)`. All temporary data structures and</div><div class="line"><a name="l03548"></a><span class="lineno"> 3548</span>&#160;data structures deserialized on the heap are destroyed with the</div><div class="line"><a name="l03549"></a><span class="lineno"> 3549</span>&#160;`soap_destroy` and `soap_end` functions (in this order).</div><div class="line"><a name="l03550"></a><span class="lineno"> 3550</span>&#160;</div><div class="line"><a name="l03551"></a><span class="lineno"> 3551</span>&#160;The `soap_done` function should be used to reset the context, i.e. the last use of the context. To detach and deallocate the context, use `soap_free`.</div><div class="line"><a name="l03552"></a><span class="lineno"> 3552</span>&#160;</div><div class="line"><a name="l03553"></a><span class="lineno"> 3553</span>&#160;To remove the temporary data only and keep the deserialized data on the heap, use `soap_free_temp`.</div><div class="line"><a name="l03554"></a><span class="lineno"> 3554</span>&#160;Temporary data structures are only created if the encoded data uses pointers.</div><div class="line"><a name="l03555"></a><span class="lineno"> 3555</span>&#160;Each pointer in the encoded data has an internal hash table entry to determine</div><div class="line"><a name="l03556"></a><span class="lineno"> 3556</span>&#160;all multi-reference parts and cyclic parts of the complete data structure.</div><div class="line"><a name="l03557"></a><span class="lineno"> 3557</span>&#160;</div><div class="line"><a name="l03558"></a><span class="lineno"> 3558</span>&#160;You can assign an</div><div class="line"><a name="l03559"></a><span class="lineno"> 3559</span>&#160;output stream in C++ to `soap.os` and in C an output string `soap.os`, or a file descriptor to `soap.sendfd`.</div><div class="line"><a name="l03560"></a><span class="lineno"> 3560</span>&#160;</div><div class="line"><a name="l03561"></a><span class="lineno"> 3561</span>&#160;For example, to assign a file descriptor:</div><div class="line"><a name="l03562"></a><span class="lineno"> 3562</span>&#160;</div><div class="line"><a name="l03563"></a><span class="lineno"> 3563</span>&#160;```cpp</div><div class="line"><a name="l03564"></a><span class="lineno"> 3564</span>&#160;soap.sendfd = open(file, O_RDWR|O_CREAT, S_IWUSR|S_IRUSR); </div><div class="line"><a name="l03565"></a><span class="lineno"> 3565</span>&#160;soap_serialize_PointerTons__Person(&amp;soap, &amp;p); </div><div class="line"><a name="l03566"></a><span class="lineno"> 3566</span>&#160;soap_begin_send(&amp;soap); </div><div class="line"><a name="l03567"></a><span class="lineno"> 3567</span>&#160;soap_put_PointerTons__Person(&amp;soap, &amp;p, &quot;ns:element-name&quot;, &quot;ns:type-name&quot;); </div><div class="line"><a name="l03568"></a><span class="lineno"> 3568</span>&#160;soap_end_send(&amp;soap);</div><div class="line"><a name="l03569"></a><span class="lineno"> 3569</span>&#160;```</div><div class="line"><a name="l03570"></a><span class="lineno"> 3570</span>&#160;</div><div class="line"><a name="l03571"></a><span class="lineno"> 3571</span>&#160;The above can be abbreviated to</div><div class="line"><a name="l03572"></a><span class="lineno"> 3572</span>&#160;</div><div class="line"><a name="l03573"></a><span class="lineno"> 3573</span>&#160;```cpp</div><div class="line"><a name="l03574"></a><span class="lineno"> 3574</span>&#160;soap.sendfd = open(file, O_RDWR|O_CREAT, S_IWUSR|S_IRUSR); </div><div class="line"><a name="l03575"></a><span class="lineno"> 3575</span>&#160;soap_write_PointerTons__Person(&amp;soap, &amp;p);</div><div class="line"><a name="l03576"></a><span class="lineno"> 3576</span>&#160;```</div><div class="line"><a name="l03577"></a><span class="lineno"> 3577</span>&#160;</div><div class="line"><a name="l03578"></a><span class="lineno"> 3578</span>&#160;The `soap_serialize` function is optional. It MUST be used when</div><div class="line"><a name="l03579"></a><span class="lineno"> 3579</span>&#160;the object graph contains cycles.</div><div class="line"><a name="l03580"></a><span class="lineno"> 3580</span>&#160;It MUST be called to preserve the logical coherence of pointer-based</div><div class="line"><a name="l03581"></a><span class="lineno"> 3581</span>&#160;data structures, where pointers may refer to co-referenced objects.</div><div class="line"><a name="l03582"></a><span class="lineno"> 3582</span>&#160;By calling `soap_serialize`, data structures shared through pointers are serialized only once and</div><div class="line"><a name="l03583"></a><span class="lineno"> 3583</span>&#160;referenced in XML using id-refs attributes.</div><div class="line"><a name="l03584"></a><span class="lineno"> 3584</span>&#160;The actual id-refs used depend on the SOAP encoding. To turn off SOAP encoding,</div><div class="line"><a name="l03585"></a><span class="lineno"> 3585</span>&#160;remove or avoid using the SOAP-ENV and SOAP-ENC namespace bindings in the namespace table.</div><div class="line"><a name="l03586"></a><span class="lineno"> 3586</span>&#160;In addition, the `SOAP_XML_TREE` and `SOAP_XML_GRAPH` flags can be used</div><div class="line"><a name="l03587"></a><span class="lineno"> 3587</span>&#160;to control the output by restricting serialization to XML trees or by enabling</div><div class="line"><a name="l03588"></a><span class="lineno"> 3588</span>&#160;multi-ref graph serialization with id-ref attribuation.</div><div class="line"><a name="l03589"></a><span class="lineno"> 3589</span>&#160;</div><div class="line"><a name="l03590"></a><span class="lineno"> 3590</span>&#160;To save the data as an XML tree (with one root) without any id-ref attributes, use the</div><div class="line"><a name="l03591"></a><span class="lineno"> 3591</span>&#160;`SOAP_XML_TREE` flag. The data structure MUST NOT contain pointer-based cycles.</div><div class="line"><a name="l03592"></a><span class="lineno"> 3592</span>&#160;</div><div class="line"><a name="l03593"></a><span class="lineno"> 3593</span>&#160;To preserve the exact structure of the data object graph and create XML with one root, use</div><div class="line"><a name="l03594"></a><span class="lineno"> 3594</span>&#160;the `SOAP_XML_GRAPH` output-mode flag (see</div><div class="line"><a name="l03595"></a><span class="lineno"> 3595</span>&#160;Section \ref flags ). Use this flag and the `soap_serialize` function</div><div class="line"><a name="l03596"></a><span class="lineno"> 3596</span>&#160;to prepare the serialization of data with in-line id-ref attributes.</div><div class="line"><a name="l03597"></a><span class="lineno"> 3597</span>&#160;Using the `SOAP_XML_GRAPH` flag assures the preservation of the logical structure of the data</div><div class="line"><a name="l03598"></a><span class="lineno"> 3598</span>&#160;</div><div class="line"><a name="l03599"></a><span class="lineno"> 3599</span>&#160;For example, to encode the contents of two variables `var1` and `var2`</div><div class="line"><a name="l03600"></a><span class="lineno"> 3600</span>&#160;that may share data through pointer structures,</div><div class="line"><a name="l03601"></a><span class="lineno"> 3601</span>&#160;the serializers are called before the output routines:</div><div class="line"><a name="l03602"></a><span class="lineno"> 3602</span>&#160;</div><div class="line"><a name="l03603"></a><span class="lineno"> 3603</span>&#160;```cpp</div><div class="line"><a name="l03604"></a><span class="lineno"> 3604</span>&#160;T1 var1; </div><div class="line"><a name="l03605"></a><span class="lineno"> 3605</span>&#160;T2 var2; </div><div class="line"><a name="l03606"></a><span class="lineno"> 3606</span>&#160;struct soap soap; </div><div class="line"><a name="l03607"></a><span class="lineno"> 3607</span>&#160;... </div><div class="line"><a name="l03608"></a><span class="lineno"> 3608</span>&#160;soap_init(&amp;soap); // initialize </div><div class="line"><a name="l03609"></a><span class="lineno"> 3609</span>&#160;[optional: soap_omode(&amp;soap, flags);] // set output-mode flags (e.g. SOAP_ENC_PLAIN|SOAP_ENC_ZLIB) </div><div class="line"><a name="l03610"></a><span class="lineno"> 3610</span>&#160;soap_begin(&amp;soap); // start new (de)serialization phase </div><div class="line"><a name="l03611"></a><span class="lineno"> 3611</span>&#160;soap_set_omode(&amp;soap, SOAP_XML_GRAPH); </div><div class="line"><a name="l03612"></a><span class="lineno"> 3612</span>&#160;soap_serialize_Type1(&amp;soap, &amp;var1); </div><div class="line"><a name="l03613"></a><span class="lineno"> 3613</span>&#160;soap_serialize_Type2(&amp;soap, &amp;var2); </div><div class="line"><a name="l03614"></a><span class="lineno"> 3614</span>&#160;... </div><div class="line"><a name="l03615"></a><span class="lineno"> 3615</span>&#160;[optional: soap.socket = a_socket_file_descriptor;] // when using sockets </div><div class="line"><a name="l03616"></a><span class="lineno"> 3616</span>&#160;[optional: soap.os = an_output_stream;] // C++ </div><div class="line"><a name="l03617"></a><span class="lineno"> 3617</span>&#160;[optional: soap.sendfd = an_output_file_descriptor;] // C </div><div class="line"><a name="l03618"></a><span class="lineno"> 3618</span>&#160;soap_begin_send(&amp;soap); </div><div class="line"><a name="l03619"></a><span class="lineno"> 3619</span>&#160;soap_put_Type1(&amp;soap, &amp;var1, &quot;[optional: namespace-prefix:]element-name1&quot;, &quot;[optional: namespace-prefix:]type-name1&quot;); </div><div class="line"><a name="l03620"></a><span class="lineno"> 3620</span>&#160;soap_put_Type2(&amp;soap, &amp;var2, &quot;[optional: namespace-prefix:]element-name2&quot;, &quot;[optional: namespace-prefix:]type-name2&quot;); </div><div class="line"><a name="l03621"></a><span class="lineno"> 3621</span>&#160;... </div><div class="line"><a name="l03622"></a><span class="lineno"> 3622</span>&#160;soap_end_send(&amp;soap); // flush </div><div class="line"><a name="l03623"></a><span class="lineno"> 3623</span>&#160;soap_destroy(&amp;soap); // remove deserialized C++ objects </div><div class="line"><a name="l03624"></a><span class="lineno"> 3624</span>&#160;soap_end(&amp;soap); // remove deserialized data structures </div><div class="line"><a name="l03625"></a><span class="lineno"> 3625</span>&#160;soap_done(&amp;soap); // finalize last use of this context </div><div class="line"><a name="l03626"></a><span class="lineno"> 3626</span>&#160;...</div><div class="line"><a name="l03627"></a><span class="lineno"> 3627</span>&#160;```</div><div class="line"><a name="l03628"></a><span class="lineno"> 3628</span>&#160;</div><div class="line"><a name="l03629"></a><span class="lineno"> 3629</span>&#160;where Type1 is the type name of T1 and</div><div class="line"><a name="l03630"></a><span class="lineno"> 3630</span>&#160;Type2 is the type name of T2 (see table above).  The</div><div class="line"><a name="l03631"></a><span class="lineno"> 3631</span>&#160;strings `[optional: namespace-prefix:]type-name1` and</div><div class="line"><a name="l03632"></a><span class="lineno"> 3632</span>&#160;`[optional: namespace-prefix:]type-name2` describe the schema types of the</div><div class="line"><a name="l03633"></a><span class="lineno"> 3633</span>&#160;elements.  Use `NULL` to omit this type information.</div><div class="line"><a name="l03634"></a><span class="lineno"> 3634</span>&#160;</div><div class="line"><a name="l03635"></a><span class="lineno"> 3635</span>&#160;For serializing class instances, method invocations MUST be used instead of function calls, for example</div><div class="line"><a name="l03636"></a><span class="lineno"> 3636</span>&#160;`obj.soap_serialize(&amp;soap)` and `obj.soap_put(&amp;soap, &quot;elt&quot;, &quot;type&quot;)`.  This ensures that the proper serializers are used for</div><div class="line"><a name="l03637"></a><span class="lineno"> 3637</span>&#160;serializing instances of derived classes.</div><div class="line"><a name="l03638"></a><span class="lineno"> 3638</span>&#160;</div><div class="line"><a name="l03639"></a><span class="lineno"> 3639</span>&#160;You can serialize a class instance to a stream as follows:</div><div class="line"><a name="l03640"></a><span class="lineno"> 3640</span>&#160;</div><div class="line"><a name="l03641"></a><span class="lineno"> 3641</span>&#160;```cpp</div><div class="line"><a name="l03642"></a><span class="lineno"> 3642</span>&#160;struct soap soap; </div><div class="line"><a name="l03643"></a><span class="lineno"> 3643</span>&#160;myClass obj; </div><div class="line"><a name="l03644"></a><span class="lineno"> 3644</span>&#160;... populate obj </div><div class="line"><a name="l03645"></a><span class="lineno"> 3645</span>&#160;soap_init(&amp;soap); // initialize </div><div class="line"><a name="l03646"></a><span class="lineno"> 3646</span>&#160;soap_begin(&amp;soap); // start new (de)serialization phase </div><div class="line"><a name="l03647"></a><span class="lineno"> 3647</span>&#160;soap_set_omode(&amp;soap, SOAP_XML_GRAPH); </div><div class="line"><a name="l03648"></a><span class="lineno"> 3648</span>&#160;obj.serialize(&amp;soap); </div><div class="line"><a name="l03649"></a><span class="lineno"> 3649</span>&#160;soap.os = &amp;cout; // send to cout </div><div class="line"><a name="l03650"></a><span class="lineno"> 3650</span>&#160;soap_begin_send(&amp;soap); </div><div class="line"><a name="l03651"></a><span class="lineno"> 3651</span>&#160;obj.put(&amp;soap, &quot;[optional: namespace-prefix:]element-name1&quot;, &quot;[optional: namespace-prefix:]type-name1&quot;); </div><div class="line"><a name="l03652"></a><span class="lineno"> 3652</span>&#160;soap_end_send(&amp;soap); // flush </div><div class="line"><a name="l03653"></a><span class="lineno"> 3653</span>&#160;... </div><div class="line"><a name="l03654"></a><span class="lineno"> 3654</span>&#160;soap_destroy(&amp;soap); // remove deserialized C++ objects </div><div class="line"><a name="l03655"></a><span class="lineno"> 3655</span>&#160;soap_end(&amp;soap); // remove deserialized data </div><div class="line"><a name="l03656"></a><span class="lineno"> 3656</span>&#160;soap_done(&amp;soap); // finalize last use of this context</div><div class="line"><a name="l03657"></a><span class="lineno"> 3657</span>&#160;```</div><div class="line"><a name="l03658"></a><span class="lineno"> 3658</span>&#160;</div><div class="line"><a name="l03659"></a><span class="lineno"> 3659</span>&#160;For gSOAP 2.8.28 and later, in C we use `soap.os` to obtain a string with the XML serialized data:</div><div class="line"><a name="l03660"></a><span class="lineno"> 3660</span>&#160;</div><div class="line"><a name="l03661"></a><span class="lineno"> 3661</span>&#160;```cpp</div><div class="line"><a name="l03662"></a><span class="lineno"> 3662</span>&#160;struct soap soap; </div><div class="line"><a name="l03663"></a><span class="lineno"> 3663</span>&#160;struct myClass obj; </div><div class="line"><a name="l03664"></a><span class="lineno"> 3664</span>&#160;const char *out; </div><div class="line"><a name="l03665"></a><span class="lineno"> 3665</span>&#160;... populate obj </div><div class="line"><a name="l03666"></a><span class="lineno"> 3666</span>&#160;soap_init(&amp;soap); // initialize </div><div class="line"><a name="l03667"></a><span class="lineno"> 3667</span>&#160;soap_begin(&amp;soap); // start new (de)serialization phase </div><div class="line"><a name="l03668"></a><span class="lineno"> 3668</span>&#160;soap_set_omode(&amp;soap, SOAP_XML_GRAPH); </div><div class="line"><a name="l03669"></a><span class="lineno"> 3669</span>&#160;soap_serialize(&amp;soap, &amp;obj); </div><div class="line"><a name="l03670"></a><span class="lineno"> 3670</span>&#160;soap.os = &amp;out; // string to set </div><div class="line"><a name="l03671"></a><span class="lineno"> 3671</span>&#160;soap_begin_send(&amp;soap); </div><div class="line"><a name="l03672"></a><span class="lineno"> 3672</span>&#160;soap_put(&amp;soap, &amp;obj, &quot;[optional: namespace-prefix:]element-name1&quot;, &quot;[optional: namespace-prefix:]type-name1&quot;); </div><div class="line"><a name="l03673"></a><span class="lineno"> 3673</span>&#160;soap_end_send(&amp;soap); // flush </div><div class="line"><a name="l03674"></a><span class="lineno"> 3674</span>&#160;... // out has XML content string managed by context </div><div class="line"><a name="l03675"></a><span class="lineno"> 3675</span>&#160;soap.os = NULL; // stop sending to string </div><div class="line"><a name="l03676"></a><span class="lineno"> 3676</span>&#160;... </div><div class="line"><a name="l03677"></a><span class="lineno"> 3677</span>&#160;soap_end(&amp;soap); // remove deserialized data </div><div class="line"><a name="l03678"></a><span class="lineno"> 3678</span>&#160;soap_done(&amp;soap); // finalize last use of this context</div><div class="line"><a name="l03679"></a><span class="lineno"> 3679</span>&#160;```</div><div class="line"><a name="l03680"></a><span class="lineno"> 3680</span>&#160;</div><div class="line"><a name="l03681"></a><span class="lineno"> 3681</span>&#160;When you declare a soap struct pointer as a data member in a class, you can overload the &lt;&lt; operator to serialize the class to streams:</div><div class="line"><a name="l03682"></a><span class="lineno"> 3682</span>&#160;</div><div class="line"><a name="l03683"></a><span class="lineno"> 3683</span>&#160;```cpp</div><div class="line"><a name="l03684"></a><span class="lineno"> 3684</span>&#160;ostream &amp;operator&lt;&lt;(ostream &amp;o, const myClass &amp;e) </div><div class="line"><a name="l03685"></a><span class="lineno"> 3685</span>&#160;{ </div><div class="line"><a name="l03686"></a><span class="lineno"> 3686</span>&#160;   if (!e.soap) </div><div class="line"><a name="l03687"></a><span class="lineno"> 3687</span>&#160;   ... error: need a soap struct to serialize (could use global struct) ... </div><div class="line"><a name="l03688"></a><span class="lineno"> 3688</span>&#160;   else </div><div class="line"><a name="l03689"></a><span class="lineno"> 3689</span>&#160;   { </div><div class="line"><a name="l03690"></a><span class="lineno"> 3690</span>&#160;     ostream *os = e.soap-&gt;os; </div><div class="line"><a name="l03691"></a><span class="lineno"> 3691</span>&#160;     e.soap-&gt;os = &amp;o; </div><div class="line"><a name="l03692"></a><span class="lineno"> 3692</span>&#160;     soap_set_omode(e.soap, SOAP_XML_GRAPH);</div><div class="line"><a name="l03693"></a><span class="lineno"> 3693</span>&#160;     e.serialize(e.soap); </div><div class="line"><a name="l03694"></a><span class="lineno"> 3694</span>&#160;     soap_begin_send(e.soap); </div><div class="line"><a name="l03695"></a><span class="lineno"> 3695</span>&#160;     e.put(e.soap, &quot;myClass&quot;, NULL); </div><div class="line"><a name="l03696"></a><span class="lineno"> 3696</span>&#160;     soap_end_send(e.soap); </div><div class="line"><a name="l03697"></a><span class="lineno"> 3697</span>&#160;     e.soap-&gt;os = os; </div><div class="line"><a name="l03698"></a><span class="lineno"> 3698</span>&#160;     soap_clr_omode(e.soap, SOAP_XML_GRAPH); </div><div class="line"><a name="l03699"></a><span class="lineno"> 3699</span>&#160;   } </div><div class="line"><a name="l03700"></a><span class="lineno"> 3700</span>&#160;   return o; </div><div class="line"><a name="l03701"></a><span class="lineno"> 3701</span>&#160;}</div><div class="line"><a name="l03702"></a><span class="lineno"> 3702</span>&#160;```</div><div class="line"><a name="l03703"></a><span class="lineno"> 3703</span>&#160;</div><div class="line"><a name="l03704"></a><span class="lineno"> 3704</span>&#160;Of course, when you construct an instance you must set its soap struct to a valid context.  Deserialized class instances with a soap struct data member will have their soap structs set automatically, see Section \ref classmemory .</div><div class="line"><a name="l03705"></a><span class="lineno"> 3705</span>&#160;</div><div class="line"><a name="l03706"></a><span class="lineno"> 3706</span>&#160;In principle, XML output for a data structure can be produced with `soap_put`</div><div class="line"><a name="l03707"></a><span class="lineno"> 3707</span>&#160;without calling the `soap_serialize` function first.</div><div class="line"><a name="l03708"></a><span class="lineno"> 3708</span>&#160;In this case, the result is similar to `SOAP_XML_TREE` which</div><div class="line"><a name="l03709"></a><span class="lineno"> 3709</span>&#160;means that no id-refs are output. Cycles in the data structure will crash the serialization</div><div class="line"><a name="l03710"></a><span class="lineno"> 3710</span>&#160;algorithm, even when the `SOAP_XML_GRAPH` is set.</div><div class="line"><a name="l03711"></a><span class="lineno"> 3711</span>&#160;</div><div class="line"><a name="l03712"></a><span class="lineno"> 3712</span>&#160;Consider the following `struct`:</div><div class="line"><a name="l03713"></a><span class="lineno"> 3713</span>&#160;</div><div class="line"><a name="l03714"></a><span class="lineno"> 3714</span>&#160;```cpp</div><div class="line"><a name="l03715"></a><span class="lineno"> 3715</span>&#160;// Contents of file &quot;tricky.h&quot;: </div><div class="line"><a name="l03716"></a><span class="lineno"> 3716</span>&#160;struct Tricky</div><div class="line"><a name="l03717"></a><span class="lineno"> 3717</span>&#160;{ </div><div class="line"><a name="l03718"></a><span class="lineno"> 3718</span>&#160;   int *p; </div><div class="line"><a name="l03719"></a><span class="lineno"> 3719</span>&#160;   int n; </div><div class="line"><a name="l03720"></a><span class="lineno"> 3720</span>&#160;   int *q; </div><div class="line"><a name="l03721"></a><span class="lineno"> 3721</span>&#160;};</div><div class="line"><a name="l03722"></a><span class="lineno"> 3722</span>&#160;```</div><div class="line"><a name="l03723"></a><span class="lineno"> 3723</span>&#160;</div><div class="line"><a name="l03724"></a><span class="lineno"> 3724</span>&#160;The following fragment initializes the pointer fields `p` and `q` to the value of field `n`:</div><div class="line"><a name="l03725"></a><span class="lineno"> 3725</span>&#160;</div><div class="line"><a name="l03726"></a><span class="lineno"> 3726</span>&#160;```cpp</div><div class="line"><a name="l03727"></a><span class="lineno"> 3727</span>&#160;struct soap soap; </div><div class="line"><a name="l03728"></a><span class="lineno"> 3728</span>&#160;struct Tricky X; </div><div class="line"><a name="l03729"></a><span class="lineno"> 3729</span>&#160;X.n = 1; </div><div class="line"><a name="l03730"></a><span class="lineno"> 3730</span>&#160;X.p = &amp;X.n; </div><div class="line"><a name="l03731"></a><span class="lineno"> 3731</span>&#160;X.q = &amp;X.n; </div><div class="line"><a name="l03732"></a><span class="lineno"> 3732</span>&#160;soap_init(&amp;soap); </div><div class="line"><a name="l03733"></a><span class="lineno"> 3733</span>&#160;soap_begin(&amp;soap); </div><div class="line"><a name="l03734"></a><span class="lineno"> 3734</span>&#160;soap_serialize_Tricky(&amp;soap, &amp;X); </div><div class="line"><a name="l03735"></a><span class="lineno"> 3735</span>&#160;soap_put_Tricky(&amp;soap, &amp;X, &quot;Tricky&quot;, NULL); </div><div class="line"><a name="l03736"></a><span class="lineno"> 3736</span>&#160;soap_end(&amp;soap); // Clean up temporary data used by the serializer</div><div class="line"><a name="l03737"></a><span class="lineno"> 3737</span>&#160;```</div><div class="line"><a name="l03738"></a><span class="lineno"> 3738</span>&#160;</div><div class="line"><a name="l03739"></a><span class="lineno"> 3739</span>&#160;What is special about this data structure is that `n` is &#39;fixed&#39; in the `Tricky` structure, and `p` and `q` both point to `n`. The gSOAP serializers strategically place the id-ref attributes such that `n` will be identified as the primary data source, while `p` and `q` are serialized with ref/href attributes.</div><div class="line"><a name="l03740"></a><span class="lineno"> 3740</span>&#160;</div><div class="line"><a name="l03741"></a><span class="lineno"> 3741</span>&#160;The resulting output is:</div><div class="line"><a name="l03742"></a><span class="lineno"> 3742</span>&#160;</div><div class="line"><a name="l03743"></a><span class="lineno"> 3743</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l03744"></a><span class="lineno"> 3744</span>&#160;```xml</div><div class="line"><a name="l03745"></a><span class="lineno"> 3745</span>&#160;&lt;Tricky xsi:type=&quot;Tricky&quot;&gt; </div><div class="line"><a name="l03746"></a><span class="lineno"> 3746</span>&#160;&lt;p href=&quot;#2&quot;/&gt;</div><div class="line"><a name="l03747"></a><span class="lineno"> 3747</span>&#160;&lt;n xsi:type=&quot;int&quot;&gt;1&lt;/n&gt;</div><div class="line"><a name="l03748"></a><span class="lineno"> 3748</span>&#160;&lt;q href=&quot;#2&quot;/&gt;</div><div class="line"><a name="l03749"></a><span class="lineno"> 3749</span>&#160;&lt;r xsi:type=&quot;int&quot;&gt;2&lt;/r&gt;</div><div class="line"><a name="l03750"></a><span class="lineno"> 3750</span>&#160;&lt;/Tricky&gt;</div><div class="line"><a name="l03751"></a><span class="lineno"> 3751</span>&#160;&lt;id id=&quot;2&quot; xsi:type=&quot;int&quot;&gt;1&lt;/id&gt;</div><div class="line"><a name="l03752"></a><span class="lineno"> 3752</span>&#160;```</div><div class="line"><a name="l03753"></a><span class="lineno"> 3753</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l03754"></a><span class="lineno"> 3754</span>&#160;</div><div class="line"><a name="l03755"></a><span class="lineno"> 3755</span>&#160;which uses an independent element at the end to represent the multi-referenced integer, assuming the `SOAP-ENV` and `SOAP-ENC` namespaces indicate SOAP 1.1 encoding.</div><div class="line"><a name="l03756"></a><span class="lineno"> 3756</span>&#160;</div><div class="line"><a name="l03757"></a><span class="lineno"> 3757</span>&#160;With the `SOAP_XML_GRAPH` flag the output is:</div><div class="line"><a name="l03758"></a><span class="lineno"> 3758</span>&#160;</div><div class="line"><a name="l03759"></a><span class="lineno"> 3759</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l03760"></a><span class="lineno"> 3760</span>&#160;```xml</div><div class="line"><a name="l03761"></a><span class="lineno"> 3761</span>&#160;&lt;Tricky xsi:type=&quot;Tricky&quot;&gt; </div><div class="line"><a name="l03762"></a><span class="lineno"> 3762</span>&#160;&lt;p href=&quot;#2&quot;/&gt;</div><div class="line"><a name="l03763"></a><span class="lineno"> 3763</span>&#160;&lt;n id=&quot;2&quot; xsi:type=&quot;int&quot;&gt;1&lt;/n&gt;</div><div class="line"><a name="l03764"></a><span class="lineno"> 3764</span>&#160;&lt;q href=&quot;#2&quot;/&gt;</div><div class="line"><a name="l03765"></a><span class="lineno"> 3765</span>&#160;&lt;/Tricky&gt;</div><div class="line"><a name="l03766"></a><span class="lineno"> 3766</span>&#160;```</div><div class="line"><a name="l03767"></a><span class="lineno"> 3767</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l03768"></a><span class="lineno"> 3768</span>&#160;</div><div class="line"><a name="l03769"></a><span class="lineno"> 3769</span>&#160;In this case, the XML is self-contained and multi-referenced data is accurately serialized.</div><div class="line"><a name="l03770"></a><span class="lineno"> 3770</span>&#160;The gSOAP generated deserializer for this data type will be able to accurately reconstruct the data from the XML (on the heap).</div><div class="line"><a name="l03771"></a><span class="lineno"> 3771</span>&#160;</div><div class="line"><a name="l03772"></a><span class="lineno"> 3772</span>&#160;### Deserializing C/C++ Data from XML        {#deserialize}</div><div class="line"><a name="l03773"></a><span class="lineno"> 3773</span>&#160;</div><div class="line"><a name="l03774"></a><span class="lineno"> 3774</span>&#160;We assume that the `wsdl2h` tool was used to map XML schema types to C/C++ data types. The `soapcpp2` tool then generates the (de)serializers for the C/C++ types. You can also use `soapcpp2` directly on a header file that declares annotated C/C++ data types to serialize.</div><div class="line"><a name="l03775"></a><span class="lineno"> 3775</span>&#160;</div><div class="line"><a name="l03776"></a><span class="lineno"> 3776</span>&#160;To deserialize a data type from XML, the `soap_get` (or the simpler `soap_read`) function for the data type to be deserialized is used. The outline of a program that deserializes two variables `var1` and `var2` is for example:</div><div class="line"><a name="l03777"></a><span class="lineno"> 3777</span>&#160;</div><div class="line"><a name="l03778"></a><span class="lineno"> 3778</span>&#160;```cpp</div><div class="line"><a name="l03779"></a><span class="lineno"> 3779</span>&#160;T1 var1; </div><div class="line"><a name="l03780"></a><span class="lineno"> 3780</span>&#160;T2 var2; </div><div class="line"><a name="l03781"></a><span class="lineno"> 3781</span>&#160;struct soap soap; </div><div class="line"><a name="l03782"></a><span class="lineno"> 3782</span>&#160;... </div><div class="line"><a name="l03783"></a><span class="lineno"> 3783</span>&#160;soap_init(&amp;soap); // initialize at least once </div><div class="line"><a name="l03784"></a><span class="lineno"> 3784</span>&#160;[optional: soap_imode(&amp;soap, flags);] // set input-mode flags </div><div class="line"><a name="l03785"></a><span class="lineno"> 3785</span>&#160;soap_begin(&amp;soap); // begin new decoding phase </div><div class="line"><a name="l03786"></a><span class="lineno"> 3786</span>&#160;[optional: soap.is = an_input_stream;] // C++ </div><div class="line"><a name="l03787"></a><span class="lineno"> 3787</span>&#160;[optional: soap.recvfd = an_input_file_desriptpr;] // C </div><div class="line"><a name="l03788"></a><span class="lineno"> 3788</span>&#160;soap_begin_recv(&amp;soap); // if HTTP/MIME/DIME/GZIP headers are present, parse them </div><div class="line"><a name="l03789"></a><span class="lineno"> 3789</span>&#160;if (!soap_get_Type1(&amp;soap, &amp;var1, &quot;[optional: namespace-prefix:]element-name1&quot;, &quot;[optional: namespace-prefix:]type-name1&quot;)) </div><div class="line"><a name="l03790"></a><span class="lineno"> 3790</span>&#160;   ... error ... </div><div class="line"><a name="l03791"></a><span class="lineno"> 3791</span>&#160;if (!soap_get_Type2(&amp;soap, &amp;var2, &quot;[optional: namespace-prefix:]element-name2&quot;, &quot;[optional: namespace-prefix:]type-name1&quot;)) </div><div class="line"><a name="l03792"></a><span class="lineno"> 3792</span>&#160;   ... error ... </div><div class="line"><a name="l03793"></a><span class="lineno"> 3793</span>&#160;... </div><div class="line"><a name="l03794"></a><span class="lineno"> 3794</span>&#160;soap_end_recv(&amp;soap); // check consistency of id/hrefs </div><div class="line"><a name="l03795"></a><span class="lineno"> 3795</span>&#160;soap_destroy(&amp;soap); // remove deserialized C++ objects </div><div class="line"><a name="l03796"></a><span class="lineno"> 3796</span>&#160;soap_end(&amp;soap); // remove deserialized data </div><div class="line"><a name="l03797"></a><span class="lineno"> 3797</span>&#160;soap_done(&amp;soap); // finalize last use of the context</div><div class="line"><a name="l03798"></a><span class="lineno"> 3798</span>&#160;```</div><div class="line"><a name="l03799"></a><span class="lineno"> 3799</span>&#160;</div><div class="line"><a name="l03800"></a><span class="lineno"> 3800</span>&#160;The strings `[optional: namespace-prefix:`type-name1] and</div><div class="line"><a name="l03801"></a><span class="lineno"> 3801</span>&#160;`[optional: namespace-prefix:`type-name2] are the schema types of the elements</div><div class="line"><a name="l03802"></a><span class="lineno"> 3802</span>&#160;and should match the *`xsi:type`* attribute of the receiving message. To omit</div><div class="line"><a name="l03803"></a><span class="lineno"> 3803</span>&#160;the match, use `NULL` as the type.  For class instances, method invocation</div><div class="line"><a name="l03804"></a><span class="lineno"> 3804</span>&#160;can be used instead of a function call if the object is already instantiated,</div><div class="line"><a name="l03805"></a><span class="lineno"> 3805</span>&#160;i.e. `obj.soap_get(&amp;soap, &quot;...&quot;, &quot;...&quot;)`.</div><div class="line"><a name="l03806"></a><span class="lineno"> 3806</span>&#160;</div><div class="line"><a name="l03807"></a><span class="lineno"> 3807</span>&#160;The `soap_begin` call resets the deserializers. The `soap_destroy`</div><div class="line"><a name="l03808"></a><span class="lineno"> 3808</span>&#160;and `soap_end` calls remove the temporary data structures **and** the</div><div class="line"><a name="l03809"></a><span class="lineno"> 3809</span>&#160;decoded data that was placed on the heap.</div><div class="line"><a name="l03810"></a><span class="lineno"> 3810</span>&#160;</div><div class="line"><a name="l03811"></a><span class="lineno"> 3811</span>&#160;To remove temporary data while retaining the deserialized data on the heap, the</div><div class="line"><a name="l03812"></a><span class="lineno"> 3812</span>&#160;function `soap_free_temp` should be called instead of `soap_destroy` and</div><div class="line"><a name="l03813"></a><span class="lineno"> 3813</span>&#160;`soap_end`.</div><div class="line"><a name="l03814"></a><span class="lineno"> 3814</span>&#160;</div><div class="line"><a name="l03815"></a><span class="lineno"> 3815</span>&#160;One call to the `soap_get_Type` function of a type `Type` scans the</div><div class="line"><a name="l03816"></a><span class="lineno"> 3816</span>&#160;entire input to process its XML content and to capture SOAP 1.1 independent</div><div class="line"><a name="l03817"></a><span class="lineno"> 3817</span>&#160;elements (which contain multi-referenced objects). As a result, `soap.error` will set to `SOAP_EOF`.</div><div class="line"><a name="l03818"></a><span class="lineno"> 3818</span>&#160;Also storing</div><div class="line"><a name="l03819"></a><span class="lineno"> 3819</span>&#160;multiple objects into one file will fail to decode them properly with multiple `soap_get` calls. A well-formed XML document should</div><div class="line"><a name="l03820"></a><span class="lineno"> 3820</span>&#160;only have one root anyway, so don&#39;t save multiple objects into one file. If you</div><div class="line"><a name="l03821"></a><span class="lineno"> 3821</span>&#160;must save multiple objects, create a linked list or an array of objects and save</div><div class="line"><a name="l03822"></a><span class="lineno"> 3822</span>&#160;the linked list or array. You could use the `soap_in_Type` function instead of the `soap_get_Type` function. The `soap_in_Type` function parses one XML element at a time.</div><div class="line"><a name="l03823"></a><span class="lineno"> 3823</span>&#160;</div><div class="line"><a name="l03824"></a><span class="lineno"> 3824</span>&#160;You can deserialize class instances from a stream as follows:</div><div class="line"><a name="l03825"></a><span class="lineno"> 3825</span>&#160;</div><div class="line"><a name="l03826"></a><span class="lineno"> 3826</span>&#160;```cpp</div><div class="line"><a name="l03827"></a><span class="lineno"> 3827</span>&#160;myClass obj; </div><div class="line"><a name="l03828"></a><span class="lineno"> 3828</span>&#160;struct soap soap; </div><div class="line"><a name="l03829"></a><span class="lineno"> 3829</span>&#160;soap_init(&amp;soap); // initialize </div><div class="line"><a name="l03830"></a><span class="lineno"> 3830</span>&#160;soap.is = &amp;cin; // read from cin </div><div class="line"><a name="l03831"></a><span class="lineno"> 3831</span>&#160;soap_begin_recv(&amp;soap); // if HTTP header is present, parse it </div><div class="line"><a name="l03832"></a><span class="lineno"> 3832</span>&#160;if (soap_get_myClass(&amp;soap, &amp;obj, &quot;myClass&quot;, NULL) == NULL) </div><div class="line"><a name="l03833"></a><span class="lineno"> 3833</span>&#160;   ... error ... </div><div class="line"><a name="l03834"></a><span class="lineno"> 3834</span>&#160;soap_end_recv(&amp;soap); // check consistency of id/hrefs </div><div class="line"><a name="l03835"></a><span class="lineno"> 3835</span>&#160;... </div><div class="line"><a name="l03836"></a><span class="lineno"> 3836</span>&#160;soap_destroy(&amp;soap); // remove deserialized C++ objects </div><div class="line"><a name="l03837"></a><span class="lineno"> 3837</span>&#160;soap_end(&amp;soap); // remove deserialized data </div><div class="line"><a name="l03838"></a><span class="lineno"> 3838</span>&#160;soap_done(&amp;soap); // finalize last use of the context</div><div class="line"><a name="l03839"></a><span class="lineno"> 3839</span>&#160;```</div><div class="line"><a name="l03840"></a><span class="lineno"> 3840</span>&#160;</div><div class="line"><a name="l03841"></a><span class="lineno"> 3841</span>&#160;This can be abbreviated to:</div><div class="line"><a name="l03842"></a><span class="lineno"> 3842</span>&#160;</div><div class="line"><a name="l03843"></a><span class="lineno"> 3843</span>&#160;```cpp</div><div class="line"><a name="l03844"></a><span class="lineno"> 3844</span>&#160;myClass obj; </div><div class="line"><a name="l03845"></a><span class="lineno"> 3845</span>&#160;struct soap soap; </div><div class="line"><a name="l03846"></a><span class="lineno"> 3846</span>&#160;soap_init(&amp;soap); // initialize </div><div class="line"><a name="l03847"></a><span class="lineno"> 3847</span>&#160;soap.is = &amp;cin; // read from cin </div><div class="line"><a name="l03848"></a><span class="lineno"> 3848</span>&#160;if (soap_read_myClass(&amp;soap, &amp;obj, NULL) != SOAP_OK) </div><div class="line"><a name="l03849"></a><span class="lineno"> 3849</span>&#160;   ... error ... </div><div class="line"><a name="l03850"></a><span class="lineno"> 3850</span>&#160;... </div><div class="line"><a name="l03851"></a><span class="lineno"> 3851</span>&#160;soap_destroy(&amp;soap); // remove deserialized C++ objects </div><div class="line"><a name="l03852"></a><span class="lineno"> 3852</span>&#160;soap_end(&amp;soap); // remove deserialized data </div><div class="line"><a name="l03853"></a><span class="lineno"> 3853</span>&#160;soap_done(&amp;soap); // finalize last use of the context</div><div class="line"><a name="l03854"></a><span class="lineno"> 3854</span>&#160;```</div><div class="line"><a name="l03855"></a><span class="lineno"> 3855</span>&#160;</div><div class="line"><a name="l03856"></a><span class="lineno"> 3856</span>&#160;When declaring a soap struct pointer as a data member in a class, you can overload the &gt;&gt; operator to parse and deserialize a class instance from a stream:</div><div class="line"><a name="l03857"></a><span class="lineno"> 3857</span>&#160;</div><div class="line"><a name="l03858"></a><span class="lineno"> 3858</span>&#160;```cpp</div><div class="line"><a name="l03859"></a><span class="lineno"> 3859</span>&#160;istream &amp;operator&gt;&gt;(istream &amp;i, myClass &amp;e) </div><div class="line"><a name="l03860"></a><span class="lineno"> 3860</span>&#160;{ </div><div class="line"><a name="l03861"></a><span class="lineno"> 3861</span>&#160;   if (!e.soap) </div><div class="line"><a name="l03862"></a><span class="lineno"> 3862</span>&#160;   ... error: need soap struct to deserialize (could use global struct)... </div><div class="line"><a name="l03863"></a><span class="lineno"> 3863</span>&#160;   istream *is = e.soap-&gt;is; </div><div class="line"><a name="l03864"></a><span class="lineno"> 3864</span>&#160;   e.soap-&gt;is = &amp;i; </div><div class="line"><a name="l03865"></a><span class="lineno"> 3865</span>&#160;   if (soap_read_myClass(e.soap, &amp;e) != SOAP_OK) </div><div class="line"><a name="l03866"></a><span class="lineno"> 3866</span>&#160;     ... error ... </div><div class="line"><a name="l03867"></a><span class="lineno"> 3867</span>&#160;   e.soap-&gt;is = is; </div><div class="line"><a name="l03868"></a><span class="lineno"> 3868</span>&#160;   return i; </div><div class="line"><a name="l03869"></a><span class="lineno"> 3869</span>&#160;}</div><div class="line"><a name="l03870"></a><span class="lineno"> 3870</span>&#160;```</div><div class="line"><a name="l03871"></a><span class="lineno"> 3871</span>&#160;</div><div class="line"><a name="l03872"></a><span class="lineno"> 3872</span>&#160;For gSOAP 2.8.28 and later, you can parse XML from strings as follows:</div><div class="line"><a name="l03873"></a><span class="lineno"> 3873</span>&#160;</div><div class="line"><a name="l03874"></a><span class="lineno"> 3874</span>&#160;```cpp</div><div class="line"><a name="l03875"></a><span class="lineno"> 3875</span>&#160;struct myClass obj; </div><div class="line"><a name="l03876"></a><span class="lineno"> 3876</span>&#160;struct soap soap; </div><div class="line"><a name="l03877"></a><span class="lineno"> 3877</span>&#160;soap_init(&amp;soap); // initialize </div><div class="line"><a name="l03878"></a><span class="lineno"> 3878</span>&#160;soap.is = &quot;...&quot;; // this is the string with XML to parse </div><div class="line"><a name="l03879"></a><span class="lineno"> 3879</span>&#160;if (soap_read_myClass(&amp;soap, &amp;obj, NULL) != SOAP_OK) </div><div class="line"><a name="l03880"></a><span class="lineno"> 3880</span>&#160;   ... error ... </div><div class="line"><a name="l03881"></a><span class="lineno"> 3881</span>&#160;soap.is = NULL; // stop parsing from strings </div><div class="line"><a name="l03882"></a><span class="lineno"> 3882</span>&#160;... </div><div class="line"><a name="l03883"></a><span class="lineno"> 3883</span>&#160;soap_end(&amp;soap); // remove deserialized data </div><div class="line"><a name="l03884"></a><span class="lineno"> 3884</span>&#160;soap_done(&amp;soap); // finalize last use of the context</div><div class="line"><a name="l03885"></a><span class="lineno"> 3885</span>&#160;```</div><div class="line"><a name="l03886"></a><span class="lineno"> 3886</span>&#160;</div><div class="line"><a name="l03887"></a><span class="lineno"> 3887</span>&#160;When declaring a soap struct pointer as a data member in a class, you can overload the &gt;&gt; operator to parse and deserialize a class instance from a stream or string stream:</div><div class="line"><a name="l03888"></a><span class="lineno"> 3888</span>&#160;</div><div class="line"><a name="l03889"></a><span class="lineno"> 3889</span>&#160;```cpp</div><div class="line"><a name="l03890"></a><span class="lineno"> 3890</span>&#160;istream &amp;operator&gt;&gt;(istream &amp;i, myClass &amp;e) </div><div class="line"><a name="l03891"></a><span class="lineno"> 3891</span>&#160;{ </div><div class="line"><a name="l03892"></a><span class="lineno"> 3892</span>&#160;   if (!e.soap) </div><div class="line"><a name="l03893"></a><span class="lineno"> 3893</span>&#160;   ... error: need soap struct to deserialize (could use global struct)... </div><div class="line"><a name="l03894"></a><span class="lineno"> 3894</span>&#160;   istream *is = e.soap-&gt;is; </div><div class="line"><a name="l03895"></a><span class="lineno"> 3895</span>&#160;   e.soap-&gt;is = &amp;i; </div><div class="line"><a name="l03896"></a><span class="lineno"> 3896</span>&#160;   if (soap_read_myClass(e.soap, &amp;e) != SOAP_OK) </div><div class="line"><a name="l03897"></a><span class="lineno"> 3897</span>&#160;     ... error ... </div><div class="line"><a name="l03898"></a><span class="lineno"> 3898</span>&#160;   e.soap-&gt;is = is; </div><div class="line"><a name="l03899"></a><span class="lineno"> 3899</span>&#160;   return i; </div><div class="line"><a name="l03900"></a><span class="lineno"> 3900</span>&#160;}</div><div class="line"><a name="l03901"></a><span class="lineno"> 3901</span>&#160;```</div><div class="line"><a name="l03902"></a><span class="lineno"> 3902</span>&#160;</div><div class="line"><a name="l03903"></a><span class="lineno"> 3903</span>&#160;### Example        {#example9}</div><div class="line"><a name="l03904"></a><span class="lineno"> 3904</span>&#160;</div><div class="line"><a name="l03905"></a><span class="lineno"> 3905</span>&#160;As an example, consider the following data type declarations:</div><div class="line"><a name="l03906"></a><span class="lineno"> 3906</span>&#160;</div><div class="line"><a name="l03907"></a><span class="lineno"> 3907</span>&#160;```cpp</div><div class="line"><a name="l03908"></a><span class="lineno"> 3908</span>&#160;// Contents of file &quot;person.h&quot;: </div><div class="line"><a name="l03909"></a><span class="lineno"> 3909</span>&#160;typedef char *xsd__string; </div><div class="line"><a name="l03910"></a><span class="lineno"> 3910</span>&#160;typedef char *xsd__Name; </div><div class="line"><a name="l03911"></a><span class="lineno"> 3911</span>&#160;typedef unsigned int xsd__unsignedInt; </div><div class="line"><a name="l03912"></a><span class="lineno"> 3912</span>&#160;enum ns__Gender {male, female}; </div><div class="line"><a name="l03913"></a><span class="lineno"> 3913</span>&#160;class ns__Address </div><div class="line"><a name="l03914"></a><span class="lineno"> 3914</span>&#160;{ </div><div class="line"><a name="l03915"></a><span class="lineno"> 3915</span>&#160;   public: </div><div class="line"><a name="l03916"></a><span class="lineno"> 3916</span>&#160;   xsd__string street; </div><div class="line"><a name="l03917"></a><span class="lineno"> 3917</span>&#160;   xsd__unsignedInt number; </div><div class="line"><a name="l03918"></a><span class="lineno"> 3918</span>&#160;   xsd__string city; </div><div class="line"><a name="l03919"></a><span class="lineno"> 3919</span>&#160;}; </div><div class="line"><a name="l03920"></a><span class="lineno"> 3920</span>&#160;class ns__Person </div><div class="line"><a name="l03921"></a><span class="lineno"> 3921</span>&#160;{ </div><div class="line"><a name="l03922"></a><span class="lineno"> 3922</span>&#160;   public: </div><div class="line"><a name="l03923"></a><span class="lineno"> 3923</span>&#160;   xsd__Name name; </div><div class="line"><a name="l03924"></a><span class="lineno"> 3924</span>&#160;   enum ns__Gender gender; </div><div class="line"><a name="l03925"></a><span class="lineno"> 3925</span>&#160;   ns__Address address; </div><div class="line"><a name="l03926"></a><span class="lineno"> 3926</span>&#160;   ns__Person *mother; </div><div class="line"><a name="l03927"></a><span class="lineno"> 3927</span>&#160;   ns__Person *father; </div><div class="line"><a name="l03928"></a><span class="lineno"> 3928</span>&#160;};</div><div class="line"><a name="l03929"></a><span class="lineno"> 3929</span>&#160;```</div><div class="line"><a name="l03930"></a><span class="lineno"> 3930</span>&#160;</div><div class="line"><a name="l03931"></a><span class="lineno"> 3931</span>&#160;The following program uses these data types to write to standard output a data structure that contains the data of a person named &quot;John&quot; living at Downing st. 10 in Londen. He has a mother</div><div class="line"><a name="l03932"></a><span class="lineno"> 3932</span>&#160;&quot;Mary&quot; and a father &quot;Stuart&quot;. After initialization, the class instance for &quot;John&quot; is serialized and encoded in XML to the</div><div class="line"><a name="l03933"></a><span class="lineno"> 3933</span>&#160;standard output stream using gzip compression (requires the Zlib library, compile sources with -DWITH_GZIP):</div><div class="line"><a name="l03934"></a><span class="lineno"> 3934</span>&#160;</div><div class="line"><a name="l03935"></a><span class="lineno"> 3935</span>&#160;```cpp</div><div class="line"><a name="l03936"></a><span class="lineno"> 3936</span>&#160;// Contents of file &quot;person.cpp&quot;: </div><div class="line"><a name="l03937"></a><span class="lineno"> 3937</span>&#160;#include &quot;soapH.h&quot; </div><div class="line"><a name="l03938"></a><span class="lineno"> 3938</span>&#160;int main() </div><div class="line"><a name="l03939"></a><span class="lineno"> 3939</span>&#160;{ </div><div class="line"><a name="l03940"></a><span class="lineno"> 3940</span>&#160;   struct soap soap; </div><div class="line"><a name="l03941"></a><span class="lineno"> 3941</span>&#160;   ns__Person mother, father, john; </div><div class="line"><a name="l03942"></a><span class="lineno"> 3942</span>&#160;   mother.name = &quot;Mary&quot;; </div><div class="line"><a name="l03943"></a><span class="lineno"> 3943</span>&#160;   mother.gender = female; </div><div class="line"><a name="l03944"></a><span class="lineno"> 3944</span>&#160;   mother.address.street = &quot;Downing st.&quot;; </div><div class="line"><a name="l03945"></a><span class="lineno"> 3945</span>&#160;   mother.address.number = 10; </div><div class="line"><a name="l03946"></a><span class="lineno"> 3946</span>&#160;   mother.address.city = &quot;London&quot;; </div><div class="line"><a name="l03947"></a><span class="lineno"> 3947</span>&#160;   mother.mother = NULL; </div><div class="line"><a name="l03948"></a><span class="lineno"> 3948</span>&#160;   mother.father = NULL; </div><div class="line"><a name="l03949"></a><span class="lineno"> 3949</span>&#160;   father.name = &quot;Stuart&quot;; </div><div class="line"><a name="l03950"></a><span class="lineno"> 3950</span>&#160;   father.gender = male; </div><div class="line"><a name="l03951"></a><span class="lineno"> 3951</span>&#160;   father.address.street = &quot;Main st.&quot;; </div><div class="line"><a name="l03952"></a><span class="lineno"> 3952</span>&#160;   father.address.number = 5; </div><div class="line"><a name="l03953"></a><span class="lineno"> 3953</span>&#160;   father.address.city = &quot;London&quot;; </div><div class="line"><a name="l03954"></a><span class="lineno"> 3954</span>&#160;   father.mother = NULL; </div><div class="line"><a name="l03955"></a><span class="lineno"> 3955</span>&#160;   father.father = NULL; </div><div class="line"><a name="l03956"></a><span class="lineno"> 3956</span>&#160;   john.name = &quot;John&quot;; </div><div class="line"><a name="l03957"></a><span class="lineno"> 3957</span>&#160;   john.gender = male; </div><div class="line"><a name="l03958"></a><span class="lineno"> 3958</span>&#160;   john.address = mother.address; </div><div class="line"><a name="l03959"></a><span class="lineno"> 3959</span>&#160;   john.mother = &amp;mother; </div><div class="line"><a name="l03960"></a><span class="lineno"> 3960</span>&#160;   john.father = &amp;father; </div><div class="line"><a name="l03961"></a><span class="lineno"> 3961</span>&#160;   soap_init(&amp;soap); </div><div class="line"><a name="l03962"></a><span class="lineno"> 3962</span>&#160;   soap_omode(&amp;soap, SOAP_ENC_ZLIB|SOAP_XML_GRAPH); // see \ref flags  </div><div class="line"><a name="l03963"></a><span class="lineno"> 3963</span>&#160;   soap_begin(&amp;soap); </div><div class="line"><a name="l03964"></a><span class="lineno"> 3964</span>&#160;   soap_begin_send(&amp;soap); </div><div class="line"><a name="l03965"></a><span class="lineno"> 3965</span>&#160;   john.soap_serialize(&amp;soap); </div><div class="line"><a name="l03966"></a><span class="lineno"> 3966</span>&#160;   john.soap_put(&amp;soap, &quot;johnnie&quot;, NULL); </div><div class="line"><a name="l03967"></a><span class="lineno"> 3967</span>&#160;   soap_end_send(&amp;soap); </div><div class="line"><a name="l03968"></a><span class="lineno"> 3968</span>&#160;   soap_destroy(&amp;soap); </div><div class="line"><a name="l03969"></a><span class="lineno"> 3969</span>&#160;   soap_end(&amp;soap); </div><div class="line"><a name="l03970"></a><span class="lineno"> 3970</span>&#160;   soap_done(&amp;soap); </div><div class="line"><a name="l03971"></a><span class="lineno"> 3971</span>&#160;} </div><div class="line"><a name="l03972"></a><span class="lineno"> 3972</span>&#160;struct Namespace namespaces[] = </div><div class="line"><a name="l03973"></a><span class="lineno"> 3973</span>&#160;{ </div><div class="line"><a name="l03974"></a><span class="lineno"> 3974</span>&#160;   {&quot;SOAP-ENV&quot;, &quot;http://schemas.xmlsoap.org/soap/envelope/&quot;}, </div><div class="line"><a name="l03975"></a><span class="lineno"> 3975</span>&#160;   {&quot;SOAP-ENC&quot;,&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;}, </div><div class="line"><a name="l03976"></a><span class="lineno"> 3976</span>&#160;   {&quot;xsi&quot;, &quot;http://www.w3.org/2001/XMLSchema-instance&quot;}, </div><div class="line"><a name="l03977"></a><span class="lineno"> 3977</span>&#160;   {&quot;xsd&quot;, &quot;http://www.w3.org/2001/XMLSchema&quot;}, </div><div class="line"><a name="l03978"></a><span class="lineno"> 3978</span>&#160;   {&quot;ns&quot;, &quot;urn:person&quot;}, // Namespace URI of the &quot;Person&quot; data type </div><div class="line"><a name="l03979"></a><span class="lineno"> 3979</span>&#160;   {NULL, NULL} </div><div class="line"><a name="l03980"></a><span class="lineno"> 3980</span>&#160;};</div><div class="line"><a name="l03981"></a><span class="lineno"> 3981</span>&#160;```</div><div class="line"><a name="l03982"></a><span class="lineno"> 3982</span>&#160;</div><div class="line"><a name="l03983"></a><span class="lineno"> 3983</span>&#160;The header file is processed and the application compiled on Linux/Unix with:</div><div class="line"><a name="l03984"></a><span class="lineno"> 3984</span>&#160;</div><div class="line"><a name="l03985"></a><span class="lineno"> 3985</span>&#160;    &gt; soapcpp2 person.h</div><div class="line"><a name="l03986"></a><span class="lineno"> 3986</span>&#160;    &gt; c++ -DWITH_GZIP -o person person.cpp soapC.cpp stdsoap2.cpp -lsocket -lxnet -lnsl -lz</div><div class="line"><a name="l03987"></a><span class="lineno"> 3987</span>&#160;</div><div class="line"><a name="l03988"></a><span class="lineno"> 3988</span>&#160;(Depending on your system configuration, the libraries `libsocket.a`,</div><div class="line"><a name="l03989"></a><span class="lineno"> 3989</span>&#160;`libxnet.a`, `libnsl.a`</div><div class="line"><a name="l03990"></a><span class="lineno"> 3990</span>&#160;are required. Compiling on Linux typically does not require the inclusion of those</div><div class="line"><a name="l03991"></a><span class="lineno"> 3991</span>&#160;libraries.)</div><div class="line"><a name="l03992"></a><span class="lineno"> 3992</span>&#160;See \ref compression  for details on compression with gSOAP.</div><div class="line"><a name="l03993"></a><span class="lineno"> 3993</span>&#160;</div><div class="line"><a name="l03994"></a><span class="lineno"> 3994</span>&#160;Running the `person` application results in the compressed XML output:</div><div class="line"><a name="l03995"></a><span class="lineno"> 3995</span>&#160;</div><div class="line"><a name="l03996"></a><span class="lineno"> 3996</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l03997"></a><span class="lineno"> 3997</span>&#160;```xml</div><div class="line"><a name="l03998"></a><span class="lineno"> 3998</span>&#160;&lt;johnnie xsi:type=&quot;ns:Person&quot; xmlns:SOAP-ENV=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; </div><div class="line"><a name="l03999"></a><span class="lineno"> 3999</span>&#160;   xmlns:SOAP-ENC=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot; </div><div class="line"><a name="l04000"></a><span class="lineno"> 4000</span>&#160;   xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; </div><div class="line"><a name="l04001"></a><span class="lineno"> 4001</span>&#160;   xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; </div><div class="line"><a name="l04002"></a><span class="lineno"> 4002</span>&#160;   xmlns:ns=&quot;urn:person&quot; </div><div class="line"><a name="l04003"></a><span class="lineno"> 4003</span>&#160;   SOAP-ENV:encodingStyle=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;&gt; </div><div class="line"><a name="l04004"></a><span class="lineno"> 4004</span>&#160;&lt;name xsi:type=&quot;xsd:Name&quot;&gt;John&lt;/name&gt; </div><div class="line"><a name="l04005"></a><span class="lineno"> 4005</span>&#160;&lt;gender xsi:type=&quot;ns:Gender&quot;&gt;male&lt;/gender&gt; </div><div class="line"><a name="l04006"></a><span class="lineno"> 4006</span>&#160;&lt;address xsi:type=&quot;ns:Address&quot;&gt; </div><div class="line"><a name="l04007"></a><span class="lineno"> 4007</span>&#160;&lt;street id=&quot;3&quot; xsi:type=&quot;xsd:string&quot;&gt;Dowling st.&lt;/street&gt; </div><div class="line"><a name="l04008"></a><span class="lineno"> 4008</span>&#160;&lt;number xsi:type=&quot;unsignedInt&quot;&gt;10&lt;/number&gt; </div><div class="line"><a name="l04009"></a><span class="lineno"> 4009</span>&#160;&lt;city id=&quot;4&quot; xsi:type=&quot;xsd:string&quot;&gt;London&lt;/city&gt; </div><div class="line"><a name="l04010"></a><span class="lineno"> 4010</span>&#160;&lt;/address&gt; </div><div class="line"><a name="l04011"></a><span class="lineno"> 4011</span>&#160;&lt;mother xsi:type=&quot;ns:Person&quot;&gt; </div><div class="line"><a name="l04012"></a><span class="lineno"> 4012</span>&#160;&lt;name xsi:type=&quot;xsd:Name&quot;&gt;Mary&lt;/name&gt; </div><div class="line"><a name="l04013"></a><span class="lineno"> 4013</span>&#160;&lt;gender xsi:type=&quot;ns:Gender&quot;&gt;female&lt;/gender&gt; </div><div class="line"><a name="l04014"></a><span class="lineno"> 4014</span>&#160;&lt;address xsi:type=&quot;ns:Address&quot;&gt; </div><div class="line"><a name="l04015"></a><span class="lineno"> 4015</span>&#160;&lt;street href=&quot;#3&quot;/&gt; </div><div class="line"><a name="l04016"></a><span class="lineno"> 4016</span>&#160;&lt;number xsi:type=&quot;unsignedInt&quot;&gt;5&lt;/number&gt; </div><div class="line"><a name="l04017"></a><span class="lineno"> 4017</span>&#160;&lt;city href=&quot;#4&quot;/&gt; </div><div class="line"><a name="l04018"></a><span class="lineno"> 4018</span>&#160;&lt;/address&gt; </div><div class="line"><a name="l04019"></a><span class="lineno"> 4019</span>&#160;&lt;/mother&gt; </div><div class="line"><a name="l04020"></a><span class="lineno"> 4020</span>&#160;&lt;father xsi:type=&quot;ns:Person&quot;&gt; </div><div class="line"><a name="l04021"></a><span class="lineno"> 4021</span>&#160;&lt;name xsi:type=&quot;xsd:Name&quot;&gt;Stuart&lt;/name&gt; </div><div class="line"><a name="l04022"></a><span class="lineno"> 4022</span>&#160;&lt;gender xsi:type=&quot;ns:Gender&quot;&gt;male&lt;/gender&gt; </div><div class="line"><a name="l04023"></a><span class="lineno"> 4023</span>&#160;&lt;address xsi:type=&quot;ns:Address&quot;&gt; </div><div class="line"><a name="l04024"></a><span class="lineno"> 4024</span>&#160;&lt;street xsi:type=&quot;xsd:string&quot;&gt;Main st.&lt;/street&gt; </div><div class="line"><a name="l04025"></a><span class="lineno"> 4025</span>&#160;&lt;number xsi:type=&quot;unsignedInt&quot;&gt;13&lt;/number&gt; </div><div class="line"><a name="l04026"></a><span class="lineno"> 4026</span>&#160;&lt;city href=&quot;#4&quot;/&gt; </div><div class="line"><a name="l04027"></a><span class="lineno"> 4027</span>&#160;&lt;/address&gt; </div><div class="line"><a name="l04028"></a><span class="lineno"> 4028</span>&#160;&lt;/father&gt; </div><div class="line"><a name="l04029"></a><span class="lineno"> 4029</span>&#160;&lt;/johnnie&gt;</div><div class="line"><a name="l04030"></a><span class="lineno"> 4030</span>&#160;```</div><div class="line"><a name="l04031"></a><span class="lineno"> 4031</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l04032"></a><span class="lineno"> 4032</span>&#160;</div><div class="line"><a name="l04033"></a><span class="lineno"> 4033</span>&#160;The following program fragment decodes this content from standard input and reconstructs the original data structure on the heap:</div><div class="line"><a name="l04034"></a><span class="lineno"> 4034</span>&#160;</div><div class="line"><a name="l04035"></a><span class="lineno"> 4035</span>&#160;```cpp</div><div class="line"><a name="l04036"></a><span class="lineno"> 4036</span>&#160;#include &quot;soapH.h&quot; </div><div class="line"><a name="l04037"></a><span class="lineno"> 4037</span>&#160;int main() </div><div class="line"><a name="l04038"></a><span class="lineno"> 4038</span>&#160;{ </div><div class="line"><a name="l04039"></a><span class="lineno"> 4039</span>&#160;   struct soap soap; </div><div class="line"><a name="l04040"></a><span class="lineno"> 4040</span>&#160;   ns__Person *mother, *father, *john = NULL; </div><div class="line"><a name="l04041"></a><span class="lineno"> 4041</span>&#160;   soap_init(&amp;soap); </div><div class="line"><a name="l04042"></a><span class="lineno"> 4042</span>&#160;   soap_imode(&amp;soap, SOAP_ENC_ZLIB); // optional: gzip is detected automatically </div><div class="line"><a name="l04043"></a><span class="lineno"> 4043</span>&#160;   soap_begin(&amp;soap); </div><div class="line"><a name="l04044"></a><span class="lineno"> 4044</span>&#160;   if ((john = soap_get_ns__Person(&amp;soap, NULL, NULL, NULL)) == NULL) </div><div class="line"><a name="l04045"></a><span class="lineno"> 4045</span>&#160;     ... error ... </div><div class="line"><a name="l04046"></a><span class="lineno"> 4046</span>&#160;   mother = john-&gt;mother; </div><div class="line"><a name="l04047"></a><span class="lineno"> 4047</span>&#160;   father = john-&gt;father; </div><div class="line"><a name="l04048"></a><span class="lineno"> 4048</span>&#160;   ... </div><div class="line"><a name="l04049"></a><span class="lineno"> 4049</span>&#160;   soap_end_recv(&amp;soap); </div><div class="line"><a name="l04050"></a><span class="lineno"> 4050</span>&#160;   soap_free_temp(&amp;soap); // Clean up temporary data but keep deserialized data </div><div class="line"><a name="l04051"></a><span class="lineno"> 4051</span>&#160;} </div><div class="line"><a name="l04052"></a><span class="lineno"> 4052</span>&#160;struct Namespace namespaces[] = </div><div class="line"><a name="l04053"></a><span class="lineno"> 4053</span>&#160;{ </div><div class="line"><a name="l04054"></a><span class="lineno"> 4054</span>&#160;   {&quot;SOAP-ENV&quot;, &quot;http://schemas.xmlsoap.org/soap/envelope/&quot;}, </div><div class="line"><a name="l04055"></a><span class="lineno"> 4055</span>&#160;   {&quot;SOAP-ENC&quot;,&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;}, </div><div class="line"><a name="l04056"></a><span class="lineno"> 4056</span>&#160;   {&quot;xsi&quot;, &quot;http://www.w3.org/2001/XMLSchema-instance&quot;}, </div><div class="line"><a name="l04057"></a><span class="lineno"> 4057</span>&#160;   {&quot;xsd&quot;, &quot;http://www.w3.org/2001/XMLSchema&quot;}, </div><div class="line"><a name="l04058"></a><span class="lineno"> 4058</span>&#160;   {&quot;ns&quot;, &quot;urn:person&quot;}, // Namespace URI of the &quot;Person&quot; data type </div><div class="line"><a name="l04059"></a><span class="lineno"> 4059</span>&#160;   {NULL, NULL} </div><div class="line"><a name="l04060"></a><span class="lineno"> 4060</span>&#160;};</div><div class="line"><a name="l04061"></a><span class="lineno"> 4061</span>&#160;```</div><div class="line"><a name="l04062"></a><span class="lineno"> 4062</span>&#160;</div><div class="line"><a name="l04063"></a><span class="lineno"> 4063</span>&#160;It is REQUIRED to either pass `NULL` to the `soap_get` routine, or a valid pointer to a data structure that can</div><div class="line"><a name="l04064"></a><span class="lineno"> 4064</span>&#160;hold the decoded content. If the data `john` was already allocated then it does not need to be allocated again as the following demonstrates.</div><div class="line"><a name="l04065"></a><span class="lineno"> 4065</span>&#160;The following program fragment decodes the SOAP content in a `struct ns__Person` allocated on the stack:</div><div class="line"><a name="l04066"></a><span class="lineno"> 4066</span>&#160;</div><div class="line"><a name="l04067"></a><span class="lineno"> 4067</span>&#160;```cpp</div><div class="line"><a name="l04068"></a><span class="lineno"> 4068</span>&#160;#include &quot;soapH.h&quot; </div><div class="line"><a name="l04069"></a><span class="lineno"> 4069</span>&#160;int main() </div><div class="line"><a name="l04070"></a><span class="lineno"> 4070</span>&#160;{</div><div class="line"><a name="l04071"></a><span class="lineno"> 4071</span>&#160;   struct soap soap; </div><div class="line"><a name="l04072"></a><span class="lineno"> 4072</span>&#160;   ns__Person *mother, *father, john; </div><div class="line"><a name="l04073"></a><span class="lineno"> 4073</span>&#160;   soap_init(&amp;soap); </div><div class="line"><a name="l04074"></a><span class="lineno"> 4074</span>&#160;   soap_default_ns__Person(&amp;soap, &amp;john); </div><div class="line"><a name="l04075"></a><span class="lineno"> 4075</span>&#160;   soap_imode(&amp;soap, SOAP_ENC_ZLIB); // optional </div><div class="line"><a name="l04076"></a><span class="lineno"> 4076</span>&#160;   soap_begin(&amp;soap); </div><div class="line"><a name="l04077"></a><span class="lineno"> 4077</span>&#160;   soap_begin_recv(&amp;soap); </div><div class="line"><a name="l04078"></a><span class="lineno"> 4078</span>&#160;   if (soap_get_ns__Person(&amp;soap, &amp;john, &quot;johnnie&quot;, NULL) == NULL) </div><div class="line"><a name="l04079"></a><span class="lineno"> 4079</span>&#160;     ... error ... </div><div class="line"><a name="l04080"></a><span class="lineno"> 4080</span>&#160;   ... </div><div class="line"><a name="l04081"></a><span class="lineno"> 4081</span>&#160;} </div><div class="line"><a name="l04082"></a><span class="lineno"> 4082</span>&#160;struct Namespace namespaces[] = </div><div class="line"><a name="l04083"></a><span class="lineno"> 4083</span>&#160;   ...</div><div class="line"><a name="l04084"></a><span class="lineno"> 4084</span>&#160;```</div><div class="line"><a name="l04085"></a><span class="lineno"> 4085</span>&#160;</div><div class="line"><a name="l04086"></a><span class="lineno"> 4086</span>&#160;Note the use of `soap_default_ns__Person`. This routine is generated by the gSOAP `soapcpp2` tool and assigns default</div><div class="line"><a name="l04087"></a><span class="lineno"> 4087</span>&#160;values to the fields of `john`.</div><div class="line"><a name="l04088"></a><span class="lineno"> 4088</span>&#160;</div><div class="line"><a name="l04089"></a><span class="lineno"> 4089</span>&#160;### Serializing and Deserializing Class Instances to Streams</div><div class="line"><a name="l04090"></a><span class="lineno"> 4090</span>&#160;</div><div class="line"><a name="l04091"></a><span class="lineno"> 4091</span>&#160;C++ applications can define appropriate stream operations on objects for (de)serialization of objects on streams.</div><div class="line"><a name="l04092"></a><span class="lineno"> 4092</span>&#160;This is best illustrated with an example. Section \ref serialize  gives details on serializing types in general.</div><div class="line"><a name="l04093"></a><span class="lineno"> 4093</span>&#160;Consider the class</div><div class="line"><a name="l04094"></a><span class="lineno"> 4094</span>&#160;</div><div class="line"><a name="l04095"></a><span class="lineno"> 4095</span>&#160;```cpp</div><div class="line"><a name="l04096"></a><span class="lineno"> 4096</span>&#160;class ns__person </div><div class="line"><a name="l04097"></a><span class="lineno"> 4097</span>&#160;{ public: </div><div class="line"><a name="l04098"></a><span class="lineno"> 4098</span>&#160;   char *name; </div><div class="line"><a name="l04099"></a><span class="lineno"> 4099</span>&#160;   struct soap *soap; // we need this, see below </div><div class="line"><a name="l04100"></a><span class="lineno"> 4100</span>&#160;   ns__person(); </div><div class="line"><a name="l04101"></a><span class="lineno"> 4101</span>&#160;   ~ns__person(); </div><div class="line"><a name="l04102"></a><span class="lineno"> 4102</span>&#160;};</div><div class="line"><a name="l04103"></a><span class="lineno"> 4103</span>&#160;```</div><div class="line"><a name="l04104"></a><span class="lineno"> 4104</span>&#160;</div><div class="line"><a name="l04105"></a><span class="lineno"> 4105</span>&#160;The `struct soap` member is used to bind the instances to a gSOAP</div><div class="line"><a name="l04106"></a><span class="lineno"> 4106</span>&#160;context for (de)serialization.  We use the gSOAP `soapcpp2` compiler from the command</div><div class="line"><a name="l04107"></a><span class="lineno"> 4107</span>&#160;prompt to generate the class (de)serializers (assuming that `person.h`</div><div class="line"><a name="l04108"></a><span class="lineno"> 4108</span>&#160;contains the class declaration):</div><div class="line"><a name="l04109"></a><span class="lineno"> 4109</span>&#160;</div><div class="line"><a name="l04110"></a><span class="lineno"> 4110</span>&#160;    &gt; soapcpp2 person.h</div><div class="line"><a name="l04111"></a><span class="lineno"> 4111</span>&#160;</div><div class="line"><a name="l04112"></a><span class="lineno"> 4112</span>&#160;gSOAP generates the (de)serializers and an instantiation function for the class</div><div class="line"><a name="l04113"></a><span class="lineno"> 4113</span>&#160;`soap_new_ns__person(struct soap *soap, int num)` to instantiate</div><div class="line"><a name="l04114"></a><span class="lineno"> 4114</span>&#160;one or more objects and associate them with a gSOAP context for deallocation with `soap_destroy(soap)`.  To instantiate a single object, omit</div><div class="line"><a name="l04115"></a><span class="lineno"> 4115</span>&#160;the `num` parameter or set to -1. To instantiate an array of objects, set `num &gt;= 0`.</div><div class="line"><a name="l04116"></a><span class="lineno"> 4116</span>&#160;</div><div class="line"><a name="l04117"></a><span class="lineno"> 4117</span>&#160;```cpp</div><div class="line"><a name="l04118"></a><span class="lineno"> 4118</span>&#160;#include &quot;soapH.h&quot; </div><div class="line"><a name="l04119"></a><span class="lineno"> 4119</span>&#160;#include &quot;ns.nsmap&quot; </div><div class="line"><a name="l04120"></a><span class="lineno"> 4120</span>&#160;... </div><div class="line"><a name="l04121"></a><span class="lineno"> 4121</span>&#160;struct soap *soap = soap_new(); </div><div class="line"><a name="l04122"></a><span class="lineno"> 4122</span>&#160;ns__person *p = soap_new_ns__person(soap); </div><div class="line"><a name="l04123"></a><span class="lineno"> 4123</span>&#160;... </div><div class="line"><a name="l04124"></a><span class="lineno"> 4124</span>&#160;cout &lt;&lt; p; // serialize p in XML </div><div class="line"><a name="l04125"></a><span class="lineno"> 4125</span>&#160;... </div><div class="line"><a name="l04126"></a><span class="lineno"> 4126</span>&#160;in &gt;&gt; p; // parse XML and deserialize p </div><div class="line"><a name="l04127"></a><span class="lineno"> 4127</span>&#160;... </div><div class="line"><a name="l04128"></a><span class="lineno"> 4128</span>&#160;soap_destroy(soap); // deletes p too </div><div class="line"><a name="l04129"></a><span class="lineno"> 4129</span>&#160;soap_end(soap); </div><div class="line"><a name="l04130"></a><span class="lineno"> 4130</span>&#160;soap_done(soap);</div><div class="line"><a name="l04131"></a><span class="lineno"> 4131</span>&#160;```</div><div class="line"><a name="l04132"></a><span class="lineno"> 4132</span>&#160;</div><div class="line"><a name="l04133"></a><span class="lineno"> 4133</span>&#160;The stream operations are implemented as follows</div><div class="line"><a name="l04134"></a><span class="lineno"> 4134</span>&#160;</div><div class="line"><a name="l04135"></a><span class="lineno"> 4135</span>&#160;```cpp</div><div class="line"><a name="l04136"></a><span class="lineno"> 4136</span>&#160;ostream &amp;\operator&lt;&lt;(ostream &amp;o, const ns__person &amp;p) </div><div class="line"><a name="l04137"></a><span class="lineno"> 4137</span>&#160;{ </div><div class="line"><a name="l04138"></a><span class="lineno"> 4138</span>&#160;   if (!p.soap) </div><div class="line"><a name="l04139"></a><span class="lineno"> 4139</span>&#160;     return o; // need a gSOAP context to serialize </div><div class="line"><a name="l04140"></a><span class="lineno"> 4140</span>&#160;   p.soap-&gt;os = &amp;o; </div><div class="line"><a name="l04141"></a><span class="lineno"> 4141</span>&#160;   soap_omode(p.soap, SOAP_XML_TREE); // XML tree or graph </div><div class="line"><a name="l04142"></a><span class="lineno"> 4142</span>&#160;   p.soap_serialize(p.soap); </div><div class="line"><a name="l04143"></a><span class="lineno"> 4143</span>&#160;   soap_begin_send(p.soap); </div><div class="line"><a name="l04144"></a><span class="lineno"> 4144</span>&#160;   if (p.soap_put(p.soap, &quot;person&quot;, NULL) </div><div class="line"><a name="l04145"></a><span class="lineno"> 4145</span>&#160;     || soap_end_send(p.soap)) </div><div class="line"><a name="l04146"></a><span class="lineno"> 4146</span>&#160;     ; // handle I/O error </div><div class="line"><a name="l04147"></a><span class="lineno"> 4147</span>&#160;   return o; </div><div class="line"><a name="l04148"></a><span class="lineno"> 4148</span>&#160;} </div><div class="line"><a name="l04149"></a><span class="lineno"> 4149</span>&#160;istream &amp;\operator&gt;&gt;(istream &amp;i, ns__person &amp;p) </div><div class="line"><a name="l04150"></a><span class="lineno"> 4150</span>&#160;{ </div><div class="line"><a name="l04151"></a><span class="lineno"> 4151</span>&#160;   if (!p.soap) </div><div class="line"><a name="l04152"></a><span class="lineno"> 4152</span>&#160;     return o; // need a gSOAP context to parse XML and deserialize </div><div class="line"><a name="l04153"></a><span class="lineno"> 4153</span>&#160;   p.soap-&gt;is = &amp;i; </div><div class="line"><a name="l04154"></a><span class="lineno"> 4154</span>&#160;   if (soap_begin_recv(p.soap) </div><div class="line"><a name="l04155"></a><span class="lineno"> 4155</span>&#160;     || p.soap_in(p.soap, NULL, NULL) </div><div class="line"><a name="l04156"></a><span class="lineno"> 4156</span>&#160;     || soap_end_recv(p.soap)) </div><div class="line"><a name="l04157"></a><span class="lineno"> 4157</span>&#160;     ; // handle I/O error </div><div class="line"><a name="l04158"></a><span class="lineno"> 4158</span>&#160;   return i; </div><div class="line"><a name="l04159"></a><span class="lineno"> 4159</span>&#160;}</div><div class="line"><a name="l04160"></a><span class="lineno"> 4160</span>&#160;```</div><div class="line"><a name="l04161"></a><span class="lineno"> 4161</span>&#160;</div><div class="line"><a name="l04162"></a><span class="lineno"> 4162</span>&#160;### How to Specify Default Values for Omitted Data        {#default}</div><div class="line"><a name="l04163"></a><span class="lineno"> 4163</span>&#160;</div><div class="line"><a name="l04164"></a><span class="lineno"> 4164</span>&#160;The gSOAP `soapcpp2` compiler generates `soap_default` functions for all data types.  The default values of the primitive types can be</div><div class="line"><a name="l04165"></a><span class="lineno"> 4165</span>&#160;easily changed by defining any of the following macros in the `stdsoap2.h` file:</div><div class="line"><a name="l04166"></a><span class="lineno"> 4166</span>&#160;</div><div class="line"><a name="l04167"></a><span class="lineno"> 4167</span>&#160;```cpp</div><div class="line"><a name="l04168"></a><span class="lineno"> 4168</span>&#160;#define SOAP_DEFAULT_bool </div><div class="line"><a name="l04169"></a><span class="lineno"> 4169</span>&#160;#define SOAP_DEFAULT_byte </div><div class="line"><a name="l04170"></a><span class="lineno"> 4170</span>&#160;#define SOAP_DEFAULT_double </div><div class="line"><a name="l04171"></a><span class="lineno"> 4171</span>&#160;#define SOAP_DEFAULT_float </div><div class="line"><a name="l04172"></a><span class="lineno"> 4172</span>&#160;#define SOAP_DEFAULT_int </div><div class="line"><a name="l04173"></a><span class="lineno"> 4173</span>&#160;#define SOAP_DEFAULT_long </div><div class="line"><a name="l04174"></a><span class="lineno"> 4174</span>&#160;#define SOAP_DEFAULT_LONG64 </div><div class="line"><a name="l04175"></a><span class="lineno"> 4175</span>&#160;#define SOAP_DEFAULT_short </div><div class="line"><a name="l04176"></a><span class="lineno"> 4176</span>&#160;#define SOAP_DEFAULT_string </div><div class="line"><a name="l04177"></a><span class="lineno"> 4177</span>&#160;#define SOAP_DEFAULT_time </div><div class="line"><a name="l04178"></a><span class="lineno"> 4178</span>&#160;#define SOAP_DEFAULT_unsignedByte </div><div class="line"><a name="l04179"></a><span class="lineno"> 4179</span>&#160;#define SOAP_DEFAULT_unsignedInt </div><div class="line"><a name="l04180"></a><span class="lineno"> 4180</span>&#160;#define SOAP_DEFAULT_unsignedLong </div><div class="line"><a name="l04181"></a><span class="lineno"> 4181</span>&#160;#define SOAP_DEFAULT_unsignedLONG64 </div><div class="line"><a name="l04182"></a><span class="lineno"> 4182</span>&#160;#define SOAP_DEFAULT_unsignedShort </div><div class="line"><a name="l04183"></a><span class="lineno"> 4183</span>&#160;#define SOAP_DEFAULT_wstring</div><div class="line"><a name="l04184"></a><span class="lineno"> 4184</span>&#160;```</div><div class="line"><a name="l04185"></a><span class="lineno"> 4185</span>&#160;</div><div class="line"><a name="l04186"></a><span class="lineno"> 4186</span>&#160;Instead of adding these to `stdsoap2.h`, you can also compile with option `-DWITH_SOAPDEFS_H` and include your</div><div class="line"><a name="l04187"></a><span class="lineno"> 4187</span>&#160;definitions in file `soapdefs.h`.</div><div class="line"><a name="l04188"></a><span class="lineno"> 4188</span>&#160;The absence of a data value in a receiving SOAP message will result in the assignment of a default value to a primitive type upon</div><div class="line"><a name="l04189"></a><span class="lineno"> 4189</span>&#160;deserialization.</div><div class="line"><a name="l04190"></a><span class="lineno"> 4190</span>&#160;</div><div class="line"><a name="l04191"></a><span class="lineno"> 4191</span>&#160;Default values can also be assigned to individual `struct` and `class` fields of primitive type. For example,</div><div class="line"><a name="l04192"></a><span class="lineno"> 4192</span>&#160;</div><div class="line"><a name="l04193"></a><span class="lineno"> 4193</span>&#160;```cpp</div><div class="line"><a name="l04194"></a><span class="lineno"> 4194</span>&#160;struct MyRecord </div><div class="line"><a name="l04195"></a><span class="lineno"> 4195</span>&#160;{ </div><div class="line"><a name="l04196"></a><span class="lineno"> 4196</span>&#160;   char *name = &quot;Unknown&quot;; </div><div class="line"><a name="l04197"></a><span class="lineno"> 4197</span>&#160;   int value = 9999; </div><div class="line"><a name="l04198"></a><span class="lineno"> 4198</span>&#160;   enum Status { active, passive } status = passive; </div><div class="line"><a name="l04199"></a><span class="lineno"> 4199</span>&#160;}</div><div class="line"><a name="l04200"></a><span class="lineno"> 4200</span>&#160;```</div><div class="line"><a name="l04201"></a><span class="lineno"> 4201</span>&#160;</div><div class="line"><a name="l04202"></a><span class="lineno"> 4202</span>&#160;Default values are assigned to the fields on receiving a SOAP/XML message in which the data values are absent.</div><div class="line"><a name="l04203"></a><span class="lineno"> 4203</span>&#160;</div><div class="line"><a name="l04204"></a><span class="lineno"> 4204</span>&#160;Because method requests and responses are essentially structs, default values can also be assigned to method parameters. The</div><div class="line"><a name="l04205"></a><span class="lineno"> 4205</span>&#160;default parameter values do not control the parameterization of C/C++ function calls, i.e. all actual parameters must be present</div><div class="line"><a name="l04206"></a><span class="lineno"> 4206</span>&#160;when calling a function. The default parameter values are used in case an inbound request or response message lacks the XML</div><div class="line"><a name="l04207"></a><span class="lineno"> 4207</span>&#160;elements with parameter values. For example, a Web service can use default values to fill-in absent parameters in a</div><div class="line"><a name="l04208"></a><span class="lineno"> 4208</span>&#160;SOAP/XML request:</div><div class="line"><a name="l04209"></a><span class="lineno"> 4209</span>&#160;</div><div class="line"><a name="l04210"></a><span class="lineno"> 4210</span>&#160;```cpp</div><div class="line"><a name="l04211"></a><span class="lineno"> 4211</span>&#160;int ns__login(char *uid = &quot;anonymous&quot;, char *pwd = &quot;guest&quot;, bool granted);</div><div class="line"><a name="l04212"></a><span class="lineno"> 4212</span>&#160;```</div><div class="line"><a name="l04213"></a><span class="lineno"> 4213</span>&#160;</div><div class="line"><a name="l04214"></a><span class="lineno"> 4214</span>&#160;When the request message lacks uid and pwd parameters, e.g.:</div><div class="line"><a name="l04215"></a><span class="lineno"> 4215</span>&#160;</div><div class="line"><a name="l04216"></a><span class="lineno"> 4216</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l04217"></a><span class="lineno"> 4217</span>&#160;```xml</div><div class="line"><a name="l04218"></a><span class="lineno"> 4218</span>&#160;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; </div><div class="line"><a name="l04219"></a><span class="lineno"> 4219</span>&#160;&lt;SOAP-ENV:Envelope </div><div class="line"><a name="l04220"></a><span class="lineno"> 4220</span>&#160;   xmlns:SOAP-ENV=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; </div><div class="line"><a name="l04221"></a><span class="lineno"> 4221</span>&#160;   xmlns:SOAP-ENC=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot; </div><div class="line"><a name="l04222"></a><span class="lineno"> 4222</span>&#160;   xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; </div><div class="line"><a name="l04223"></a><span class="lineno"> 4223</span>&#160;   xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; </div><div class="line"><a name="l04224"></a><span class="lineno"> 4224</span>&#160;   xmlns:ns=&quot;http://tempuri.org&quot;&gt; </div><div class="line"><a name="l04225"></a><span class="lineno"> 4225</span>&#160;   &lt;SOAP-ENV:Body encodingStyle=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;&gt; </div><div class="line"><a name="l04226"></a><span class="lineno"> 4226</span>&#160;     &lt;ns:login&gt; </div><div class="line"><a name="l04227"></a><span class="lineno"> 4227</span>&#160;     &lt;/ns:login&gt; </div><div class="line"><a name="l04228"></a><span class="lineno"> 4228</span>&#160;   &lt;/SOAP-ENV:Body&gt; </div><div class="line"><a name="l04229"></a><span class="lineno"> 4229</span>&#160;&lt;/SOAP-ENV:Envelope&gt;</div><div class="line"><a name="l04230"></a><span class="lineno"> 4230</span>&#160;```</div><div class="line"><a name="l04231"></a><span class="lineno"> 4231</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l04232"></a><span class="lineno"> 4232</span>&#160;</div><div class="line"><a name="l04233"></a><span class="lineno"> 4233</span>&#160;then the service uses the default values.</div><div class="line"><a name="l04234"></a><span class="lineno"> 4234</span>&#160;In addition, the default values will show up in the SOAP/XML request and response message examples generated by the gSOAP</div><div class="line"><a name="l04235"></a><span class="lineno"> 4235</span>&#160;compiler.</div><div class="line"><a name="l04236"></a><span class="lineno"> 4236</span>&#160;</div><div class="line"><a name="l04237"></a><span class="lineno"> 4237</span>&#160;# The wsdl2h WSDL and Schema Importer        {#wsdlin}</div><div class="line"><a name="l04238"></a><span class="lineno"> 4238</span>&#160;</div><div class="line"><a name="l04239"></a><span class="lineno"> 4239</span>&#160;The `wsdl2h` tool is an advanced application that converts one or more</div><div class="line"><a name="l04240"></a><span class="lineno"> 4240</span>&#160;WSDLs to C/C++. It can also be used without WSDLs to convert XML schemas (XSD</div><div class="line"><a name="l04241"></a><span class="lineno"> 4241</span>&#160;files) to C/C++ to implement XML data bindings in C and C++.</div><div class="line"><a name="l04242"></a><span class="lineno"> 4242</span>&#160;</div><div class="line"><a name="l04243"></a><span class="lineno"> 4243</span>&#160;The creation of C and C++ applications from one of more WSDL service</div><div class="line"><a name="l04244"></a><span class="lineno"> 4244</span>&#160;descriptions is a two-step process.</div><div class="line"><a name="l04245"></a><span class="lineno"> 4245</span>&#160;</div><div class="line"><a name="l04246"></a><span class="lineno"> 4246</span>&#160;To convert a WSDL to C++, use:</div><div class="line"><a name="l04247"></a><span class="lineno"> 4247</span>&#160;</div><div class="line"><a name="l04248"></a><span class="lineno"> 4248</span>&#160;    &gt; wsdl2h file.wsdl</div><div class="line"><a name="l04249"></a><span class="lineno"> 4249</span>&#160;</div><div class="line"><a name="l04250"></a><span class="lineno"> 4250</span>&#160;to generate a C++ header file `file`.h.</div><div class="line"><a name="l04251"></a><span class="lineno"> 4251</span>&#160;This generated header file is a Web service specification that contains the parameter types and service function definitions in an understandable format in C++ (or ANSI C as shown below).</div><div class="line"><a name="l04252"></a><span class="lineno"> 4252</span>&#160;Web service operations are represented as function prototypes. Schema types are</div><div class="line"><a name="l04253"></a><span class="lineno"> 4253</span>&#160;represented by semantically equivalent C/C++ types that are convenient and</div><div class="line"><a name="l04254"></a><span class="lineno"> 4254</span>&#160;natural to use in a C/C++ application. The generated header file also contains</div><div class="line"><a name="l04255"></a><span class="lineno"> 4255</span>&#160;various annotations related to the Web service properties defined in the WSDL.</div><div class="line"><a name="l04256"></a><span class="lineno"> 4256</span>&#160;</div><div class="line"><a name="l04257"></a><span class="lineno"> 4257</span>&#160;To generate ANSI C, use option `-c`:</div><div class="line"><a name="l04258"></a><span class="lineno"> 4258</span>&#160;</div><div class="line"><a name="l04259"></a><span class="lineno"> 4259</span>&#160;    &gt; wsdl2h -c file.wsdl</div><div class="line"><a name="l04260"></a><span class="lineno"> 4260</span>&#160;</div><div class="line"><a name="l04261"></a><span class="lineno"> 4261</span>&#160;Multiple WSDL specifications can be processed at once and saved to one file with the `-o` option:</div><div class="line"><a name="l04262"></a><span class="lineno"> 4262</span>&#160;</div><div class="line"><a name="l04263"></a><span class="lineno"> 4263</span>&#160;    &gt; wsdl2h -o file.h file1.wsdl file2.wsdl file3.wsdl</div><div class="line"><a name="l04264"></a><span class="lineno"> 4264</span>&#160;</div><div class="line"><a name="l04265"></a><span class="lineno"> 4265</span>&#160;You can retrieve WSDLs from one of more URLs:</div><div class="line"><a name="l04266"></a><span class="lineno"> 4266</span>&#160;</div><div class="line"><a name="l04267"></a><span class="lineno"> 4267</span>&#160;    &gt; wsdl2h -o file.h http://www.example.com/example.wsdl</div><div class="line"><a name="l04268"></a><span class="lineno"> 4268</span>&#160;</div><div class="line"><a name="l04269"></a><span class="lineno"> 4269</span>&#160;To convert XML schemas to C or C++ XML data binding code, use:</div><div class="line"><a name="l04270"></a><span class="lineno"> 4270</span>&#160;</div><div class="line"><a name="l04271"></a><span class="lineno"> 4271</span>&#160;    &gt; wsdl2h -o file.h file1.xsd file2.xsd file3.xsd</div><div class="line"><a name="l04272"></a><span class="lineno"> 4272</span>&#160;</div><div class="line"><a name="l04273"></a><span class="lineno"> 4273</span>&#160;The `wsdl2h`-generated header file `file.h` is processed by the</div><div class="line"><a name="l04274"></a><span class="lineno"> 4274</span>&#160;`soapcpp2` tool to auto-generate the advanced data binding logic to</div><div class="line"><a name="l04275"></a><span class="lineno"> 4275</span>&#160;convert the C/C++ data to XML and vice versa at runtime for your SOAP/XML</div><div class="line"><a name="l04276"></a><span class="lineno"> 4276</span>&#160;application.</div><div class="line"><a name="l04277"></a><span class="lineno"> 4277</span>&#160;</div><div class="line"><a name="l04278"></a><span class="lineno"> 4278</span>&#160;To process a gSOAP header file `file.h` (generated by `wsdl2h`) to generate advanced XML data bindings for C++, use:</div><div class="line"><a name="l04279"></a><span class="lineno"> 4279</span>&#160;</div><div class="line"><a name="l04280"></a><span class="lineno"> 4280</span>&#160;    &gt; soapcpp2 -i -Iimport file.h</div><div class="line"><a name="l04281"></a><span class="lineno"> 4281</span>&#160;</div><div class="line"><a name="l04282"></a><span class="lineno"> 4282</span>&#160;When the header file `file.h` was generated for C++, then this command</div><div class="line"><a name="l04283"></a><span class="lineno"> 4283</span>&#160;generates a couple of C++ source files (more details will follow in</div><div class="line"><a name="l04284"></a><span class="lineno"> 4284</span>&#160;Section \ref soapcpp2 ) that implement XML encoders for the data binding.</div><div class="line"><a name="l04285"></a><span class="lineno"> 4285</span>&#160;Option `-i` generates a client proxy objects and service objects to invoke</div><div class="line"><a name="l04286"></a><span class="lineno"> 4286</span>&#160;and serve SOAP/XML operations, respectively. Option `-Iimport` sets the</div><div class="line"><a name="l04287"></a><span class="lineno"> 4287</span>&#160;import directory for imported files from the package&#39;s `import`, such as</div><div class="line"><a name="l04288"></a><span class="lineno"> 4288</span>&#160;`stlvector.h` for STL vector serialization support.</div><div class="line"><a name="l04289"></a><span class="lineno"> 4289</span>&#160;</div><div class="line"><a name="l04290"></a><span class="lineno"> 4290</span>&#160;When the header file `file.h` was generated for ANSI C, then the above</div><div class="line"><a name="l04291"></a><span class="lineno"> 4291</span>&#160;command generates a couple of C files that implement XML encoders, client stubs</div><div class="line"><a name="l04292"></a><span class="lineno"> 4292</span>&#160;for remote invocation, and service skeletons for service operations. </div><div class="line"><a name="l04293"></a><span class="lineno"> 4293</span>&#160;</div><div class="line"><a name="l04294"></a><span class="lineno"> 4294</span>&#160;Consider for example the following commands to implement a c++ client of a service:</div><div class="line"><a name="l04295"></a><span class="lineno"> 4295</span>&#160;</div><div class="line"><a name="l04296"></a><span class="lineno"> 4296</span>&#160;    &gt; wsdl2h -o calc.h http://www.genivia.com/calc.wsdl </div><div class="line"><a name="l04297"></a><span class="lineno"> 4297</span>&#160;    &gt; soapcpp2 -i -Iimport calc.h</div><div class="line"><a name="l04298"></a><span class="lineno"> 4298</span>&#160;</div><div class="line"><a name="l04299"></a><span class="lineno"> 4299</span>&#160;The first command generates `calc.h` from the WSDL at the specified URL.</div><div class="line"><a name="l04300"></a><span class="lineno"> 4300</span>&#160;The header file is then processed by the `soapcpp2` tool to generate the</div><div class="line"><a name="l04301"></a><span class="lineno"> 4301</span>&#160;proxies (and service objects that we will not use) for the client application.</div><div class="line"><a name="l04302"></a><span class="lineno"> 4302</span>&#160;</div><div class="line"><a name="l04303"></a><span class="lineno"> 4303</span>&#160;The C++ client application uses the auto-generated `soapcalcProxy.h` class and</div><div class="line"><a name="l04304"></a><span class="lineno"> 4304</span>&#160;`calc.nsmap` XML namespace table to access the Web</div><div class="line"><a name="l04305"></a><span class="lineno"> 4305</span>&#160;service. Both need to be `#include`-d in your source. Then compile and link</div><div class="line"><a name="l04306"></a><span class="lineno"> 4306</span>&#160;the `soapcalcProxy.cpp`, `soapC.cpp` and `stdsoap2.cpp` sources to complete the build.</div><div class="line"><a name="l04307"></a><span class="lineno"> 4307</span>&#160;</div><div class="line"><a name="l04308"></a><span class="lineno"> 4308</span>&#160;## wsdl2h Options</div><div class="line"><a name="l04309"></a><span class="lineno"> 4309</span>&#160;</div><div class="line"><a name="l04310"></a><span class="lineno"> 4310</span>&#160;The `wsdl2h` tool is an advanced XML data binding tool for converting WSDLs</div><div class="line"><a name="l04311"></a><span class="lineno"> 4311</span>&#160;and XML schemas (XSD files) to C or C++. The tool takes WSDL and/or XSD files</div><div class="line"><a name="l04312"></a><span class="lineno"> 4312</span>&#160;or URLs and converts these to a C or C++ specification in one easy-to-read</div><div class="line"><a name="l04313"></a><span class="lineno"> 4313</span>&#160;C/C++ header file. **The header file is not intended to be included in your</div><div class="line"><a name="l04314"></a><span class="lineno"> 4314</span>&#160;code directly!**. It should be converted by `soapcpp2` to generate the logic</div><div class="line"><a name="l04315"></a><span class="lineno"> 4315</span>&#160;for the data bindings. It can however be safely converted by a documentation</div><div class="line"><a name="l04316"></a><span class="lineno"> 4316</span>&#160;tool such as Doxygen to analyze and represent the service operations and data</div><div class="line"><a name="l04317"></a><span class="lineno"> 4317</span>&#160;in a convenient layout. To this end, the header file is self-explanatory.</div><div class="line"><a name="l04318"></a><span class="lineno"> 4318</span>&#160;</div><div class="line"><a name="l04319"></a><span class="lineno"> 4319</span>&#160;The `wsdl2h` tool generates only one file, the header file that includes</div><div class="line"><a name="l04320"></a><span class="lineno"> 4320</span>&#160;all of the information obtained from all WSDL and schema files provided to the</div><div class="line"><a name="l04321"></a><span class="lineno"> 4321</span>&#160;tool at the command-line prompt. The default output file name of `wsdl2h`</div><div class="line"><a name="l04322"></a><span class="lineno"> 4322</span>&#160;is the first WSDL/schema input file name but with extension `.h` instead of</div><div class="line"><a name="l04323"></a><span class="lineno"> 4323</span>&#160;`.wsdl` (or `.xsd`). When an input file is absent or a WSDL file from a</div><div class="line"><a name="l04324"></a><span class="lineno"> 4324</span>&#160;Web location is accessed, the header output will be produced on the standard</div><div class="line"><a name="l04325"></a><span class="lineno"> 4325</span>&#160;output unless option `-o` is used to direct the output to a file.</div><div class="line"><a name="l04326"></a><span class="lineno"> 4326</span>&#160;</div><div class="line"><a name="l04327"></a><span class="lineno"> 4327</span>&#160;The `wsdl2h` command-line options are:</div><div class="line"><a name="l04328"></a><span class="lineno"> 4328</span>&#160;</div><div class="line"><a name="l04329"></a><span class="lineno"> 4329</span>&#160;option                   | result</div><div class="line"><a name="l04330"></a><span class="lineno"> 4330</span>&#160;------------------------ | ------</div><div class="line"><a name="l04331"></a><span class="lineno"> 4331</span>&#160;`-a`                     | generate indexed struct names for local elements with anonymous types </div><div class="line"><a name="l04332"></a><span class="lineno"> 4332</span>&#160;`-b`                     | bi-directional operations to serve one-way response messages (duplex)</div><div class="line"><a name="l04333"></a><span class="lineno"> 4333</span>&#160;`-c`                     | generate C source code </div><div class="line"><a name="l04334"></a><span class="lineno"> 4334</span>&#160;`-d`                     | use DOM to populate xs:any and xsd:anyType elements </div><div class="line"><a name="l04335"></a><span class="lineno"> 4335</span>&#160;`-e`                     | don&#39;t qualify enum names</div><div class="line"><a name="l04336"></a><span class="lineno"> 4336</span>&#160;`-f`                     | generate flat C++ class hierarchy for schema extensions </div><div class="line"><a name="l04337"></a><span class="lineno"> 4337</span>&#160;`-g`                     | generate global top-level element declarations </div><div class="line"><a name="l04338"></a><span class="lineno"> 4338</span>&#160;`-h`                     | print help information </div><div class="line"><a name="l04339"></a><span class="lineno"> 4339</span>&#160;`-I path`                | use path to locate source files for `#import` </div><div class="line"><a name="l04340"></a><span class="lineno"> 4340</span>&#160;`-i`                     | don&#39;t import (advanced option)</div><div class="line"><a name="l04341"></a><span class="lineno"> 4341</span>&#160;`-j`                     | don&#39;t generate `SOAP_ENV__Header` and `SOAP_ENV__Detail` definitions </div><div class="line"><a name="l04342"></a><span class="lineno"> 4342</span>&#160;`-k`                     | don&#39;t generate `SOAP_ENV__Header` `mustUnderstand` qualifiers </div><div class="line"><a name="l04343"></a><span class="lineno"> 4343</span>&#160;`-l`                     | include license information in output </div><div class="line"><a name="l04344"></a><span class="lineno"> 4344</span>&#160;`-m`                     | use xsd.h module to import primitive types </div><div class="line"><a name="l04345"></a><span class="lineno"> 4345</span>&#160;`-N name`                | use `name` for service prefixes to produce a service for each binding </div><div class="line"><a name="l04346"></a><span class="lineno"> 4346</span>&#160;`-n name`                | use `name` as the base namespace prefix name instead of `ns` </div><div class="line"><a name="l04347"></a><span class="lineno"> 4347</span>&#160;`-o file`                | output to file </div><div class="line"><a name="l04348"></a><span class="lineno"> 4348</span>&#160;`-P`                     | don&#39;t create polymorphic types inherited from `xsd__anyType` </div><div class="line"><a name="l04349"></a><span class="lineno"> 4349</span>&#160;`-p`                     | create polymorphic types inherited from base `xsd__anyType` (this is automatically performed when WSDL contains polymorphic definitions)</div><div class="line"><a name="l04350"></a><span class="lineno"> 4350</span>&#160;`-q name`                | use `name` for the C++ namespace of all declarations </div><div class="line"><a name="l04351"></a><span class="lineno"> 4351</span>&#160;`-r host[:port[:id:pw]]` | connect via proxy host, port, and proxy credentials </div><div class="line"><a name="l04352"></a><span class="lineno"> 4352</span>&#160;`-r:uid:pwd`             | connect with authentication credentials (digest auth requires SSL) </div><div class="line"><a name="l04353"></a><span class="lineno"> 4353</span>&#160;`-R`                     | generate REST operations for REST bindings in the WSDL </div><div class="line"><a name="l04354"></a><span class="lineno"> 4354</span>&#160;`-s`                     | don&#39;t generate STL code (no std::string and no std::vector) </div><div class="line"><a name="l04355"></a><span class="lineno"> 4355</span>&#160;`-t file`                | use type map file instead of the default file typemap.dat </div><div class="line"><a name="l04356"></a><span class="lineno"> 4356</span>&#160;`-U`                     | map Unicode XML names to UTF8-encoded Unicode C/C++ identifiers </div><div class="line"><a name="l04357"></a><span class="lineno"> 4357</span>&#160;`-u`                     | don&#39;t generate unions </div><div class="line"><a name="l04358"></a><span class="lineno"> 4358</span>&#160;`-V`                     | display the current version and exit</div><div class="line"><a name="l04359"></a><span class="lineno"> 4359</span>&#160;`-v`                     | verbose output </div><div class="line"><a name="l04360"></a><span class="lineno"> 4360</span>&#160;`-W`                     | suppress warnings </div><div class="line"><a name="l04361"></a><span class="lineno"> 4361</span>&#160;`-w`                     | always wrap response parameters in a response struct </div><div class="line"><a name="l04362"></a><span class="lineno"> 4362</span>&#160;`-x`                     | don&#39;t generate `_XML any/anyAttribute` extensibility elements </div><div class="line"><a name="l04363"></a><span class="lineno"> 4363</span>&#160;`-y`                     | generate typedef synonyms for structs and enums </div><div class="line"><a name="l04364"></a><span class="lineno"> 4364</span>&#160;`-z1`                    | compatibility with 2.7.6e: generate pointer-based arrays</div><div class="line"><a name="l04365"></a><span class="lineno"> 4365</span>&#160;`-z2`                    | compatibility with 2.7.15: qualify element/attribute referenced members</div><div class="line"><a name="l04366"></a><span class="lineno"> 4366</span>&#160;`-z3`                    | compatibility with 2.7.16 to 2.8.7: qualify element/attribute references</div><div class="line"><a name="l04367"></a><span class="lineno"> 4367</span>&#160;`-z4`                    | compatibility up to 2.8.11: don&#39;t generate union structs in std::vector </div><div class="line"><a name="l04368"></a><span class="lineno"> 4368</span>&#160;`-z5`                    | compatibility up to 2.8.15 </div><div class="line"><a name="l04369"></a><span class="lineno"> 4369</span>&#160;`-z6`                    | compatibility up to 2.8.17 </div><div class="line"><a name="l04370"></a><span class="lineno"> 4370</span>&#160;`-_`                     | don&#39;t generate `_USCORE` (replace with Unicode _x005f) </div><div class="line"><a name="l04371"></a><span class="lineno"> 4371</span>&#160;</div><div class="line"><a name="l04372"></a><span class="lineno"> 4372</span>&#160;Note: see `README.txt` in the `wsdl` directory for the latest</div><div class="line"><a name="l04373"></a><span class="lineno"> 4373</span>&#160;information on installation and options to of the `wsdl2h` WSDL/schema importer.</div><div class="line"><a name="l04374"></a><span class="lineno"> 4374</span>&#160;</div><div class="line"><a name="l04375"></a><span class="lineno"> 4375</span>&#160;## Customizing Data Bindings With The typemap.dat File        {#typemap}</div><div class="line"><a name="l04376"></a><span class="lineno"> 4376</span>&#160;</div><div class="line"><a name="l04377"></a><span class="lineno"> 4377</span>&#160;The `typemap.dat` file for the `wsdl2h` tool is intended to customize or optimize</div><div class="line"><a name="l04378"></a><span class="lineno"> 4378</span>&#160;the type bindings by mapping schema types to C/C++ types.  It contains custom</div><div class="line"><a name="l04379"></a><span class="lineno"> 4379</span>&#160;XML Schema to C/C++ type bindings and a few bindings are defined for</div><div class="line"><a name="l04380"></a><span class="lineno"> 4380</span>&#160;convenience.</div><div class="line"><a name="l04381"></a><span class="lineno"> 4381</span>&#160;</div><div class="line"><a name="l04382"></a><span class="lineno"> 4382</span>&#160;Here is an example typemap file&#39;s content:</div><div class="line"><a name="l04383"></a><span class="lineno"> 4383</span>&#160;</div><div class="line"><a name="l04384"></a><span class="lineno"> 4384</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l04385"></a><span class="lineno"> 4385</span>&#160;```xml</div><div class="line"><a name="l04386"></a><span class="lineno"> 4386</span>&#160;#       This file contains custom definitions of the XML Schema types and </div><div class="line"><a name="l04387"></a><span class="lineno"> 4387</span>&#160;#       C/C++ types for your project, and XML namespace prefix definitions. </div><div class="line"><a name="l04388"></a><span class="lineno"> 4388</span>&#160;#       The wsdl2h WSDL importer consults this file to determine bindings. </div><div class="line"><a name="l04389"></a><span class="lineno"> 4389</span>&#160;  </div><div class="line"><a name="l04390"></a><span class="lineno"> 4390</span>&#160;[ </div><div class="line"><a name="l04391"></a><span class="lineno"> 4391</span>&#160;// This comment will be included in the generated .h file </div><div class="line"><a name="l04392"></a><span class="lineno"> 4392</span>&#160;// You can include any additional declarations, includes, imports, etc. </div><div class="line"><a name="l04393"></a><span class="lineno"> 4393</span>&#160;// within [ ] sections. The brackets MUST appear at the start of a line </div><div class="line"><a name="l04394"></a><span class="lineno"> 4394</span>&#160;] </div><div class="line"><a name="l04395"></a><span class="lineno"> 4395</span>&#160;#       XML namespace prefix definitions can be provided to override the </div><div class="line"><a name="l04396"></a><span class="lineno"> 4396</span>&#160;#       default choice of ns1, ns2, ... prefixes. For example: </div><div class="line"><a name="l04397"></a><span class="lineno"> 4397</span>&#160; </div><div class="line"><a name="l04398"></a><span class="lineno"> 4398</span>&#160;i       = &quot;http://www.soapinterop.org/&quot; </div><div class="line"><a name="l04399"></a><span class="lineno"> 4399</span>&#160;s       = &quot;http://www.soapinterop.org/xsd&quot;</div><div class="line"><a name="l04400"></a><span class="lineno"> 4400</span>&#160;```</div><div class="line"><a name="l04401"></a><span class="lineno"> 4401</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l04402"></a><span class="lineno"> 4402</span>&#160;</div><div class="line"><a name="l04403"></a><span class="lineno"> 4403</span>&#160;Type bindings can be provided to bind XML schema types to C/C++</div><div class="line"><a name="l04404"></a><span class="lineno"> 4404</span>&#160;types for your project.</div><div class="line"><a name="l04405"></a><span class="lineno"> 4405</span>&#160;Type bindings have four parts:</div><div class="line"><a name="l04406"></a><span class="lineno"> 4406</span>&#160;</div><div class="line"><a name="l04407"></a><span class="lineno"> 4407</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l04408"></a><span class="lineno"> 4408</span>&#160;```xml</div><div class="line"><a name="l04409"></a><span class="lineno"> 4409</span>&#160;prefix__type = declaration | use | ptr-use</div><div class="line"><a name="l04410"></a><span class="lineno"> 4410</span>&#160;```</div><div class="line"><a name="l04411"></a><span class="lineno"> 4411</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l04412"></a><span class="lineno"> 4412</span>&#160;</div><div class="line"><a name="l04413"></a><span class="lineno"> 4413</span>&#160;where &#39;prefix__type&#39; is the C/C++-translation of the schema type,</div><div class="line"><a name="l04414"></a><span class="lineno"> 4414</span>&#160;&#39;declaration&#39; introduces the C/C++ type in the header file, the optional</div><div class="line"><a name="l04415"></a><span class="lineno"> 4415</span>&#160;&#39;use&#39; specifies how the type is used directly, and the optional</div><div class="line"><a name="l04416"></a><span class="lineno"> 4416</span>&#160;&#39;ptr-use&#39; specifies how the type is used as a pointer type.</div><div class="line"><a name="l04417"></a><span class="lineno"> 4417</span>&#160;</div><div class="line"><a name="l04418"></a><span class="lineno"> 4418</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l04419"></a><span class="lineno"> 4419</span>&#160;```xml</div><div class="line"><a name="l04420"></a><span class="lineno"> 4420</span>&#160;#       Example XML Schema and C/C++ type bindings: </div><div class="line"><a name="l04421"></a><span class="lineno"> 4421</span>&#160; </div><div class="line"><a name="l04422"></a><span class="lineno"> 4422</span>&#160;xsd__int        = | int </div><div class="line"><a name="l04423"></a><span class="lineno"> 4423</span>&#160;xsd__string     = | char* | char* </div><div class="line"><a name="l04424"></a><span class="lineno"> 4424</span>&#160;xsd__boolean = enum xsd__boolean { false_, true_ }; | enum xsd__boolean </div><div class="line"><a name="l04425"></a><span class="lineno"> 4425</span>&#160;xsd__base64Binary = class xsd__base64Binary { unsigned char *__ptr; int __size; }; | xsd__base64Binary | xsd__base64Binary </div><div class="line"><a name="l04426"></a><span class="lineno"> 4426</span>&#160;#       You can extend structs and classes with member data and functions. </div><div class="line"><a name="l04427"></a><span class="lineno"> 4427</span>&#160;#      For example, adding a constructor to ns__myClass:</div><div class="line"><a name="l04428"></a><span class="lineno"> 4428</span>&#160;ns__myClass     = $ ns__myClass(); </div><div class="line"><a name="l04429"></a><span class="lineno"> 4429</span>&#160;#       The general form is</div><div class="line"><a name="l04430"></a><span class="lineno"> 4430</span>&#160;#       class_name = $ member; </div><div class="line"><a name="l04431"></a><span class="lineno"> 4431</span>&#160;```</div><div class="line"><a name="l04432"></a><span class="lineno"> 4432</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l04433"></a><span class="lineno"> 4433</span>&#160;</div><div class="line"><a name="l04434"></a><span class="lineno"> 4434</span>&#160;The `i` and `s` prefixes are declared such that the header file output by the WSDL parser will use these to produce C/C++ code.</div><div class="line"><a name="l04435"></a><span class="lineno"> 4435</span>&#160;XML Schema types are associated with an optional C/C++ type declaration, a use reference, and a pointer-use reference. The pointer-use reference of the `xsd__byte` type for example, is `int*` because `char*` is reserved for strings.</div><div class="line"><a name="l04436"></a><span class="lineno"> 4436</span>&#160;</div><div class="line"><a name="l04437"></a><span class="lineno"> 4437</span>&#160;When a type binding requires only the usage to be changed, the</div><div class="line"><a name="l04438"></a><span class="lineno"> 4438</span>&#160;declaration part can be given by an elipsis ..., as in:</div><div class="line"><a name="l04439"></a><span class="lineno"> 4439</span>&#160;</div><div class="line"><a name="l04440"></a><span class="lineno"> 4440</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l04441"></a><span class="lineno"> 4441</span>&#160;```xml</div><div class="line"><a name="l04442"></a><span class="lineno"> 4442</span>&#160;prefix__type = ... | use | ptr-use</div><div class="line"><a name="l04443"></a><span class="lineno"> 4443</span>&#160;```</div><div class="line"><a name="l04444"></a><span class="lineno"> 4444</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l04445"></a><span class="lineno"> 4445</span>&#160;</div><div class="line"><a name="l04446"></a><span class="lineno"> 4446</span>&#160;This ensures that the wsdl2h-generated type definition is preserved,</div><div class="line"><a name="l04447"></a><span class="lineno"> 4447</span>&#160;while the use and ptr-use are remapped.</div><div class="line"><a name="l04448"></a><span class="lineno"> 4448</span>&#160;</div><div class="line"><a name="l04449"></a><span class="lineno"> 4449</span>&#160;This method is useful to serialize dynamic types in C, where elements types int</div><div class="line"><a name="l04450"></a><span class="lineno"> 4450</span>&#160;XML carry the *`xsi:type`* attribute.</div><div class="line"><a name="l04451"></a><span class="lineno"> 4451</span>&#160;</div><div class="line"><a name="l04452"></a><span class="lineno"> 4452</span>&#160;The following example illustrates an &quot;any&quot; type mapping for the</div><div class="line"><a name="l04453"></a><span class="lineno"> 4453</span>&#160;*`ns:sometype`* XSD type in a schema. This type will be replaced with a &quot;any&quot;</div><div class="line"><a name="l04454"></a><span class="lineno"> 4454</span>&#160;type wrapper that supports dynamic serialization with *`xsi:type`*:</div><div class="line"><a name="l04455"></a><span class="lineno"> 4455</span>&#160;</div><div class="line"><a name="l04456"></a><span class="lineno"> 4456</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l04457"></a><span class="lineno"> 4457</span>&#160;```xml</div><div class="line"><a name="l04458"></a><span class="lineno"> 4458</span>&#160;[ </div><div class="line"><a name="l04459"></a><span class="lineno"> 4459</span>&#160;struct __any </div><div class="line"><a name="l04460"></a><span class="lineno"> 4460</span>&#160;{ </div><div class="line"><a name="l04461"></a><span class="lineno"> 4461</span>&#160;   int __type; </div><div class="line"><a name="l04462"></a><span class="lineno"> 4462</span>&#160;   void *__item; </div><div class="line"><a name="l04463"></a><span class="lineno"> 4463</span>&#160;} </div><div class="line"><a name="l04464"></a><span class="lineno"> 4464</span>&#160;] </div><div class="line"><a name="l04465"></a><span class="lineno"> 4465</span>&#160;xsd__anyType = ... | struct __any | struct __any</div><div class="line"><a name="l04466"></a><span class="lineno"> 4466</span>&#160;```</div><div class="line"><a name="l04467"></a><span class="lineno"> 4467</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l04468"></a><span class="lineno"> 4468</span>&#160;</div><div class="line"><a name="l04469"></a><span class="lineno"> 4469</span>&#160;where *`__type`* and *`__item`* are used to (de)serialize any data type in the wrapper,</div><div class="line"><a name="l04470"></a><span class="lineno"> 4470</span>&#160;including base and its derived types based on *`xsi:type`* attribuation.</div><div class="line"><a name="l04471"></a><span class="lineno"> 4471</span>&#160;</div><div class="line"><a name="l04472"></a><span class="lineno"> 4472</span>&#160;To support complexType extensions that are dynamically bound in C code, i.e.</div><div class="line"><a name="l04473"></a><span class="lineno"> 4473</span>&#160;polymorphic types based on inheritance hierarchies, we can redeclare the base</div><div class="line"><a name="l04474"></a><span class="lineno"> 4474</span>&#160;type of a hierarchy as a wrapper type and use the `__type` to serialize</div><div class="line"><a name="l04475"></a><span class="lineno"> 4475</span>&#160;base or derived types. One addition is needed to support base type</div><div class="line"><a name="l04476"></a><span class="lineno"> 4476</span>&#160;serialization without the use of *`xsi:type`* attributes. The absence of this attribute requires the serialization of the base type.</div><div class="line"><a name="l04477"></a><span class="lineno"> 4477</span>&#160;</div><div class="line"><a name="l04478"></a><span class="lineno"> 4478</span>&#160;Basically, we need to be able to both handle a base type and its extensions</div><div class="line"><a name="l04479"></a><span class="lineno"> 4479</span>&#160;as per schema extensibility. Say base type *`ns:base`* is a complexType that is extended by several other complexTypes. To implement dynamic binding in C to serialize the base type and derived types, we define:</div><div class="line"><a name="l04480"></a><span class="lineno"> 4480</span>&#160;</div><div class="line"><a name="l04481"></a><span class="lineno"> 4481</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l04482"></a><span class="lineno"> 4482</span>&#160;```xml</div><div class="line"><a name="l04483"></a><span class="lineno"> 4483</span>&#160;[ </div><div class="line"><a name="l04484"></a><span class="lineno"> 4484</span>&#160;struct __ns__base </div><div class="line"><a name="l04485"></a><span class="lineno"> 4485</span>&#160;{ </div><div class="line"><a name="l04486"></a><span class="lineno"> 4486</span>&#160;   int __type; </div><div class="line"><a name="l04487"></a><span class="lineno"> 4487</span>&#160;   void *__item; </div><div class="line"><a name="l04488"></a><span class="lineno"> 4488</span>&#160;   struct ns__base *__self; </div><div class="line"><a name="l04489"></a><span class="lineno"> 4489</span>&#160;} </div><div class="line"><a name="l04490"></a><span class="lineno"> 4490</span>&#160;] </div><div class="line"><a name="l04491"></a><span class="lineno"> 4491</span>&#160;ns__base = ... | struct __ns__base | struct __ns__base</div><div class="line"><a name="l04492"></a><span class="lineno"> 4492</span>&#160;```</div><div class="line"><a name="l04493"></a><span class="lineno"> 4493</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l04494"></a><span class="lineno"> 4494</span>&#160;</div><div class="line"><a name="l04495"></a><span class="lineno"> 4495</span>&#160;The *`__self`* field refers to the element tag (basically a struct member name)</div><div class="line"><a name="l04496"></a><span class="lineno"> 4496</span>&#160;to which the *`ns:base`* type is associated. So for example, we see in the soapcpp2-generated output:</div><div class="line"><a name="l04497"></a><span class="lineno"> 4497</span>&#160;</div><div class="line"><a name="l04498"></a><span class="lineno"> 4498</span>&#160;```cpp</div><div class="line"><a name="l04499"></a><span class="lineno"> 4499</span>&#160;struct ns__data </div><div class="line"><a name="l04500"></a><span class="lineno"> 4500</span>&#160;{ </div><div class="line"><a name="l04501"></a><span class="lineno"> 4501</span>&#160;   ... </div><div class="line"><a name="l04502"></a><span class="lineno"> 4502</span>&#160;   struct __ns__base name; </div><div class="line"><a name="l04503"></a><span class="lineno"> 4503</span>&#160;   ... </div><div class="line"><a name="l04504"></a><span class="lineno"> 4504</span>&#160;};</div><div class="line"><a name="l04505"></a><span class="lineno"> 4505</span>&#160;```</div><div class="line"><a name="l04506"></a><span class="lineno"> 4506</span>&#160;</div><div class="line"><a name="l04507"></a><span class="lineno"> 4507</span>&#160;where `__item` represents `name` when the `__ns__base` is</div><div class="line"><a name="l04508"></a><span class="lineno"> 4508</span>&#160;serialized with an *`xsi:type`* attribute, and `__self` represents</div><div class="line"><a name="l04509"></a><span class="lineno"> 4509</span>&#160;`name` when the `__ns__base` is serialized wwithout an *`xsi:type`*</div><div class="line"><a name="l04510"></a><span class="lineno"> 4510</span>&#160;attribute. Therefore, the dynamic binding defaults to `struct ns__base *__self` when no dynamic type information in XML is available.</div><div class="line"><a name="l04511"></a><span class="lineno"> 4511</span>&#160;</div><div class="line"><a name="l04512"></a><span class="lineno"> 4512</span>&#160;Additional data and function members can be provided to extend a</div><div class="line"><a name="l04513"></a><span class="lineno"> 4513</span>&#160;generated struct or class.</div><div class="line"><a name="l04514"></a><span class="lineno"> 4514</span>&#160;Class and struct extensions are of the form:</div><div class="line"><a name="l04515"></a><span class="lineno"> 4515</span>&#160;</div><div class="line"><a name="l04516"></a><span class="lineno"> 4516</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l04517"></a><span class="lineno"> 4517</span>&#160;```xml</div><div class="line"><a name="l04518"></a><span class="lineno"> 4518</span>&#160;prefix__type = $ member-declaration</div><div class="line"><a name="l04519"></a><span class="lineno"> 4519</span>&#160;```</div><div class="line"><a name="l04520"></a><span class="lineno"> 4520</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l04521"></a><span class="lineno"> 4521</span>&#160;</div><div class="line"><a name="l04522"></a><span class="lineno"> 4522</span>&#160;For example, to add a constructor and destructor to class myns__record:</div><div class="line"><a name="l04523"></a><span class="lineno"> 4523</span>&#160;</div><div class="line"><a name="l04524"></a><span class="lineno"> 4524</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l04525"></a><span class="lineno"> 4525</span>&#160;```xml</div><div class="line"><a name="l04526"></a><span class="lineno"> 4526</span>&#160;myns__record = $ myns__record();</div><div class="line"><a name="l04527"></a><span class="lineno"> 4527</span>&#160;myns__record = $ ~myns__record();</div><div class="line"><a name="l04528"></a><span class="lineno"> 4528</span>&#160;```</div><div class="line"><a name="l04529"></a><span class="lineno"> 4529</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l04530"></a><span class="lineno"> 4530</span>&#160;</div><div class="line"><a name="l04531"></a><span class="lineno"> 4531</span>&#160;Type remappings can be given to map a type to another type:</div><div class="line"><a name="l04532"></a><span class="lineno"> 4532</span>&#160;</div><div class="line"><a name="l04533"></a><span class="lineno"> 4533</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l04534"></a><span class="lineno"> 4534</span>&#160;```xml</div><div class="line"><a name="l04535"></a><span class="lineno"> 4535</span>&#160;prefix__type1 == prefix__type2</div><div class="line"><a name="l04536"></a><span class="lineno"> 4536</span>&#160;```</div><div class="line"><a name="l04537"></a><span class="lineno"> 4537</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l04538"></a><span class="lineno"> 4538</span>&#160;</div><div class="line"><a name="l04539"></a><span class="lineno"> 4539</span>&#160;which replaces *`prefix__type1`* by *`prefix__type2`* in the wsdl2h output.</div><div class="line"><a name="l04540"></a><span class="lineno"> 4540</span>&#160;For example:</div><div class="line"><a name="l04541"></a><span class="lineno"> 4541</span>&#160;</div><div class="line"><a name="l04542"></a><span class="lineno"> 4542</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l04543"></a><span class="lineno"> 4543</span>&#160;```xml</div><div class="line"><a name="l04544"></a><span class="lineno"> 4544</span>&#160;SOAP_ENC__boolean == xsd__boolean</div><div class="line"><a name="l04545"></a><span class="lineno"> 4545</span>&#160;```</div><div class="line"><a name="l04546"></a><span class="lineno"> 4546</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l04547"></a><span class="lineno"> 4547</span>&#160;</div><div class="line"><a name="l04548"></a><span class="lineno"> 4548</span>&#160;where *`SOAP_ENC__boolean`* is mapped to *`xsd__boolean`*, which in turn may be mapped to a C *`enum xsd__boolean`* type or C++ *`bool`* type.</div><div class="line"><a name="l04549"></a><span class="lineno"> 4549</span>&#160;</div><div class="line"><a name="l04550"></a><span class="lineno"> 4550</span>&#160;# Using the soapcpp2 Compiler and Code Generator        {#soapcpp2}</div><div class="line"><a name="l04551"></a><span class="lineno"> 4551</span>&#160;</div><div class="line"><a name="l04552"></a><span class="lineno"> 4552</span>&#160;The `soapcpp2` compiler and code generator is invoked from the command line</div><div class="line"><a name="l04553"></a><span class="lineno"> 4553</span>&#160;and optionally takes the name of a header file as an argument or, when the file</div><div class="line"><a name="l04554"></a><span class="lineno"> 4554</span>&#160;name is absent, parses the standard input:</div><div class="line"><a name="l04555"></a><span class="lineno"> 4555</span>&#160;</div><div class="line"><a name="l04556"></a><span class="lineno"> 4556</span>&#160;    &gt; soapcpp2 headerfile.h</div><div class="line"><a name="l04557"></a><span class="lineno"> 4557</span>&#160;</div><div class="line"><a name="l04558"></a><span class="lineno"> 4558</span>&#160;where `aheaderfile.h` is a C/C++ header file generated by `wsdl2h` or</div><div class="line"><a name="l04559"></a><span class="lineno"> 4559</span>&#160;developed manually to specify the SOAP/XML service operations as function</div><div class="line"><a name="l04560"></a><span class="lineno"> 4560</span>&#160;prototypes and the C/C++ data types to be auto-mapped to XML.</div><div class="line"><a name="l04561"></a><span class="lineno"> 4561</span>&#160;</div><div class="line"><a name="l04562"></a><span class="lineno"> 4562</span>&#160;The `soapcpp2` tool produces C/C++ source files. These files are used to</div><div class="line"><a name="l04563"></a><span class="lineno"> 4563</span>&#160;implement SOAP/XML clients and services, and to implement the advanced XML data</div><div class="line"><a name="l04564"></a><span class="lineno"> 4564</span>&#160;binding logic to convert C/C++ data into XML and vice versa.</div><div class="line"><a name="l04565"></a><span class="lineno"> 4565</span>&#160;</div><div class="line"><a name="l04566"></a><span class="lineno"> 4566</span>&#160;The type of files generated by `soapcpp2` are:</div><div class="line"><a name="l04567"></a><span class="lineno"> 4567</span>&#160;</div><div class="line"><a name="l04568"></a><span class="lineno"> 4568</span>&#160;* `soapStub.h`  A modified and annotated header file produced from the input header file </div><div class="line"><a name="l04569"></a><span class="lineno"> 4569</span>&#160;</div><div class="line"><a name="l04570"></a><span class="lineno"> 4570</span>&#160;* `soapH.h`  Main header file to be included by all client and service sources </div><div class="line"><a name="l04571"></a><span class="lineno"> 4571</span>&#160;</div><div class="line"><a name="l04572"></a><span class="lineno"> 4572</span>&#160;* `soapC.cpp` Serializers and deserializers for the specified data structures </div><div class="line"><a name="l04573"></a><span class="lineno"> 4573</span>&#160;</div><div class="line"><a name="l04574"></a><span class="lineno"> 4574</span>&#160;* `soapClient.cpp` Client stub routines for remote operations </div><div class="line"><a name="l04575"></a><span class="lineno"> 4575</span>&#160;</div><div class="line"><a name="l04576"></a><span class="lineno"> 4576</span>&#160;* `soapServer.cpp` Service skeleton routines </div><div class="line"><a name="l04577"></a><span class="lineno"> 4577</span>&#160;</div><div class="line"><a name="l04578"></a><span class="lineno"> 4578</span>&#160;* `soapClientLib.cpp` Client stubs combined with local static (de)serializers </div><div class="line"><a name="l04579"></a><span class="lineno"> 4579</span>&#160;</div><div class="line"><a name="l04580"></a><span class="lineno"> 4580</span>&#160;* `soapServerLib.cpp` Service skeletons combined with local static (de)serializers </div><div class="line"><a name="l04581"></a><span class="lineno"> 4581</span>&#160;</div><div class="line"><a name="l04582"></a><span class="lineno"> 4582</span>&#160;* `soapXYZProxy.h` A C++ proxy object (link with soapC.cpp soapClient.cpp) </div><div class="line"><a name="l04583"></a><span class="lineno"> 4583</span>&#160;</div><div class="line"><a name="l04584"></a><span class="lineno"> 4584</span>&#160;* `soapXYZProxy.h` With option -i: proxy object (link with soapC.cpp and soapXYZProxy.cpp) </div><div class="line"><a name="l04585"></a><span class="lineno"> 4585</span>&#160;</div><div class="line"><a name="l04586"></a><span class="lineno"> 4586</span>&#160;* `soapXYZProxy.cpp` With option -i: proxy code </div><div class="line"><a name="l04587"></a><span class="lineno"> 4587</span>&#160;</div><div class="line"><a name="l04588"></a><span class="lineno"> 4588</span>&#160;* `soapXYZObject.h` A C++ server object (link with soapC.cpp and soapServer.cpp) </div><div class="line"><a name="l04589"></a><span class="lineno"> 4589</span>&#160;</div><div class="line"><a name="l04590"></a><span class="lineno"> 4590</span>&#160;* `soapXYZService.h` With option -i: server object (link with soapC.cpp and soapXYZService.cpp) </div><div class="line"><a name="l04591"></a><span class="lineno"> 4591</span>&#160;</div><div class="line"><a name="l04592"></a><span class="lineno"> 4592</span>&#160;* `soapXYZService.cpp` With option -i: server code </div><div class="line"><a name="l04593"></a><span class="lineno"> 4593</span>&#160;</div><div class="line"><a name="l04594"></a><span class="lineno"> 4594</span>&#160;* `.xsd` An `ns.xsd` file is generated with an XML Schema for each namespace prefix `ns` used by a data structure in the header file input to the compiler, see Section \ref wsdl  </div><div class="line"><a name="l04595"></a><span class="lineno"> 4595</span>&#160;</div><div class="line"><a name="l04596"></a><span class="lineno"> 4596</span>&#160;* `.wsdl` A `ns.wsdl` file is generated with an WSDL description for each namespace prefix `ns` used by a service operation in the header file input to the compiler, see Section \ref wsdl  </div><div class="line"><a name="l04597"></a><span class="lineno"> 4597</span>&#160;</div><div class="line"><a name="l04598"></a><span class="lineno"> 4598</span>&#160;* `.xml` Several SOAP/XML request and response files are generated. These are example message files are valid provided that sufficient schema namespace directives are added to the header file or the generated .nsmap namespace table for the</div><div class="line"><a name="l04599"></a><span class="lineno"> 4599</span>&#160;client/service is not modified by hand </div><div class="line"><a name="l04600"></a><span class="lineno"> 4600</span>&#160;</div><div class="line"><a name="l04601"></a><span class="lineno"> 4601</span>&#160;* `.nsmap` A `ns.nsmap` file is generated for each namespace prefix `ns` used by a service operation in the header file input to the compiler, see Section \ref wsdl .  The file contains a namespace mapping table that can be used in the client/service sources </div><div class="line"><a name="l04602"></a><span class="lineno"> 4602</span>&#160;</div><div class="line"><a name="l04603"></a><span class="lineno"> 4603</span>&#160;Both client and service applications are developed from a header file that</div><div class="line"><a name="l04604"></a><span class="lineno"> 4604</span>&#160;specifies the service operations. If client and service applications are</div><div class="line"><a name="l04605"></a><span class="lineno"> 4605</span>&#160;developed with the same header file, the applications are guaranteed to be</div><div class="line"><a name="l04606"></a><span class="lineno"> 4606</span>&#160;compatible because the stub and skeleton routines use the same serializers and</div><div class="line"><a name="l04607"></a><span class="lineno"> 4607</span>&#160;deserializers to encode and decode the parameters. Note that when client and</div><div class="line"><a name="l04608"></a><span class="lineno"> 4608</span>&#160;service applications are developed together, an application developer does not</div><div class="line"><a name="l04609"></a><span class="lineno"> 4609</span>&#160;need to know the details of the internal SOAP encoding used by the client and</div><div class="line"><a name="l04610"></a><span class="lineno"> 4610</span>&#160;service.</div><div class="line"><a name="l04611"></a><span class="lineno"> 4611</span>&#160;</div><div class="line"><a name="l04612"></a><span class="lineno"> 4612</span>&#160;The `soapClientLib.cpp` and `soapServerLib.cpp` can be used to build (dynamic) client and server libraries. The serialization routines are local (static) to avoid link symbol conflicts. You must create a separate library for SOAP Header and Fault handling, as described in Section \ref dylibs .</div><div class="line"><a name="l04613"></a><span class="lineno"> 4613</span>&#160;</div><div class="line"><a name="l04614"></a><span class="lineno"> 4614</span>&#160;The following files are part of the gSOAP package and are required to build client and service applications:</div><div class="line"><a name="l04615"></a><span class="lineno"> 4615</span>&#160;</div><div class="line"><a name="l04616"></a><span class="lineno"> 4616</span>&#160;* `stdsoap2.h` Header file of `stdsoap2.cpp` runtime library </div><div class="line"><a name="l04617"></a><span class="lineno"> 4617</span>&#160;</div><div class="line"><a name="l04618"></a><span class="lineno"> 4618</span>&#160;* `stdsoap2.c` Runtime C library with XML parser and run-time support routines </div><div class="line"><a name="l04619"></a><span class="lineno"> 4619</span>&#160;</div><div class="line"><a name="l04620"></a><span class="lineno"> 4620</span>&#160;* `stdsoap2.cpp` Runtime C++ library identical to `stdsoap2.c` </div><div class="line"><a name="l04621"></a><span class="lineno"> 4621</span>&#160;</div><div class="line"><a name="l04622"></a><span class="lineno"> 4622</span>&#160;## soapcpp2 Options        {#options}</div><div class="line"><a name="l04623"></a><span class="lineno"> 4623</span>&#160;</div><div class="line"><a name="l04624"></a><span class="lineno"> 4624</span>&#160;The `soapcpp2` source-to-source compiler supports the following command-line options:</div><div class="line"><a name="l04625"></a><span class="lineno"> 4625</span>&#160;</div><div class="line"><a name="l04626"></a><span class="lineno"> 4626</span>&#160;option      | result</div><div class="line"><a name="l04627"></a><span class="lineno"> 4627</span>&#160;----------- | ------</div><div class="line"><a name="l04628"></a><span class="lineno"> 4628</span>&#160;`-1`        | generate SOAP 1.1 bindings </div><div class="line"><a name="l04629"></a><span class="lineno"> 4629</span>&#160;`-2`        | generate SOAP 1.2 bindings </div><div class="line"><a name="l04630"></a><span class="lineno"> 4630</span>&#160;`-0`        | no SOAP bindings, use REST</div><div class="line"><a name="l04631"></a><span class="lineno"> 4631</span>&#160;`-C`        | generate client-side code only </div><div class="line"><a name="l04632"></a><span class="lineno"> 4632</span>&#160;`-S`        | generate server-side code only </div><div class="line"><a name="l04633"></a><span class="lineno"> 4633</span>&#160;`-T`        | generate server auto-test code </div><div class="line"><a name="l04634"></a><span class="lineno"> 4634</span>&#160;`-Ec`       | generate extra routines for deep data copying </div><div class="line"><a name="l04635"></a><span class="lineno"> 4635</span>&#160;`-Ed`       | generate extra routines for deep data deletion </div><div class="line"><a name="l04636"></a><span class="lineno"> 4636</span>&#160;`-Et`       | generate extra routines for data traversals with walker functions </div><div class="line"><a name="l04637"></a><span class="lineno"> 4637</span>&#160;`-L`        | do not generate soapClientLib/soapServerLib </div><div class="line"><a name="l04638"></a><span class="lineno"> 4638</span>&#160;`-a`        | use SOAPAction with WS-Addressing to invoke server-side operations </div><div class="line"><a name="l04639"></a><span class="lineno"> 4639</span>&#160;`-A`        | require SOAPAction to invoke server-side operations </div><div class="line"><a name="l04640"></a><span class="lineno"> 4640</span>&#160;`-b`        | serialize byte arrays `char[N]` as string </div><div class="line"><a name="l04641"></a><span class="lineno"> 4641</span>&#160;`-c`        | generate pure C code </div><div class="line"><a name="l04642"></a><span class="lineno"> 4642</span>&#160;`-d &lt;path&gt;` | save sources in directory specified by `&lt;path&gt;` </div><div class="line"><a name="l04643"></a><span class="lineno"> 4643</span>&#160;`-e`        | generate SOAP RPC encoding style bindings </div><div class="line"><a name="l04644"></a><span class="lineno"> 4644</span>&#160;`-f N`      | multiple soapC files, with N serializer definitions per file (N&gt;=10) </div><div class="line"><a name="l04645"></a><span class="lineno"> 4645</span>&#160;`-h`        | print a brief usage message </div><div class="line"><a name="l04646"></a><span class="lineno"> 4646</span>&#160;`-i`        | generate service proxies and objects inherited from soap struct </div><div class="line"><a name="l04647"></a><span class="lineno"> 4647</span>&#160;`-j`        | generate C++ service proxies and objects that can share a soap struct </div><div class="line"><a name="l04648"></a><span class="lineno"> 4648</span>&#160;`-I &lt;path&gt;` | use `&lt;path&gt;` for `#import` (paths separated with &#39;:&#39; or &#39;;&#39; for windows) </div><div class="line"><a name="l04649"></a><span class="lineno"> 4649</span>&#160;`-l`        | generate linkable modules (experimental) </div><div class="line"><a name="l04650"></a><span class="lineno"> 4650</span>&#160;`-m`        | generate Matlab code for MEX compiler </div><div class="line"><a name="l04651"></a><span class="lineno"> 4651</span>&#160;`-n`        | when used with `-p`, enables multi-client and multi-server builds: sets compiler option `WITH_NONAMESPACES`, see Section \ref compilerflags saves the namespace mapping table with name `&lt;name&gt;_namespaces` instead of `namespaces` </div><div class="line"><a name="l04652"></a><span class="lineno"> 4652</span>&#160;            | renames `soap_serve()` into `&lt;name&gt;_serve()` and `soap_destroy()` into `&lt;name&gt;_destroy()` </div><div class="line"><a name="l04653"></a><span class="lineno"> 4653</span>&#160;`-p &lt;name&gt;` | save sources with file name prefix `&lt;name&gt;` instead of &quot;`soap`&quot; </div><div class="line"><a name="l04654"></a><span class="lineno"> 4654</span>&#160;`-q &lt;name&gt;` | use `name` for the C++ namespace of all declarations </div><div class="line"><a name="l04655"></a><span class="lineno"> 4655</span>&#160;`-r`        | generate soapReadme.md report </div><div class="line"><a name="l04656"></a><span class="lineno"> 4656</span>&#160;`-s`        | generates deserialization code with strict XML validation checks </div><div class="line"><a name="l04657"></a><span class="lineno"> 4657</span>&#160;`-t`        | generates code to send typed messages (with the *`xsi:type`* attribute) </div><div class="line"><a name="l04658"></a><span class="lineno"> 4658</span>&#160;`-u`        | uncomment comments in WSDL/schema output by suppressing XML comments </div><div class="line"><a name="l04659"></a><span class="lineno"> 4659</span>&#160;`-V`        | display the current version and exit</div><div class="line"><a name="l04660"></a><span class="lineno"> 4660</span>&#160;`-v`        | verbose output </div><div class="line"><a name="l04661"></a><span class="lineno"> 4661</span>&#160;`-w`        | do not generate WSDL and schema files </div><div class="line"><a name="l04662"></a><span class="lineno"> 4662</span>&#160;`-x`        | do not generate sample XML message files </div><div class="line"><a name="l04663"></a><span class="lineno"> 4663</span>&#160;`-y`        | include C/C++ type access information in sample XML messages </div><div class="line"><a name="l04664"></a><span class="lineno"> 4664</span>&#160;`-z1`       | compatibility: generate old-style C++ service proxies and objects </div><div class="line"><a name="l04665"></a><span class="lineno"> 4665</span>&#160;`-z2`       | compatibility with 2.7.x: omit XML output for NULL pointers </div><div class="line"><a name="l04666"></a><span class="lineno"> 4666</span>&#160;`-z3`       | compatibility with 2.8.30 and earlier: _param_N is indexed globally </div><div class="line"><a name="l04667"></a><span class="lineno"> 4667</span>&#160;</div><div class="line"><a name="l04668"></a><span class="lineno"> 4668</span>&#160;For example</div><div class="line"><a name="l04669"></a><span class="lineno"> 4669</span>&#160;</div><div class="line"><a name="l04670"></a><span class="lineno"> 4670</span>&#160;    &gt; soapcpp2 -c -d &#39;projects&#39; -pmy file.h</div><div class="line"><a name="l04671"></a><span class="lineno"> 4671</span>&#160;</div><div class="line"><a name="l04672"></a><span class="lineno"> 4672</span>&#160;Saves the sources:</div><div class="line"><a name="l04673"></a><span class="lineno"> 4673</span>&#160;</div><div class="line"><a name="l04674"></a><span class="lineno"> 4674</span>&#160;* `projects/myH.h` </div><div class="line"><a name="l04675"></a><span class="lineno"> 4675</span>&#160;</div><div class="line"><a name="l04676"></a><span class="lineno"> 4676</span>&#160;* `projects/myC.c` </div><div class="line"><a name="l04677"></a><span class="lineno"> 4677</span>&#160;</div><div class="line"><a name="l04678"></a><span class="lineno"> 4678</span>&#160;* `projects/myClient.c` </div><div class="line"><a name="l04679"></a><span class="lineno"> 4679</span>&#160;</div><div class="line"><a name="l04680"></a><span class="lineno"> 4680</span>&#160;* `projects/myServer.c` </div><div class="line"><a name="l04681"></a><span class="lineno"> 4681</span>&#160;</div><div class="line"><a name="l04682"></a><span class="lineno"> 4682</span>&#160;* `projects/myStub.h` </div><div class="line"><a name="l04683"></a><span class="lineno"> 4683</span>&#160;</div><div class="line"><a name="l04684"></a><span class="lineno"> 4684</span>&#160;MS Windows users can use the usual &quot;`/`&quot; for options, for example:</div><div class="line"><a name="l04685"></a><span class="lineno"> 4685</span>&#160;</div><div class="line"><a name="l04686"></a><span class="lineno"> 4686</span>&#160;    soapcpp2 /cd &#39;..\projects&#39; /pmy file.h</div><div class="line"><a name="l04687"></a><span class="lineno"> 4687</span>&#160;</div><div class="line"><a name="l04688"></a><span class="lineno"> 4688</span>&#160;Compiler options `c, i, n, l, w` can be set in the gSOAP header file using the `//gsoapopt` directive. For example,</div><div class="line"><a name="l04689"></a><span class="lineno"> 4689</span>&#160;</div><div class="line"><a name="l04690"></a><span class="lineno"> 4690</span>&#160;```cpp</div><div class="line"><a name="l04691"></a><span class="lineno"> 4691</span>&#160;// Generate pure C and do not produce WSDL output: </div><div class="line"><a name="l04692"></a><span class="lineno"> 4692</span>&#160;//gsoapopt cw </div><div class="line"><a name="l04693"></a><span class="lineno"> 4693</span>&#160;int ns__myMethod(char*, char**); // takes a string and returns a string (as pointed to)</div><div class="line"><a name="l04694"></a><span class="lineno"> 4694</span>&#160;```</div><div class="line"><a name="l04695"></a><span class="lineno"> 4695</span>&#160;</div><div class="line"><a name="l04696"></a><span class="lineno"> 4696</span>&#160;## SOAP 1.1 Versus SOAP 1.2 and Dynamic Switching</div><div class="line"><a name="l04697"></a><span class="lineno"> 4697</span>&#160;</div><div class="line"><a name="l04698"></a><span class="lineno"> 4698</span>&#160;gSOAP supports SOAP 1.1 by default. SOAP 1.2 support is automatically turned on when the appropriate SOAP 1.2 namespace is used, which shows up in</div><div class="line"><a name="l04699"></a><span class="lineno"> 4699</span>&#160;the namespace mapping table:</div><div class="line"><a name="l04700"></a><span class="lineno"> 4700</span>&#160;</div><div class="line"><a name="l04701"></a><span class="lineno"> 4701</span>&#160;```cpp</div><div class="line"><a name="l04702"></a><span class="lineno"> 4702</span>&#160;struct Namespace namespaces[] = </div><div class="line"><a name="l04703"></a><span class="lineno"> 4703</span>&#160;{ </div><div class="line"><a name="l04704"></a><span class="lineno"> 4704</span>&#160;   {&quot;SOAP-ENV&quot;, &quot;http://www.w3.org/2003/05/soap-envelope&quot;, ... }, </div><div class="line"><a name="l04705"></a><span class="lineno"> 4705</span>&#160;   {&quot;SOAP-ENC&quot;, &quot;http://www.w3.org/2003/05/soap-encoding, ... &quot;}, </div><div class="line"><a name="l04706"></a><span class="lineno"> 4706</span>&#160;   ... </div><div class="line"><a name="l04707"></a><span class="lineno"> 4707</span>&#160;}</div><div class="line"><a name="l04708"></a><span class="lineno"> 4708</span>&#160;```</div><div class="line"><a name="l04709"></a><span class="lineno"> 4709</span>&#160;</div><div class="line"><a name="l04710"></a><span class="lineno"> 4710</span>&#160;Normally the `soapcpp2`-generated namespace table allows dynamic switching between SOAP 1.1 to SOAP 1.2 by providing the SOAP 1.2 namespace</div><div class="line"><a name="l04711"></a><span class="lineno"> 4711</span>&#160;as a **pattern** in the third column of a namespace table:</div><div class="line"><a name="l04712"></a><span class="lineno"> 4712</span>&#160;</div><div class="line"><a name="l04713"></a><span class="lineno"> 4713</span>&#160;```cpp</div><div class="line"><a name="l04714"></a><span class="lineno"> 4714</span>&#160;struct Namespace namespaces[] = </div><div class="line"><a name="l04715"></a><span class="lineno"> 4715</span>&#160;{ </div><div class="line"><a name="l04716"></a><span class="lineno"> 4716</span>&#160;   {&quot;SOAP-ENV&quot;, &quot;http://schemas.xmlsoap.org/soap/envelope/&quot;, &quot;http://www.w3.org/*/soap-encoding&quot;}, </div><div class="line"><a name="l04717"></a><span class="lineno"> 4717</span>&#160;   {&quot;SOAP-ENC&quot;, &quot;http://schemas.xmlsoap.org/soap/encoding/&quot;, &quot;http://www.w3.org/*/soap-envelope&quot;}, </div><div class="line"><a name="l04718"></a><span class="lineno"> 4718</span>&#160;   ... </div><div class="line"><a name="l04719"></a><span class="lineno"> 4719</span>&#160;}</div><div class="line"><a name="l04720"></a><span class="lineno"> 4720</span>&#160;```</div><div class="line"><a name="l04721"></a><span class="lineno"> 4721</span>&#160;</div><div class="line"><a name="l04722"></a><span class="lineno"> 4722</span>&#160;where the &quot;`*`&quot; in the third column of the namespace URI pattern is a meta wildcard. This is used to match and accept inbound namespaces.</div><div class="line"><a name="l04723"></a><span class="lineno"> 4723</span>&#160;</div><div class="line"><a name="l04724"></a><span class="lineno"> 4724</span>&#160;This way, gSOAP Web services can respond to either SOAP 1.1 or SOAP 1.2 requests.  gSOAP will automatically return SOAP 1.2 responses for SOAP 1.2 requests.</div><div class="line"><a name="l04725"></a><span class="lineno"> 4725</span>&#160;</div><div class="line"><a name="l04726"></a><span class="lineno"> 4726</span>&#160;The gSOAP `soapcpp2` tool generates a `.nsmap` file with `SOAP-ENV` and `SOAP-ENC` namespace patterns similar to the above.</div><div class="line"><a name="l04727"></a><span class="lineno"> 4727</span>&#160;Since clients issue a send first, they will always use SOAP 1.1 for requests when the namespace table is similar as shown above.</div><div class="line"><a name="l04728"></a><span class="lineno"> 4728</span>&#160;Clients can accept SOAP 1.2 responses by inspecting the response message.</div><div class="line"><a name="l04729"></a><span class="lineno"> 4729</span>&#160;</div><div class="line"><a name="l04730"></a><span class="lineno"> 4730</span>&#160;To use SOAP 1.2 by default and allow SOAP 1.1 messages to be received, use the `soapcpp2 -2` option to generate SOAP 1.2 conformant `.nsmap` and `.wsdl` files. Alternatively, add the following line to your service definitions header file (generated by `wsdl2h`) for `soapcpp2`:</div><div class="line"><a name="l04731"></a><span class="lineno"> 4731</span>&#160;</div><div class="line"><a name="l04732"></a><span class="lineno"> 4732</span>&#160;```cpp</div><div class="line"><a name="l04733"></a><span class="lineno"> 4733</span>&#160;#import &quot;import/soap12.h&quot;</div><div class="line"><a name="l04734"></a><span class="lineno"> 4734</span>&#160;```</div><div class="line"><a name="l04735"></a><span class="lineno"> 4735</span>&#160;</div><div class="line"><a name="l04736"></a><span class="lineno"> 4736</span>&#160;@warning SOAP 1.2 does not support partially transmitted arrays. So the `__offset` field of a dynamic array is meaningless.</div><div class="line"><a name="l04737"></a><span class="lineno"> 4737</span>&#160;</div><div class="line"><a name="l04738"></a><span class="lineno"> 4738</span>&#160;@warning SOAP 1.2 requires the use of `SOAP_ENV__Code`, `SOAP_ENV__Reason`, and `SOAP_ENV__Detail` fields</div><div class="line"><a name="l04739"></a><span class="lineno"> 4739</span>&#160;in a `SOAP_ENV__Fault` fault struct, while SOAP 1.1 uses `faultcode`, `faultstring`, and `detail` fields.</div><div class="line"><a name="l04740"></a><span class="lineno"> 4740</span>&#160;Use `soap_receiver_fault_subcode(struct soap *soap, const char *subcode, const char *faultstring, const char *detail)` to set a SOAP 1.1/1.2</div><div class="line"><a name="l04741"></a><span class="lineno"> 4741</span>&#160;fault at the server-side with a fault subcode (SOAP 1.2).</div><div class="line"><a name="l04742"></a><span class="lineno"> 4742</span>&#160;Use `soap_sender_fault_subcode(struct soap *soap, const char *subcode, const char *faultstring, const char *detail)` to set a SOAP 1.1/1.2</div><div class="line"><a name="l04743"></a><span class="lineno"> 4743</span>&#160;unrecoverable Bad Request fault at the server-side with a fault subcode (SOAP 1.2).</div><div class="line"><a name="l04744"></a><span class="lineno"> 4744</span>&#160;</div><div class="line"><a name="l04745"></a><span class="lineno"> 4745</span>&#160;## The soapdefs.h Header File        {#soapdefs}</div><div class="line"><a name="l04746"></a><span class="lineno"> 4746</span>&#160;</div><div class="line"><a name="l04747"></a><span class="lineno"> 4747</span>&#160;The `soapdefs.h` header file is included in `stdsoap2.h` when compiling with option `-DWITH_SOAPDEFS_H`:</div><div class="line"><a name="l04748"></a><span class="lineno"> 4748</span>&#160;</div><div class="line"><a name="l04749"></a><span class="lineno"> 4749</span>&#160;    &gt; c++ -DWITH_SOAPDEFS_H -c stdsoap2.cpp</div><div class="line"><a name="l04750"></a><span class="lineno"> 4750</span>&#160;</div><div class="line"><a name="l04751"></a><span class="lineno"> 4751</span>&#160;The `soapdefs.h` file allows users to include definitions and add includes without requiring changes to `stdsoap2.h`. You can also specify the header file name to include as a macro `SOAPDEFS_h` to override the name `soapdefs.h`:</div><div class="line"><a name="l04752"></a><span class="lineno"> 4752</span>&#160;</div><div class="line"><a name="l04753"></a><span class="lineno"> 4753</span>&#160;    &gt; c++ -DSOAPDEFS_H=mydefs.h -c stdsoap2.cpp</div><div class="line"><a name="l04754"></a><span class="lineno"> 4754</span>&#160;</div><div class="line"><a name="l04755"></a><span class="lineno"> 4755</span>&#160;For example,</div><div class="line"><a name="l04756"></a><span class="lineno"> 4756</span>&#160;</div><div class="line"><a name="l04757"></a><span class="lineno"> 4757</span>&#160;```cpp</div><div class="line"><a name="l04758"></a><span class="lineno"> 4758</span>&#160;// Contents of soapdefs.h </div><div class="line"><a name="l04759"></a><span class="lineno"> 4759</span>&#160;#include &lt;ostream&gt; </div><div class="line"><a name="l04760"></a><span class="lineno"> 4760</span>&#160;#define SOAP_BUFLEN 65536 // use large send/recv buffer </div><div class="line"><a name="l04761"></a><span class="lineno"> 4761</span>&#160;```</div><div class="line"><a name="l04762"></a><span class="lineno"> 4762</span>&#160;</div><div class="line"><a name="l04763"></a><span class="lineno"> 4763</span>&#160;The following header file can now refer to `ostream`:</div><div class="line"><a name="l04764"></a><span class="lineno"> 4764</span>&#160;</div><div class="line"><a name="l04765"></a><span class="lineno"> 4765</span>&#160;```cpp</div><div class="line"><a name="l04766"></a><span class="lineno"> 4766</span>&#160;extern class ostream; // ostream can&#39;t be (de)serialized, but need to be declared to make it visible to gSOAP </div><div class="line"><a name="l04767"></a><span class="lineno"> 4767</span>&#160;class ns__myClass </div><div class="line"><a name="l04768"></a><span class="lineno"> 4768</span>&#160;{ ... </div><div class="line"><a name="l04769"></a><span class="lineno"> 4769</span>&#160;   virtual void print(ostream &amp;s) const; // need ostream here </div><div class="line"><a name="l04770"></a><span class="lineno"> 4770</span>&#160;   ... </div><div class="line"><a name="l04771"></a><span class="lineno"> 4771</span>&#160;};</div><div class="line"><a name="l04772"></a><span class="lineno"> 4772</span>&#160;```</div><div class="line"><a name="l04773"></a><span class="lineno"> 4773</span>&#160;</div><div class="line"><a name="l04774"></a><span class="lineno"> 4774</span>&#160;See also Section \ref transient .</div><div class="line"><a name="l04775"></a><span class="lineno"> 4775</span>&#160;</div><div class="line"><a name="l04776"></a><span class="lineno"> 4776</span>&#160;## How to Build Modules and Libraries with the #module Directive        {#module}</div><div class="line"><a name="l04777"></a><span class="lineno"> 4777</span>&#160;</div><div class="line"><a name="l04778"></a><span class="lineno"> 4778</span>&#160;The `#module` directive is used to build modules. A library can be built from a module and linked with multiple Web services applications. The directive should appear at the top of the header file and has the following formats:</div><div class="line"><a name="l04779"></a><span class="lineno"> 4779</span>&#160;</div><div class="line"><a name="l04780"></a><span class="lineno"> 4780</span>&#160;```cpp</div><div class="line"><a name="l04781"></a><span class="lineno"> 4781</span>&#160;#module &quot;name&quot; </div><div class="line"><a name="l04782"></a><span class="lineno"> 4782</span>&#160;```</div><div class="line"><a name="l04783"></a><span class="lineno"> 4783</span>&#160;</div><div class="line"><a name="l04784"></a><span class="lineno"> 4784</span>&#160;and</div><div class="line"><a name="l04785"></a><span class="lineno"> 4785</span>&#160;</div><div class="line"><a name="l04786"></a><span class="lineno"> 4786</span>&#160;```cpp</div><div class="line"><a name="l04787"></a><span class="lineno"> 4787</span>&#160;#module &quot;name&quot; &quot;fullname&quot;</div><div class="line"><a name="l04788"></a><span class="lineno"> 4788</span>&#160;```</div><div class="line"><a name="l04789"></a><span class="lineno"> 4789</span>&#160;</div><div class="line"><a name="l04790"></a><span class="lineno"> 4790</span>&#160;where *name* must be a unique short name for the module. The name is case insensitive and MUST not exceed 4 characters in length. The *fullname*, when present, represents the full name of the module.</div><div class="line"><a name="l04791"></a><span class="lineno"> 4791</span>&#160;</div><div class="line"><a name="l04792"></a><span class="lineno"> 4792</span>&#160;The rest of the content of the header file includes type declarations and optionally the declarations of service operations and SOAP Headers/Faults. When the gSOAP `soapcpp2` compiler processes the header file module, it will generate the source codes for a library. The Web services application that uses the library should use a header file that imports the module with the `#import` directive.</div><div class="line"><a name="l04793"></a><span class="lineno"> 4793</span>&#160;</div><div class="line"><a name="l04794"></a><span class="lineno"> 4794</span>&#160;For example:</div><div class="line"><a name="l04795"></a><span class="lineno"> 4795</span>&#160;</div><div class="line"><a name="l04796"></a><span class="lineno"> 4796</span>&#160;```cpp</div><div class="line"><a name="l04797"></a><span class="lineno"> 4797</span>&#160;/* Contents of module.h */ </div><div class="line"><a name="l04798"></a><span class="lineno"> 4798</span>&#160;#module &quot;test&quot;</div><div class="line"><a name="l04799"></a><span class="lineno"> 4799</span>&#160;long; </div><div class="line"><a name="l04800"></a><span class="lineno"> 4800</span>&#160;char*; </div><div class="line"><a name="l04801"></a><span class="lineno"> 4801</span>&#160;struct ns__S </div><div class="line"><a name="l04802"></a><span class="lineno"> 4802</span>&#160;{ ... }</div><div class="line"><a name="l04803"></a><span class="lineno"> 4803</span>&#160;```</div><div class="line"><a name="l04804"></a><span class="lineno"> 4804</span>&#160;</div><div class="line"><a name="l04805"></a><span class="lineno"> 4805</span>&#160;The `module.h` header file declares a long, char*, and a `struct ns__X`. The module name is &quot;test&quot;, so the gSOAP `soapcpp2` compiler produces a `testC.cpp` file with the (de)serializers for these types. The `testC.cpp` library can be separately compiled and linked with an application that is built from a header file that imports &quot;module.h&quot; using `#import &quot;module.h&quot;`. You should also compile `testClient.cpp` when you want to build a library that includes the service operations that you defined in the module header file.</div><div class="line"><a name="l04806"></a><span class="lineno"> 4806</span>&#160;</div><div class="line"><a name="l04807"></a><span class="lineno"> 4807</span>&#160;There are some limitations on a sequence of module imports. A module MUST be imported into another header to use the module content and you MUST place this import statement before all other statements in the file, including other imports (except when these are also modules). It is also advised to put all basic data type definitions in the root module of a module import hierarchy, e.g. using `typedef` to declare XSD types (see also Section \ref primitive ).</div><div class="line"><a name="l04808"></a><span class="lineno"> 4808</span>&#160;</div><div class="line"><a name="l04809"></a><span class="lineno"> 4809</span>&#160;You cannot use a module alone to build a SOAP or XML application. That is, the final gSOAP header file in the import chain SHOULD NOT be a module.</div><div class="line"><a name="l04810"></a><span class="lineno"> 4810</span>&#160;</div><div class="line"><a name="l04811"></a><span class="lineno"> 4811</span>&#160;When multiple modules are linked, the types that they declare MUST be declared in one module only to avoid name clashes and link errors. You cannot create two modules that share the same type declaration and link the modules. When necessary, you should consider creating a module hierarchy such that types are declared only once and by only one module when these modules must be linked.</div><div class="line"><a name="l04812"></a><span class="lineno"> 4812</span>&#160;</div><div class="line"><a name="l04813"></a><span class="lineno"> 4813</span>&#160;## How to use the #import Directive        {#import}</div><div class="line"><a name="l04814"></a><span class="lineno"> 4814</span>&#160;</div><div class="line"><a name="l04815"></a><span class="lineno"> 4815</span>&#160;The `#import` directive is used to include gSOAP header files into other gSOAP header files for processing with</div><div class="line"><a name="l04816"></a><span class="lineno"> 4816</span>&#160;the gSOAP compiler `soapcpp2`.</div><div class="line"><a name="l04817"></a><span class="lineno"> 4817</span>&#160;The C `#include` directive cannot be used to include gSOAP header files.</div><div class="line"><a name="l04818"></a><span class="lineno"> 4818</span>&#160;The `#include` directive is reserved to control the post-gSOAP compilation process, see \ref pragmas .</div><div class="line"><a name="l04819"></a><span class="lineno"> 4819</span>&#160;</div><div class="line"><a name="l04820"></a><span class="lineno"> 4820</span>&#160;The `#import` directive is used for two purposes: you can use it to include the contents of a header file into another header file and you can use it to import a module, see \ref module .</div><div class="line"><a name="l04821"></a><span class="lineno"> 4821</span>&#160;</div><div class="line"><a name="l04822"></a><span class="lineno"> 4822</span>&#160;An example of the `#import` directive:</div><div class="line"><a name="l04823"></a><span class="lineno"> 4823</span>&#160;</div><div class="line"><a name="l04824"></a><span class="lineno"> 4824</span>&#160;```cpp</div><div class="line"><a name="l04825"></a><span class="lineno"> 4825</span>&#160;#import &quot;mydefs.gsoap&quot; </div><div class="line"><a name="l04826"></a><span class="lineno"> 4826</span>&#160;int ns__mymethod(xsd__string in, xsd__int *out);</div><div class="line"><a name="l04827"></a><span class="lineno"> 4827</span>&#160;```</div><div class="line"><a name="l04828"></a><span class="lineno"> 4828</span>&#160;</div><div class="line"><a name="l04829"></a><span class="lineno"> 4829</span>&#160;where `&quot;mydefs.gsoap&quot;` is a gSOAP header file that defines `xsd__string` and `xsd__int`:</div><div class="line"><a name="l04830"></a><span class="lineno"> 4830</span>&#160;</div><div class="line"><a name="l04831"></a><span class="lineno"> 4831</span>&#160;```cpp</div><div class="line"><a name="l04832"></a><span class="lineno"> 4832</span>&#160;typedef char *xsd__string; </div><div class="line"><a name="l04833"></a><span class="lineno"> 4833</span>&#160;typedef int xsd__int;</div><div class="line"><a name="l04834"></a><span class="lineno"> 4834</span>&#160;```</div><div class="line"><a name="l04835"></a><span class="lineno"> 4835</span>&#160;</div><div class="line"><a name="l04836"></a><span class="lineno"> 4836</span>&#160;When importing a module, where the module content is declared with `#module`, then note that this module MUST place the import statement before all other statements in the header file, including other imports (except when these are also modules).</div><div class="line"><a name="l04837"></a><span class="lineno"> 4837</span>&#160;</div><div class="line"><a name="l04838"></a><span class="lineno"> 4838</span>&#160;## How to Use #include and #define Directives        {#pragmas}</div><div class="line"><a name="l04839"></a><span class="lineno"> 4839</span>&#160;</div><div class="line"><a name="l04840"></a><span class="lineno"> 4840</span>&#160;The `#include` and `#define` directives are normally ignored by the gSOAP `soapcpp2` compiler and just passed on to the generated code.</div><div class="line"><a name="l04841"></a><span class="lineno"> 4841</span>&#160;Thus, the gSOAP compiler will not actually parse the contents of the header files provided by the `#include` directives in a header file.</div><div class="line"><a name="l04842"></a><span class="lineno"> 4842</span>&#160;Instead, the `#include` and `#define` directives will be added to the generated `soapH.h` header file **before**</div><div class="line"><a name="l04843"></a><span class="lineno"> 4843</span>&#160;any other header file is included. Therefore, `#include` and `#define` directives can be used to control the C/C++</div><div class="line"><a name="l04844"></a><span class="lineno"> 4844</span>&#160;compilation process of the sources of an application. However, they have no effect on `soapcpp2`.</div><div class="line"><a name="l04845"></a><span class="lineno"> 4845</span>&#160;</div><div class="line"><a name="l04846"></a><span class="lineno"> 4846</span>&#160;The following example header file refers to `ostream` by including `&lt;ostream&gt;`:</div><div class="line"><a name="l04847"></a><span class="lineno"> 4847</span>&#160;</div><div class="line"><a name="l04848"></a><span class="lineno"> 4848</span>&#160;```cpp</div><div class="line"><a name="l04849"></a><span class="lineno"> 4849</span>&#160;#include &lt;ostream&gt; </div><div class="line"><a name="l04850"></a><span class="lineno"> 4850</span>&#160;#define WITH_COOKIES // use HTTP cookie support (you must compile stdsoap2.cpp with -DWITH_COOKIES) </div><div class="line"><a name="l04851"></a><span class="lineno"> 4851</span>&#160;#define WITH_OPENSSL // enable HTTPS/SSL support (you must compile stdsoap2.cpp with -DWITH_OPENSSL) </div><div class="line"><a name="l04852"></a><span class="lineno"> 4852</span>&#160;#define WITH_GNUTLS // enable HTTPS/SSL support (you must compile stdsoap2.cpp with -DWITH_GNUTLS) </div><div class="line"><a name="l04853"></a><span class="lineno"> 4853</span>&#160;#define SOAP_DEFAULT_float FLT_NAN // use NaN instead of 0.0 </div><div class="line"><a name="l04854"></a><span class="lineno"> 4854</span>&#160;extern class ostream; // ostream can&#39;t be (de)serialized, but need to be declared to make it visible to gSOAP </div><div class="line"><a name="l04855"></a><span class="lineno"> 4855</span>&#160;class ns__myClass </div><div class="line"><a name="l04856"></a><span class="lineno"> 4856</span>&#160;{ ... </div><div class="line"><a name="l04857"></a><span class="lineno"> 4857</span>&#160;   virtual void print(ostream &amp;s) const; // need ostream here </div><div class="line"><a name="l04858"></a><span class="lineno"> 4858</span>&#160;   ... </div><div class="line"><a name="l04859"></a><span class="lineno"> 4859</span>&#160;};</div><div class="line"><a name="l04860"></a><span class="lineno"> 4860</span>&#160;```</div><div class="line"><a name="l04861"></a><span class="lineno"> 4861</span>&#160;</div><div class="line"><a name="l04862"></a><span class="lineno"> 4862</span>&#160;This example also uses `#define` directives for various settings in the target source code.</div><div class="line"><a name="l04863"></a><span class="lineno"> 4863</span>&#160;</div><div class="line"><a name="l04864"></a><span class="lineno"> 4864</span>&#160;@warning Note that the use of `#define` in the header file does not automatically result in compiling</div><div class="line"><a name="l04865"></a><span class="lineno"> 4865</span>&#160;`stdsoap2.cpp` with these directives. You MUST use the `-DWITH_COOKIES` and `-DWITH_OPENSSL` (or `-DWITH_GNUTLS` options when</div><div class="line"><a name="l04866"></a><span class="lineno"> 4866</span>&#160;compiling `stdsoap2.cpp` before linking the object file with your codes. As an alternative, you can use `#define WITH_SOAPDEFS_H` and put the `#define` directives in the `soapdefs.h` file.</div><div class="line"><a name="l04867"></a><span class="lineno"> 4867</span>&#160;</div><div class="line"><a name="l04868"></a><span class="lineno"> 4868</span>&#160;## Compiling a SOAP/XML Client Application with soapcpp2</div><div class="line"><a name="l04869"></a><span class="lineno"> 4869</span>&#160;</div><div class="line"><a name="l04870"></a><span class="lineno"> 4870</span>&#160;After invoking the gSOAP `soapcpp2` tool on a header file description of a service, the client application can be compiled on a Linux machine as follows:</div><div class="line"><a name="l04871"></a><span class="lineno"> 4871</span>&#160;</div><div class="line"><a name="l04872"></a><span class="lineno"> 4872</span>&#160;    &gt; c++ -o myclient myclient.cpp stdsoap2.cpp soapC.cpp soapClient.cpp</div><div class="line"><a name="l04873"></a><span class="lineno"> 4873</span>&#160;</div><div class="line"><a name="l04874"></a><span class="lineno"> 4874</span>&#160;Or on a Unix machine:</div><div class="line"><a name="l04875"></a><span class="lineno"> 4875</span>&#160;</div><div class="line"><a name="l04876"></a><span class="lineno"> 4876</span>&#160;    &gt; c++ -o myclient myclient.cpp stdsoap2.cpp soapC.cpp soapClient.cpp -lsocket -lxnet -lnsl</div><div class="line"><a name="l04877"></a><span class="lineno"> 4877</span>&#160;</div><div class="line"><a name="l04878"></a><span class="lineno"> 4878</span>&#160;(Depending on your system configuration, the libraries `libsocket.a`,</div><div class="line"><a name="l04879"></a><span class="lineno"> 4879</span>&#160;`libxnet.a`, `libnsl.a` or dynamic `*.so` versions of those libraries are required.)</div><div class="line"><a name="l04880"></a><span class="lineno"> 4880</span>&#160;</div><div class="line"><a name="l04881"></a><span class="lineno"> 4881</span>&#160;The `myclient.cpp` file must include `soapH.h` and must define a global namespace mapping table. A typical client program layout with namespace mapping table is shown below:</div><div class="line"><a name="l04882"></a><span class="lineno"> 4882</span>&#160;</div><div class="line"><a name="l04883"></a><span class="lineno"> 4883</span>&#160;```cpp</div><div class="line"><a name="l04884"></a><span class="lineno"> 4884</span>&#160;// Contents of file &quot;myclient.cpp&quot; </div><div class="line"><a name="l04885"></a><span class="lineno"> 4885</span>&#160;#include &quot;soapH.h&quot;; </div><div class="line"><a name="l04886"></a><span class="lineno"> 4886</span>&#160;... </div><div class="line"><a name="l04887"></a><span class="lineno"> 4887</span>&#160;// A service operation invocation: </div><div class="line"><a name="l04888"></a><span class="lineno"> 4888</span>&#160;   soap_call_some_remote_method(...); </div><div class="line"><a name="l04889"></a><span class="lineno"> 4889</span>&#160;... </div><div class="line"><a name="l04890"></a><span class="lineno"> 4890</span>&#160;struct Namespace namespaces[] = </div><div class="line"><a name="l04891"></a><span class="lineno"> 4891</span>&#160;{   // {&quot;ns-prefix&quot;, &quot;ns-name&quot;} </div><div class="line"><a name="l04892"></a><span class="lineno"> 4892</span>&#160;  {&quot;SOAP-ENV&quot;, &quot;http://schemas.xmlsoap.org/soap/envelope/&quot;}, </div><div class="line"><a name="l04893"></a><span class="lineno"> 4893</span>&#160;  {&quot;SOAP-ENC&quot;, &quot;http://schemas.xmlsoap.org/soap/encoding/&quot;}, </div><div class="line"><a name="l04894"></a><span class="lineno"> 4894</span>&#160;  {&quot;xsi&quot;,      &quot;http://www.w3.org/2001/XMLSchema-instance&quot;}, </div><div class="line"><a name="l04895"></a><span class="lineno"> 4895</span>&#160;  {&quot;xsd&quot;,      &quot;http://www.w3.org/2001/XMLSchema&quot;}, </div><div class="line"><a name="l04896"></a><span class="lineno"> 4896</span>&#160;  {&quot;ns1&quot;,      &quot;urn:my-remote-method&quot;}, </div><div class="line"><a name="l04897"></a><span class="lineno"> 4897</span>&#160;  {NULL, NULL} </div><div class="line"><a name="l04898"></a><span class="lineno"> 4898</span>&#160;}; </div><div class="line"><a name="l04899"></a><span class="lineno"> 4899</span>&#160;...</div><div class="line"><a name="l04900"></a><span class="lineno"> 4900</span>&#160;```</div><div class="line"><a name="l04901"></a><span class="lineno"> 4901</span>&#160;</div><div class="line"><a name="l04902"></a><span class="lineno"> 4902</span>&#160;A mapping table is generated by the gSOAP `soapcpp2` compiler that can be used in the source, see Section \ref wsdl .</div><div class="line"><a name="l04903"></a><span class="lineno"> 4903</span>&#160;</div><div class="line"><a name="l04904"></a><span class="lineno"> 4904</span>&#160;## Compiling a SOAP/XML Web Service with soapcpp2</div><div class="line"><a name="l04905"></a><span class="lineno"> 4905</span>&#160;</div><div class="line"><a name="l04906"></a><span class="lineno"> 4906</span>&#160;After invoking the gSOAP `soapcpp2` tool on a header file description of the service, the server application can be compiled on a Linux machine as follows:</div><div class="line"><a name="l04907"></a><span class="lineno"> 4907</span>&#160;</div><div class="line"><a name="l04908"></a><span class="lineno"> 4908</span>&#160;    &gt; c++ -o myserver myserver.cpp stdsoap2.cpp soapC.cpp soapServer.cpp</div><div class="line"><a name="l04909"></a><span class="lineno"> 4909</span>&#160;</div><div class="line"><a name="l04910"></a><span class="lineno"> 4910</span>&#160;Or on a Unix machine:</div><div class="line"><a name="l04911"></a><span class="lineno"> 4911</span>&#160;</div><div class="line"><a name="l04912"></a><span class="lineno"> 4912</span>&#160;    &gt; c++ -o myserver myserver.cpp stdsoap2.cpp soapC.cpp soapServer.cpp -lsocket -lxnet -lnsl</div><div class="line"><a name="l04913"></a><span class="lineno"> 4913</span>&#160;</div><div class="line"><a name="l04914"></a><span class="lineno"> 4914</span>&#160;(Depending on your system configuration, the libraries `libsocket.a`,</div><div class="line"><a name="l04915"></a><span class="lineno"> 4915</span>&#160;`libxnet.a`, `libnsl.a` or dynamic `*.so` versions of those libraries are required.)</div><div class="line"><a name="l04916"></a><span class="lineno"> 4916</span>&#160;</div><div class="line"><a name="l04917"></a><span class="lineno"> 4917</span>&#160;The `myserver.cpp` file must include `soapH.h` and must define a global namespace mapping table. A typical service program layout with namespace mapping table is shown below:</div><div class="line"><a name="l04918"></a><span class="lineno"> 4918</span>&#160;</div><div class="line"><a name="l04919"></a><span class="lineno"> 4919</span>&#160;```cpp</div><div class="line"><a name="l04920"></a><span class="lineno"> 4920</span>&#160;// Contents of file &quot;myserver.cpp&quot; </div><div class="line"><a name="l04921"></a><span class="lineno"> 4921</span>&#160;#include &quot;soapH.h&quot;; </div><div class="line"><a name="l04922"></a><span class="lineno"> 4922</span>&#160;int main() </div><div class="line"><a name="l04923"></a><span class="lineno"> 4923</span>&#160;{ </div><div class="line"><a name="l04924"></a><span class="lineno"> 4924</span>&#160;   soap_serve(soap_new()); </div><div class="line"><a name="l04925"></a><span class="lineno"> 4925</span>&#160;} </div><div class="line"><a name="l04926"></a><span class="lineno"> 4926</span>&#160;... </div><div class="line"><a name="l04927"></a><span class="lineno"> 4927</span>&#160;// Implementations of the service operations as C++ functions </div><div class="line"><a name="l04928"></a><span class="lineno"> 4928</span>&#160;... </div><div class="line"><a name="l04929"></a><span class="lineno"> 4929</span>&#160;struct Namespace namespaces[] = </div><div class="line"><a name="l04930"></a><span class="lineno"> 4930</span>&#160;{   // {&quot;ns-prefix&quot;, &quot;ns-name&quot;} </div><div class="line"><a name="l04931"></a><span class="lineno"> 4931</span>&#160;  {&quot;SOAP-ENV&quot;, &quot;http://schemas.xmlsoap.org/soap/envelope/&quot;}, </div><div class="line"><a name="l04932"></a><span class="lineno"> 4932</span>&#160;  {&quot;SOAP-ENC&quot;, &quot;http://schemas.xmlsoap.org/soap/encoding/&quot;}, </div><div class="line"><a name="l04933"></a><span class="lineno"> 4933</span>&#160;  {&quot;xsi&quot;,      &quot;http://www.w3.org/2001/XMLSchema-instance&quot;}, </div><div class="line"><a name="l04934"></a><span class="lineno"> 4934</span>&#160;  {&quot;xsd&quot;,      &quot;http://www.w3.org/2001/XMLSchema&quot;}, </div><div class="line"><a name="l04935"></a><span class="lineno"> 4935</span>&#160;  {&quot;ns1&quot;,      &quot;urn:my-remote-method&quot;}, </div><div class="line"><a name="l04936"></a><span class="lineno"> 4936</span>&#160;  {NULL, NULL} </div><div class="line"><a name="l04937"></a><span class="lineno"> 4937</span>&#160;}; </div><div class="line"><a name="l04938"></a><span class="lineno"> 4938</span>&#160;...</div><div class="line"><a name="l04939"></a><span class="lineno"> 4939</span>&#160;```</div><div class="line"><a name="l04940"></a><span class="lineno"> 4940</span>&#160;</div><div class="line"><a name="l04941"></a><span class="lineno"> 4941</span>&#160;When the gSOAP service is compiled and installed as a CGI application, the `soap_serve` function acts as a service dispatcher. It listens to standard input and</div><div class="line"><a name="l04942"></a><span class="lineno"> 4942</span>&#160;invokes the method via a skeleton routine to serve a SOAP client request. After the request is served, the response is encoded in</div><div class="line"><a name="l04943"></a><span class="lineno"> 4943</span>&#160;SOAP and send to standard output. The method must be implemented in the server application and the type signature of the method</div><div class="line"><a name="l04944"></a><span class="lineno"> 4944</span>&#160;must be identical to the service operations specified in the header file. That is, the function prototype in the header file must be a</div><div class="line"><a name="l04945"></a><span class="lineno"> 4945</span>&#160;valid prototype of the method implemented as a C/C++ function.</div><div class="line"><a name="l04946"></a><span class="lineno"> 4946</span>&#160;</div><div class="line"><a name="l04947"></a><span class="lineno"> 4947</span>&#160;## Compiling Web Services and Clients in ANSI C</div><div class="line"><a name="l04948"></a><span class="lineno"> 4948</span>&#160;</div><div class="line"><a name="l04949"></a><span class="lineno"> 4949</span>&#160;The gSOAP `soapcpp2` compiler can be used to create pure C Web services and clients. The gSOAP stub and skeleton compiler</div><div class="line"><a name="l04950"></a><span class="lineno"> 4950</span>&#160;`soapcpp2` generates `.cpp` files by default. The compiler generates `.c` files with the `-c` option.</div><div class="line"><a name="l04951"></a><span class="lineno"> 4951</span>&#160;However, these files only use C syntax and data types **if** the header</div><div class="line"><a name="l04952"></a><span class="lineno"> 4952</span>&#160;file input to `soapcpp2` uses C syntax and data types. For example:</div><div class="line"><a name="l04953"></a><span class="lineno"> 4953</span>&#160;</div><div class="line"><a name="l04954"></a><span class="lineno"> 4954</span>&#160;    &gt; soapcpp2 -c quote.h</div><div class="line"><a name="l04955"></a><span class="lineno"> 4955</span>&#160;    &gt; cc -o quote quote.c stdsoap2.c soapC.c soapClient.c</div><div class="line"><a name="l04956"></a><span class="lineno"> 4956</span>&#160;</div><div class="line"><a name="l04957"></a><span class="lineno"> 4957</span>&#160;Warnings will be issued by the compiler when C++ class declarations occur in the header file.</div><div class="line"><a name="l04958"></a><span class="lineno"> 4958</span>&#160;</div><div class="line"><a name="l04959"></a><span class="lineno"> 4959</span>&#160;## Limitations of gSOAP        {#limitations}</div><div class="line"><a name="l04960"></a><span class="lineno"> 4960</span>&#160;</div><div class="line"><a name="l04961"></a><span class="lineno"> 4961</span>&#160;gSOAP is SOAP 1.1 and SOAP 1.2 compliant and supports SOAP RPC and document/literal operations.</div><div class="line"><a name="l04962"></a><span class="lineno"> 4962</span>&#160;</div><div class="line"><a name="l04963"></a><span class="lineno"> 4963</span>&#160;From the perspective of the C/C++ language, a few C++ language features are not supported by gSOAP and these features cannot be used in the specification of SOAP service operations.</div><div class="line"><a name="l04964"></a><span class="lineno"> 4964</span>&#160;</div><div class="line"><a name="l04965"></a><span class="lineno"> 4965</span>&#160;There are certain limitations for the following C++ language constructs:</div><div class="line"><a name="l04966"></a><span class="lineno"> 4966</span>&#160;</div><div class="line"><a name="l04967"></a><span class="lineno"> 4967</span>&#160;* STL and STL templates: The gSOAP `soapcpp2` compiler supports C++ strings `std::string` and `std::wstring` (see Section \ref strings ) and the STL containers `std::deque`, `std::list`, `std::vector`, and `std::set`, (see Section \ref templates ).</div><div class="line"><a name="l04968"></a><span class="lineno"> 4968</span>&#160;</div><div class="line"><a name="l04969"></a><span class="lineno"> 4969</span>&#160;* Templates; The gSOAP `soapcpp2` compiler is a preprocessor that cannot determine the template instantiations used by the main program, nor can it generate templated code. You can however implement containers similar to the STL containers.</div><div class="line"><a name="l04970"></a><span class="lineno"> 4970</span>&#160;</div><div class="line"><a name="l04971"></a><span class="lineno"> 4971</span>&#160;* Multiple inheritance: Single class inheritance is supported. Multiple inheritance cannot be supported due to limitations of the SOAP protocol.</div><div class="line"><a name="l04972"></a><span class="lineno"> 4972</span>&#160;</div><div class="line"><a name="l04973"></a><span class="lineno"> 4973</span>&#160;* Abstract methods: A class must be instantiatable to allow decoding of instances of the class.</div><div class="line"><a name="l04974"></a><span class="lineno"> 4974</span>&#160;</div><div class="line"><a name="l04975"></a><span class="lineno"> 4975</span>&#160;* Directives: Directives and pragmas such as `#include` and `#define` are interpreted by the gSOAP `soapcpp2` compiler.</div><div class="line"><a name="l04976"></a><span class="lineno"> 4976</span>&#160;However, the interpretation is different compared to the usual handling of directives, see Section \ref pragmas . If necessary, a traditional C++</div><div class="line"><a name="l04977"></a><span class="lineno"> 4977</span>&#160;preprocessor can be used for the interpretation of directives. For example, Unix and Linux users can use &quot;*`cpp -B`*&quot;</div><div class="line"><a name="l04978"></a><span class="lineno"> 4978</span>&#160;to expand the header file, e.g. *`cpp -B myfile.h | soapcpp2`*.</div><div class="line"><a name="l04979"></a><span class="lineno"> 4979</span>&#160;Use the gSOAP `#import` directive to import gSOAP header files, see \ref import .</div><div class="line"><a name="l04980"></a><span class="lineno"> 4980</span>&#160;</div><div class="line"><a name="l04981"></a><span class="lineno"> 4981</span>&#160;* [C and C++ programming statements] All class methods of a class should be declared within the class declaration in the header file, but the methods should not be implemented in code. All class method implementations must be defined within another C++ source file and linked to the application.</div><div class="line"><a name="l04982"></a><span class="lineno"> 4982</span>&#160;</div><div class="line"><a name="l04983"></a><span class="lineno"> 4983</span>&#160;The following data types require some attention to ensure they are serialized:</div><div class="line"><a name="l04984"></a><span class="lineno"> 4984</span>&#160;</div><div class="line"><a name="l04985"></a><span class="lineno"> 4985</span>&#160;</div><div class="line"><a name="l04986"></a><span class="lineno"> 4986</span>&#160;* `union` types: A `union` data type can not be serialized unless run-time information is associated with a `union` in a struct/class as discussed in Section \ref union . An alternative is to use a `struct` with a pointer type for each field. Because `NULL` pointers are not encoded, the resulting encoding will appear as a union type if only one pointer field is valid (i.e. non-`NULL`) at the time that the data type is encoded.</div><div class="line"><a name="l04987"></a><span class="lineno"> 4987</span>&#160;</div><div class="line"><a name="l04988"></a><span class="lineno"> 4988</span>&#160;* `void` and `void *` types: The `void` data type cannot be serialized unless run-time type information is associated with the pointer using a `int __type` field in the struct/class that contains the `void*`. The `void *` data type is typically used to point to some object or to some array of some type of objects at run-time. The compiler cannot determine the type of data pointed to and the size of the array pointed to. A struct or class with a `void*` field can be augmented to support the (de)serialization of the `void*` using a `int __type` field as described in Section \ref void .</div><div class="line"><a name="l04989"></a><span class="lineno"> 4989</span>&#160;</div><div class="line"><a name="l04990"></a><span class="lineno"> 4990</span>&#160;* Pointers to sequences of elements in memory: Any pointer, except for C strings which are pointers to a sequence of</div><div class="line"><a name="l04991"></a><span class="lineno"> 4991</span>&#160;characters, are treated by the compiler as if the pointer points to **only one element in memory** at run-time. Consequently,</div><div class="line"><a name="l04992"></a><span class="lineno"> 4992</span>&#160;the encoding and decoding routines will ignore any subsequent elements that follow the first in memory. For the same reason,</div><div class="line"><a name="l04993"></a><span class="lineno"> 4993</span>&#160;arrays of undetermined length, e.g. `float a[]` cannot be used. gSOAP supports dynamic arrays using a special type convention,</div><div class="line"><a name="l04994"></a><span class="lineno"> 4994</span>&#160;see Section \ref dynarray .</div><div class="line"><a name="l04995"></a><span class="lineno"> 4995</span>&#160;</div><div class="line"><a name="l04996"></a><span class="lineno"> 4996</span>&#160;* Uninitialized pointers: Obviously, all pointers that are part of a data structure must be valid or `NULL` to enable</div><div class="line"><a name="l04997"></a><span class="lineno"> 4997</span>&#160;serialization of the data structure at run time.</div><div class="line"><a name="l04998"></a><span class="lineno"> 4998</span>&#160;</div><div class="line"><a name="l04999"></a><span class="lineno"> 4999</span>&#160;There are a number of programming solutions that can be adopted to circumvent these limitations. Instead of using `void *`, a program</div><div class="line"><a name="l05000"></a><span class="lineno"> 5000</span>&#160;can in some cases be modified to use a pointer to a known type. If the pointer is intended to point to different types of objects, a generic</div><div class="line"><a name="l05001"></a><span class="lineno"> 5001</span>&#160;base class can be declared and the pointer is declared to point to the base class. All the other types are declared to be derived</div><div class="line"><a name="l05002"></a><span class="lineno"> 5002</span>&#160;classes of this base class. For pointers that point to a sequence of elements in memory dynamic arrays should be used instead,</div><div class="line"><a name="l05003"></a><span class="lineno"> 5003</span>&#160;see \ref dynarray .</div><div class="line"><a name="l05004"></a><span class="lineno"> 5004</span>&#160;</div><div class="line"><a name="l05005"></a><span class="lineno"> 5005</span>&#160;## Library Build Flags        {#compilerflags}</div><div class="line"><a name="l05006"></a><span class="lineno"> 5006</span>&#160;</div><div class="line"><a name="l05007"></a><span class="lineno"> 5007</span>&#160;The following macros (`#define`s) can be used to enable certain optional features by compiling all of the source code files with compiler option `-D` to set the macro:</div><div class="line"><a name="l05008"></a><span class="lineno"> 5008</span>&#160;</div><div class="line"><a name="l05009"></a><span class="lineno"> 5009</span>&#160;define                      | result</div><div class="line"><a name="l05010"></a><span class="lineno"> 5010</span>&#160;--------------------------- | ------</div><div class="line"><a name="l05011"></a><span class="lineno"> 5011</span>&#160;`WITH_SOAPDEFS_H`           | includes the `soapdefs.h` file for custom settings, see Section \ref soapdefs  </div><div class="line"><a name="l05012"></a><span class="lineno"> 5012</span>&#160;`SOAPDEFS_H`                | the header file to include, if different from `soapdefs.h` (see above) </div><div class="line"><a name="l05013"></a><span class="lineno"> 5013</span>&#160;`WITH_COOKIES`              | enables HTTP cookies, see Sections \ref clientcookie  \ref servercookie  </div><div class="line"><a name="l05014"></a><span class="lineno"> 5014</span>&#160;`WITH_OPENSSL`              | enables OpenSSL, see Sections \ref clientopenssl  \ref serveropenssl  </div><div class="line"><a name="l05015"></a><span class="lineno"> 5015</span>&#160;`WITH_GNUTLS`               | enables GNUTLS, see Sections \ref clientopenssl  \ref serveropenssl  </div><div class="line"><a name="l05016"></a><span class="lineno"> 5016</span>&#160;`WITH_IPV6`                 | enables IPv6 support (compile ALL sources with this macro set)</div><div class="line"><a name="l05017"></a><span class="lineno"> 5017</span>&#160;`WITH_IPV6_V6ONLY`          | IPv6-only server option (compile ALL sources with this macro set)</div><div class="line"><a name="l05018"></a><span class="lineno"> 5018</span>&#160;`WITH_NO_IPV6_V6ONLY`       | permits IPv4 and IPv6 (compile ALL sources with this macro set)</div><div class="line"><a name="l05019"></a><span class="lineno"> 5019</span>&#160;`WITH_TCPFIN`               | use TCP FIN after sends when socket is ready to close </div><div class="line"><a name="l05020"></a><span class="lineno"> 5020</span>&#160;`WITH_FASTCGI`              | enables FastCGI, see Sections \ref fastcgi  </div><div class="line"><a name="l05021"></a><span class="lineno"> 5021</span>&#160;`WITH_GZIP`                 | enables gzip and deflate compression, see Section \ref compression  </div><div class="line"><a name="l05022"></a><span class="lineno"> 5022</span>&#160;`WITH_ZLIB`                 | enables deflate compression only, see Section \ref compression  </div><div class="line"><a name="l05023"></a><span class="lineno"> 5023</span>&#160;`WITH_NOIO`                 | eliminates need for file IO and BSD socket library, see Section \ref noio  </div><div class="line"><a name="l05024"></a><span class="lineno"> 5024</span>&#160;`WITH_NOIDREF`              | eliminates href/ref and id attributes to (de)serialize multi-ref data, or use the `SOAP_XML_TREE` runtime flag </div><div class="line"><a name="l05025"></a><span class="lineno"> 5025</span>&#160;`WITH_NOHTTP`               | eliminates HTTP stack to reduce code size </div><div class="line"><a name="l05026"></a><span class="lineno"> 5026</span>&#160;`WITH_NOZONE`               | removes and ignores the timezone in xsd:dateTime </div><div class="line"><a name="l05027"></a><span class="lineno"> 5027</span>&#160;`WITH_LEAN`                 | creates a small-footprint executable, see Section \ref lean  </div><div class="line"><a name="l05028"></a><span class="lineno"> 5028</span>&#160;`WITH_LEANER`               | creates an even smaller footprint executable, see Section \ref lean  </div><div class="line"><a name="l05029"></a><span class="lineno"> 5029</span>&#160;`WITH_FAST`                 | use faster memory allocation when used with `WITH_LEAN`/`WITH_LEANER` </div><div class="line"><a name="l05030"></a><span class="lineno"> 5030</span>&#160;`WITH_COMPAT`               | removes dependency on C++ stream libraries, eliminating C++ exceptions </div><div class="line"><a name="l05031"></a><span class="lineno"> 5031</span>&#160;`WITH_NONAMESPACES`         | removes dependence on global `namespaces` table, MUST set it explicitly with `soap_set_.namespaces()` see also Section \ref nstable  </div><div class="line"><a name="l05032"></a><span class="lineno"> 5032</span>&#160;`WITH_PURE_VIRTUAL`         | to generate C++ abstract service classes with pure virtual methods </div><div class="line"><a name="l05033"></a><span class="lineno"> 5033</span>&#160;`WITH_NOEMPTYSTRUCT`        | inserts a dummy member in empty structs to allow compilation </div><div class="line"><a name="l05034"></a><span class="lineno"> 5034</span>&#160;`WITH_NOGLOBAL`             | omit SOAP Header and Fault serialization code, prevents duplicate definitions with generated soapXYZLib code </div><div class="line"><a name="l05035"></a><span class="lineno"> 5035</span>&#160;`WITH_CDATA`                | retain the parsed CDATA sections in literal XML strings (no conversion, default) </div><div class="line"><a name="l05036"></a><span class="lineno"> 5036</span>&#160;`WITH_C_LOCALE`             | use locale functions when available to ensure locale-independent number conversions (force the use of C locale) </div><div class="line"><a name="l05037"></a><span class="lineno"> 5037</span>&#160;`WITH_CASEINSENSITIVETAGS`  | enable case insensitive XML parsing </div><div class="line"><a name="l05038"></a><span class="lineno"> 5038</span>&#160;`WITH_REPLACE_ILLEGAL_UTF8` | strict UTF-8: replaces UTF8 content that is outside the allowed range, with U+FFFD </div><div class="line"><a name="l05039"></a><span class="lineno"> 5039</span>&#160;`SOCKET_CLOSE_ON_EXIT`      | prevents a server port from staying in listening mode after exit by internally setting `fcntl(sock, F_SETFD, FD_CLOEXEC)` </div><div class="line"><a name="l05040"></a><span class="lineno"> 5040</span>&#160;</div><div class="line"><a name="l05041"></a><span class="lineno"> 5041</span>&#160;Compile-time flags to change the default engine settings:</div><div class="line"><a name="l05042"></a><span class="lineno"> 5042</span>&#160;</div><div class="line"><a name="l05043"></a><span class="lineno"> 5043</span>&#160;define                      | result</div><div class="line"><a name="l05044"></a><span class="lineno"> 5044</span>&#160;--------------------------- | ------</div><div class="line"><a name="l05045"></a><span class="lineno"> 5045</span>&#160;`SOAP_BUFLEN`               | the length of the internal message buffer (affects socket comms) </div><div class="line"><a name="l05046"></a><span class="lineno"> 5046</span>&#160;`SOAP_TAGLEN`               | maximum length of XML tags and URL domain names (buffering) </div><div class="line"><a name="l05047"></a><span class="lineno"> 5047</span>&#160;`SOAP_SSL_RSA_BITS`         |  the length of the RSA key (2048 by default) </div><div class="line"><a name="l05048"></a><span class="lineno"> 5048</span>&#160;`SOAP_UNKNOWN_CHAR`         | an 8 bit code that represents a character that could not be converted to an ASCII `char` (e.g. from Unicode, applicable when `SOAP_C_UTFSTRING` is off) </div><div class="line"><a name="l05049"></a><span class="lineno"> 5049</span>&#160;</div><div class="line"><a name="l05050"></a><span class="lineno"> 5050</span>&#160;@warning it is important that all of these macros MUST be consistently defined to</div><div class="line"><a name="l05051"></a><span class="lineno"> 5051</span>&#160;compile all sources, such as `stdsoap2.cpp`, `soapC.cpp`,</div><div class="line"><a name="l05052"></a><span class="lineno"> 5052</span>&#160;`soapClient.cpp`, `soapServer.cpp`, and all application sources that</div><div class="line"><a name="l05053"></a><span class="lineno"> 5053</span>&#160;include `stdsoap2.h` or `soapH.h`. If the macros are not consistently</div><div class="line"><a name="l05054"></a><span class="lineno"> 5054</span>&#160;used, the application will crash due to a mismatches in the declaration and</div><div class="line"><a name="l05055"></a><span class="lineno"> 5055</span>&#160;access of the gSOAP context.</div><div class="line"><a name="l05056"></a><span class="lineno"> 5056</span>&#160;</div><div class="line"><a name="l05057"></a><span class="lineno"> 5057</span>&#160;## Run Time Flags        {#flags}</div><div class="line"><a name="l05058"></a><span class="lineno"> 5058</span>&#160;</div><div class="line"><a name="l05059"></a><span class="lineno"> 5059</span>&#160;gSOAP provides flags to control the input and output mode settings at runtime.</div><div class="line"><a name="l05060"></a><span class="lineno"> 5060</span>&#160;These flags are divided into four categories: transport (IO), content encoding</div><div class="line"><a name="l05061"></a><span class="lineno"> 5061</span>&#160;(ENC), XML marshalling (XML), and C/C++ data mapping (C).</div><div class="line"><a name="l05062"></a><span class="lineno"> 5062</span>&#160;</div><div class="line"><a name="l05063"></a><span class="lineno"> 5063</span>&#160;Although gSOAP is fully SOAP 1.1 compliant, some SOAP implementations may have</div><div class="line"><a name="l05064"></a><span class="lineno"> 5064</span>&#160;trouble accepting multi-reference data and/or require explicit nil data so</div><div class="line"><a name="l05065"></a><span class="lineno"> 5065</span>&#160;these flags can be used to put gSOAP in &quot;safe mode&quot;.  In addition, the</div><div class="line"><a name="l05066"></a><span class="lineno"> 5066</span>&#160;embedding (or inlining) of multi-reference data is adopted in the SOAP 1.2</div><div class="line"><a name="l05067"></a><span class="lineno"> 5067</span>&#160;specification, which gSOAP automatically supports when handling with SOAP 1.2</div><div class="line"><a name="l05068"></a><span class="lineno"> 5068</span>&#160;messages.</div><div class="line"><a name="l05069"></a><span class="lineno"> 5069</span>&#160;</div><div class="line"><a name="l05070"></a><span class="lineno"> 5070</span>&#160;To set and clear flags for inbound message processing use:</div><div class="line"><a name="l05071"></a><span class="lineno"> 5071</span>&#160;</div><div class="line"><a name="l05072"></a><span class="lineno"> 5072</span>&#160;```cpp</div><div class="line"><a name="l05073"></a><span class="lineno"> 5073</span>&#160;soap_set_imode(soap, inflag);</div><div class="line"><a name="l05074"></a><span class="lineno"> 5074</span>&#160;soap_clr_imode(soap, inflag);</div><div class="line"><a name="l05075"></a><span class="lineno"> 5075</span>&#160;```</div><div class="line"><a name="l05076"></a><span class="lineno"> 5076</span>&#160;</div><div class="line"><a name="l05077"></a><span class="lineno"> 5077</span>&#160;To set and clear the flags for outbound message processing use:</div><div class="line"><a name="l05078"></a><span class="lineno"> 5078</span>&#160;</div><div class="line"><a name="l05079"></a><span class="lineno"> 5079</span>&#160;```cpp</div><div class="line"><a name="l05080"></a><span class="lineno"> 5080</span>&#160;soap_set_omode(soap, outflag);</div><div class="line"><a name="l05081"></a><span class="lineno"> 5081</span>&#160;soap_clr_imode(soap, outflag);</div><div class="line"><a name="l05082"></a><span class="lineno"> 5082</span>&#160;```</div><div class="line"><a name="l05083"></a><span class="lineno"> 5083</span>&#160;</div><div class="line"><a name="l05084"></a><span class="lineno"> 5084</span>&#160;To allocate and initialize a gSOAP context with inbound and outbound flags use:</div><div class="line"><a name="l05085"></a><span class="lineno"> 5085</span>&#160;</div><div class="line"><a name="l05086"></a><span class="lineno"> 5086</span>&#160;```cpp</div><div class="line"><a name="l05087"></a><span class="lineno"> 5087</span>&#160;soap_new2(soap, inflag, outflag);</div><div class="line"><a name="l05088"></a><span class="lineno"> 5088</span>&#160;```</div><div class="line"><a name="l05089"></a><span class="lineno"> 5089</span>&#160;</div><div class="line"><a name="l05090"></a><span class="lineno"> 5090</span>&#160;To initialize an unitialized gSOAP context with inbound and outbound flags use:</div><div class="line"><a name="l05091"></a><span class="lineno"> 5091</span>&#160;</div><div class="line"><a name="l05092"></a><span class="lineno"> 5092</span>&#160;```cpp</div><div class="line"><a name="l05093"></a><span class="lineno"> 5093</span>&#160;soap_init2(soap, inflag, outflag);</div><div class="line"><a name="l05094"></a><span class="lineno"> 5094</span>&#160;```</div><div class="line"><a name="l05095"></a><span class="lineno"> 5095</span>&#160;</div><div class="line"><a name="l05096"></a><span class="lineno"> 5096</span>&#160;The input-mode and output-mode flags for inbound and outbound message processing are:</div><div class="line"><a name="l05097"></a><span class="lineno"> 5097</span>&#160;</div><div class="line"><a name="l05098"></a><span class="lineno"> 5098</span>&#160;flag                 | in, out, or in+out result</div><div class="line"><a name="l05099"></a><span class="lineno"> 5099</span>&#160;-------------------- | -------------------------</div><div class="line"><a name="l05100"></a><span class="lineno"> 5100</span>&#160;`SOAP_IO_FLUSH`      | in: disable buffering and flush output (default for all file-based output) </div><div class="line"><a name="l05101"></a><span class="lineno"> 5101</span>&#160;`SOAP_IO_BUFFER`     | in: enable buffering (default for all socket-oriented connections) </div><div class="line"><a name="l05102"></a><span class="lineno"> 5102</span>&#160;`SOAP_IO_STORE`      | in: store entire message to calculate HTTP content length </div><div class="line"><a name="l05103"></a><span class="lineno"> 5103</span>&#160;`SOAP_IO_CHUNK`      | out: use HTTP chunking </div><div class="line"><a name="l05104"></a><span class="lineno"> 5104</span>&#160;`SOAP_IO_LENGTH`     | out: (internal flag) require apriori calculation of content length </div><div class="line"><a name="l05105"></a><span class="lineno"> 5105</span>&#160;`SOAP_IO_KEEPALIVE`  | in+out: attempt to keep socket connections alive (open) </div><div class="line"><a name="l05106"></a><span class="lineno"> 5106</span>&#160;`SOAP_IO_UDP`        | in+out: use UDP (datagram) transport, maximum message length is `SOAP_BUFLEN` </div><div class="line"><a name="l05107"></a><span class="lineno"> 5107</span>&#160;`SOAP_ENC_PLAIN`     | in+out: use plain messages without parsing or emitting HTTP headers </div><div class="line"><a name="l05108"></a><span class="lineno"> 5108</span>&#160;`SOAP_ENC_XML`       | deprecated, alias for `SOAP_ENC_PLAIN` </div><div class="line"><a name="l05109"></a><span class="lineno"> 5109</span>&#160;`SOAP_ENC_DIME`      | out: use DIME encoding (automatic when DIME attachments are used) </div><div class="line"><a name="l05110"></a><span class="lineno"> 5110</span>&#160;`SOAP_ENC_MIME`      | out: use MIME encoding (activate using `soap_set_mime`) </div><div class="line"><a name="l05111"></a><span class="lineno"> 5111</span>&#160;`SOAP_ENC_MTOM`      | out: use MTOM XOP attachments (instead of DIME) </div><div class="line"><a name="l05112"></a><span class="lineno"> 5112</span>&#160;`SOAP_ENC_ZLIB`      | out: compress encoding with Zlib (deflate or gzip format) </div><div class="line"><a name="l05113"></a><span class="lineno"> 5113</span>&#160;`SOAP_ENC_SSL`       | in+out: encrypt with SSL (automatic with &quot;https:&quot; endpoints) </div><div class="line"><a name="l05114"></a><span class="lineno"> 5114</span>&#160;`SOAP_XML_INDENT`    | out: produces indented XML output </div><div class="line"><a name="l05115"></a><span class="lineno"> 5115</span>&#160;`SOAP_XML_CANONICAL` | out: produces canonical XML output </div><div class="line"><a name="l05116"></a><span class="lineno"> 5116</span>&#160;`SOAP_XML_DEFAULTNS` | out: forces output of xmlns=&quot;...&quot; default namespace declarations </div><div class="line"><a name="l05117"></a><span class="lineno"> 5117</span>&#160;`SOAP_XML_IGNORENS`  | in: ignores the use of XML namespaces in input </div><div class="line"><a name="l05118"></a><span class="lineno"> 5118</span>&#160;`SOAP_XML_STRICT`    | in: XML strict validation </div><div class="line"><a name="l05119"></a><span class="lineno"> 5119</span>&#160;`SOAP_XML_TREE`      | out: serialize data as XML trees (no multi-ref, duplicate data when necessary); in: ignore id attributes (do not resolve id-ref)</div><div class="line"><a name="l05120"></a><span class="lineno"> 5120</span>&#160;`SOAP_XML_GRAPH`     | out: serialize data as an XML graph with inline multi-ref (SOAP 1.2 default) </div><div class="line"><a name="l05121"></a><span class="lineno"> 5121</span>&#160;`SOAP_XML_NIL`       | out: serialize NULL data as xsi:nil attributed elements </div><div class="line"><a name="l05122"></a><span class="lineno"> 5122</span>&#160;`SOAP_XML_NOTYPE`    | out: disable *`xsi:type`* attributes </div><div class="line"><a name="l05123"></a><span class="lineno"> 5123</span>&#160;`SOAP_C_NOIOB`       | in: do not fault with `SOAP_IOB` </div><div class="line"><a name="l05124"></a><span class="lineno"> 5124</span>&#160;`SOAP_C_UTFSTRING`   | in+out: (de)serialize 8-bit strings &quot;as is&quot; (strings MUST have UTF-8 encoded content) </div><div class="line"><a name="l05125"></a><span class="lineno"> 5125</span>&#160;`SOAP_C_MBSTRING`    | in+out: enable multibyte character support (depends on locale) </div><div class="line"><a name="l05126"></a><span class="lineno"> 5126</span>&#160;`SOAP_C_NILSTRING`   | out: serialize empty strings as nil (ommited element) </div><div class="line"><a name="l05127"></a><span class="lineno"> 5127</span>&#160;</div><div class="line"><a name="l05128"></a><span class="lineno"> 5128</span>&#160;The flags can be selectively turned on/off at any time, for example when</div><div class="line"><a name="l05129"></a><span class="lineno"> 5129</span>&#160;multiple Web services are accessed by a client that require special treatment.</div><div class="line"><a name="l05130"></a><span class="lineno"> 5130</span>&#160;</div><div class="line"><a name="l05131"></a><span class="lineno"> 5131</span>&#160;All flags are orthogonal, except</div><div class="line"><a name="l05132"></a><span class="lineno"> 5132</span>&#160;`SOAP_IO_FLUSH`,</div><div class="line"><a name="l05133"></a><span class="lineno"> 5133</span>&#160;`SOAP_IO_BUFFER`,</div><div class="line"><a name="l05134"></a><span class="lineno"> 5134</span>&#160;`SOAP_IO_STORE`, and</div><div class="line"><a name="l05135"></a><span class="lineno"> 5135</span>&#160;`SOAP_IO_CHUNK`</div><div class="line"><a name="l05136"></a><span class="lineno"> 5136</span>&#160;which are enumerations and only one of these I/O flags can be used.  Also the</div><div class="line"><a name="l05137"></a><span class="lineno"> 5137</span>&#160;XML serialization flags</div><div class="line"><a name="l05138"></a><span class="lineno"> 5138</span>&#160;`SOAP_XML_TREE` and</div><div class="line"><a name="l05139"></a><span class="lineno"> 5139</span>&#160;`SOAP_XML_GRAPH` should not be mixed.</div><div class="line"><a name="l05140"></a><span class="lineno"> 5140</span>&#160;</div><div class="line"><a name="l05141"></a><span class="lineno"> 5141</span>&#160;The flags control the inbound and outbound message transport, encoding, and</div><div class="line"><a name="l05142"></a><span class="lineno"> 5142</span>&#160;(de)serialization.  The following functions are used to set and reset the flags</div><div class="line"><a name="l05143"></a><span class="lineno"> 5143</span>&#160;for input and output modes:</div><div class="line"><a name="l05144"></a><span class="lineno"> 5144</span>&#160;</div><div class="line"><a name="l05145"></a><span class="lineno"> 5145</span>&#160;* `soap_init2(struct soap *soap, int imode, int omode)` Initialize the runtime and set flags </div><div class="line"><a name="l05146"></a><span class="lineno"> 5146</span>&#160;</div><div class="line"><a name="l05147"></a><span class="lineno"> 5147</span>&#160;* `soap_imode(struct soap *soap, int imode)` Set all input mode flags </div><div class="line"><a name="l05148"></a><span class="lineno"> 5148</span>&#160;</div><div class="line"><a name="l05149"></a><span class="lineno"> 5149</span>&#160;* `soap_omode(struct soap *soap, int omode)` Set all output mode flags </div><div class="line"><a name="l05150"></a><span class="lineno"> 5150</span>&#160;</div><div class="line"><a name="l05151"></a><span class="lineno"> 5151</span>&#160;* `soap_set_imode(struct soap *soap, int imode)` Enable input mode flags </div><div class="line"><a name="l05152"></a><span class="lineno"> 5152</span>&#160;</div><div class="line"><a name="l05153"></a><span class="lineno"> 5153</span>&#160;* `soap_set_omode(struct soap *soap, int omode)` Enable output mode flags </div><div class="line"><a name="l05154"></a><span class="lineno"> 5154</span>&#160;</div><div class="line"><a name="l05155"></a><span class="lineno"> 5155</span>&#160;* `soap_clr_imode(struct soap *soap, int omode)` Disable input mode flags </div><div class="line"><a name="l05156"></a><span class="lineno"> 5156</span>&#160;</div><div class="line"><a name="l05157"></a><span class="lineno"> 5157</span>&#160;* `soap_clr_omode(struct soap *soap, int omode)` Disable output mode flags </div><div class="line"><a name="l05158"></a><span class="lineno"> 5158</span>&#160;</div><div class="line"><a name="l05159"></a><span class="lineno"> 5159</span>&#160;The default setting is `SOAP_IO_DEFAULT` for both input and output modes.</div><div class="line"><a name="l05160"></a><span class="lineno"> 5160</span>&#160;</div><div class="line"><a name="l05161"></a><span class="lineno"> 5161</span>&#160;For example</div><div class="line"><a name="l05162"></a><span class="lineno"> 5162</span>&#160;</div><div class="line"><a name="l05163"></a><span class="lineno"> 5163</span>&#160;```cpp</div><div class="line"><a name="l05164"></a><span class="lineno"> 5164</span>&#160;struct soap soap; </div><div class="line"><a name="l05165"></a><span class="lineno"> 5165</span>&#160;soap_init2(&amp;soap, SOAP_IO_KEEPALIVE, </div><div class="line"><a name="l05166"></a><span class="lineno"> 5166</span>&#160;   SOAP_IO_KEEPALIVE|SOAP_ENC_ZLIB|SOAP_XML_TREE|SOAP_XML_CANONICAL); </div><div class="line"><a name="l05167"></a><span class="lineno"> 5167</span>&#160;if (soap_call_ns__myMethod(&amp;soap, ...)) </div><div class="line"><a name="l05168"></a><span class="lineno"> 5168</span>&#160;...</div><div class="line"><a name="l05169"></a><span class="lineno"> 5169</span>&#160;```</div><div class="line"><a name="l05170"></a><span class="lineno"> 5170</span>&#160;</div><div class="line"><a name="l05171"></a><span class="lineno"> 5171</span>&#160;sends a compressed client request with keep-alive enabled and all data serialized as canonical XML trees.</div><div class="line"><a name="l05172"></a><span class="lineno"> 5172</span>&#160;</div><div class="line"><a name="l05173"></a><span class="lineno"> 5173</span>&#160;In many cases, setting the input mode will have no effect, especially with HTTP</div><div class="line"><a name="l05174"></a><span class="lineno"> 5174</span>&#160;transport because gSOAP will determine the optimal input buffering and the</div><div class="line"><a name="l05175"></a><span class="lineno"> 5175</span>&#160;encoding used for an inbound message. The flags that have an effect on</div><div class="line"><a name="l05176"></a><span class="lineno"> 5176</span>&#160;handling inbound messages are `SOAP_IO_KEEPALIVE`, `SOAP_ENC_SSL`</div><div class="line"><a name="l05177"></a><span class="lineno"> 5177</span>&#160;(but automatic when &quot;https:&quot; endpoints are used or `soap_ssl_accept`),</div><div class="line"><a name="l05178"></a><span class="lineno"> 5178</span>&#160;`SOAP_C_NOIOB`, `SOAP_C_UTFSTRING`, and `SOAP_C_MBSTRING`.</div><div class="line"><a name="l05179"></a><span class="lineno"> 5179</span>&#160;</div><div class="line"><a name="l05180"></a><span class="lineno"> 5180</span>&#160;@warning The `SOAP_XML_TREE` serialization flag can be used to</div><div class="line"><a name="l05181"></a><span class="lineno"> 5181</span>&#160;improve interoperability with SOAP implementations that are not fully SOAP 1.1</div><div class="line"><a name="l05182"></a><span class="lineno"> 5182</span>&#160;compliant.  However, a tree serialization will duplicate data when necessary</div><div class="line"><a name="l05183"></a><span class="lineno"> 5183</span>&#160;and will crash the serializer for cyclic data structures.</div><div class="line"><a name="l05184"></a><span class="lineno"> 5184</span>&#160;</div><div class="line"><a name="l05185"></a><span class="lineno"> 5185</span>&#160;Additional run-time flags to control sockets. </div><div class="line"><a name="l05186"></a><span class="lineno"> 5186</span>&#160;</div><div class="line"><a name="l05187"></a><span class="lineno"> 5187</span>&#160;Use the following selection of flags that are OS dependent to control sockets for send/sendto/recv/recvfrom operations:</div><div class="line"><a name="l05188"></a><span class="lineno"> 5188</span>&#160;</div><div class="line"><a name="l05189"></a><span class="lineno"> 5189</span>&#160;* `MSG_NOSIGNAL` disables sigpipe (check your OS, this is not portable) </div><div class="line"><a name="l05190"></a><span class="lineno"> 5190</span>&#160;</div><div class="line"><a name="l05191"></a><span class="lineno"> 5191</span>&#160;* `MSG_DONTROUTE` bypass routing, use direct interface </div><div class="line"><a name="l05192"></a><span class="lineno"> 5192</span>&#160;</div><div class="line"><a name="l05193"></a><span class="lineno"> 5193</span>&#160;Use the following selection of flags to set client-side socket connection flags (setsockopt):</div><div class="line"><a name="l05194"></a><span class="lineno"> 5194</span>&#160;</div><div class="line"><a name="l05195"></a><span class="lineno"> 5195</span>&#160;* `SO_NOSIGPIPE` disables sigpipe (check your OS, this is not portable) </div><div class="line"><a name="l05196"></a><span class="lineno"> 5196</span>&#160;</div><div class="line"><a name="l05197"></a><span class="lineno"> 5197</span>&#160;* `SO_DEBUG` turns on recording of debugging information in the underlying protocol modules </div><div class="line"><a name="l05198"></a><span class="lineno"> 5198</span>&#160;</div><div class="line"><a name="l05199"></a><span class="lineno"> 5199</span>&#160;* `SO_BROADCAST` permits sending of broadcast messages (e.g. with UDP) when permitted </div><div class="line"><a name="l05200"></a><span class="lineno"> 5200</span>&#160;</div><div class="line"><a name="l05201"></a><span class="lineno"> 5201</span>&#160;* `SO_LINGER` set `soap.linger_time` (set this value as needed) </div><div class="line"><a name="l05202"></a><span class="lineno"> 5202</span>&#160;</div><div class="line"><a name="l05203"></a><span class="lineno"> 5203</span>&#160;Use the following selection of flags to set server-side socket connection accept flags (setsockopt):</div><div class="line"><a name="l05204"></a><span class="lineno"> 5204</span>&#160;</div><div class="line"><a name="l05205"></a><span class="lineno"> 5205</span>&#160;* `SO_NOSIGPIPE` disables sigpipe (check your OS, this is not portable) </div><div class="line"><a name="l05206"></a><span class="lineno"> 5206</span>&#160;</div><div class="line"><a name="l05207"></a><span class="lineno"> 5207</span>&#160;* `SO_DEBUG` turns on recording of debugging information in the underlying protocol modules </div><div class="line"><a name="l05208"></a><span class="lineno"> 5208</span>&#160;</div><div class="line"><a name="l05209"></a><span class="lineno"> 5209</span>&#160;* `SO_REUSEADDR` reuse bind address immediately (prevents bind reject) </div><div class="line"><a name="l05210"></a><span class="lineno"> 5210</span>&#160;</div><div class="line"><a name="l05211"></a><span class="lineno"> 5211</span>&#160;* `SO_LINGER` set `soap.linger_time` (set this value as needed) </div><div class="line"><a name="l05212"></a><span class="lineno"> 5212</span>&#160;</div><div class="line"><a name="l05213"></a><span class="lineno"> 5213</span>&#160;For example, `soap.accept_flags = (SO_NOSIGPIPE | SO_LINGER)` disables sigpipe signals and set linger time value given by `soap.linger_time` (zero by default).</div><div class="line"><a name="l05214"></a><span class="lineno"> 5214</span>&#160;</div><div class="line"><a name="l05215"></a><span class="lineno"> 5215</span>&#160;The `SO_SNDBUF` and `SO_RCVBUF` socket options can be set by assigning `soap.sndbuf` and `soap.rcvbuf` after the context initialization, respectively.  The default value is `SOAP_BUFLEN`, which is the same as the size of the internal buffer.  A zero value omits the internal `setsockopt` call to set these options.  Setting these values to zero enables autotuning with Linux 2.4 and up.</div><div class="line"><a name="l05216"></a><span class="lineno"> 5216</span>&#160;</div><div class="line"><a name="l05217"></a><span class="lineno"> 5217</span>&#160;## Memory Management        {#memory}</div><div class="line"><a name="l05218"></a><span class="lineno"> 5218</span>&#160;</div><div class="line"><a name="l05219"></a><span class="lineno"> 5219</span>&#160;Understanding gSOAP&#39;s run-time memory management is important to optimize</div><div class="line"><a name="l05220"></a><span class="lineno"> 5220</span>&#160;client and service applications by eliminating memory leaks and/or dangling</div><div class="line"><a name="l05221"></a><span class="lineno"> 5221</span>&#160;references.</div><div class="line"><a name="l05222"></a><span class="lineno"> 5222</span>&#160;</div><div class="line"><a name="l05223"></a><span class="lineno"> 5223</span>&#160;There are two forms of dynamic (heap) allocations made by gSOAP&#39;s runtime for</div><div class="line"><a name="l05224"></a><span class="lineno"> 5224</span>&#160;serialization and deserialization of data.  Temporary data is created by the</div><div class="line"><a name="l05225"></a><span class="lineno"> 5225</span>&#160;runtime such as hash tables to keep pointer reference information for</div><div class="line"><a name="l05226"></a><span class="lineno"> 5226</span>&#160;serialization and hash tables to keep XML id/href information for</div><div class="line"><a name="l05227"></a><span class="lineno"> 5227</span>&#160;multi-reference object deserialization.  Deserialized data is created upon</div><div class="line"><a name="l05228"></a><span class="lineno"> 5228</span>&#160;receiving SOAP messages.  This data is stored on the heap and requires several</div><div class="line"><a name="l05229"></a><span class="lineno"> 5229</span>&#160;calls to the `malloc` library function to allocate space for the data and</div><div class="line"><a name="l05230"></a><span class="lineno"> 5230</span>&#160;`new` to create class instances.  All such allocations are tracked by</div><div class="line"><a name="l05231"></a><span class="lineno"> 5231</span>&#160;gSOAP&#39;s runtime by linked lists for later deallocation.  The linked list for</div><div class="line"><a name="l05232"></a><span class="lineno"> 5232</span>&#160;`malloc` allocations uses some extra space in each `malloc`ed block to</div><div class="line"><a name="l05233"></a><span class="lineno"> 5233</span>&#160;form a chain of pointers through the `malloc`ed blocks.  A separate</div><div class="line"><a name="l05234"></a><span class="lineno"> 5234</span>&#160;`malloc`ed linked list is used to keep track of class instance allocations.</div><div class="line"><a name="l05235"></a><span class="lineno"> 5235</span>&#160;</div><div class="line"><a name="l05236"></a><span class="lineno"> 5236</span>&#160;If you want to preserve the deserialized data before deleting a soap context, you can assign management of the data and delegate responsibility of deletion to another soap context using `soap_delegate_deletion(struct soap *soap_from, struct soap *soap_to)`. This moves all deserialized and temporary data to the other soap context `soap_to`, which will delete its data and all the delegated data it is responsible for when you call `soap_destroy` and `soap_end`. This can be particularly useful for making client calls inside a server operation, i.e. a mixed server/client. The client call inside the server operation requires a new soap context, e.g. copied from the server&#39;s with `soap_copy`. Before destroying the client context with `soap_free`, the data can be delegated to the server&#39;s context with `soap_delegate_deletion`. See `samples/mashup/machupserver.c` code for an example.</div><div class="line"><a name="l05237"></a><span class="lineno"> 5237</span>&#160;</div><div class="line"><a name="l05238"></a><span class="lineno"> 5238</span>&#160;Note that gSOAP does not per se enforce a deallocation policy and the user can</div><div class="line"><a name="l05239"></a><span class="lineno"> 5239</span>&#160;adopt a deallocation policy that works best for a particular application.  As a</div><div class="line"><a name="l05240"></a><span class="lineno"> 5240</span>&#160;consequence, deserialized data is never deallocated by the gSOAP runtime unless</div><div class="line"><a name="l05241"></a><span class="lineno"> 5241</span>&#160;the user explicitly forces deallocation by calling functions to deallocate data</div><div class="line"><a name="l05242"></a><span class="lineno"> 5242</span>&#160;collectively or individually.</div><div class="line"><a name="l05243"></a><span class="lineno"> 5243</span>&#160;</div><div class="line"><a name="l05244"></a><span class="lineno"> 5244</span>&#160;The deallocation functions are:</div><div class="line"><a name="l05245"></a><span class="lineno"> 5245</span>&#160;</div><div class="line"><a name="l05246"></a><span class="lineno"> 5246</span>&#160;* `soap_destroy(struct soap *soap)` Remove all dynamically allocated C++ objects. must be called before `soap_end()` </div><div class="line"><a name="l05247"></a><span class="lineno"> 5247</span>&#160;</div><div class="line"><a name="l05248"></a><span class="lineno"> 5248</span>&#160;* `soap_end(struct soap *soap)` Remove temporary data and deserialized data except class instances </div><div class="line"><a name="l05249"></a><span class="lineno"> 5249</span>&#160;</div><div class="line"><a name="l05250"></a><span class="lineno"> 5250</span>&#160;* `soap_free_temp(struct soap *soap)` Instead of `soap_destroy` and `soap_end`: remove temporary data only </div><div class="line"><a name="l05251"></a><span class="lineno"> 5251</span>&#160;</div><div class="line"><a name="l05252"></a><span class="lineno"> 5252</span>&#160;* `soap_dealloc(struct soap *soap, void *p)` Remove malloced data at `p`. When `p==NULL`: remove all dynamically allocated (deserialized) data except class instances </div><div class="line"><a name="l05253"></a><span class="lineno"> 5253</span>&#160;</div><div class="line"><a name="l05254"></a><span class="lineno"> 5254</span>&#160;* `soap_delete(struct soap *soap, void *p)` Remove class instance at `p`. When `p==NULL`: remove all dynamically allocated (deserialized) class instances (this is identical to calling soap_destroy(struct soap *soap)) </div><div class="line"><a name="l05255"></a><span class="lineno"> 5255</span>&#160;</div><div class="line"><a name="l05256"></a><span class="lineno"> 5256</span>&#160;* `soap_unlink(struct soap *soap, void *p)` Unlink data/object at `p` from gSOAP&#39;s deallocation chain so gSOAP won&#39;t deallocate it </div><div class="line"><a name="l05257"></a><span class="lineno"> 5257</span>&#160;</div><div class="line"><a name="l05258"></a><span class="lineno"> 5258</span>&#160;* `soap_done(struct soap *soap)` Detach context (reset runtime context) </div><div class="line"><a name="l05259"></a><span class="lineno"> 5259</span>&#160;</div><div class="line"><a name="l05260"></a><span class="lineno"> 5260</span>&#160;* `soap_free(struct soap *soap)` Detach and free context (allocated with `soap_new`) </div><div class="line"><a name="l05261"></a><span class="lineno"> 5261</span>&#160;</div><div class="line"><a name="l05262"></a><span class="lineno"> 5262</span>&#160;Temporary data (i.e. the hash tables) are automatically removed with calls to</div><div class="line"><a name="l05263"></a><span class="lineno"> 5263</span>&#160;the `soap_free_temp` function which is also made by `soap_end` and</div><div class="line"><a name="l05264"></a><span class="lineno"> 5264</span>&#160;`soap_done` or when the next call to a stub or skeleton routine is made to</div><div class="line"><a name="l05265"></a><span class="lineno"> 5265</span>&#160;send a message or receive a message.  Deallocation of non-class based data is</div><div class="line"><a name="l05266"></a><span class="lineno"> 5266</span>&#160;straightforward: `soap_end` removes all dynamically allocated deserialized</div><div class="line"><a name="l05267"></a><span class="lineno"> 5267</span>&#160;data (data allocated with `soap_malloc`.  That is, when the client/service</div><div class="line"><a name="l05268"></a><span class="lineno"> 5268</span>&#160;application does not use any class instances that are (de)marshalled, but uses</div><div class="line"><a name="l05269"></a><span class="lineno"> 5269</span>&#160;structs, arrays, etc., then calling the `soap_end` function is safe to</div><div class="line"><a name="l05270"></a><span class="lineno"> 5270</span>&#160;remove all deserialized data.  The function can be called after processing the</div><div class="line"><a name="l05271"></a><span class="lineno"> 5271</span>&#160;deserialized data of a service operation call or after a number of service operation</div><div class="line"><a name="l05272"></a><span class="lineno"> 5272</span>&#160;calls have been made.  The function is also typically called after</div><div class="line"><a name="l05273"></a><span class="lineno"> 5273</span>&#160;`soap_serve`, when the service finished sending the response to a client</div><div class="line"><a name="l05274"></a><span class="lineno"> 5274</span>&#160;and the deserialized client request data can be removed.</div><div class="line"><a name="l05275"></a><span class="lineno"> 5275</span>&#160;</div><div class="line"><a name="l05276"></a><span class="lineno"> 5276</span>&#160;Individual data objects can be unlinked from the deallocation chain if</div><div class="line"><a name="l05277"></a><span class="lineno"> 5277</span>&#160;necessary, to prevent deallocation by the collective `soap_end` or</div><div class="line"><a name="l05278"></a><span class="lineno"> 5278</span>&#160;`soap_destroy` functions.</div><div class="line"><a name="l05279"></a><span class="lineno"> 5279</span>&#160;</div><div class="line"><a name="l05280"></a><span class="lineno"> 5280</span>&#160;### Memory Allocation and Management Policies</div><div class="line"><a name="l05281"></a><span class="lineno"> 5281</span>&#160;</div><div class="line"><a name="l05282"></a><span class="lineno"> 5282</span>&#160;There are three situations to consider for memory deallocation policies for class instances:</div><div class="line"><a name="l05283"></a><span class="lineno"> 5283</span>&#160;</div><div class="line"><a name="l05284"></a><span class="lineno"> 5284</span>&#160;</div><div class="line"><a name="l05285"></a><span class="lineno"> 5285</span>&#160;*  the program code deletes the class</div><div class="line"><a name="l05286"></a><span class="lineno"> 5286</span>&#160;instances and the class destructors in turn SHOULD delete and free any dynamically allocated data (deep deallocation) without</div><div class="line"><a name="l05287"></a><span class="lineno"> 5287</span>&#160;calling the `soap_end` and `soap_destroy` functions,</div><div class="line"><a name="l05288"></a><span class="lineno"> 5288</span>&#160;</div><div class="line"><a name="l05289"></a><span class="lineno"> 5289</span>&#160;*  or the class</div><div class="line"><a name="l05290"></a><span class="lineno"> 5290</span>&#160;destructors SHOULD NOT deallocate any data and the `soap_end` and `soap_destroy` functions can be called to remove</div><div class="line"><a name="l05291"></a><span class="lineno"> 5291</span>&#160;the data.</div><div class="line"><a name="l05292"></a><span class="lineno"> 5292</span>&#160;</div><div class="line"><a name="l05293"></a><span class="lineno"> 5293</span>&#160;*  or the class</div><div class="line"><a name="l05294"></a><span class="lineno"> 5294</span>&#160;destructors SHOULD mark their own deallocation and mark the deallocation of any other data deallocated by it&#39;s destructors</div><div class="line"><a name="l05295"></a><span class="lineno"> 5295</span>&#160;by calling the `soap_unlink` function. This allows</div><div class="line"><a name="l05296"></a><span class="lineno"> 5296</span>&#160;`soap_destroy` and `soap_end` to remove the remaining instances and data without causing duplicate deallocations.</div><div class="line"><a name="l05297"></a><span class="lineno"> 5297</span>&#160;</div><div class="line"><a name="l05298"></a><span class="lineno"> 5298</span>&#160;It is advised to use pointers to class instances that are used within other structs and classes to avoid the creation of temporary</div><div class="line"><a name="l05299"></a><span class="lineno"> 5299</span>&#160;class instances during deserialization. The problem with temporary class instances is that the destructor of the temporary may affect data used by</div><div class="line"><a name="l05300"></a><span class="lineno"> 5300</span>&#160;other instances through the sharing of data parts accessed with pointers. Temporaries and even whole copies of class instances</div><div class="line"><a name="l05301"></a><span class="lineno"> 5301</span>&#160;can be created when deserializing SOAP multi-referenced objects.</div><div class="line"><a name="l05302"></a><span class="lineno"> 5302</span>&#160;A dynamic array of class instances is similar: temporaries may be created to fill the array upon deserialization. To avoid</div><div class="line"><a name="l05303"></a><span class="lineno"> 5303</span>&#160;problems, use dynamic arrays of pointers to class instances. This also enables the exchange of polymorphic arrays when the</div><div class="line"><a name="l05304"></a><span class="lineno"> 5304</span>&#160;elements are instances of classes in an inheritance hierarchy.</div><div class="line"><a name="l05305"></a><span class="lineno"> 5305</span>&#160;In addition, allocate data and class instances with `soap_malloc` and `soap_new_X` functions (more details below).</div><div class="line"><a name="l05306"></a><span class="lineno"> 5306</span>&#160;</div><div class="line"><a name="l05307"></a><span class="lineno"> 5307</span>&#160;To summarize, it is advised to pass class data types by pointer to a service operation. For example:</div><div class="line"><a name="l05308"></a><span class="lineno"> 5308</span>&#160;</div><div class="line"><a name="l05309"></a><span class="lineno"> 5309</span>&#160;```cpp</div><div class="line"><a name="l05310"></a><span class="lineno"> 5310</span>&#160;class X { ... }; </div><div class="line"><a name="l05311"></a><span class="lineno"> 5311</span>&#160;ns__remoteMethod(X *in, ...);</div><div class="line"><a name="l05312"></a><span class="lineno"> 5312</span>&#160;```</div><div class="line"><a name="l05313"></a><span class="lineno"> 5313</span>&#160;</div><div class="line"><a name="l05314"></a><span class="lineno"> 5314</span>&#160;Response elements that are class data types can be passed by reference, as in:</div><div class="line"><a name="l05315"></a><span class="lineno"> 5315</span>&#160;</div><div class="line"><a name="l05316"></a><span class="lineno"> 5316</span>&#160;```cpp</div><div class="line"><a name="l05317"></a><span class="lineno"> 5317</span>&#160;class X { ... }; </div><div class="line"><a name="l05318"></a><span class="lineno"> 5318</span>&#160;class ns__remoteMethodResponse { ... }; </div><div class="line"><a name="l05319"></a><span class="lineno"> 5319</span>&#160;ns__remoteMethod(X *in, ns__remoteMethodResponse &amp;out);</div><div class="line"><a name="l05320"></a><span class="lineno"> 5320</span>&#160;```</div><div class="line"><a name="l05321"></a><span class="lineno"> 5321</span>&#160;</div><div class="line"><a name="l05322"></a><span class="lineno"> 5322</span>&#160;But dynamic arrays declared as class data types should use a pointer to a valid object that will be overwritten when the</div><div class="line"><a name="l05323"></a><span class="lineno"> 5323</span>&#160;function is called, as in:</div><div class="line"><a name="l05324"></a><span class="lineno"> 5324</span>&#160;</div><div class="line"><a name="l05325"></a><span class="lineno"> 5325</span>&#160;```cpp</div><div class="line"><a name="l05326"></a><span class="lineno"> 5326</span>&#160;typedef int xsd__int; </div><div class="line"><a name="l05327"></a><span class="lineno"> 5327</span>&#160;class X { ... }; </div><div class="line"><a name="l05328"></a><span class="lineno"> 5328</span>&#160;class ArrayOfint { xsd__int *__ptr; int __size; }; </div><div class="line"><a name="l05329"></a><span class="lineno"> 5329</span>&#160;ns__remoteMethod(X *in, ArrayOfint *out);</div><div class="line"><a name="l05330"></a><span class="lineno"> 5330</span>&#160;```</div><div class="line"><a name="l05331"></a><span class="lineno"> 5331</span>&#160;</div><div class="line"><a name="l05332"></a><span class="lineno"> 5332</span>&#160;Or a reference to a valid or `NULL` pointer, as in:</div><div class="line"><a name="l05333"></a><span class="lineno"> 5333</span>&#160;</div><div class="line"><a name="l05334"></a><span class="lineno"> 5334</span>&#160;```cpp</div><div class="line"><a name="l05335"></a><span class="lineno"> 5335</span>&#160;typedef int xsd__int; </div><div class="line"><a name="l05336"></a><span class="lineno"> 5336</span>&#160;class X { ... }; </div><div class="line"><a name="l05337"></a><span class="lineno"> 5337</span>&#160;class ArrayOfint { xsd__int *__ptr; int __size; }; </div><div class="line"><a name="l05338"></a><span class="lineno"> 5338</span>&#160;ns__remoteMethod(X *in, ArrayOfint *&amp;out);</div><div class="line"><a name="l05339"></a><span class="lineno"> 5339</span>&#160;```</div><div class="line"><a name="l05340"></a><span class="lineno"> 5340</span>&#160;</div><div class="line"><a name="l05341"></a><span class="lineno"> 5341</span>&#160;The gSOAP memory allocation functions can be used in client and/or service code to allocate temporary data that will be</div><div class="line"><a name="l05342"></a><span class="lineno"> 5342</span>&#160;automatically deallocated.</div><div class="line"><a name="l05343"></a><span class="lineno"> 5343</span>&#160;These functions are:</div><div class="line"><a name="l05344"></a><span class="lineno"> 5344</span>&#160;</div><div class="line"><a name="l05345"></a><span class="lineno"> 5345</span>&#160;* `void *soap_malloc(struct soap *soap, size_t n)` return pointer to `n` bytes </div><div class="line"><a name="l05346"></a><span class="lineno"> 5346</span>&#160;</div><div class="line"><a name="l05347"></a><span class="lineno"> 5347</span>&#160;* `Type *soap_new_Type(struct soap *soap)` allocate and instantiate</div><div class="line"><a name="l05348"></a><span class="lineno"> 5348</span>&#160;</div><div class="line"><a name="l05349"></a><span class="lineno"> 5349</span>&#160;* `Type *soap_new_Type(struct soap *soap, int n)` instantiate array of `n` objects </div><div class="line"><a name="l05350"></a><span class="lineno"> 5350</span>&#160;</div><div class="line"><a name="l05351"></a><span class="lineno"> 5351</span>&#160;* `Type *soap_new_set_Type(struct soap *soap, m1, ..., mn)` instantiate and set members</div><div class="line"><a name="l05352"></a><span class="lineno"> 5352</span>&#160;</div><div class="line"><a name="l05353"></a><span class="lineno"> 5353</span>&#160;* `Type *soap_new_req_Type(struct soap *soap, m1, ..., mn)` instantiate and set required-only members</div><div class="line"><a name="l05354"></a><span class="lineno"> 5354</span>&#160;</div><div class="line"><a name="l05355"></a><span class="lineno"> 5355</span>&#160;The `soap_new_X` functions are generated by the gSOAP `soapcpp2` compiler for every type in the header file.</div><div class="line"><a name="l05356"></a><span class="lineno"> 5356</span>&#160;</div><div class="line"><a name="l05357"></a><span class="lineno"> 5357</span>&#160;Space allocated with `soap_malloc` will be released with the `soap_end` and `soap_dealloc` functions.</div><div class="line"><a name="l05358"></a><span class="lineno"> 5358</span>&#160;All objects instantiated with `soap_new_X(struct soap*)` are removed altogether with `soap_destroy(struct soap*)`.</div><div class="line"><a name="l05359"></a><span class="lineno"> 5359</span>&#160;</div><div class="line"><a name="l05360"></a><span class="lineno"> 5360</span>&#160;For example, the following service uses temporary data in the service operation implementation:</div><div class="line"><a name="l05361"></a><span class="lineno"> 5361</span>&#160;</div><div class="line"><a name="l05362"></a><span class="lineno"> 5362</span>&#160;```cpp</div><div class="line"><a name="l05363"></a><span class="lineno"> 5363</span>&#160;int main() </div><div class="line"><a name="l05364"></a><span class="lineno"> 5364</span>&#160;{</div><div class="line"><a name="l05365"></a><span class="lineno"> 5365</span>&#160;  ... </div><div class="line"><a name="l05366"></a><span class="lineno"> 5366</span>&#160;  struct soap soap; </div><div class="line"><a name="l05367"></a><span class="lineno"> 5367</span>&#160;  soap_init(&amp;soap); </div><div class="line"><a name="l05368"></a><span class="lineno"> 5368</span>&#160;  soap_serve(&amp;soap); </div><div class="line"><a name="l05369"></a><span class="lineno"> 5369</span>&#160;  soap_end(&amp;soap); </div><div class="line"><a name="l05370"></a><span class="lineno"> 5370</span>&#160;  ... </div><div class="line"><a name="l05371"></a><span class="lineno"> 5371</span>&#160;}</div><div class="line"><a name="l05372"></a><span class="lineno"> 5372</span>&#160;```</div><div class="line"><a name="l05373"></a><span class="lineno"> 5373</span>&#160;</div><div class="line"><a name="l05374"></a><span class="lineno"> 5374</span>&#160;An example service operation that allocates a temporary string is:</div><div class="line"><a name="l05375"></a><span class="lineno"> 5375</span>&#160;</div><div class="line"><a name="l05376"></a><span class="lineno"> 5376</span>&#160;```cpp</div><div class="line"><a name="l05377"></a><span class="lineno"> 5377</span>&#160;int ns__itoa(struct soap *soap, int i, char **a) </div><div class="line"><a name="l05378"></a><span class="lineno"> 5378</span>&#160;{ </div><div class="line"><a name="l05379"></a><span class="lineno"> 5379</span>&#160;  *a = (char*)soap_malloc(soap, 11); </div><div class="line"><a name="l05380"></a><span class="lineno"> 5380</span>&#160;  sprintf(*a, &quot;%d&quot;, i); </div><div class="line"><a name="l05381"></a><span class="lineno"> 5381</span>&#160;  return SOAP_OK; </div><div class="line"><a name="l05382"></a><span class="lineno"> 5382</span>&#160;}</div><div class="line"><a name="l05383"></a><span class="lineno"> 5383</span>&#160;```</div><div class="line"><a name="l05384"></a><span class="lineno"> 5384</span>&#160;</div><div class="line"><a name="l05385"></a><span class="lineno"> 5385</span>&#160;This temporary allocation can also be used to allocate strings for the SOAP Fault data structure. For example:</div><div class="line"><a name="l05386"></a><span class="lineno"> 5386</span>&#160;</div><div class="line"><a name="l05387"></a><span class="lineno"> 5387</span>&#160;```cpp</div><div class="line"><a name="l05388"></a><span class="lineno"> 5388</span>&#160;int ns__mymethod(...) </div><div class="line"><a name="l05389"></a><span class="lineno"> 5389</span>&#160;{ ... </div><div class="line"><a name="l05390"></a><span class="lineno"> 5390</span>&#160;  if (exception) </div><div class="line"><a name="l05391"></a><span class="lineno"> 5391</span>&#160;  { </div><div class="line"><a name="l05392"></a><span class="lineno"> 5392</span>&#160;    char *msg = (char*)soap_malloc(soap, 1024); // allocate temporary space for detailed message </div><div class="line"><a name="l05393"></a><span class="lineno"> 5393</span>&#160;    sprintf(msg, &quot;...&quot;, ...); // produce the detailed message </div><div class="line"><a name="l05394"></a><span class="lineno"> 5394</span>&#160;    return soap_receiver_fault(soap, &quot;An exception occurred&quot;, msg); // return the server-side fault </div><div class="line"><a name="l05395"></a><span class="lineno"> 5395</span>&#160;  } </div><div class="line"><a name="l05396"></a><span class="lineno"> 5396</span>&#160;  ... </div><div class="line"><a name="l05397"></a><span class="lineno"> 5397</span>&#160;}</div><div class="line"><a name="l05398"></a><span class="lineno"> 5398</span>&#160;```</div><div class="line"><a name="l05399"></a><span class="lineno"> 5399</span>&#160;</div><div class="line"><a name="l05400"></a><span class="lineno"> 5400</span>&#160;Use `soap_receiver_fault(struct soap *soap, const char *faultstring, const char *detail)` to set a SOAP 1.1/1.2 fault at the server-side.</div><div class="line"><a name="l05401"></a><span class="lineno"> 5401</span>&#160;Use `soap_sender_fault(struct soap *soap, const char *faultstring, const char *detail)` to set a SOAP 1.1/1.2 unrecoverable Bad Request fault</div><div class="line"><a name="l05402"></a><span class="lineno"> 5402</span>&#160;at the server-side. Sending clients are not supposed to retry messages after a</div><div class="line"><a name="l05403"></a><span class="lineno"> 5403</span>&#160;Bad Request, while errors at the receiver-side indicate temporary problems.</div><div class="line"><a name="l05404"></a><span class="lineno"> 5404</span>&#160;</div><div class="line"><a name="l05405"></a><span class="lineno"> 5405</span>&#160;The above functions do not include a SOAP 1.2 Subcode element. To include Subcode element, use `soap_receiver_fault_subcode(struct soap *soap, const char *subcode, const char *faultstring, const char *detail)` to set a SOAP 1.1/1.2 fault with Subcode at the server-side.</div><div class="line"><a name="l05406"></a><span class="lineno"> 5406</span>&#160;Use `soap_sender_fault_subcode(struct soap *soap, const char *subcode, const char *faultstring, const char *detail)` to set a SOAP 1.1/1.2 unrecoverable Bad Request fault with Subcode at the server-side.</div><div class="line"><a name="l05407"></a><span class="lineno"> 5407</span>&#160;</div><div class="line"><a name="l05408"></a><span class="lineno"> 5408</span>&#160;gSOAP provides a function to duplicate a string into gSOAP&#39;s memory space:</div><div class="line"><a name="l05409"></a><span class="lineno"> 5409</span>&#160;</div><div class="line"><a name="l05410"></a><span class="lineno"> 5410</span>&#160;```cpp</div><div class="line"><a name="l05411"></a><span class="lineno"> 5411</span>&#160;char *soap_strdup(struct soap *soap, const char *s)</div><div class="line"><a name="l05412"></a><span class="lineno"> 5412</span>&#160;```</div><div class="line"><a name="l05413"></a><span class="lineno"> 5413</span>&#160;</div><div class="line"><a name="l05414"></a><span class="lineno"> 5414</span>&#160;The function allocates space for `s` with `soap_malloc`, copies the</div><div class="line"><a name="l05415"></a><span class="lineno"> 5415</span>&#160;string, and returns a pointer to the duplicated string. When `s` is NULL,</div><div class="line"><a name="l05416"></a><span class="lineno"> 5416</span>&#160;the function does not allocate and copy the string and returns NULL.</div><div class="line"><a name="l05417"></a><span class="lineno"> 5417</span>&#160;</div><div class="line"><a name="l05418"></a><span class="lineno"> 5418</span>&#160;### Intra-Class Memory Management        {#classmemory}</div><div class="line"><a name="l05419"></a><span class="lineno"> 5419</span>&#160;</div><div class="line"><a name="l05420"></a><span class="lineno"> 5420</span>&#160;When a class declaration has a `struct soap *` field, this field will be set to point to the current gSOAP runtime context by</div><div class="line"><a name="l05421"></a><span class="lineno"> 5421</span>&#160;gSOAP&#39;s deserializers and by the `soap_new_Class` functions.</div><div class="line"><a name="l05422"></a><span class="lineno"> 5422</span>&#160;This simplifies memory management for class instances.</div><div class="line"><a name="l05423"></a><span class="lineno"> 5423</span>&#160;The `struct soap*` pointer is implicitly set by the gSOAP deserializer for</div><div class="line"><a name="l05424"></a><span class="lineno"> 5424</span>&#160;the class or explicitly by calling the `soap_new_X` function for class `X`.</div><div class="line"><a name="l05425"></a><span class="lineno"> 5425</span>&#160;For example:</div><div class="line"><a name="l05426"></a><span class="lineno"> 5426</span>&#160;</div><div class="line"><a name="l05427"></a><span class="lineno"> 5427</span>&#160;```cpp</div><div class="line"><a name="l05428"></a><span class="lineno"> 5428</span>&#160;class Sample </div><div class="line"><a name="l05429"></a><span class="lineno"> 5429</span>&#160;{ public: </div><div class="line"><a name="l05430"></a><span class="lineno"> 5430</span>&#160;   struct soap *soap; // reference to gSOAP&#39;s run-time </div><div class="line"><a name="l05431"></a><span class="lineno"> 5431</span>&#160;   ... </div><div class="line"><a name="l05432"></a><span class="lineno"> 5432</span>&#160;   Sample(); </div><div class="line"><a name="l05433"></a><span class="lineno"> 5433</span>&#160;   ~Sample(); </div><div class="line"><a name="l05434"></a><span class="lineno"> 5434</span>&#160;};</div><div class="line"><a name="l05435"></a><span class="lineno"> 5435</span>&#160;```</div><div class="line"><a name="l05436"></a><span class="lineno"> 5436</span>&#160;</div><div class="line"><a name="l05437"></a><span class="lineno"> 5437</span>&#160;The constructor and destructor for class `Sample` are:</div><div class="line"><a name="l05438"></a><span class="lineno"> 5438</span>&#160;</div><div class="line"><a name="l05439"></a><span class="lineno"> 5439</span>&#160;```cpp</div><div class="line"><a name="l05440"></a><span class="lineno"> 5440</span>&#160;Sample::Sample() </div><div class="line"><a name="l05441"></a><span class="lineno"> 5441</span>&#160;{ this-&gt;soap = NULL; </div><div class="line"><a name="l05442"></a><span class="lineno"> 5442</span>&#160;} </div><div class="line"><a name="l05443"></a><span class="lineno"> 5443</span>&#160;Sample::~Sample() </div><div class="line"><a name="l05444"></a><span class="lineno"> 5444</span>&#160;{ soap_unlink(this-&gt;soap, this); </div><div class="line"><a name="l05445"></a><span class="lineno"> 5445</span>&#160;}</div><div class="line"><a name="l05446"></a><span class="lineno"> 5446</span>&#160;```</div><div class="line"><a name="l05447"></a><span class="lineno"> 5447</span>&#160;</div><div class="line"><a name="l05448"></a><span class="lineno"> 5448</span>&#160;The `soap_unlink()` call removes the object from gSOAP&#39;s deallocation chain.</div><div class="line"><a name="l05449"></a><span class="lineno"> 5449</span>&#160;In that way, `soap_destroy` can be safely called to remove all class instances.</div><div class="line"><a name="l05450"></a><span class="lineno"> 5450</span>&#160;The following code illustrates the explicit creation of a `Sample` object and cleanup:</div><div class="line"><a name="l05451"></a><span class="lineno"> 5451</span>&#160;</div><div class="line"><a name="l05452"></a><span class="lineno"> 5452</span>&#160;```cpp</div><div class="line"><a name="l05453"></a><span class="lineno"> 5453</span>&#160;struct soap *soap = soap_new(); // new gSOAP runtime </div><div class="line"><a name="l05454"></a><span class="lineno"> 5454</span>&#160;Sample *obj = soap_new_Sample(soap); // new Sample object with obj-&gt;soap set to runtime </div><div class="line"><a name="l05455"></a><span class="lineno"> 5455</span>&#160;... </div><div class="line"><a name="l05456"></a><span class="lineno"> 5456</span>&#160;delete obj; // also calls soap_unlink to remove obj from the deallocation chain </div><div class="line"><a name="l05457"></a><span class="lineno"> 5457</span>&#160;soap_destroy(soap); // deallocate all (other) class instances </div><div class="line"><a name="l05458"></a><span class="lineno"> 5458</span>&#160;soap_end(soap); // clean up</div><div class="line"><a name="l05459"></a><span class="lineno"> 5459</span>&#160;```</div><div class="line"><a name="l05460"></a><span class="lineno"> 5460</span>&#160;</div><div class="line"><a name="l05461"></a><span class="lineno"> 5461</span>&#160;Here is another example:</div><div class="line"><a name="l05462"></a><span class="lineno"> 5462</span>&#160;</div><div class="line"><a name="l05463"></a><span class="lineno"> 5463</span>&#160;```cpp</div><div class="line"><a name="l05464"></a><span class="lineno"> 5464</span>&#160;class ns__myClass </div><div class="line"><a name="l05465"></a><span class="lineno"> 5465</span>&#160;{ ... </div><div class="line"><a name="l05466"></a><span class="lineno"> 5466</span>&#160;   struct soap *soap; // set by soap_new_ns__myClass() </div><div class="line"><a name="l05467"></a><span class="lineno"> 5467</span>&#160;   char *name; </div><div class="line"><a name="l05468"></a><span class="lineno"> 5468</span>&#160;   void setName(const char *s); </div><div class="line"><a name="l05469"></a><span class="lineno"> 5469</span>&#160;   ... </div><div class="line"><a name="l05470"></a><span class="lineno"> 5470</span>&#160;};</div><div class="line"><a name="l05471"></a><span class="lineno"> 5471</span>&#160;```</div><div class="line"><a name="l05472"></a><span class="lineno"> 5472</span>&#160;</div><div class="line"><a name="l05473"></a><span class="lineno"> 5473</span>&#160;Calls to `soap_new_ns__myClass(soap)` will set the `soap` field in the class instance to the current gSOAP</div><div class="line"><a name="l05474"></a><span class="lineno"> 5474</span>&#160;context. Because the deserializers invoke the `soap_new` functions, the `soap` field of the `ns__myClass`</div><div class="line"><a name="l05475"></a><span class="lineno"> 5475</span>&#160;instances are set as well.</div><div class="line"><a name="l05476"></a><span class="lineno"> 5476</span>&#160;This mechanism is convenient when Web Service methods need to return objects that are instantiated in the methods.</div><div class="line"><a name="l05477"></a><span class="lineno"> 5477</span>&#160;For example</div><div class="line"><a name="l05478"></a><span class="lineno"> 5478</span>&#160;</div><div class="line"><a name="l05479"></a><span class="lineno"> 5479</span>&#160;```cpp</div><div class="line"><a name="l05480"></a><span class="lineno"> 5480</span>&#160;int ns__myMethod(struct soap *soap, ...) </div><div class="line"><a name="l05481"></a><span class="lineno"> 5481</span>&#160;{ </div><div class="line"><a name="l05482"></a><span class="lineno"> 5482</span>&#160;   ns__myClass *p = soap_new_ns__myClass(soap); </div><div class="line"><a name="l05483"></a><span class="lineno"> 5483</span>&#160;   p-&gt;setName(&quot;SOAP&quot;); </div><div class="line"><a name="l05484"></a><span class="lineno"> 5484</span>&#160;   return SOAP_OK; </div><div class="line"><a name="l05485"></a><span class="lineno"> 5485</span>&#160;} </div><div class="line"><a name="l05486"></a><span class="lineno"> 5486</span>&#160;void ns__myClass::ns__setName(const char *s) </div><div class="line"><a name="l05487"></a><span class="lineno"> 5487</span>&#160;{ </div><div class="line"><a name="l05488"></a><span class="lineno"> 5488</span>&#160;   if (soap) </div><div class="line"><a name="l05489"></a><span class="lineno"> 5489</span>&#160;     name = (char*)soap_malloc(soap, strlen(s)+1); </div><div class="line"><a name="l05490"></a><span class="lineno"> 5490</span>&#160;   else </div><div class="line"><a name="l05491"></a><span class="lineno"> 5491</span>&#160;     name = (char*)malloc(strlen(s)+1); </div><div class="line"><a name="l05492"></a><span class="lineno"> 5492</span>&#160;   strcpy(name, s); </div><div class="line"><a name="l05493"></a><span class="lineno"> 5493</span>&#160;} </div><div class="line"><a name="l05494"></a><span class="lineno"> 5494</span>&#160;ns__myClass::ns__myClass() </div><div class="line"><a name="l05495"></a><span class="lineno"> 5495</span>&#160;{ </div><div class="line"><a name="l05496"></a><span class="lineno"> 5496</span>&#160;   soap = NULL; </div><div class="line"><a name="l05497"></a><span class="lineno"> 5497</span>&#160;   name = NULL; </div><div class="line"><a name="l05498"></a><span class="lineno"> 5498</span>&#160;} </div><div class="line"><a name="l05499"></a><span class="lineno"> 5499</span>&#160;ns__myClass::~ns__myClass() </div><div class="line"><a name="l05500"></a><span class="lineno"> 5500</span>&#160;{ </div><div class="line"><a name="l05501"></a><span class="lineno"> 5501</span>&#160;   if (!soap &amp;&amp; name) free(name); </div><div class="line"><a name="l05502"></a><span class="lineno"> 5502</span>&#160;   soap_unlink(soap, this); </div><div class="line"><a name="l05503"></a><span class="lineno"> 5503</span>&#160;} </div><div class="line"><a name="l05504"></a><span class="lineno"> 5504</span>&#160;```</div><div class="line"><a name="l05505"></a><span class="lineno"> 5505</span>&#160;</div><div class="line"><a name="l05506"></a><span class="lineno"> 5506</span>&#160;Calling `soap_destroy` right after `soap_serve` in the Web Service will destroy all dynamically allocated</div><div class="line"><a name="l05507"></a><span class="lineno"> 5507</span>&#160;class instances.</div><div class="line"><a name="l05508"></a><span class="lineno"> 5508</span>&#160;</div><div class="line"><a name="l05509"></a><span class="lineno"> 5509</span>&#160;## Debugging</div><div class="line"><a name="l05510"></a><span class="lineno"> 5510</span>&#160;</div><div class="line"><a name="l05511"></a><span class="lineno"> 5511</span>&#160;To activate debugging and message logging, set the `#define DEBUG` macro</div><div class="line"><a name="l05512"></a><span class="lineno"> 5512</span>&#160;on the compiler&#39;s command line (typically as a compiler option `-DDEBUG`)</div><div class="line"><a name="l05513"></a><span class="lineno"> 5513</span>&#160;or in `stdsoap2.h`, and recompile your code together with `stdsoap2.c`</div><div class="line"><a name="l05514"></a><span class="lineno"> 5514</span>&#160;or `stdsoap2.cpp` (instead of `libgsoap`). When using</div><div class="line"><a name="l05515"></a><span class="lineno"> 5515</span>&#160;`libgsoap` and `libgsoap++`, reinstall the software with</div><div class="line"><a name="l05516"></a><span class="lineno"> 5516</span>&#160;`./configure --enable-debug`.</div><div class="line"><a name="l05517"></a><span class="lineno"> 5517</span>&#160;</div><div class="line"><a name="l05518"></a><span class="lineno"> 5518</span>&#160;When your client and server applications run, they will log their activity in three</div><div class="line"><a name="l05519"></a><span class="lineno"> 5519</span>&#160;separate files:</div><div class="line"><a name="l05520"></a><span class="lineno"> 5520</span>&#160;</div><div class="line"><a name="l05521"></a><span class="lineno"> 5521</span>&#160;* `SENT.log` the SOAP content transmitted by the application </div><div class="line"><a name="l05522"></a><span class="lineno"> 5522</span>&#160;</div><div class="line"><a name="l05523"></a><span class="lineno"> 5523</span>&#160;* `RECV.log` the SOAP content received by the application </div><div class="line"><a name="l05524"></a><span class="lineno"> 5524</span>&#160;</div><div class="line"><a name="l05525"></a><span class="lineno"> 5525</span>&#160;* `TEST.log` a log containing various activities performed by the application </div><div class="line"><a name="l05526"></a><span class="lineno"> 5526</span>&#160;</div><div class="line"><a name="l05527"></a><span class="lineno"> 5527</span>&#160;@warning The client and server applications may run slow due to the logging activity.</div><div class="line"><a name="l05528"></a><span class="lineno"> 5528</span>&#160;</div><div class="line"><a name="l05529"></a><span class="lineno"> 5529</span>&#160;@note: Set macro `DEBUG_STAMP` instead of `DEBUG` to add time</div><div class="line"><a name="l05530"></a><span class="lineno"> 5530</span>&#160;stamps to `TEST.log`. This works on platforms supporting the</div><div class="line"><a name="l05531"></a><span class="lineno"> 5531</span>&#160;`gettimeofday` function.</div><div class="line"><a name="l05532"></a><span class="lineno"> 5532</span>&#160;</div><div class="line"><a name="l05533"></a><span class="lineno"> 5533</span>&#160;@warning When installing a CGI application on the Web with debugging activated, the log files may sometimes not be created due to file</div><div class="line"><a name="l05534"></a><span class="lineno"> 5534</span>&#160;access permission restrictions imposed on CGI applications. To get around this, create empty log files with universal write</div><div class="line"><a name="l05535"></a><span class="lineno"> 5535</span>&#160;permissions. Be careful about the security implication of this.</div><div class="line"><a name="l05536"></a><span class="lineno"> 5536</span>&#160;</div><div class="line"><a name="l05537"></a><span class="lineno"> 5537</span>&#160;You can test a service CGI application without deploying it on the Web.</div><div class="line"><a name="l05538"></a><span class="lineno"> 5538</span>&#160;To do this, create a client application for the service and activate message logging by this client.</div><div class="line"><a name="l05539"></a><span class="lineno"> 5539</span>&#160;Remove any old `SENT.log` file and run the client (which connects to the Web service or to another dummy, but valid address)</div><div class="line"><a name="l05540"></a><span class="lineno"> 5540</span>&#160;and copy the `SENT.log` file to another file, e.g. `SENT.tst`.</div><div class="line"><a name="l05541"></a><span class="lineno"> 5541</span>&#160;Then redirect the `SENT.tst` file to the service CGI application.  For example,</div><div class="line"><a name="l05542"></a><span class="lineno"> 5542</span>&#160;</div><div class="line"><a name="l05543"></a><span class="lineno"> 5543</span>&#160;    &gt; ./myservice.cgi &lt; SENT.tst</div><div class="line"><a name="l05544"></a><span class="lineno"> 5544</span>&#160;</div><div class="line"><a name="l05545"></a><span class="lineno"> 5545</span>&#160;This should display the service response on the terminal.</div><div class="line"><a name="l05546"></a><span class="lineno"> 5546</span>&#160;</div><div class="line"><a name="l05547"></a><span class="lineno"> 5547</span>&#160;The file names of the log files and the logging activity can be controlled at the application level. This allows the creation of</div><div class="line"><a name="l05548"></a><span class="lineno"> 5548</span>&#160;separate log files by separate services, clients, and threads.</div><div class="line"><a name="l05549"></a><span class="lineno"> 5549</span>&#160;For example, the following service logs all SOAP messages (but no debug messages) in separate directories:</div><div class="line"><a name="l05550"></a><span class="lineno"> 5550</span>&#160;</div><div class="line"><a name="l05551"></a><span class="lineno"> 5551</span>&#160;```cpp</div><div class="line"><a name="l05552"></a><span class="lineno"> 5552</span>&#160;struct soap soap; </div><div class="line"><a name="l05553"></a><span class="lineno"> 5553</span>&#160;soap_init(&amp;soap); </div><div class="line"><a name="l05554"></a><span class="lineno"> 5554</span>&#160;... </div><div class="line"><a name="l05555"></a><span class="lineno"> 5555</span>&#160;soap_set_recv_logfile(&amp;soap, &quot;logs/recv/service12.log&quot;); // append all messages received in /logs/recv/service12.log </div><div class="line"><a name="l05556"></a><span class="lineno"> 5556</span>&#160;soap_set_sent_logfile(&amp;soap, &quot;logs/sent/service12.log&quot;); // append all messages sent in /logs/sent/service12.log </div><div class="line"><a name="l05557"></a><span class="lineno"> 5557</span>&#160;soap_set_test_logfile(&amp;soap, NULL); // no file name: do not save debug messages </div><div class="line"><a name="l05558"></a><span class="lineno"> 5558</span>&#160;... </div><div class="line"><a name="l05559"></a><span class="lineno"> 5559</span>&#160;soap_serve(&amp;soap); </div><div class="line"><a name="l05560"></a><span class="lineno"> 5560</span>&#160;...</div><div class="line"><a name="l05561"></a><span class="lineno"> 5561</span>&#160;```</div><div class="line"><a name="l05562"></a><span class="lineno"> 5562</span>&#160;</div><div class="line"><a name="l05563"></a><span class="lineno"> 5563</span>&#160;Likewise, messages can be logged for individual client-side service operation calls.</div><div class="line"><a name="l05564"></a><span class="lineno"> 5564</span>&#160;</div><div class="line"><a name="l05565"></a><span class="lineno"> 5565</span>&#160;## Generating an Auto Test Server for Client Testing</div><div class="line"><a name="l05566"></a><span class="lineno"> 5566</span>&#160;</div><div class="line"><a name="l05567"></a><span class="lineno"> 5567</span>&#160;The `soapcpp2 -T` option generates an auto-test server application in `soapTester.cpp`, which is to be compiled and linked with the code generated for a server implementation, i.e. `soapServer.cpp` (or with the generated server object class) and `soapC.cpp`. The feature also supports C, so use the `soapcpp2 -c` option to generate C.</div><div class="line"><a name="l05568"></a><span class="lineno"> 5568</span>&#160;</div><div class="line"><a name="l05569"></a><span class="lineno"> 5569</span>&#160;The auto-test server can be used to test a client application. Suppose the</div><div class="line"><a name="l05570"></a><span class="lineno"> 5570</span>&#160;generated code is compiled into the executable named `tester` (compile `soapServer.cpp`, `soapC.cpp`, and `stdsoap2.cpp` or link `libgsoap++`). We can use the IO</div><div class="line"><a name="l05571"></a><span class="lineno"> 5571</span>&#160;redirect to &quot;send&quot; it a message saved in a file, for example one of the</div><div class="line"><a name="l05572"></a><span class="lineno"> 5572</span>&#160;sample request messages generated by `soapcpp2`:</div><div class="line"><a name="l05573"></a><span class="lineno"> 5573</span>&#160;</div><div class="line"><a name="l05574"></a><span class="lineno"> 5574</span>&#160;    &gt; ./tester &lt; example.req.xml</div><div class="line"><a name="l05575"></a><span class="lineno"> 5575</span>&#160;</div><div class="line"><a name="l05576"></a><span class="lineno"> 5576</span>&#160;which then returns the response with default XML values displayed on the terminal.</div><div class="line"><a name="l05577"></a><span class="lineno"> 5577</span>&#160;</div><div class="line"><a name="l05578"></a><span class="lineno"> 5578</span>&#160;To run the auto test service on a port to test a client against, use two command-line arguments. The first argument is the OR-ed values of the gSOAP runtime context flags such as `SOAP_IO_KEEPALIVE` (0x10 = 16) and the second argument is the port number:</div><div class="line"><a name="l05579"></a><span class="lineno"> 5579</span>&#160;</div><div class="line"><a name="l05580"></a><span class="lineno"> 5580</span>&#160;    &gt; ./tester 16 8080</div><div class="line"><a name="l05581"></a><span class="lineno"> 5581</span>&#160;</div><div class="line"><a name="l05582"></a><span class="lineno"> 5582</span>&#160;This starts an iterative stand-alone server on port 8080. This way, messages</div><div class="line"><a name="l05583"></a><span class="lineno"> 5583</span>&#160;can be sent to *`http://localhost:8080`* to test the client. The data in the</div><div class="line"><a name="l05584"></a><span class="lineno"> 5584</span>&#160;response messages are copied from the request messages</div><div class="line"><a name="l05585"></a><span class="lineno"> 5585</span>&#160;when possible, or XML default values, or empty otherwise.</div><div class="line"><a name="l05586"></a><span class="lineno"> 5586</span>&#160;</div><div class="line"><a name="l05587"></a><span class="lineno"> 5587</span>&#160;## Generating Deep Copy and Deletion Code</div><div class="line"><a name="l05588"></a><span class="lineno"> 5588</span>&#160;</div><div class="line"><a name="l05589"></a><span class="lineno"> 5589</span>&#160;The `soapcpp2 -Ec` option generates deep copy code for each type `T`:</div><div class="line"><a name="l05590"></a><span class="lineno"> 5590</span>&#160;</div><div class="line"><a name="l05591"></a><span class="lineno"> 5591</span>&#160;`T * soap_dup_T(struct soap*, T *dst, const T *src)` deep copy `src`</div><div class="line"><a name="l05592"></a><span class="lineno"> 5592</span>&#160;into `dst`, replicating all deep cycles and shared pointers when a managing</div><div class="line"><a name="l05593"></a><span class="lineno"> 5593</span>&#160;soap context is provided as argument. When `dst` is NULL, allocates space</div><div class="line"><a name="l05594"></a><span class="lineno"> 5594</span>&#160;for `dst`. Deep copy is a tree when argument is NULL, but the presence of</div><div class="line"><a name="l05595"></a><span class="lineno"> 5595</span>&#160;deep cycles will lead to non-termination. Use flag `SOAP_XML_TREE` with</div><div class="line"><a name="l05596"></a><span class="lineno"> 5596</span>&#160;managing context to copy into a tree without cycles and</div><div class="line"><a name="l05597"></a><span class="lineno"> 5597</span>&#160;pointers to shared objects. Returns `dst` (or allocated space when</div><div class="line"><a name="l05598"></a><span class="lineno"> 5598</span>&#160;`dst` is NULL).</div><div class="line"><a name="l05599"></a><span class="lineno"> 5599</span>&#160;</div><div class="line"><a name="l05600"></a><span class="lineno"> 5600</span>&#160;For classes `T`, also a deep copy method is generated with option `-Ec`:</div><div class="line"><a name="l05601"></a><span class="lineno"> 5601</span>&#160;</div><div class="line"><a name="l05602"></a><span class="lineno"> 5602</span>&#160;`virtual T * T::soap_dup(struct soap*) const` returns a duplicate of this</div><div class="line"><a name="l05603"></a><span class="lineno"> 5603</span>&#160;object by deep copying, replicating all deep cycles and shared pointers when a</div><div class="line"><a name="l05604"></a><span class="lineno"> 5604</span>&#160;managing soap context is provided as argument. Deep copy is a tree when</div><div class="line"><a name="l05605"></a><span class="lineno"> 5605</span>&#160;argument is NULL, but the presence of deep cycles will lead to non-termination.</div><div class="line"><a name="l05606"></a><span class="lineno"> 5606</span>&#160;Use flag `SOAP_XML_TREE` with managing context to copy into a tree</div><div class="line"><a name="l05607"></a><span class="lineno"> 5607</span>&#160;without cycles and pointers to shared objects.</div><div class="line"><a name="l05608"></a><span class="lineno"> 5608</span>&#160;</div><div class="line"><a name="l05609"></a><span class="lineno"> 5609</span>&#160;The `soapcpp2 -Ed` option generates deep deletion code for each type</div><div class="line"><a name="l05610"></a><span class="lineno"> 5610</span>&#160;`T`:</div><div class="line"><a name="l05611"></a><span class="lineno"> 5611</span>&#160;</div><div class="line"><a name="l05612"></a><span class="lineno"> 5612</span>&#160;`void soap_del_T(const T*)` deletes all heap-allocated members of</div><div class="line"><a name="l05613"></a><span class="lineno"> 5613</span>&#160;this object by deep deletion ONLY IF this object and all of its (deep) members</div><div class="line"><a name="l05614"></a><span class="lineno"> 5614</span>&#160;are not managed by a soap context AND the deep structure is a tree (no cycles</div><div class="line"><a name="l05615"></a><span class="lineno"> 5615</span>&#160;and co-referenced objects by way of multiple</div><div class="line"><a name="l05616"></a><span class="lineno"> 5616</span>&#160;(non-smart) pointers pointing to the same data). Can be safely used after</div><div class="line"><a name="l05617"></a><span class="lineno"> 5617</span>&#160;`soap_dup(NULL)` to delete the deep copy. Does not delete the object</div><div class="line"><a name="l05618"></a><span class="lineno"> 5618</span>&#160;itself.</div><div class="line"><a name="l05619"></a><span class="lineno"> 5619</span>&#160;</div><div class="line"><a name="l05620"></a><span class="lineno"> 5620</span>&#160;For classes `T`, also a deep deletion method is generated with option</div><div class="line"><a name="l05621"></a><span class="lineno"> 5621</span>&#160;`-Ed`:</div><div class="line"><a name="l05622"></a><span class="lineno"> 5622</span>&#160;</div><div class="line"><a name="l05623"></a><span class="lineno"> 5623</span>&#160;`virtual void T::soap_del() const` deletes all</div><div class="line"><a name="l05624"></a><span class="lineno"> 5624</span>&#160;heap-allocated members of this object by deep deletion ONLY IF this object</div><div class="line"><a name="l05625"></a><span class="lineno"> 5625</span>&#160;and all of its (deep) members are not managed by a soap context AND the deep</div><div class="line"><a name="l05626"></a><span class="lineno"> 5626</span>&#160;structure is a tree (no cycles and co-referenced objects by way of multiple</div><div class="line"><a name="l05627"></a><span class="lineno"> 5627</span>&#160;(non-smart) pointers pointing to the same data).Can be safely used after</div><div class="line"><a name="l05628"></a><span class="lineno"> 5628</span>&#160;`soap_dup(NULL)` to delete the deep copy. Does not delete the object</div><div class="line"><a name="l05629"></a><span class="lineno"> 5629</span>&#160;itself.</div><div class="line"><a name="l05630"></a><span class="lineno"> 5630</span>&#160;</div><div class="line"><a name="l05631"></a><span class="lineno"> 5631</span>&#160;## Required Libraries</div><div class="line"><a name="l05632"></a><span class="lineno"> 5632</span>&#160;</div><div class="line"><a name="l05633"></a><span class="lineno"> 5633</span>&#160;</div><div class="line"><a name="l05634"></a><span class="lineno"> 5634</span>&#160;</div><div class="line"><a name="l05635"></a><span class="lineno"> 5635</span>&#160;*  The socket library is essential and requires the inclusion of the appropriate libraries with the compile command for Sun</div><div class="line"><a name="l05636"></a><span class="lineno"> 5636</span>&#160;Solaris systems:</div><div class="line"><a name="l05637"></a><span class="lineno"> 5637</span>&#160;</div><div class="line"><a name="l05638"></a><span class="lineno"> 5638</span>&#160;    &gt; c++ -o myclient myclient.cpp stdsoap2.cpp soapC.cpp soapClient.cpp -lsocket -lxnet -lnsl</div><div class="line"><a name="l05639"></a><span class="lineno"> 5639</span>&#160;</div><div class="line"><a name="l05640"></a><span class="lineno"> 5640</span>&#160;These library loading options are not required with Linux.</div><div class="line"><a name="l05641"></a><span class="lineno"> 5641</span>&#160;</div><div class="line"><a name="l05642"></a><span class="lineno"> 5642</span>&#160;*  The gSOAP runtime uses the math library for the *`NaN`*, *`INF`*, and *`-INF`* floating point representations.  The library</div><div class="line"><a name="l05643"></a><span class="lineno"> 5643</span>&#160;is not strictly necessary and the `&lt;math.h&gt;` header file import can be commented out from the `stdsoap2.h` header file.</div><div class="line"><a name="l05644"></a><span class="lineno"> 5644</span>&#160;The application can be linked without the `-lm` math library e.g. under Sun Solaris:</div><div class="line"><a name="l05645"></a><span class="lineno"> 5645</span>&#160;</div><div class="line"><a name="l05646"></a><span class="lineno"> 5646</span>&#160;    &gt; c++ -o myclient myclient.cpp stdsoap2.cpp soapC.cpp soapClient.cpp -lsocket -lxnet -lnsl</div><div class="line"><a name="l05647"></a><span class="lineno"> 5647</span>&#160;</div><div class="line"><a name="l05648"></a><span class="lineno"> 5648</span>&#160;# The gSOAP Service Operation Specification Format</div><div class="line"><a name="l05649"></a><span class="lineno"> 5649</span>&#160;</div><div class="line"><a name="l05650"></a><span class="lineno"> 5650</span>&#160;A service operation is specified as a C/C++ function prototype in a header</div><div class="line"><a name="l05651"></a><span class="lineno"> 5651</span>&#160;file. The function is REQUIRED to return `int`, which is used to represent</div><div class="line"><a name="l05652"></a><span class="lineno"> 5652</span>&#160;a SOAP error code, see Section \ref errcodes . Multiple service operations MAY</div><div class="line"><a name="l05653"></a><span class="lineno"> 5653</span>&#160;be declared together in one header file.</div><div class="line"><a name="l05654"></a><span class="lineno"> 5654</span>&#160;</div><div class="line"><a name="l05655"></a><span class="lineno"> 5655</span>&#160;The general format of a service operation specification is:</div><div class="line"><a name="l05656"></a><span class="lineno"> 5656</span>&#160;</div><div class="line"><a name="l05657"></a><span class="lineno"> 5657</span>&#160;```cpp</div><div class="line"><a name="l05658"></a><span class="lineno"> 5658</span>&#160;[optional: int] [optional: namespace_prefix__]method_name([optional: inparam1, inparam2, ...,] outparam);</div><div class="line"><a name="l05659"></a><span class="lineno"> 5659</span>&#160;```</div><div class="line"><a name="l05660"></a><span class="lineno"> 5660</span>&#160;</div><div class="line"><a name="l05661"></a><span class="lineno"> 5661</span>&#160;where</div><div class="line"><a name="l05662"></a><span class="lineno"> 5662</span>&#160;</div><div class="line"><a name="l05663"></a><span class="lineno"> 5663</span>&#160;* `namespace_prefix__` is the optional namespace prefix of the method (see identifier translation rules \ref idtrans )</div><div class="line"><a name="l05664"></a><span class="lineno"> 5664</span>&#160;</div><div class="line"><a name="l05665"></a><span class="lineno"> 5665</span>&#160;* `method_name`  it the service operation name (see identifier translation rules \ref idtrans )</div><div class="line"><a name="l05666"></a><span class="lineno"> 5666</span>&#160;</div><div class="line"><a name="l05667"></a><span class="lineno"> 5667</span>&#160;* `inparam`              is the declaration of an input parameter of the service operation</div><div class="line"><a name="l05668"></a><span class="lineno"> 5668</span>&#160;</div><div class="line"><a name="l05669"></a><span class="lineno"> 5669</span>&#160;* `outparam`     is the declaration of the output parameter of the service operation</div><div class="line"><a name="l05670"></a><span class="lineno"> 5670</span>&#160;</div><div class="line"><a name="l05671"></a><span class="lineno"> 5671</span>&#160;This simple form can only pass a single, non-`struct` and non-`class`</div><div class="line"><a name="l05672"></a><span class="lineno"> 5672</span>&#160;type output parameter. See \ref param  for passing multiple output</div><div class="line"><a name="l05673"></a><span class="lineno"> 5673</span>&#160;parameters. The name of the declared function `namespace_prefix__method_name` must be unique and cannot match the name of a `struct`,</div><div class="line"><a name="l05674"></a><span class="lineno"> 5674</span>&#160;`class`, or `enum` declared in the same header file.</div><div class="line"><a name="l05675"></a><span class="lineno"> 5675</span>&#160;</div><div class="line"><a name="l05676"></a><span class="lineno"> 5676</span>&#160;The method request is encoded in SOAP as an XML element and the namespace prefix, method name, and input parameters are encoded using the format:</div><div class="line"><a name="l05677"></a><span class="lineno"> 5677</span>&#160;</div><div class="line"><a name="l05678"></a><span class="lineno"> 5678</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l05679"></a><span class="lineno"> 5679</span>&#160;```xml</div><div class="line"><a name="l05680"></a><span class="lineno"> 5680</span>&#160;&lt;[optional: namespace-prefix:]method_name xsi:type=&quot;[optional: namespace-prefix:]method_name&gt; </div><div class="line"><a name="l05681"></a><span class="lineno"> 5681</span>&#160;&lt;inparam-name1 xsi:type=&quot;...&quot;&gt;...&lt;/inparam-name1&gt; </div><div class="line"><a name="l05682"></a><span class="lineno"> 5682</span>&#160;&lt;inparam-name2 xsi:type=&quot;...&quot;&gt;...&lt;/inparam-name2&gt; </div><div class="line"><a name="l05683"></a><span class="lineno"> 5683</span>&#160;... </div><div class="line"><a name="l05684"></a><span class="lineno"> 5684</span>&#160;&lt;/[optional: namespace-prefix:]method_name&gt;</div><div class="line"><a name="l05685"></a><span class="lineno"> 5685</span>&#160;```</div><div class="line"><a name="l05686"></a><span class="lineno"> 5686</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l05687"></a><span class="lineno"> 5687</span>&#160;</div><div class="line"><a name="l05688"></a><span class="lineno"> 5688</span>&#160;where the *`inparam-name`* accessors are the element-name representations of the `inparam` parameter name declarations, see</div><div class="line"><a name="l05689"></a><span class="lineno"> 5689</span>&#160;Section \ref idtrans . (The optional parts are shown enclosed in [optional: ].)</div><div class="line"><a name="l05690"></a><span class="lineno"> 5690</span>&#160;</div><div class="line"><a name="l05691"></a><span class="lineno"> 5691</span>&#160;The XML response by the Web service is of the form:</div><div class="line"><a name="l05692"></a><span class="lineno"> 5692</span>&#160;</div><div class="line"><a name="l05693"></a><span class="lineno"> 5693</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l05694"></a><span class="lineno"> 5694</span>&#160;```xml</div><div class="line"><a name="l05695"></a><span class="lineno"> 5695</span>&#160;&lt;[optional: namespace-prefix:]method-nameResponse xsi:type=&quot;[optional: namespace-prefix:]method-nameResponse&gt; </div><div class="line"><a name="l05696"></a><span class="lineno"> 5696</span>&#160;&lt;outparam-name xsi:type=&quot;...&quot;&gt;...&lt;/outparam-name&gt; </div><div class="line"><a name="l05697"></a><span class="lineno"> 5697</span>&#160;&lt;/[optional: namespace-prefix:]method-nameResponse&gt;</div><div class="line"><a name="l05698"></a><span class="lineno"> 5698</span>&#160;```</div><div class="line"><a name="l05699"></a><span class="lineno"> 5699</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l05700"></a><span class="lineno"> 5700</span>&#160;</div><div class="line"><a name="l05701"></a><span class="lineno"> 5701</span>&#160;where the *`outparam-name`* accessor is the element-name representation of the `outparam` parameter name declaration, see</div><div class="line"><a name="l05702"></a><span class="lineno"> 5702</span>&#160;Section \ref idtrans . By convention, the response element name is the method name ending in *`Response`*.</div><div class="line"><a name="l05703"></a><span class="lineno"> 5703</span>&#160;See \ref param  on how to change the declaration if the service response element name is different.</div><div class="line"><a name="l05704"></a><span class="lineno"> 5704</span>&#160;</div><div class="line"><a name="l05705"></a><span class="lineno"> 5705</span>&#160;The gSOAP `soapcpp2` tool generates a stub routine for the service</div><div class="line"><a name="l05706"></a><span class="lineno"> 5706</span>&#160;operation. This stub is of the form:</div><div class="line"><a name="l05707"></a><span class="lineno"> 5707</span>&#160;</div><div class="line"><a name="l05708"></a><span class="lineno"> 5708</span>&#160;```cpp</div><div class="line"><a name="l05709"></a><span class="lineno"> 5709</span>&#160;int soap_call_[optional: namespace_prefix__]method_name(struct soap *soap, char *URL, char *action, [optional: inparam1, inparam2, ...,] outparam);</div><div class="line"><a name="l05710"></a><span class="lineno"> 5710</span>&#160;```</div><div class="line"><a name="l05711"></a><span class="lineno"> 5711</span>&#160;</div><div class="line"><a name="l05712"></a><span class="lineno"> 5712</span>&#160;This proxy can be called by a client application to perform the service operation</div><div class="line"><a name="l05713"></a><span class="lineno"> 5713</span>&#160;call.</div><div class="line"><a name="l05714"></a><span class="lineno"> 5714</span>&#160;</div><div class="line"><a name="l05715"></a><span class="lineno"> 5715</span>&#160;The gSOAP `soapcpp2` tool generates a skeleton routine for the</div><div class="line"><a name="l05716"></a><span class="lineno"> 5716</span>&#160;service operation. The skeleton function is:</div><div class="line"><a name="l05717"></a><span class="lineno"> 5717</span>&#160;</div><div class="line"><a name="l05718"></a><span class="lineno"> 5718</span>&#160;```cpp</div><div class="line"><a name="l05719"></a><span class="lineno"> 5719</span>&#160;int soap_serve_[optional: namespace_prefix__]method_name(struct soap *soap);</div><div class="line"><a name="l05720"></a><span class="lineno"> 5720</span>&#160;```</div><div class="line"><a name="l05721"></a><span class="lineno"> 5721</span>&#160;</div><div class="line"><a name="l05722"></a><span class="lineno"> 5722</span>&#160;The skeleton routine, when called by a service application, will attempt to</div><div class="line"><a name="l05723"></a><span class="lineno"> 5723</span>&#160;serve a request on the standard input. If no request is present or if the</div><div class="line"><a name="l05724"></a><span class="lineno"> 5724</span>&#160;request does not match the method name, `SOAP_NO_METHOD` is returned.</div><div class="line"><a name="l05725"></a><span class="lineno"> 5725</span>&#160;The skeleton routines are automatically called by the generated</div><div class="line"><a name="l05726"></a><span class="lineno"> 5726</span>&#160;`soap_serve` routine that handles all requests.</div><div class="line"><a name="l05727"></a><span class="lineno"> 5727</span>&#160;</div><div class="line"><a name="l05728"></a><span class="lineno"> 5728</span>&#160;## Service Operation Parameter Passing        {#param}</div><div class="line"><a name="l05729"></a><span class="lineno"> 5729</span>&#160;</div><div class="line"><a name="l05730"></a><span class="lineno"> 5730</span>&#160;The input parameters of a service operation MUST be passed by value.  Input</div><div class="line"><a name="l05731"></a><span class="lineno"> 5731</span>&#160;parameters cannot be passed by reference with the `&amp;` reference operator,</div><div class="line"><a name="l05732"></a><span class="lineno"> 5732</span>&#160;but an input parameter value MAY be passed by a pointer to the data.  Of</div><div class="line"><a name="l05733"></a><span class="lineno"> 5733</span>&#160;course, passing a pointer to the data is preferred when the size of the data of</div><div class="line"><a name="l05734"></a><span class="lineno"> 5734</span>&#160;the parameter is large.  Also, to pass instances of (derived) classes, pointers</div><div class="line"><a name="l05735"></a><span class="lineno"> 5735</span>&#160;to the instance need to be used to avoid passing the instance by value which</div><div class="line"><a name="l05736"></a><span class="lineno"> 5736</span>&#160;requires a temporary and prohibits passing derived class instances.  When two</div><div class="line"><a name="l05737"></a><span class="lineno"> 5737</span>&#160;input parameter values are identical, passing them using a pointer has the</div><div class="line"><a name="l05738"></a><span class="lineno"> 5738</span>&#160;advantage that the value will be encoded only once as multi-reference (hence,</div><div class="line"><a name="l05739"></a><span class="lineno"> 5739</span>&#160;the parameters are aliases).  When input parameters are passed using a pointer,</div><div class="line"><a name="l05740"></a><span class="lineno"> 5740</span>&#160;the data pointed to will not be modified by the service operation and returned to</div><div class="line"><a name="l05741"></a><span class="lineno"> 5741</span>&#160;the caller.</div><div class="line"><a name="l05742"></a><span class="lineno"> 5742</span>&#160;</div><div class="line"><a name="l05743"></a><span class="lineno"> 5743</span>&#160;The output parameter MUST be passed by reference using `&amp;` or by using a</div><div class="line"><a name="l05744"></a><span class="lineno"> 5744</span>&#160;pointer. Arrays are passed by reference by default and do not require the use</div><div class="line"><a name="l05745"></a><span class="lineno"> 5745</span>&#160;of the reference operator `&amp;`.</div><div class="line"><a name="l05746"></a><span class="lineno"> 5746</span>&#160;</div><div class="line"><a name="l05747"></a><span class="lineno"> 5747</span>&#160;The input and output parameter types have certain limitations, see</div><div class="line"><a name="l05748"></a><span class="lineno"> 5748</span>&#160;Section \ref limitations </div><div class="line"><a name="l05749"></a><span class="lineno"> 5749</span>&#160;</div><div class="line"><a name="l05750"></a><span class="lineno"> 5750</span>&#160;If the output parameter is a `struct` or `class` type, it is</div><div class="line"><a name="l05751"></a><span class="lineno"> 5751</span>&#160;considered a service operation response element instead of a simple output</div><div class="line"><a name="l05752"></a><span class="lineno"> 5752</span>&#160;parameter value. That is, the name of the `struct` or `class` is the</div><div class="line"><a name="l05753"></a><span class="lineno"> 5753</span>&#160;name of the response element and the `struct` or `class` fields are</div><div class="line"><a name="l05754"></a><span class="lineno"> 5754</span>&#160;the output parameters of the service operation, see also \ref response . Hence,</div><div class="line"><a name="l05755"></a><span class="lineno"> 5755</span>&#160;if the output parameter has to be a `struct` or `class`, a response</div><div class="line"><a name="l05756"></a><span class="lineno"> 5756</span>&#160;`struct` or `class` MUST be declared as well.  In addition, if a</div><div class="line"><a name="l05757"></a><span class="lineno"> 5757</span>&#160;service operation returns multiple output parameters, a response `struct` or</div><div class="line"><a name="l05758"></a><span class="lineno"> 5758</span>&#160;`class` MUST be declared. By convention, the response element is the</div><div class="line"><a name="l05759"></a><span class="lineno"> 5759</span>&#160;service operation name ending with &quot;*`Response`*&quot;.</div><div class="line"><a name="l05760"></a><span class="lineno"> 5760</span>&#160;</div><div class="line"><a name="l05761"></a><span class="lineno"> 5761</span>&#160;The general form of a response element declaration is:</div><div class="line"><a name="l05762"></a><span class="lineno"> 5762</span>&#160;</div><div class="line"><a name="l05763"></a><span class="lineno"> 5763</span>&#160;```cpp</div><div class="line"><a name="l05764"></a><span class="lineno"> 5764</span>&#160;struct [optional: namespace_prefix__]response_element_name </div><div class="line"><a name="l05765"></a><span class="lineno"> 5765</span>&#160;{ </div><div class="line"><a name="l05766"></a><span class="lineno"> 5766</span>&#160;   outparam1; </div><div class="line"><a name="l05767"></a><span class="lineno"> 5767</span>&#160;   outparam2; </div><div class="line"><a name="l05768"></a><span class="lineno"> 5768</span>&#160;   ... </div><div class="line"><a name="l05769"></a><span class="lineno"> 5769</span>&#160;};</div><div class="line"><a name="l05770"></a><span class="lineno"> 5770</span>&#160;```</div><div class="line"><a name="l05771"></a><span class="lineno"> 5771</span>&#160;</div><div class="line"><a name="l05772"></a><span class="lineno"> 5772</span>&#160;where</div><div class="line"><a name="l05773"></a><span class="lineno"> 5773</span>&#160;</div><div class="line"><a name="l05774"></a><span class="lineno"> 5774</span>&#160;* `namespace_prefix__` is the optional namespace prefix of the response element (see identifier translation rules \ref idtrans )</div><div class="line"><a name="l05775"></a><span class="lineno"> 5775</span>&#160;</div><div class="line"><a name="l05776"></a><span class="lineno"> 5776</span>&#160;* `response_element_name`        it the name of the response element (see identifier translation rules \ref idtrans )</div><div class="line"><a name="l05777"></a><span class="lineno"> 5777</span>&#160;</div><div class="line"><a name="l05778"></a><span class="lineno"> 5778</span>&#160;* `outparam`     is the declaration of an output parameter of the service operation</div><div class="line"><a name="l05779"></a><span class="lineno"> 5779</span>&#160;</div><div class="line"><a name="l05780"></a><span class="lineno"> 5780</span>&#160;The general form of a service operation specification with a response element declaration for (multiple) output parameters is:</div><div class="line"><a name="l05781"></a><span class="lineno"> 5781</span>&#160;</div><div class="line"><a name="l05782"></a><span class="lineno"> 5782</span>&#160;```cpp</div><div class="line"><a name="l05783"></a><span class="lineno"> 5783</span>&#160;[optional: int] [optional: namespace_prefix__]method_name([optional: inparam1, inparam2, ...,] struct [optional: namespace_prefix__]response_element_name {outparam1[optional: , outparam2, ...]} &amp;anyparam);</div><div class="line"><a name="l05784"></a><span class="lineno"> 5784</span>&#160;```</div><div class="line"><a name="l05785"></a><span class="lineno"> 5785</span>&#160;</div><div class="line"><a name="l05786"></a><span class="lineno"> 5786</span>&#160;The choice of name for `anyparam` has no effect on the SOAP encoding and decoding and is only used as a place holder for the</div><div class="line"><a name="l05787"></a><span class="lineno"> 5787</span>&#160;response.</div><div class="line"><a name="l05788"></a><span class="lineno"> 5788</span>&#160;</div><div class="line"><a name="l05789"></a><span class="lineno"> 5789</span>&#160;The method request is encoded in SOAP as an independent element and the</div><div class="line"><a name="l05790"></a><span class="lineno"> 5790</span>&#160;namespace prefix, method name, and input parameters are encoded using the</div><div class="line"><a name="l05791"></a><span class="lineno"> 5791</span>&#160;format:</div><div class="line"><a name="l05792"></a><span class="lineno"> 5792</span>&#160;</div><div class="line"><a name="l05793"></a><span class="lineno"> 5793</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l05794"></a><span class="lineno"> 5794</span>&#160;```xml</div><div class="line"><a name="l05795"></a><span class="lineno"> 5795</span>&#160;&lt;[optional: namespace-prefix:]method-name xsi:type=&quot;[optional: namespace-prefix:]method-name&gt; </div><div class="line"><a name="l05796"></a><span class="lineno"> 5796</span>&#160;&lt;inparam-name1 xsi:type=&quot;...&quot;&gt;...&lt;/inparam-name1&gt; </div><div class="line"><a name="l05797"></a><span class="lineno"> 5797</span>&#160;&lt;inparam-name2 xsi:type=&quot;...&quot;&gt;...&lt;/inparam-name2&gt; </div><div class="line"><a name="l05798"></a><span class="lineno"> 5798</span>&#160;... </div><div class="line"><a name="l05799"></a><span class="lineno"> 5799</span>&#160;&lt;/[optional: namespace-prefix:]method-name&gt;</div><div class="line"><a name="l05800"></a><span class="lineno"> 5800</span>&#160;```</div><div class="line"><a name="l05801"></a><span class="lineno"> 5801</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l05802"></a><span class="lineno"> 5802</span>&#160;</div><div class="line"><a name="l05803"></a><span class="lineno"> 5803</span>&#160;where the *`inparam-name`* accessors are the element-name representations of</div><div class="line"><a name="l05804"></a><span class="lineno"> 5804</span>&#160;the `inparam` parameter name declarations, see Section \ref idtrans .</div><div class="line"><a name="l05805"></a><span class="lineno"> 5805</span>&#160;(The optional parts resulting from the specification are shown enclosed in</div><div class="line"><a name="l05806"></a><span class="lineno"> 5806</span>&#160;[optional: ].)</div><div class="line"><a name="l05807"></a><span class="lineno"> 5807</span>&#160;</div><div class="line"><a name="l05808"></a><span class="lineno"> 5808</span>&#160;The method response is expected to be of the form:</div><div class="line"><a name="l05809"></a><span class="lineno"> 5809</span>&#160;</div><div class="line"><a name="l05810"></a><span class="lineno"> 5810</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l05811"></a><span class="lineno"> 5811</span>&#160;```xml</div><div class="line"><a name="l05812"></a><span class="lineno"> 5812</span>&#160;&lt;[optional: namespace-prefix:]response-element-name xsi:type=&quot;[optional: namespace-prefix:]response-element-name&gt; </div><div class="line"><a name="l05813"></a><span class="lineno"> 5813</span>&#160;&lt;outparam-name1 xsi:type=&quot;...&quot;&gt;...&lt;/outparam-name1&gt; </div><div class="line"><a name="l05814"></a><span class="lineno"> 5814</span>&#160;&lt;outparam-name2 xsi:type=&quot;...&quot;&gt;...&lt;/outparam-name2&gt; </div><div class="line"><a name="l05815"></a><span class="lineno"> 5815</span>&#160;... </div><div class="line"><a name="l05816"></a><span class="lineno"> 5816</span>&#160;&lt;/[optional: namespace-prefix:]response-element-name&gt;</div><div class="line"><a name="l05817"></a><span class="lineno"> 5817</span>&#160;```</div><div class="line"><a name="l05818"></a><span class="lineno"> 5818</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l05819"></a><span class="lineno"> 5819</span>&#160;</div><div class="line"><a name="l05820"></a><span class="lineno"> 5820</span>&#160;where the *`outparam-name`* accessors are the element-name representations of</div><div class="line"><a name="l05821"></a><span class="lineno"> 5821</span>&#160;the `outparam` parameter name declarations, see Section \ref idtrans .</div><div class="line"><a name="l05822"></a><span class="lineno"> 5822</span>&#160;(The optional parts resulting from the specification are shown enclosed in</div><div class="line"><a name="l05823"></a><span class="lineno"> 5823</span>&#160;[optional: ].)</div><div class="line"><a name="l05824"></a><span class="lineno"> 5824</span>&#160;</div><div class="line"><a name="l05825"></a><span class="lineno"> 5825</span>&#160;The input and/or output parameters can be made anonymous, which allows the</div><div class="line"><a name="l05826"></a><span class="lineno"> 5826</span>&#160;deserialization of requests/responses with different parameter names as is</div><div class="line"><a name="l05827"></a><span class="lineno"> 5827</span>&#160;endorsed by the SOAP 1.1 specification, see Section \ref anonymous .</div><div class="line"><a name="l05828"></a><span class="lineno"> 5828</span>&#160;</div><div class="line"><a name="l05829"></a><span class="lineno"> 5829</span>&#160;## Error Codes        {#errcodes}</div><div class="line"><a name="l05830"></a><span class="lineno"> 5830</span>&#160;</div><div class="line"><a name="l05831"></a><span class="lineno"> 5831</span>&#160;The error codes returned by the stub and skeleton routines are listed below.</div><div class="line"><a name="l05832"></a><span class="lineno"> 5832</span>&#160;</div><div class="line"><a name="l05833"></a><span class="lineno"> 5833</span>&#160;code                       | description</div><div class="line"><a name="l05834"></a><span class="lineno"> 5834</span>&#160;-------------------------- | -----------</div><div class="line"><a name="l05835"></a><span class="lineno"> 5835</span>&#160;`SOAP_OK`                  | No error (code is zero)</div><div class="line"><a name="l05836"></a><span class="lineno"> 5836</span>&#160;`SOAP_CLI_FAULT`*          | The service returned a client fault (SOAP 1.2 Sender fault)</div><div class="line"><a name="l05837"></a><span class="lineno"> 5837</span>&#160;`SOAP_SVR_FAULT`*          | The service returned a server fault (SOAP 1.2 Receiver fault)</div><div class="line"><a name="l05838"></a><span class="lineno"> 5838</span>&#160;`SOAP_TAG_MISMATCH`        | Element found didn&#39;t correspond to anything expected </div><div class="line"><a name="l05839"></a><span class="lineno"> 5839</span>&#160;`SOAP_TYPE`                | XML Schema type mismatch </div><div class="line"><a name="l05840"></a><span class="lineno"> 5840</span>&#160;`SOAP_SYNTAX_ERROR`        | An XML syntax error occurred on the input </div><div class="line"><a name="l05841"></a><span class="lineno"> 5841</span>&#160;`SOAP_NO_TAG`              | Begin of an element expected, but not found </div><div class="line"><a name="l05842"></a><span class="lineno"> 5842</span>&#160;`SOAP_IOB`                 | Array index out of bounds </div><div class="line"><a name="l05843"></a><span class="lineno"> 5843</span>&#160;`SOAP_MUSTUNDERSTAND`*     | An element needs to be ignored that need to be understood </div><div class="line"><a name="l05844"></a><span class="lineno"> 5844</span>&#160;`SOAP_NAMESPACE`           | Namespace name mismatch (validation error) </div><div class="line"><a name="l05845"></a><span class="lineno"> 5845</span>&#160;`SOAP_FATAL_ERROR`         | Internal error </div><div class="line"><a name="l05846"></a><span class="lineno"> 5846</span>&#160;`SOAP_USER_ERROR`          | User error (reserved for `soap.user` usage </div><div class="line"><a name="l05847"></a><span class="lineno"> 5847</span>&#160;`SOAP_FAULT`               | An exception raised by the service </div><div class="line"><a name="l05848"></a><span class="lineno"> 5848</span>&#160;`SOAP_NO_METHOD`           | The dispatcher did not find a matching operation for a request</div><div class="line"><a name="l05849"></a><span class="lineno"> 5849</span>&#160;`SOAP_NO_DATA`             | No data in HTTP message </div><div class="line"><a name="l05850"></a><span class="lineno"> 5850</span>&#160;`SOAP_GET_METHOD`          | HTTP GET operation not handled, see Section \ref get  </div><div class="line"><a name="l05851"></a><span class="lineno"> 5851</span>&#160;`SOAP_EOM`                 | Out of memory </div><div class="line"><a name="l05852"></a><span class="lineno"> 5852</span>&#160;`SOAP_MOE`                 | Memory overflow/corruption error (DEBUG mode) </div><div class="line"><a name="l05853"></a><span class="lineno"> 5853</span>&#160;`SOAP_NULL`                | An element was null, while it is not supposed to be null </div><div class="line"><a name="l05854"></a><span class="lineno"> 5854</span>&#160;`SOAP_DUPLICATE_ID`        | Element&#39;s ID duplicated (multi-ref encoding) </div><div class="line"><a name="l05855"></a><span class="lineno"> 5855</span>&#160;`SOAP_MISSING_ID`          | Element ID missing for an href/ref (multi-ref encoding) </div><div class="line"><a name="l05856"></a><span class="lineno"> 5856</span>&#160;`SOAP_HREF`                | Reference to object is incompatible with the object refered to </div><div class="line"><a name="l05857"></a><span class="lineno"> 5857</span>&#160;`SOAP_UTF_ERROR`           | An UTF-encoded message decoding error occured </div><div class="line"><a name="l05858"></a><span class="lineno"> 5858</span>&#160;`SOAP_UDP_ERROR`           | Message too large to store in UDP packet </div><div class="line"><a name="l05859"></a><span class="lineno"> 5859</span>&#160;`SOAP_TCP_ERROR`           | A connection error occured </div><div class="line"><a name="l05860"></a><span class="lineno"> 5860</span>&#160;`SOAP_HTTP_ERROR`          | An HTTP error occured </div><div class="line"><a name="l05861"></a><span class="lineno"> 5861</span>&#160;`SOAP_NTLM_ERROR`          | An NTLM authentication handshake error occured </div><div class="line"><a name="l05862"></a><span class="lineno"> 5862</span>&#160;`SOAP_SSL_ERROR`           | An SSL error occured </div><div class="line"><a name="l05863"></a><span class="lineno"> 5863</span>&#160;`SOAP_ZLIB_ERROR`          | A Zlib error occured </div><div class="line"><a name="l05864"></a><span class="lineno"> 5864</span>&#160;`SOAP_PLUGIN_ERROR`        | Failed to register plugin </div><div class="line"><a name="l05865"></a><span class="lineno"> 5865</span>&#160;`SOAP_MIME_ERROR`          | MIME parsing error </div><div class="line"><a name="l05866"></a><span class="lineno"> 5866</span>&#160;`SOAP_MIME_HREF`           | MIME attachment has no href from SOAP body error </div><div class="line"><a name="l05867"></a><span class="lineno"> 5867</span>&#160;`SOAP_MIME_END`            | End of MIME attachments protocol error </div><div class="line"><a name="l05868"></a><span class="lineno"> 5868</span>&#160;`SOAP_DIME_ERROR`          | DIME formatting error or DIME size exceeds SOAP_MAXDIMESIZE </div><div class="line"><a name="l05869"></a><span class="lineno"> 5869</span>&#160;`SOAP_DIME_END`            | End of DIME attachments protocol error </div><div class="line"><a name="l05870"></a><span class="lineno"> 5870</span>&#160;`SOAP_DIME_HREF`           | DIME attachment has no href from SOAP body (and no DIME callbacks were defined to save the attachment) </div><div class="line"><a name="l05871"></a><span class="lineno"> 5871</span>&#160;`SOAP_DIME_MISMATCH`       | DIME version/transmission error </div><div class="line"><a name="l05872"></a><span class="lineno"> 5872</span>&#160;`SOAP_VERSIONMISMATCH`*    | SOAP version mismatch or no SOAP message </div><div class="line"><a name="l05873"></a><span class="lineno"> 5873</span>&#160;`SOAP_DATAENCODINGUNKNOWN` | SOAP 1.2 DataEncodingUnknown fault </div><div class="line"><a name="l05874"></a><span class="lineno"> 5874</span>&#160;`SOAP_REQUIRED`            | Attributed is required</div><div class="line"><a name="l05875"></a><span class="lineno"> 5875</span>&#160;`SOAP_PROHIBITED`          | Attributed is prohibited</div><div class="line"><a name="l05876"></a><span class="lineno"> 5876</span>&#160;`SOAP_LEVEL`               | XML nesting depth level exceeds `SOAP_MAXLEVEL`</div><div class="line"><a name="l05877"></a><span class="lineno"> 5877</span>&#160;`SOAP_OCCURS`              | Element minOccurs/maxOccurs validation error or `SOAP_MAXOCCURS` exceeded </div><div class="line"><a name="l05878"></a><span class="lineno"> 5878</span>&#160;`SOAP_LENGTH`              | Element length validation error or `SOAP_MAXLENGTH` exceeded</div><div class="line"><a name="l05879"></a><span class="lineno"> 5879</span>&#160;`SOAP_FIXED`               | Element or attribute value is fixed</div><div class="line"><a name="l05880"></a><span class="lineno"> 5880</span>&#160;`SOAP_EMPTY`               | Element or attribute is empty when a value is expected</div><div class="line"><a name="l05881"></a><span class="lineno"> 5881</span>&#160;`SOAP_FD_EXCEEDED`         | Too many open sockets (for non-win32 systems not supporting `poll()`) </div><div class="line"><a name="l05882"></a><span class="lineno"> 5882</span>&#160;`SOAP_EOM`                 | Out of memory</div><div class="line"><a name="l05883"></a><span class="lineno"> 5883</span>&#160;`SOAP_EOF`                 | Unexpected end of file, no input, or timeout receiving data </div><div class="line"><a name="l05884"></a><span class="lineno"> 5884</span>&#160;`SOAP_ERR`                 | Error (for internal use) </div><div class="line"><a name="l05885"></a><span class="lineno"> 5885</span>&#160;</div><div class="line"><a name="l05886"></a><span class="lineno"> 5886</span>&#160;The error codes that are returned by a stub routine (proxy) upon receiving a</div><div class="line"><a name="l05887"></a><span class="lineno"> 5887</span>&#160;SOAP Fault from the server are marked (*).  The remaining error codes are</div><div class="line"><a name="l05888"></a><span class="lineno"> 5888</span>&#160;generated by the proxy itself as a result of problems with a SOAP payload.  The</div><div class="line"><a name="l05889"></a><span class="lineno"> 5889</span>&#160;error code is `SOAP_OK` when the service operation call was successful (the</div><div class="line"><a name="l05890"></a><span class="lineno"> 5890</span>&#160;`SOAP_OK` predefined constant is guaranteed to be `0`).  The error</div><div class="line"><a name="l05891"></a><span class="lineno"> 5891</span>&#160;code is also stored in `soap.error`, where `soap` is a variable that</div><div class="line"><a name="l05892"></a><span class="lineno"> 5892</span>&#160;contains the current runtime context. The function</div><div class="line"><a name="l05893"></a><span class="lineno"> 5893</span>&#160;`soap_print_fault(struct soap *soap, FILE *fd)` can be called to</div><div class="line"><a name="l05894"></a><span class="lineno"> 5894</span>&#160;display an error message on `fd` where current value of the</div><div class="line"><a name="l05895"></a><span class="lineno"> 5895</span>&#160;`soap.error` variable is used by the function to display the error.  </div><div class="line"><a name="l05896"></a><span class="lineno"> 5896</span>&#160;Use `soap_stream_fault(struct soap *soap, std::ostream&amp; os)` in C++.</div><div class="line"><a name="l05897"></a><span class="lineno"> 5897</span>&#160;The function `soap_print_fault_location(struct soap *soap, FILE *fd)`</div><div class="line"><a name="l05898"></a><span class="lineno"> 5898</span>&#160;prints the location of the error if the error is a result from parsing XML.</div><div class="line"><a name="l05899"></a><span class="lineno"> 5899</span>&#160;Use `soap_print_stream_location(struct soap *soap, std::ostream&amp; os)` in C++.</div><div class="line"><a name="l05900"></a><span class="lineno"> 5900</span>&#160;Use `soap_sprint_fault(struct soap*, char *buf, size_t len)` to print the error to a string.</div><div class="line"><a name="l05901"></a><span class="lineno"> 5901</span>&#160;</div><div class="line"><a name="l05902"></a><span class="lineno"> 5902</span>&#160;A service operation implemented in a SOAP service MUST return an error code as the</div><div class="line"><a name="l05903"></a><span class="lineno"> 5903</span>&#160;function&#39;s return value. `SOAP_OK` denotes success and `SOAP_FAULT`</div><div class="line"><a name="l05904"></a><span class="lineno"> 5904</span>&#160;denotes an exception. The exception details can be assigned with the</div><div class="line"><a name="l05905"></a><span class="lineno"> 5905</span>&#160;`soap_receiver_fault(struct soap *soap, const char *faultstring, const char *detail)` which sets the strings</div><div class="line"><a name="l05906"></a><span class="lineno"> 5906</span>&#160;`soap.fault-&gt;faultstring` and</div><div class="line"><a name="l05907"></a><span class="lineno"> 5907</span>&#160;`soap.fault-&gt;detail` for SOAP 1.1, and</div><div class="line"><a name="l05908"></a><span class="lineno"> 5908</span>&#160;`soap.fault-&gt;SOAP_ENV__Reason` and</div><div class="line"><a name="l05909"></a><span class="lineno"> 5909</span>&#160;`soap.fault-&gt;SOAP_ENV__Detail` for SOAP 1.2, where</div><div class="line"><a name="l05910"></a><span class="lineno"> 5910</span>&#160;`soap` is a variable that contains the current runtime context, see</div><div class="line"><a name="l05911"></a><span class="lineno"> 5911</span>&#160;Section \ref fault .</div><div class="line"><a name="l05912"></a><span class="lineno"> 5912</span>&#160;A receiver error indicates that the service can&#39;t handle the request, but can possibly recover from the error.</div><div class="line"><a name="l05913"></a><span class="lineno"> 5913</span>&#160;To return an unrecoverable SOAP 1.1/1.2 error, use `soap_sender_fault(struct soap *soap, const char *faultstring, const char *detail)`.</div><div class="line"><a name="l05914"></a><span class="lineno"> 5914</span>&#160;</div><div class="line"><a name="l05915"></a><span class="lineno"> 5915</span>&#160;To return a HTTP error code a service method can simply return the HTTP error code number.</div><div class="line"><a name="l05916"></a><span class="lineno"> 5916</span>&#160;For example, `return 404;` returns a &quot;404 Not Found&quot; HTTP error back to the client.  The `soap.error`</div><div class="line"><a name="l05917"></a><span class="lineno"> 5917</span>&#160;is set to the HTTP error code at the client side.</div><div class="line"><a name="l05918"></a><span class="lineno"> 5918</span>&#160;The HTTP 1.1 error codes are:</div><div class="line"><a name="l05919"></a><span class="lineno"> 5919</span>&#160;</div><div class="line"><a name="l05920"></a><span class="lineno"> 5920</span>&#160;code | description</div><div class="line"><a name="l05921"></a><span class="lineno"> 5921</span>&#160;---- | -----------</div><div class="line"><a name="l05922"></a><span class="lineno"> 5922</span>&#160;201  | Created </div><div class="line"><a name="l05923"></a><span class="lineno"> 5923</span>&#160;202  | Accepted </div><div class="line"><a name="l05924"></a><span class="lineno"> 5924</span>&#160;203  | Non-Authoritative Information </div><div class="line"><a name="l05925"></a><span class="lineno"> 5925</span>&#160;204  | No Content </div><div class="line"><a name="l05926"></a><span class="lineno"> 5926</span>&#160;205  | Reset Content </div><div class="line"><a name="l05927"></a><span class="lineno"> 5927</span>&#160;206  | Partial Content </div><div class="line"><a name="l05928"></a><span class="lineno"> 5928</span>&#160;300  | Multiple Choices </div><div class="line"><a name="l05929"></a><span class="lineno"> 5929</span>&#160;301  | Moved Permanently </div><div class="line"><a name="l05930"></a><span class="lineno"> 5930</span>&#160;302  | Found </div><div class="line"><a name="l05931"></a><span class="lineno"> 5931</span>&#160;303  | See Other </div><div class="line"><a name="l05932"></a><span class="lineno"> 5932</span>&#160;304  | Not Modified </div><div class="line"><a name="l05933"></a><span class="lineno"> 5933</span>&#160;305  | Use Proxy </div><div class="line"><a name="l05934"></a><span class="lineno"> 5934</span>&#160;307  | Temporary Redirect </div><div class="line"><a name="l05935"></a><span class="lineno"> 5935</span>&#160;400  | Bad Request </div><div class="line"><a name="l05936"></a><span class="lineno"> 5936</span>&#160;401  | Unauthorized </div><div class="line"><a name="l05937"></a><span class="lineno"> 5937</span>&#160;402  | Payment Required </div><div class="line"><a name="l05938"></a><span class="lineno"> 5938</span>&#160;403  | Forbidden </div><div class="line"><a name="l05939"></a><span class="lineno"> 5939</span>&#160;404  | Not Found </div><div class="line"><a name="l05940"></a><span class="lineno"> 5940</span>&#160;405  | Method Not Allowed </div><div class="line"><a name="l05941"></a><span class="lineno"> 5941</span>&#160;406  | Not Acceptable </div><div class="line"><a name="l05942"></a><span class="lineno"> 5942</span>&#160;407  | Proxy Authentication Required </div><div class="line"><a name="l05943"></a><span class="lineno"> 5943</span>&#160;408  | Request Time-out </div><div class="line"><a name="l05944"></a><span class="lineno"> 5944</span>&#160;409  | Conflict </div><div class="line"><a name="l05945"></a><span class="lineno"> 5945</span>&#160;410  | Gone </div><div class="line"><a name="l05946"></a><span class="lineno"> 5946</span>&#160;411  | Length Required </div><div class="line"><a name="l05947"></a><span class="lineno"> 5947</span>&#160;412  | Precondition Failed </div><div class="line"><a name="l05948"></a><span class="lineno"> 5948</span>&#160;413  | Request Entity Too Large </div><div class="line"><a name="l05949"></a><span class="lineno"> 5949</span>&#160;414  | Request-URI Too Large </div><div class="line"><a name="l05950"></a><span class="lineno"> 5950</span>&#160;415  | Unsupported Media Type </div><div class="line"><a name="l05951"></a><span class="lineno"> 5951</span>&#160;416  | Requested range not satisfiable </div><div class="line"><a name="l05952"></a><span class="lineno"> 5952</span>&#160;417  | Expectation Failed </div><div class="line"><a name="l05953"></a><span class="lineno"> 5953</span>&#160;500  | Internal Server Error </div><div class="line"><a name="l05954"></a><span class="lineno"> 5954</span>&#160;501  | Not Implemented </div><div class="line"><a name="l05955"></a><span class="lineno"> 5955</span>&#160;502  | Bad Gateway </div><div class="line"><a name="l05956"></a><span class="lineno"> 5956</span>&#160;503  | Service Unavailable </div><div class="line"><a name="l05957"></a><span class="lineno"> 5957</span>&#160;504  | Gateway Time-out </div><div class="line"><a name="l05958"></a><span class="lineno"> 5958</span>&#160;505  | HTTP Version not supported </div><div class="line"><a name="l05959"></a><span class="lineno"> 5959</span>&#160;</div><div class="line"><a name="l05960"></a><span class="lineno"> 5960</span>&#160;The error codes are given for informational purposes only. The HTTP protocol requires the proper actions after an error is issued. gSOAP&#39;s HTTP 1.0/1.1 handling is automatic.</div><div class="line"><a name="l05961"></a><span class="lineno"> 5961</span>&#160;</div><div class="line"><a name="l05962"></a><span class="lineno"> 5962</span>&#160;## C/C++ Identifier Name to XML Tag Name Mapping        {#idtrans}</div><div class="line"><a name="l05963"></a><span class="lineno"> 5963</span>&#160;</div><div class="line"><a name="l05964"></a><span class="lineno"> 5964</span>&#160;One of the &quot;secrets&quot; behind the power and flexibility of gSOAP&#39;s encoding and</div><div class="line"><a name="l05965"></a><span class="lineno"> 5965</span>&#160;decoding of service operation names, class names, type identifiers, and struct or</div><div class="line"><a name="l05966"></a><span class="lineno"> 5966</span>&#160;class fields is the ability to specify namespace prefixes with these names that</div><div class="line"><a name="l05967"></a><span class="lineno"> 5967</span>&#160;are used to denote their encoding style. More specifically, a C/C++ identifier</div><div class="line"><a name="l05968"></a><span class="lineno"> 5968</span>&#160;name of the form</div><div class="line"><a name="l05969"></a><span class="lineno"> 5969</span>&#160;</div><div class="line"><a name="l05970"></a><span class="lineno"> 5970</span>&#160;```cpp</div><div class="line"><a name="l05971"></a><span class="lineno"> 5971</span>&#160;[optional: namespace_prefix__]element_name</div><div class="line"><a name="l05972"></a><span class="lineno"> 5972</span>&#160;```</div><div class="line"><a name="l05973"></a><span class="lineno"> 5973</span>&#160;</div><div class="line"><a name="l05974"></a><span class="lineno"> 5974</span>&#160;where the prefix and the element name are separated by  double underscores will be encoded in XML as</div><div class="line"><a name="l05975"></a><span class="lineno"> 5975</span>&#160;</div><div class="line"><a name="l05976"></a><span class="lineno"> 5976</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l05977"></a><span class="lineno"> 5977</span>&#160;```xml</div><div class="line"><a name="l05978"></a><span class="lineno"> 5978</span>&#160;&lt;[optional: namespace-prefix:]element-name ...&gt;</div><div class="line"><a name="l05979"></a><span class="lineno"> 5979</span>&#160;```</div><div class="line"><a name="l05980"></a><span class="lineno"> 5980</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l05981"></a><span class="lineno"> 5981</span>&#160;</div><div class="line"><a name="l05982"></a><span class="lineno"> 5982</span>&#160;The **underscore pair** (`__`) separates the namespace prefix from the</div><div class="line"><a name="l05983"></a><span class="lineno"> 5983</span>&#160;element name.  Each namespace prefix has a namespace URI specified by a</div><div class="line"><a name="l05984"></a><span class="lineno"> 5984</span>&#160;namespace mapping table \ref nstable , see also</div><div class="line"><a name="l05985"></a><span class="lineno"> 5985</span>&#160;Section \ref namespace .  The namespace URI is a unique identification that</div><div class="line"><a name="l05986"></a><span class="lineno"> 5986</span>&#160;can be associated with the service operations and data types.  The namespace URI</div><div class="line"><a name="l05987"></a><span class="lineno"> 5987</span>&#160;disambiguates potentially identical service operation names and data type names</div><div class="line"><a name="l05988"></a><span class="lineno"> 5988</span>&#160;used by disparate organizations.</div><div class="line"><a name="l05989"></a><span class="lineno"> 5989</span>&#160;</div><div class="line"><a name="l05990"></a><span class="lineno"> 5990</span>&#160;XML element names are NCNames (restricted strings) that MAY contain</div><div class="line"><a name="l05991"></a><span class="lineno"> 5991</span>&#160;**hyphens**, **dots**, and **underscores**.  The special characters in the XML</div><div class="line"><a name="l05992"></a><span class="lineno"> 5992</span>&#160;element names of service operations, structs, classes, typedefs, and fields can be</div><div class="line"><a name="l05993"></a><span class="lineno"> 5993</span>&#160;controlled using the following conventions: A **single underscore** in a</div><div class="line"><a name="l05994"></a><span class="lineno"> 5994</span>&#160;namespace prefix or identifier name is replaced by a hyphen (*`-`*) in the</div><div class="line"><a name="l05995"></a><span class="lineno"> 5995</span>&#160;XML element name.  For example, the identifier name `SOAP_ENC__ur_type`</div><div class="line"><a name="l05996"></a><span class="lineno"> 5996</span>&#160;is represented in XML as *`SOAP-ENC:ur-type`*.  The sequence `_DOT` is</div><div class="line"><a name="l05997"></a><span class="lineno"> 5997</span>&#160;replaced by a dot (*`.`*), and the sequence `_USCORE` is replaced by</div><div class="line"><a name="l05998"></a><span class="lineno"> 5998</span>&#160;an underscore (*`_`*) in the corresponding XML element name.  For example:</div><div class="line"><a name="l05999"></a><span class="lineno"> 5999</span>&#160;</div><div class="line"><a name="l06000"></a><span class="lineno"> 6000</span>&#160;```cpp</div><div class="line"><a name="l06001"></a><span class="lineno"> 6001</span>&#160;class n_s__biz_DOTcom </div><div class="line"><a name="l06002"></a><span class="lineno"> 6002</span>&#160;{ </div><div class="line"><a name="l06003"></a><span class="lineno"> 6003</span>&#160;   char *n_s__biz_USCOREname; </div><div class="line"><a name="l06004"></a><span class="lineno"> 6004</span>&#160;};</div><div class="line"><a name="l06005"></a><span class="lineno"> 6005</span>&#160;```</div><div class="line"><a name="l06006"></a><span class="lineno"> 6006</span>&#160;</div><div class="line"><a name="l06007"></a><span class="lineno"> 6007</span>&#160;is encoded in XML as:</div><div class="line"><a name="l06008"></a><span class="lineno"> 6008</span>&#160;</div><div class="line"><a name="l06009"></a><span class="lineno"> 6009</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l06010"></a><span class="lineno"> 6010</span>&#160;```xml</div><div class="line"><a name="l06011"></a><span class="lineno"> 6011</span>&#160;&lt;n-s:biz.com xsi:type=&quot;n-s:biz.com&quot;&gt; </div><div class="line"><a name="l06012"></a><span class="lineno"> 6012</span>&#160;   &lt;n-s:biz_name xsi:type=&quot;string&quot;&gt;Bizybiz&lt;/n-s:biz_name&gt; </div><div class="line"><a name="l06013"></a><span class="lineno"> 6013</span>&#160;&lt;/n-s:biz.com&gt;</div><div class="line"><a name="l06014"></a><span class="lineno"> 6014</span>&#160;```</div><div class="line"><a name="l06015"></a><span class="lineno"> 6015</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l06016"></a><span class="lineno"> 6016</span>&#160;</div><div class="line"><a name="l06017"></a><span class="lineno"> 6017</span>&#160;Trailing underscores of an identifier name are not translated into the XML</div><div class="line"><a name="l06018"></a><span class="lineno"> 6018</span>&#160;representation. This is useful when an identifier name clashes with a C++</div><div class="line"><a name="l06019"></a><span class="lineno"> 6019</span>&#160;keyword. For example, *`return`* is often used as an accessor name in a SOAP</div><div class="line"><a name="l06020"></a><span class="lineno"> 6020</span>&#160;response element.  The *`return`* element can be specified as `return_`</div><div class="line"><a name="l06021"></a><span class="lineno"> 6021</span>&#160;in the C++ source code. Note that XML should be treated as case sensitive, so</div><div class="line"><a name="l06022"></a><span class="lineno"> 6022</span>&#160;the use of e.g. `Return` may not always work to avoid a name clash with the</div><div class="line"><a name="l06023"></a><span class="lineno"> 6023</span>&#160;`\return` keyword.  The use of trailing underscores also allows for</div><div class="line"><a name="l06024"></a><span class="lineno"> 6024</span>&#160;defining `struct`s and `class`es with essentially the same XML Schema</div><div class="line"><a name="l06025"></a><span class="lineno"> 6025</span>&#160;type name, but that have to be distinguished as seperate C/C++ types.</div><div class="line"><a name="l06026"></a><span class="lineno"> 6026</span>&#160;</div><div class="line"><a name="l06027"></a><span class="lineno"> 6027</span>&#160;For decoding, the underscores in identifier names act as wildcards. An XML</div><div class="line"><a name="l06028"></a><span class="lineno"> 6028</span>&#160;element is parsed and matches the name of an identifier if the name is</div><div class="line"><a name="l06029"></a><span class="lineno"> 6029</span>&#160;identical to the element name (case insensitive) and the underscores in the</div><div class="line"><a name="l06030"></a><span class="lineno"> 6030</span>&#160;identifier name are allowed to match any character in the element name. For</div><div class="line"><a name="l06031"></a><span class="lineno"> 6031</span>&#160;example, the identifier name `I_want__soap_fun_the_bea___DOTcom`</div><div class="line"><a name="l06032"></a><span class="lineno"> 6032</span>&#160;matches the element name *`I-want:SOAP4fun@the-beach.com`*.</div><div class="line"><a name="l06033"></a><span class="lineno"> 6033</span>&#160;</div><div class="line"><a name="l06034"></a><span class="lineno"> 6034</span>&#160;By default, `soapcpp2` generates data bindings in which  all XML elements are and attributes are unqualified:</div><div class="line"><a name="l06035"></a><span class="lineno"> 6035</span>&#160;</div><div class="line"><a name="l06036"></a><span class="lineno"> 6036</span>&#160;```cpp</div><div class="line"><a name="l06037"></a><span class="lineno"> 6037</span>&#160;//gsoap x schema namespace: urn:x </div><div class="line"><a name="l06038"></a><span class="lineno"> 6038</span>&#160;struct x__record </div><div class="line"><a name="l06039"></a><span class="lineno"> 6039</span>&#160;{ </div><div class="line"><a name="l06040"></a><span class="lineno"> 6040</span>&#160;  @ char * type; </div><div class="line"><a name="l06041"></a><span class="lineno"> 6041</span>&#160;  char * name; </div><div class="line"><a name="l06042"></a><span class="lineno"> 6042</span>&#160;};</div><div class="line"><a name="l06043"></a><span class="lineno"> 6043</span>&#160;```</div><div class="line"><a name="l06044"></a><span class="lineno"> 6044</span>&#160;</div><div class="line"><a name="l06045"></a><span class="lineno"> 6045</span>&#160;where the `name` element and the `type` attribute are unqualified in the XML content (for example to facilitate SOAP RPC encoding).</div><div class="line"><a name="l06046"></a><span class="lineno"> 6046</span>&#160;</div><div class="line"><a name="l06047"></a><span class="lineno"> 6047</span>&#160;To force qualification of elements and attributes, use the &quot;form&quot; directive:</div><div class="line"><a name="l06048"></a><span class="lineno"> 6048</span>&#160;</div><div class="line"><a name="l06049"></a><span class="lineno"> 6049</span>&#160;```cpp</div><div class="line"><a name="l06050"></a><span class="lineno"> 6050</span>&#160;//gsoap x schema namespace: urn:x </div><div class="line"><a name="l06051"></a><span class="lineno"> 6051</span>&#160;//gsoap x schema form: qualified </div><div class="line"><a name="l06052"></a><span class="lineno"> 6052</span>&#160;struct x__record </div><div class="line"><a name="l06053"></a><span class="lineno"> 6053</span>&#160;{ </div><div class="line"><a name="l06054"></a><span class="lineno"> 6054</span>&#160;  @ char * type; </div><div class="line"><a name="l06055"></a><span class="lineno"> 6055</span>&#160;  char * name; </div><div class="line"><a name="l06056"></a><span class="lineno"> 6056</span>&#160;};</div><div class="line"><a name="l06057"></a><span class="lineno"> 6057</span>&#160;```</div><div class="line"><a name="l06058"></a><span class="lineno"> 6058</span>&#160;</div><div class="line"><a name="l06059"></a><span class="lineno"> 6059</span>&#160;You can also use &quot;elementForm&quot; and &quot;attributeForm&quot; directives to (un)qualify local element and attributes, respectively.</div><div class="line"><a name="l06060"></a><span class="lineno"> 6060</span>&#160;</div><div class="line"><a name="l06061"></a><span class="lineno"> 6061</span>&#160;Because the `soapcpp2`-generated serializers follow the</div><div class="line"><a name="l06062"></a><span class="lineno"> 6062</span>&#160;qualified/unqualified forms of the schemas, there is normally no need to</div><div class="line"><a name="l06063"></a><span class="lineno"> 6063</span>&#160;explicitly qualify struct/class members because automatic encoding rules will</div><div class="line"><a name="l06064"></a><span class="lineno"> 6064</span>&#160;be used.</div><div class="line"><a name="l06065"></a><span class="lineno"> 6065</span>&#160;</div><div class="line"><a name="l06066"></a><span class="lineno"> 6066</span>&#160;If explicit qualification is needed, this can be done using the prefix convention:</div><div class="line"><a name="l06067"></a><span class="lineno"> 6067</span>&#160;</div><div class="line"><a name="l06068"></a><span class="lineno"> 6068</span>&#160;```cpp</div><div class="line"><a name="l06069"></a><span class="lineno"> 6069</span>&#160;//gsoap x schema namespace: urn:x </div><div class="line"><a name="l06070"></a><span class="lineno"> 6070</span>&#160;//gsoap y schema namespace: urn:y </div><div class="line"><a name="l06071"></a><span class="lineno"> 6071</span>&#160;struct x__record </div><div class="line"><a name="l06072"></a><span class="lineno"> 6072</span>&#160;{ </div><div class="line"><a name="l06073"></a><span class="lineno"> 6073</span>&#160;  @ char * xsi__type;  </div><div class="line"><a name="l06074"></a><span class="lineno"> 6074</span>&#160;  char * y__name; </div><div class="line"><a name="l06075"></a><span class="lineno"> 6075</span>&#160;};</div><div class="line"><a name="l06076"></a><span class="lineno"> 6076</span>&#160;```</div><div class="line"><a name="l06077"></a><span class="lineno"> 6077</span>&#160;</div><div class="line"><a name="l06078"></a><span class="lineno"> 6078</span>&#160;which ensures that there cannot be any name clashes between members of the same name defined in different schemas (consider for example `name` and `y__name`), but this can clutter the representation when clashes do not occur.</div><div class="line"><a name="l06079"></a><span class="lineno"> 6079</span>&#160;</div><div class="line"><a name="l06080"></a><span class="lineno"> 6080</span>&#160;An alternative to the prefix convention is the use of &quot;**colon notation**&quot; in the</div><div class="line"><a name="l06081"></a><span class="lineno"> 6081</span>&#160;gSOAP header file. This deviation from the C/C++ syntax allows you to bind</div><div class="line"><a name="l06082"></a><span class="lineno"> 6082</span>&#160;type names and struct and class members to qualified and unqualified XML tag names explicitly,</div><div class="line"><a name="l06083"></a><span class="lineno"> 6083</span>&#160;thus bypassing the default mechanism that automatically qualifies or</div><div class="line"><a name="l06084"></a><span class="lineno"> 6084</span>&#160;unqualifies element and attribute tag names based on the schema</div><div class="line"><a name="l06085"></a><span class="lineno"> 6085</span>&#160;element/attribute form.</div><div class="line"><a name="l06086"></a><span class="lineno"> 6086</span>&#160;</div><div class="line"><a name="l06087"></a><span class="lineno"> 6087</span>&#160;The colon notation for type names, struct/class names and members overrides the prefix qualification rules explicitly:</div><div class="line"><a name="l06088"></a><span class="lineno"> 6088</span>&#160;</div><div class="line"><a name="l06089"></a><span class="lineno"> 6089</span>&#160;```cpp</div><div class="line"><a name="l06090"></a><span class="lineno"> 6090</span>&#160;//gsoap x schema namespace: urn:x </div><div class="line"><a name="l06091"></a><span class="lineno"> 6091</span>&#160;//gsoap y schema namespace: urn:y </div><div class="line"><a name="l06092"></a><span class="lineno"> 6092</span>&#160;struct x:record </div><div class="line"><a name="l06093"></a><span class="lineno"> 6093</span>&#160;{ </div><div class="line"><a name="l06094"></a><span class="lineno"> 6094</span>&#160;  @ char * xsi:type;  </div><div class="line"><a name="l06095"></a><span class="lineno"> 6095</span>&#160;  char * y:name; </div><div class="line"><a name="l06096"></a><span class="lineno"> 6096</span>&#160;};</div><div class="line"><a name="l06097"></a><span class="lineno"> 6097</span>&#160;```</div><div class="line"><a name="l06098"></a><span class="lineno"> 6098</span>&#160;</div><div class="line"><a name="l06099"></a><span class="lineno"> 6099</span>&#160;where `x` and `y` are namespace prefixes that MUST be declared with a directive. The `xsi:type` member is an XML attribute in the `xsi` namespace.</div><div class="line"><a name="l06100"></a><span class="lineno"> 6100</span>&#160;The `soapcpp2` tool maps this to the following struct without the annotations:</div><div class="line"><a name="l06101"></a><span class="lineno"> 6101</span>&#160;</div><div class="line"><a name="l06102"></a><span class="lineno"> 6102</span>&#160;```cpp</div><div class="line"><a name="l06103"></a><span class="lineno"> 6103</span>&#160;// This code is generated from the above by soapcpp2 in soapStub.h: </div><div class="line"><a name="l06104"></a><span class="lineno"> 6104</span>&#160;struct record </div><div class="line"><a name="l06105"></a><span class="lineno"> 6105</span>&#160;{ </div><div class="line"><a name="l06106"></a><span class="lineno"> 6106</span>&#160;          char *type;     /* optional attribute of type xsd:string */ </div><div class="line"><a name="l06107"></a><span class="lineno"> 6107</span>&#160;          char *name;     /* optional element of type xsd:string */ </div><div class="line"><a name="l06108"></a><span class="lineno"> 6108</span>&#160;};</div><div class="line"><a name="l06109"></a><span class="lineno"> 6109</span>&#160;```</div><div class="line"><a name="l06110"></a><span class="lineno"> 6110</span>&#160;</div><div class="line"><a name="l06111"></a><span class="lineno"> 6111</span>&#160;The `soapcpp2` tool also generates XML schemas with element and attribute</div><div class="line"><a name="l06112"></a><span class="lineno"> 6112</span>&#160;references. That is, `y:name` is referenced from the `y` schema by the</div><div class="line"><a name="l06113"></a><span class="lineno"> 6113</span>&#160;*`x:record`* complexType defined in the `x` schema.</div><div class="line"><a name="l06114"></a><span class="lineno"> 6114</span>&#160;</div><div class="line"><a name="l06115"></a><span class="lineno"> 6115</span>&#160;The colon notation also allows you to override the element/attribute form to unqualified for qualified schemas:</div><div class="line"><a name="l06116"></a><span class="lineno"> 6116</span>&#160;</div><div class="line"><a name="l06117"></a><span class="lineno"> 6117</span>&#160;```cpp</div><div class="line"><a name="l06118"></a><span class="lineno"> 6118</span>&#160;//gsoap x schema namespace: urn:x </div><div class="line"><a name="l06119"></a><span class="lineno"> 6119</span>&#160;//gsoap x schema form: qualified </div><div class="line"><a name="l06120"></a><span class="lineno"> 6120</span>&#160;struct x:record </div><div class="line"><a name="l06121"></a><span class="lineno"> 6121</span>&#160;{ </div><div class="line"><a name="l06122"></a><span class="lineno"> 6122</span>&#160;  @ char * :type; </div><div class="line"><a name="l06123"></a><span class="lineno"> 6123</span>&#160;  char * :name; </div><div class="line"><a name="l06124"></a><span class="lineno"> 6124</span>&#160;};</div><div class="line"><a name="l06125"></a><span class="lineno"> 6125</span>&#160;```</div><div class="line"><a name="l06126"></a><span class="lineno"> 6126</span>&#160;</div><div class="line"><a name="l06127"></a><span class="lineno"> 6127</span>&#160;where the colon notation ensures that both `type` and `name` are</div><div class="line"><a name="l06128"></a><span class="lineno"> 6128</span>&#160;unqualified in the XML content, which overrides the default qualified forms of</div><div class="line"><a name="l06129"></a><span class="lineno"> 6129</span>&#160;the `x` schema.</div><div class="line"><a name="l06130"></a><span class="lineno"> 6130</span>&#160;</div><div class="line"><a name="l06131"></a><span class="lineno"> 6131</span>&#160;Note that the use of colon notation to bind namespace prefixes to type names</div><div class="line"><a name="l06132"></a><span class="lineno"> 6132</span>&#160;(typedef, enum, struct, and class names) translates to code without the</div><div class="line"><a name="l06133"></a><span class="lineno"> 6133</span>&#160;prefixes. This means that name clashes can occur between types with identical unquaified names:</div><div class="line"><a name="l06134"></a><span class="lineno"> 6134</span>&#160;</div><div class="line"><a name="l06135"></a><span class="lineno"> 6135</span>&#160;```cpp</div><div class="line"><a name="l06136"></a><span class="lineno"> 6136</span>&#160;enum x:color { RED, WHITE, BLUE }; </div><div class="line"><a name="l06137"></a><span class="lineno"> 6137</span>&#160;enum y:color { YELLOW, ORANGE }; // illegal enum name: name clash with x:color</div><div class="line"><a name="l06138"></a><span class="lineno"> 6138</span>&#160;```</div><div class="line"><a name="l06139"></a><span class="lineno"> 6139</span>&#160;</div><div class="line"><a name="l06140"></a><span class="lineno"> 6140</span>&#160;while prefixing with double underscores never lead to clashes:</div><div class="line"><a name="l06141"></a><span class="lineno"> 6141</span>&#160;</div><div class="line"><a name="l06142"></a><span class="lineno"> 6142</span>&#160;```cpp</div><div class="line"><a name="l06143"></a><span class="lineno"> 6143</span>&#160;enum x__color { RED, WHITE, BLUE }; </div><div class="line"><a name="l06144"></a><span class="lineno"> 6144</span>&#160;enum y__color { YELLOW, ORANGE }; // no name clash</div><div class="line"><a name="l06145"></a><span class="lineno"> 6145</span>&#160;```</div><div class="line"><a name="l06146"></a><span class="lineno"> 6146</span>&#160;</div><div class="line"><a name="l06147"></a><span class="lineno"> 6147</span>&#160;Also note that colon notation has a very different role than the C++ scope</div><div class="line"><a name="l06148"></a><span class="lineno"> 6148</span>&#160;operator `::`. The scope operator cannot be used in places where we need</div><div class="line"><a name="l06149"></a><span class="lineno"> 6149</span>&#160;colon notation, such as struct/class member fields.</div><div class="line"><a name="l06150"></a><span class="lineno"> 6150</span>&#160;</div><div class="line"><a name="l06151"></a><span class="lineno"> 6151</span>&#160;The default mechanism that associates XML tag names with the names of struct</div><div class="line"><a name="l06152"></a><span class="lineno"> 6152</span>&#160;and class member fields can be overriden by &quot;**retagging**&quot; names with the</div><div class="line"><a name="l06153"></a><span class="lineno"> 6153</span>&#160;annotation of ``*tag``* placed next to the member field name. This is particularly useful to support legacy code for which the fixed naming of member fields cannot be easily changed. For example:</div><div class="line"><a name="l06154"></a><span class="lineno"> 6154</span>&#160;</div><div class="line"><a name="l06155"></a><span class="lineno"> 6155</span>&#160;```cpp</div><div class="line"><a name="l06156"></a><span class="lineno"> 6156</span>&#160;//gsoap x schema namespace: urn:x </div><div class="line"><a name="l06157"></a><span class="lineno"> 6157</span>&#160;//gsoap x schema form: qualified </div><div class="line"><a name="l06158"></a><span class="lineno"> 6158</span>&#160;struct x:record </div><div class="line"><a name="l06159"></a><span class="lineno"> 6159</span>&#160;{ </div><div class="line"><a name="l06160"></a><span class="lineno"> 6160</span>&#160;  @ char * t `type{}`;  </div><div class="line"><a name="l06161"></a><span class="lineno"> 6161</span>&#160;  char * s `full-name{}`;  </div><div class="line"><a name="l06162"></a><span class="lineno"> 6162</span>&#160;};</div><div class="line"><a name="l06163"></a><span class="lineno"> 6163</span>&#160;```</div><div class="line"><a name="l06164"></a><span class="lineno"> 6164</span>&#160;</div><div class="line"><a name="l06165"></a><span class="lineno"> 6165</span>&#160;This maps the `t` member to the *`x:type`* XML attribute tag and `s`</div><div class="line"><a name="l06166"></a><span class="lineno"> 6166</span>&#160;member to the *`x:full-name`* XML element tag. Note that both tags are namespace</div><div class="line"><a name="l06167"></a><span class="lineno"> 6167</span>&#160;qualified as per schema declaration.</div><div class="line"><a name="l06168"></a><span class="lineno"> 6168</span>&#160;</div><div class="line"><a name="l06169"></a><span class="lineno"> 6169</span>&#160;As of gSOAP 2.8.23, Unicode characters in C/C++ identifiers are accepted by `soapcpp2` when the source file is encoded in UTF8. C/C++ Unicode names are mapped to Unicode XML tags. For C/C++ source code portability reasons, the `wsdl2h` tool still converts Unicode XML tag names to ASCII C/C++ identifiers using the `_xHHHH` naming convention for `HHHH` character code points. Option `wsdl2h -U` maps Unicode letters in XML tag names to UTF8-encoded Unicode letters in C/C++ identifiers.</div><div class="line"><a name="l06170"></a><span class="lineno"> 6170</span>&#160;</div><div class="line"><a name="l06171"></a><span class="lineno"> 6171</span>&#160;## Namespace Mapping Table        {#nstable}</div><div class="line"><a name="l06172"></a><span class="lineno"> 6172</span>&#160;</div><div class="line"><a name="l06173"></a><span class="lineno"> 6173</span>&#160;A namespace mapping table MUST be defined by clients and service applications.</div><div class="line"><a name="l06174"></a><span class="lineno"> 6174</span>&#160;The mapping table is used by the serializers and deserializers of the stub and</div><div class="line"><a name="l06175"></a><span class="lineno"> 6175</span>&#160;skeleton routines to produce a valid SOAP payload and to validate an incoming</div><div class="line"><a name="l06176"></a><span class="lineno"> 6176</span>&#160;SOAP payload.  A typical mapping table is shown below:</div><div class="line"><a name="l06177"></a><span class="lineno"> 6177</span>&#160;</div><div class="line"><a name="l06178"></a><span class="lineno"> 6178</span>&#160;```cpp</div><div class="line"><a name="l06179"></a><span class="lineno"> 6179</span>&#160;struct Namespace namespaces[] = </div><div class="line"><a name="l06180"></a><span class="lineno"> 6180</span>&#160;{   // {&quot;ns-prefix&quot;, &quot;ns-name&quot;} </div><div class="line"><a name="l06181"></a><span class="lineno"> 6181</span>&#160;  {&quot;SOAP-ENV&quot;, &quot;http://schemas.xmlsoap.org/soap/envelope/&quot;}, // MUST be first </div><div class="line"><a name="l06182"></a><span class="lineno"> 6182</span>&#160;  {&quot;SOAP-ENC&quot;, &quot;http://schemas.xmlsoap.org/soap/encoding/&quot;}, // MUST be second </div><div class="line"><a name="l06183"></a><span class="lineno"> 6183</span>&#160;  {&quot;xsi&quot;,      &quot;http://www.w3.org/2001/XMLSchema-instance&quot;}, // MUST be third </div><div class="line"><a name="l06184"></a><span class="lineno"> 6184</span>&#160;  {&quot;xsd&quot;,      &quot;http://www.w3.org/2001/XMLSchema&quot;}, // Required for XML Schema types </div><div class="line"><a name="l06185"></a><span class="lineno"> 6185</span>&#160;  {&quot;ns1&quot;,      &quot;urn:my-service-URI&quot;}, // The namespace URI of the service operations </div><div class="line"><a name="l06186"></a><span class="lineno"> 6186</span>&#160;  {NULL, NULL} // end of table </div><div class="line"><a name="l06187"></a><span class="lineno"> 6187</span>&#160;}; </div><div class="line"><a name="l06188"></a><span class="lineno"> 6188</span>&#160;```</div><div class="line"><a name="l06189"></a><span class="lineno"> 6189</span>&#160;</div><div class="line"><a name="l06190"></a><span class="lineno"> 6190</span>&#160;Each namespace prefix used by a identifier name in the header file</div><div class="line"><a name="l06191"></a><span class="lineno"> 6191</span>&#160;specification (see Section \ref idtrans ) MUST have a binding to a</div><div class="line"><a name="l06192"></a><span class="lineno"> 6192</span>&#160;namespace URI in the mapping table. The end of the namespace mapping table MUST</div><div class="line"><a name="l06193"></a><span class="lineno"> 6193</span>&#160;be indicated by the `NULL` pair.  The namespace URI matching is case</div><div class="line"><a name="l06194"></a><span class="lineno"> 6194</span>&#160;insensitive. A namespace prefix is distinguished by the occurrence of a pair</div><div class="line"><a name="l06195"></a><span class="lineno"> 6195</span>&#160;of underscores (`__`) in an identifier.</div><div class="line"><a name="l06196"></a><span class="lineno"> 6196</span>&#160;</div><div class="line"><a name="l06197"></a><span class="lineno"> 6197</span>&#160;An optional namespace pattern MAY be provided with each namespace mapping table</div><div class="line"><a name="l06198"></a><span class="lineno"> 6198</span>&#160;entry.  The patterns provide an alternative namespace matching for the</div><div class="line"><a name="l06199"></a><span class="lineno"> 6199</span>&#160;validation of decoded SOAP messages.  In this pattern, dashes (`-`) are</div><div class="line"><a name="l06200"></a><span class="lineno"> 6200</span>&#160;single-character wildcards and asterisks (`*`) are multi-character</div><div class="line"><a name="l06201"></a><span class="lineno"> 6201</span>&#160;wildcards.  For example, to decode different versions of XML Schema type with</div><div class="line"><a name="l06202"></a><span class="lineno"> 6202</span>&#160;different authoring dates, four dashes can be used in place of the specific</div><div class="line"><a name="l06203"></a><span class="lineno"> 6203</span>&#160;dates in the namespace mapping table pattern:</div><div class="line"><a name="l06204"></a><span class="lineno"> 6204</span>&#160;</div><div class="line"><a name="l06205"></a><span class="lineno"> 6205</span>&#160;```cpp</div><div class="line"><a name="l06206"></a><span class="lineno"> 6206</span>&#160;struct Namespace namespaces[] = </div><div class="line"><a name="l06207"></a><span class="lineno"> 6207</span>&#160;{   // {&quot;ns-prefix&quot;, &quot;ns-name&quot;, &quot;ns-name validation pattern&quot;} </div><div class="line"><a name="l06208"></a><span class="lineno"> 6208</span>&#160;... </div><div class="line"><a name="l06209"></a><span class="lineno"> 6209</span>&#160;  {&quot;xsi&quot;,      &quot;http://www.w3.org/2001/XMLSchema-instance&quot;, &quot;http://www.w3.org/----/XMLSchema-instance&quot;}, </div><div class="line"><a name="l06210"></a><span class="lineno"> 6210</span>&#160;  {&quot;xsd&quot;,      &quot;http://www.w3.org/2001/XMLSchema&quot;, &quot;http://www.w3.org/----/XMLSchema&quot;}, </div><div class="line"><a name="l06211"></a><span class="lineno"> 6211</span>&#160;...</div><div class="line"><a name="l06212"></a><span class="lineno"> 6212</span>&#160;```</div><div class="line"><a name="l06213"></a><span class="lineno"> 6213</span>&#160;</div><div class="line"><a name="l06214"></a><span class="lineno"> 6214</span>&#160;Or alternatively, asterisks can be used as wildcards for multiple characters:</div><div class="line"><a name="l06215"></a><span class="lineno"> 6215</span>&#160;</div><div class="line"><a name="l06216"></a><span class="lineno"> 6216</span>&#160;```cpp</div><div class="line"><a name="l06217"></a><span class="lineno"> 6217</span>&#160;struct Namespace namespaces[] = </div><div class="line"><a name="l06218"></a><span class="lineno"> 6218</span>&#160;{   // {&quot;ns-prefix&quot;, &quot;ns-name&quot;, &quot;ns-name validation pattern&quot;} </div><div class="line"><a name="l06219"></a><span class="lineno"> 6219</span>&#160;... </div><div class="line"><a name="l06220"></a><span class="lineno"> 6220</span>&#160;  {&quot;xsi&quot;,      &quot;http://www.w3.org/2001/XMLSchema-instance&quot;, &quot;http://www.w3.org/*/XMLSchema-instance&quot;}, </div><div class="line"><a name="l06221"></a><span class="lineno"> 6221</span>&#160;  {&quot;xsd&quot;,      &quot;http://www.w3.org/2001/XMLSchema&quot;, &quot;http://www.w3.org/*/XMLSchema&quot;}, </div><div class="line"><a name="l06222"></a><span class="lineno"> 6222</span>&#160;...</div><div class="line"><a name="l06223"></a><span class="lineno"> 6223</span>&#160;```</div><div class="line"><a name="l06224"></a><span class="lineno"> 6224</span>&#160;</div><div class="line"><a name="l06225"></a><span class="lineno"> 6225</span>&#160;A namespace mapping table is automatically generated together with a WSDL file</div><div class="line"><a name="l06226"></a><span class="lineno"> 6226</span>&#160;for each namespace prefix that is used for a service operation specified in the header file.</div><div class="line"><a name="l06227"></a><span class="lineno"> 6227</span>&#160;This namespace mapping table has entries for all namespace prefixes.  The</div><div class="line"><a name="l06228"></a><span class="lineno"> 6228</span>&#160;namespace URIs need to be filled in. These appear as `http://tempuri.org`</div><div class="line"><a name="l06229"></a><span class="lineno"> 6229</span>&#160;in the table.  See Section \ref directives  on how to specify the namespace</div><div class="line"><a name="l06230"></a><span class="lineno"> 6230</span>&#160;URIs in the header file.</div><div class="line"><a name="l06231"></a><span class="lineno"> 6231</span>&#160;</div><div class="line"><a name="l06232"></a><span class="lineno"> 6232</span>&#160;For decoding elements with namespace prefixes, the namespace URI associated with the namespace prefix (through the *`xmlns`*</div><div class="line"><a name="l06233"></a><span class="lineno"> 6233</span>&#160;attribute of an XML element) is searched from the</div><div class="line"><a name="l06234"></a><span class="lineno"> 6234</span>&#160;beginning to the end in a namespace mapping table,</div><div class="line"><a name="l06235"></a><span class="lineno"> 6235</span>&#160;and for every row the following tests are performed as part of the validation process:</div><div class="line"><a name="l06236"></a><span class="lineno"> 6236</span>&#160;</div><div class="line"><a name="l06237"></a><span class="lineno"> 6237</span>&#160;</div><div class="line"><a name="l06238"></a><span class="lineno"> 6238</span>&#160;*  the string in the second column matches the namespace URI (case insensitive)</div><div class="line"><a name="l06239"></a><span class="lineno"> 6239</span>&#160;</div><div class="line"><a name="l06240"></a><span class="lineno"> 6240</span>&#160;*  the string in the optional third column matches the namespace URI (case insensitive), where `-` is a one-character wildcard and `*` is a</div><div class="line"><a name="l06241"></a><span class="lineno"> 6241</span>&#160;   multi-character wildcard</div><div class="line"><a name="l06242"></a><span class="lineno"> 6242</span>&#160;</div><div class="line"><a name="l06243"></a><span class="lineno"> 6243</span>&#160;When a match is found, the namespace prefix in the first column of the table is considered semantically identical to the namespace prefix used</div><div class="line"><a name="l06244"></a><span class="lineno"> 6244</span>&#160;by the XML element to be decoded, though the prefix names may differ.</div><div class="line"><a name="l06245"></a><span class="lineno"> 6245</span>&#160;A service will respond with the namespace that it received from a client in case it matches a pattern in the third column.</div><div class="line"><a name="l06246"></a><span class="lineno"> 6246</span>&#160;</div><div class="line"><a name="l06247"></a><span class="lineno"> 6247</span>&#160;For example, let&#39;s say we have the following structs:</div><div class="line"><a name="l06248"></a><span class="lineno"> 6248</span>&#160;</div><div class="line"><a name="l06249"></a><span class="lineno"> 6249</span>&#160;```cpp</div><div class="line"><a name="l06250"></a><span class="lineno"> 6250</span>&#160;struct a__elt { ... }; </div><div class="line"><a name="l06251"></a><span class="lineno"> 6251</span>&#160;struct b__elt { ... }; </div><div class="line"><a name="l06252"></a><span class="lineno"> 6252</span>&#160;struct k__elt { ... }; </div><div class="line"><a name="l06253"></a><span class="lineno"> 6253</span>&#160;```</div><div class="line"><a name="l06254"></a><span class="lineno"> 6254</span>&#160;</div><div class="line"><a name="l06255"></a><span class="lineno"> 6255</span>&#160;and a namespace mapping table in the program:</div><div class="line"><a name="l06256"></a><span class="lineno"> 6256</span>&#160;</div><div class="line"><a name="l06257"></a><span class="lineno"> 6257</span>&#160;```cpp</div><div class="line"><a name="l06258"></a><span class="lineno"> 6258</span>&#160;struct Namespace namespaces[] = </div><div class="line"><a name="l06259"></a><span class="lineno"> 6259</span>&#160;{   // {&quot;ns-prefix&quot;, &quot;ns-name&quot;, &quot;ns-name validation pattern&quot;} </div><div class="line"><a name="l06260"></a><span class="lineno"> 6260</span>&#160;... </div><div class="line"><a name="l06261"></a><span class="lineno"> 6261</span>&#160;  {&quot;a&quot;, &quot;some uri&quot;}, </div><div class="line"><a name="l06262"></a><span class="lineno"> 6262</span>&#160;  {&quot;b&quot;, &quot;other uri&quot;}, </div><div class="line"><a name="l06263"></a><span class="lineno"> 6263</span>&#160;  {&quot;c&quot;, &quot;his uri&quot;, &quot;* uri&quot;}, </div><div class="line"><a name="l06264"></a><span class="lineno"> 6264</span>&#160;...</div><div class="line"><a name="l06265"></a><span class="lineno"> 6265</span>&#160;```</div><div class="line"><a name="l06266"></a><span class="lineno"> 6266</span>&#160;</div><div class="line"><a name="l06267"></a><span class="lineno"> 6267</span>&#160;Then, the following XML elements will match the structs:</div><div class="line"><a name="l06268"></a><span class="lineno"> 6268</span>&#160;</div><div class="line"><a name="l06269"></a><span class="lineno"> 6269</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l06270"></a><span class="lineno"> 6270</span>&#160;```xml</div><div class="line"><a name="l06271"></a><span class="lineno"> 6271</span>&#160;&lt;n:elt xmlns:n=&quot;some URI&quot;&gt; \qquad\mbox{matches the struct name `a__elt`} </div><div class="line"><a name="l06272"></a><span class="lineno"> 6272</span>&#160;... </div><div class="line"><a name="l06273"></a><span class="lineno"> 6273</span>&#160;&lt;m:elt xmlns:m=&quot;other URI&quot;&gt; \qquad\mbox{matches the struct name `b__elt`} </div><div class="line"><a name="l06274"></a><span class="lineno"> 6274</span>&#160;... </div><div class="line"><a name="l06275"></a><span class="lineno"> 6275</span>&#160;&lt;k:elt xmlns:k=&quot;my URI&quot;&gt; \qquad\mbox{matches the struct name `c__elt`} </div><div class="line"><a name="l06276"></a><span class="lineno"> 6276</span>&#160;... </div><div class="line"><a name="l06277"></a><span class="lineno"> 6277</span>&#160;```</div><div class="line"><a name="l06278"></a><span class="lineno"> 6278</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l06279"></a><span class="lineno"> 6279</span>&#160;</div><div class="line"><a name="l06280"></a><span class="lineno"> 6280</span>&#160;The response of a service to a client request that uses the namespaces listed above,</div><div class="line"><a name="l06281"></a><span class="lineno"> 6281</span>&#160;will include *`my URI`* for the name space of element *`k`*.</div><div class="line"><a name="l06282"></a><span class="lineno"> 6282</span>&#160;</div><div class="line"><a name="l06283"></a><span class="lineno"> 6283</span>&#160;It is possible to use a number of different namespace tables and select the one that is appropriate.</div><div class="line"><a name="l06284"></a><span class="lineno"> 6284</span>&#160;For example, an application might contact many different Web services all using different namespace URIs.</div><div class="line"><a name="l06285"></a><span class="lineno"> 6285</span>&#160;If all the URIs are stored in one table, each service operation invocation will dump the whole namespace</div><div class="line"><a name="l06286"></a><span class="lineno"> 6286</span>&#160;table in the SOAP payload.  There is no technical problem with that, but it can be ugly when the table is large.</div><div class="line"><a name="l06287"></a><span class="lineno"> 6287</span>&#160;To use different namespace tables, declare a pointer to a table and set the pointer to a particular table before service operation</div><div class="line"><a name="l06288"></a><span class="lineno"> 6288</span>&#160;invocation.  For example:</div><div class="line"><a name="l06289"></a><span class="lineno"> 6289</span>&#160;</div><div class="line"><a name="l06290"></a><span class="lineno"> 6290</span>&#160;```cpp</div><div class="line"><a name="l06291"></a><span class="lineno"> 6291</span>&#160;struct Namespace namespacesTable1[] = { ... }; </div><div class="line"><a name="l06292"></a><span class="lineno"> 6292</span>&#160;struct Namespace namespacesTable2[] = { ... }; </div><div class="line"><a name="l06293"></a><span class="lineno"> 6293</span>&#160;struct Namespace namespacesTable3[] = { ... }; </div><div class="line"><a name="l06294"></a><span class="lineno"> 6294</span>&#160;struct Namespace *namespaces; </div><div class="line"><a name="l06295"></a><span class="lineno"> 6295</span>&#160;... </div><div class="line"><a name="l06296"></a><span class="lineno"> 6296</span>&#160;struct soap soap; </div><div class="line"><a name="l06297"></a><span class="lineno"> 6297</span>&#160;... </div><div class="line"><a name="l06298"></a><span class="lineno"> 6298</span>&#160;soap_init(&amp;soap); </div><div class="line"><a name="l06299"></a><span class="lineno"> 6299</span>&#160;soap_set_namespaces(&amp;soap, namespaceTable1); </div><div class="line"><a name="l06300"></a><span class="lineno"> 6300</span>&#160;soap_call_remote_method(&amp;soap, URL, Action, ...); </div><div class="line"><a name="l06301"></a><span class="lineno"> 6301</span>&#160;...</div><div class="line"><a name="l06302"></a><span class="lineno"> 6302</span>&#160;``` </div><div class="line"><a name="l06303"></a><span class="lineno"> 6303</span>&#160;</div><div class="line"><a name="l06304"></a><span class="lineno"> 6304</span>&#160;# gSOAP Serialization and Deserialization Rules</div><div class="line"><a name="l06305"></a><span class="lineno"> 6305</span>&#160;</div><div class="line"><a name="l06306"></a><span class="lineno"> 6306</span>&#160;This section describes the serialization and deserialization of C and C++ data types for SOAP 1.1 and 1.2 compliant encoding and decoding.</div><div class="line"><a name="l06307"></a><span class="lineno"> 6307</span>&#160;</div><div class="line"><a name="l06308"></a><span class="lineno"> 6308</span>&#160;## SOAP RPC Encoding Versus Document/Literal and xsi:type Info</div><div class="line"><a name="l06309"></a><span class="lineno"> 6309</span>&#160;</div><div class="line"><a name="l06310"></a><span class="lineno"> 6310</span>&#160;The wsdl2h tool automatically generates a header file specialized for SOAP RPC</div><div class="line"><a name="l06311"></a><span class="lineno"> 6311</span>&#160;encoding or document/literal style. The serialization and deserialization rules</div><div class="line"><a name="l06312"></a><span class="lineno"> 6312</span>&#160;for C/C++ objects is almost identical for these styles, except for the</div><div class="line"><a name="l06313"></a><span class="lineno"> 6313</span>&#160;following important issues.</div><div class="line"><a name="l06314"></a><span class="lineno"> 6314</span>&#160;</div><div class="line"><a name="l06315"></a><span class="lineno"> 6315</span>&#160;With SOAP RPC encoding style, care must be taken to ensure typed messages are</div><div class="line"><a name="l06316"></a><span class="lineno"> 6316</span>&#160;produced for interoperability and compatibility reasons. To ensure that the</div><div class="line"><a name="l06317"></a><span class="lineno"> 6317</span>&#160;gSOAP engine automatically generates typed (*`xsi:type`* attributed)</div><div class="line"><a name="l06318"></a><span class="lineno"> 6318</span>&#160;messages, use `soapcpp2` option -t, see also Section \ref options .</div><div class="line"><a name="l06319"></a><span class="lineno"> 6319</span>&#160;While gSOAP can handle untyped messages, some toolkits fail to find</div><div class="line"><a name="l06320"></a><span class="lineno"> 6320</span>&#160;deserializers when the *`xsi:type`* information is absent.</div><div class="line"><a name="l06321"></a><span class="lineno"> 6321</span>&#160;</div><div class="line"><a name="l06322"></a><span class="lineno"> 6322</span>&#160;When starting the development of a gSOAP application from a header file, the</div><div class="line"><a name="l06323"></a><span class="lineno"> 6323</span>&#160;`soapcpp2` compiler will generate WSDL and schema files for SOAP 1.1</div><div class="line"><a name="l06324"></a><span class="lineno"> 6324</span>&#160;document/literal style by default (use the `//gsoap` directives to control</div><div class="line"><a name="l06325"></a><span class="lineno"> 6325</span>&#160;this, see Section \ref directives ). Use `soapcpp2` options -2, -e, and</div><div class="line"><a name="l06326"></a><span class="lineno"> 6326</span>&#160;-t to generate code for SOAP 1.2, RPC encoding, and typed messages.</div><div class="line"><a name="l06327"></a><span class="lineno"> 6327</span>&#160;</div><div class="line"><a name="l06328"></a><span class="lineno"> 6328</span>&#160;With SOAP RPC encoding, generic *`complexTypes`* with</div><div class="line"><a name="l06329"></a><span class="lineno"> 6329</span>&#160;*`maxOccurs=&quot;unbounded&quot;`* are not allowed and SOAP encoded arrays must be</div><div class="line"><a name="l06330"></a><span class="lineno"> 6330</span>&#160;used. Also XML attributes and unions (XML schema *`choice`*) are not allowed</div><div class="line"><a name="l06331"></a><span class="lineno"> 6331</span>&#160;with SOAP RPC encoding.</div><div class="line"><a name="l06332"></a><span class="lineno"> 6332</span>&#160;</div><div class="line"><a name="l06333"></a><span class="lineno"> 6333</span>&#160;Also with SOAP RPC encoding, multi-reference accessors are common to encode</div><div class="line"><a name="l06334"></a><span class="lineno"> 6334</span>&#160;co-referenced objects and object digraphs. Multi-reference encoding is not</div><div class="line"><a name="l06335"></a><span class="lineno"> 6335</span>&#160;supported in document/literal style, which means that cyclic object digraphs</div><div class="line"><a name="l06336"></a><span class="lineno"> 6336</span>&#160;cannot be serialized (the engine will crash). Also DAGs are represented as XML</div><div class="line"><a name="l06337"></a><span class="lineno"> 6337</span>&#160;trees in document/literal style messaging.</div><div class="line"><a name="l06338"></a><span class="lineno"> 6338</span>&#160;</div><div class="line"><a name="l06339"></a><span class="lineno"> 6339</span>&#160;## Primitive Type Encoding</div><div class="line"><a name="l06340"></a><span class="lineno"> 6340</span>&#160;</div><div class="line"><a name="l06341"></a><span class="lineno"> 6341</span>&#160;The default encoding rules for the primitive C and C++ data types are given in the table below:</div><div class="line"><a name="l06342"></a><span class="lineno"> 6342</span>&#160;</div><div class="line"><a name="l06343"></a><span class="lineno"> 6343</span>&#160;C/C++ type           | XML schema type</div><div class="line"><a name="l06344"></a><span class="lineno"> 6344</span>&#160;-------------------- | ---------------</div><div class="line"><a name="l06345"></a><span class="lineno"> 6345</span>&#160;`bool`               | *`boolean`* </div><div class="line"><a name="l06346"></a><span class="lineno"> 6346</span>&#160;`char*`              | *`string`* </div><div class="line"><a name="l06347"></a><span class="lineno"> 6347</span>&#160;`char`               | *`byte`* </div><div class="line"><a name="l06348"></a><span class="lineno"> 6348</span>&#160;`long double`        | *`decimal`* with `#import &quot;custom/long_double.h&quot;`</div><div class="line"><a name="l06349"></a><span class="lineno"> 6349</span>&#160;`double`             | *`double`* </div><div class="line"><a name="l06350"></a><span class="lineno"> 6350</span>&#160;`float`              | *`float`* </div><div class="line"><a name="l06351"></a><span class="lineno"> 6351</span>&#160;`int`                | *`int`* </div><div class="line"><a name="l06352"></a><span class="lineno"> 6352</span>&#160;`long`               | *`long`* </div><div class="line"><a name="l06353"></a><span class="lineno"> 6353</span>&#160;`LONG64`             | *`long`* </div><div class="line"><a name="l06354"></a><span class="lineno"> 6354</span>&#160;`long long`          | *`long`* </div><div class="line"><a name="l06355"></a><span class="lineno"> 6355</span>&#160;`short`              | *`short`* </div><div class="line"><a name="l06356"></a><span class="lineno"> 6356</span>&#160;`time_t`             | *`dateTime`* </div><div class="line"><a name="l06357"></a><span class="lineno"> 6357</span>&#160;`std::string`        | *`string`* </div><div class="line"><a name="l06358"></a><span class="lineno"> 6358</span>&#160;`std::wstring`       | *`string`* </div><div class="line"><a name="l06359"></a><span class="lineno"> 6359</span>&#160;`struct tm`          | *`dateTime`* with `#import &quot;custom/struct_tm.h&quot;` </div><div class="line"><a name="l06360"></a><span class="lineno"> 6360</span>&#160;`struct timeval`     | *`dateTime`* with `#import &quot;custom/struct_timeval.h&quot;`</div><div class="line"><a name="l06361"></a><span class="lineno"> 6361</span>&#160;`unsigned char`      | *`unsignedByte`* </div><div class="line"><a name="l06362"></a><span class="lineno"> 6362</span>&#160;`unsigned int`       | *`unsignedInt`* </div><div class="line"><a name="l06363"></a><span class="lineno"> 6363</span>&#160;`unsigned long`      | *`unsignedLong`* </div><div class="line"><a name="l06364"></a><span class="lineno"> 6364</span>&#160;`ULONG64`            | *`unsignedLong`* </div><div class="line"><a name="l06365"></a><span class="lineno"> 6365</span>&#160;`unsigned long long` | *`unsignedLong`* </div><div class="line"><a name="l06366"></a><span class="lineno"> 6366</span>&#160;`unsigned short`     | *`unsignedShort`* </div><div class="line"><a name="l06367"></a><span class="lineno"> 6367</span>&#160;`wchar_t*`           | *`string`* </div><div class="line"><a name="l06368"></a><span class="lineno"> 6368</span>&#160;</div><div class="line"><a name="l06369"></a><span class="lineno"> 6369</span>&#160;Objects of type `void` and `void *` cannot be encoded.</div><div class="line"><a name="l06370"></a><span class="lineno"> 6370</span>&#160;Enumerations and bit masks are supported as well, see \ref enum .</div><div class="line"><a name="l06371"></a><span class="lineno"> 6371</span>&#160;</div><div class="line"><a name="l06372"></a><span class="lineno"> 6372</span>&#160;## How to Represent Primitive C/C++ Types as XSD Types        {#primitive}</div><div class="line"><a name="l06373"></a><span class="lineno"> 6373</span>&#160;</div><div class="line"><a name="l06374"></a><span class="lineno"> 6374</span>&#160;By default, encoding of the primitive types will take place as per SOAP</div><div class="line"><a name="l06375"></a><span class="lineno"> 6375</span>&#160;encoding style.  The encoding can be changed to any XML Schema type (XSD type) with an</div><div class="line"><a name="l06376"></a><span class="lineno"> 6376</span>&#160;optional namespace prefix by using a `typedef` in the header file input to</div><div class="line"><a name="l06377"></a><span class="lineno"> 6377</span>&#160;the gSOAP `soapcpp2` tool. The declaration enables the</div><div class="line"><a name="l06378"></a><span class="lineno"> 6378</span>&#160;implementation of built-in XML Schema types (also known as XSD types) such as</div><div class="line"><a name="l06379"></a><span class="lineno"> 6379</span>&#160;*`positiveInteger`*, *`xsd:anyURI`*, and *`xsd:date`* for which no</div><div class="line"><a name="l06380"></a><span class="lineno"> 6380</span>&#160;built-in data structures in C and C++ exist but which can be represented using</div><div class="line"><a name="l06381"></a><span class="lineno"> 6381</span>&#160;standard data structures such as strings, integers, and floats.</div><div class="line"><a name="l06382"></a><span class="lineno"> 6382</span>&#160;</div><div class="line"><a name="l06383"></a><span class="lineno"> 6383</span>&#160;The `typedef` declaration is frequently used for convenience in C. A</div><div class="line"><a name="l06384"></a><span class="lineno"> 6384</span>&#160;`typedef` declares a type name for a (complex) type expression. The type</div><div class="line"><a name="l06385"></a><span class="lineno"> 6385</span>&#160;name can then be used in other declarations in place of the more complex type</div><div class="line"><a name="l06386"></a><span class="lineno"> 6386</span>&#160;expression, which often improves the readability of the program code.</div><div class="line"><a name="l06387"></a><span class="lineno"> 6387</span>&#160;</div><div class="line"><a name="l06388"></a><span class="lineno"> 6388</span>&#160;The gSOAP `soapcpp2` compiler interprets `typedef` declarations the same way as a</div><div class="line"><a name="l06389"></a><span class="lineno"> 6389</span>&#160;regular C compiler interprets them, i.e. as types in declarations. In addition</div><div class="line"><a name="l06390"></a><span class="lineno"> 6390</span>&#160;however, the gSOAP `soapcpp2` compiler will also use the type name in the encoding of the</div><div class="line"><a name="l06391"></a><span class="lineno"> 6391</span>&#160;data in SOAP.  The `typedef` name will appear as the XML element name of</div><div class="line"><a name="l06392"></a><span class="lineno"> 6392</span>&#160;an independent element and as the value of the *`xsi:type`* attribute in the</div><div class="line"><a name="l06393"></a><span class="lineno"> 6393</span>&#160;SOAP payload.</div><div class="line"><a name="l06394"></a><span class="lineno"> 6394</span>&#160;</div><div class="line"><a name="l06395"></a><span class="lineno"> 6395</span>&#160;Many built-in primitive and derived XSD types such as *`xsd:anyURI`*,</div><div class="line"><a name="l06396"></a><span class="lineno"> 6396</span>&#160;*`positiveInteger`*, and *`decimal`* can be stored by standard primitive</div><div class="line"><a name="l06397"></a><span class="lineno"> 6397</span>&#160;data structures in C++, such as strings, integers, floats, and doubles.</div><div class="line"><a name="l06398"></a><span class="lineno"> 6398</span>&#160;To serialize strings, integers, floats, and doubles as built-in primitive and</div><div class="line"><a name="l06399"></a><span class="lineno"> 6399</span>&#160;derived XSD types, a `typedef` declaration can be used</div><div class="line"><a name="l06400"></a><span class="lineno"> 6400</span>&#160;to declare an XSD type.</div><div class="line"><a name="l06401"></a><span class="lineno"> 6401</span>&#160;</div><div class="line"><a name="l06402"></a><span class="lineno"> 6402</span>&#160;For example, the declaration</div><div class="line"><a name="l06403"></a><span class="lineno"> 6403</span>&#160;</div><div class="line"><a name="l06404"></a><span class="lineno"> 6404</span>&#160;```cpp</div><div class="line"><a name="l06405"></a><span class="lineno"> 6405</span>&#160;typedef unsigned int xsd__positiveInteger;</div><div class="line"><a name="l06406"></a><span class="lineno"> 6406</span>&#160;```</div><div class="line"><a name="l06407"></a><span class="lineno"> 6407</span>&#160;</div><div class="line"><a name="l06408"></a><span class="lineno"> 6408</span>&#160;creates a named type `positiveInteger` which is represented by `unsigned int` in C++. For example, the encoding of a</div><div class="line"><a name="l06409"></a><span class="lineno"> 6409</span>&#160;`positiveInteger` value `3` is</div><div class="line"><a name="l06410"></a><span class="lineno"> 6410</span>&#160;</div><div class="line"><a name="l06411"></a><span class="lineno"> 6411</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l06412"></a><span class="lineno"> 6412</span>&#160;```xml</div><div class="line"><a name="l06413"></a><span class="lineno"> 6413</span>&#160;&lt;positiveInteger xsi:type=&quot;xsd:positiveInteger&quot;&gt;3&lt;/positiveInteger&gt;</div><div class="line"><a name="l06414"></a><span class="lineno"> 6414</span>&#160;```</div><div class="line"><a name="l06415"></a><span class="lineno"> 6415</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l06416"></a><span class="lineno"> 6416</span>&#160;</div><div class="line"><a name="l06417"></a><span class="lineno"> 6417</span>&#160;&lt;img src=&quot;https://www.w3.org/TR/xmlschema-2/type-hierarchy.gif&quot;/&gt;</div><div class="line"><a name="l06418"></a><span class="lineno"> 6418</span>&#160;</div><div class="line"><a name="l06419"></a><span class="lineno"> 6419</span>&#160;The built-in primitive and derived numerical XML Schema types are listed below together with their recommended `typedef`</div><div class="line"><a name="l06420"></a><span class="lineno"> 6420</span>&#160;declarations. Note that the SOAP encoding schemas for primitive types are derived from the built-in XML Schema types, so</div><div class="line"><a name="l06421"></a><span class="lineno"> 6421</span>&#160;`SOAP_ENC__` can be used as a namespace prefix instead of `xsd__`.</div><div class="line"><a name="l06422"></a><span class="lineno"> 6422</span>&#160;</div><div class="line"><a name="l06423"></a><span class="lineno"> 6423</span>&#160;* *`xsd:anyURI`*</div><div class="line"><a name="l06424"></a><span class="lineno"> 6424</span>&#160;Represents a Uniform Resource Identifier Reference (URI).</div><div class="line"><a name="l06425"></a><span class="lineno"> 6425</span>&#160;Each URI scheme imposes specialized syntax rules for URIs in that scheme, including restrictions</div><div class="line"><a name="l06426"></a><span class="lineno"> 6426</span>&#160;on the syntax of allowed fragment identifiers.</div><div class="line"><a name="l06427"></a><span class="lineno"> 6427</span>&#160;It is recommended to use strings to store *`xsd:anyURI`* XML Schema types. The recommended type declaration is:</div><div class="line"><a name="l06428"></a><span class="lineno"> 6428</span>&#160;</div><div class="line"><a name="l06429"></a><span class="lineno"> 6429</span>&#160;```cpp</div><div class="line"><a name="l06430"></a><span class="lineno"> 6430</span>&#160;typedef char *xsd__anyURI;</div><div class="line"><a name="l06431"></a><span class="lineno"> 6431</span>&#160;```</div><div class="line"><a name="l06432"></a><span class="lineno"> 6432</span>&#160;</div><div class="line"><a name="l06433"></a><span class="lineno"> 6433</span>&#160;* *`xsd:base64Binary`*</div><div class="line"><a name="l06434"></a><span class="lineno"> 6434</span>&#160;Represents Base64-encoded arbitrary binary data.</div><div class="line"><a name="l06435"></a><span class="lineno"> 6435</span>&#160;For using the *`xsd:base64Binary`* XSD Schema type, the use of the base64Binary representation of a dynamic array is **strongly** recommended,</div><div class="line"><a name="l06436"></a><span class="lineno"> 6436</span>&#160;see Section \ref base64binary . However, the</div><div class="line"><a name="l06437"></a><span class="lineno"> 6437</span>&#160;type can also be declared as a string and the encoding will be string-based:</div><div class="line"><a name="l06438"></a><span class="lineno"> 6438</span>&#160;</div><div class="line"><a name="l06439"></a><span class="lineno"> 6439</span>&#160;```cpp</div><div class="line"><a name="l06440"></a><span class="lineno"> 6440</span>&#160;typedef char *xsd__base64Binary;</div><div class="line"><a name="l06441"></a><span class="lineno"> 6441</span>&#160;```</div><div class="line"><a name="l06442"></a><span class="lineno"> 6442</span>&#160;</div><div class="line"><a name="l06443"></a><span class="lineno"> 6443</span>&#160;With this approach, it is the responsibility of the application to make sure the string content is according to the Base64 Content-Transfer-Encoding defined in Section 6.8 of RFC 2045.</div><div class="line"><a name="l06444"></a><span class="lineno"> 6444</span>&#160;</div><div class="line"><a name="l06445"></a><span class="lineno"> 6445</span>&#160;</div><div class="line"><a name="l06446"></a><span class="lineno"> 6446</span>&#160;* *`xsd:boolean`*</div><div class="line"><a name="l06447"></a><span class="lineno"> 6447</span>&#160;For declaring an *`xsd:boolean`* XSD Schema type, the use of a bool is **strongly** recommended.</div><div class="line"><a name="l06448"></a><span class="lineno"> 6448</span>&#160;If a pure C compiler is used that does not support the `bool` type, see Section \ref boolean .</div><div class="line"><a name="l06449"></a><span class="lineno"> 6449</span>&#160;The corresponding type declaration is:</div><div class="line"><a name="l06450"></a><span class="lineno"> 6450</span>&#160;</div><div class="line"><a name="l06451"></a><span class="lineno"> 6451</span>&#160;```cpp</div><div class="line"><a name="l06452"></a><span class="lineno"> 6452</span>&#160;typedef bool xsd__boolean;</div><div class="line"><a name="l06453"></a><span class="lineno"> 6453</span>&#160;```</div><div class="line"><a name="l06454"></a><span class="lineno"> 6454</span>&#160;</div><div class="line"><a name="l06455"></a><span class="lineno"> 6455</span>&#160;Type `xsd__boolean` declares a Boolean (0 or 1), which is encoded as</div><div class="line"><a name="l06456"></a><span class="lineno"> 6456</span>&#160;</div><div class="line"><a name="l06457"></a><span class="lineno"> 6457</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l06458"></a><span class="lineno"> 6458</span>&#160;```xml</div><div class="line"><a name="l06459"></a><span class="lineno"> 6459</span>&#160;&lt;xsd:boolean xsi:type=&quot;xsd:boolean&quot;&gt;...&lt;/xsd:boolean&gt;</div><div class="line"><a name="l06460"></a><span class="lineno"> 6460</span>&#160;```</div><div class="line"><a name="l06461"></a><span class="lineno"> 6461</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l06462"></a><span class="lineno"> 6462</span>&#160;</div><div class="line"><a name="l06463"></a><span class="lineno"> 6463</span>&#160;</div><div class="line"><a name="l06464"></a><span class="lineno"> 6464</span>&#160;* *`xsd:byte`*</div><div class="line"><a name="l06465"></a><span class="lineno"> 6465</span>&#160;Represents a byte (-128...127). The corresponding type declaration is:</div><div class="line"><a name="l06466"></a><span class="lineno"> 6466</span>&#160;```cpp</div><div class="line"><a name="l06467"></a><span class="lineno"> 6467</span>&#160;typedef char xsd__byte;</div><div class="line"><a name="l06468"></a><span class="lineno"> 6468</span>&#160;```</div><div class="line"><a name="l06469"></a><span class="lineno"> 6469</span>&#160;</div><div class="line"><a name="l06470"></a><span class="lineno"> 6470</span>&#160;Type `xsd__byte` declares a byte which is encoded as </div><div class="line"><a name="l06471"></a><span class="lineno"> 6471</span>&#160;</div><div class="line"><a name="l06472"></a><span class="lineno"> 6472</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l06473"></a><span class="lineno"> 6473</span>&#160;```xml</div><div class="line"><a name="l06474"></a><span class="lineno"> 6474</span>&#160;&lt;xsd:byte xsi:type=&quot;xsd:byte&quot;&gt;...&lt;/xsd:byte&gt;</div><div class="line"><a name="l06475"></a><span class="lineno"> 6475</span>&#160;```</div><div class="line"><a name="l06476"></a><span class="lineno"> 6476</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l06477"></a><span class="lineno"> 6477</span>&#160;</div><div class="line"><a name="l06478"></a><span class="lineno"> 6478</span>&#160;</div><div class="line"><a name="l06479"></a><span class="lineno"> 6479</span>&#160;* *`xsd:dateTime`*</div><div class="line"><a name="l06480"></a><span class="lineno"> 6480</span>&#160;Represents a date and time. The lexical representation is according to the ISO 8601 extended format CCYY-MM-DDThh:mm:ss where &quot;CC&quot;</div><div class="line"><a name="l06481"></a><span class="lineno"> 6481</span>&#160;represents the century, &quot;YY&quot; the year, &quot;MM&quot; the month and &quot;DD&quot; the day, preceded by an optional leading &quot;-&quot; sign to indicate a</div><div class="line"><a name="l06482"></a><span class="lineno"> 6482</span>&#160;negative number. If the sign is omitted, &quot;+&quot; is assumed. The letter &quot;T&quot; is the date/time separator and &quot;hh&quot;, &quot;mm&quot;, &quot;ss&quot; represent</div><div class="line"><a name="l06483"></a><span class="lineno"> 6483</span>&#160;hour, minute and second respectively.</div><div class="line"><a name="l06484"></a><span class="lineno"> 6484</span>&#160;It is recommended to use the `time_t` type to store *`xsd:dateTime`* XSD Schema types and the type declaration is:</div><div class="line"><a name="l06485"></a><span class="lineno"> 6485</span>&#160;</div><div class="line"><a name="l06486"></a><span class="lineno"> 6486</span>&#160;```cpp</div><div class="line"><a name="l06487"></a><span class="lineno"> 6487</span>&#160;typedef time_t xsd__dateTime;</div><div class="line"><a name="l06488"></a><span class="lineno"> 6488</span>&#160;```</div><div class="line"><a name="l06489"></a><span class="lineno"> 6489</span>&#160;</div><div class="line"><a name="l06490"></a><span class="lineno"> 6490</span>&#160;However, note that calendar times  before  the year 1902  or after</div><div class="line"><a name="l06491"></a><span class="lineno"> 6491</span>&#160;the year 2037 cannot be represented. Upon receiving a date outside this range,</div><div class="line"><a name="l06492"></a><span class="lineno"> 6492</span>&#160;the `time_t` value will be set to -1.</div><div class="line"><a name="l06493"></a><span class="lineno"> 6493</span>&#160;</div><div class="line"><a name="l06494"></a><span class="lineno"> 6494</span>&#160;Strings (`char*`) can be used to store *`xsd:dateTime`* XSD Schema types. The type declaration is:</div><div class="line"><a name="l06495"></a><span class="lineno"> 6495</span>&#160;</div><div class="line"><a name="l06496"></a><span class="lineno"> 6496</span>&#160;```cpp</div><div class="line"><a name="l06497"></a><span class="lineno"> 6497</span>&#160;typedef char *xsd__dateTime;</div><div class="line"><a name="l06498"></a><span class="lineno"> 6498</span>&#160;```</div><div class="line"><a name="l06499"></a><span class="lineno"> 6499</span>&#160;In this case, it is up to the application to read and set the dateTime representation.</div><div class="line"><a name="l06500"></a><span class="lineno"> 6500</span>&#160;</div><div class="line"><a name="l06501"></a><span class="lineno"> 6501</span>&#160;</div><div class="line"><a name="l06502"></a><span class="lineno"> 6502</span>&#160;* *`xsd:date`*</div><div class="line"><a name="l06503"></a><span class="lineno"> 6503</span>&#160;Represents a date.</div><div class="line"><a name="l06504"></a><span class="lineno"> 6504</span>&#160;The lexical representation for date is the reduced (right truncated) lexical representation for dateTime: CCYY-MM-DD.</div><div class="line"><a name="l06505"></a><span class="lineno"> 6505</span>&#160;It is recommended to use strings (`char*`) to store *`xsd:date`* XSD Schema types. The type declaration is:</div><div class="line"><a name="l06506"></a><span class="lineno"> 6506</span>&#160;</div><div class="line"><a name="l06507"></a><span class="lineno"> 6507</span>&#160;```cpp</div><div class="line"><a name="l06508"></a><span class="lineno"> 6508</span>&#160;typedef char *xsd__date;</div><div class="line"><a name="l06509"></a><span class="lineno"> 6509</span>&#160;```</div><div class="line"><a name="l06510"></a><span class="lineno"> 6510</span>&#160;</div><div class="line"><a name="l06511"></a><span class="lineno"> 6511</span>&#160;</div><div class="line"><a name="l06512"></a><span class="lineno"> 6512</span>&#160;* *`xsd:decimal`*</div><div class="line"><a name="l06513"></a><span class="lineno"> 6513</span>&#160;Represents arbitrary precision decimal numbers.</div><div class="line"><a name="l06514"></a><span class="lineno"> 6514</span>&#160;It is recommended to use the {double} type to store *`xsd:decimal`* XSD Schema types and the type declaration is:</div><div class="line"><a name="l06515"></a><span class="lineno"> 6515</span>&#160;</div><div class="line"><a name="l06516"></a><span class="lineno"> 6516</span>&#160;```cpp</div><div class="line"><a name="l06517"></a><span class="lineno"> 6517</span>&#160;typedef double xsd__decimal;</div><div class="line"><a name="l06518"></a><span class="lineno"> 6518</span>&#160;```</div><div class="line"><a name="l06519"></a><span class="lineno"> 6519</span>&#160;</div><div class="line"><a name="l06520"></a><span class="lineno"> 6520</span>&#160;Type `xsd__decimal` declares a double floating point number which is encoded as </div><div class="line"><a name="l06521"></a><span class="lineno"> 6521</span>&#160;</div><div class="line"><a name="l06522"></a><span class="lineno"> 6522</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l06523"></a><span class="lineno"> 6523</span>&#160;```xml</div><div class="line"><a name="l06524"></a><span class="lineno"> 6524</span>&#160;&lt;xsd:double xsi:type=&quot;xsd:decimal&quot;&gt;...&lt;/xsd:double&gt;</div><div class="line"><a name="l06525"></a><span class="lineno"> 6525</span>&#160;```</div><div class="line"><a name="l06526"></a><span class="lineno"> 6526</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l06527"></a><span class="lineno"> 6527</span>&#160;</div><div class="line"><a name="l06528"></a><span class="lineno"> 6528</span>&#160;</div><div class="line"><a name="l06529"></a><span class="lineno"> 6529</span>&#160;* *`xsd:double`*</div><div class="line"><a name="l06530"></a><span class="lineno"> 6530</span>&#160;Corresponds to the IEEE double-precision 64-bit floating point type. The type declaration is:</div><div class="line"><a name="l06531"></a><span class="lineno"> 6531</span>&#160;</div><div class="line"><a name="l06532"></a><span class="lineno"> 6532</span>&#160;```cpp</div><div class="line"><a name="l06533"></a><span class="lineno"> 6533</span>&#160;typedef double xsd__double;</div><div class="line"><a name="l06534"></a><span class="lineno"> 6534</span>&#160;```</div><div class="line"><a name="l06535"></a><span class="lineno"> 6535</span>&#160;</div><div class="line"><a name="l06536"></a><span class="lineno"> 6536</span>&#160;Type `xsd__double` declares a double floating point number which is encoded as </div><div class="line"><a name="l06537"></a><span class="lineno"> 6537</span>&#160;</div><div class="line"><a name="l06538"></a><span class="lineno"> 6538</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l06539"></a><span class="lineno"> 6539</span>&#160;```xml</div><div class="line"><a name="l06540"></a><span class="lineno"> 6540</span>&#160;&lt;xsd:double xsi:type=&quot;xsd:double&quot;&gt;...&lt;/xsd:double&gt;</div><div class="line"><a name="l06541"></a><span class="lineno"> 6541</span>&#160;```</div><div class="line"><a name="l06542"></a><span class="lineno"> 6542</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l06543"></a><span class="lineno"> 6543</span>&#160;</div><div class="line"><a name="l06544"></a><span class="lineno"> 6544</span>&#160;</div><div class="line"><a name="l06545"></a><span class="lineno"> 6545</span>&#160;* *`xsd:duration`*</div><div class="line"><a name="l06546"></a><span class="lineno"> 6546</span>&#160;Represents a duration of time.</div><div class="line"><a name="l06547"></a><span class="lineno"> 6547</span>&#160;The lexical representation for duration is the ISO 8601 extended format PnYn MnDTnH nMnS, where nY represents</div><div class="line"><a name="l06548"></a><span class="lineno"> 6548</span>&#160;the number of years, nM the number of months, nD the number of days, T is the date/time separator, nH the number of</div><div class="line"><a name="l06549"></a><span class="lineno"> 6549</span>&#160;hours, nM the number of minutes and nS the number of seconds. The number of seconds can include decimal digits to</div><div class="line"><a name="l06550"></a><span class="lineno"> 6550</span>&#160;arbitrary precision.</div><div class="line"><a name="l06551"></a><span class="lineno"> 6551</span>&#160;It is recommended to use strings (`char*`) to store *`xsd:duration`* XSD Schema types. The type declaration is:</div><div class="line"><a name="l06552"></a><span class="lineno"> 6552</span>&#160;</div><div class="line"><a name="l06553"></a><span class="lineno"> 6553</span>&#160;```cpp</div><div class="line"><a name="l06554"></a><span class="lineno"> 6554</span>&#160;typedef char *xsd__duration;</div><div class="line"><a name="l06555"></a><span class="lineno"> 6555</span>&#160;```</div><div class="line"><a name="l06556"></a><span class="lineno"> 6556</span>&#160;</div><div class="line"><a name="l06557"></a><span class="lineno"> 6557</span>&#160;</div><div class="line"><a name="l06558"></a><span class="lineno"> 6558</span>&#160;* *`xsd:float`*</div><div class="line"><a name="l06559"></a><span class="lineno"> 6559</span>&#160;Corresponds to the IEEE single-precision 32-bit floating point type. The type declaration is:</div><div class="line"><a name="l06560"></a><span class="lineno"> 6560</span>&#160;</div><div class="line"><a name="l06561"></a><span class="lineno"> 6561</span>&#160;```cpp</div><div class="line"><a name="l06562"></a><span class="lineno"> 6562</span>&#160;typedef float xsd__float;</div><div class="line"><a name="l06563"></a><span class="lineno"> 6563</span>&#160;```</div><div class="line"><a name="l06564"></a><span class="lineno"> 6564</span>&#160;</div><div class="line"><a name="l06565"></a><span class="lineno"> 6565</span>&#160;Type `xsd__float` declares a floating point number which is encoded as </div><div class="line"><a name="l06566"></a><span class="lineno"> 6566</span>&#160;</div><div class="line"><a name="l06567"></a><span class="lineno"> 6567</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l06568"></a><span class="lineno"> 6568</span>&#160;```xml</div><div class="line"><a name="l06569"></a><span class="lineno"> 6569</span>&#160;&lt;xsd:float xsi:type=&quot;xsd:float&quot;&gt;...&lt;/xsd:float&gt;</div><div class="line"><a name="l06570"></a><span class="lineno"> 6570</span>&#160;```</div><div class="line"><a name="l06571"></a><span class="lineno"> 6571</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l06572"></a><span class="lineno"> 6572</span>&#160;</div><div class="line"><a name="l06573"></a><span class="lineno"> 6573</span>&#160;</div><div class="line"><a name="l06574"></a><span class="lineno"> 6574</span>&#160;* *`xsd:hexBinary`*</div><div class="line"><a name="l06575"></a><span class="lineno"> 6575</span>&#160;Represents arbitrary hex-encoded binary data.  It has a lexical representation where each binary octet is encoded as a character</div><div class="line"><a name="l06576"></a><span class="lineno"> 6576</span>&#160;tuple, consisting of two hexadecimal digits ([0-9a-fA-F]) representing the octet code. For example, &quot;0FB7&quot; is a hex encoding for</div><div class="line"><a name="l06577"></a><span class="lineno"> 6577</span>&#160;the 16-bit integer 4023 (binary representation is 111110110111.</div><div class="line"><a name="l06578"></a><span class="lineno"> 6578</span>&#160;For using the *`xsd:hexBinary`* XSD Schema type, the use of the hexBinary representation of a dynamic array is **strongly** recommended,</div><div class="line"><a name="l06579"></a><span class="lineno"> 6579</span>&#160;see Section \ref hexbinary . However, the</div><div class="line"><a name="l06580"></a><span class="lineno"> 6580</span>&#160;type can also be declared as a string and the encoding will be string-based:</div><div class="line"><a name="l06581"></a><span class="lineno"> 6581</span>&#160;</div><div class="line"><a name="l06582"></a><span class="lineno"> 6582</span>&#160;```cpp</div><div class="line"><a name="l06583"></a><span class="lineno"> 6583</span>&#160;typedef char *xsd__hexBinary;</div><div class="line"><a name="l06584"></a><span class="lineno"> 6584</span>&#160;```</div><div class="line"><a name="l06585"></a><span class="lineno"> 6585</span>&#160;</div><div class="line"><a name="l06586"></a><span class="lineno"> 6586</span>&#160;With this approach, it is solely the responsibility of the application to make sure the string content consists of a sequence of octets.</div><div class="line"><a name="l06587"></a><span class="lineno"> 6587</span>&#160;</div><div class="line"><a name="l06588"></a><span class="lineno"> 6588</span>&#160;</div><div class="line"><a name="l06589"></a><span class="lineno"> 6589</span>&#160;* *`xsd:int`*</div><div class="line"><a name="l06590"></a><span class="lineno"> 6590</span>&#160;Corresponds to a 32-bit integer in the range -2147483648 to 2147483647.</div><div class="line"><a name="l06591"></a><span class="lineno"> 6591</span>&#160;</div><div class="line"><a name="l06592"></a><span class="lineno"> 6592</span>&#160;```cpp</div><div class="line"><a name="l06593"></a><span class="lineno"> 6593</span>&#160;typedef int xsd__int;</div><div class="line"><a name="l06594"></a><span class="lineno"> 6594</span>&#160;```</div><div class="line"><a name="l06595"></a><span class="lineno"> 6595</span>&#160;</div><div class="line"><a name="l06596"></a><span class="lineno"> 6596</span>&#160;Type `xsd__int` declares a 32-bit integer which is encoded as </div><div class="line"><a name="l06597"></a><span class="lineno"> 6597</span>&#160;</div><div class="line"><a name="l06598"></a><span class="lineno"> 6598</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l06599"></a><span class="lineno"> 6599</span>&#160;```xml</div><div class="line"><a name="l06600"></a><span class="lineno"> 6600</span>&#160;&lt;xsd:int xsi:type=&quot;xsd:int&quot;&gt;...&lt;/xsd:int&gt;</div><div class="line"><a name="l06601"></a><span class="lineno"> 6601</span>&#160;```</div><div class="line"><a name="l06602"></a><span class="lineno"> 6602</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l06603"></a><span class="lineno"> 6603</span>&#160;</div><div class="line"><a name="l06604"></a><span class="lineno"> 6604</span>&#160;</div><div class="line"><a name="l06605"></a><span class="lineno"> 6605</span>&#160;* *`xsd:integer`*</div><div class="line"><a name="l06606"></a><span class="lineno"> 6606</span>&#160;Corresponds to an unbounded integer.</div><div class="line"><a name="l06607"></a><span class="lineno"> 6607</span>&#160;Since C++ does not support unbounded integers as a standard feature, the recommended type declaration is:</div><div class="line"><a name="l06608"></a><span class="lineno"> 6608</span>&#160;</div><div class="line"><a name="l06609"></a><span class="lineno"> 6609</span>&#160;```cpp</div><div class="line"><a name="l06610"></a><span class="lineno"> 6610</span>&#160;typedef long long xsd__integer;</div><div class="line"><a name="l06611"></a><span class="lineno"> 6611</span>&#160;```</div><div class="line"><a name="l06612"></a><span class="lineno"> 6612</span>&#160;</div><div class="line"><a name="l06613"></a><span class="lineno"> 6613</span>&#160;Type `xsd__integer` declares a 64-bit integer which is encoded as an unbounded *`xsd:integer`*:</div><div class="line"><a name="l06614"></a><span class="lineno"> 6614</span>&#160;</div><div class="line"><a name="l06615"></a><span class="lineno"> 6615</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l06616"></a><span class="lineno"> 6616</span>&#160;```xml</div><div class="line"><a name="l06617"></a><span class="lineno"> 6617</span>&#160;&lt;xsd:integer xsi:type=&quot;xsd:integer&quot;&gt;...&lt;/xsd:integer&gt;</div><div class="line"><a name="l06618"></a><span class="lineno"> 6618</span>&#160;```</div><div class="line"><a name="l06619"></a><span class="lineno"> 6619</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l06620"></a><span class="lineno"> 6620</span>&#160;</div><div class="line"><a name="l06621"></a><span class="lineno"> 6621</span>&#160;Another possibility is to use strings to represent unbounded integers and do the translation in code.</div><div class="line"><a name="l06622"></a><span class="lineno"> 6622</span>&#160;</div><div class="line"><a name="l06623"></a><span class="lineno"> 6623</span>&#160;</div><div class="line"><a name="l06624"></a><span class="lineno"> 6624</span>&#160;* *`xsd:long`*</div><div class="line"><a name="l06625"></a><span class="lineno"> 6625</span>&#160;Corresponds to a 64-bit integer in the range -9223372036854775808 to 9223372036854775807.</div><div class="line"><a name="l06626"></a><span class="lineno"> 6626</span>&#160;The type declaration is:</div><div class="line"><a name="l06627"></a><span class="lineno"> 6627</span>&#160;</div><div class="line"><a name="l06628"></a><span class="lineno"> 6628</span>&#160;```cpp</div><div class="line"><a name="l06629"></a><span class="lineno"> 6629</span>&#160;typedef long long xsd__long;</div><div class="line"><a name="l06630"></a><span class="lineno"> 6630</span>&#160;```</div><div class="line"><a name="l06631"></a><span class="lineno"> 6631</span>&#160;</div><div class="line"><a name="l06632"></a><span class="lineno"> 6632</span>&#160;Or</div><div class="line"><a name="l06633"></a><span class="lineno"> 6633</span>&#160;</div><div class="line"><a name="l06634"></a><span class="lineno"> 6634</span>&#160;```cpp</div><div class="line"><a name="l06635"></a><span class="lineno"> 6635</span>&#160;typedef LONG64 xsd__long;</div><div class="line"><a name="l06636"></a><span class="lineno"> 6636</span>&#160;```</div><div class="line"><a name="l06637"></a><span class="lineno"> 6637</span>&#160;</div><div class="line"><a name="l06638"></a><span class="lineno"> 6638</span>&#160;Or</div><div class="line"><a name="l06639"></a><span class="lineno"> 6639</span>&#160;</div><div class="line"><a name="l06640"></a><span class="lineno"> 6640</span>&#160;```cpp</div><div class="line"><a name="l06641"></a><span class="lineno"> 6641</span>&#160;typedef int64_t xsd__long;</div><div class="line"><a name="l06642"></a><span class="lineno"> 6642</span>&#160;```</div><div class="line"><a name="l06643"></a><span class="lineno"> 6643</span>&#160;</div><div class="line"><a name="l06644"></a><span class="lineno"> 6644</span>&#160;Type `xsd__long` declares a 64-bit integer which is encoded as </div><div class="line"><a name="l06645"></a><span class="lineno"> 6645</span>&#160;</div><div class="line"><a name="l06646"></a><span class="lineno"> 6646</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l06647"></a><span class="lineno"> 6647</span>&#160;```xml</div><div class="line"><a name="l06648"></a><span class="lineno"> 6648</span>&#160;&lt;xsd:long xsi:type=&quot;xsd:long&quot;&gt;...&lt;/xsd:long&gt;</div><div class="line"><a name="l06649"></a><span class="lineno"> 6649</span>&#160;```</div><div class="line"><a name="l06650"></a><span class="lineno"> 6650</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l06651"></a><span class="lineno"> 6651</span>&#160;</div><div class="line"><a name="l06652"></a><span class="lineno"> 6652</span>&#160;</div><div class="line"><a name="l06653"></a><span class="lineno"> 6653</span>&#160;* *`xsd:negativeInteger`*</div><div class="line"><a name="l06654"></a><span class="lineno"> 6654</span>&#160;Corresponds to a negative unbounded integer (&lt;0).</div><div class="line"><a name="l06655"></a><span class="lineno"> 6655</span>&#160;Since C++ does not support unbounded integers as a standard feature, the recommended type declaration is:</div><div class="line"><a name="l06656"></a><span class="lineno"> 6656</span>&#160;</div><div class="line"><a name="l06657"></a><span class="lineno"> 6657</span>&#160;```cpp</div><div class="line"><a name="l06658"></a><span class="lineno"> 6658</span>&#160;typedef long long xsd__negativeInteger;</div><div class="line"><a name="l06659"></a><span class="lineno"> 6659</span>&#160;```</div><div class="line"><a name="l06660"></a><span class="lineno"> 6660</span>&#160;</div><div class="line"><a name="l06661"></a><span class="lineno"> 6661</span>&#160;Type `xsd__negativeInteger` declares a 64-bit integer which is encoded as a *`xsd:negativeInteger`*:</div><div class="line"><a name="l06662"></a><span class="lineno"> 6662</span>&#160;</div><div class="line"><a name="l06663"></a><span class="lineno"> 6663</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l06664"></a><span class="lineno"> 6664</span>&#160;```xml</div><div class="line"><a name="l06665"></a><span class="lineno"> 6665</span>&#160;&lt;xsd:negativeInteger xsi:type=&quot;xsd:negativeInteger&quot;&gt;...&lt;/xsd:negativeInteger&gt;</div><div class="line"><a name="l06666"></a><span class="lineno"> 6666</span>&#160;```</div><div class="line"><a name="l06667"></a><span class="lineno"> 6667</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l06668"></a><span class="lineno"> 6668</span>&#160;</div><div class="line"><a name="l06669"></a><span class="lineno"> 6669</span>&#160;Another possibility is to use strings to represent unbounded integers and do the translation in code.</div><div class="line"><a name="l06670"></a><span class="lineno"> 6670</span>&#160;</div><div class="line"><a name="l06671"></a><span class="lineno"> 6671</span>&#160;</div><div class="line"><a name="l06672"></a><span class="lineno"> 6672</span>&#160;* *`xsd:nonNegativeInteger`*</div><div class="line"><a name="l06673"></a><span class="lineno"> 6673</span>&#160;Corresponds to a non-negative unbounded integer (&gt;0).</div><div class="line"><a name="l06674"></a><span class="lineno"> 6674</span>&#160;Since C++ does not support unbounded integers as a standard feature, the recommended type declaration is:</div><div class="line"><a name="l06675"></a><span class="lineno"> 6675</span>&#160;</div><div class="line"><a name="l06676"></a><span class="lineno"> 6676</span>&#160;```cpp</div><div class="line"><a name="l06677"></a><span class="lineno"> 6677</span>&#160;typedef unsigned long long xsd__nonNegativeInteger;</div><div class="line"><a name="l06678"></a><span class="lineno"> 6678</span>&#160;```</div><div class="line"><a name="l06679"></a><span class="lineno"> 6679</span>&#160;</div><div class="line"><a name="l06680"></a><span class="lineno"> 6680</span>&#160;Type `xsd__nonNegativeInteger` declares a 64-bit unsigned integer which is encoded as a non-negative unbounded *`xsd:nonNegativeInteger`*:</div><div class="line"><a name="l06681"></a><span class="lineno"> 6681</span>&#160;</div><div class="line"><a name="l06682"></a><span class="lineno"> 6682</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l06683"></a><span class="lineno"> 6683</span>&#160;```xml</div><div class="line"><a name="l06684"></a><span class="lineno"> 6684</span>&#160;&lt;xsd:nonNegativeInteger xsi:type=&quot;xsd:nonNegativeInteger&quot;&gt;...&lt;/xsd:nonNegativeInteger&gt;</div><div class="line"><a name="l06685"></a><span class="lineno"> 6685</span>&#160;```</div><div class="line"><a name="l06686"></a><span class="lineno"> 6686</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l06687"></a><span class="lineno"> 6687</span>&#160;</div><div class="line"><a name="l06688"></a><span class="lineno"> 6688</span>&#160;Another possibility is to use strings to represent unbounded integers and do the translation in code.</div><div class="line"><a name="l06689"></a><span class="lineno"> 6689</span>&#160;</div><div class="line"><a name="l06690"></a><span class="lineno"> 6690</span>&#160;</div><div class="line"><a name="l06691"></a><span class="lineno"> 6691</span>&#160;* *`xsd:nonPositiveInteger`*</div><div class="line"><a name="l06692"></a><span class="lineno"> 6692</span>&#160;Corresponds to a non-positive unbounded integer (&lt;=0).</div><div class="line"><a name="l06693"></a><span class="lineno"> 6693</span>&#160;Since C++ does not support unbounded integers as a standard feature, the recommended type declaration is:</div><div class="line"><a name="l06694"></a><span class="lineno"> 6694</span>&#160;</div><div class="line"><a name="l06695"></a><span class="lineno"> 6695</span>&#160;```cpp</div><div class="line"><a name="l06696"></a><span class="lineno"> 6696</span>&#160;typedef long long xsd__nonPositiveInteger;</div><div class="line"><a name="l06697"></a><span class="lineno"> 6697</span>&#160;```</div><div class="line"><a name="l06698"></a><span class="lineno"> 6698</span>&#160;</div><div class="line"><a name="l06699"></a><span class="lineno"> 6699</span>&#160;Type `xsd__nonPositiveInteger` declares a 64-bit integer which is encoded as a *`xsd:nonPositiveInteger`*:</div><div class="line"><a name="l06700"></a><span class="lineno"> 6700</span>&#160;</div><div class="line"><a name="l06701"></a><span class="lineno"> 6701</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l06702"></a><span class="lineno"> 6702</span>&#160;```xml</div><div class="line"><a name="l06703"></a><span class="lineno"> 6703</span>&#160;&lt;xsd:nonPositiveInteger xsi:type=&quot;xsd:nonPositiveInteger&quot;&gt;...&lt;/xsd:nonPositiveInteger&gt;</div><div class="line"><a name="l06704"></a><span class="lineno"> 6704</span>&#160;```</div><div class="line"><a name="l06705"></a><span class="lineno"> 6705</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l06706"></a><span class="lineno"> 6706</span>&#160;</div><div class="line"><a name="l06707"></a><span class="lineno"> 6707</span>&#160;Another possibility is to use strings to represent unbounded integers and do the translation in code.</div><div class="line"><a name="l06708"></a><span class="lineno"> 6708</span>&#160;</div><div class="line"><a name="l06709"></a><span class="lineno"> 6709</span>&#160;</div><div class="line"><a name="l06710"></a><span class="lineno"> 6710</span>&#160;* *`xsd:normalizedString`*</div><div class="line"><a name="l06711"></a><span class="lineno"> 6711</span>&#160;Represents normalized character strings.</div><div class="line"><a name="l06712"></a><span class="lineno"> 6712</span>&#160;Normalized character strings do not contain the carriage return (#xD), line feed (#xA) nor tab (#x9) characters.</div><div class="line"><a name="l06713"></a><span class="lineno"> 6713</span>&#160;It is recommended to use strings to store *`xsd:normalizeString`* XSD Schema types.</div><div class="line"><a name="l06714"></a><span class="lineno"> 6714</span>&#160;The type declaration is:</div><div class="line"><a name="l06715"></a><span class="lineno"> 6715</span>&#160;</div><div class="line"><a name="l06716"></a><span class="lineno"> 6716</span>&#160;```cpp</div><div class="line"><a name="l06717"></a><span class="lineno"> 6717</span>&#160;typedef char *xsd__normalizedString;</div><div class="line"><a name="l06718"></a><span class="lineno"> 6718</span>&#160;```</div><div class="line"><a name="l06719"></a><span class="lineno"> 6719</span>&#160;</div><div class="line"><a name="l06720"></a><span class="lineno"> 6720</span>&#160;Type `xsd__normalizedString` declares a string type which is encoded as </div><div class="line"><a name="l06721"></a><span class="lineno"> 6721</span>&#160;</div><div class="line"><a name="l06722"></a><span class="lineno"> 6722</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l06723"></a><span class="lineno"> 6723</span>&#160;```xml</div><div class="line"><a name="l06724"></a><span class="lineno"> 6724</span>&#160;&lt;xsd:normalizedString xsi:type=&quot;xsd:normalizedString&quot;&gt;...&lt;/xsd:normalizedString&gt;</div><div class="line"><a name="l06725"></a><span class="lineno"> 6725</span>&#160;```</div><div class="line"><a name="l06726"></a><span class="lineno"> 6726</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l06727"></a><span class="lineno"> 6727</span>&#160;</div><div class="line"><a name="l06728"></a><span class="lineno"> 6728</span>&#160;It is solely the responsibility of the application to make sure the strings do not contain carriage return (#xD), line feed (#xA)</div><div class="line"><a name="l06729"></a><span class="lineno"> 6729</span>&#160;and tab (#x9) characters.</div><div class="line"><a name="l06730"></a><span class="lineno"> 6730</span>&#160;</div><div class="line"><a name="l06731"></a><span class="lineno"> 6731</span>&#160;</div><div class="line"><a name="l06732"></a><span class="lineno"> 6732</span>&#160;* *`xsd:positiveInteger`*</div><div class="line"><a name="l06733"></a><span class="lineno"> 6733</span>&#160;Corresponds to a positive unbounded integer (&gt;=0).</div><div class="line"><a name="l06734"></a><span class="lineno"> 6734</span>&#160;Since C++ does not support unbounded integers as a standard feature, the recommended type declaration is:</div><div class="line"><a name="l06735"></a><span class="lineno"> 6735</span>&#160;</div><div class="line"><a name="l06736"></a><span class="lineno"> 6736</span>&#160;```cpp</div><div class="line"><a name="l06737"></a><span class="lineno"> 6737</span>&#160;typedef unsigned long long xsd__positiveInteger;</div><div class="line"><a name="l06738"></a><span class="lineno"> 6738</span>&#160;```</div><div class="line"><a name="l06739"></a><span class="lineno"> 6739</span>&#160;</div><div class="line"><a name="l06740"></a><span class="lineno"> 6740</span>&#160;Type `xsd__positiveInteger` declares a 64-bit unsigned integer which is encoded as a *`xsd:positiveInteger`*:</div><div class="line"><a name="l06741"></a><span class="lineno"> 6741</span>&#160;</div><div class="line"><a name="l06742"></a><span class="lineno"> 6742</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l06743"></a><span class="lineno"> 6743</span>&#160;```xml</div><div class="line"><a name="l06744"></a><span class="lineno"> 6744</span>&#160;&lt;xsd:positiveInteger xsi:type=&quot;xsd:positiveInteger&quot;&gt;...&lt;/xsd:positiveInteger&gt;</div><div class="line"><a name="l06745"></a><span class="lineno"> 6745</span>&#160;```</div><div class="line"><a name="l06746"></a><span class="lineno"> 6746</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l06747"></a><span class="lineno"> 6747</span>&#160;</div><div class="line"><a name="l06748"></a><span class="lineno"> 6748</span>&#160;Another possibility is to use strings to represent unbounded integers and do the translation in code.</div><div class="line"><a name="l06749"></a><span class="lineno"> 6749</span>&#160;</div><div class="line"><a name="l06750"></a><span class="lineno"> 6750</span>&#160;</div><div class="line"><a name="l06751"></a><span class="lineno"> 6751</span>&#160;* *`xsd:short`*</div><div class="line"><a name="l06752"></a><span class="lineno"> 6752</span>&#160;Corresponds to a 16-bit integer in the range -32768 to 32767.</div><div class="line"><a name="l06753"></a><span class="lineno"> 6753</span>&#160;The type declaration is:</div><div class="line"><a name="l06754"></a><span class="lineno"> 6754</span>&#160;</div><div class="line"><a name="l06755"></a><span class="lineno"> 6755</span>&#160;```cpp</div><div class="line"><a name="l06756"></a><span class="lineno"> 6756</span>&#160;typedef short xsd__short;</div><div class="line"><a name="l06757"></a><span class="lineno"> 6757</span>&#160;```</div><div class="line"><a name="l06758"></a><span class="lineno"> 6758</span>&#160;</div><div class="line"><a name="l06759"></a><span class="lineno"> 6759</span>&#160;Type `xsd__short` declares a short 16-bit integer which is encoded as </div><div class="line"><a name="l06760"></a><span class="lineno"> 6760</span>&#160;</div><div class="line"><a name="l06761"></a><span class="lineno"> 6761</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l06762"></a><span class="lineno"> 6762</span>&#160;```xml</div><div class="line"><a name="l06763"></a><span class="lineno"> 6763</span>&#160;&lt;xsd:short xsi:type=&quot;xsd:short&quot;&gt;...&lt;/xsd:short&gt;</div><div class="line"><a name="l06764"></a><span class="lineno"> 6764</span>&#160;```</div><div class="line"><a name="l06765"></a><span class="lineno"> 6765</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l06766"></a><span class="lineno"> 6766</span>&#160;</div><div class="line"><a name="l06767"></a><span class="lineno"> 6767</span>&#160;</div><div class="line"><a name="l06768"></a><span class="lineno"> 6768</span>&#160;* *`xsd:string`*</div><div class="line"><a name="l06769"></a><span class="lineno"> 6769</span>&#160;Represents character strings. The type declaration is:</div><div class="line"><a name="l06770"></a><span class="lineno"> 6770</span>&#160;</div><div class="line"><a name="l06771"></a><span class="lineno"> 6771</span>&#160;```cpp</div><div class="line"><a name="l06772"></a><span class="lineno"> 6772</span>&#160;typedef char *xsd__string;</div><div class="line"><a name="l06773"></a><span class="lineno"> 6773</span>&#160;```</div><div class="line"><a name="l06774"></a><span class="lineno"> 6774</span>&#160;</div><div class="line"><a name="l06775"></a><span class="lineno"> 6775</span>&#160;Type `xsd__string` declares a string type which is encoded as </div><div class="line"><a name="l06776"></a><span class="lineno"> 6776</span>&#160;</div><div class="line"><a name="l06777"></a><span class="lineno"> 6777</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l06778"></a><span class="lineno"> 6778</span>&#160;```xml</div><div class="line"><a name="l06779"></a><span class="lineno"> 6779</span>&#160;&lt;xsd:string xsi:type=&quot;xsd:string&quot;&gt;...&lt;/xsd:string&gt;</div><div class="line"><a name="l06780"></a><span class="lineno"> 6780</span>&#160;```</div><div class="line"><a name="l06781"></a><span class="lineno"> 6781</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l06782"></a><span class="lineno"> 6782</span>&#160;</div><div class="line"><a name="l06783"></a><span class="lineno"> 6783</span>&#160;The type declaration for wide character strings is:</div><div class="line"><a name="l06784"></a><span class="lineno"> 6784</span>&#160;</div><div class="line"><a name="l06785"></a><span class="lineno"> 6785</span>&#160;```cpp</div><div class="line"><a name="l06786"></a><span class="lineno"> 6786</span>&#160;typedef wchar_t *xsd__string;</div><div class="line"><a name="l06787"></a><span class="lineno"> 6787</span>&#160;```</div><div class="line"><a name="l06788"></a><span class="lineno"> 6788</span>&#160;</div><div class="line"><a name="l06789"></a><span class="lineno"> 6789</span>&#160;Both type of strings can be used at the same time, but requires one typedef name to be changed by appending an underscore which is</div><div class="line"><a name="l06790"></a><span class="lineno"> 6790</span>&#160;invisible in XML. For example:</div><div class="line"><a name="l06791"></a><span class="lineno"> 6791</span>&#160;</div><div class="line"><a name="l06792"></a><span class="lineno"> 6792</span>&#160;```cpp</div><div class="line"><a name="l06793"></a><span class="lineno"> 6793</span>&#160;typedef wchar_t *xsd__string_;</div><div class="line"><a name="l06794"></a><span class="lineno"> 6794</span>&#160;```</div><div class="line"><a name="l06795"></a><span class="lineno"> 6795</span>&#160;</div><div class="line"><a name="l06796"></a><span class="lineno"> 6796</span>&#160;</div><div class="line"><a name="l06797"></a><span class="lineno"> 6797</span>&#160;* *`xsd:time`*</div><div class="line"><a name="l06798"></a><span class="lineno"> 6798</span>&#160;Represents a time.  The lexical representation for time is the left truncated lexical representation for dateTime: hh:mm:ss.sss</div><div class="line"><a name="l06799"></a><span class="lineno"> 6799</span>&#160;with optional following time zone indicator.</div><div class="line"><a name="l06800"></a><span class="lineno"> 6800</span>&#160;It is recommended to use strings (`char*`) to store *`xsd:time`* XSD Schema types. The type declaration is:</div><div class="line"><a name="l06801"></a><span class="lineno"> 6801</span>&#160;</div><div class="line"><a name="l06802"></a><span class="lineno"> 6802</span>&#160;```cpp</div><div class="line"><a name="l06803"></a><span class="lineno"> 6803</span>&#160;typedef char *xsd__time;</div><div class="line"><a name="l06804"></a><span class="lineno"> 6804</span>&#160;```</div><div class="line"><a name="l06805"></a><span class="lineno"> 6805</span>&#160;</div><div class="line"><a name="l06806"></a><span class="lineno"> 6806</span>&#160;* *`xsd:token`*</div><div class="line"><a name="l06807"></a><span class="lineno"> 6807</span>&#160;Represents tokenized strings.</div><div class="line"><a name="l06808"></a><span class="lineno"> 6808</span>&#160;Tokens are strings that do not contain the</div><div class="line"><a name="l06809"></a><span class="lineno"> 6809</span>&#160;line feed (#xA) nor tab (#x9) characters, that have no leading or trailing spaces (#x20) and that have no internal</div><div class="line"><a name="l06810"></a><span class="lineno"> 6810</span>&#160;sequences of two or more spaces.</div><div class="line"><a name="l06811"></a><span class="lineno"> 6811</span>&#160;It is recommended to use strings to store *`xsd:token`* XSD Schema types.</div><div class="line"><a name="l06812"></a><span class="lineno"> 6812</span>&#160;The type declaration is:</div><div class="line"><a name="l06813"></a><span class="lineno"> 6813</span>&#160;</div><div class="line"><a name="l06814"></a><span class="lineno"> 6814</span>&#160;```cpp</div><div class="line"><a name="l06815"></a><span class="lineno"> 6815</span>&#160;typedef char *xsd__token;</div><div class="line"><a name="l06816"></a><span class="lineno"> 6816</span>&#160;```</div><div class="line"><a name="l06817"></a><span class="lineno"> 6817</span>&#160;</div><div class="line"><a name="l06818"></a><span class="lineno"> 6818</span>&#160;Type `xsd__token` declares a string type which is encoded as </div><div class="line"><a name="l06819"></a><span class="lineno"> 6819</span>&#160;</div><div class="line"><a name="l06820"></a><span class="lineno"> 6820</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l06821"></a><span class="lineno"> 6821</span>&#160;```xml</div><div class="line"><a name="l06822"></a><span class="lineno"> 6822</span>&#160;&lt;xsd:token xsi:type=&quot;xsd:token&quot;&gt;...&lt;/xsd:token&gt;</div><div class="line"><a name="l06823"></a><span class="lineno"> 6823</span>&#160;```</div><div class="line"><a name="l06824"></a><span class="lineno"> 6824</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l06825"></a><span class="lineno"> 6825</span>&#160;</div><div class="line"><a name="l06826"></a><span class="lineno"> 6826</span>&#160;It is solely the responsibility of the application to make sure the strings do not contain the line feed (#xA) nor tab (#x9)</div><div class="line"><a name="l06827"></a><span class="lineno"> 6827</span>&#160;characters, that have no leading or trailing spaces (#x20) and that have no internal sequences of two or more spaces.</div><div class="line"><a name="l06828"></a><span class="lineno"> 6828</span>&#160;</div><div class="line"><a name="l06829"></a><span class="lineno"> 6829</span>&#160;</div><div class="line"><a name="l06830"></a><span class="lineno"> 6830</span>&#160;* *`xsd:unsignedByte`*</div><div class="line"><a name="l06831"></a><span class="lineno"> 6831</span>&#160;Corresponds to an 8-bit unsigned integer in the range 0 to 255.</div><div class="line"><a name="l06832"></a><span class="lineno"> 6832</span>&#160;The type declaration is:</div><div class="line"><a name="l06833"></a><span class="lineno"> 6833</span>&#160;</div><div class="line"><a name="l06834"></a><span class="lineno"> 6834</span>&#160;```cpp</div><div class="line"><a name="l06835"></a><span class="lineno"> 6835</span>&#160;typedef unsigned char xsd__unsignedByte;</div><div class="line"><a name="l06836"></a><span class="lineno"> 6836</span>&#160;```</div><div class="line"><a name="l06837"></a><span class="lineno"> 6837</span>&#160;</div><div class="line"><a name="l06838"></a><span class="lineno"> 6838</span>&#160;Type `xsd__unsignedByte` declares a unsigned 8-bit integer which is encoded as </div><div class="line"><a name="l06839"></a><span class="lineno"> 6839</span>&#160;</div><div class="line"><a name="l06840"></a><span class="lineno"> 6840</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l06841"></a><span class="lineno"> 6841</span>&#160;```xml</div><div class="line"><a name="l06842"></a><span class="lineno"> 6842</span>&#160;&lt;xsd:unsignedByte xsi:type=&quot;xsd:unsignedByte&quot;&gt;...&lt;/xsd:unsignedByte&gt;</div><div class="line"><a name="l06843"></a><span class="lineno"> 6843</span>&#160;```</div><div class="line"><a name="l06844"></a><span class="lineno"> 6844</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l06845"></a><span class="lineno"> 6845</span>&#160;</div><div class="line"><a name="l06846"></a><span class="lineno"> 6846</span>&#160;</div><div class="line"><a name="l06847"></a><span class="lineno"> 6847</span>&#160;* *`xsd:unsignedInt`*</div><div class="line"><a name="l06848"></a><span class="lineno"> 6848</span>&#160;Corresponds to a 32-bit unsigned integer in the range 0 to 4294967295.</div><div class="line"><a name="l06849"></a><span class="lineno"> 6849</span>&#160;If the C++ compiler supports 32-bit `int` types, the type declaration can use the `int` type:</div><div class="line"><a name="l06850"></a><span class="lineno"> 6850</span>&#160;</div><div class="line"><a name="l06851"></a><span class="lineno"> 6851</span>&#160;```cpp</div><div class="line"><a name="l06852"></a><span class="lineno"> 6852</span>&#160;typedef unsigned int xsd__unsignedInt;</div><div class="line"><a name="l06853"></a><span class="lineno"> 6853</span>&#160;```</div><div class="line"><a name="l06854"></a><span class="lineno"> 6854</span>&#160;</div><div class="line"><a name="l06855"></a><span class="lineno"> 6855</span>&#160;Otherwise, the C++ compiler supports 16-bit `int` types and the type declaration should use the `long` type:</div><div class="line"><a name="l06856"></a><span class="lineno"> 6856</span>&#160;</div><div class="line"><a name="l06857"></a><span class="lineno"> 6857</span>&#160;```cpp</div><div class="line"><a name="l06858"></a><span class="lineno"> 6858</span>&#160;typedef unsigned long xsd__unsignedInt;</div><div class="line"><a name="l06859"></a><span class="lineno"> 6859</span>&#160;```</div><div class="line"><a name="l06860"></a><span class="lineno"> 6860</span>&#160;</div><div class="line"><a name="l06861"></a><span class="lineno"> 6861</span>&#160;Type `xsd__unsignedInt` declares an unsigned 32-bit integer which is encoded as </div><div class="line"><a name="l06862"></a><span class="lineno"> 6862</span>&#160;</div><div class="line"><a name="l06863"></a><span class="lineno"> 6863</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l06864"></a><span class="lineno"> 6864</span>&#160;```xml</div><div class="line"><a name="l06865"></a><span class="lineno"> 6865</span>&#160;&lt;xsd:unsignedInt xsi:type=&quot;xsd:unsignedInt&quot;&gt;...&lt;/xsd:unsignedInt&gt;</div><div class="line"><a name="l06866"></a><span class="lineno"> 6866</span>&#160;```</div><div class="line"><a name="l06867"></a><span class="lineno"> 6867</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l06868"></a><span class="lineno"> 6868</span>&#160;</div><div class="line"><a name="l06869"></a><span class="lineno"> 6869</span>&#160;</div><div class="line"><a name="l06870"></a><span class="lineno"> 6870</span>&#160;* *`xsd:unsignedLong`*</div><div class="line"><a name="l06871"></a><span class="lineno"> 6871</span>&#160;Corresponds to a 64-bit unsigned integer in the range 0 to 18446744073709551615.</div><div class="line"><a name="l06872"></a><span class="lineno"> 6872</span>&#160;The type declaration is:</div><div class="line"><a name="l06873"></a><span class="lineno"> 6873</span>&#160;</div><div class="line"><a name="l06874"></a><span class="lineno"> 6874</span>&#160;```cpp</div><div class="line"><a name="l06875"></a><span class="lineno"> 6875</span>&#160;typedef unsigned long long xsd__unsignedLong;</div><div class="line"><a name="l06876"></a><span class="lineno"> 6876</span>&#160;```</div><div class="line"><a name="l06877"></a><span class="lineno"> 6877</span>&#160;</div><div class="line"><a name="l06878"></a><span class="lineno"> 6878</span>&#160;Or in Visual C++:</div><div class="line"><a name="l06879"></a><span class="lineno"> 6879</span>&#160;</div><div class="line"><a name="l06880"></a><span class="lineno"> 6880</span>&#160;```cpp</div><div class="line"><a name="l06881"></a><span class="lineno"> 6881</span>&#160;typedef ULONG64 xsd__unsignedLong;</div><div class="line"><a name="l06882"></a><span class="lineno"> 6882</span>&#160;```</div><div class="line"><a name="l06883"></a><span class="lineno"> 6883</span>&#160;</div><div class="line"><a name="l06884"></a><span class="lineno"> 6884</span>&#160;Type `xsd__unsignedLong` declares an unsigned 64-bit integer which is encoded as </div><div class="line"><a name="l06885"></a><span class="lineno"> 6885</span>&#160;</div><div class="line"><a name="l06886"></a><span class="lineno"> 6886</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l06887"></a><span class="lineno"> 6887</span>&#160;```xml</div><div class="line"><a name="l06888"></a><span class="lineno"> 6888</span>&#160;&lt;xsd:unsignedLong xsi:type=&quot;xsd:unsignedLong&quot;&gt;...&lt;/xsd:unsignedLong&gt;</div><div class="line"><a name="l06889"></a><span class="lineno"> 6889</span>&#160;```</div><div class="line"><a name="l06890"></a><span class="lineno"> 6890</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l06891"></a><span class="lineno"> 6891</span>&#160;</div><div class="line"><a name="l06892"></a><span class="lineno"> 6892</span>&#160;</div><div class="line"><a name="l06893"></a><span class="lineno"> 6893</span>&#160;* *`xsd:unsignedShort`*</div><div class="line"><a name="l06894"></a><span class="lineno"> 6894</span>&#160;Corresponds to a 16-bit unsigned integer in the range 0 to 65535.</div><div class="line"><a name="l06895"></a><span class="lineno"> 6895</span>&#160;The type declaration is:</div><div class="line"><a name="l06896"></a><span class="lineno"> 6896</span>&#160;</div><div class="line"><a name="l06897"></a><span class="lineno"> 6897</span>&#160;```cpp</div><div class="line"><a name="l06898"></a><span class="lineno"> 6898</span>&#160;typedef unsigned short xsd__unsignedShort;</div><div class="line"><a name="l06899"></a><span class="lineno"> 6899</span>&#160;```</div><div class="line"><a name="l06900"></a><span class="lineno"> 6900</span>&#160;</div><div class="line"><a name="l06901"></a><span class="lineno"> 6901</span>&#160;Type `xsd__unsginedShort` declares an unsigned short 16-bit integer which is encoded as </div><div class="line"><a name="l06902"></a><span class="lineno"> 6902</span>&#160;</div><div class="line"><a name="l06903"></a><span class="lineno"> 6903</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l06904"></a><span class="lineno"> 6904</span>&#160;```xml</div><div class="line"><a name="l06905"></a><span class="lineno"> 6905</span>&#160;&lt;xsd:unsignedShort xsi:type=&quot;xsd:unsignedShort&quot;&gt;...&lt;/xsd:unsignedShort&gt;</div><div class="line"><a name="l06906"></a><span class="lineno"> 6906</span>&#160;```</div><div class="line"><a name="l06907"></a><span class="lineno"> 6907</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l06908"></a><span class="lineno"> 6908</span>&#160;</div><div class="line"><a name="l06909"></a><span class="lineno"> 6909</span>&#160;Other XSD Schema types such as *`gYearMonth`*, *`gYear`*, *`gMonthDay`*, *`gDay`*, *`xsd:gMonth`*, *`QName`*,</div><div class="line"><a name="l06910"></a><span class="lineno"> 6910</span>&#160;*`NOTATION`*, etc., can be encoded similarly using a `typedef` declaration.</div><div class="line"><a name="l06911"></a><span class="lineno"> 6911</span>&#160;</div><div class="line"><a name="l06912"></a><span class="lineno"> 6912</span>&#160;### How to Use Multiple C/C++ Types for a Single Primitive XSD Type</div><div class="line"><a name="l06913"></a><span class="lineno"> 6913</span>&#160;</div><div class="line"><a name="l06914"></a><span class="lineno"> 6914</span>&#160;Trailing underscores (see Section \ref idtrans ) can be used in the type</div><div class="line"><a name="l06915"></a><span class="lineno"> 6915</span>&#160;name in a `typedef` to enable the declaration of multiple storage formats</div><div class="line"><a name="l06916"></a><span class="lineno"> 6916</span>&#160;for a single XML Schema type. For example, one part of a C/C++ application&#39;s</div><div class="line"><a name="l06917"></a><span class="lineno"> 6917</span>&#160;data structure may use plain strings while another part may use wide character</div><div class="line"><a name="l06918"></a><span class="lineno"> 6918</span>&#160;strings.  To enable this simultaneous use, declare:</div><div class="line"><a name="l06919"></a><span class="lineno"> 6919</span>&#160;</div><div class="line"><a name="l06920"></a><span class="lineno"> 6920</span>&#160;```cpp</div><div class="line"><a name="l06921"></a><span class="lineno"> 6921</span>&#160;typedef char *xsd__string; </div><div class="line"><a name="l06922"></a><span class="lineno"> 6922</span>&#160;typedef wchar_t *xsd__string_;</div><div class="line"><a name="l06923"></a><span class="lineno"> 6923</span>&#160;```</div><div class="line"><a name="l06924"></a><span class="lineno"> 6924</span>&#160;</div><div class="line"><a name="l06925"></a><span class="lineno"> 6925</span>&#160;Now, the `xsd__string` and `xsd__string_` types will both be encoded</div><div class="line"><a name="l06926"></a><span class="lineno"> 6926</span>&#160;and decoded as XML string types and the use of trailing underscores allows</div><div class="line"><a name="l06927"></a><span class="lineno"> 6927</span>&#160;multiple declarations for a single XML Schema type.</div><div class="line"><a name="l06928"></a><span class="lineno"> 6928</span>&#160;</div><div class="line"><a name="l06929"></a><span class="lineno"> 6929</span>&#160;### How to use C++ Wrapper Classes to Specify Polymorphic Primitive Types        {#primclass}</div><div class="line"><a name="l06930"></a><span class="lineno"> 6930</span>&#160;</div><div class="line"><a name="l06931"></a><span class="lineno"> 6931</span>&#160;SOAP 1.1 supports polymorphic types, because XSD Schema types form a hierarchy.</div><div class="line"><a name="l06932"></a><span class="lineno"> 6932</span>&#160;The root of the hierarchy is called *`xsd:anyType`* (*`xsd:ur-type`* in the</div><div class="line"><a name="l06933"></a><span class="lineno"> 6933</span>&#160;older 1999 schema).  So, for example, an array of *`xsd:anyType`* in SOAP may</div><div class="line"><a name="l06934"></a><span class="lineno"> 6934</span>&#160;actually contain any mix of element types that are the derived types of the</div><div class="line"><a name="l06935"></a><span class="lineno"> 6935</span>&#160;root type.  The use of polymorphic types is indicated by the WSDL and schema</div><div class="line"><a name="l06936"></a><span class="lineno"> 6936</span>&#160;descriptions of a Web service and can therefore be predicted/expected for each</div><div class="line"><a name="l06937"></a><span class="lineno"> 6937</span>&#160;particular case.</div><div class="line"><a name="l06938"></a><span class="lineno"> 6938</span>&#160;</div><div class="line"><a name="l06939"></a><span class="lineno"> 6939</span>&#160;On the one hand, the `typedef` construct provides a convenient way to</div><div class="line"><a name="l06940"></a><span class="lineno"> 6940</span>&#160;associate C/C++ types with XML Schema types and makes it easy to incorporate</div><div class="line"><a name="l06941"></a><span class="lineno"> 6941</span>&#160;these types in a (legacy) C/C++ application.  However, on the other hand the</div><div class="line"><a name="l06942"></a><span class="lineno"> 6942</span>&#160;`typedef` declarations cannot be used to support polymorphic XML Schema</div><div class="line"><a name="l06943"></a><span class="lineno"> 6943</span>&#160;types.  Most SOAP clients and services do not use polymorphic types.  In case</div><div class="line"><a name="l06944"></a><span class="lineno"> 6944</span>&#160;they do, the primitive polymorphic types can be declared as a hierarchy of C++</div><div class="line"><a name="l06945"></a><span class="lineno"> 6945</span>&#160;`class`es that can be used simultaneously with the `typedef`</div><div class="line"><a name="l06946"></a><span class="lineno"> 6946</span>&#160;declarations.</div><div class="line"><a name="l06947"></a><span class="lineno"> 6947</span>&#160;</div><div class="line"><a name="l06948"></a><span class="lineno"> 6948</span>&#160;The general form of a primitive type declaration that is derived from a super type is:</div><div class="line"><a name="l06949"></a><span class="lineno"> 6949</span>&#160;</div><div class="line"><a name="l06950"></a><span class="lineno"> 6950</span>&#160;```cpp</div><div class="line"><a name="l06951"></a><span class="lineno"> 6951</span>&#160;class xsd__type_name: [optional: public xsd__super_type_name] </div><div class="line"><a name="l06952"></a><span class="lineno"> 6952</span>&#160;{ public: Type __item; </div><div class="line"><a name="l06953"></a><span class="lineno"> 6953</span>&#160;   [optional: public:] [optional: private] [optional: protected:] </div><div class="line"><a name="l06954"></a><span class="lineno"> 6954</span>&#160;   method1; </div><div class="line"><a name="l06955"></a><span class="lineno"> 6955</span>&#160;   method2; </div><div class="line"><a name="l06956"></a><span class="lineno"> 6956</span>&#160;   ... </div><div class="line"><a name="l06957"></a><span class="lineno"> 6957</span>&#160;};</div><div class="line"><a name="l06958"></a><span class="lineno"> 6958</span>&#160;```</div><div class="line"><a name="l06959"></a><span class="lineno"> 6959</span>&#160;</div><div class="line"><a name="l06960"></a><span class="lineno"> 6960</span>&#160;where Type is a primitive C type. The `__item` field MUST be the first</div><div class="line"><a name="l06961"></a><span class="lineno"> 6961</span>&#160;field in this wrapper class.</div><div class="line"><a name="l06962"></a><span class="lineno"> 6962</span>&#160;</div><div class="line"><a name="l06963"></a><span class="lineno"> 6963</span>&#160;For example, the XML Schema type hierarchy can be copied to C++ with the following declarations:</div><div class="line"><a name="l06964"></a><span class="lineno"> 6964</span>&#160;</div><div class="line"><a name="l06965"></a><span class="lineno"> 6965</span>&#160;```cpp</div><div class="line"><a name="l06966"></a><span class="lineno"> 6966</span>&#160;class xsd__anyType { }; </div><div class="line"><a name="l06967"></a><span class="lineno"> 6967</span>&#160;class xsd__anySimpleType: public xsd__anyType { }; </div><div class="line"><a name="l06968"></a><span class="lineno"> 6968</span>&#160;typedef char *xsd__anyURI; </div><div class="line"><a name="l06969"></a><span class="lineno"> 6969</span>&#160;class xsd__anyURI_: public xsd__anySimpleType { public: xsd__anyURI __item; }; </div><div class="line"><a name="l06970"></a><span class="lineno"> 6970</span>&#160;typedef bool xsd__boolean; </div><div class="line"><a name="l06971"></a><span class="lineno"> 6971</span>&#160;class xsd__boolean_: public xsd__anySimpleType { public: xsd__boolean __item; }; </div><div class="line"><a name="l06972"></a><span class="lineno"> 6972</span>&#160;typedef char *xsd__date; </div><div class="line"><a name="l06973"></a><span class="lineno"> 6973</span>&#160;class xsd__date_: public xsd__anySimpleType { public: xsd__date __item; }; </div><div class="line"><a name="l06974"></a><span class="lineno"> 6974</span>&#160;typedef time_t xsd__dateTime; </div><div class="line"><a name="l06975"></a><span class="lineno"> 6975</span>&#160;class xsd__dateTime_: public xsd__anySimpleType { public: xsd__dateTime __item; }; </div><div class="line"><a name="l06976"></a><span class="lineno"> 6976</span>&#160;typedef double xsd__double; </div><div class="line"><a name="l06977"></a><span class="lineno"> 6977</span>&#160;class xsd__double_: public xsd__anySimpleType { public: xsd__double __item; }; </div><div class="line"><a name="l06978"></a><span class="lineno"> 6978</span>&#160;typedef char *xsd__duration; </div><div class="line"><a name="l06979"></a><span class="lineno"> 6979</span>&#160;class xsd__duration_: public xsd__anySimpleType { public: xsd__duration __item; }; </div><div class="line"><a name="l06980"></a><span class="lineno"> 6980</span>&#160;typedef float xsd__float; </div><div class="line"><a name="l06981"></a><span class="lineno"> 6981</span>&#160;class xsd__float_: public xsd__anySimpleType { public: xsd__float __item; }; </div><div class="line"><a name="l06982"></a><span class="lineno"> 6982</span>&#160;typedef char *xsd__time; </div><div class="line"><a name="l06983"></a><span class="lineno"> 6983</span>&#160;class xsd__time_: public xsd__anySimpleType { public: xsd__time __item; }; </div><div class="line"><a name="l06984"></a><span class="lineno"> 6984</span>&#160;typedef char *xsd__decimal; </div><div class="line"><a name="l06985"></a><span class="lineno"> 6985</span>&#160;class xsd__decimal_: public xsd__anySimpleType { public: xsd__decimal __item; }; </div><div class="line"><a name="l06986"></a><span class="lineno"> 6986</span>&#160;typedef char *xsd__integer; </div><div class="line"><a name="l06987"></a><span class="lineno"> 6987</span>&#160;class xsd__integer_: public xsd__decimal_ { public: xsd__integer __item; }; </div><div class="line"><a name="l06988"></a><span class="lineno"> 6988</span>&#160;typedef LONG64 xsd__long; </div><div class="line"><a name="l06989"></a><span class="lineno"> 6989</span>&#160;class xsd__long_: public xsd__integer_ { public: xsd__long __item; }; </div><div class="line"><a name="l06990"></a><span class="lineno"> 6990</span>&#160;typedef long xsd__int; </div><div class="line"><a name="l06991"></a><span class="lineno"> 6991</span>&#160;class xsd__int_: public xsd__long_ { public: xsd__int __item; }; </div><div class="line"><a name="l06992"></a><span class="lineno"> 6992</span>&#160;typedef short xsd__short; </div><div class="line"><a name="l06993"></a><span class="lineno"> 6993</span>&#160;class xsd__short_: public xsd__int_ { public: xsd__short __item; }; </div><div class="line"><a name="l06994"></a><span class="lineno"> 6994</span>&#160;typedef char xsd__byte; </div><div class="line"><a name="l06995"></a><span class="lineno"> 6995</span>&#160;class xsd__byte_: public xsd__short_ { public: xsd__byte __item; }; </div><div class="line"><a name="l06996"></a><span class="lineno"> 6996</span>&#160;typedef char *xsd__nonPositiveInteger; </div><div class="line"><a name="l06997"></a><span class="lineno"> 6997</span>&#160;class xsd__nonPositiveInteger_: public xsd__integer_ { public: xsd__nonPositiveInteger __item; }; </div><div class="line"><a name="l06998"></a><span class="lineno"> 6998</span>&#160;typedef char *xsd__negativeInteger; </div><div class="line"><a name="l06999"></a><span class="lineno"> 6999</span>&#160;class xsd__negativeInteger_: public xsd__nonPositiveInteger_ { public: xsd__negativeInteger __item; }; </div><div class="line"><a name="l07000"></a><span class="lineno"> 7000</span>&#160;typedef char *xsd__nonNegativeInteger; </div><div class="line"><a name="l07001"></a><span class="lineno"> 7001</span>&#160;class xsd__nonNegativeInteger_: public xsd__integer_ { public: xsd__nonNegativeInteger __item; }; </div><div class="line"><a name="l07002"></a><span class="lineno"> 7002</span>&#160;typedef char *xsd__positiveInteger; </div><div class="line"><a name="l07003"></a><span class="lineno"> 7003</span>&#160;class xsd__positiveInteger_: public xsd__nonNegativeInteger_ { public: xsd__positiveInteger __item; }; </div><div class="line"><a name="l07004"></a><span class="lineno"> 7004</span>&#160;typedef ULONG64 xsd__unsignedLong; </div><div class="line"><a name="l07005"></a><span class="lineno"> 7005</span>&#160;class xsd__unsignedLong_: public xsd__nonNegativeInteger_ { public: xsd__unsignedLong __item; }; </div><div class="line"><a name="l07006"></a><span class="lineno"> 7006</span>&#160;typedef unsigned long xsd__unsignedInt; </div><div class="line"><a name="l07007"></a><span class="lineno"> 7007</span>&#160;class xsd__unsignedInt_: public xsd__unsginedLong_ { public: xsd__unsignedInt __item; }; </div><div class="line"><a name="l07008"></a><span class="lineno"> 7008</span>&#160;typedef unsigned short xsd__unsignedShort; </div><div class="line"><a name="l07009"></a><span class="lineno"> 7009</span>&#160;class xsd__unsignedShort_: public xsd__unsignedInt_ { public: xsd__unsignedShort __item; }; </div><div class="line"><a name="l07010"></a><span class="lineno"> 7010</span>&#160;typedef unsigned char xsd__unsignedByte; </div><div class="line"><a name="l07011"></a><span class="lineno"> 7011</span>&#160;class xsd__unsignedByte_: public xsd__unsignedShort_ { public: xsd__unsignedByte __item; }; </div><div class="line"><a name="l07012"></a><span class="lineno"> 7012</span>&#160;typedef char *xsd__string; </div><div class="line"><a name="l07013"></a><span class="lineno"> 7013</span>&#160;class xsd__string_: public xsd__anySimpleType { public: xsd__string __item; }; </div><div class="line"><a name="l07014"></a><span class="lineno"> 7014</span>&#160;typedef char *xsd__normalizedString; </div><div class="line"><a name="l07015"></a><span class="lineno"> 7015</span>&#160;class xsd__normalizedString_: public xsd__string_ { public: xsd__normalizedString __item; }; </div><div class="line"><a name="l07016"></a><span class="lineno"> 7016</span>&#160;typedef char *xsd__token; </div><div class="line"><a name="l07017"></a><span class="lineno"> 7017</span>&#160;class xsd__token_: public xsd__normalizedString_ { public: xsd__token __item; }; </div><div class="line"><a name="l07018"></a><span class="lineno"> 7018</span>&#160;```</div><div class="line"><a name="l07019"></a><span class="lineno"> 7019</span>&#160;</div><div class="line"><a name="l07020"></a><span class="lineno"> 7020</span>&#160;Note the use of the trailing underscores for the `class` names to distinguish the `typedef` type names from the</div><div class="line"><a name="l07021"></a><span class="lineno"> 7021</span>&#160;`class` names.  Only the most frequently used built-in schema types are shown.</div><div class="line"><a name="l07022"></a><span class="lineno"> 7022</span>&#160;It is also allowed to include the `xsd:base64Binary` and `xsd:hexBinary` types in the hierarchy:</div><div class="line"><a name="l07023"></a><span class="lineno"> 7023</span>&#160;</div><div class="line"><a name="l07024"></a><span class="lineno"> 7024</span>&#160;```cpp</div><div class="line"><a name="l07025"></a><span class="lineno"> 7025</span>&#160;class xsd__base64Binary: public xsd__anySimpleType { public: unsigned char *__ptr; int __size; }; </div><div class="line"><a name="l07026"></a><span class="lineno"> 7026</span>&#160;class xsd__hexBinary: public xsd__anySimpleType { public: unsigned char *__ptr; int __size; };</div><div class="line"><a name="l07027"></a><span class="lineno"> 7027</span>&#160;```</div><div class="line"><a name="l07028"></a><span class="lineno"> 7028</span>&#160;</div><div class="line"><a name="l07029"></a><span class="lineno"> 7029</span>&#160;See Sections \ref base64binary  and \ref hexbinary .</div><div class="line"><a name="l07030"></a><span class="lineno"> 7030</span>&#160;</div><div class="line"><a name="l07031"></a><span class="lineno"> 7031</span>&#160;Methods are allowed to be added to the classes above, such as constructors and getter/setter methods, see Section \ref gettersetter .</div><div class="line"><a name="l07032"></a><span class="lineno"> 7032</span>&#160;</div><div class="line"><a name="l07033"></a><span class="lineno"> 7033</span>&#160;Wrapper structs are supported as well, similar to wrapper classes.  But they cannot be used</div><div class="line"><a name="l07034"></a><span class="lineno"> 7034</span>&#160;to implement polymorphism.  Rather, the wrapper structs facilitate the use of XML attributes</div><div class="line"><a name="l07035"></a><span class="lineno"> 7035</span>&#160;with a primitive typed object, see \ref attributes .</div><div class="line"><a name="l07036"></a><span class="lineno"> 7036</span>&#160;</div><div class="line"><a name="l07037"></a><span class="lineno"> 7037</span>&#160;### Multi-Reference Strings</div><div class="line"><a name="l07038"></a><span class="lineno"> 7038</span>&#160;</div><div class="line"><a name="l07039"></a><span class="lineno"> 7039</span>&#160;If more than one `char` pointer points to the same string, the string is encoded as a multi-reference value.</div><div class="line"><a name="l07040"></a><span class="lineno"> 7040</span>&#160;Consider for example</div><div class="line"><a name="l07041"></a><span class="lineno"> 7041</span>&#160;</div><div class="line"><a name="l07042"></a><span class="lineno"> 7042</span>&#160;```cpp</div><div class="line"><a name="l07043"></a><span class="lineno"> 7043</span>&#160;char *s = &quot;hello&quot;, *t = s;</div><div class="line"><a name="l07044"></a><span class="lineno"> 7044</span>&#160;```</div><div class="line"><a name="l07045"></a><span class="lineno"> 7045</span>&#160;</div><div class="line"><a name="l07046"></a><span class="lineno"> 7046</span>&#160;The `s` and `t` variables are assigned the same string, and when serialized, `t` refers to the content of `s`:</div><div class="line"><a name="l07047"></a><span class="lineno"> 7047</span>&#160;</div><div class="line"><a name="l07048"></a><span class="lineno"> 7048</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l07049"></a><span class="lineno"> 7049</span>&#160;```xml</div><div class="line"><a name="l07050"></a><span class="lineno"> 7050</span>&#160;&lt;string id=&quot;123&quot; xsi:type=&quot;string&quot;&gt;hello&lt;/string&gt; </div><div class="line"><a name="l07051"></a><span class="lineno"> 7051</span>&#160;... </div><div class="line"><a name="l07052"></a><span class="lineno"> 7052</span>&#160;&lt;string href=&quot;#123&quot;/&gt;</div><div class="line"><a name="l07053"></a><span class="lineno"> 7053</span>&#160;```</div><div class="line"><a name="l07054"></a><span class="lineno"> 7054</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l07055"></a><span class="lineno"> 7055</span>&#160;</div><div class="line"><a name="l07056"></a><span class="lineno"> 7056</span>&#160;The example assumed that `s` and `t` are encoded as independent elements.</div><div class="line"><a name="l07057"></a><span class="lineno"> 7057</span>&#160;</div><div class="line"><a name="l07058"></a><span class="lineno"> 7058</span>&#160;Note: the use of `typedef` to declare a string type such as `xsd__string` will not affect the multi-reference string</div><div class="line"><a name="l07059"></a><span class="lineno"> 7059</span>&#160;encoding.  However, strings declared with different `typedef`s will never be considered multi-reference even when they point</div><div class="line"><a name="l07060"></a><span class="lineno"> 7060</span>&#160;to the same string.  For example</div><div class="line"><a name="l07061"></a><span class="lineno"> 7061</span>&#160;</div><div class="line"><a name="l07062"></a><span class="lineno"> 7062</span>&#160;```cpp</div><div class="line"><a name="l07063"></a><span class="lineno"> 7063</span>&#160;typedef char *xsd__string; </div><div class="line"><a name="l07064"></a><span class="lineno"> 7064</span>&#160;typedef char *xsd__anyURI; </div><div class="line"><a name="l07065"></a><span class="lineno"> 7065</span>&#160;xsd__anyURI *s = &quot;http://www.myservice.com&quot;; </div><div class="line"><a name="l07066"></a><span class="lineno"> 7066</span>&#160;xsd__string *t = s;</div><div class="line"><a name="l07067"></a><span class="lineno"> 7067</span>&#160;```</div><div class="line"><a name="l07068"></a><span class="lineno"> 7068</span>&#160;</div><div class="line"><a name="l07069"></a><span class="lineno"> 7069</span>&#160;The variables `s` and `t` point to the same string, but since they are considered different types their content will not</div><div class="line"><a name="l07070"></a><span class="lineno"> 7070</span>&#160;be shared in the SOAP payload through a multi-referenced string.</div><div class="line"><a name="l07071"></a><span class="lineno"> 7071</span>&#160;</div><div class="line"><a name="l07072"></a><span class="lineno"> 7072</span>&#160;### &quot;Smart String&quot; Mixed-Content Decoding        {#smart}</div><div class="line"><a name="l07073"></a><span class="lineno"> 7073</span>&#160;</div><div class="line"><a name="l07074"></a><span class="lineno"> 7074</span>&#160;The implementation of string decoding in gSOAP allows for mixed content decoding. If the SOAP payload contains a complex data type in place of</div><div class="line"><a name="l07075"></a><span class="lineno"> 7075</span>&#160;a string, the complex data type is decoded in the string as plain XML text.</div><div class="line"><a name="l07076"></a><span class="lineno"> 7076</span>&#160;</div><div class="line"><a name="l07077"></a><span class="lineno"> 7077</span>&#160;For example, suppose the `getInfo` service operation returns some detailed information. The service operation is declared as:</div><div class="line"><a name="l07078"></a><span class="lineno"> 7078</span>&#160;</div><div class="line"><a name="l07079"></a><span class="lineno"> 7079</span>&#160;```cpp</div><div class="line"><a name="l07080"></a><span class="lineno"> 7080</span>&#160;// Contents of header file &quot;getInfo.h&quot;: </div><div class="line"><a name="l07081"></a><span class="lineno"> 7081</span>&#160;getInfo(char *detail);</div><div class="line"><a name="l07082"></a><span class="lineno"> 7082</span>&#160;```</div><div class="line"><a name="l07083"></a><span class="lineno"> 7083</span>&#160;</div><div class="line"><a name="l07084"></a><span class="lineno"> 7084</span>&#160;The proxy of the service is used by a client to request a piece of information and the service responds with:</div><div class="line"><a name="l07085"></a><span class="lineno"> 7085</span>&#160;</div><div class="line"><a name="l07086"></a><span class="lineno"> 7086</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l07087"></a><span class="lineno"> 7087</span>&#160;```xml</div><div class="line"><a name="l07088"></a><span class="lineno"> 7088</span>&#160;HTTP/1.1 200 OK </div><div class="line"><a name="l07089"></a><span class="lineno"> 7089</span>&#160;Content-Type: text/xml </div><div class="line"><a name="l07090"></a><span class="lineno"> 7090</span>&#160;Content-Length: nnn </div><div class="line"><a name="l07091"></a><span class="lineno"> 7091</span>&#160;</div><div class="line"><a name="l07092"></a><span class="lineno"> 7092</span>&#160;&lt;SOAP-ENV:Envelope xmlns:SOAP-ENV=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; </div><div class="line"><a name="l07093"></a><span class="lineno"> 7093</span>&#160;   xmlns:SOAP-ENC=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot; </div><div class="line"><a name="l07094"></a><span class="lineno"> 7094</span>&#160;   xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; </div><div class="line"><a name="l07095"></a><span class="lineno"> 7095</span>&#160;   xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; </div><div class="line"><a name="l07096"></a><span class="lineno"> 7096</span>&#160;&lt;SOAP-ENV:Body&gt; </div><div class="line"><a name="l07097"></a><span class="lineno"> 7097</span>&#160;&lt;getInfoResponse&gt; </div><div class="line"><a name="l07098"></a><span class="lineno"> 7098</span>&#160;&lt;detail&gt; </div><div class="line"><a name="l07099"></a><span class="lineno"> 7099</span>&#160;&lt;picture&gt;Mona Lisa by &lt;i&gt;Leonardo da Vinci&lt;/i&gt;&lt;/picture&gt; </div><div class="line"><a name="l07100"></a><span class="lineno"> 7100</span>&#160;&lt;/detail&gt; </div><div class="line"><a name="l07101"></a><span class="lineno"> 7101</span>&#160;&lt;/getInfoResponse&gt; </div><div class="line"><a name="l07102"></a><span class="lineno"> 7102</span>&#160;&lt;/SOAP-ENV:Body&gt; </div><div class="line"><a name="l07103"></a><span class="lineno"> 7103</span>&#160;&lt;/SOAP-ENV:Envelope&gt;</div><div class="line"><a name="l07104"></a><span class="lineno"> 7104</span>&#160;```</div><div class="line"><a name="l07105"></a><span class="lineno"> 7105</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l07106"></a><span class="lineno"> 7106</span>&#160;</div><div class="line"><a name="l07107"></a><span class="lineno"> 7107</span>&#160;As a result of the mixed content decoding, the `detail` string contains &quot;*`&lt;picture&gt;Mona Lisa by &lt;i&gt;Leonardo da Vinci&lt;/i&gt;&lt;/picture&gt;`*&quot;.</div><div class="line"><a name="l07108"></a><span class="lineno"> 7108</span>&#160;</div><div class="line"><a name="l07109"></a><span class="lineno"> 7109</span>&#160;### C++ Strings        {#strings}</div><div class="line"><a name="l07110"></a><span class="lineno"> 7110</span>&#160;</div><div class="line"><a name="l07111"></a><span class="lineno"> 7111</span>&#160;gSOAP supports C++ strings `std::string` and `std::wstring` wide character strings.</div><div class="line"><a name="l07112"></a><span class="lineno"> 7112</span>&#160;For example:</div><div class="line"><a name="l07113"></a><span class="lineno"> 7113</span>&#160;</div><div class="line"><a name="l07114"></a><span class="lineno"> 7114</span>&#160;```cpp</div><div class="line"><a name="l07115"></a><span class="lineno"> 7115</span>&#160;typedef std::string xsd__string; </div><div class="line"><a name="l07116"></a><span class="lineno"> 7116</span>&#160;class ns__myClass </div><div class="line"><a name="l07117"></a><span class="lineno"> 7117</span>&#160;{ public: </div><div class="line"><a name="l07118"></a><span class="lineno"> 7118</span>&#160;   xsd__string s; // serialized with xsi:type=&quot;xsd:string&quot; </div><div class="line"><a name="l07119"></a><span class="lineno"> 7119</span>&#160;   std::string t; // serialized without xsi:type </div><div class="line"><a name="l07120"></a><span class="lineno"> 7120</span>&#160;... </div><div class="line"><a name="l07121"></a><span class="lineno"> 7121</span>&#160;};</div><div class="line"><a name="l07122"></a><span class="lineno"> 7122</span>&#160;```</div><div class="line"><a name="l07123"></a><span class="lineno"> 7123</span>&#160;</div><div class="line"><a name="l07124"></a><span class="lineno"> 7124</span>&#160;@warning Please avoid mixing `std::string` and C strings (`char*`) in the header file when using SOAP 1.1 encoding. The problem is that multi-referenced strings in SOAP encoded messages cannot be assigned simultaneously to a `std::string` and a `char*` string.</div><div class="line"><a name="l07125"></a><span class="lineno"> 7125</span>&#160;</div><div class="line"><a name="l07126"></a><span class="lineno"> 7126</span>&#160;### Changing the Encoding Precision of float and double Types</div><div class="line"><a name="l07127"></a><span class="lineno"> 7127</span>&#160;</div><div class="line"><a name="l07128"></a><span class="lineno"> 7128</span>&#160;The `double` encoding format is by default set to &quot;`%.18G`&quot; (see a manual on `printf` text formatting in C),</div><div class="line"><a name="l07129"></a><span class="lineno"> 7129</span>&#160;i.e. at most 18 digits of precision to limit a loss in accuracy.</div><div class="line"><a name="l07130"></a><span class="lineno"> 7130</span>&#160;The `float` encoding format is by default &quot;`%.9G`&quot;, i.e. at most 9 digits of precision.</div><div class="line"><a name="l07131"></a><span class="lineno"> 7131</span>&#160;</div><div class="line"><a name="l07132"></a><span class="lineno"> 7132</span>&#160;The encoding format of a double type can be set by assigning a format string to `soap.double_format`, where `soap` is a</div><div class="line"><a name="l07133"></a><span class="lineno"> 7133</span>&#160;variable that contains the</div><div class="line"><a name="l07134"></a><span class="lineno"> 7134</span>&#160;current runtime context. For example:</div><div class="line"><a name="l07135"></a><span class="lineno"> 7135</span>&#160;</div><div class="line"><a name="l07136"></a><span class="lineno"> 7136</span>&#160;```cpp</div><div class="line"><a name="l07137"></a><span class="lineno"> 7137</span>&#160;struct soap soap; </div><div class="line"><a name="l07138"></a><span class="lineno"> 7138</span>&#160;soap_init(&amp;soap); // sets double_format = &quot;%.18G&quot; </div><div class="line"><a name="l07139"></a><span class="lineno"> 7139</span>&#160;soap.double_format = &quot;%e&quot;; // redefine</div><div class="line"><a name="l07140"></a><span class="lineno"> 7140</span>&#160;```</div><div class="line"><a name="l07141"></a><span class="lineno"> 7141</span>&#160;</div><div class="line"><a name="l07142"></a><span class="lineno"> 7142</span>&#160;which causes all doubles to be encoded in scientific notation.</div><div class="line"><a name="l07143"></a><span class="lineno"> 7143</span>&#160;Likewise, the encoding format of a float type can be set by assigning a format string to the static `soap_float_format` string variable. For example:</div><div class="line"><a name="l07144"></a><span class="lineno"> 7144</span>&#160;</div><div class="line"><a name="l07145"></a><span class="lineno"> 7145</span>&#160;```cpp</div><div class="line"><a name="l07146"></a><span class="lineno"> 7146</span>&#160;struct soap soap; </div><div class="line"><a name="l07147"></a><span class="lineno"> 7147</span>&#160;soap_init(&amp;soap); // sets float_format = &quot;%.9G&quot; </div><div class="line"><a name="l07148"></a><span class="lineno"> 7148</span>&#160;soap.float_format = &quot;%.4f&quot;; // redefine</div><div class="line"><a name="l07149"></a><span class="lineno"> 7149</span>&#160;```</div><div class="line"><a name="l07150"></a><span class="lineno"> 7150</span>&#160;</div><div class="line"><a name="l07151"></a><span class="lineno"> 7151</span>&#160;which causes all floats to be encoded with four digits precision.</div><div class="line"><a name="l07152"></a><span class="lineno"> 7152</span>&#160;</div><div class="line"><a name="l07153"></a><span class="lineno"> 7153</span>&#160;@warning The format strings are not automatically reset before or after</div><div class="line"><a name="l07154"></a><span class="lineno"> 7154</span>&#160;SOAP communications. An error in the format string may result in the incorrect</div><div class="line"><a name="l07155"></a><span class="lineno"> 7155</span>&#160;encoding of floating point values.</div><div class="line"><a name="l07156"></a><span class="lineno"> 7156</span>&#160;</div><div class="line"><a name="l07157"></a><span class="lineno"> 7157</span>&#160;A special case for C format string patterns is introduced in gSOAP 2.8.18. A</div><div class="line"><a name="l07158"></a><span class="lineno"> 7158</span>&#160;C format string that is used as a pattern for a typedef float or double in the</div><div class="line"><a name="l07159"></a><span class="lineno"> 7159</span>&#160;gSOAP header file is used to format the output of the floating point value in</div><div class="line"><a name="l07160"></a><span class="lineno"> 7160</span>&#160;XML. For example:</div><div class="line"><a name="l07161"></a><span class="lineno"> 7161</span>&#160;</div><div class="line"><a name="l07162"></a><span class="lineno"> 7162</span>&#160;```cpp</div><div class="line"><a name="l07163"></a><span class="lineno"> 7163</span>&#160;typedef float time__ratio &quot;%5.2f&quot;;</div><div class="line"><a name="l07164"></a><span class="lineno"> 7164</span>&#160;```</div><div class="line"><a name="l07165"></a><span class="lineno"> 7165</span>&#160;</div><div class="line"><a name="l07166"></a><span class="lineno"> 7166</span>&#160;This will output the float with 5 digits total and 2 digits after the decimal</div><div class="line"><a name="l07167"></a><span class="lineno"> 7167</span>&#160;point.</div><div class="line"><a name="l07168"></a><span class="lineno"> 7168</span>&#160;</div><div class="line"><a name="l07169"></a><span class="lineno"> 7169</span>&#160;When *`xs:totalDigits`* and *`xs:fractionDigits`* are given in a XSD file,</div><div class="line"><a name="l07170"></a><span class="lineno"> 7170</span>&#160;then also a C format string is produced to output floating point values with</div><div class="line"><a name="l07171"></a><span class="lineno"> 7171</span>&#160;the proper precision and scale. For example:</div><div class="line"><a name="l07172"></a><span class="lineno"> 7172</span>&#160;</div><div class="line"><a name="l07173"></a><span class="lineno"> 7173</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l07174"></a><span class="lineno"> 7174</span>&#160;```xml</div><div class="line"><a name="l07175"></a><span class="lineno"> 7175</span>&#160;&lt;simpleType name=&quot;ratio&quot;&gt; </div><div class="line"><a name="l07176"></a><span class="lineno"> 7176</span>&#160;   &lt;restriction base=&quot;xsd:float&quot;&gt; </div><div class="line"><a name="l07177"></a><span class="lineno"> 7177</span>&#160;     &lt;totalDigits value=&quot;5&quot;/&gt; </div><div class="line"><a name="l07178"></a><span class="lineno"> 7178</span>&#160;     &lt;fractionDigits value=&quot;2&quot;/&gt; </div><div class="line"><a name="l07179"></a><span class="lineno"> 7179</span>&#160;   &lt;/restriction&gt; </div><div class="line"><a name="l07180"></a><span class="lineno"> 7180</span>&#160;&lt;/simpleType&gt;</div><div class="line"><a name="l07181"></a><span class="lineno"> 7181</span>&#160;```</div><div class="line"><a name="l07182"></a><span class="lineno"> 7182</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l07183"></a><span class="lineno"> 7183</span>&#160;</div><div class="line"><a name="l07184"></a><span class="lineno"> 7184</span>&#160;### INF, -INF, and NaN Values of float and double Types</div><div class="line"><a name="l07185"></a><span class="lineno"> 7185</span>&#160;</div><div class="line"><a name="l07186"></a><span class="lineno"> 7186</span>&#160;The gSOAP runtime `stdsoap2.cpp` and header file `stdsoap2.h` support the marshalling of IEEE INF, -INF, and NaN</div><div class="line"><a name="l07187"></a><span class="lineno"> 7187</span>&#160;representations.  Under certain circumstances this may break if the hardware and/or C/C++ compiler does not support these</div><div class="line"><a name="l07188"></a><span class="lineno"> 7188</span>&#160;representations.</div><div class="line"><a name="l07189"></a><span class="lineno"> 7189</span>&#160;To remove the representations, remove the inclusion of the `&lt;math.h&gt;` header file from the `stdsoap2.h` file.</div><div class="line"><a name="l07190"></a><span class="lineno"> 7190</span>&#160;You can control the representations as well, which are defined by the macros:</div><div class="line"><a name="l07191"></a><span class="lineno"> 7191</span>&#160;</div><div class="line"><a name="l07192"></a><span class="lineno"> 7192</span>&#160;```cpp</div><div class="line"><a name="l07193"></a><span class="lineno"> 7193</span>&#160;#define FLT_NAN </div><div class="line"><a name="l07194"></a><span class="lineno"> 7194</span>&#160;#define FLT_PINFTY </div><div class="line"><a name="l07195"></a><span class="lineno"> 7195</span>&#160;#define FLT_NINFTY </div><div class="line"><a name="l07196"></a><span class="lineno"> 7196</span>&#160;#define DBL_NAN </div><div class="line"><a name="l07197"></a><span class="lineno"> 7197</span>&#160;#define DBL_PINFTY </div><div class="line"><a name="l07198"></a><span class="lineno"> 7198</span>&#160;#define DBL_NINFTY</div><div class="line"><a name="l07199"></a><span class="lineno"> 7199</span>&#160;```</div><div class="line"><a name="l07200"></a><span class="lineno"> 7200</span>&#160;</div><div class="line"><a name="l07201"></a><span class="lineno"> 7201</span>&#160;## Enumeration Serialization        {#enum}</div><div class="line"><a name="l07202"></a><span class="lineno"> 7202</span>&#160;</div><div class="line"><a name="l07203"></a><span class="lineno"> 7203</span>&#160;Enumerations are generally useful for the declaration of named integer-valued constants, also called enumeration constants.</div><div class="line"><a name="l07204"></a><span class="lineno"> 7204</span>&#160;</div><div class="line"><a name="l07205"></a><span class="lineno"> 7205</span>&#160;### Serialization of Symbolic Enumeration Constants</div><div class="line"><a name="l07206"></a><span class="lineno"> 7206</span>&#160;</div><div class="line"><a name="l07207"></a><span class="lineno"> 7207</span>&#160;The gSOAP `soapcpp2` tool encodes the constants of enumeration-typed variables in symbolic form using the names of the constants when possible to comply to SOAP&#39;s enumeration encoding style. Consider for example the following enumeration of weekdays:</div><div class="line"><a name="l07208"></a><span class="lineno"> 7208</span>&#160;</div><div class="line"><a name="l07209"></a><span class="lineno"> 7209</span>&#160;```cpp</div><div class="line"><a name="l07210"></a><span class="lineno"> 7210</span>&#160;enum weekday {Mon, Tue, Wed, Thu, Fri, Sat, Sun};</div><div class="line"><a name="l07211"></a><span class="lineno"> 7211</span>&#160;```</div><div class="line"><a name="l07212"></a><span class="lineno"> 7212</span>&#160;</div><div class="line"><a name="l07213"></a><span class="lineno"> 7213</span>&#160;The enumeration-constant `Mon`, for example, is encoded as</div><div class="line"><a name="l07214"></a><span class="lineno"> 7214</span>&#160;</div><div class="line"><a name="l07215"></a><span class="lineno"> 7215</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l07216"></a><span class="lineno"> 7216</span>&#160;```xml</div><div class="line"><a name="l07217"></a><span class="lineno"> 7217</span>&#160;&lt;weekday xsi:type=&quot;weekday&quot;&gt;Mon&lt;/weekday&gt;</div><div class="line"><a name="l07218"></a><span class="lineno"> 7218</span>&#160;```</div><div class="line"><a name="l07219"></a><span class="lineno"> 7219</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l07220"></a><span class="lineno"> 7220</span>&#160;</div><div class="line"><a name="l07221"></a><span class="lineno"> 7221</span>&#160;The value of the *`xsi:type`* attribute is the enumeration-type identifier&#39;s name. If the element is independent as in the example above, the element name is the enumeration-type identifier&#39;s name.</div><div class="line"><a name="l07222"></a><span class="lineno"> 7222</span>&#160;</div><div class="line"><a name="l07223"></a><span class="lineno"> 7223</span>&#160;The encoding of complex types such as enumerations requires a reference to an XML Schema through the use of a namespace prefix. The namespace prefix can be specified as part of the enumeration-type identifier&#39;s name, with the usual namespace prefix conventions for identifiers. This can be used to explicitly specify the encoding style. For example:</div><div class="line"><a name="l07224"></a><span class="lineno"> 7224</span>&#160;</div><div class="line"><a name="l07225"></a><span class="lineno"> 7225</span>&#160;```cpp</div><div class="line"><a name="l07226"></a><span class="lineno"> 7226</span>&#160;enum ns1__weekday {Mon, Tue, Wed, Thu, Fri, Sat, Sun};</div><div class="line"><a name="l07227"></a><span class="lineno"> 7227</span>&#160;```</div><div class="line"><a name="l07228"></a><span class="lineno"> 7228</span>&#160;</div><div class="line"><a name="l07229"></a><span class="lineno"> 7229</span>&#160;The enumeration-constant `Sat`, for example, is encoded as:</div><div class="line"><a name="l07230"></a><span class="lineno"> 7230</span>&#160;</div><div class="line"><a name="l07231"></a><span class="lineno"> 7231</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l07232"></a><span class="lineno"> 7232</span>&#160;```xml</div><div class="line"><a name="l07233"></a><span class="lineno"> 7233</span>&#160;&lt;ns1:weekday xsi:type=&quot;ns1:weekday&quot;&gt;Sat&lt;/ns1:weekday&gt;</div><div class="line"><a name="l07234"></a><span class="lineno"> 7234</span>&#160;```</div><div class="line"><a name="l07235"></a><span class="lineno"> 7235</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l07236"></a><span class="lineno"> 7236</span>&#160;</div><div class="line"><a name="l07237"></a><span class="lineno"> 7237</span>&#160;The corresponding XML Schema for this enumeration data type would be:</div><div class="line"><a name="l07238"></a><span class="lineno"> 7238</span>&#160;</div><div class="line"><a name="l07239"></a><span class="lineno"> 7239</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l07240"></a><span class="lineno"> 7240</span>&#160;```xml</div><div class="line"><a name="l07241"></a><span class="lineno"> 7241</span>&#160;&lt;xsd:element name=&quot;weekday&quot; type=&quot;tns:weekday&quot;/&gt; </div><div class="line"><a name="l07242"></a><span class="lineno"> 7242</span>&#160;&lt;xsd:simpleType name=&quot;weekday&quot;&gt; </div><div class="line"><a name="l07243"></a><span class="lineno"> 7243</span>&#160;  &lt;xsd:restriction base=&quot;xsd:string&quot;&gt; </div><div class="line"><a name="l07244"></a><span class="lineno"> 7244</span>&#160;    &lt;xsd:enumeration value=&quot;Mon&quot;/&gt; </div><div class="line"><a name="l07245"></a><span class="lineno"> 7245</span>&#160;    &lt;xsd:enumeration value=&quot;Tue&quot;/&gt; </div><div class="line"><a name="l07246"></a><span class="lineno"> 7246</span>&#160;    &lt;xsd:enumeration value=&quot;Wed&quot;/&gt; </div><div class="line"><a name="l07247"></a><span class="lineno"> 7247</span>&#160;    &lt;xsd:enumeration value=&quot;Thu&quot;/&gt; </div><div class="line"><a name="l07248"></a><span class="lineno"> 7248</span>&#160;    &lt;xsd:enumeration value=&quot;Fri&quot;/&gt; </div><div class="line"><a name="l07249"></a><span class="lineno"> 7249</span>&#160;    &lt;xsd:enumeration value=&quot;Sat&quot;/&gt; </div><div class="line"><a name="l07250"></a><span class="lineno"> 7250</span>&#160;    &lt;xsd:enumeration value=&quot;Sun&quot;/&gt; </div><div class="line"><a name="l07251"></a><span class="lineno"> 7251</span>&#160;  &lt;/xsd:restriction&gt; </div><div class="line"><a name="l07252"></a><span class="lineno"> 7252</span>&#160;&lt;/xsd:simpleType&gt;</div><div class="line"><a name="l07253"></a><span class="lineno"> 7253</span>&#160;```</div><div class="line"><a name="l07254"></a><span class="lineno"> 7254</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l07255"></a><span class="lineno"> 7255</span>&#160;</div><div class="line"><a name="l07256"></a><span class="lineno"> 7256</span>&#160;### Encoding of Enumeration Constants</div><div class="line"><a name="l07257"></a><span class="lineno"> 7257</span>&#160;</div><div class="line"><a name="l07258"></a><span class="lineno"> 7258</span>&#160;If the value of an enumeration-typed variable has no corresponding named constant, the value is encoded as a signed integer literal. For example, the following declaration of a `workday` enumeration type lacks named constants for Saturday and Sunday:</div><div class="line"><a name="l07259"></a><span class="lineno"> 7259</span>&#160;</div><div class="line"><a name="l07260"></a><span class="lineno"> 7260</span>&#160;```cpp</div><div class="line"><a name="l07261"></a><span class="lineno"> 7261</span>&#160;enum ns1__workday {Mon, Tue, Wed, Thu, Fri};</div><div class="line"><a name="l07262"></a><span class="lineno"> 7262</span>&#160;```</div><div class="line"><a name="l07263"></a><span class="lineno"> 7263</span>&#160;</div><div class="line"><a name="l07264"></a><span class="lineno"> 7264</span>&#160;If the constant `5` (Saturday) or `6` (Sunday) is assigned to a variable of the `workday` enumeration type, the variable will be encoded with the integer literals *`5`* and *`6`*, respectively. For example:</div><div class="line"><a name="l07265"></a><span class="lineno"> 7265</span>&#160;</div><div class="line"><a name="l07266"></a><span class="lineno"> 7266</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l07267"></a><span class="lineno"> 7267</span>&#160;```xml</div><div class="line"><a name="l07268"></a><span class="lineno"> 7268</span>&#160;&lt;ns1:workday xsi:type=&quot;ns1:workday&quot;&gt;5&lt;/ns1:workday&gt;</div><div class="line"><a name="l07269"></a><span class="lineno"> 7269</span>&#160;```</div><div class="line"><a name="l07270"></a><span class="lineno"> 7270</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l07271"></a><span class="lineno"> 7271</span>&#160;</div><div class="line"><a name="l07272"></a><span class="lineno"> 7272</span>&#160;Since this is legal in C++ and SOAP allows enumeration constants to be integer literals, this method ensures that non-symbolic</div><div class="line"><a name="l07273"></a><span class="lineno"> 7273</span>&#160;enumeration constants are correctly communicated to another party if the other party accepts literal enumeration constants (as</div><div class="line"><a name="l07274"></a><span class="lineno"> 7274</span>&#160;with the gSOAP `soapcpp2` tool).</div><div class="line"><a name="l07275"></a><span class="lineno"> 7275</span>&#160;</div><div class="line"><a name="l07276"></a><span class="lineno"> 7276</span>&#160;Both symbolic and literal enumeration constants can be decoded.</div><div class="line"><a name="l07277"></a><span class="lineno"> 7277</span>&#160;</div><div class="line"><a name="l07278"></a><span class="lineno"> 7278</span>&#160;To enforce the literal enumeration constant encoding and to get the literal constants in the WSDL file, use the following trick:</div><div class="line"><a name="l07279"></a><span class="lineno"> 7279</span>&#160;</div><div class="line"><a name="l07280"></a><span class="lineno"> 7280</span>&#160;```cpp</div><div class="line"><a name="l07281"></a><span class="lineno"> 7281</span>&#160;enum ns1__nums { _1 = 1, _2 = 2, _3 = 3 };</div><div class="line"><a name="l07282"></a><span class="lineno"> 7282</span>&#160;```</div><div class="line"><a name="l07283"></a><span class="lineno"> 7283</span>&#160;</div><div class="line"><a name="l07284"></a><span class="lineno"> 7284</span>&#160;The difference with an enumeration type without a list of values and the enumeration type above is that the enumeration constants</div><div class="line"><a name="l07285"></a><span class="lineno"> 7285</span>&#160;will appear in the WSDL service description.</div><div class="line"><a name="l07286"></a><span class="lineno"> 7286</span>&#160;</div><div class="line"><a name="l07287"></a><span class="lineno"> 7287</span>&#160;### Initialized Enumeration Constants</div><div class="line"><a name="l07288"></a><span class="lineno"> 7288</span>&#160;</div><div class="line"><a name="l07289"></a><span class="lineno"> 7289</span>&#160;The gSOAP `soapcpp2` compiler supports the initialization of enumeration constants, as in:</div><div class="line"><a name="l07290"></a><span class="lineno"> 7290</span>&#160;```cpp</div><div class="line"><a name="l07291"></a><span class="lineno"> 7291</span>&#160;enum ns1__relation {LESS = -1, EQUAL = 0, GREATER = 1};</div><div class="line"><a name="l07292"></a><span class="lineno"> 7292</span>&#160;```</div><div class="line"><a name="l07293"></a><span class="lineno"> 7293</span>&#160;The symbolic names *`LESS`*, *`EQUAL`*, and *`GREATER`* will appear in the SOAP payload for the encoding of the `ns1__relation` enumeration values `-1`, `0`, and `1`, respectively.</div><div class="line"><a name="l07294"></a><span class="lineno"> 7294</span>&#160;</div><div class="line"><a name="l07295"></a><span class="lineno"> 7295</span>&#160;### How to &quot;Reuse&quot; Symbolic Enumeration Constants</div><div class="line"><a name="l07296"></a><span class="lineno"> 7296</span>&#160;</div><div class="line"><a name="l07297"></a><span class="lineno"> 7297</span>&#160;A well-known deficiency of C and C++ enumeration types is the lack of support for the reuse of symbolic names by multiple enumerations. That is, the names of all the symbolic constants defined by an enumeration cannot be reused by another enumeration. To force encoding of the same symbolic name by different enumerations, the identifier of the symbolic name can end in an underscore (`_`) or any number of underscores to distinguish it from other symbolic names in C++. This guarantees that the SOAP encoding will use the same name, while the symbolic names can be distinguished in C++. Effectively, the underscores are removed from a symbolic name prior to encoding.</div><div class="line"><a name="l07298"></a><span class="lineno"> 7298</span>&#160;</div><div class="line"><a name="l07299"></a><span class="lineno"> 7299</span>&#160;Consider for example:</div><div class="line"><a name="l07300"></a><span class="lineno"> 7300</span>&#160;</div><div class="line"><a name="l07301"></a><span class="lineno"> 7301</span>&#160;```cpp</div><div class="line"><a name="l07302"></a><span class="lineno"> 7302</span>&#160;enum ns1__workday {Mon, Tue, Wed, Thu, Fri}; </div><div class="line"><a name="l07303"></a><span class="lineno"> 7303</span>&#160;enum ns1__weekday {Mon_, Tue_, Wed_, Thu_, Fri_, Sat_, Sun_};</div><div class="line"><a name="l07304"></a><span class="lineno"> 7304</span>&#160;```</div><div class="line"><a name="l07305"></a><span class="lineno"> 7305</span>&#160;</div><div class="line"><a name="l07306"></a><span class="lineno"> 7306</span>&#160;which will result in the encoding of the constants of `enum ns1__weekday` without the underscore, for example as *`Mon`*.</div><div class="line"><a name="l07307"></a><span class="lineno"> 7307</span>&#160;</div><div class="line"><a name="l07308"></a><span class="lineno"> 7308</span>&#160;As an alternative to the trailing underscores that can get quite long for commonly used symbolic enum names, you can use the following convention with double underscores to add the enum name to the enum constants:</div><div class="line"><a name="l07309"></a><span class="lineno"> 7309</span>&#160;</div><div class="line"><a name="l07310"></a><span class="lineno"> 7310</span>&#160;```cpp</div><div class="line"><a name="l07311"></a><span class="lineno"> 7311</span>&#160;enum prefixedname { prefixedname__enumconst1, prefixedname__enumconst2, ... };</div><div class="line"><a name="l07312"></a><span class="lineno"> 7312</span>&#160;```</div><div class="line"><a name="l07313"></a><span class="lineno"> 7313</span>&#160;</div><div class="line"><a name="l07314"></a><span class="lineno"> 7314</span>&#160;where the type name of the enumeration `prefixedname` is a prefixed name,</div><div class="line"><a name="l07315"></a><span class="lineno"> 7315</span>&#160;such as:</div><div class="line"><a name="l07316"></a><span class="lineno"> 7316</span>&#160;</div><div class="line"><a name="l07317"></a><span class="lineno"> 7317</span>&#160;```cpp</div><div class="line"><a name="l07318"></a><span class="lineno"> 7318</span>&#160;enum ns1__workday {</div><div class="line"><a name="l07319"></a><span class="lineno"> 7319</span>&#160;ns1__workday__Mon,</div><div class="line"><a name="l07320"></a><span class="lineno"> 7320</span>&#160;ns1__workday__Tue,</div><div class="line"><a name="l07321"></a><span class="lineno"> 7321</span>&#160;ns1__workday__Wed,</div><div class="line"><a name="l07322"></a><span class="lineno"> 7322</span>&#160;ns1__workday__Thu,</div><div class="line"><a name="l07323"></a><span class="lineno"> 7323</span>&#160;ns1__workday__Fri }; </div><div class="line"><a name="l07324"></a><span class="lineno"> 7324</span>&#160;enum ns1__weekday {</div><div class="line"><a name="l07325"></a><span class="lineno"> 7325</span>&#160;ns1__workday__Mon,</div><div class="line"><a name="l07326"></a><span class="lineno"> 7326</span>&#160;ns1__workday__Tue,</div><div class="line"><a name="l07327"></a><span class="lineno"> 7327</span>&#160;ns1__workday__Wed,</div><div class="line"><a name="l07328"></a><span class="lineno"> 7328</span>&#160;ns1__workday__Thu,</div><div class="line"><a name="l07329"></a><span class="lineno"> 7329</span>&#160;ns1__workday__Fri,</div><div class="line"><a name="l07330"></a><span class="lineno"> 7330</span>&#160;ns1__workday__Sat,</div><div class="line"><a name="l07331"></a><span class="lineno"> 7331</span>&#160;ns1__workday__Sun</div><div class="line"><a name="l07332"></a><span class="lineno"> 7332</span>&#160;}; </div><div class="line"><a name="l07333"></a><span class="lineno"> 7333</span>&#160;```</div><div class="line"><a name="l07334"></a><span class="lineno"> 7334</span>&#160;</div><div class="line"><a name="l07335"></a><span class="lineno"> 7335</span>&#160;This ensures that the XML schema enumeration values are still simply *`Mon`*, *`Tue`*, *`Wed`*, *`Thu`*, *`Fri`*, *`Sat`*, and *`Sun`*.</div><div class="line"><a name="l07336"></a><span class="lineno"> 7336</span>&#160;</div><div class="line"><a name="l07337"></a><span class="lineno"> 7337</span>&#160;@warning The following declaration:</div><div class="line"><a name="l07338"></a><span class="lineno"> 7338</span>&#160;</div><div class="line"><a name="l07339"></a><span class="lineno"> 7339</span>&#160;```cpp</div><div class="line"><a name="l07340"></a><span class="lineno"> 7340</span>&#160;enum ns1__workday {Mon, Tue, Wed, Thu, Fri}; </div><div class="line"><a name="l07341"></a><span class="lineno"> 7341</span>&#160;enum ns1__weekday {Sat = 5, Sun = 6};</div><div class="line"><a name="l07342"></a><span class="lineno"> 7342</span>&#160;```</div><div class="line"><a name="l07343"></a><span class="lineno"> 7343</span>&#160;</div><div class="line"><a name="l07344"></a><span class="lineno"> 7344</span>&#160;will not properly encode the `weekday` enumeration when you assume that workdays are part of weekdays, because it lacks the named constants for `workday` in its enumeration list. All enumerations must be self-contained and cannot use enum constants of other enumerations.</div><div class="line"><a name="l07345"></a><span class="lineno"> 7345</span>&#160;</div><div class="line"><a name="l07346"></a><span class="lineno"> 7346</span>&#160;### Boolean Enumeration Serialization for C        {#boolean}</div><div class="line"><a name="l07347"></a><span class="lineno"> 7347</span>&#160;</div><div class="line"><a name="l07348"></a><span class="lineno"> 7348</span>&#160;When developing a C Web service application, the C++ `bool` type should not be used since it is not usually supported by the C compiler.</div><div class="line"><a name="l07349"></a><span class="lineno"> 7349</span>&#160;Instead, an enumeration type should be used to serialize true/false values as *`xsd:boolean`* Schema type enumeration values.</div><div class="line"><a name="l07350"></a><span class="lineno"> 7350</span>&#160;The *`xsd:boolean`* XML Schema type is defined as:</div><div class="line"><a name="l07351"></a><span class="lineno"> 7351</span>&#160;</div><div class="line"><a name="l07352"></a><span class="lineno"> 7352</span>&#160;```cpp</div><div class="line"><a name="l07353"></a><span class="lineno"> 7353</span>&#160;enum xsd__boolean {false_, true_};</div><div class="line"><a name="l07354"></a><span class="lineno"> 7354</span>&#160;```</div><div class="line"><a name="l07355"></a><span class="lineno"> 7355</span>&#160;</div><div class="line"><a name="l07356"></a><span class="lineno"> 7356</span>&#160;The value `false_`, for example, is encoded as:</div><div class="line"><a name="l07357"></a><span class="lineno"> 7357</span>&#160;</div><div class="line"><a name="l07358"></a><span class="lineno"> 7358</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l07359"></a><span class="lineno"> 7359</span>&#160;```xml</div><div class="line"><a name="l07360"></a><span class="lineno"> 7360</span>&#160;&lt;xsd:boolean xsi:type=&quot;xsd:boolean&quot;&gt;false&lt;/xsd:boolean&gt; </div><div class="line"><a name="l07361"></a><span class="lineno"> 7361</span>&#160;```</div><div class="line"><a name="l07362"></a><span class="lineno"> 7362</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l07363"></a><span class="lineno"> 7363</span>&#160;</div><div class="line"><a name="l07364"></a><span class="lineno"> 7364</span>&#160;Peculiar of the SOAP boolean type encoding is that it only defines the values *`0`* and *`1`*, while the built-in XML Schema boolean type also defines the *`false`* and *`true`* symbolic constants as valid values. The following example declaration of an enumeration type lacks named constants altogether to force encoding of the enumeration values as literal constants:</div><div class="line"><a name="l07365"></a><span class="lineno"> 7365</span>&#160;</div><div class="line"><a name="l07366"></a><span class="lineno"> 7366</span>&#160;```cpp</div><div class="line"><a name="l07367"></a><span class="lineno"> 7367</span>&#160;enum SOAP_ENC__boolean {};</div><div class="line"><a name="l07368"></a><span class="lineno"> 7368</span>&#160;```</div><div class="line"><a name="l07369"></a><span class="lineno"> 7369</span>&#160;</div><div class="line"><a name="l07370"></a><span class="lineno"> 7370</span>&#160;The value `0`, for example, is encoded with an integer literal:</div><div class="line"><a name="l07371"></a><span class="lineno"> 7371</span>&#160;</div><div class="line"><a name="l07372"></a><span class="lineno"> 7372</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l07373"></a><span class="lineno"> 7373</span>&#160;```xml</div><div class="line"><a name="l07374"></a><span class="lineno"> 7374</span>&#160;&lt;SOAP-ENC:boolean xsi:type=&quot;SOAP-ENC:boolean&quot;&gt;0&lt;SOAP-ENC:boolean&gt;</div><div class="line"><a name="l07375"></a><span class="lineno"> 7375</span>&#160;```</div><div class="line"><a name="l07376"></a><span class="lineno"> 7376</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l07377"></a><span class="lineno"> 7377</span>&#160;</div><div class="line"><a name="l07378"></a><span class="lineno"> 7378</span>&#160;### Bitmask Enumeration Serialization</div><div class="line"><a name="l07379"></a><span class="lineno"> 7379</span>&#160;</div><div class="line"><a name="l07380"></a><span class="lineno"> 7380</span>&#160;A bitmask is an enumeration of flags such as declared with C#&#39;s [Flags] `enum` annotation.</div><div class="line"><a name="l07381"></a><span class="lineno"> 7381</span>&#160;gSOAP supports bitmask encoding and decoding for interoperability. However, bitmask types are not standardized with SOAP RPC.</div><div class="line"><a name="l07382"></a><span class="lineno"> 7382</span>&#160;</div><div class="line"><a name="l07383"></a><span class="lineno"> 7383</span>&#160;A special syntactic convention is used in the header file input to the gSOAP `soapcpp2` compiler to indicate the use of bitmasks with an</div><div class="line"><a name="l07384"></a><span class="lineno"> 7384</span>&#160;asterisk:</div><div class="line"><a name="l07385"></a><span class="lineno"> 7385</span>&#160;</div><div class="line"><a name="l07386"></a><span class="lineno"> 7386</span>&#160;```cpp</div><div class="line"><a name="l07387"></a><span class="lineno"> 7387</span>&#160;enum * *name* { *enum-constant*, *enum-constant*, ... };</div><div class="line"><a name="l07388"></a><span class="lineno"> 7388</span>&#160;```</div><div class="line"><a name="l07389"></a><span class="lineno"> 7389</span>&#160;</div><div class="line"><a name="l07390"></a><span class="lineno"> 7390</span>&#160;The gSOAP `soapcpp2` compiler will encode the enumeration constants as flags, i.e. as a series of powers of 2 starting with 1.</div><div class="line"><a name="l07391"></a><span class="lineno"> 7391</span>&#160;The enumeration constants can be or-ed to form a bitvector (bitmask) which is encoded and decoded as a list of symbolic values</div><div class="line"><a name="l07392"></a><span class="lineno"> 7392</span>&#160;in SOAP.</div><div class="line"><a name="l07393"></a><span class="lineno"> 7393</span>&#160;For example:</div><div class="line"><a name="l07394"></a><span class="lineno"> 7394</span>&#160;</div><div class="line"><a name="l07395"></a><span class="lineno"> 7395</span>&#160;```cpp</div><div class="line"><a name="l07396"></a><span class="lineno"> 7396</span>&#160;enum * ns__machineStatus { ON, BELT, VALVE, HATCH}; </div><div class="line"><a name="l07397"></a><span class="lineno"> 7397</span>&#160;int ns__getMachineStatus(char *name, char *enum ns__machineStatus result);</div><div class="line"><a name="l07398"></a><span class="lineno"> 7398</span>&#160;```</div><div class="line"><a name="l07399"></a><span class="lineno"> 7399</span>&#160;</div><div class="line"><a name="l07400"></a><span class="lineno"> 7400</span>&#160;Note that the use of the `enum` does not require the asterisk, only the definition.</div><div class="line"><a name="l07401"></a><span class="lineno"> 7401</span>&#160;The gSOAP `soapcpp2` compiler generates the enumeration:</div><div class="line"><a name="l07402"></a><span class="lineno"> 7402</span>&#160;</div><div class="line"><a name="l07403"></a><span class="lineno"> 7403</span>&#160;```cpp</div><div class="line"><a name="l07404"></a><span class="lineno"> 7404</span>&#160;enum ns__machineStatus { ON=1, BELT=2, VALVE=4, HATCH=8};</div><div class="line"><a name="l07405"></a><span class="lineno"> 7405</span>&#160;```</div><div class="line"><a name="l07406"></a><span class="lineno"> 7406</span>&#160;</div><div class="line"><a name="l07407"></a><span class="lineno"> 7407</span>&#160;A service operation implementation in a Web service can return:</div><div class="line"><a name="l07408"></a><span class="lineno"> 7408</span>&#160;</div><div class="line"><a name="l07409"></a><span class="lineno"> 7409</span>&#160;```cpp</div><div class="line"><a name="l07410"></a><span class="lineno"> 7410</span>&#160;int ns__getMachineStatus(struct soap *soap, char *name, enum ns__machineStatus result) </div><div class="line"><a name="l07411"></a><span class="lineno"> 7411</span>&#160;{ ... </div><div class="line"><a name="l07412"></a><span class="lineno"> 7412</span>&#160;   *result = BELT | HATCH; </div><div class="line"><a name="l07413"></a><span class="lineno"> 7413</span>&#160;   return SOAP_OK; </div><div class="line"><a name="l07414"></a><span class="lineno"> 7414</span>&#160;}</div><div class="line"><a name="l07415"></a><span class="lineno"> 7415</span>&#160;```</div><div class="line"><a name="l07416"></a><span class="lineno"> 7416</span>&#160;</div><div class="line"><a name="l07417"></a><span class="lineno"> 7417</span>&#160;## Struct Serialization        {#struct}</div><div class="line"><a name="l07418"></a><span class="lineno"> 7418</span>&#160;</div><div class="line"><a name="l07419"></a><span class="lineno"> 7419</span>&#160;A `struct` data type is encoded as an XML Schema complexType such that the</div><div class="line"><a name="l07420"></a><span class="lineno"> 7420</span>&#160;`struct` name is the XML Schema type name and the</div><div class="line"><a name="l07421"></a><span class="lineno"> 7421</span>&#160;fields of the `struct` are the type&#39;s accessors. This encoding is</div><div class="line"><a name="l07422"></a><span class="lineno"> 7422</span>&#160;identical to the `class` instance encoding without inheritance and method</div><div class="line"><a name="l07423"></a><span class="lineno"> 7423</span>&#160;declarations, see Section \ref class  for further details.  However, the</div><div class="line"><a name="l07424"></a><span class="lineno"> 7424</span>&#160;encoding and decoding of `struct`s is more efficient compared to</div><div class="line"><a name="l07425"></a><span class="lineno"> 7425</span>&#160;`class` instances due to the lack of inheritance and the requirement by</div><div class="line"><a name="l07426"></a><span class="lineno"> 7426</span>&#160;the serialization routines to check inheritance properties at run time.</div><div class="line"><a name="l07427"></a><span class="lineno"> 7427</span>&#160;</div><div class="line"><a name="l07428"></a><span class="lineno"> 7428</span>&#160;Certain type of fields of a `struct` can be (de)serialized as XML</div><div class="line"><a name="l07429"></a><span class="lineno"> 7429</span>&#160;attributes using the `@` type qualifier.  See Section \ref attributes </div><div class="line"><a name="l07430"></a><span class="lineno"> 7430</span>&#160;for more details.</div><div class="line"><a name="l07431"></a><span class="lineno"> 7431</span>&#160;</div><div class="line"><a name="l07432"></a><span class="lineno"> 7432</span>&#160;See Section \ref idtrans  for more details on the struct/class member field</div><div class="line"><a name="l07433"></a><span class="lineno"> 7433</span>&#160;serialization and the resulting element and attribute qualified forms.</div><div class="line"><a name="l07434"></a><span class="lineno"> 7434</span>&#160;</div><div class="line"><a name="l07435"></a><span class="lineno"> 7435</span>&#160;## Class Instance Serialization        {#class}</div><div class="line"><a name="l07436"></a><span class="lineno"> 7436</span>&#160;</div><div class="line"><a name="l07437"></a><span class="lineno"> 7437</span>&#160;A `class` instance is serialized as an XML Schema complexType (SOAP-encoded compound data type) such that the</div><div class="line"><a name="l07438"></a><span class="lineno"> 7438</span>&#160;`class` name forms the data type&#39;s element name and schema type and the</div><div class="line"><a name="l07439"></a><span class="lineno"> 7439</span>&#160;data member fields are the data type&#39;s accessors. Only the data member fields</div><div class="line"><a name="l07440"></a><span class="lineno"> 7440</span>&#160;are encoded in the SOAP payload. Class methods are not encoded.</div><div class="line"><a name="l07441"></a><span class="lineno"> 7441</span>&#160;</div><div class="line"><a name="l07442"></a><span class="lineno"> 7442</span>&#160;The general form of a `class` declaration is:</div><div class="line"><a name="l07443"></a><span class="lineno"> 7443</span>&#160;</div><div class="line"><a name="l07444"></a><span class="lineno"> 7444</span>&#160;```cpp</div><div class="line"><a name="l07445"></a><span class="lineno"> 7445</span>&#160;class [optional: namespace_prefix__]class_name1 [optional: :[optional: public:] [optional: private:] [optional: protected:] [optional: namespace_prefix__]class_name2] </div><div class="line"><a name="l07446"></a><span class="lineno"> 7446</span>&#160;{ </div><div class="line"><a name="l07447"></a><span class="lineno"> 7447</span>&#160;   [optional: public:] [optional: private:] [optional: protected:] </div><div class="line"><a name="l07448"></a><span class="lineno"> 7448</span>&#160;   field1; </div><div class="line"><a name="l07449"></a><span class="lineno"> 7449</span>&#160;   field2; </div><div class="line"><a name="l07450"></a><span class="lineno"> 7450</span>&#160;   ... </div><div class="line"><a name="l07451"></a><span class="lineno"> 7451</span>&#160;   [optional: public:] [optional: private:] [optional: protected:] </div><div class="line"><a name="l07452"></a><span class="lineno"> 7452</span>&#160;   method1; </div><div class="line"><a name="l07453"></a><span class="lineno"> 7453</span>&#160;   method2; </div><div class="line"><a name="l07454"></a><span class="lineno"> 7454</span>&#160;   ... </div><div class="line"><a name="l07455"></a><span class="lineno"> 7455</span>&#160;}; </div><div class="line"><a name="l07456"></a><span class="lineno"> 7456</span>&#160;```</div><div class="line"><a name="l07457"></a><span class="lineno"> 7457</span>&#160;</div><div class="line"><a name="l07458"></a><span class="lineno"> 7458</span>&#160;where</div><div class="line"><a name="l07459"></a><span class="lineno"> 7459</span>&#160;</div><div class="line"><a name="l07460"></a><span class="lineno"> 7460</span>&#160;* `namespace_prefix__` is the optional namespace prefix of the compound data type (see identifier translation rules \ref idtrans )</div><div class="line"><a name="l07461"></a><span class="lineno"> 7461</span>&#160;</div><div class="line"><a name="l07462"></a><span class="lineno"> 7462</span>&#160;* `class_name1`  is the element name of the compound data type (see identifier translation rules \ref idtrans ).</div><div class="line"><a name="l07463"></a><span class="lineno"> 7463</span>&#160;</div><div class="line"><a name="l07464"></a><span class="lineno"> 7464</span>&#160;* `class_name2`  is an optional base class.</div><div class="line"><a name="l07465"></a><span class="lineno"> 7465</span>&#160;</div><div class="line"><a name="l07466"></a><span class="lineno"> 7466</span>&#160;* `field`        is a field declaration (data member). A field MAY be declared `static` and `const` and MAY be initialized.</div><div class="line"><a name="l07467"></a><span class="lineno"> 7467</span>&#160;</div><div class="line"><a name="l07468"></a><span class="lineno"> 7468</span>&#160;* `method` is a method declaration. A method MAY be declared `virtual`, but abstract methods are not allowed. The method parameter declarations are REQUIRED to have parameter identifier names.</div><div class="line"><a name="l07469"></a><span class="lineno"> 7469</span>&#160;</div><div class="line"><a name="l07470"></a><span class="lineno"> 7470</span>&#160;* [optional: public:] [optional: private:] [optional: protected:] are OPTIONAL. Only members with `public` acces permission can be serialized.</div><div class="line"><a name="l07471"></a><span class="lineno"> 7471</span>&#160;</div><div class="line"><a name="l07472"></a><span class="lineno"> 7472</span>&#160;A class name is REQUIRED to be unique and cannot have the same name as a</div><div class="line"><a name="l07473"></a><span class="lineno"> 7473</span>&#160;`struct`, `enum`, or service operation name specified in the header file</div><div class="line"><a name="l07474"></a><span class="lineno"> 7474</span>&#160;input to the gSOAP `soapcpp2` compiler.  The reason is that service operation requests are</div><div class="line"><a name="l07475"></a><span class="lineno"> 7475</span>&#160;encoded similarly to class instances in SOAP and they are in principle</div><div class="line"><a name="l07476"></a><span class="lineno"> 7476</span>&#160;undistinguishable (the method parameters are encoded just as the fields of a</div><div class="line"><a name="l07477"></a><span class="lineno"> 7477</span>&#160;`class`).</div><div class="line"><a name="l07478"></a><span class="lineno"> 7478</span>&#160;</div><div class="line"><a name="l07479"></a><span class="lineno"> 7479</span>&#160;Only single inheritance is supported by the gSOAP `soapcpp2` compiler. Multiple</div><div class="line"><a name="l07480"></a><span class="lineno"> 7480</span>&#160;inheritance is not supported, because of the limitations of the SOAP protocol.</div><div class="line"><a name="l07481"></a><span class="lineno"> 7481</span>&#160;</div><div class="line"><a name="l07482"></a><span class="lineno"> 7482</span>&#160;If a constructor method is present, there MUST also be a constructor</div><div class="line"><a name="l07483"></a><span class="lineno"> 7483</span>&#160;declaration with empty parameter list.</div><div class="line"><a name="l07484"></a><span class="lineno"> 7484</span>&#160;</div><div class="line"><a name="l07485"></a><span class="lineno"> 7485</span>&#160;Classes should be declared &quot;volatile&quot; if you don&#39;t want gSOAP to add serialization methods to these classes, see Section \ref volatile  for more details.</div><div class="line"><a name="l07486"></a><span class="lineno"> 7486</span>&#160;</div><div class="line"><a name="l07487"></a><span class="lineno"> 7487</span>&#160;Class templates are not supported by the gSOAP `soapcpp2` compiler, but you can use STL containers,</div><div class="line"><a name="l07488"></a><span class="lineno"> 7488</span>&#160;see Section \ref templates . You can also define your own</div><div class="line"><a name="l07489"></a><span class="lineno"> 7489</span>&#160;containers similar to STL containers.</div><div class="line"><a name="l07490"></a><span class="lineno"> 7490</span>&#160;</div><div class="line"><a name="l07491"></a><span class="lineno"> 7491</span>&#160;Certain type of fields of a `struct` can be (de)serialized as XML</div><div class="line"><a name="l07492"></a><span class="lineno"> 7492</span>&#160;attributes using the `@` type qualifier.  See Section \ref attributes </div><div class="line"><a name="l07493"></a><span class="lineno"> 7493</span>&#160;for more details.</div><div class="line"><a name="l07494"></a><span class="lineno"> 7494</span>&#160;</div><div class="line"><a name="l07495"></a><span class="lineno"> 7495</span>&#160;See Section \ref idtrans  for more details on the struct/class member field</div><div class="line"><a name="l07496"></a><span class="lineno"> 7496</span>&#160;serialization and the resulting element and attribute qualified forms.</div><div class="line"><a name="l07497"></a><span class="lineno"> 7497</span>&#160;</div><div class="line"><a name="l07498"></a><span class="lineno"> 7498</span>&#160;Arrays may be embedded within a class (and struct) using a pointer field and</div><div class="line"><a name="l07499"></a><span class="lineno"> 7499</span>&#160;size information, see Section \ref list . This defines what is sometimes</div><div class="line"><a name="l07500"></a><span class="lineno"> 7500</span>&#160;referred to in SOAP as &quot;generics&quot;.</div><div class="line"><a name="l07501"></a><span class="lineno"> 7501</span>&#160;</div><div class="line"><a name="l07502"></a><span class="lineno"> 7502</span>&#160;Void pointers may be used in a class (or struct), but you have to add a type</div><div class="line"><a name="l07503"></a><span class="lineno"> 7503</span>&#160;field so the gSOAP runtime can determine the type of object pointed to, see</div><div class="line"><a name="l07504"></a><span class="lineno"> 7504</span>&#160;Section \ref void .</div><div class="line"><a name="l07505"></a><span class="lineno"> 7505</span>&#160;</div><div class="line"><a name="l07506"></a><span class="lineno"> 7506</span>&#160;A `class` instance is encoded as:</div><div class="line"><a name="l07507"></a><span class="lineno"> 7507</span>&#160;</div><div class="line"><a name="l07508"></a><span class="lineno"> 7508</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l07509"></a><span class="lineno"> 7509</span>&#160;```xml</div><div class="line"><a name="l07510"></a><span class="lineno"> 7510</span>&#160;&lt;[optional: namespace-prefix:]class-name xsi:type=&quot;[optional: namespace-prefix:]class-name&quot;&gt; </div><div class="line"><a name="l07511"></a><span class="lineno"> 7511</span>&#160;&lt;basefield-name1 xsi:type=&quot;...&quot;&gt;...&lt;/basefield-name1&gt; </div><div class="line"><a name="l07512"></a><span class="lineno"> 7512</span>&#160;&lt;basefield-name2 xsi:type=&quot;...&quot;&gt;...&lt;/basefield-name2&gt; </div><div class="line"><a name="l07513"></a><span class="lineno"> 7513</span>&#160;... </div><div class="line"><a name="l07514"></a><span class="lineno"> 7514</span>&#160;&lt;field-name1 xsi:type=&quot;...&quot;&gt;...&lt;/field-name1&gt; </div><div class="line"><a name="l07515"></a><span class="lineno"> 7515</span>&#160;&lt;field-name2 xsi:type=&quot;...&quot;&gt;...&lt;/field-name2&gt; </div><div class="line"><a name="l07516"></a><span class="lineno"> 7516</span>&#160;... </div><div class="line"><a name="l07517"></a><span class="lineno"> 7517</span>&#160;&lt;/[optional: namespace-prefix:]class-name&gt;</div><div class="line"><a name="l07518"></a><span class="lineno"> 7518</span>&#160;```</div><div class="line"><a name="l07519"></a><span class="lineno"> 7519</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l07520"></a><span class="lineno"> 7520</span>&#160;</div><div class="line"><a name="l07521"></a><span class="lineno"> 7521</span>&#160;where the *`field-name`* accessors have element-name representations of the</div><div class="line"><a name="l07522"></a><span class="lineno"> 7522</span>&#160;class fields and the *`basefield-name`* accessors have element-name</div><div class="line"><a name="l07523"></a><span class="lineno"> 7523</span>&#160;representations of the base class fields. (The optional parts resulting from</div><div class="line"><a name="l07524"></a><span class="lineno"> 7524</span>&#160;the specification are shown enclosed in [optional: ].)</div><div class="line"><a name="l07525"></a><span class="lineno"> 7525</span>&#160;</div><div class="line"><a name="l07526"></a><span class="lineno"> 7526</span>&#160;The decoding of a class instance allows any ordering of the accessors in the</div><div class="line"><a name="l07527"></a><span class="lineno"> 7527</span>&#160;SOAP payload. However, if a base class field name is identical to a derived</div><div class="line"><a name="l07528"></a><span class="lineno"> 7528</span>&#160;class field name because the field is overloaded, the base class field name</div><div class="line"><a name="l07529"></a><span class="lineno"> 7529</span>&#160;MUST precede the derived class field name in the SOAP payload for decoding.</div><div class="line"><a name="l07530"></a><span class="lineno"> 7530</span>&#160;gSOAP guarantees this, but interoperability with other SOAP implementations is</div><div class="line"><a name="l07531"></a><span class="lineno"> 7531</span>&#160;cannot be guaranteed.</div><div class="line"><a name="l07532"></a><span class="lineno"> 7532</span>&#160;</div><div class="line"><a name="l07533"></a><span class="lineno"> 7533</span>&#160;### Example</div><div class="line"><a name="l07534"></a><span class="lineno"> 7534</span>&#160;</div><div class="line"><a name="l07535"></a><span class="lineno"> 7535</span>&#160;The following example declares a base class `ns__Object` and a derived class `ns__Shape`:</div><div class="line"><a name="l07536"></a><span class="lineno"> 7536</span>&#160;</div><div class="line"><a name="l07537"></a><span class="lineno"> 7537</span>&#160;```cpp</div><div class="line"><a name="l07538"></a><span class="lineno"> 7538</span>&#160;// Contents of file &quot;shape.h&quot;: </div><div class="line"><a name="l07539"></a><span class="lineno"> 7539</span>&#160;class ns__Object </div><div class="line"><a name="l07540"></a><span class="lineno"> 7540</span>&#160;{ </div><div class="line"><a name="l07541"></a><span class="lineno"> 7541</span>&#160;   public: </div><div class="line"><a name="l07542"></a><span class="lineno"> 7542</span>&#160;   char *name; </div><div class="line"><a name="l07543"></a><span class="lineno"> 7543</span>&#160;}; </div><div class="line"><a name="l07544"></a><span class="lineno"> 7544</span>&#160;class ns__Shape : public ns__Object </div><div class="line"><a name="l07545"></a><span class="lineno"> 7545</span>&#160;{ </div><div class="line"><a name="l07546"></a><span class="lineno"> 7546</span>&#160;   public: </div><div class="line"><a name="l07547"></a><span class="lineno"> 7547</span>&#160;   int sides; </div><div class="line"><a name="l07548"></a><span class="lineno"> 7548</span>&#160;   enum ns__Color {Red, Green, Blue} color; </div><div class="line"><a name="l07549"></a><span class="lineno"> 7549</span>&#160;   ns__Shape(); </div><div class="line"><a name="l07550"></a><span class="lineno"> 7550</span>&#160;   ns__Shape(int sides, enum ns__Green color); </div><div class="line"><a name="l07551"></a><span class="lineno"> 7551</span>&#160;   ~ns__Shape(); </div><div class="line"><a name="l07552"></a><span class="lineno"> 7552</span>&#160;};</div><div class="line"><a name="l07553"></a><span class="lineno"> 7553</span>&#160;```</div><div class="line"><a name="l07554"></a><span class="lineno"> 7554</span>&#160;</div><div class="line"><a name="l07555"></a><span class="lineno"> 7555</span>&#160;The implementation of the methods of `class ns__Shape` must not be part of the header file and need to be defined elsewhere.</div><div class="line"><a name="l07556"></a><span class="lineno"> 7556</span>&#160;</div><div class="line"><a name="l07557"></a><span class="lineno"> 7557</span>&#160;An instance of `class ns__Shape` with name Triangle, 3 sides, and color Green is encoded as:</div><div class="line"><a name="l07558"></a><span class="lineno"> 7558</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l07559"></a><span class="lineno"> 7559</span>&#160;</div><div class="line"><a name="l07560"></a><span class="lineno"> 7560</span>&#160;```xml</div><div class="line"><a name="l07561"></a><span class="lineno"> 7561</span>&#160;&lt;ns:Shape xsi:type=&quot;ns:Shape&quot;&gt; </div><div class="line"><a name="l07562"></a><span class="lineno"> 7562</span>&#160;&lt;name xsi:type=&quot;string&quot;&gt;Triangle&lt;/name&gt; </div><div class="line"><a name="l07563"></a><span class="lineno"> 7563</span>&#160;&lt;sides xsi:type=&quot;int&quot;&gt;3&lt;/sides&gt; </div><div class="line"><a name="l07564"></a><span class="lineno"> 7564</span>&#160;&lt;color xsi:type=&quot;ns:Color&quot;&gt;Green&lt;/color&gt; </div><div class="line"><a name="l07565"></a><span class="lineno"> 7565</span>&#160;&lt;/ns:shape&gt;</div><div class="line"><a name="l07566"></a><span class="lineno"> 7566</span>&#160;```</div><div class="line"><a name="l07567"></a><span class="lineno"> 7567</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l07568"></a><span class="lineno"> 7568</span>&#160;</div><div class="line"><a name="l07569"></a><span class="lineno"> 7569</span>&#160;The namespace URI of the namespace prefix *`ns`* must be defined by a namespace mapping table, see Section \ref nstable .</div><div class="line"><a name="l07570"></a><span class="lineno"> 7570</span>&#160;</div><div class="line"><a name="l07571"></a><span class="lineno"> 7571</span>&#160;### Initialized static const Fields</div><div class="line"><a name="l07572"></a><span class="lineno"> 7572</span>&#160;</div><div class="line"><a name="l07573"></a><span class="lineno"> 7573</span>&#160;A data member field of a class declared as `static const` is initialized</div><div class="line"><a name="l07574"></a><span class="lineno"> 7574</span>&#160;with a constant value at compile time. This field is encoded in the</div><div class="line"><a name="l07575"></a><span class="lineno"> 7575</span>&#160;serialization process, but is not decoded in the deserialization process. For</div><div class="line"><a name="l07576"></a><span class="lineno"> 7576</span>&#160;example:</div><div class="line"><a name="l07577"></a><span class="lineno"> 7577</span>&#160;</div><div class="line"><a name="l07578"></a><span class="lineno"> 7578</span>&#160;```cpp</div><div class="line"><a name="l07579"></a><span class="lineno"> 7579</span>&#160;// Contents of file &quot;triangle.h&quot;: </div><div class="line"><a name="l07580"></a><span class="lineno"> 7580</span>&#160;class ns__Triangle : public ns__Object </div><div class="line"><a name="l07581"></a><span class="lineno"> 7581</span>&#160;{ </div><div class="line"><a name="l07582"></a><span class="lineno"> 7582</span>&#160;   public: </div><div class="line"><a name="l07583"></a><span class="lineno"> 7583</span>&#160;  int size; </div><div class="line"><a name="l07584"></a><span class="lineno"> 7584</span>&#160;  static const int sides = 3; </div><div class="line"><a name="l07585"></a><span class="lineno"> 7585</span>&#160;};</div><div class="line"><a name="l07586"></a><span class="lineno"> 7586</span>&#160;```</div><div class="line"><a name="l07587"></a><span class="lineno"> 7587</span>&#160;</div><div class="line"><a name="l07588"></a><span class="lineno"> 7588</span>&#160;An instance of `class ns__Triangle` is encoded in SOAP as:</div><div class="line"><a name="l07589"></a><span class="lineno"> 7589</span>&#160;</div><div class="line"><a name="l07590"></a><span class="lineno"> 7590</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l07591"></a><span class="lineno"> 7591</span>&#160;```xml</div><div class="line"><a name="l07592"></a><span class="lineno"> 7592</span>&#160;&lt;ns:Triangle xsi:type=&quot;ns:Triangle&quot;&gt; </div><div class="line"><a name="l07593"></a><span class="lineno"> 7593</span>&#160;&lt;name xsi:type=&quot;string&quot;&gt;Triangle&lt;/name&gt; </div><div class="line"><a name="l07594"></a><span class="lineno"> 7594</span>&#160;&lt;size xsi:type=&quot;int&quot;&gt;15&lt;/size&gt; </div><div class="line"><a name="l07595"></a><span class="lineno"> 7595</span>&#160;&lt;sides xsi:type=&quot;int&quot;&gt;3&gt;/sides&gt; </div><div class="line"><a name="l07596"></a><span class="lineno"> 7596</span>&#160;&lt;/ns:Triangle&gt;</div><div class="line"><a name="l07597"></a><span class="lineno"> 7597</span>&#160;```</div><div class="line"><a name="l07598"></a><span class="lineno"> 7598</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l07599"></a><span class="lineno"> 7599</span>&#160;</div><div class="line"><a name="l07600"></a><span class="lineno"> 7600</span>&#160;Decoding will ignore the `sides` field&#39;s value.</div><div class="line"><a name="l07601"></a><span class="lineno"> 7601</span>&#160;</div><div class="line"><a name="l07602"></a><span class="lineno"> 7602</span>&#160;@warning The current gSOAP implementation does not support encoding</div><div class="line"><a name="l07603"></a><span class="lineno"> 7603</span>&#160;`static const` fields, due to C++ compiler compatibility differences.</div><div class="line"><a name="l07604"></a><span class="lineno"> 7604</span>&#160;This feature may be provided the future.</div><div class="line"><a name="l07605"></a><span class="lineno"> 7605</span>&#160;</div><div class="line"><a name="l07606"></a><span class="lineno"> 7606</span>&#160;### Class Methods</div><div class="line"><a name="l07607"></a><span class="lineno"> 7607</span>&#160;</div><div class="line"><a name="l07608"></a><span class="lineno"> 7608</span>&#160;A `class` declaration in the header file input to the gSOAP `soapcpp2` compiler MAY</div><div class="line"><a name="l07609"></a><span class="lineno"> 7609</span>&#160;include method declarations.  The method implementations MUST NOT be part of</div><div class="line"><a name="l07610"></a><span class="lineno"> 7610</span>&#160;the header file but are required to be defined in another C++ source that is</div><div class="line"><a name="l07611"></a><span class="lineno"> 7611</span>&#160;externally linked with the application. This convention is also used for the</div><div class="line"><a name="l07612"></a><span class="lineno"> 7612</span>&#160;constructors and destructors of the `class`.</div><div class="line"><a name="l07613"></a><span class="lineno"> 7613</span>&#160;</div><div class="line"><a name="l07614"></a><span class="lineno"> 7614</span>&#160;Dynamic binding is supported, so a method MAY be declared `virtual`.</div><div class="line"><a name="l07615"></a><span class="lineno"> 7615</span>&#160;</div><div class="line"><a name="l07616"></a><span class="lineno"> 7616</span>&#160;### Getter and Setter Methods        {#gettersetter}</div><div class="line"><a name="l07617"></a><span class="lineno"> 7617</span>&#160;</div><div class="line"><a name="l07618"></a><span class="lineno"> 7618</span>&#160;Setter and getter methods are invoked at run time upon serialization and</div><div class="line"><a name="l07619"></a><span class="lineno"> 7619</span>&#160;deserialization of class instances, respectively. The use of setter and getter methods adds more flexibility to the serialization and deserialization process.</div><div class="line"><a name="l07620"></a><span class="lineno"> 7620</span>&#160;</div><div class="line"><a name="l07621"></a><span class="lineno"> 7621</span>&#160;A setter method is called in the serialization phase from the virtual</div><div class="line"><a name="l07622"></a><span class="lineno"> 7622</span>&#160;`soap_serialization` method generated by the gSOAP `soapcpp2` compiler.  You can use</div><div class="line"><a name="l07623"></a><span class="lineno"> 7623</span>&#160;setter methods to process a class instance just before it is serialized. A</div><div class="line"><a name="l07624"></a><span class="lineno"> 7624</span>&#160;setter method can be used to convert application data, such as translating</div><div class="line"><a name="l07625"></a><span class="lineno"> 7625</span>&#160;transient application data into serializable data, for example. You can also</div><div class="line"><a name="l07626"></a><span class="lineno"> 7626</span>&#160;use setter methods to retrieve dynamic content and use it to update a class</div><div class="line"><a name="l07627"></a><span class="lineno"> 7627</span>&#160;instance right before serialization. Remember setters</div><div class="line"><a name="l07628"></a><span class="lineno"> 7628</span>&#160;as &quot;set to serialize&quot; operations.</div><div class="line"><a name="l07629"></a><span class="lineno"> 7629</span>&#160;</div><div class="line"><a name="l07630"></a><span class="lineno"> 7630</span>&#160;Getter methods are invoked after deserialization of the instance. You can use</div><div class="line"><a name="l07631"></a><span class="lineno"> 7631</span>&#160;them to adjust the contents of class instances after all their members have been</div><div class="line"><a name="l07632"></a><span class="lineno"> 7632</span>&#160;deserialized. Getters can be used to convert deserialized members into</div><div class="line"><a name="l07633"></a><span class="lineno"> 7633</span>&#160;transient members and even invoke methods to process the deserialized data on</div><div class="line"><a name="l07634"></a><span class="lineno"> 7634</span>&#160;the fly.</div><div class="line"><a name="l07635"></a><span class="lineno"> 7635</span>&#160;</div><div class="line"><a name="l07636"></a><span class="lineno"> 7636</span>&#160;Getter and setter methods have the following signature:</div><div class="line"><a name="l07637"></a><span class="lineno"> 7637</span>&#160;</div><div class="line"><a name="l07638"></a><span class="lineno"> 7638</span>&#160;```cpp</div><div class="line"><a name="l07639"></a><span class="lineno"> 7639</span>&#160;[optional: virtual] int get(struct soap *soap) [optional: const]; </div><div class="line"><a name="l07640"></a><span class="lineno"> 7640</span>&#160;[optional: virtual] int set(struct soap *soap);</div><div class="line"><a name="l07641"></a><span class="lineno"> 7641</span>&#160;```</div><div class="line"><a name="l07642"></a><span class="lineno"> 7642</span>&#160;</div><div class="line"><a name="l07643"></a><span class="lineno"> 7643</span>&#160;The active soap struct will be passed to the `get` and `set` methods. The methods should return `SOAP_OK` when successful. A setter method should prepare the contents of the class instance for serialization. A getter method should process the instance after deserialization.</div><div class="line"><a name="l07644"></a><span class="lineno"> 7644</span>&#160;</div><div class="line"><a name="l07645"></a><span class="lineno"> 7645</span>&#160;Here is an example of a base64 binary class:</div><div class="line"><a name="l07646"></a><span class="lineno"> 7646</span>&#160;</div><div class="line"><a name="l07647"></a><span class="lineno"> 7647</span>&#160;```cpp</div><div class="line"><a name="l07648"></a><span class="lineno"> 7648</span>&#160;class xsd__base64Binary </div><div class="line"><a name="l07649"></a><span class="lineno"> 7649</span>&#160;{ public: </div><div class="line"><a name="l07650"></a><span class="lineno"> 7650</span>&#160;   unsigned char *__ptr; </div><div class="line"><a name="l07651"></a><span class="lineno"> 7651</span>&#160;   int __size; </div><div class="line"><a name="l07652"></a><span class="lineno"> 7652</span>&#160;   int get(struct soap *soap); </div><div class="line"><a name="l07653"></a><span class="lineno"> 7653</span>&#160;   int set(struct soap *soap); </div><div class="line"><a name="l07654"></a><span class="lineno"> 7654</span>&#160;};</div><div class="line"><a name="l07655"></a><span class="lineno"> 7655</span>&#160;```</div><div class="line"><a name="l07656"></a><span class="lineno"> 7656</span>&#160;</div><div class="line"><a name="l07657"></a><span class="lineno"> 7657</span>&#160;Suppose that the type and options members of the attachment should be set when</div><div class="line"><a name="l07658"></a><span class="lineno"> 7658</span>&#160;the class is about to be serialized. This can be accomplished with the</div><div class="line"><a name="l07659"></a><span class="lineno"> 7659</span>&#160;`set` method from the information provided by the `__ptr` to the data</div><div class="line"><a name="l07660"></a><span class="lineno"> 7660</span>&#160;and the soap struct passed to the `set` method (you can pass data via the</div><div class="line"><a name="l07661"></a><span class="lineno"> 7661</span>&#160;`void *soap.user` field).</div><div class="line"><a name="l07662"></a><span class="lineno"> 7662</span>&#160;</div><div class="line"><a name="l07663"></a><span class="lineno"> 7663</span>&#160;The `get` method is invoked after the base64 data has been processed. You</div><div class="line"><a name="l07664"></a><span class="lineno"> 7664</span>&#160;can use it for post-processing purposes.</div><div class="line"><a name="l07665"></a><span class="lineno"> 7665</span>&#160;</div><div class="line"><a name="l07666"></a><span class="lineno"> 7666</span>&#160;Here is another example. It defines a primitive `update` type. The class is a wrapper for the `time_t` type, see Section \ref primclass . Therefore, elements of this type contain *`xsd:dateType`* data.</div><div class="line"><a name="l07667"></a><span class="lineno"> 7667</span>&#160;</div><div class="line"><a name="l07668"></a><span class="lineno"> 7668</span>&#160;```cpp</div><div class="line"><a name="l07669"></a><span class="lineno"> 7669</span>&#160;class update </div><div class="line"><a name="l07670"></a><span class="lineno"> 7670</span>&#160;{ public: </div><div class="line"><a name="l07671"></a><span class="lineno"> 7671</span>&#160;   time_t __item; </div><div class="line"><a name="l07672"></a><span class="lineno"> 7672</span>&#160;   int set(struct soap *soap); </div><div class="line"><a name="l07673"></a><span class="lineno"> 7673</span>&#160;};</div><div class="line"><a name="l07674"></a><span class="lineno"> 7674</span>&#160;```</div><div class="line"><a name="l07675"></a><span class="lineno"> 7675</span>&#160;</div><div class="line"><a name="l07676"></a><span class="lineno"> 7676</span>&#160;The setter method assigns the current time:</div><div class="line"><a name="l07677"></a><span class="lineno"> 7677</span>&#160;</div><div class="line"><a name="l07678"></a><span class="lineno"> 7678</span>&#160;```cpp</div><div class="line"><a name="l07679"></a><span class="lineno"> 7679</span>&#160;int update::set(struct soap *soap) </div><div class="line"><a name="l07680"></a><span class="lineno"> 7680</span>&#160;{ </div><div class="line"><a name="l07681"></a><span class="lineno"> 7681</span>&#160;   this-&gt;__item = time(NULL); </div><div class="line"><a name="l07682"></a><span class="lineno"> 7682</span>&#160;   return SOAP_OK; </div><div class="line"><a name="l07683"></a><span class="lineno"> 7683</span>&#160;}</div><div class="line"><a name="l07684"></a><span class="lineno"> 7684</span>&#160;```</div><div class="line"><a name="l07685"></a><span class="lineno"> 7685</span>&#160;</div><div class="line"><a name="l07686"></a><span class="lineno"> 7686</span>&#160;Therefore, serialization results in the inclusion of a time stamp in XML.</div><div class="line"><a name="l07687"></a><span class="lineno"> 7687</span>&#160;</div><div class="line"><a name="l07688"></a><span class="lineno"> 7688</span>&#160;@warning a `get` method is invoked only when the XML element with its data</div><div class="line"><a name="l07689"></a><span class="lineno"> 7689</span>&#160;was completely parsed. The method is not invoked when the element is an *`xsi:nil`* element or has an </div><div class="line"><a name="l07690"></a><span class="lineno"> 7690</span>&#160;*`href`* attribute.</div><div class="line"><a name="l07691"></a><span class="lineno"> 7691</span>&#160;</div><div class="line"><a name="l07692"></a><span class="lineno"> 7692</span>&#160;@warning The `soap_out` method of a class calls the setter (when</div><div class="line"><a name="l07693"></a><span class="lineno"> 7693</span>&#160;provided). However, the `soap_out` method is declared `const`</div><div class="line"><a name="l07694"></a><span class="lineno"> 7694</span>&#160;while the setter should be allowed to modify the contents of the class</div><div class="line"><a name="l07695"></a><span class="lineno"> 7695</span>&#160;instance. Therefore, the gSOAP-generated code recasts the instance and the</div><div class="line"><a name="l07696"></a><span class="lineno"> 7696</span>&#160;`const` is removed when invoking the setter.</div><div class="line"><a name="l07697"></a><span class="lineno"> 7697</span>&#160;</div><div class="line"><a name="l07698"></a><span class="lineno"> 7698</span>&#160;### Streaming XML with Getter and Setter Methods        {#streaming}</div><div class="line"><a name="l07699"></a><span class="lineno"> 7699</span>&#160;</div><div class="line"><a name="l07700"></a><span class="lineno"> 7700</span>&#160;Getter methods enable streaming XML operations. A getter method is invoked</div><div class="line"><a name="l07701"></a><span class="lineno"> 7701</span>&#160;when the object is deserialized and the rest of the SOAP/XML message has not</div><div class="line"><a name="l07702"></a><span class="lineno"> 7702</span>&#160;been processed yet. For example, you can add a getter method to the SOAP Header</div><div class="line"><a name="l07703"></a><span class="lineno"> 7703</span>&#160;class to implement header processing logic that is activated as soon as the</div><div class="line"><a name="l07704"></a><span class="lineno"> 7704</span>&#160;SOAP Header is received.  An example code is shown below:</div><div class="line"><a name="l07705"></a><span class="lineno"> 7705</span>&#160;</div><div class="line"><a name="l07706"></a><span class="lineno"> 7706</span>&#160;```cpp</div><div class="line"><a name="l07707"></a><span class="lineno"> 7707</span>&#160;class h__Authentication </div><div class="line"><a name="l07708"></a><span class="lineno"> 7708</span>&#160;{ public: </div><div class="line"><a name="l07709"></a><span class="lineno"> 7709</span>&#160;   char *id; </div><div class="line"><a name="l07710"></a><span class="lineno"> 7710</span>&#160;   int get(struct soap *soap); </div><div class="line"><a name="l07711"></a><span class="lineno"> 7711</span>&#160;}; </div><div class="line"><a name="l07712"></a><span class="lineno"> 7712</span>&#160;class SOAP_ENV__Header </div><div class="line"><a name="l07713"></a><span class="lineno"> 7713</span>&#160;{ public: </div><div class="line"><a name="l07714"></a><span class="lineno"> 7714</span>&#160;   h__Authentication *h__authentication; </div><div class="line"><a name="l07715"></a><span class="lineno"> 7715</span>&#160;};</div><div class="line"><a name="l07716"></a><span class="lineno"> 7716</span>&#160;```</div><div class="line"><a name="l07717"></a><span class="lineno"> 7717</span>&#160;</div><div class="line"><a name="l07718"></a><span class="lineno"> 7718</span>&#160;The `Authentication` SOAP Header field is instantiated and decoded. After</div><div class="line"><a name="l07719"></a><span class="lineno"> 7719</span>&#160;decoding, the getter method is invoked, which can be used to check the `id`</div><div class="line"><a name="l07720"></a><span class="lineno"> 7720</span>&#160;before the rest of the SOAP message is processed.</div><div class="line"><a name="l07721"></a><span class="lineno"> 7721</span>&#160;</div><div class="line"><a name="l07722"></a><span class="lineno"> 7722</span>&#160;### Polymorphism, Derived Classes, and Dynamic Binding        {#polymorph}</div><div class="line"><a name="l07723"></a><span class="lineno"> 7723</span>&#160;</div><div class="line"><a name="l07724"></a><span class="lineno"> 7724</span>&#160;Interoperability between client and service applications developed with gSOAP</div><div class="line"><a name="l07725"></a><span class="lineno"> 7725</span>&#160;is established even when clients and/or services use derived classes instead of</div><div class="line"><a name="l07726"></a><span class="lineno"> 7726</span>&#160;the base classes used in the declaration of the service operation parameters.  A</div><div class="line"><a name="l07727"></a><span class="lineno"> 7727</span>&#160;client application MAY use pointers to instances of derived classes for the</div><div class="line"><a name="l07728"></a><span class="lineno"> 7728</span>&#160;input parameters of a service operation. If the service was compiled with a</div><div class="line"><a name="l07729"></a><span class="lineno"> 7729</span>&#160;declaration and implementation of the derived class, the service operation base</div><div class="line"><a name="l07730"></a><span class="lineno"> 7730</span>&#160;class input parameters are demarshalled and a derived class instance is created</div><div class="line"><a name="l07731"></a><span class="lineno"> 7731</span>&#160;instead of a base class instance. If the service did not include a declaration</div><div class="line"><a name="l07732"></a><span class="lineno"> 7732</span>&#160;of the derived class, the derived class fields are ignored and a base class</div><div class="line"><a name="l07733"></a><span class="lineno"> 7733</span>&#160;instance is created. Therefore, interoperability is guaranteed even when the</div><div class="line"><a name="l07734"></a><span class="lineno"> 7734</span>&#160;client sends an instance of a derived classes and when a service returns an</div><div class="line"><a name="l07735"></a><span class="lineno"> 7735</span>&#160;instance of a derived class.</div><div class="line"><a name="l07736"></a><span class="lineno"> 7736</span>&#160;</div><div class="line"><a name="l07737"></a><span class="lineno"> 7737</span>&#160;The following example declares Base and Derived classes and a service operation</div><div class="line"><a name="l07738"></a><span class="lineno"> 7738</span>&#160;that takes a pointer to a Base class instance and returns a Base class</div><div class="line"><a name="l07739"></a><span class="lineno"> 7739</span>&#160;instance:</div><div class="line"><a name="l07740"></a><span class="lineno"> 7740</span>&#160;</div><div class="line"><a name="l07741"></a><span class="lineno"> 7741</span>&#160;```cpp</div><div class="line"><a name="l07742"></a><span class="lineno"> 7742</span>&#160;// Contents of file &quot;derived.h&quot; </div><div class="line"><a name="l07743"></a><span class="lineno"> 7743</span>&#160;class Base </div><div class="line"><a name="l07744"></a><span class="lineno"> 7744</span>&#160;{ </div><div class="line"><a name="l07745"></a><span class="lineno"> 7745</span>&#160;   public: </div><div class="line"><a name="l07746"></a><span class="lineno"> 7746</span>&#160;   char *name; </div><div class="line"><a name="l07747"></a><span class="lineno"> 7747</span>&#160;   Base(); </div><div class="line"><a name="l07748"></a><span class="lineno"> 7748</span>&#160;   virtual void print(); </div><div class="line"><a name="l07749"></a><span class="lineno"> 7749</span>&#160;}; </div><div class="line"><a name="l07750"></a><span class="lineno"> 7750</span>&#160;class Derived : public Base </div><div class="line"><a name="l07751"></a><span class="lineno"> 7751</span>&#160;{ </div><div class="line"><a name="l07752"></a><span class="lineno"> 7752</span>&#160;   public: </div><div class="line"><a name="l07753"></a><span class="lineno"> 7753</span>&#160;   int num; </div><div class="line"><a name="l07754"></a><span class="lineno"> 7754</span>&#160;   Derived(); </div><div class="line"><a name="l07755"></a><span class="lineno"> 7755</span>&#160;   virtual void print(); </div><div class="line"><a name="l07756"></a><span class="lineno"> 7756</span>&#160;}; </div><div class="line"><a name="l07757"></a><span class="lineno"> 7757</span>&#160;int method(Base *in, struct methodResponse { Base *out; } &amp;result);</div><div class="line"><a name="l07758"></a><span class="lineno"> 7758</span>&#160;```</div><div class="line"><a name="l07759"></a><span class="lineno"> 7759</span>&#160;</div><div class="line"><a name="l07760"></a><span class="lineno"> 7760</span>&#160;This header file specification is processed by the gSOAP `soapcpp2` compiler to produce the stub and skeleton routines which are used to implement a client and service.</div><div class="line"><a name="l07761"></a><span class="lineno"> 7761</span>&#160;The pointer of the service operation is also allowed to point to Derived class instances and these instances will be marshalled as Derived class instances and send to a service, which is in accord to the usual semantics of parameter passing in C++ with dynamic binding.</div><div class="line"><a name="l07762"></a><span class="lineno"> 7762</span>&#160;</div><div class="line"><a name="l07763"></a><span class="lineno"> 7763</span>&#160;The Base and Derived class method implementations are:</div><div class="line"><a name="l07764"></a><span class="lineno"> 7764</span>&#160;</div><div class="line"><a name="l07765"></a><span class="lineno"> 7765</span>&#160;```cpp</div><div class="line"><a name="l07766"></a><span class="lineno"> 7766</span>&#160;// Method implementations of the Base and Derived classes: </div><div class="line"><a name="l07767"></a><span class="lineno"> 7767</span>&#160;#include &quot;soapH.h&quot; </div><div class="line"><a name="l07768"></a><span class="lineno"> 7768</span>&#160;... </div><div class="line"><a name="l07769"></a><span class="lineno"> 7769</span>&#160;Base::Base() </div><div class="line"><a name="l07770"></a><span class="lineno"> 7770</span>&#160;{ </div><div class="line"><a name="l07771"></a><span class="lineno"> 7771</span>&#160;   cout &lt;&lt; &quot;created a Base class instance&quot; &lt;&lt; endl; </div><div class="line"><a name="l07772"></a><span class="lineno"> 7772</span>&#160;} </div><div class="line"><a name="l07773"></a><span class="lineno"> 7773</span>&#160;Derived::Derived() </div><div class="line"><a name="l07774"></a><span class="lineno"> 7774</span>&#160;{</div><div class="line"><a name="l07775"></a><span class="lineno"> 7775</span>&#160;   cout &lt;&lt; &quot;created a Derived class instance&quot; &lt;&lt; endl; </div><div class="line"><a name="l07776"></a><span class="lineno"> 7776</span>&#160;} </div><div class="line"><a name="l07777"></a><span class="lineno"> 7777</span>&#160;Base::print() </div><div class="line"><a name="l07778"></a><span class="lineno"> 7778</span>&#160;{ </div><div class="line"><a name="l07779"></a><span class="lineno"> 7779</span>&#160;   cout &lt;&lt; &quot;print(): Base class instance &quot; &lt;&lt; name &lt;&lt; endl; </div><div class="line"><a name="l07780"></a><span class="lineno"> 7780</span>&#160;} </div><div class="line"><a name="l07781"></a><span class="lineno"> 7781</span>&#160;Derived::print() </div><div class="line"><a name="l07782"></a><span class="lineno"> 7782</span>&#160;{ </div><div class="line"><a name="l07783"></a><span class="lineno"> 7783</span>&#160;   cout &lt;&lt; &quot;print(): Derived class instance &quot; &lt;&lt; name &lt;&lt; &quot; &quot; &lt;&lt; num &lt;&lt; endl; </div><div class="line"><a name="l07784"></a><span class="lineno"> 7784</span>&#160;}</div><div class="line"><a name="l07785"></a><span class="lineno"> 7785</span>&#160;```</div><div class="line"><a name="l07786"></a><span class="lineno"> 7786</span>&#160;</div><div class="line"><a name="l07787"></a><span class="lineno"> 7787</span>&#160;Below is an example `CLIENT` application that creates a Derived class instance that is passed as the input parameter of the service operation:</div><div class="line"><a name="l07788"></a><span class="lineno"> 7788</span>&#160;</div><div class="line"><a name="l07789"></a><span class="lineno"> 7789</span>&#160;```cpp</div><div class="line"><a name="l07790"></a><span class="lineno"> 7790</span>&#160;// CLIENT </div><div class="line"><a name="l07791"></a><span class="lineno"> 7791</span>&#160;#include &quot;soapH.h&quot; </div><div class="line"><a name="l07792"></a><span class="lineno"> 7792</span>&#160;int main() </div><div class="line"><a name="l07793"></a><span class="lineno"> 7793</span>&#160;{ </div><div class="line"><a name="l07794"></a><span class="lineno"> 7794</span>&#160;   struct soap soap; </div><div class="line"><a name="l07795"></a><span class="lineno"> 7795</span>&#160;   soap_init(&amp;soap); </div><div class="line"><a name="l07796"></a><span class="lineno"> 7796</span>&#160;   Derived obj1; </div><div class="line"><a name="l07797"></a><span class="lineno"> 7797</span>&#160;   Base *obj2; </div><div class="line"><a name="l07798"></a><span class="lineno"> 7798</span>&#160;   struct methodResponse r; </div><div class="line"><a name="l07799"></a><span class="lineno"> 7799</span>&#160;   obj1.name = &quot;X&quot;; </div><div class="line"><a name="l07800"></a><span class="lineno"> 7800</span>&#160;   obj1.num = 3; </div><div class="line"><a name="l07801"></a><span class="lineno"> 7801</span>&#160;   soap_call_method(&amp;soap, url, action, &amp;obj1, r); </div><div class="line"><a name="l07802"></a><span class="lineno"> 7802</span>&#160;   r.obj2-&gt;print(); </div><div class="line"><a name="l07803"></a><span class="lineno"> 7803</span>&#160;} </div><div class="line"><a name="l07804"></a><span class="lineno"> 7804</span>&#160;...</div><div class="line"><a name="l07805"></a><span class="lineno"> 7805</span>&#160;```</div><div class="line"><a name="l07806"></a><span class="lineno"> 7806</span>&#160;</div><div class="line"><a name="l07807"></a><span class="lineno"> 7807</span>&#160;The following example `SERVER1` application copies a class instance (Base or Derived class) from the input to the output parameter:</div><div class="line"><a name="l07808"></a><span class="lineno"> 7808</span>&#160;</div><div class="line"><a name="l07809"></a><span class="lineno"> 7809</span>&#160;```cpp</div><div class="line"><a name="l07810"></a><span class="lineno"> 7810</span>&#160;// SERVER1 </div><div class="line"><a name="l07811"></a><span class="lineno"> 7811</span>&#160;#include &quot;soapH.h&quot; </div><div class="line"><a name="l07812"></a><span class="lineno"> 7812</span>&#160;int main() </div><div class="line"><a name="l07813"></a><span class="lineno"> 7813</span>&#160;{ </div><div class="line"><a name="l07814"></a><span class="lineno"> 7814</span>&#160;   soap_serve(soap_new()); </div><div class="line"><a name="l07815"></a><span class="lineno"> 7815</span>&#160;} </div><div class="line"><a name="l07816"></a><span class="lineno"> 7816</span>&#160;int method(struct soap *soap, Base *obj1, struct methodResponse &amp;result) </div><div class="line"><a name="l07817"></a><span class="lineno"> 7817</span>&#160;{ </div><div class="line"><a name="l07818"></a><span class="lineno"> 7818</span>&#160;   obj1-&gt;print(); </div><div class="line"><a name="l07819"></a><span class="lineno"> 7819</span>&#160;   result.obj2 = obj1; </div><div class="line"><a name="l07820"></a><span class="lineno"> 7820</span>&#160;   return SOAP_OK; </div><div class="line"><a name="l07821"></a><span class="lineno"> 7821</span>&#160;} </div><div class="line"><a name="l07822"></a><span class="lineno"> 7822</span>&#160;...</div><div class="line"><a name="l07823"></a><span class="lineno"> 7823</span>&#160;```</div><div class="line"><a name="l07824"></a><span class="lineno"> 7824</span>&#160;</div><div class="line"><a name="l07825"></a><span class="lineno"> 7825</span>&#160;The following messages are produced by the `CLIENT` and `SERVER1` applications:</div><div class="line"><a name="l07826"></a><span class="lineno"> 7826</span>&#160;</div><div class="line"><a name="l07827"></a><span class="lineno"> 7827</span>&#160;    CLIENT: created a Derived class instance </div><div class="line"><a name="l07828"></a><span class="lineno"> 7828</span>&#160;    SERVER1: created a Derived class instance </div><div class="line"><a name="l07829"></a><span class="lineno"> 7829</span>&#160;    SERVER1: print(): Derived class instance X 3 </div><div class="line"><a name="l07830"></a><span class="lineno"> 7830</span>&#160;    CLIENT: created a Derived class instance </div><div class="line"><a name="l07831"></a><span class="lineno"> 7831</span>&#160;    CLIENT: print(): Derived class instance X 3</div><div class="line"><a name="l07832"></a><span class="lineno"> 7832</span>&#160;</div><div class="line"><a name="l07833"></a><span class="lineno"> 7833</span>&#160;Which indicates that the derived class kept its identity when it passed through `SERVER1`. Note that instances are created both by the `CLIENT` and `SERVER1` by the demarshalling process.</div><div class="line"><a name="l07834"></a><span class="lineno"> 7834</span>&#160;</div><div class="line"><a name="l07835"></a><span class="lineno"> 7835</span>&#160;Now suppose a service application is developed that only accepts Base class instances. The header file is:</div><div class="line"><a name="l07836"></a><span class="lineno"> 7836</span>&#160;</div><div class="line"><a name="l07837"></a><span class="lineno"> 7837</span>&#160;```cpp</div><div class="line"><a name="l07838"></a><span class="lineno"> 7838</span>&#160;// Contents of file &quot;base.h&quot;: </div><div class="line"><a name="l07839"></a><span class="lineno"> 7839</span>&#160;class Base </div><div class="line"><a name="l07840"></a><span class="lineno"> 7840</span>&#160;{ </div><div class="line"><a name="l07841"></a><span class="lineno"> 7841</span>&#160;   public: </div><div class="line"><a name="l07842"></a><span class="lineno"> 7842</span>&#160;   char *name; </div><div class="line"><a name="l07843"></a><span class="lineno"> 7843</span>&#160;   Base(); </div><div class="line"><a name="l07844"></a><span class="lineno"> 7844</span>&#160;   virtual void print(); </div><div class="line"><a name="l07845"></a><span class="lineno"> 7845</span>&#160;}; </div><div class="line"><a name="l07846"></a><span class="lineno"> 7846</span>&#160;int method(Base *in, Base *out);</div><div class="line"><a name="l07847"></a><span class="lineno"> 7847</span>&#160;```</div><div class="line"><a name="l07848"></a><span class="lineno"> 7848</span>&#160;</div><div class="line"><a name="l07849"></a><span class="lineno"> 7849</span>&#160;This header file specification is processed by the gSOAP `soapcpp2` tool to produce skeleton routine which is used to implement a service (so the client will still use the derived classes).</div><div class="line"><a name="l07850"></a><span class="lineno"> 7850</span>&#160;</div><div class="line"><a name="l07851"></a><span class="lineno"> 7851</span>&#160;The method implementation of the Base class are:</div><div class="line"><a name="l07852"></a><span class="lineno"> 7852</span>&#160;</div><div class="line"><a name="l07853"></a><span class="lineno"> 7853</span>&#160;```cpp</div><div class="line"><a name="l07854"></a><span class="lineno"> 7854</span>&#160;// Method implementations of the Base class: </div><div class="line"><a name="l07855"></a><span class="lineno"> 7855</span>&#160;#include &quot;soapH.h&quot; </div><div class="line"><a name="l07856"></a><span class="lineno"> 7856</span>&#160;... </div><div class="line"><a name="l07857"></a><span class="lineno"> 7857</span>&#160;Base::Base() </div><div class="line"><a name="l07858"></a><span class="lineno"> 7858</span>&#160;{ </div><div class="line"><a name="l07859"></a><span class="lineno"> 7859</span>&#160;   cout &lt;&lt; &quot;created a Base class instance&quot; &lt;&lt; endl; </div><div class="line"><a name="l07860"></a><span class="lineno"> 7860</span>&#160;} </div><div class="line"><a name="l07861"></a><span class="lineno"> 7861</span>&#160;Base::print() </div><div class="line"><a name="l07862"></a><span class="lineno"> 7862</span>&#160;{ </div><div class="line"><a name="l07863"></a><span class="lineno"> 7863</span>&#160;   cout &lt;&lt; &quot;print(): Base class instance &quot; &lt;&lt; name &lt;&lt; endl; </div><div class="line"><a name="l07864"></a><span class="lineno"> 7864</span>&#160;} </div><div class="line"><a name="l07865"></a><span class="lineno"> 7865</span>&#160;```</div><div class="line"><a name="l07866"></a><span class="lineno"> 7866</span>&#160;</div><div class="line"><a name="l07867"></a><span class="lineno"> 7867</span>&#160;And the `SERVER2` application is that uses the Base class is:</div><div class="line"><a name="l07868"></a><span class="lineno"> 7868</span>&#160;</div><div class="line"><a name="l07869"></a><span class="lineno"> 7869</span>&#160;```cpp</div><div class="line"><a name="l07870"></a><span class="lineno"> 7870</span>&#160;// SERVER2 </div><div class="line"><a name="l07871"></a><span class="lineno"> 7871</span>&#160;#include &quot;soapH.h&quot; </div><div class="line"><a name="l07872"></a><span class="lineno"> 7872</span>&#160;int main() </div><div class="line"><a name="l07873"></a><span class="lineno"> 7873</span>&#160;{ </div><div class="line"><a name="l07874"></a><span class="lineno"> 7874</span>&#160;   soap_serve(soap_new()); </div><div class="line"><a name="l07875"></a><span class="lineno"> 7875</span>&#160;} </div><div class="line"><a name="l07876"></a><span class="lineno"> 7876</span>&#160;int method(struct soap *soap, Base *obj1, struct methodResponse &amp;result) </div><div class="line"><a name="l07877"></a><span class="lineno"> 7877</span>&#160;{ </div><div class="line"><a name="l07878"></a><span class="lineno"> 7878</span>&#160;   obj1-&gt;print(); </div><div class="line"><a name="l07879"></a><span class="lineno"> 7879</span>&#160;   result.obj2 = obj1; </div><div class="line"><a name="l07880"></a><span class="lineno"> 7880</span>&#160;   return SOAP_OK; </div><div class="line"><a name="l07881"></a><span class="lineno"> 7881</span>&#160;} </div><div class="line"><a name="l07882"></a><span class="lineno"> 7882</span>&#160;...</div><div class="line"><a name="l07883"></a><span class="lineno"> 7883</span>&#160;```</div><div class="line"><a name="l07884"></a><span class="lineno"> 7884</span>&#160;</div><div class="line"><a name="l07885"></a><span class="lineno"> 7885</span>&#160;Here are the messages produced by the `CLIENT` and `SERVER2` applications:</div><div class="line"><a name="l07886"></a><span class="lineno"> 7886</span>&#160;</div><div class="line"><a name="l07887"></a><span class="lineno"> 7887</span>&#160;    CLIENT: created a Derived class instance </div><div class="line"><a name="l07888"></a><span class="lineno"> 7888</span>&#160;    SERVER2: created a Base class instance </div><div class="line"><a name="l07889"></a><span class="lineno"> 7889</span>&#160;    SERVER2: print(): Base class instance X </div><div class="line"><a name="l07890"></a><span class="lineno"> 7890</span>&#160;    CLIENT: created a Base class instance </div><div class="line"><a name="l07891"></a><span class="lineno"> 7891</span>&#160;    CLIENT: print(): Base class instance X</div><div class="line"><a name="l07892"></a><span class="lineno"> 7892</span>&#160;</div><div class="line"><a name="l07893"></a><span class="lineno"> 7893</span>&#160;In this example, the object was passed as a Derived class instance to `SERVER2`. Since `SERVER2` only implements the Base class, this object is converted to a Base class instance and send back to `CLIENT`.</div><div class="line"><a name="l07894"></a><span class="lineno"> 7894</span>&#160;</div><div class="line"><a name="l07895"></a><span class="lineno"> 7895</span>&#160;### XML Attributes        {#attributes}</div><div class="line"><a name="l07896"></a><span class="lineno"> 7896</span>&#160;</div><div class="line"><a name="l07897"></a><span class="lineno"> 7897</span>&#160;The SOAP RPC/LIT and SOAP DOC/LIT encoding styles support XML attributes in</div><div class="line"><a name="l07898"></a><span class="lineno"> 7898</span>&#160;SOAP messages while SOAP RPC with &quot;Section 5&quot; encoding does not support XML</div><div class="line"><a name="l07899"></a><span class="lineno"> 7899</span>&#160;attributes other than the SOAP and XSD specific attributes. SOAP RPC Section</div><div class="line"><a name="l07900"></a><span class="lineno"> 7900</span>&#160;5 encoding has advantages for cross-language interoperability and data</div><div class="line"><a name="l07901"></a><span class="lineno"> 7901</span>&#160;encodings such as graph serialization. However, RPC/LIT and DOC/LIT enables</div><div class="line"><a name="l07902"></a><span class="lineno"> 7902</span>&#160;direct exchange of XML documents, which may include encoded application data</div><div class="line"><a name="l07903"></a><span class="lineno"> 7903</span>&#160;structures. Language interoperability is compromised, because no mapping</div><div class="line"><a name="l07904"></a><span class="lineno"> 7904</span>&#160;between XML and the typical language data types is defined. The meaning of the</div><div class="line"><a name="l07905"></a><span class="lineno"> 7905</span>&#160;RPC/LIT and DOC/LIT XML content is Schema driven rather than</div><div class="line"><a name="l07906"></a><span class="lineno"> 7906</span>&#160;application/language driven.</div><div class="line"><a name="l07907"></a><span class="lineno"> 7907</span>&#160;</div><div class="line"><a name="l07908"></a><span class="lineno"> 7908</span>&#160;gSOAP supports XML attribute (de)serialization of members in structs and classes.</div><div class="line"><a name="l07909"></a><span class="lineno"> 7909</span>&#160;Attributes are primitive XSD types, such as strings, enumerations, boolean, and</div><div class="line"><a name="l07910"></a><span class="lineno"> 7910</span>&#160;numeric types. To declare an XML attribute in a struct/class, the qualifier</div><div class="line"><a name="l07911"></a><span class="lineno"> 7911</span>&#160;`@` is used with the type of the attribute. The type must be</div><div class="line"><a name="l07912"></a><span class="lineno"> 7912</span>&#160;primitive type (including enumerations and strings), which can be declared with or without</div><div class="line"><a name="l07913"></a><span class="lineno"> 7913</span>&#160;a `typedef` to associate a XSD type with the C/C+ type.  For example</div><div class="line"><a name="l07914"></a><span class="lineno"> 7914</span>&#160;</div><div class="line"><a name="l07915"></a><span class="lineno"> 7915</span>&#160;```cpp</div><div class="line"><a name="l07916"></a><span class="lineno"> 7916</span>&#160;typedef char *xsd__string; </div><div class="line"><a name="l07917"></a><span class="lineno"> 7917</span>&#160;typedef bool *xsd__boolean; </div><div class="line"><a name="l07918"></a><span class="lineno"> 7918</span>&#160;enum ns__state { _0, _1, _2 }; </div><div class="line"><a name="l07919"></a><span class="lineno"> 7919</span>&#160;struct ns__myStruct </div><div class="line"><a name="l07920"></a><span class="lineno"> 7920</span>&#160;{ </div><div class="line"><a name="l07921"></a><span class="lineno"> 7921</span>&#160;  @ xsd__string         ns__type;</div><div class="line"><a name="l07922"></a><span class="lineno"> 7922</span>&#160;  @ xsd__boolean        ns__flag = false;</div><div class="line"><a name="l07923"></a><span class="lineno"> 7923</span>&#160;  @ enum ns__state      ns__state = _2;</div><div class="line"><a name="l07924"></a><span class="lineno"> 7924</span>&#160;  struct ns__myStruct *next; </div><div class="line"><a name="l07925"></a><span class="lineno"> 7925</span>&#160;};</div><div class="line"><a name="l07926"></a><span class="lineno"> 7926</span>&#160;```</div><div class="line"><a name="l07927"></a><span class="lineno"> 7927</span>&#160;</div><div class="line"><a name="l07928"></a><span class="lineno"> 7928</span>&#160;The `@` qualifier indicates XML attribute encoding for the</div><div class="line"><a name="l07929"></a><span class="lineno"> 7929</span>&#160;`ns__type`, `ns__flag`, and `ns__state` fields. Note that the</div><div class="line"><a name="l07930"></a><span class="lineno"> 7930</span>&#160;namespace prefix `ns` is used to distinguish these attributes from any</div><div class="line"><a name="l07931"></a><span class="lineno"> 7931</span>&#160;other attributes such as *`xsi:type`* (*`ns:type`* is not to be confused</div><div class="line"><a name="l07932"></a><span class="lineno"> 7932</span>&#160;with *`xsi:type`*).</div><div class="line"><a name="l07933"></a><span class="lineno"> 7933</span>&#160;</div><div class="line"><a name="l07934"></a><span class="lineno"> 7934</span>&#160;Default values can be associated with any field that has</div><div class="line"><a name="l07935"></a><span class="lineno"> 7935</span>&#160;a primitive type in a struct/class, as is illustrated in this example. The</div><div class="line"><a name="l07936"></a><span class="lineno"> 7936</span>&#160;default values are used when the receiving message does not contain the</div><div class="line"><a name="l07937"></a><span class="lineno"> 7937</span>&#160;corresponding values.</div><div class="line"><a name="l07938"></a><span class="lineno"> 7938</span>&#160;</div><div class="line"><a name="l07939"></a><span class="lineno"> 7939</span>&#160;String attributes are optional. Other type of attributes should be declared as pointers to make them optional:</div><div class="line"><a name="l07940"></a><span class="lineno"> 7940</span>&#160;</div><div class="line"><a name="l07941"></a><span class="lineno"> 7941</span>&#160;```cpp</div><div class="line"><a name="l07942"></a><span class="lineno"> 7942</span>&#160;struct ns__myStruct </div><div class="line"><a name="l07943"></a><span class="lineno"> 7943</span>&#160;{ </div><div class="line"><a name="l07944"></a><span class="lineno"> 7944</span>&#160;  @ int *a; // omitted when NULL </div><div class="line"><a name="l07945"></a><span class="lineno"> 7945</span>&#160;};</div><div class="line"><a name="l07946"></a><span class="lineno"> 7946</span>&#160;```</div><div class="line"><a name="l07947"></a><span class="lineno"> 7947</span>&#160;</div><div class="line"><a name="l07948"></a><span class="lineno"> 7948</span>&#160;Because a service operation request and response is essentially a struct, XML</div><div class="line"><a name="l07949"></a><span class="lineno"> 7949</span>&#160;attributes can also be associated with method requests and responses. For</div><div class="line"><a name="l07950"></a><span class="lineno"> 7950</span>&#160;example</div><div class="line"><a name="l07951"></a><span class="lineno"> 7951</span>&#160;</div><div class="line"><a name="l07952"></a><span class="lineno"> 7952</span>&#160;```cpp</div><div class="line"><a name="l07953"></a><span class="lineno"> 7953</span>&#160;int ns__myMethod(@ char *ns__name, ...);</div><div class="line"><a name="l07954"></a><span class="lineno"> 7954</span>&#160;```</div><div class="line"><a name="l07955"></a><span class="lineno"> 7955</span>&#160;</div><div class="line"><a name="l07956"></a><span class="lineno"> 7956</span>&#160;Attributes can also be attached to the dynamic arrays, binary types, and wrapper classes/structs of primitive</div><div class="line"><a name="l07957"></a><span class="lineno"> 7957</span>&#160;types. Wrapper classes are described in Section \ref primclass .  For</div><div class="line"><a name="l07958"></a><span class="lineno"> 7958</span>&#160;example</div><div class="line"><a name="l07959"></a><span class="lineno"> 7959</span>&#160;</div><div class="line"><a name="l07960"></a><span class="lineno"> 7960</span>&#160;```cpp</div><div class="line"><a name="l07961"></a><span class="lineno"> 7961</span>&#160;struct xsd__string </div><div class="line"><a name="l07962"></a><span class="lineno"> 7962</span>&#160;{ </div><div class="line"><a name="l07963"></a><span class="lineno"> 7963</span>&#160;  char *__item; </div><div class="line"><a name="l07964"></a><span class="lineno"> 7964</span>&#160;  @ xsd__boolean flag; </div><div class="line"><a name="l07965"></a><span class="lineno"> 7965</span>&#160;};</div><div class="line"><a name="l07966"></a><span class="lineno"> 7966</span>&#160;```</div><div class="line"><a name="l07967"></a><span class="lineno"> 7967</span>&#160;</div><div class="line"><a name="l07968"></a><span class="lineno"> 7968</span>&#160;and</div><div class="line"><a name="l07969"></a><span class="lineno"> 7969</span>&#160;</div><div class="line"><a name="l07970"></a><span class="lineno"> 7970</span>&#160;```cpp</div><div class="line"><a name="l07971"></a><span class="lineno"> 7971</span>&#160;struct xsd__base64Binary </div><div class="line"><a name="l07972"></a><span class="lineno"> 7972</span>&#160;{ </div><div class="line"><a name="l07973"></a><span class="lineno"> 7973</span>&#160;  unsigned char *__ptr; </div><div class="line"><a name="l07974"></a><span class="lineno"> 7974</span>&#160;  int __size; </div><div class="line"><a name="l07975"></a><span class="lineno"> 7975</span>&#160;  @ xsd__boolean flag; </div><div class="line"><a name="l07976"></a><span class="lineno"> 7976</span>&#160;};</div><div class="line"><a name="l07977"></a><span class="lineno"> 7977</span>&#160;```</div><div class="line"><a name="l07978"></a><span class="lineno"> 7978</span>&#160;</div><div class="line"><a name="l07979"></a><span class="lineno"> 7979</span>&#160;The attribute declarations MUST follow the `__item`, `__ptr`, and `__size` fields</div><div class="line"><a name="l07980"></a><span class="lineno"> 7980</span>&#160;which define the characteristics of wrapper structs/classes and dynamic arrays.</div><div class="line"><a name="l07981"></a><span class="lineno"> 7981</span>&#160;</div><div class="line"><a name="l07982"></a><span class="lineno"> 7982</span>&#160;@warning Do not use XML attributes with SOAP RPC encoding. You can only use attributes with RPC literal encoding.</div><div class="line"><a name="l07983"></a><span class="lineno"> 7983</span>&#160;</div><div class="line"><a name="l07984"></a><span class="lineno"> 7984</span>&#160;### QName Attributes and Elements</div><div class="line"><a name="l07985"></a><span class="lineno"> 7985</span>&#160;</div><div class="line"><a name="l07986"></a><span class="lineno"> 7986</span>&#160;gSOAP ensures the proper decoding of XSD QNames.</div><div class="line"><a name="l07987"></a><span class="lineno"> 7987</span>&#160;An element or attribute with type QName (Qualified Name) contains a namespace prefix and a local name.</div><div class="line"><a name="l07988"></a><span class="lineno"> 7988</span>&#160;You can declare a QName type as a `typedef char *xsd__QName`. Values of type QName</div><div class="line"><a name="l07989"></a><span class="lineno"> 7989</span>&#160;are internally handled as regular strings.</div><div class="line"><a name="l07990"></a><span class="lineno"> 7990</span>&#160;gSOAP takes care of the proper namespace prefix mappings when deserializing QName values.</div><div class="line"><a name="l07991"></a><span class="lineno"> 7991</span>&#160;For example</div><div class="line"><a name="l07992"></a><span class="lineno"> 7992</span>&#160;</div><div class="line"><a name="l07993"></a><span class="lineno"> 7993</span>&#160;```cpp</div><div class="line"><a name="l07994"></a><span class="lineno"> 7994</span>&#160;typedef char *xsd__QName; </div><div class="line"><a name="l07995"></a><span class="lineno"> 7995</span>&#160;struct ns__myStruct </div><div class="line"><a name="l07996"></a><span class="lineno"> 7996</span>&#160;{ </div><div class="line"><a name="l07997"></a><span class="lineno"> 7997</span>&#160;  xsd__QName elt = &quot;ns:xyz&quot;; // QName element with default value &quot;ns:xyz&quot; </div><div class="line"><a name="l07998"></a><span class="lineno"> 7998</span>&#160;  @ xsd__QName att = &quot;ns:abc&quot;; // QName attribute with default value &quot;ns:abc&quot; </div><div class="line"><a name="l07999"></a><span class="lineno"> 7999</span>&#160;};</div><div class="line"><a name="l08000"></a><span class="lineno"> 8000</span>&#160;```</div><div class="line"><a name="l08001"></a><span class="lineno"> 8001</span>&#160;</div><div class="line"><a name="l08002"></a><span class="lineno"> 8002</span>&#160;When the `elt` and `att` fields are serialized,</div><div class="line"><a name="l08003"></a><span class="lineno"> 8003</span>&#160;their string contents are just transmitted (which means that the application is responsible to</div><div class="line"><a name="l08004"></a><span class="lineno"> 8004</span>&#160;ensure proper formatting of the QName strings prior to transmission). When the</div><div class="line"><a name="l08005"></a><span class="lineno"> 8005</span>&#160;fields are deserialized however, gSOAP takes care mapping the qualifiers to the</div><div class="line"><a name="l08006"></a><span class="lineno"> 8006</span>&#160;appropriate namespace prefixes. Suppose that the inbound value</div><div class="line"><a name="l08007"></a><span class="lineno"> 8007</span>&#160;for the `elt` is *`x:def`*, where the namespace name associated with the</div><div class="line"><a name="l08008"></a><span class="lineno"> 8008</span>&#160;prefix *`x`* matches the namespace name of the prefix *`ns`* (as defined in</div><div class="line"><a name="l08009"></a><span class="lineno"> 8009</span>&#160;the namespace mapping table). Then, the value is automatically converted into *`ns:def`*.</div><div class="line"><a name="l08010"></a><span class="lineno"> 8010</span>&#160;If the namespace name is not in the table, then</div><div class="line"><a name="l08011"></a><span class="lineno"> 8011</span>&#160;*`x:def`* is converted to `&quot;{`URI&quot;:def} where *`&quot;{`*URI&quot;} is the namespace</div><div class="line"><a name="l08012"></a><span class="lineno"> 8012</span>&#160;URI bound to *`x`* in the message received.  This enables an application to</div><div class="line"><a name="l08013"></a><span class="lineno"> 8013</span>&#160;retrieve the namespace information, whether it is in the namespace mapping</div><div class="line"><a name="l08014"></a><span class="lineno"> 8014</span>&#160;table or not.</div><div class="line"><a name="l08015"></a><span class="lineno"> 8015</span>&#160;</div><div class="line"><a name="l08016"></a><span class="lineno"> 8016</span>&#160;Note: `QName` is a pre-defined typedef type and used by gSOAP to</div><div class="line"><a name="l08017"></a><span class="lineno"> 8017</span>&#160;(de)serialize SOAP Fault codes which are QName elements.</div><div class="line"><a name="l08018"></a><span class="lineno"> 8018</span>&#160;</div><div class="line"><a name="l08019"></a><span class="lineno"> 8019</span>&#160;## Union Serialization        {#union}</div><div class="line"><a name="l08020"></a><span class="lineno"> 8020</span>&#160;</div><div class="line"><a name="l08021"></a><span class="lineno"> 8021</span>&#160;A `union` is only serialized if the `union` is used within a</div><div class="line"><a name="l08022"></a><span class="lineno"> 8022</span>&#160;`struct` or `class` declaration that includes a `int __union`</div><div class="line"><a name="l08023"></a><span class="lineno"> 8023</span>&#160;field that acts as a *discriminant* or *selector* for the `union`</div><div class="line"><a name="l08024"></a><span class="lineno"> 8024</span>&#160;fields. The selector stores run-time usage information about the `union`</div><div class="line"><a name="l08025"></a><span class="lineno"> 8025</span>&#160;fields. That is, the selector is used to enumerate the `union` fields such</div><div class="line"><a name="l08026"></a><span class="lineno"> 8026</span>&#160;that the gSOAP engine is able to select the correct `union` field to</div><div class="line"><a name="l08027"></a><span class="lineno"> 8027</span>&#160;serialize.</div><div class="line"><a name="l08028"></a><span class="lineno"> 8028</span>&#160;</div><div class="line"><a name="l08029"></a><span class="lineno"> 8029</span>&#160;A `union` within a `struct` or `class` with a selector field</div><div class="line"><a name="l08030"></a><span class="lineno"> 8030</span>&#160;represents *`xs:choice`* within a Schema complexType component. For example:</div><div class="line"><a name="l08031"></a><span class="lineno"> 8031</span>&#160;</div><div class="line"><a name="l08032"></a><span class="lineno"> 8032</span>&#160;```cpp</div><div class="line"><a name="l08033"></a><span class="lineno"> 8033</span>&#160;struct ns__PO </div><div class="line"><a name="l08034"></a><span class="lineno"> 8034</span>&#160;{ ... }; </div><div class="line"><a name="l08035"></a><span class="lineno"> 8035</span>&#160;struct ns__Invoice </div><div class="line"><a name="l08036"></a><span class="lineno"> 8036</span>&#160;{ ... }; </div><div class="line"><a name="l08037"></a><span class="lineno"> 8037</span>&#160;union ns__PO_or_Invoice </div><div class="line"><a name="l08038"></a><span class="lineno"> 8038</span>&#160;{ </div><div class="line"><a name="l08039"></a><span class="lineno"> 8039</span>&#160;   struct ns__PO po; </div><div class="line"><a name="l08040"></a><span class="lineno"> 8040</span>&#160;   struct ns__Invoice invoice; </div><div class="line"><a name="l08041"></a><span class="lineno"> 8041</span>&#160;}; </div><div class="line"><a name="l08042"></a><span class="lineno"> 8042</span>&#160;struct ns__composite </div><div class="line"><a name="l08043"></a><span class="lineno"> 8043</span>&#160;{ </div><div class="line"><a name="l08044"></a><span class="lineno"> 8044</span>&#160;   char *name; </div><div class="line"><a name="l08045"></a><span class="lineno"> 8045</span>&#160;   int __union; </div><div class="line"><a name="l08046"></a><span class="lineno"> 8046</span>&#160;   union ns__PO_or_Invoice value; </div><div class="line"><a name="l08047"></a><span class="lineno"> 8047</span>&#160;};</div><div class="line"><a name="l08048"></a><span class="lineno"> 8048</span>&#160;```</div><div class="line"><a name="l08049"></a><span class="lineno"> 8049</span>&#160;</div><div class="line"><a name="l08050"></a><span class="lineno"> 8050</span>&#160;The `union ns__PO_or_Invoice` is expanded as a *`xs:choice`*:</div><div class="line"><a name="l08051"></a><span class="lineno"> 8051</span>&#160;</div><div class="line"><a name="l08052"></a><span class="lineno"> 8052</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l08053"></a><span class="lineno"> 8053</span>&#160;```xml</div><div class="line"><a name="l08054"></a><span class="lineno"> 8054</span>&#160;&lt;complexType name=&quot;composite&quot;&gt; </div><div class="line"><a name="l08055"></a><span class="lineno"> 8055</span>&#160;   &lt;sequence&gt; </div><div class="line"><a name="l08056"></a><span class="lineno"> 8056</span>&#160;     &lt;element name=&quot;name&quot; type=&quot;xsd:string&quot;/&gt; </div><div class="line"><a name="l08057"></a><span class="lineno"> 8057</span>&#160;     &lt;choice&gt; </div><div class="line"><a name="l08058"></a><span class="lineno"> 8058</span>&#160;       &lt;element name=&quot;po&quot; type=&quot;ns:PO&quot;/&gt; </div><div class="line"><a name="l08059"></a><span class="lineno"> 8059</span>&#160;       &lt;element name=&quot;invoice&quot; type=&quot;ns:Invoice&quot;/&gt; </div><div class="line"><a name="l08060"></a><span class="lineno"> 8060</span>&#160;     &lt;/choice&gt; </div><div class="line"><a name="l08061"></a><span class="lineno"> 8061</span>&#160;   &lt;/sequence&gt; </div><div class="line"><a name="l08062"></a><span class="lineno"> 8062</span>&#160;&lt;/complexType&gt;</div><div class="line"><a name="l08063"></a><span class="lineno"> 8063</span>&#160;```</div><div class="line"><a name="l08064"></a><span class="lineno"> 8064</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l08065"></a><span class="lineno"> 8065</span>&#160;</div><div class="line"><a name="l08066"></a><span class="lineno"> 8066</span>&#160;Therefore, the name of the `union` and field can be freely chosen.</div><div class="line"><a name="l08067"></a><span class="lineno"> 8067</span>&#160;However, the `union` name should be qualified (as shown in the example) to</div><div class="line"><a name="l08068"></a><span class="lineno"> 8068</span>&#160;ensure instances of XML Schemas with *`elementFormDefault=&quot;qualified&quot;`* are</div><div class="line"><a name="l08069"></a><span class="lineno"> 8069</span>&#160;correctly serialized (`po` and `invoice` are *`ns:`* qualified).</div><div class="line"><a name="l08070"></a><span class="lineno"> 8070</span>&#160;</div><div class="line"><a name="l08071"></a><span class="lineno"> 8071</span>&#160;The `int __union` field selector&#39;s values are determined by the</div><div class="line"><a name="l08072"></a><span class="lineno"> 8072</span>&#160;`soapcpp2` compiler. Each `union` field name has a selector value</div><div class="line"><a name="l08073"></a><span class="lineno"> 8073</span>&#160;formed by:</div><div class="line"><a name="l08074"></a><span class="lineno"> 8074</span>&#160;</div><div class="line"><a name="l08075"></a><span class="lineno"> 8075</span>&#160;```cpp</div><div class="line"><a name="l08076"></a><span class="lineno"> 8076</span>&#160;SOAP_UNION_*union-name*_*field-name*</div><div class="line"><a name="l08077"></a><span class="lineno"> 8077</span>&#160;```</div><div class="line"><a name="l08078"></a><span class="lineno"> 8078</span>&#160;</div><div class="line"><a name="l08079"></a><span class="lineno"> 8079</span>&#160;These selector values enumerate the `union` fields starting with 1. The</div><div class="line"><a name="l08080"></a><span class="lineno"> 8080</span>&#160;value 0 (or any negative value) can be assigned to omit the serialization of the `union`, but only</div><div class="line"><a name="l08081"></a><span class="lineno"> 8081</span>&#160;if explicitly allowed by validation rules, which requires *`minOccurs=&quot;0&quot;`*</div><div class="line"><a name="l08082"></a><span class="lineno"> 8082</span>&#160;for the *`xs:choice`* as follows:</div><div class="line"><a name="l08083"></a><span class="lineno"> 8083</span>&#160;</div><div class="line"><a name="l08084"></a><span class="lineno"> 8084</span>&#160;```cpp</div><div class="line"><a name="l08085"></a><span class="lineno"> 8085</span>&#160;struct ns__composite </div><div class="line"><a name="l08086"></a><span class="lineno"> 8086</span>&#160;{ </div><div class="line"><a name="l08087"></a><span class="lineno"> 8087</span>&#160;   char *name; </div><div class="line"><a name="l08088"></a><span class="lineno"> 8088</span>&#160;   int __union 0; // *`&lt;choice minOccurs=&quot;0&quot;{`*&gt;} </div><div class="line"><a name="l08089"></a><span class="lineno"> 8089</span>&#160;   union ns__PO_or_Invoice value; </div><div class="line"><a name="l08090"></a><span class="lineno"> 8090</span>&#160;};</div><div class="line"><a name="l08091"></a><span class="lineno"> 8091</span>&#160;```</div><div class="line"><a name="l08092"></a><span class="lineno"> 8092</span>&#160;</div><div class="line"><a name="l08093"></a><span class="lineno"> 8093</span>&#160;This way we can treat the `union` as an optional data item by setting `__union=0`.</div><div class="line"><a name="l08094"></a><span class="lineno"> 8094</span>&#160;</div><div class="line"><a name="l08095"></a><span class="lineno"> 8095</span>&#160;Since 2.7.16 it is also possible to use a &#39;`$`&#39; as a special marker to annotate a</div><div class="line"><a name="l08096"></a><span class="lineno"> 8096</span>&#160;selector field that must be of type `int` and the field name is no longer</div><div class="line"><a name="l08097"></a><span class="lineno"> 8097</span>&#160;relevant:</div><div class="line"><a name="l08098"></a><span class="lineno"> 8098</span>&#160;</div><div class="line"><a name="l08099"></a><span class="lineno"> 8099</span>&#160;```cpp</div><div class="line"><a name="l08100"></a><span class="lineno"> 8100</span>&#160;struct ns__composite </div><div class="line"><a name="l08101"></a><span class="lineno"> 8101</span>&#160;{ </div><div class="line"><a name="l08102"></a><span class="lineno"> 8102</span>&#160;   char *name; </div><div class="line"><a name="l08103"></a><span class="lineno"> 8103</span>&#160;   $int select 0; // *`&lt;choice minOccurs=&quot;0&quot;{`*&gt;} </div><div class="line"><a name="l08104"></a><span class="lineno"> 8104</span>&#160;   union ns__PO_or_Invoice value; </div><div class="line"><a name="l08105"></a><span class="lineno"> 8105</span>&#160;};</div><div class="line"><a name="l08106"></a><span class="lineno"> 8106</span>&#160;```</div><div class="line"><a name="l08107"></a><span class="lineno"> 8107</span>&#160;</div><div class="line"><a name="l08108"></a><span class="lineno"> 8108</span>&#160;The following example shows how the `struct ns__composite` instance is</div><div class="line"><a name="l08109"></a><span class="lineno"> 8109</span>&#160;initialized for serialization using the above declaration:</div><div class="line"><a name="l08110"></a><span class="lineno"> 8110</span>&#160;</div><div class="line"><a name="l08111"></a><span class="lineno"> 8111</span>&#160;```cpp</div><div class="line"><a name="l08112"></a><span class="lineno"> 8112</span>&#160;struct ns__composite data; </div><div class="line"><a name="l08113"></a><span class="lineno"> 8113</span>&#160;data.name = &quot;...&quot;; </div><div class="line"><a name="l08114"></a><span class="lineno"> 8114</span>&#160;data.select = SOAP_UNION_ns__PO_or_Invoice_po; // select PO </div><div class="line"><a name="l08115"></a><span class="lineno"> 8115</span>&#160;data.value.po.number = ...; // populate the PO</div><div class="line"><a name="l08116"></a><span class="lineno"> 8116</span>&#160;```</div><div class="line"><a name="l08117"></a><span class="lineno"> 8117</span>&#160;</div><div class="line"><a name="l08118"></a><span class="lineno"> 8118</span>&#160;Note that failing to set the selector to a valid `union` field can lead to</div><div class="line"><a name="l08119"></a><span class="lineno"> 8119</span>&#160;a crash of the gSOAP serializer because it will attempt to serialize an invalid</div><div class="line"><a name="l08120"></a><span class="lineno"> 8120</span>&#160;`union` field.</div><div class="line"><a name="l08121"></a><span class="lineno"> 8121</span>&#160;</div><div class="line"><a name="l08122"></a><span class="lineno"> 8122</span>&#160;For deserialization of `union` types, the selector will be</div><div class="line"><a name="l08123"></a><span class="lineno"> 8123</span>&#160;set to one of the</div><div class="line"><a name="l08124"></a><span class="lineno"> 8124</span>&#160;`union` field selector values, as determined by the XML payload.</div><div class="line"><a name="l08125"></a><span class="lineno"> 8125</span>&#160;The selector will be set to 0 or -1 when no union member was deserialized,</div><div class="line"><a name="l08126"></a><span class="lineno"> 8126</span>&#160;where a negative value indicates that a member was required by validation rules.</div><div class="line"><a name="l08127"></a><span class="lineno"> 8127</span>&#160;Strict validation enabled with `SOAP_XML_STRICT` results in a validation fault.</div><div class="line"><a name="l08128"></a><span class="lineno"> 8128</span>&#160;</div><div class="line"><a name="l08129"></a><span class="lineno"> 8129</span>&#160;When more than one `union` is used in a `struct` or `class`, the</div><div class="line"><a name="l08130"></a><span class="lineno"> 8130</span>&#160;`__union` selectors must be renamed to avoid name clashes by using</div><div class="line"><a name="l08131"></a><span class="lineno"> 8131</span>&#160;suffixes as in:</div><div class="line"><a name="l08132"></a><span class="lineno"> 8132</span>&#160;</div><div class="line"><a name="l08133"></a><span class="lineno"> 8133</span>&#160;```cpp</div><div class="line"><a name="l08134"></a><span class="lineno"> 8134</span>&#160;struct ns__composite </div><div class="line"><a name="l08135"></a><span class="lineno"> 8135</span>&#160;{ </div><div class="line"><a name="l08136"></a><span class="lineno"> 8136</span>&#160;   char *name; </div><div class="line"><a name="l08137"></a><span class="lineno"> 8137</span>&#160;   $int sel_value; // = SOAP_UNION_ns__PO_or_Invoice_[po|invoice] </div><div class="line"><a name="l08138"></a><span class="lineno"> 8138</span>&#160;   union ns__PO_or_Invoice value; </div><div class="line"><a name="l08139"></a><span class="lineno"> 8139</span>&#160;   $int sel_data; // = SOAP_UNIO_ns__Email_or_Fax_[email|fax] </div><div class="line"><a name="l08140"></a><span class="lineno"> 8140</span>&#160;   union ns__Email_or_Fax data; </div><div class="line"><a name="l08141"></a><span class="lineno"> 8141</span>&#160;};</div><div class="line"><a name="l08142"></a><span class="lineno"> 8142</span>&#160;```</div><div class="line"><a name="l08143"></a><span class="lineno"> 8143</span>&#160;</div><div class="line"><a name="l08144"></a><span class="lineno"> 8144</span>&#160;## Serializing Pointer Types        {#pointer}</div><div class="line"><a name="l08145"></a><span class="lineno"> 8145</span>&#160;</div><div class="line"><a name="l08146"></a><span class="lineno"> 8146</span>&#160;The serialization of a pointer to a data type amounts to the serialization of</div><div class="line"><a name="l08147"></a><span class="lineno"> 8147</span>&#160;the data type in SOAP and the SOAP encoded representation of a pointer to the</div><div class="line"><a name="l08148"></a><span class="lineno"> 8148</span>&#160;data type is indistinguishable from the encoded representation of the data</div><div class="line"><a name="l08149"></a><span class="lineno"> 8149</span>&#160;type pointed to.</div><div class="line"><a name="l08150"></a><span class="lineno"> 8150</span>&#160;</div><div class="line"><a name="l08151"></a><span class="lineno"> 8151</span>&#160;### Multi-Referenced Data</div><div class="line"><a name="l08152"></a><span class="lineno"> 8152</span>&#160;</div><div class="line"><a name="l08153"></a><span class="lineno"> 8153</span>&#160;A data structure pointed to by more than one pointer is serialized as SOAP</div><div class="line"><a name="l08154"></a><span class="lineno"> 8154</span>&#160;multi-reference data. This means that the data will be serialized only once and</div><div class="line"><a name="l08155"></a><span class="lineno"> 8155</span>&#160;identified with a unique *`id`* attribute. The encoding of the pointers to</div><div class="line"><a name="l08156"></a><span class="lineno"> 8156</span>&#160;the shared data is done through the use of *`href`* or *`ref`* attributes</div><div class="line"><a name="l08157"></a><span class="lineno"> 8157</span>&#160;to refer to the multi-reference data. See Section \ref flags  on</div><div class="line"><a name="l08158"></a><span class="lineno"> 8158</span>&#160;options to control the serialization of multi-reference data. To turn multi-ref off, use `SOAP_XML_TREE` to process plain tree-based XML. To completely eliminate multi-ref (de)serialization use the `WITH_NOIDREF` compile-time flag with all source code (including `stdsoap2.c` and `stdsoap2.cpp`) to permanently disable id-href processing. Cyclic C/C++</div><div class="line"><a name="l08159"></a><span class="lineno"> 8159</span>&#160;data structures are encoded with multi-reference SOAP encoding.  Consider for</div><div class="line"><a name="l08160"></a><span class="lineno"> 8160</span>&#160;example the following a linked list data structure:</div><div class="line"><a name="l08161"></a><span class="lineno"> 8161</span>&#160;</div><div class="line"><a name="l08162"></a><span class="lineno"> 8162</span>&#160;```cpp</div><div class="line"><a name="l08163"></a><span class="lineno"> 8163</span>&#160;typedef char *xsd__string; </div><div class="line"><a name="l08164"></a><span class="lineno"> 8164</span>&#160;struct ns__list</div><div class="line"><a name="l08165"></a><span class="lineno"> 8165</span>&#160;{ </div><div class="line"><a name="l08166"></a><span class="lineno"> 8166</span>&#160;   xsd__string value; </div><div class="line"><a name="l08167"></a><span class="lineno"> 8167</span>&#160;   struct ns__list *next; </div><div class="line"><a name="l08168"></a><span class="lineno"> 8168</span>&#160;};</div><div class="line"><a name="l08169"></a><span class="lineno"> 8169</span>&#160;```</div><div class="line"><a name="l08170"></a><span class="lineno"> 8170</span>&#160;</div><div class="line"><a name="l08171"></a><span class="lineno"> 8171</span>&#160;Suppose a cyclic linked list is created. The first node contains the value &quot;abc&quot; and points to a node with value</div><div class="line"><a name="l08172"></a><span class="lineno"> 8172</span>&#160;&quot;def&quot; which in turn points to the first node. This is encoded as:</div><div class="line"><a name="l08173"></a><span class="lineno"> 8173</span>&#160;</div><div class="line"><a name="l08174"></a><span class="lineno"> 8174</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l08175"></a><span class="lineno"> 8175</span>&#160;```xml</div><div class="line"><a name="l08176"></a><span class="lineno"> 8176</span>&#160;&lt;ns:list id=&quot;1&quot; xsi:type=&quot;ns:list&quot;&gt; </div><div class="line"><a name="l08177"></a><span class="lineno"> 8177</span>&#160;  &lt;value xsi:type=&quot;xsd:string&quot;&gt;abc&lt;/value&gt; </div><div class="line"><a name="l08178"></a><span class="lineno"> 8178</span>&#160;  &lt;next xsi:type=&quot;ns:list&quot;&gt; </div><div class="line"><a name="l08179"></a><span class="lineno"> 8179</span>&#160;    &lt;value xsi:type=&quot;xsd:string&quot;&gt;def&lt;/value&gt; </div><div class="line"><a name="l08180"></a><span class="lineno"> 8180</span>&#160;    &lt;next href=&quot;#1&quot;/&gt; </div><div class="line"><a name="l08181"></a><span class="lineno"> 8181</span>&#160;  &lt;/next&gt; </div><div class="line"><a name="l08182"></a><span class="lineno"> 8182</span>&#160;&lt;/ns:list&gt;</div><div class="line"><a name="l08183"></a><span class="lineno"> 8183</span>&#160;```</div><div class="line"><a name="l08184"></a><span class="lineno"> 8184</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l08185"></a><span class="lineno"> 8185</span>&#160;</div><div class="line"><a name="l08186"></a><span class="lineno"> 8186</span>&#160;In case multi-referenced data is received that &quot;does not fit in a pointer-based structure&quot;, the data is copied.</div><div class="line"><a name="l08187"></a><span class="lineno"> 8187</span>&#160;For example, the following two `struct`s are similar, except that the first uses pointer-based fields while the other uses</div><div class="line"><a name="l08188"></a><span class="lineno"> 8188</span>&#160;non-pointer-based fields:</div><div class="line"><a name="l08189"></a><span class="lineno"> 8189</span>&#160;</div><div class="line"><a name="l08190"></a><span class="lineno"> 8190</span>&#160;```cpp</div><div class="line"><a name="l08191"></a><span class="lineno"> 8191</span>&#160;typedef long xsd__int; </div><div class="line"><a name="l08192"></a><span class="lineno"> 8192</span>&#160;struct ns__record </div><div class="line"><a name="l08193"></a><span class="lineno"> 8193</span>&#160;{ </div><div class="line"><a name="l08194"></a><span class="lineno"> 8194</span>&#160;   xsd__int *a; </div><div class="line"><a name="l08195"></a><span class="lineno"> 8195</span>&#160;   xsd__int *b; </div><div class="line"><a name="l08196"></a><span class="lineno"> 8196</span>&#160;} P; </div><div class="line"><a name="l08197"></a><span class="lineno"> 8197</span>&#160;struct ns__record</div><div class="line"><a name="l08198"></a><span class="lineno"> 8198</span>&#160;{ </div><div class="line"><a name="l08199"></a><span class="lineno"> 8199</span>&#160;   xsd__int a; </div><div class="line"><a name="l08200"></a><span class="lineno"> 8200</span>&#160;   xsd__int b; </div><div class="line"><a name="l08201"></a><span class="lineno"> 8201</span>&#160;} R; </div><div class="line"><a name="l08202"></a><span class="lineno"> 8202</span>&#160;... </div><div class="line"><a name="l08203"></a><span class="lineno"> 8203</span>&#160;   P.a = &amp;n; </div><div class="line"><a name="l08204"></a><span class="lineno"> 8204</span>&#160;   P.b = &amp;n; </div><div class="line"><a name="l08205"></a><span class="lineno"> 8205</span>&#160;...</div><div class="line"><a name="l08206"></a><span class="lineno"> 8206</span>&#160;```</div><div class="line"><a name="l08207"></a><span class="lineno"> 8207</span>&#160;</div><div class="line"><a name="l08208"></a><span class="lineno"> 8208</span>&#160;Since both `a` and `b` fields of `P` point to the same integer, the encoding of `P` is multi-reference:</div><div class="line"><a name="l08209"></a><span class="lineno"> 8209</span>&#160;</div><div class="line"><a name="l08210"></a><span class="lineno"> 8210</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l08211"></a><span class="lineno"> 8211</span>&#160;```xml</div><div class="line"><a name="l08212"></a><span class="lineno"> 8212</span>&#160;&lt;ns:record xsi:type=&quot;ns:record&quot;&gt; </div><div class="line"><a name="l08213"></a><span class="lineno"> 8213</span>&#160;   &lt;a href=&quot;#1&quot;/&gt; </div><div class="line"><a name="l08214"></a><span class="lineno"> 8214</span>&#160;   &lt;b href=&quot;#1&quot;/&gt; </div><div class="line"><a name="l08215"></a><span class="lineno"> 8215</span>&#160;&lt;/ns:record&gt; </div><div class="line"><a name="l08216"></a><span class="lineno"> 8216</span>&#160;&lt;id id=&quot;1&quot; xsi:type=&quot;xsd:int&quot;&gt;123&lt;/id&gt;</div><div class="line"><a name="l08217"></a><span class="lineno"> 8217</span>&#160;```</div><div class="line"><a name="l08218"></a><span class="lineno"> 8218</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l08219"></a><span class="lineno"> 8219</span>&#160;</div><div class="line"><a name="l08220"></a><span class="lineno"> 8220</span>&#160;Now, the decoding of the content in the `R` data structure that does not use pointers to integers results in a copy of each</div><div class="line"><a name="l08221"></a><span class="lineno"> 8221</span>&#160;multi-reference integer.  Note that the two `struct`s resemble the same XML data type because the trailing underscore will be</div><div class="line"><a name="l08222"></a><span class="lineno"> 8222</span>&#160;ignored in XML encoding and decoding.</div><div class="line"><a name="l08223"></a><span class="lineno"> 8223</span>&#160;</div><div class="line"><a name="l08224"></a><span class="lineno"> 8224</span>&#160;### NULL Pointers and Nil Elements</div><div class="line"><a name="l08225"></a><span class="lineno"> 8225</span>&#160;</div><div class="line"><a name="l08226"></a><span class="lineno"> 8226</span>&#160;A `NULL` pointer is **not** serialized, unless the pointer itself is pointed to by another pointer (but see</div><div class="line"><a name="l08227"></a><span class="lineno"> 8227</span>&#160;Section \ref flags  to control the serialization of NULLs).</div><div class="line"><a name="l08228"></a><span class="lineno"> 8228</span>&#160;For example:</div><div class="line"><a name="l08229"></a><span class="lineno"> 8229</span>&#160;</div><div class="line"><a name="l08230"></a><span class="lineno"> 8230</span>&#160;```cpp</div><div class="line"><a name="l08231"></a><span class="lineno"> 8231</span>&#160;struct X </div><div class="line"><a name="l08232"></a><span class="lineno"> 8232</span>&#160;{</div><div class="line"><a name="l08233"></a><span class="lineno"> 8233</span>&#160;  int *p; </div><div class="line"><a name="l08234"></a><span class="lineno"> 8234</span>&#160;  int **q; </div><div class="line"><a name="l08235"></a><span class="lineno"> 8235</span>&#160;}</div><div class="line"><a name="l08236"></a><span class="lineno"> 8236</span>&#160;```</div><div class="line"><a name="l08237"></a><span class="lineno"> 8237</span>&#160;</div><div class="line"><a name="l08238"></a><span class="lineno"> 8238</span>&#160;Suppose pointer `q` points to pointer `p` and suppose `p=NULL`.</div><div class="line"><a name="l08239"></a><span class="lineno"> 8239</span>&#160;In that case the `p` pointer is serialized as</div><div class="line"><a name="l08240"></a><span class="lineno"> 8240</span>&#160;</div><div class="line"><a name="l08241"></a><span class="lineno"> 8241</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l08242"></a><span class="lineno"> 8242</span>&#160;```xml</div><div class="line"><a name="l08243"></a><span class="lineno"> 8243</span>&#160;&lt;... id=&quot;123&quot; xsi:nil=&quot;true&quot;/&gt;</div><div class="line"><a name="l08244"></a><span class="lineno"> 8244</span>&#160;```</div><div class="line"><a name="l08245"></a><span class="lineno"> 8245</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l08246"></a><span class="lineno"> 8246</span>&#160;</div><div class="line"><a name="l08247"></a><span class="lineno"> 8247</span>&#160;and the serialization of `q` refers to *`href=&quot;#123&quot;`*.</div><div class="line"><a name="l08248"></a><span class="lineno"> 8248</span>&#160;Note that SOAP 1.1 does not support</div><div class="line"><a name="l08249"></a><span class="lineno"> 8249</span>&#160;pointer to pointer types (!), so this encoding is specific to gSOAP. The pointer to pointer encoding is rarely used in codes</div><div class="line"><a name="l08250"></a><span class="lineno"> 8250</span>&#160;anyway.  More common is a pointer to a data type such as a `struct` with pointer fields.</div><div class="line"><a name="l08251"></a><span class="lineno"> 8251</span>&#160;</div><div class="line"><a name="l08252"></a><span class="lineno"> 8252</span>&#160;@warning When the deserializer encounters an XML element that has a *`xsi:nil=&quot;true&quot;`* attribute but the corresponding C++ data is not a pointer or reference,</div><div class="line"><a name="l08253"></a><span class="lineno"> 8253</span>&#160;the deserializer will terminate with a `SOAP_NULL` fault when the `SOAP_XML_STRICT` flag is set.</div><div class="line"><a name="l08254"></a><span class="lineno"> 8254</span>&#160;The types section of a WSDL description contains information on the &quot;nilability&quot; of data.</div><div class="line"><a name="l08255"></a><span class="lineno"> 8255</span>&#160;</div><div class="line"><a name="l08256"></a><span class="lineno"> 8256</span>&#160;## Void Pointers        {#void}</div><div class="line"><a name="l08257"></a><span class="lineno"> 8257</span>&#160;</div><div class="line"><a name="l08258"></a><span class="lineno"> 8258</span>&#160;In general, void pointers (`void*`) cannot be (de)serialized because the</div><div class="line"><a name="l08259"></a><span class="lineno"> 8259</span>&#160;type of data referred to is untyped.  To enable the (de)serialization of the</div><div class="line"><a name="l08260"></a><span class="lineno"> 8260</span>&#160;void pointers that are members of structs or classes, you can insert a</div><div class="line"><a name="l08261"></a><span class="lineno"> 8261</span>&#160;`int __type` field right before the void pointer field.  The `int __type` field contains run time information on the type of the data pointed to by</div><div class="line"><a name="l08262"></a><span class="lineno"> 8262</span>&#160;`void*` member in a struct/class to enable the (de)serialization of this</div><div class="line"><a name="l08263"></a><span class="lineno"> 8263</span>&#160;data.  The `int __type` field is set to a `SOAP_TYPE_X` value, where `X` is the name of a type.  gSOAP generates the `SOAP_TYPE_X` definitions in `soapH.h` and uses them internally to uniquely identify the type of each object.</div><div class="line"><a name="l08264"></a><span class="lineno"> 8264</span>&#160;The type naming conventions outlined in</div><div class="line"><a name="l08265"></a><span class="lineno"> 8265</span>&#160;Section \ref serialize  are used to determine the type name for *X*.</div><div class="line"><a name="l08266"></a><span class="lineno"> 8266</span>&#160;</div><div class="line"><a name="l08267"></a><span class="lineno"> 8267</span>&#160;Here is an example to illustrate the (de)serialization of a `void*` field in a struct:</div><div class="line"><a name="l08268"></a><span class="lineno"> 8268</span>&#160;</div><div class="line"><a name="l08269"></a><span class="lineno"> 8269</span>&#160;```cpp</div><div class="line"><a name="l08270"></a><span class="lineno"> 8270</span>&#160;struct myStruct </div><div class="line"><a name="l08271"></a><span class="lineno"> 8271</span>&#160;{ </div><div class="line"><a name="l08272"></a><span class="lineno"> 8272</span>&#160;   int __type; // the SOAP_TYPE pointed to by p </div><div class="line"><a name="l08273"></a><span class="lineno"> 8273</span>&#160;   void *p; </div><div class="line"><a name="l08274"></a><span class="lineno"> 8274</span>&#160;};</div><div class="line"><a name="l08275"></a><span class="lineno"> 8275</span>&#160;```</div><div class="line"><a name="l08276"></a><span class="lineno"> 8276</span>&#160;</div><div class="line"><a name="l08277"></a><span class="lineno"> 8277</span>&#160;The `__type` integer can be set to 0 at run time to omit the serialization</div><div class="line"><a name="l08278"></a><span class="lineno"> 8278</span>&#160;of the void pointer field.</div><div class="line"><a name="l08279"></a><span class="lineno"> 8279</span>&#160;</div><div class="line"><a name="l08280"></a><span class="lineno"> 8280</span>&#160;The following example illustrates the initialization of `myStruct` with a</div><div class="line"><a name="l08281"></a><span class="lineno"> 8281</span>&#160;void pointer to an int:</div><div class="line"><a name="l08282"></a><span class="lineno"> 8282</span>&#160;</div><div class="line"><a name="l08283"></a><span class="lineno"> 8283</span>&#160;```cpp</div><div class="line"><a name="l08284"></a><span class="lineno"> 8284</span>&#160;struct myStruct S; </div><div class="line"><a name="l08285"></a><span class="lineno"> 8285</span>&#160;int n; </div><div class="line"><a name="l08286"></a><span class="lineno"> 8286</span>&#160;S.p = &amp;n; </div><div class="line"><a name="l08287"></a><span class="lineno"> 8287</span>&#160;S.__type = SOAP_TYPE_int; </div><div class="line"><a name="l08288"></a><span class="lineno"> 8288</span>&#160;```</div><div class="line"><a name="l08289"></a><span class="lineno"> 8289</span>&#160;</div><div class="line"><a name="l08290"></a><span class="lineno"> 8290</span>&#160;The serialized output of `S` contains the integer.</div><div class="line"><a name="l08291"></a><span class="lineno"> 8291</span>&#160;</div><div class="line"><a name="l08292"></a><span class="lineno"> 8292</span>&#160;The deserializer for `myStruct` will automatically set the `__type`</div><div class="line"><a name="l08293"></a><span class="lineno"> 8293</span>&#160;field and void pointer to the deserialized data, provided that the XML content</div><div class="line"><a name="l08294"></a><span class="lineno"> 8294</span>&#160;for `p` carries the *`xsi:type`* attribute from which gSOAP can determine</div><div class="line"><a name="l08295"></a><span class="lineno"> 8295</span>&#160;the type.</div><div class="line"><a name="l08296"></a><span class="lineno"> 8296</span>&#160;</div><div class="line"><a name="l08297"></a><span class="lineno"> 8297</span>&#160;@note when (de)serializing strings via a `void*` field, the `void*` pointer MUST directly point to the string value rather than indirectly as with all other types. For example:</div><div class="line"><a name="l08298"></a><span class="lineno"> 8298</span>&#160;</div><div class="line"><a name="l08299"></a><span class="lineno"> 8299</span>&#160;```cpp</div><div class="line"><a name="l08300"></a><span class="lineno"> 8300</span>&#160;struct myStruct S; </div><div class="line"><a name="l08301"></a><span class="lineno"> 8301</span>&#160;S.p = (void*)&quot;Hello&quot;; </div><div class="line"><a name="l08302"></a><span class="lineno"> 8302</span>&#160;S.__type = SOAP_TYPE_string; </div><div class="line"><a name="l08303"></a><span class="lineno"> 8303</span>&#160;```</div><div class="line"><a name="l08304"></a><span class="lineno"> 8304</span>&#160;</div><div class="line"><a name="l08305"></a><span class="lineno"> 8305</span>&#160;This is the case for all string-based types, including types defined with `typedef char*`.</div><div class="line"><a name="l08306"></a><span class="lineno"> 8306</span>&#160;</div><div class="line"><a name="l08307"></a><span class="lineno"> 8307</span>&#160;You may use an arbitrary suffix with the `__type` fields to handle</div><div class="line"><a name="l08308"></a><span class="lineno"> 8308</span>&#160;multiple void pointers in structs/classes.  For example</div><div class="line"><a name="l08309"></a><span class="lineno"> 8309</span>&#160;</div><div class="line"><a name="l08310"></a><span class="lineno"> 8310</span>&#160;```cpp</div><div class="line"><a name="l08311"></a><span class="lineno"> 8311</span>&#160;struct myStruct </div><div class="line"><a name="l08312"></a><span class="lineno"> 8312</span>&#160;{ </div><div class="line"><a name="l08313"></a><span class="lineno"> 8313</span>&#160;   int __typeOfp; // the SOAP_TYPE pointed to by p </div><div class="line"><a name="l08314"></a><span class="lineno"> 8314</span>&#160;   void *p; </div><div class="line"><a name="l08315"></a><span class="lineno"> 8315</span>&#160;   int __typeOfq; // the SOAP_TYPE pointed to by q </div><div class="line"><a name="l08316"></a><span class="lineno"> 8316</span>&#160;   void *q; </div><div class="line"><a name="l08317"></a><span class="lineno"> 8317</span>&#160;};</div><div class="line"><a name="l08318"></a><span class="lineno"> 8318</span>&#160;```</div><div class="line"><a name="l08319"></a><span class="lineno"> 8319</span>&#160;</div><div class="line"><a name="l08320"></a><span class="lineno"> 8320</span>&#160;Because service method parameters are stored within structs, you can use</div><div class="line"><a name="l08321"></a><span class="lineno"> 8321</span>&#160;`__type` and `void*` parameters to pass polymorphic arguments without</div><div class="line"><a name="l08322"></a><span class="lineno"> 8322</span>&#160;having to define a C++ class hierarchy (Section \ref polymorph ).  For</div><div class="line"><a name="l08323"></a><span class="lineno"> 8323</span>&#160;example:</div><div class="line"><a name="l08324"></a><span class="lineno"> 8324</span>&#160;</div><div class="line"><a name="l08325"></a><span class="lineno"> 8325</span>&#160;```cpp</div><div class="line"><a name="l08326"></a><span class="lineno"> 8326</span>&#160;typedef char *xsd__string; </div><div class="line"><a name="l08327"></a><span class="lineno"> 8327</span>&#160;typedef int xsd__int; </div><div class="line"><a name="l08328"></a><span class="lineno"> 8328</span>&#160;typedef float xsd__float; </div><div class="line"><a name="l08329"></a><span class="lineno"> 8329</span>&#160;enum ns__status { on, off }; </div><div class="line"><a name="l08330"></a><span class="lineno"> 8330</span>&#160;struct ns__widget { xsd__string name; xsd__int part; };</div><div class="line"><a name="l08331"></a><span class="lineno"> 8331</span>&#160;int ns__myMethod(int __type, void *data, struct ns__myMethodResponse { int __type; void *return_; } *out);</div><div class="line"><a name="l08332"></a><span class="lineno"> 8332</span>&#160;```</div><div class="line"><a name="l08333"></a><span class="lineno"> 8333</span>&#160;</div><div class="line"><a name="l08334"></a><span class="lineno"> 8334</span>&#160;This method has a polymorphic input parameter `data` and a polymorphic</div><div class="line"><a name="l08335"></a><span class="lineno"> 8335</span>&#160;output parameter `return_`.  The `__type` parameters can be one of</div><div class="line"><a name="l08336"></a><span class="lineno"> 8336</span>&#160;`SOAP_TYPE_xsd__string`, `SOAP_TYPE_xsd__int`,</div><div class="line"><a name="l08337"></a><span class="lineno"> 8337</span>&#160;`SOAP_TYPE_xsd__float`, `SOAP_TYPE_ns__status`, or</div><div class="line"><a name="l08338"></a><span class="lineno"> 8338</span>&#160;`SOAP_TYPE_ns__widget`.  The WSDL produced by the gSOAP `soapcpp2` compiler</div><div class="line"><a name="l08339"></a><span class="lineno"> 8339</span>&#160;declares the polymorphic parameters of type *`xsd:anyType`* which is &quot;too</div><div class="line"><a name="l08340"></a><span class="lineno"> 8340</span>&#160;loose&quot; and doesn&#39;t allow the gSOAP importer to handle the WSDL accurately.</div><div class="line"><a name="l08341"></a><span class="lineno"> 8341</span>&#160;Future gSOAP releases might replace *`xsd:anyType`* with a *`choice`*</div><div class="line"><a name="l08342"></a><span class="lineno"> 8342</span>&#160;schema type that limits the choice of types to the types declared in the</div><div class="line"><a name="l08343"></a><span class="lineno"> 8343</span>&#160;header file.</div><div class="line"><a name="l08344"></a><span class="lineno"> 8344</span>&#160;</div><div class="line"><a name="l08345"></a><span class="lineno"> 8345</span>&#160;## Fixed-Size Arrays</div><div class="line"><a name="l08346"></a><span class="lineno"> 8346</span>&#160;</div><div class="line"><a name="l08347"></a><span class="lineno"> 8347</span>&#160;Fixed size arrays are encoded as per SOAP 1.1 one-dimensional array types.</div><div class="line"><a name="l08348"></a><span class="lineno"> 8348</span>&#160;Multi-dimensional fixed size arrays are encoded by gSOAP as nested</div><div class="line"><a name="l08349"></a><span class="lineno"> 8349</span>&#160;one-dimensional arrays in SOAP.  Encoding of fixed size arrays supports</div><div class="line"><a name="l08350"></a><span class="lineno"> 8350</span>&#160;partially transmitted and sparse array SOAP formats.</div><div class="line"><a name="l08351"></a><span class="lineno"> 8351</span>&#160;</div><div class="line"><a name="l08352"></a><span class="lineno"> 8352</span>&#160;The decoding of (multi-dimensional) fixed-size arrays supports the SOAP multi-dimensional array format as well as partially transmitted and sparse array formats.</div><div class="line"><a name="l08353"></a><span class="lineno"> 8353</span>&#160;</div><div class="line"><a name="l08354"></a><span class="lineno"> 8354</span>&#160;An example:</div><div class="line"><a name="l08355"></a><span class="lineno"> 8355</span>&#160;</div><div class="line"><a name="l08356"></a><span class="lineno"> 8356</span>&#160;```cpp</div><div class="line"><a name="l08357"></a><span class="lineno"> 8357</span>&#160;// Contents of header file &quot;fixed.h&quot;: </div><div class="line"><a name="l08358"></a><span class="lineno"> 8358</span>&#160;struct Example </div><div class="line"><a name="l08359"></a><span class="lineno"> 8359</span>&#160;{ </div><div class="line"><a name="l08360"></a><span class="lineno"> 8360</span>&#160;  float a[2][3]; </div><div class="line"><a name="l08361"></a><span class="lineno"> 8361</span>&#160;};</div><div class="line"><a name="l08362"></a><span class="lineno"> 8362</span>&#160;```</div><div class="line"><a name="l08363"></a><span class="lineno"> 8363</span>&#160;</div><div class="line"><a name="l08364"></a><span class="lineno"> 8364</span>&#160;This specifies a fixed-size array part of the `struct Example`. The encoding of array `a` is:</div><div class="line"><a name="l08365"></a><span class="lineno"> 8365</span>&#160;</div><div class="line"><a name="l08366"></a><span class="lineno"> 8366</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l08367"></a><span class="lineno"> 8367</span>&#160;```xml</div><div class="line"><a name="l08368"></a><span class="lineno"> 8368</span>&#160;&lt;a xsi:type=&quot;SOAP-ENC:Array&quot; SOAP-ENC:arrayType=&quot;float[][2]&quot;&gt; </div><div class="line"><a name="l08369"></a><span class="lineno"> 8369</span>&#160;&lt;SOAP-ENC:Array xsi:type=&quot;SOAP-ENC:Array&quot; SOAP-ENC:arrayType=&quot;float[3]&quot; </div><div class="line"><a name="l08370"></a><span class="lineno"> 8370</span>&#160;&lt;float xsi:type=&quot;float&quot;&gt;...&lt;/float&gt; </div><div class="line"><a name="l08371"></a><span class="lineno"> 8371</span>&#160;&lt;float xsi:type=&quot;float&quot;&gt;...&lt;/float&gt; </div><div class="line"><a name="l08372"></a><span class="lineno"> 8372</span>&#160;&lt;float xsi:type=&quot;float&quot;&gt;...&lt;/float&gt; </div><div class="line"><a name="l08373"></a><span class="lineno"> 8373</span>&#160;&lt;/SOAP-ENC:Array&gt; </div><div class="line"><a name="l08374"></a><span class="lineno"> 8374</span>&#160;&lt;SOAP-ENC:Array xsi:type=&quot;SOAP-ENC:Array&quot; SOAP-ENC:arrayType=&quot;float[3]&quot; </div><div class="line"><a name="l08375"></a><span class="lineno"> 8375</span>&#160;&lt;float xsi:type=&quot;float&quot;&gt;...&lt;/float&gt; </div><div class="line"><a name="l08376"></a><span class="lineno"> 8376</span>&#160;&lt;float xsi:type=&quot;float&quot;&gt;...&lt;/float&gt; </div><div class="line"><a name="l08377"></a><span class="lineno"> 8377</span>&#160;&lt;float xsi:type=&quot;float&quot;&gt;...&lt;/float&gt; </div><div class="line"><a name="l08378"></a><span class="lineno"> 8378</span>&#160;&lt;/SOAP-ENC:Array&gt; </div><div class="line"><a name="l08379"></a><span class="lineno"> 8379</span>&#160;&lt;/a&gt;</div><div class="line"><a name="l08380"></a><span class="lineno"> 8380</span>&#160;```</div><div class="line"><a name="l08381"></a><span class="lineno"> 8381</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l08382"></a><span class="lineno"> 8382</span>&#160;</div><div class="line"><a name="l08383"></a><span class="lineno"> 8383</span>&#160;@warning Any decoded parts of a (multi-dimensional) array that do not &quot;fit&quot; in the fixed size array are ignored by the deserializer.</div><div class="line"><a name="l08384"></a><span class="lineno"> 8384</span>&#160;</div><div class="line"><a name="l08385"></a><span class="lineno"> 8385</span>&#160;## Dynamic Arrays        {#dynarray}</div><div class="line"><a name="l08386"></a><span class="lineno"> 8386</span>&#160;</div><div class="line"><a name="l08387"></a><span class="lineno"> 8387</span>&#160;As the name suggests, dynamic arrays are much more flexible than fixed-size</div><div class="line"><a name="l08388"></a><span class="lineno"> 8388</span>&#160;arrays and dynamic arrays are better adaptable to the SOAP encoding and decoding</div><div class="line"><a name="l08389"></a><span class="lineno"> 8389</span>&#160;rules for arrays.  In addition, a typical C application allocates a dynamic</div><div class="line"><a name="l08390"></a><span class="lineno"> 8390</span>&#160;array using `malloc`, assigns the location to a pointer variable, and</div><div class="line"><a name="l08391"></a><span class="lineno"> 8391</span>&#160;deallocates the array later with `free`.  A typical C++ application</div><div class="line"><a name="l08392"></a><span class="lineno"> 8392</span>&#160;allocates a dynamic array using `new`, assigns the location to a pointer</div><div class="line"><a name="l08393"></a><span class="lineno"> 8393</span>&#160;variable, and deallocates the array later with `delete`.  Such dynamic</div><div class="line"><a name="l08394"></a><span class="lineno"> 8394</span>&#160;allocations are flexible, but pose a problem for the serialization of data: how</div><div class="line"><a name="l08395"></a><span class="lineno"> 8395</span>&#160;does the array serializer know the length of the array to be serialized given</div><div class="line"><a name="l08396"></a><span class="lineno"> 8396</span>&#160;only a pointer to the sequence of elements?  The application stores the size</div><div class="line"><a name="l08397"></a><span class="lineno"> 8397</span>&#160;information somewhere. This information is crucial for the array serializer and</div><div class="line"><a name="l08398"></a><span class="lineno"> 8398</span>&#160;has to be made explicitly known to the array serializer by packaging the</div><div class="line"><a name="l08399"></a><span class="lineno"> 8399</span>&#160;pointer and array size information within a `struct` or `class`.</div><div class="line"><a name="l08400"></a><span class="lineno"> 8400</span>&#160;</div><div class="line"><a name="l08401"></a><span class="lineno"> 8401</span>&#160;### SOAP Array Bounds Limits</div><div class="line"><a name="l08402"></a><span class="lineno"> 8402</span>&#160;</div><div class="line"><a name="l08403"></a><span class="lineno"> 8403</span>&#160;SOAP encoded arrays use the *`SOAP-ENC:Array`* type and the *`SOAP-ENC:arrayType`* attribute to define the array dimensionality and size. As a security measure to avoid denial of service attacks based on sending a huge array size value requiring the allocation of large chunks of memory, the total number of array elements set by the *`SOAP-ENC:arrayType`* attribute cannot exceed `SOAP_MAXARRAYSIZE`, which is set to 100,000 by default. This constant is defined in `stdsoap2.h`. This constant **only** affects multi-dimensional arrays and the dimensionality of the receiving array will be lost when the number of elements exceeds 100,000. One-dimensional arrays will be populated in sequential order as expected.</div><div class="line"><a name="l08404"></a><span class="lineno"> 8404</span>&#160;</div><div class="line"><a name="l08405"></a><span class="lineno"> 8405</span>&#160;### One-Dimensional Dynamic SOAP Arrays</div><div class="line"><a name="l08406"></a><span class="lineno"> 8406</span>&#160;</div><div class="line"><a name="l08407"></a><span class="lineno"> 8407</span>&#160;A special form of `struct` or `class` is used to define one-dimensional</div><div class="line"><a name="l08408"></a><span class="lineno"> 8408</span>&#160;dynamic SOAP-encoded arrays. Each array has a pointer variable and a field that records the</div><div class="line"><a name="l08409"></a><span class="lineno"> 8409</span>&#160;number of elements the pointer points to in memory.</div><div class="line"><a name="l08410"></a><span class="lineno"> 8410</span>&#160;</div><div class="line"><a name="l08411"></a><span class="lineno"> 8411</span>&#160;The general form of the `struct` declaration that contains a one-dimensional dynamic SOAP-encoded array is:</div><div class="line"><a name="l08412"></a><span class="lineno"> 8412</span>&#160;</div><div class="line"><a name="l08413"></a><span class="lineno"> 8413</span>&#160;```cpp</div><div class="line"><a name="l08414"></a><span class="lineno"> 8414</span>&#160;struct some_name </div><div class="line"><a name="l08415"></a><span class="lineno"> 8415</span>&#160;{ </div><div class="line"><a name="l08416"></a><span class="lineno"> 8416</span>&#160;   Type *__ptr; // pointer to array of elements in memory</div><div class="line"><a name="l08417"></a><span class="lineno"> 8417</span>&#160;   int __size; // number of elements pointed to </div><div class="line"><a name="l08418"></a><span class="lineno"> 8418</span>&#160;   [optional: [optional: static const] int __offset [optional: = ...];] // optional SOAP 1.1 array offset </div><div class="line"><a name="l08419"></a><span class="lineno"> 8419</span>&#160;   ... // anything that follows here will be ignored </div><div class="line"><a name="l08420"></a><span class="lineno"> 8420</span>&#160;};</div><div class="line"><a name="l08421"></a><span class="lineno"> 8421</span>&#160;```</div><div class="line"><a name="l08422"></a><span class="lineno"> 8422</span>&#160;</div><div class="line"><a name="l08423"></a><span class="lineno"> 8423</span>&#160;where `Type` MUST be a type associated with an XML Schema or MUST be a primitive type.</div><div class="line"><a name="l08424"></a><span class="lineno"> 8424</span>&#160;If these conditions are not met, a vector-like XML (de)serialization is used (see Section \ref list ).</div><div class="line"><a name="l08425"></a><span class="lineno"> 8425</span>&#160;A primitive type can be used with or without a `typedef`.</div><div class="line"><a name="l08426"></a><span class="lineno"> 8426</span>&#160;If the array elements are structs or classes, then the `struct`/`class` type names should have a namespace prefix for schema</div><div class="line"><a name="l08427"></a><span class="lineno"> 8427</span>&#160;association, or they should be other (nested) dynamic arrays. </div><div class="line"><a name="l08428"></a><span class="lineno"> 8428</span>&#160;</div><div class="line"><a name="l08429"></a><span class="lineno"> 8429</span>&#160;An alternative to a `struct` is to use a `class` with optional methods that MUST appear after the `__ptr` and</div><div class="line"><a name="l08430"></a><span class="lineno"> 8430</span>&#160;`__size` fields:</div><div class="line"><a name="l08431"></a><span class="lineno"> 8431</span>&#160;</div><div class="line"><a name="l08432"></a><span class="lineno"> 8432</span>&#160;```cpp</div><div class="line"><a name="l08433"></a><span class="lineno"> 8433</span>&#160;class some_name </div><div class="line"><a name="l08434"></a><span class="lineno"> 8434</span>&#160;{ </div><div class="line"><a name="l08435"></a><span class="lineno"> 8435</span>&#160;   public: </div><div class="line"><a name="l08436"></a><span class="lineno"> 8436</span>&#160;   Type *__ptr; </div><div class="line"><a name="l08437"></a><span class="lineno"> 8437</span>&#160;   int __size; </div><div class="line"><a name="l08438"></a><span class="lineno"> 8438</span>&#160;   [optional: [optional: static const] int __offset [optional: = ...];] </div><div class="line"><a name="l08439"></a><span class="lineno"> 8439</span>&#160;   method1; </div><div class="line"><a name="l08440"></a><span class="lineno"> 8440</span>&#160;   method2; </div><div class="line"><a name="l08441"></a><span class="lineno"> 8441</span>&#160;   ... // any fields that follow will be ignored </div><div class="line"><a name="l08442"></a><span class="lineno"> 8442</span>&#160;};</div><div class="line"><a name="l08443"></a><span class="lineno"> 8443</span>&#160;```</div><div class="line"><a name="l08444"></a><span class="lineno"> 8444</span>&#160;</div><div class="line"><a name="l08445"></a><span class="lineno"> 8445</span>&#160;To encode the data type as an array, the name of the `struct` or</div><div class="line"><a name="l08446"></a><span class="lineno"> 8446</span>&#160;`class` SHOULD NOT have a namespace prefix, otherwise the data type will</div><div class="line"><a name="l08447"></a><span class="lineno"> 8447</span>&#160;be encoded and decoded as a generic vector, see Section \ref list .</div><div class="line"><a name="l08448"></a><span class="lineno"> 8448</span>&#160;</div><div class="line"><a name="l08449"></a><span class="lineno"> 8449</span>&#160;The deserializer of a dynamic array can decode partially transmitted and/or</div><div class="line"><a name="l08450"></a><span class="lineno"> 8450</span>&#160;SOAP sparse arrays, and even multi-dimensional arrays which will be collapsed</div><div class="line"><a name="l08451"></a><span class="lineno"> 8451</span>&#160;into a one-dimensional array with row-major ordering.</div><div class="line"><a name="l08452"></a><span class="lineno"> 8452</span>&#160;</div><div class="line"><a name="l08453"></a><span class="lineno"> 8453</span>&#160;@warning SOAP 1.2 does not support partially transmitted arrays. So the `__offset` field of a dynamic array is ignored.</div><div class="line"><a name="l08454"></a><span class="lineno"> 8454</span>&#160;</div><div class="line"><a name="l08455"></a><span class="lineno"> 8455</span>&#160;### Example</div><div class="line"><a name="l08456"></a><span class="lineno"> 8456</span>&#160;</div><div class="line"><a name="l08457"></a><span class="lineno"> 8457</span>&#160;The following example header file specifies the XMethods Service Listing service `getAllSOAPServices` service operation and an array of `SOAPService` data structures:</div><div class="line"><a name="l08458"></a><span class="lineno"> 8458</span>&#160;</div><div class="line"><a name="l08459"></a><span class="lineno"> 8459</span>&#160;```cpp</div><div class="line"><a name="l08460"></a><span class="lineno"> 8460</span>&#160;// Contents of file &quot;listing.h&quot;: </div><div class="line"><a name="l08461"></a><span class="lineno"> 8461</span>&#160;class ns3__SOAPService </div><div class="line"><a name="l08462"></a><span class="lineno"> 8462</span>&#160;{ </div><div class="line"><a name="l08463"></a><span class="lineno"> 8463</span>&#160;   public: </div><div class="line"><a name="l08464"></a><span class="lineno"> 8464</span>&#160;   int ID; </div><div class="line"><a name="l08465"></a><span class="lineno"> 8465</span>&#160;   char *name; </div><div class="line"><a name="l08466"></a><span class="lineno"> 8466</span>&#160;   char *owner; </div><div class="line"><a name="l08467"></a><span class="lineno"> 8467</span>&#160;   char *description; </div><div class="line"><a name="l08468"></a><span class="lineno"> 8468</span>&#160;   char *homepageURL; </div><div class="line"><a name="l08469"></a><span class="lineno"> 8469</span>&#160;   char *endpoint; </div><div class="line"><a name="l08470"></a><span class="lineno"> 8470</span>&#160;   char *SOAPAction; </div><div class="line"><a name="l08471"></a><span class="lineno"> 8471</span>&#160;   char *methodNamespaceURI; </div><div class="line"><a name="l08472"></a><span class="lineno"> 8472</span>&#160;   char *serviceStatus; </div><div class="line"><a name="l08473"></a><span class="lineno"> 8473</span>&#160;   char *methodName; </div><div class="line"><a name="l08474"></a><span class="lineno"> 8474</span>&#160;   char *dateCreated; </div><div class="line"><a name="l08475"></a><span class="lineno"> 8475</span>&#160;   char *downloadURL; </div><div class="line"><a name="l08476"></a><span class="lineno"> 8476</span>&#160;   char *wsdlURL; </div><div class="line"><a name="l08477"></a><span class="lineno"> 8477</span>&#160;   char *instructions; </div><div class="line"><a name="l08478"></a><span class="lineno"> 8478</span>&#160;   char *contactEmail; </div><div class="line"><a name="l08479"></a><span class="lineno"> 8479</span>&#160;   char *serverImplementation; </div><div class="line"><a name="l08480"></a><span class="lineno"> 8480</span>&#160;}; </div><div class="line"><a name="l08481"></a><span class="lineno"> 8481</span>&#160;class ServiceArray </div><div class="line"><a name="l08482"></a><span class="lineno"> 8482</span>&#160;{ </div><div class="line"><a name="l08483"></a><span class="lineno"> 8483</span>&#160;   public: </div><div class="line"><a name="l08484"></a><span class="lineno"> 8484</span>&#160;   ns3__SOAPService *__ptr; // points to array elements </div><div class="line"><a name="l08485"></a><span class="lineno"> 8485</span>&#160;   int __size; // number of elements pointed to </div><div class="line"><a name="l08486"></a><span class="lineno"> 8486</span>&#160;   ServiceArray(); </div><div class="line"><a name="l08487"></a><span class="lineno"> 8487</span>&#160;   ~ServiceArray(); </div><div class="line"><a name="l08488"></a><span class="lineno"> 8488</span>&#160;   void print(); </div><div class="line"><a name="l08489"></a><span class="lineno"> 8489</span>&#160;}; </div><div class="line"><a name="l08490"></a><span class="lineno"> 8490</span>&#160;int ns__getAllSOAPServices(ServiceArray &amp;return_);</div><div class="line"><a name="l08491"></a><span class="lineno"> 8491</span>&#160;```</div><div class="line"><a name="l08492"></a><span class="lineno"> 8492</span>&#160;</div><div class="line"><a name="l08493"></a><span class="lineno"> 8493</span>&#160;An example client application:</div><div class="line"><a name="l08494"></a><span class="lineno"> 8494</span>&#160;</div><div class="line"><a name="l08495"></a><span class="lineno"> 8495</span>&#160;```cpp</div><div class="line"><a name="l08496"></a><span class="lineno"> 8496</span>&#160;#include &quot;soapH.h&quot;</div><div class="line"><a name="l08497"></a><span class="lineno"> 8497</span>&#160;... </div><div class="line"><a name="l08498"></a><span class="lineno"> 8498</span>&#160;// ServiceArray class method implementations: </div><div class="line"><a name="l08499"></a><span class="lineno"> 8499</span>&#160;ServiceArray::ServiceArray() </div><div class="line"><a name="l08500"></a><span class="lineno"> 8500</span>&#160;{ </div><div class="line"><a name="l08501"></a><span class="lineno"> 8501</span>&#160;   __ptr = NULL; </div><div class="line"><a name="l08502"></a><span class="lineno"> 8502</span>&#160;   __size = 0; </div><div class="line"><a name="l08503"></a><span class="lineno"> 8503</span>&#160;} </div><div class="line"><a name="l08504"></a><span class="lineno"> 8504</span>&#160;ServiceArray::~ServiceArray() </div><div class="line"><a name="l08505"></a><span class="lineno"> 8505</span>&#160;{ // destruction handled by gSOAP </div><div class="line"><a name="l08506"></a><span class="lineno"> 8506</span>&#160;} </div><div class="line"><a name="l08507"></a><span class="lineno"> 8507</span>&#160;void ServiceArray::print() </div><div class="line"><a name="l08508"></a><span class="lineno"> 8508</span>&#160;{ </div><div class="line"><a name="l08509"></a><span class="lineno"> 8509</span>&#160;   for (int i = 0; i &lt; __size; i++) </div><div class="line"><a name="l08510"></a><span class="lineno"> 8510</span>&#160;     cout &lt;&lt; __ptr[i].name &lt;&lt; &quot;: &quot; &lt;&lt; __ptr[i].homepage &lt;&lt; endl; </div><div class="line"><a name="l08511"></a><span class="lineno"> 8511</span>&#160;} </div><div class="line"><a name="l08512"></a><span class="lineno"> 8512</span>&#160;... </div><div class="line"><a name="l08513"></a><span class="lineno"> 8513</span>&#160;// Request a service listing and display results: </div><div class="line"><a name="l08514"></a><span class="lineno"> 8514</span>&#160;{ </div><div class="line"><a name="l08515"></a><span class="lineno"> 8515</span>&#160;   struct soap soap; </div><div class="line"><a name="l08516"></a><span class="lineno"> 8516</span>&#160;   ServiceArray result; </div><div class="line"><a name="l08517"></a><span class="lineno"> 8517</span>&#160;   const char *endpoint = &quot;www.xmethods.net:80/soap/servlet/rpcrouter&quot;; </div><div class="line"><a name="l08518"></a><span class="lineno"> 8518</span>&#160;   const char *action = &quot;urn:xmethodsServicesManager#getAllSOAPServices&quot;; </div><div class="line"><a name="l08519"></a><span class="lineno"> 8519</span>&#160;   ... </div><div class="line"><a name="l08520"></a><span class="lineno"> 8520</span>&#160;   soap_init(&amp;soap); </div><div class="line"><a name="l08521"></a><span class="lineno"> 8521</span>&#160;   soap_call_ns__getAllSOAPServices(&amp;soap, endpoint, action, result); </div><div class="line"><a name="l08522"></a><span class="lineno"> 8522</span>&#160;   result.print(); </div><div class="line"><a name="l08523"></a><span class="lineno"> 8523</span>&#160;   ... </div><div class="line"><a name="l08524"></a><span class="lineno"> 8524</span>&#160;   soap_destroy(&amp;soap); // dealloc class instances </div><div class="line"><a name="l08525"></a><span class="lineno"> 8525</span>&#160;   soap_end(&amp;soap); // dealloc deserialized data </div><div class="line"><a name="l08526"></a><span class="lineno"> 8526</span>&#160;   soap_done(&amp;soap); // cleanup and detach soap struct </div><div class="line"><a name="l08527"></a><span class="lineno"> 8527</span>&#160;}</div><div class="line"><a name="l08528"></a><span class="lineno"> 8528</span>&#160;```</div><div class="line"><a name="l08529"></a><span class="lineno"> 8529</span>&#160;</div><div class="line"><a name="l08530"></a><span class="lineno"> 8530</span>&#160;### One-Dimensional Dynamic SOAP Arrays With Non-Zero Offset</div><div class="line"><a name="l08531"></a><span class="lineno"> 8531</span>&#160;</div><div class="line"><a name="l08532"></a><span class="lineno"> 8532</span>&#160;The declaration of a dynamic array as described in \ref dynarray  MAY</div><div class="line"><a name="l08533"></a><span class="lineno"> 8533</span>&#160;include an `int __offset` field. When set to an integer value, the</div><div class="line"><a name="l08534"></a><span class="lineno"> 8534</span>&#160;serializer of the dynamic array will use this field as the start index of the</div><div class="line"><a name="l08535"></a><span class="lineno"> 8535</span>&#160;array and the SOAP array offset attribute will be used in the SOAP payload.</div><div class="line"><a name="l08536"></a><span class="lineno"> 8536</span>&#160;Note that array offsets is a SOAP 1.1 specific feature which is not supported</div><div class="line"><a name="l08537"></a><span class="lineno"> 8537</span>&#160;in SOAP 1.2.</div><div class="line"><a name="l08538"></a><span class="lineno"> 8538</span>&#160;</div><div class="line"><a name="l08539"></a><span class="lineno"> 8539</span>&#160;For example, the following header file declares a mathematical `Vector`</div><div class="line"><a name="l08540"></a><span class="lineno"> 8540</span>&#160;class, which is a dynamic array of floating point values with an index that</div><div class="line"><a name="l08541"></a><span class="lineno"> 8541</span>&#160;starts at 1:</div><div class="line"><a name="l08542"></a><span class="lineno"> 8542</span>&#160;</div><div class="line"><a name="l08543"></a><span class="lineno"> 8543</span>&#160;```cpp</div><div class="line"><a name="l08544"></a><span class="lineno"> 8544</span>&#160;// Contents of file &quot;vector.h&quot;: </div><div class="line"><a name="l08545"></a><span class="lineno"> 8545</span>&#160;typedef float xsd__float; </div><div class="line"><a name="l08546"></a><span class="lineno"> 8546</span>&#160;class Vector </div><div class="line"><a name="l08547"></a><span class="lineno"> 8547</span>&#160;{ </div><div class="line"><a name="l08548"></a><span class="lineno"> 8548</span>&#160;   xsd__float *__ptr; </div><div class="line"><a name="l08549"></a><span class="lineno"> 8549</span>&#160;  int __size; </div><div class="line"><a name="l08550"></a><span class="lineno"> 8550</span>&#160;  int __offset; </div><div class="line"><a name="l08551"></a><span class="lineno"> 8551</span>&#160;   Vector(); </div><div class="line"><a name="l08552"></a><span class="lineno"> 8552</span>&#160;   Vector(int n); </div><div class="line"><a name="l08553"></a><span class="lineno"> 8553</span>&#160;  float&amp; \operator[](int i); </div><div class="line"><a name="l08554"></a><span class="lineno"> 8554</span>&#160;}</div><div class="line"><a name="l08555"></a><span class="lineno"> 8555</span>&#160;```</div><div class="line"><a name="l08556"></a><span class="lineno"> 8556</span>&#160;</div><div class="line"><a name="l08557"></a><span class="lineno"> 8557</span>&#160;The implementations of the `Vector` methods are:</div><div class="line"><a name="l08558"></a><span class="lineno"> 8558</span>&#160;</div><div class="line"><a name="l08559"></a><span class="lineno"> 8559</span>&#160;```cpp</div><div class="line"><a name="l08560"></a><span class="lineno"> 8560</span>&#160;Vector::Vector() </div><div class="line"><a name="l08561"></a><span class="lineno"> 8561</span>&#160;{ </div><div class="line"><a name="l08562"></a><span class="lineno"> 8562</span>&#160;   __ptr = NULL; </div><div class="line"><a name="l08563"></a><span class="lineno"> 8563</span>&#160;   __size = 0; </div><div class="line"><a name="l08564"></a><span class="lineno"> 8564</span>&#160;   __offset = 1; </div><div class="line"><a name="l08565"></a><span class="lineno"> 8565</span>&#160;} </div><div class="line"><a name="l08566"></a><span class="lineno"> 8566</span>&#160;Vector::Vector(int n) </div><div class="line"><a name="l08567"></a><span class="lineno"> 8567</span>&#160;{ </div><div class="line"><a name="l08568"></a><span class="lineno"> 8568</span>&#160;   __ptr = (float*)malloc(n*sizeof(float)); </div><div class="line"><a name="l08569"></a><span class="lineno"> 8569</span>&#160;   __size = n; </div><div class="line"><a name="l08570"></a><span class="lineno"> 8570</span>&#160;   __offset = 1; </div><div class="line"><a name="l08571"></a><span class="lineno"> 8571</span>&#160;} </div><div class="line"><a name="l08572"></a><span class="lineno"> 8572</span>&#160;Vector::~Vector() </div><div class="line"><a name="l08573"></a><span class="lineno"> 8573</span>&#160;{ </div><div class="line"><a name="l08574"></a><span class="lineno"> 8574</span>&#160;   if (__ptr) </div><div class="line"><a name="l08575"></a><span class="lineno"> 8575</span>&#160;      free(__ptr); </div><div class="line"><a name="l08576"></a><span class="lineno"> 8576</span>&#160;} </div><div class="line"><a name="l08577"></a><span class="lineno"> 8577</span>&#160;float&amp; Vector::\operator[](int i) </div><div class="line"><a name="l08578"></a><span class="lineno"> 8578</span>&#160;{ </div><div class="line"><a name="l08579"></a><span class="lineno"> 8579</span>&#160;   return __ptr[i-__offset]; </div><div class="line"><a name="l08580"></a><span class="lineno"> 8580</span>&#160;}</div><div class="line"><a name="l08581"></a><span class="lineno"> 8581</span>&#160;```</div><div class="line"><a name="l08582"></a><span class="lineno"> 8582</span>&#160;</div><div class="line"><a name="l08583"></a><span class="lineno"> 8583</span>&#160;An example program fragment that serializes a vector of 3 elements:</div><div class="line"><a name="l08584"></a><span class="lineno"> 8584</span>&#160;</div><div class="line"><a name="l08585"></a><span class="lineno"> 8585</span>&#160;```cpp</div><div class="line"><a name="l08586"></a><span class="lineno"> 8586</span>&#160;struct soap soap; </div><div class="line"><a name="l08587"></a><span class="lineno"> 8587</span>&#160;soap_init(&amp;soap); </div><div class="line"><a name="l08588"></a><span class="lineno"> 8588</span>&#160;Vector v(3); </div><div class="line"><a name="l08589"></a><span class="lineno"> 8589</span>&#160;v[1] = 1.0; </div><div class="line"><a name="l08590"></a><span class="lineno"> 8590</span>&#160;v[2] = 2.0; </div><div class="line"><a name="l08591"></a><span class="lineno"> 8591</span>&#160;v[3] = 3.0; </div><div class="line"><a name="l08592"></a><span class="lineno"> 8592</span>&#160;soap_begin(&amp;soap); </div><div class="line"><a name="l08593"></a><span class="lineno"> 8593</span>&#160;v.serialize(&amp;soap); </div><div class="line"><a name="l08594"></a><span class="lineno"> 8594</span>&#160;v.put(&quot;vec&quot;); </div><div class="line"><a name="l08595"></a><span class="lineno"> 8595</span>&#160;soap_end(&amp;soap);</div><div class="line"><a name="l08596"></a><span class="lineno"> 8596</span>&#160;```</div><div class="line"><a name="l08597"></a><span class="lineno"> 8597</span>&#160;</div><div class="line"><a name="l08598"></a><span class="lineno"> 8598</span>&#160;The output is a partially transmitted array:</div><div class="line"><a name="l08599"></a><span class="lineno"> 8599</span>&#160;</div><div class="line"><a name="l08600"></a><span class="lineno"> 8600</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l08601"></a><span class="lineno"> 8601</span>&#160;```xml</div><div class="line"><a name="l08602"></a><span class="lineno"> 8602</span>&#160;&lt;vec xsi:type=&quot;SOAP-ENC:Array&quot; SOAP-ENC:arrayType=&quot;xsd:float[4]&quot; SOAP-ENC:offset=&quot;[1]&quot;&gt; </div><div class="line"><a name="l08603"></a><span class="lineno"> 8603</span>&#160;&lt;item xsi:type=&quot;xsd:float&quot;&gt;1.0&lt;/item&gt; </div><div class="line"><a name="l08604"></a><span class="lineno"> 8604</span>&#160;&lt;item xsi:type=&quot;xsd:float&quot;&gt;2.0&lt;/item&gt; </div><div class="line"><a name="l08605"></a><span class="lineno"> 8605</span>&#160;&lt;item xsi:type=&quot;xsd:float&quot;&gt;3.0&lt;/item&gt; </div><div class="line"><a name="l08606"></a><span class="lineno"> 8606</span>&#160;&lt;/vec&gt;</div><div class="line"><a name="l08607"></a><span class="lineno"> 8607</span>&#160;```</div><div class="line"><a name="l08608"></a><span class="lineno"> 8608</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l08609"></a><span class="lineno"> 8609</span>&#160;</div><div class="line"><a name="l08610"></a><span class="lineno"> 8610</span>&#160;Note that the size of the encoded array is necessarily set to 4 and that the encoding omits the non-existent element at index 0.</div><div class="line"><a name="l08611"></a><span class="lineno"> 8611</span>&#160;</div><div class="line"><a name="l08612"></a><span class="lineno"> 8612</span>&#160;The decoding of a dynamic array with an `__offset` field is more efficient than decoding a dynamic array without an `__offset` field, because the `__offset` field will be assigned the value of the *`SOAP-ENC:offset`* attribute instead of padding the initial part of the array with default values.</div><div class="line"><a name="l08613"></a><span class="lineno"> 8613</span>&#160;</div><div class="line"><a name="l08614"></a><span class="lineno"> 8614</span>&#160;### Nested One-Dimensional Dynamic SOAP Arrays        {#nested}</div><div class="line"><a name="l08615"></a><span class="lineno"> 8615</span>&#160;</div><div class="line"><a name="l08616"></a><span class="lineno"> 8616</span>&#160;One-dimensional dynamic arrays MAY be nested.</div><div class="line"><a name="l08617"></a><span class="lineno"> 8617</span>&#160;For example, using `class Vector` declared in the previous section, `class Matrix` is declared:</div><div class="line"><a name="l08618"></a><span class="lineno"> 8618</span>&#160;</div><div class="line"><a name="l08619"></a><span class="lineno"> 8619</span>&#160;```cpp</div><div class="line"><a name="l08620"></a><span class="lineno"> 8620</span>&#160;// Contents of file &quot;matrix.h&quot;: </div><div class="line"><a name="l08621"></a><span class="lineno"> 8621</span>&#160;class Matrix </div><div class="line"><a name="l08622"></a><span class="lineno"> 8622</span>&#160;{ </div><div class="line"><a name="l08623"></a><span class="lineno"> 8623</span>&#160;   public: </div><div class="line"><a name="l08624"></a><span class="lineno"> 8624</span>&#160;   Vector *__ptr; </div><div class="line"><a name="l08625"></a><span class="lineno"> 8625</span>&#160;   int __size; </div><div class="line"><a name="l08626"></a><span class="lineno"> 8626</span>&#160;   int __offset; </div><div class="line"><a name="l08627"></a><span class="lineno"> 8627</span>&#160;   Matrix(); </div><div class="line"><a name="l08628"></a><span class="lineno"> 8628</span>&#160;   Matrix(int n, int m); </div><div class="line"><a name="l08629"></a><span class="lineno"> 8629</span>&#160;   ~Matrix(); </div><div class="line"><a name="l08630"></a><span class="lineno"> 8630</span>&#160;   Vector&amp; \operator[](int i); </div><div class="line"><a name="l08631"></a><span class="lineno"> 8631</span>&#160;}; </div><div class="line"><a name="l08632"></a><span class="lineno"> 8632</span>&#160;```</div><div class="line"><a name="l08633"></a><span class="lineno"> 8633</span>&#160;</div><div class="line"><a name="l08634"></a><span class="lineno"> 8634</span>&#160;The Matrix type is essentially an array of pointers to arrays which make up the rows of a matrix.</div><div class="line"><a name="l08635"></a><span class="lineno"> 8635</span>&#160;The encoding of the two-dimensional dynamic array in SOAP will be in nested form.</div><div class="line"><a name="l08636"></a><span class="lineno"> 8636</span>&#160;</div><div class="line"><a name="l08637"></a><span class="lineno"> 8637</span>&#160;### Multi-Dimensional Dynamic SOAP Arrays</div><div class="line"><a name="l08638"></a><span class="lineno"> 8638</span>&#160;</div><div class="line"><a name="l08639"></a><span class="lineno"> 8639</span>&#160;The general form of the `struct` declaration for K-dimensional (K&gt;1) dynamic arrays is:</div><div class="line"><a name="l08640"></a><span class="lineno"> 8640</span>&#160;</div><div class="line"><a name="l08641"></a><span class="lineno"> 8641</span>&#160;```cpp</div><div class="line"><a name="l08642"></a><span class="lineno"> 8642</span>&#160;struct some_name </div><div class="line"><a name="l08643"></a><span class="lineno"> 8643</span>&#160;{ </div><div class="line"><a name="l08644"></a><span class="lineno"> 8644</span>&#160;   Type *__ptr; </div><div class="line"><a name="l08645"></a><span class="lineno"> 8645</span>&#160;   int __size[K]; </div><div class="line"><a name="l08646"></a><span class="lineno"> 8646</span>&#160;   int __offset[K]; </div><div class="line"><a name="l08647"></a><span class="lineno"> 8647</span>&#160;   ... // anything that follows here will be ignored </div><div class="line"><a name="l08648"></a><span class="lineno"> 8648</span>&#160;};</div><div class="line"><a name="l08649"></a><span class="lineno"> 8649</span>&#160;```</div><div class="line"><a name="l08650"></a><span class="lineno"> 8650</span>&#160;</div><div class="line"><a name="l08651"></a><span class="lineno"> 8651</span>&#160;where `Type` MUST be a type associated with an XML Schema, which means that it must be a `typedef`ed type</div><div class="line"><a name="l08652"></a><span class="lineno"> 8652</span>&#160;in case of a primitive type, or a `struct`/`class` name with a namespace prefix for schema association, or another dynamic array. If these conditions are not met, a generic vector XML (de)serialization is used (see Section \ref list ).</div><div class="line"><a name="l08653"></a><span class="lineno"> 8653</span>&#160;</div><div class="line"><a name="l08654"></a><span class="lineno"> 8654</span>&#160;An alternative is to use a `class` with optional methods:</div><div class="line"><a name="l08655"></a><span class="lineno"> 8655</span>&#160;</div><div class="line"><a name="l08656"></a><span class="lineno"> 8656</span>&#160;```cpp</div><div class="line"><a name="l08657"></a><span class="lineno"> 8657</span>&#160;class some_name </div><div class="line"><a name="l08658"></a><span class="lineno"> 8658</span>&#160;{ </div><div class="line"><a name="l08659"></a><span class="lineno"> 8659</span>&#160;   public: </div><div class="line"><a name="l08660"></a><span class="lineno"> 8660</span>&#160;   Type *__ptr; </div><div class="line"><a name="l08661"></a><span class="lineno"> 8661</span>&#160;   int __size[K]; </div><div class="line"><a name="l08662"></a><span class="lineno"> 8662</span>&#160;   int __offset[K]; </div><div class="line"><a name="l08663"></a><span class="lineno"> 8663</span>&#160;   method1; </div><div class="line"><a name="l08664"></a><span class="lineno"> 8664</span>&#160;   method2; </div><div class="line"><a name="l08665"></a><span class="lineno"> 8665</span>&#160;   ... // any fields that follow will be ignored </div><div class="line"><a name="l08666"></a><span class="lineno"> 8666</span>&#160;};</div><div class="line"><a name="l08667"></a><span class="lineno"> 8667</span>&#160;```</div><div class="line"><a name="l08668"></a><span class="lineno"> 8668</span>&#160;</div><div class="line"><a name="l08669"></a><span class="lineno"> 8669</span>&#160;In the above, K is a constant denoting the number of dimensions of the multi-dimensional array.</div><div class="line"><a name="l08670"></a><span class="lineno"> 8670</span>&#160;</div><div class="line"><a name="l08671"></a><span class="lineno"> 8671</span>&#160;To encode the data type as an array, the name of the `struct` or `class` SHOULD NOT have a namespace prefix, otherwise</div><div class="line"><a name="l08672"></a><span class="lineno"> 8672</span>&#160;the data type will be encoded and decoded as a generic vector, see Section \ref list .</div><div class="line"><a name="l08673"></a><span class="lineno"> 8673</span>&#160;</div><div class="line"><a name="l08674"></a><span class="lineno"> 8674</span>&#160;The deserializer of a dynamic array can decode partially transmitted multi-dimensional arrays.</div><div class="line"><a name="l08675"></a><span class="lineno"> 8675</span>&#160;</div><div class="line"><a name="l08676"></a><span class="lineno"> 8676</span>&#160;For example, the following declaration specifies a matrix class:</div><div class="line"><a name="l08677"></a><span class="lineno"> 8677</span>&#160;</div><div class="line"><a name="l08678"></a><span class="lineno"> 8678</span>&#160;```cpp</div><div class="line"><a name="l08679"></a><span class="lineno"> 8679</span>&#160;typedef double xsd__double; </div><div class="line"><a name="l08680"></a><span class="lineno"> 8680</span>&#160;class Matrix </div><div class="line"><a name="l08681"></a><span class="lineno"> 8681</span>&#160;{ </div><div class="line"><a name="l08682"></a><span class="lineno"> 8682</span>&#160;   public: </div><div class="line"><a name="l08683"></a><span class="lineno"> 8683</span>&#160;   xsd__double *__ptr; </div><div class="line"><a name="l08684"></a><span class="lineno"> 8684</span>&#160;   int __size[2]; </div><div class="line"><a name="l08685"></a><span class="lineno"> 8685</span>&#160;   int __offset[2]; </div><div class="line"><a name="l08686"></a><span class="lineno"> 8686</span>&#160;}; </div><div class="line"><a name="l08687"></a><span class="lineno"> 8687</span>&#160;```</div><div class="line"><a name="l08688"></a><span class="lineno"> 8688</span>&#160;</div><div class="line"><a name="l08689"></a><span class="lineno"> 8689</span>&#160;In contrast to the matrix class of Section \ref nested  that defined a matrix as an array of pointers to matrix rows, this</div><div class="line"><a name="l08690"></a><span class="lineno"> 8690</span>&#160;class has one pointer to a matrix stored in row-major order.  The size of the matrix is determined by the `__size` field:</div><div class="line"><a name="l08691"></a><span class="lineno"> 8691</span>&#160;`__size[0]` holds the number of rows and `__size[1]` holds the number of columns of the matrix.  Likewise, `__offset[0]` is the row offset and `__offset[1]` is the columns offset.</div><div class="line"><a name="l08692"></a><span class="lineno"> 8692</span>&#160;</div><div class="line"><a name="l08693"></a><span class="lineno"> 8693</span>&#160;### Encoding XML Generics Containing Dynamic Arrays        {#list}</div><div class="line"><a name="l08694"></a><span class="lineno"> 8694</span>&#160;</div><div class="line"><a name="l08695"></a><span class="lineno"> 8695</span>&#160;The XML &quot;generics&quot; concept discussed in the SOAP encoding protocols extends the concept of a SOAP struct by allowing repetitions of elements within the struct. This is just a form of a repetition of XML elements without the SOAP-encoded array requirements. While SOAP-encoded arrays are more expressive (offset information to encode sparse arrays for example), simple repetitions of values are used more frequently.</div><div class="line"><a name="l08696"></a><span class="lineno"> 8696</span>&#160;</div><div class="line"><a name="l08697"></a><span class="lineno"> 8697</span>&#160;A simple generic reperition is an array-like data structure with a repetition of an element.</div><div class="line"><a name="l08698"></a><span class="lineno"> 8698</span>&#160;To achieve this, declare a dynamic array as a `struct` or `class` with a name that is qualified with</div><div class="line"><a name="l08699"></a><span class="lineno"> 8699</span>&#160;a namespace prefix.  SOAP arrays are declared without prefix.</div><div class="line"><a name="l08700"></a><span class="lineno"> 8700</span>&#160;</div><div class="line"><a name="l08701"></a><span class="lineno"> 8701</span>&#160;For example, we define a Map structure that contains a sequence of pairs of key-val:</div><div class="line"><a name="l08702"></a><span class="lineno"> 8702</span>&#160;</div><div class="line"><a name="l08703"></a><span class="lineno"> 8703</span>&#160;```cpp</div><div class="line"><a name="l08704"></a><span class="lineno"> 8704</span>&#160;struct ns__Map </div><div class="line"><a name="l08705"></a><span class="lineno"> 8705</span>&#160;{ </div><div class="line"><a name="l08706"></a><span class="lineno"> 8706</span>&#160;   int __size; // number of pairs </div><div class="line"><a name="l08707"></a><span class="lineno"> 8707</span>&#160;   struct ns__Binding {char *key; char *val;} *pair; </div><div class="line"><a name="l08708"></a><span class="lineno"> 8708</span>&#160;};</div><div class="line"><a name="l08709"></a><span class="lineno"> 8709</span>&#160;```</div><div class="line"><a name="l08710"></a><span class="lineno"> 8710</span>&#160;</div><div class="line"><a name="l08711"></a><span class="lineno"> 8711</span>&#160;Since 2.7.16 it is also possible to use a &#39;`$`&#39; as a special marker to annotate a</div><div class="line"><a name="l08712"></a><span class="lineno"> 8712</span>&#160;size field that must be of type `int` or `size_t` and the field</div><div class="line"><a name="l08713"></a><span class="lineno"> 8713</span>&#160;name is no longer relevant:</div><div class="line"><a name="l08714"></a><span class="lineno"> 8714</span>&#160;</div><div class="line"><a name="l08715"></a><span class="lineno"> 8715</span>&#160;```cpp</div><div class="line"><a name="l08716"></a><span class="lineno"> 8716</span>&#160;struct ns__Map </div><div class="line"><a name="l08717"></a><span class="lineno"> 8717</span>&#160;{ </div><div class="line"><a name="l08718"></a><span class="lineno"> 8718</span>&#160;   $int length; // number of pairs </div><div class="line"><a name="l08719"></a><span class="lineno"> 8719</span>&#160;   struct ns__Binding {char *key; char *val;} *pair; </div><div class="line"><a name="l08720"></a><span class="lineno"> 8720</span>&#160;};</div><div class="line"><a name="l08721"></a><span class="lineno"> 8721</span>&#160;```</div><div class="line"><a name="l08722"></a><span class="lineno"> 8722</span>&#160;This declares a dynamic array pointed to by `pair` and size `__size`. The array will be serialized and deserialized as a sequence of pairs:</div><div class="line"><a name="l08723"></a><span class="lineno"> 8723</span>&#160;</div><div class="line"><a name="l08724"></a><span class="lineno"> 8724</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l08725"></a><span class="lineno"> 8725</span>&#160;```xml</div><div class="line"><a name="l08726"></a><span class="lineno"> 8726</span>&#160;&lt;ns:Map xsi:type=&quot;ns:Map&quot;&gt; </div><div class="line"><a name="l08727"></a><span class="lineno"> 8727</span>&#160;&lt;pair xsi:type=&quot;ns:Binding&quot;&gt; </div><div class="line"><a name="l08728"></a><span class="lineno"> 8728</span>&#160;&lt;key&gt;Joe&lt;/key&gt; </div><div class="line"><a name="l08729"></a><span class="lineno"> 8729</span>&#160;&lt;val&gt;555 77 1234&lt;/val&gt; </div><div class="line"><a name="l08730"></a><span class="lineno"> 8730</span>&#160;&lt;/pair&gt; </div><div class="line"><a name="l08731"></a><span class="lineno"> 8731</span>&#160;&lt;pair xsi:type=&quot;ns:Binding&quot;&gt; </div><div class="line"><a name="l08732"></a><span class="lineno"> 8732</span>&#160;&lt;key&gt;Susan&lt;/key&gt; </div><div class="line"><a name="l08733"></a><span class="lineno"> 8733</span>&#160;&lt;val&gt;555 12 6725&lt;/val&gt; </div><div class="line"><a name="l08734"></a><span class="lineno"> 8734</span>&#160;&lt;/pair&gt; </div><div class="line"><a name="l08735"></a><span class="lineno"> 8735</span>&#160;&lt;pair xsi:type=&quot;ns:Binding&quot;&gt; </div><div class="line"><a name="l08736"></a><span class="lineno"> 8736</span>&#160;&lt;key&gt;Pete&lt;/key&gt; </div><div class="line"><a name="l08737"></a><span class="lineno"> 8737</span>&#160;&lt;val&gt;555 99 4321&lt;/val&gt; </div><div class="line"><a name="l08738"></a><span class="lineno"> 8738</span>&#160;&lt;/pair&gt; </div><div class="line"><a name="l08739"></a><span class="lineno"> 8739</span>&#160;&lt;/ns:Map&gt;</div><div class="line"><a name="l08740"></a><span class="lineno"> 8740</span>&#160;```</div><div class="line"><a name="l08741"></a><span class="lineno"> 8741</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l08742"></a><span class="lineno"> 8742</span>&#160;</div><div class="line"><a name="l08743"></a><span class="lineno"> 8743</span>&#160;Deserialization is less efficient compared to a SOAP-encoded array, because the size of the</div><div class="line"><a name="l08744"></a><span class="lineno"> 8744</span>&#160;sequence is not part of the SOAP encoding. Internal buffering is used by the</div><div class="line"><a name="l08745"></a><span class="lineno"> 8745</span>&#160;deserializer to collect the elements. When the end of the list is reached, the</div><div class="line"><a name="l08746"></a><span class="lineno"> 8746</span>&#160;buffered elements are copied to a newly allocated space on the heap for the</div><div class="line"><a name="l08747"></a><span class="lineno"> 8747</span>&#160;dynamic array.</div><div class="line"><a name="l08748"></a><span class="lineno"> 8748</span>&#160;</div><div class="line"><a name="l08749"></a><span class="lineno"> 8749</span>&#160;Multiple arrays can be used in a struct/class to support the concept of</div><div class="line"><a name="l08750"></a><span class="lineno"> 8750</span>&#160;&quot;generics&quot;.  Each array results in a repetition of elements in the struct/class.</div><div class="line"><a name="l08751"></a><span class="lineno"> 8751</span>&#160;This is achieved with a `int __size` (or `$int`) field in</div><div class="line"><a name="l08752"></a><span class="lineno"> 8752</span>&#160;the struct/class where the next field (i.e. below the `__size` field) is a</div><div class="line"><a name="l08753"></a><span class="lineno"> 8753</span>&#160;pointer type.  The pointer</div><div class="line"><a name="l08754"></a><span class="lineno"> 8754</span>&#160;type is assumed to point to an array of values at run time.  The `__size`</div><div class="line"><a name="l08755"></a><span class="lineno"> 8755</span>&#160;field holds the number of values at run time.  Multiple arrays can be embedded</div><div class="line"><a name="l08756"></a><span class="lineno"> 8756</span>&#160;in a struct/class with `__size` fields that have a distinct names.  To</div><div class="line"><a name="l08757"></a><span class="lineno"> 8757</span>&#160;make the `__size` fields distinct, you can end them with a unique name</div><div class="line"><a name="l08758"></a><span class="lineno"> 8758</span>&#160;suffix such as `__sizeOfstrings`, for example.</div><div class="line"><a name="l08759"></a><span class="lineno"> 8759</span>&#160;</div><div class="line"><a name="l08760"></a><span class="lineno"> 8760</span>&#160;The general convention for embedding arrays is:</div><div class="line"><a name="l08761"></a><span class="lineno"> 8761</span>&#160;</div><div class="line"><a name="l08762"></a><span class="lineno"> 8762</span>&#160;```cpp</div><div class="line"><a name="l08763"></a><span class="lineno"> 8763</span>&#160;struct ns__SomeStruct </div><div class="line"><a name="l08764"></a><span class="lineno"> 8764</span>&#160;{ </div><div class="line"><a name="l08765"></a><span class="lineno"> 8765</span>&#160;   ... </div><div class="line"><a name="l08766"></a><span class="lineno"> 8766</span>&#160;   int __sizename1; // number of elements pointed to </div><div class="line"><a name="l08767"></a><span class="lineno"> 8767</span>&#160;   Type1 *field1; // by this field </div><div class="line"><a name="l08768"></a><span class="lineno"> 8768</span>&#160;   ... </div><div class="line"><a name="l08769"></a><span class="lineno"> 8769</span>&#160;   int __sizename2; // number of elements pointed to </div><div class="line"><a name="l08770"></a><span class="lineno"> 8770</span>&#160;   Type2 *field2; // by this field </div><div class="line"><a name="l08771"></a><span class="lineno"> 8771</span>&#160;   ... </div><div class="line"><a name="l08772"></a><span class="lineno"> 8772</span>&#160;};</div><div class="line"><a name="l08773"></a><span class="lineno"> 8773</span>&#160;```</div><div class="line"><a name="l08774"></a><span class="lineno"> 8774</span>&#160;</div><div class="line"><a name="l08775"></a><span class="lineno"> 8775</span>&#160;where `name1` and `name2` are identifiers used as a suffix to distinguish the `__size` field. These names can be arbitrary and are not visible in XML.</div><div class="line"><a name="l08776"></a><span class="lineno"> 8776</span>&#160;</div><div class="line"><a name="l08777"></a><span class="lineno"> 8777</span>&#160;In 2.7.16 and higher this is simplified with a &#39;`$`&#39; marker:</div><div class="line"><a name="l08778"></a><span class="lineno"> 8778</span>&#160;</div><div class="line"><a name="l08779"></a><span class="lineno"> 8779</span>&#160;```cpp</div><div class="line"><a name="l08780"></a><span class="lineno"> 8780</span>&#160;struct ns__SomeStruct </div><div class="line"><a name="l08781"></a><span class="lineno"> 8781</span>&#160;{ </div><div class="line"><a name="l08782"></a><span class="lineno"> 8782</span>&#160;   ... </div><div class="line"><a name="l08783"></a><span class="lineno"> 8783</span>&#160;   $int name1; // number of elements pointed to </div><div class="line"><a name="l08784"></a><span class="lineno"> 8784</span>&#160;   Type1 *field1; // by this field </div><div class="line"><a name="l08785"></a><span class="lineno"> 8785</span>&#160;   ... </div><div class="line"><a name="l08786"></a><span class="lineno"> 8786</span>&#160;   $int name2; // number of elements pointed to </div><div class="line"><a name="l08787"></a><span class="lineno"> 8787</span>&#160;   Type2 *field2; // by this field </div><div class="line"><a name="l08788"></a><span class="lineno"> 8788</span>&#160;   ... </div><div class="line"><a name="l08789"></a><span class="lineno"> 8789</span>&#160;};</div><div class="line"><a name="l08790"></a><span class="lineno"> 8790</span>&#160;```</div><div class="line"><a name="l08791"></a><span class="lineno"> 8791</span>&#160;</div><div class="line"><a name="l08792"></a><span class="lineno"> 8792</span>&#160;For example, the following struct has two embedded arrays:</div><div class="line"><a name="l08793"></a><span class="lineno"> 8793</span>&#160;</div><div class="line"><a name="l08794"></a><span class="lineno"> 8794</span>&#160;```cpp</div><div class="line"><a name="l08795"></a><span class="lineno"> 8795</span>&#160;struct ns__Contact </div><div class="line"><a name="l08796"></a><span class="lineno"> 8796</span>&#160;{ </div><div class="line"><a name="l08797"></a><span class="lineno"> 8797</span>&#160;   char *firstName; </div><div class="line"><a name="l08798"></a><span class="lineno"> 8798</span>&#160;   char *lastName; </div><div class="line"><a name="l08799"></a><span class="lineno"> 8799</span>&#160;   $int nPhones; // number of Phones</div><div class="line"><a name="l08800"></a><span class="lineno"> 8800</span>&#160;   ULONG64 *phoneNumber; // array of phone numbers </div><div class="line"><a name="l08801"></a><span class="lineno"> 8801</span>&#160;   $int nEmails; // number of emails </div><div class="line"><a name="l08802"></a><span class="lineno"> 8802</span>&#160;   char **emailAddress; // array of email addresses </div><div class="line"><a name="l08803"></a><span class="lineno"> 8803</span>&#160;   char *socSecNumber; </div><div class="line"><a name="l08804"></a><span class="lineno"> 8804</span>&#160;};</div><div class="line"><a name="l08805"></a><span class="lineno"> 8805</span>&#160;```</div><div class="line"><a name="l08806"></a><span class="lineno"> 8806</span>&#160;</div><div class="line"><a name="l08807"></a><span class="lineno"> 8807</span>&#160;The XML serialization of an example `ns__Contact` is:</div><div class="line"><a name="l08808"></a><span class="lineno"> 8808</span>&#160;</div><div class="line"><a name="l08809"></a><span class="lineno"> 8809</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l08810"></a><span class="lineno"> 8810</span>&#160;```xml</div><div class="line"><a name="l08811"></a><span class="lineno"> 8811</span>&#160;&lt;mycontact xsi:type=&quot;ns:Contact&quot;&gt; </div><div class="line"><a name="l08812"></a><span class="lineno"> 8812</span>&#160;   &lt;firstName&gt;Joe&lt;/firstName&gt; </div><div class="line"><a name="l08813"></a><span class="lineno"> 8813</span>&#160;   &lt;lastName&gt;Smith&lt;/lastName&gt; </div><div class="line"><a name="l08814"></a><span class="lineno"> 8814</span>&#160;   &lt;phoneNumber&gt;5551112222&lt;/phoneNumber&gt; </div><div class="line"><a name="l08815"></a><span class="lineno"> 8815</span>&#160;   &lt;phoneNumber&gt;5551234567&lt;/phoneNumber&gt; </div><div class="line"><a name="l08816"></a><span class="lineno"> 8816</span>&#160;   &lt;phoneNumber&gt;5552348901&lt;/phoneNumber&gt; </div><div class="line"><a name="l08817"></a><span class="lineno"> 8817</span>&#160;   &lt;emailAddress&gt;Joe.Smith@mail.com&lt;/emailAddress&gt; </div><div class="line"><a name="l08818"></a><span class="lineno"> 8818</span>&#160;   &lt;emailAddress&gt;Joe@Smith.com&lt;/emailAddress&gt; </div><div class="line"><a name="l08819"></a><span class="lineno"> 8819</span>&#160;   &lt;socSecNumber&gt;999999999&lt;/socSecNumber&gt; </div><div class="line"><a name="l08820"></a><span class="lineno"> 8820</span>&#160;&lt;/mycontact&gt;</div><div class="line"><a name="l08821"></a><span class="lineno"> 8821</span>&#160;```</div><div class="line"><a name="l08822"></a><span class="lineno"> 8822</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l08823"></a><span class="lineno"> 8823</span>&#160;</div><div class="line"><a name="l08824"></a><span class="lineno"> 8824</span>&#160;### STL Containers        {#templates}</div><div class="line"><a name="l08825"></a><span class="lineno"> 8825</span>&#160;</div><div class="line"><a name="l08826"></a><span class="lineno"> 8826</span>&#160;gSOAP supports the STL containers `std::deque`, `std::list`,</div><div class="line"><a name="l08827"></a><span class="lineno"> 8827</span>&#160;`std::set`, and `std::vector`.</div><div class="line"><a name="l08828"></a><span class="lineno"> 8828</span>&#160;</div><div class="line"><a name="l08829"></a><span class="lineno"> 8829</span>&#160;STL containers can only be used within classes to declare members that contain</div><div class="line"><a name="l08830"></a><span class="lineno"> 8830</span>&#160;multiple values.  This is somewhat similar to the embedding of arrays in</div><div class="line"><a name="l08831"></a><span class="lineno"> 8831</span>&#160;structs in C as explained in Section \ref list , but the STL container</div><div class="line"><a name="l08832"></a><span class="lineno"> 8832</span>&#160;approach is more flexible.</div><div class="line"><a name="l08833"></a><span class="lineno"> 8833</span>&#160;</div><div class="line"><a name="l08834"></a><span class="lineno"> 8834</span>&#160;You need to import `stldeque.h`, `stllist.h`, `stlset.h`, or</div><div class="line"><a name="l08835"></a><span class="lineno"> 8835</span>&#160;`stlvector.h` to enable `std::deque`, `std::list`, `std::set`,</div><div class="line"><a name="l08836"></a><span class="lineno"> 8836</span>&#160;and `std::vector` (de)serialization.</div><div class="line"><a name="l08837"></a><span class="lineno"> 8837</span>&#160;Here is an example:</div><div class="line"><a name="l08838"></a><span class="lineno"> 8838</span>&#160;</div><div class="line"><a name="l08839"></a><span class="lineno"> 8839</span>&#160;```cpp</div><div class="line"><a name="l08840"></a><span class="lineno"> 8840</span>&#160;#import &quot;stlvector.h&quot; </div><div class="line"><a name="l08841"></a><span class="lineno"> 8841</span>&#160;class ns__myClass </div><div class="line"><a name="l08842"></a><span class="lineno"> 8842</span>&#160;{ public: </div><div class="line"><a name="l08843"></a><span class="lineno"> 8843</span>&#160;   std::vector&lt;int&gt; *number; </div><div class="line"><a name="l08844"></a><span class="lineno"> 8844</span>&#160;   std::vector&lt;xsd__string&gt; *name; </div><div class="line"><a name="l08845"></a><span class="lineno"> 8845</span>&#160;   ... </div><div class="line"><a name="l08846"></a><span class="lineno"> 8846</span>&#160;};</div><div class="line"><a name="l08847"></a><span class="lineno"> 8847</span>&#160;```</div><div class="line"><a name="l08848"></a><span class="lineno"> 8848</span>&#160;</div><div class="line"><a name="l08849"></a><span class="lineno"> 8849</span>&#160;The use of pointer members is not required but advised. The reason is that</div><div class="line"><a name="l08850"></a><span class="lineno"> 8850</span>&#160;interoperability with other SOAP toolkits may lead to copying of `ns__myClass` instances at run time when (de)serializing multi-referenced data.</div><div class="line"><a name="l08851"></a><span class="lineno"> 8851</span>&#160;When a copy is made, certain parts of the containers will be shared between the</div><div class="line"><a name="l08852"></a><span class="lineno"> 8852</span>&#160;copies which could lead to disaster when the classes with their containers are</div><div class="line"><a name="l08853"></a><span class="lineno"> 8853</span>&#160;deallocated.  Another way to avoid this is to declare class `ns__myClass`</div><div class="line"><a name="l08854"></a><span class="lineno"> 8854</span>&#160;within other data types via a pointer.  (Interoperability between gSOAP clients</div><div class="line"><a name="l08855"></a><span class="lineno"> 8855</span>&#160;and services does not lead to copying.)</div><div class="line"><a name="l08856"></a><span class="lineno"> 8856</span>&#160;</div><div class="line"><a name="l08857"></a><span class="lineno"> 8857</span>&#160;The XML Schema that corresponds to the `ns__myClass` type is</div><div class="line"><a name="l08858"></a><span class="lineno"> 8858</span>&#160;</div><div class="line"><a name="l08859"></a><span class="lineno"> 8859</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l08860"></a><span class="lineno"> 8860</span>&#160;```xml</div><div class="line"><a name="l08861"></a><span class="lineno"> 8861</span>&#160;&lt;complexType name=&quot;myClass&quot;&gt; </div><div class="line"><a name="l08862"></a><span class="lineno"> 8862</span>&#160;   &lt;sequence&gt; </div><div class="line"><a name="l08863"></a><span class="lineno"> 8863</span>&#160;     &lt;element name=&quot;number&quot; type=&quot;xsd:int&quot; minOccurs=&quot;1&quot; maxOccurs=&quot;unbounded&quot;/&gt; </div><div class="line"><a name="l08864"></a><span class="lineno"> 8864</span>&#160;     &lt;element name=&quot;name&quot; type=&quot;xsd:string&quot; minOccurs=&quot;1&quot; maxOccurs=&quot;unbounded&quot;/&gt; </div><div class="line"><a name="l08865"></a><span class="lineno"> 8865</span>&#160;     ... </div><div class="line"><a name="l08866"></a><span class="lineno"> 8866</span>&#160;   &lt;/sequence&gt; </div><div class="line"><a name="l08867"></a><span class="lineno"> 8867</span>&#160;&lt;/complexType&gt;</div><div class="line"><a name="l08868"></a><span class="lineno"> 8868</span>&#160;```</div><div class="line"><a name="l08869"></a><span class="lineno"> 8869</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l08870"></a><span class="lineno"> 8870</span>&#160;</div><div class="line"><a name="l08871"></a><span class="lineno"> 8871</span>&#160;You can specify the minOccurs and maxOccurs values as explained in Section \ref directives .</div><div class="line"><a name="l08872"></a><span class="lineno"> 8872</span>&#160;</div><div class="line"><a name="l08873"></a><span class="lineno"> 8873</span>&#160;You can also implement your own</div><div class="line"><a name="l08874"></a><span class="lineno"> 8874</span>&#160;containers similar to STL containers. The containers must be class templates and should define a forward iterator type, and provide the following methods:</div><div class="line"><a name="l08875"></a><span class="lineno"> 8875</span>&#160;</div><div class="line"><a name="l08876"></a><span class="lineno"> 8876</span>&#160;</div><div class="line"><a name="l08877"></a><span class="lineno"> 8877</span>&#160;*  `void clear()` empty the container;</div><div class="line"><a name="l08878"></a><span class="lineno"> 8878</span>&#160;</div><div class="line"><a name="l08879"></a><span class="lineno"> 8879</span>&#160;*  `iterator begin()` return iterator to beginning;</div><div class="line"><a name="l08880"></a><span class="lineno"> 8880</span>&#160;</div><div class="line"><a name="l08881"></a><span class="lineno"> 8881</span>&#160;*  `const_iterator begin() const` return const iterator to beginning;</div><div class="line"><a name="l08882"></a><span class="lineno"> 8882</span>&#160;</div><div class="line"><a name="l08883"></a><span class="lineno"> 8883</span>&#160;*  `iterator end()` return iterator to end;</div><div class="line"><a name="l08884"></a><span class="lineno"> 8884</span>&#160;</div><div class="line"><a name="l08885"></a><span class="lineno"> 8885</span>&#160;*  `const_iterator end() const` return const iterator to end;</div><div class="line"><a name="l08886"></a><span class="lineno"> 8886</span>&#160;</div><div class="line"><a name="l08887"></a><span class="lineno"> 8887</span>&#160;*  `size_t size()` return size;</div><div class="line"><a name="l08888"></a><span class="lineno"> 8888</span>&#160;</div><div class="line"><a name="l08889"></a><span class="lineno"> 8889</span>&#160;*  `iterator insert(iterator pos, const_reference val)` insert element.</div><div class="line"><a name="l08890"></a><span class="lineno"> 8890</span>&#160;</div><div class="line"><a name="l08891"></a><span class="lineno"> 8891</span>&#160;The `iterator` should be a forward iterator with a dereference operator to</div><div class="line"><a name="l08892"></a><span class="lineno"> 8892</span>&#160;access the container&#39;s elements, it must be comparable (equal/unequal), and be pre-incrementable (`++it`).  The const iterator is used by gSOAP to</div><div class="line"><a name="l08893"></a><span class="lineno"> 8893</span>&#160;send a sequence of XML element values.  The `insert` method is used to populate a container with `Container::iterator i = container.insert(container.end(), val)`.</div><div class="line"><a name="l08894"></a><span class="lineno"> 8894</span>&#160;</div><div class="line"><a name="l08895"></a><span class="lineno"> 8895</span>&#160;Here is in example user-defined container template class:</div><div class="line"><a name="l08896"></a><span class="lineno"> 8896</span>&#160;</div><div class="line"><a name="l08897"></a><span class="lineno"> 8897</span>&#160;```cpp</div><div class="line"><a name="l08898"></a><span class="lineno"> 8898</span>&#160;// simple_vector.h </div><div class="line"><a name="l08899"></a><span class="lineno"> 8899</span>&#160;template &lt;class T&gt; </div><div class="line"><a name="l08900"></a><span class="lineno"> 8900</span>&#160;class simple_vector </div><div class="line"><a name="l08901"></a><span class="lineno"> 8901</span>&#160;{ </div><div class="line"><a name="l08902"></a><span class="lineno"> 8902</span>&#160;public: </div><div class="line"><a name="l08903"></a><span class="lineno"> 8903</span>&#160;   typedef T                       value_type; </div><div class="line"><a name="l08904"></a><span class="lineno"> 8904</span>&#160;   typedef value_type            * pointer; </div><div class="line"><a name="l08905"></a><span class="lineno"> 8905</span>&#160;   typedef const value_type      * const_pointer; </div><div class="line"><a name="l08906"></a><span class="lineno"> 8906</span>&#160;   typedef value_type            &amp; reference; </div><div class="line"><a name="l08907"></a><span class="lineno"> 8907</span>&#160;   typedef const value_type      &amp; const_reference; </div><div class="line"><a name="l08908"></a><span class="lineno"> 8908</span>&#160;   typedef pointer                 iterator; </div><div class="line"><a name="l08909"></a><span class="lineno"> 8909</span>&#160;   typedef const_pointer           const_iterator; </div><div class="line"><a name="l08910"></a><span class="lineno"> 8910</span>&#160;protected: </div><div class="line"><a name="l08911"></a><span class="lineno"> 8911</span>&#160;   iterator                        head; </div><div class="line"><a name="l08912"></a><span class="lineno"> 8912</span>&#160;   iterator                        tail; </div><div class="line"><a name="l08913"></a><span class="lineno"> 8913</span>&#160;   size_t                          capacity; </div><div class="line"><a name="l08914"></a><span class="lineno"> 8914</span>&#160;public: </div><div class="line"><a name="l08915"></a><span class="lineno"> 8915</span>&#160;                                   simple_vector()       { head = tail = NULL; } </div><div class="line"><a name="l08916"></a><span class="lineno"> 8916</span>&#160;                                   simple_vector(const simple_vector&amp; v) </div><div class="line"><a name="l08917"></a><span class="lineno"> 8917</span>&#160;                                                         { operator=(v); } </div><div class="line"><a name="l08918"></a><span class="lineno"> 8918</span>&#160;                                   ~simple_vector()      { if (head) delete[] head; } </div><div class="line"><a name="l08919"></a><span class="lineno"> 8919</span>&#160;   void                            clear()               { tail = head; } </div><div class="line"><a name="l08920"></a><span class="lineno"> 8920</span>&#160;/* the member functions below are required for (de)serialization of templates */ </div><div class="line"><a name="l08921"></a><span class="lineno"> 8921</span>&#160;   iterator                        begin()               { return head; } </div><div class="line"><a name="l08922"></a><span class="lineno"> 8922</span>&#160;   const_iterator                  begin() const { return head; } </div><div class="line"><a name="l08923"></a><span class="lineno"> 8923</span>&#160;   iterator                        end()                 { return tail; } </div><div class="line"><a name="l08924"></a><span class="lineno"> 8924</span>&#160;   const_iterator                  end() const { return tail; } </div><div class="line"><a name="l08925"></a><span class="lineno"> 8925</span>&#160;   size_t                          size() const { return tail - head; } </div><div class="line"><a name="l08926"></a><span class="lineno"> 8926</span>&#160;   iterator                        insert(iterator pos, const_reference val) </div><div class="line"><a name="l08927"></a><span class="lineno"> 8927</span>&#160;   { </div><div class="line"><a name="l08928"></a><span class="lineno"> 8928</span>&#160;     if (!head) </div><div class="line"><a name="l08929"></a><span class="lineno"> 8929</span>&#160;        head = tail = new value_type[capacity = 1]; </div><div class="line"><a name="l08930"></a><span class="lineno"> 8930</span>&#160;     else if (tail &gt;= head + capacity) </div><div class="line"><a name="l08931"></a><span class="lineno"> 8931</span>&#160;     { </div><div class="line"><a name="l08932"></a><span class="lineno"> 8932</span>&#160;       iterator i = head; </div><div class="line"><a name="l08933"></a><span class="lineno"> 8933</span>&#160;       iterator j = new value_type[capacity *= 2]; </div><div class="line"><a name="l08934"></a><span class="lineno"> 8934</span>&#160;       iterator k = j; </div><div class="line"><a name="l08935"></a><span class="lineno"> 8935</span>&#160;       while (i &lt; tail) </div><div class="line"><a name="l08936"></a><span class="lineno"> 8936</span>&#160;         *k++ = *i++; </div><div class="line"><a name="l08937"></a><span class="lineno"> 8937</span>&#160;       if (pos) </div><div class="line"><a name="l08938"></a><span class="lineno"> 8938</span>&#160;         pos = j + (pos - head); </div><div class="line"><a name="l08939"></a><span class="lineno"> 8939</span>&#160;       tail = j + (tail - head); </div><div class="line"><a name="l08940"></a><span class="lineno"> 8940</span>&#160;       delete[] head; </div><div class="line"><a name="l08941"></a><span class="lineno"> 8941</span>&#160;       head = j; </div><div class="line"><a name="l08942"></a><span class="lineno"> 8942</span>&#160;     } </div><div class="line"><a name="l08943"></a><span class="lineno"> 8943</span>&#160;     if (pos &amp;&amp; pos &gt;= head &amp;&amp; pos &lt; tail) </div><div class="line"><a name="l08944"></a><span class="lineno"> 8944</span>&#160;     { </div><div class="line"><a name="l08945"></a><span class="lineno"> 8945</span>&#160;       iterator i = tail; </div><div class="line"><a name="l08946"></a><span class="lineno"> 8946</span>&#160;       iterator j = i - 1; </div><div class="line"><a name="l08947"></a><span class="lineno"> 8947</span>&#160;       while (j != pos) </div><div class="line"><a name="l08948"></a><span class="lineno"> 8948</span>&#160;          *i-- = *j--; </div><div class="line"><a name="l08949"></a><span class="lineno"> 8949</span>&#160;       *pos = val; </div><div class="line"><a name="l08950"></a><span class="lineno"> 8950</span>&#160;     } </div><div class="line"><a name="l08951"></a><span class="lineno"> 8951</span>&#160;     else </div><div class="line"><a name="l08952"></a><span class="lineno"> 8952</span>&#160;     { </div><div class="line"><a name="l08953"></a><span class="lineno"> 8953</span>&#160;       pos = tail; </div><div class="line"><a name="l08954"></a><span class="lineno"> 8954</span>&#160;       *tail++ = val; </div><div class="line"><a name="l08955"></a><span class="lineno"> 8955</span>&#160;     } </div><div class="line"><a name="l08956"></a><span class="lineno"> 8956</span>&#160;     return pos; </div><div class="line"><a name="l08957"></a><span class="lineno"> 8957</span>&#160;   } </div><div class="line"><a name="l08958"></a><span class="lineno"> 8958</span>&#160;   simple_vector&amp; \operator=(const simple_vector&amp; v) </div><div class="line"><a name="l08959"></a><span class="lineno"> 8959</span>&#160;   { </div><div class="line"><a name="l08960"></a><span class="lineno"> 8960</span>&#160;     head = tail = NULL; </div><div class="line"><a name="l08961"></a><span class="lineno"> 8961</span>&#160;     capacity = v.capacity; </div><div class="line"><a name="l08962"></a><span class="lineno"> 8962</span>&#160;     if (v.head) </div><div class="line"><a name="l08963"></a><span class="lineno"> 8963</span>&#160;     { </div><div class="line"><a name="l08964"></a><span class="lineno"> 8964</span>&#160;       head = tail = new value_type[capacity]; </div><div class="line"><a name="l08965"></a><span class="lineno"> 8965</span>&#160;       iterator i = v.head; </div><div class="line"><a name="l08966"></a><span class="lineno"> 8966</span>&#160;       while (i != v.tail) </div><div class="line"><a name="l08967"></a><span class="lineno"> 8967</span>&#160;         *tail++ = *i++; </div><div class="line"><a name="l08968"></a><span class="lineno"> 8968</span>&#160;     } </div><div class="line"><a name="l08969"></a><span class="lineno"> 8969</span>&#160;     return *\this; </div><div class="line"><a name="l08970"></a><span class="lineno"> 8970</span>&#160;   } </div><div class="line"><a name="l08971"></a><span class="lineno"> 8971</span>&#160;};</div><div class="line"><a name="l08972"></a><span class="lineno"> 8972</span>&#160;```</div><div class="line"><a name="l08973"></a><span class="lineno"> 8973</span>&#160;</div><div class="line"><a name="l08974"></a><span class="lineno"> 8974</span>&#160;To enable the container, we add the following two lines to our gSOAP header file:</div><div class="line"><a name="l08975"></a><span class="lineno"> 8975</span>&#160;</div><div class="line"><a name="l08976"></a><span class="lineno"> 8976</span>&#160;```cpp</div><div class="line"><a name="l08977"></a><span class="lineno"> 8977</span>&#160;#include &quot;simpleVector.h&quot; </div><div class="line"><a name="l08978"></a><span class="lineno"> 8978</span>&#160;template &lt;class T&gt; class simpleVector;</div><div class="line"><a name="l08979"></a><span class="lineno"> 8979</span>&#160;```</div><div class="line"><a name="l08980"></a><span class="lineno"> 8980</span>&#160;</div><div class="line"><a name="l08981"></a><span class="lineno"> 8981</span>&#160;The container class</div><div class="line"><a name="l08982"></a><span class="lineno"> 8982</span>&#160;should not be defined in the gSOAP header file. It must be defined in</div><div class="line"><a name="l08983"></a><span class="lineno"> 8983</span>&#160;a separate header file (e.g. &quot;simpleVector.h&quot;). The `template &lt;class T&gt; class simpleVector` declaration ensures that gSOAP will recognize `simpleVector` as a container class.</div><div class="line"><a name="l08984"></a><span class="lineno"> 8984</span>&#160;</div><div class="line"><a name="l08985"></a><span class="lineno"> 8985</span>&#160;@warning when parsing XML content the container elements may not be stored in the same order given in</div><div class="line"><a name="l08986"></a><span class="lineno"> 8986</span>&#160;the XML content.  When gSOAP parses XML it uses the `insert` container methods to</div><div class="line"><a name="l08987"></a><span class="lineno"> 8987</span>&#160;store elements one by one.  However, element content that is &quot;forwarded&quot; with</div><div class="line"><a name="l08988"></a><span class="lineno"> 8988</span>&#160;*`href`* attributes will be appended to the container.  Forwarding can take</div><div class="line"><a name="l08989"></a><span class="lineno"> 8989</span>&#160;place with multi-referenced data that is referred to from the main part of the</div><div class="line"><a name="l08990"></a><span class="lineno"> 8990</span>&#160;SOAP 1.1 XML message to the independent elements that carry *`id`*s.</div><div class="line"><a name="l08991"></a><span class="lineno"> 8991</span>&#160;Therefore, your application should not rely on the preservation of the order of</div><div class="line"><a name="l08992"></a><span class="lineno"> 8992</span>&#160;elements in a container.</div><div class="line"><a name="l08993"></a><span class="lineno"> 8993</span>&#160;</div><div class="line"><a name="l08994"></a><span class="lineno"> 8994</span>&#160;### Polymorphic Dynamic Arrays and Lists</div><div class="line"><a name="l08995"></a><span class="lineno"> 8995</span>&#160;</div><div class="line"><a name="l08996"></a><span class="lineno"> 8996</span>&#160;Polymorphic arrays (arrays of polymorphic element types) can be encoded when</div><div class="line"><a name="l08997"></a><span class="lineno"> 8997</span>&#160;declared as an array of pointers to class instances. For example:</div><div class="line"><a name="l08998"></a><span class="lineno"> 8998</span>&#160;</div><div class="line"><a name="l08999"></a><span class="lineno"> 8999</span>&#160;```cpp</div><div class="line"><a name="l09000"></a><span class="lineno"> 9000</span>&#160;class ns__Object </div><div class="line"><a name="l09001"></a><span class="lineno"> 9001</span>&#160;{</div><div class="line"><a name="l09002"></a><span class="lineno"> 9002</span>&#160;  public: </div><div class="line"><a name="l09003"></a><span class="lineno"> 9003</span>&#160;  ... </div><div class="line"><a name="l09004"></a><span class="lineno"> 9004</span>&#160;}; </div><div class="line"><a name="l09005"></a><span class="lineno"> 9005</span>&#160;class ns__Data: public ns__Object </div><div class="line"><a name="l09006"></a><span class="lineno"> 9006</span>&#160;{</div><div class="line"><a name="l09007"></a><span class="lineno"> 9007</span>&#160;  public: </div><div class="line"><a name="l09008"></a><span class="lineno"> 9008</span>&#160;  ... </div><div class="line"><a name="l09009"></a><span class="lineno"> 9009</span>&#160;}; </div><div class="line"><a name="l09010"></a><span class="lineno"> 9010</span>&#160;class ArrayOfObject </div><div class="line"><a name="l09011"></a><span class="lineno"> 9011</span>&#160;{ </div><div class="line"><a name="l09012"></a><span class="lineno"> 9012</span>&#160;   public: </div><div class="line"><a name="l09013"></a><span class="lineno"> 9013</span>&#160;   ns__Object **__ptr; // pointer to array of pointers to Objects </div><div class="line"><a name="l09014"></a><span class="lineno"> 9014</span>&#160;   int __size; // number of Objects pointed to </div><div class="line"><a name="l09015"></a><span class="lineno"> 9015</span>&#160;   int __offset; // optional SOAP 1.1 array offset </div><div class="line"><a name="l09016"></a><span class="lineno"> 9016</span>&#160;}; </div><div class="line"><a name="l09017"></a><span class="lineno"> 9017</span>&#160;class ns__Objects </div><div class="line"><a name="l09018"></a><span class="lineno"> 9018</span>&#160;{ </div><div class="line"><a name="l09019"></a><span class="lineno"> 9019</span>&#160;  public: </div><div class="line"><a name="l09020"></a><span class="lineno"> 9020</span>&#160;   std::vector&lt;ns__Object*&gt; objects; // vector of pointers to objects </div><div class="line"><a name="l09021"></a><span class="lineno"> 9021</span>&#160;};</div><div class="line"><a name="l09022"></a><span class="lineno"> 9022</span>&#160;```</div><div class="line"><a name="l09023"></a><span class="lineno"> 9023</span>&#160;</div><div class="line"><a name="l09024"></a><span class="lineno"> 9024</span>&#160;The pointers in the array can point to the `ns__Object` base class or</div><div class="line"><a name="l09025"></a><span class="lineno"> 9025</span>&#160;`ns__Data` derived class instances which will be serialized and</div><div class="line"><a name="l09026"></a><span class="lineno"> 9026</span>&#160;deserialized accordingly in SOAP.  That is, the array elements are polymorphic.</div><div class="line"><a name="l09027"></a><span class="lineno"> 9027</span>&#160;</div><div class="line"><a name="l09028"></a><span class="lineno"> 9028</span>&#160;Since we can&#39;t use dynamic binding to support polymorphism in C, another</div><div class="line"><a name="l09029"></a><span class="lineno"> 9029</span>&#160;mechanism is available based on the serialization of void pointers, that is, dynamic serialization of data referenced by void pointers, see Section \ref void .</div><div class="line"><a name="l09030"></a><span class="lineno"> 9030</span>&#160;</div><div class="line"><a name="l09031"></a><span class="lineno"> 9031</span>&#160;```cpp</div><div class="line"><a name="l09032"></a><span class="lineno"> 9032</span>&#160;struct __wrapper </div><div class="line"><a name="l09033"></a><span class="lineno"> 9033</span>&#160;{</div><div class="line"><a name="l09034"></a><span class="lineno"> 9034</span>&#160;   int __type; // type T represented by SOAP_TYPE_T </div><div class="line"><a name="l09035"></a><span class="lineno"> 9035</span>&#160;   void *__item; // pointer to data of type T </div><div class="line"><a name="l09036"></a><span class="lineno"> 9036</span>&#160;}; </div><div class="line"><a name="l09037"></a><span class="lineno"> 9037</span>&#160;struct ArrayOfObject </div><div class="line"><a name="l09038"></a><span class="lineno"> 9038</span>&#160;{ </div><div class="line"><a name="l09039"></a><span class="lineno"> 9039</span>&#160;   struct __wrapper __ptr; // pointer to array of pointers to Objects </div><div class="line"><a name="l09040"></a><span class="lineno"> 9040</span>&#160;   int __size; // number of Objects pointed to </div><div class="line"><a name="l09041"></a><span class="lineno"> 9041</span>&#160;   int __offset; // optional SOAP 1.1 array offset </div><div class="line"><a name="l09042"></a><span class="lineno"> 9042</span>&#160;}; </div><div class="line"><a name="l09043"></a><span class="lineno"> 9043</span>&#160;struct ns__Objects </div><div class="line"><a name="l09044"></a><span class="lineno"> 9044</span>&#160;{ </div><div class="line"><a name="l09045"></a><span class="lineno"> 9045</span>&#160;   int __size; </div><div class="line"><a name="l09046"></a><span class="lineno"> 9046</span>&#160;   struct __wrapper *objects; // array of pointers to wrapped types </div><div class="line"><a name="l09047"></a><span class="lineno"> 9047</span>&#160;};</div><div class="line"><a name="l09048"></a><span class="lineno"> 9048</span>&#160;```</div><div class="line"><a name="l09049"></a><span class="lineno"> 9049</span>&#160;</div><div class="line"><a name="l09050"></a><span class="lineno"> 9050</span>&#160;### How to Change the Tag Names of the Elements of a SOAP Array or List</div><div class="line"><a name="l09051"></a><span class="lineno"> 9051</span>&#160;</div><div class="line"><a name="l09052"></a><span class="lineno"> 9052</span>&#160;The `__ptr` field in a `struct` or `class` declaration of a dynamic array may have an optional suffix part that</div><div class="line"><a name="l09053"></a><span class="lineno"> 9053</span>&#160;describes the name of the tags of the SOAP array XML elements.</div><div class="line"><a name="l09054"></a><span class="lineno"> 9054</span>&#160;The suffix is part of the field name:</div><div class="line"><a name="l09055"></a><span class="lineno"> 9055</span>&#160;</div><div class="line"><a name="l09056"></a><span class="lineno"> 9056</span>&#160;```cpp</div><div class="line"><a name="l09057"></a><span class="lineno"> 9057</span>&#160;Type *__ptrarray_elt_name</div><div class="line"><a name="l09058"></a><span class="lineno"> 9058</span>&#160;```</div><div class="line"><a name="l09059"></a><span class="lineno"> 9059</span>&#160;</div><div class="line"><a name="l09060"></a><span class="lineno"> 9060</span>&#160;The suffix describes the tag name to be used for all array elements. The usual identifier to XML translations apply, see</div><div class="line"><a name="l09061"></a><span class="lineno"> 9061</span>&#160;Section \ref idtrans .</div><div class="line"><a name="l09062"></a><span class="lineno"> 9062</span>&#160;The default XML element tag name for array elements is *`item`* (which corresponds to the use of field name `__ptritem`).</div><div class="line"><a name="l09063"></a><span class="lineno"> 9063</span>&#160;</div><div class="line"><a name="l09064"></a><span class="lineno"> 9064</span>&#160;Consider for example:</div><div class="line"><a name="l09065"></a><span class="lineno"> 9065</span>&#160;</div><div class="line"><a name="l09066"></a><span class="lineno"> 9066</span>&#160;```cpp</div><div class="line"><a name="l09067"></a><span class="lineno"> 9067</span>&#160;struct ArrayOfstring </div><div class="line"><a name="l09068"></a><span class="lineno"> 9068</span>&#160;{ </div><div class="line"><a name="l09069"></a><span class="lineno"> 9069</span>&#160;   xsd__string *__ptrstring;</div><div class="line"><a name="l09070"></a><span class="lineno"> 9070</span>&#160;   int __size;</div><div class="line"><a name="l09071"></a><span class="lineno"> 9071</span>&#160;};</div><div class="line"><a name="l09072"></a><span class="lineno"> 9072</span>&#160;```</div><div class="line"><a name="l09073"></a><span class="lineno"> 9073</span>&#160;</div><div class="line"><a name="l09074"></a><span class="lineno"> 9074</span>&#160;The array is serialized as:</div><div class="line"><a name="l09075"></a><span class="lineno"> 9075</span>&#160;</div><div class="line"><a name="l09076"></a><span class="lineno"> 9076</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l09077"></a><span class="lineno"> 9077</span>&#160;```xml</div><div class="line"><a name="l09078"></a><span class="lineno"> 9078</span>&#160;&lt;array xsi:type=&quot;SOAP-ENC:Array&quot; SOAP-ENC:arrayType=&quot;xsd:string[2]&quot;&gt; </div><div class="line"><a name="l09079"></a><span class="lineno"> 9079</span>&#160;&lt;string xsi:type=&quot;xsd:string&quot;&gt;Hello&lt;/string&gt; </div><div class="line"><a name="l09080"></a><span class="lineno"> 9080</span>&#160;&lt;string xsi:type=&quot;xsd:string&quot;&gt;World&lt;/string&gt; </div><div class="line"><a name="l09081"></a><span class="lineno"> 9081</span>&#160;&lt;/array&gt;</div><div class="line"><a name="l09082"></a><span class="lineno"> 9082</span>&#160;```</div><div class="line"><a name="l09083"></a><span class="lineno"> 9083</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l09084"></a><span class="lineno"> 9084</span>&#160;</div><div class="line"><a name="l09085"></a><span class="lineno"> 9085</span>&#160;SOAP 1.1 and 1.2 do not require the use of a specific tag name for array elements.  gSOAP will deserialize a SOAP array while</div><div class="line"><a name="l09086"></a><span class="lineno"> 9086</span>&#160;ignoring the tag names. Certain XML Schemas used in doc/literal encoding may require the declaration of array element tag names.</div><div class="line"><a name="l09087"></a><span class="lineno"> 9087</span>&#160;</div><div class="line"><a name="l09088"></a><span class="lineno"> 9088</span>&#160;## Base64Binary XML Schema Type Encoding        {#base64binary}</div><div class="line"><a name="l09089"></a><span class="lineno"> 9089</span>&#160;</div><div class="line"><a name="l09090"></a><span class="lineno"> 9090</span>&#160;The *`base64Binary`* XML Schema type is a special form of dynamic array declared with a pointer (`__ptr`) to an</div><div class="line"><a name="l09091"></a><span class="lineno"> 9091</span>&#160;`unsigned char` array.</div><div class="line"><a name="l09092"></a><span class="lineno"> 9092</span>&#160;</div><div class="line"><a name="l09093"></a><span class="lineno"> 9093</span>&#160;For example using a `struct`:</div><div class="line"><a name="l09094"></a><span class="lineno"> 9094</span>&#160;</div><div class="line"><a name="l09095"></a><span class="lineno"> 9095</span>&#160;```cpp</div><div class="line"><a name="l09096"></a><span class="lineno"> 9096</span>&#160;struct xsd__base64Binary </div><div class="line"><a name="l09097"></a><span class="lineno"> 9097</span>&#160;{ </div><div class="line"><a name="l09098"></a><span class="lineno"> 9098</span>&#160;   unsigned char *__ptr; </div><div class="line"><a name="l09099"></a><span class="lineno"> 9099</span>&#160;   int __size; </div><div class="line"><a name="l09100"></a><span class="lineno"> 9100</span>&#160;};</div><div class="line"><a name="l09101"></a><span class="lineno"> 9101</span>&#160;```</div><div class="line"><a name="l09102"></a><span class="lineno"> 9102</span>&#160;</div><div class="line"><a name="l09103"></a><span class="lineno"> 9103</span>&#160;Or with a `class`:</div><div class="line"><a name="l09104"></a><span class="lineno"> 9104</span>&#160;</div><div class="line"><a name="l09105"></a><span class="lineno"> 9105</span>&#160;```cpp</div><div class="line"><a name="l09106"></a><span class="lineno"> 9106</span>&#160;class xsd__base64Binary </div><div class="line"><a name="l09107"></a><span class="lineno"> 9107</span>&#160;{ </div><div class="line"><a name="l09108"></a><span class="lineno"> 9108</span>&#160;   public: </div><div class="line"><a name="l09109"></a><span class="lineno"> 9109</span>&#160;   unsigned char *__ptr; </div><div class="line"><a name="l09110"></a><span class="lineno"> 9110</span>&#160;   int __size; </div><div class="line"><a name="l09111"></a><span class="lineno"> 9111</span>&#160;};</div><div class="line"><a name="l09112"></a><span class="lineno"> 9112</span>&#160;```</div><div class="line"><a name="l09113"></a><span class="lineno"> 9113</span>&#160;</div><div class="line"><a name="l09114"></a><span class="lineno"> 9114</span>&#160;When compiled by the gSOAP `soapcpp2` tool, this header file specification will generate *`base64Binary`* serializers and deserializers.</div><div class="line"><a name="l09115"></a><span class="lineno"> 9115</span>&#160;</div><div class="line"><a name="l09116"></a><span class="lineno"> 9116</span>&#160;The *`SOAP_ENC:base64`* encoding is another type for base 64 binary encoding</div><div class="line"><a name="l09117"></a><span class="lineno"> 9117</span>&#160;specified by the SOAP data type schema and some SOAP applications may use this form</div><div class="line"><a name="l09118"></a><span class="lineno"> 9118</span>&#160;(as indicated by their WSDL descriptions). It is declared by:</div><div class="line"><a name="l09119"></a><span class="lineno"> 9119</span>&#160;</div><div class="line"><a name="l09120"></a><span class="lineno"> 9120</span>&#160;```cpp</div><div class="line"><a name="l09121"></a><span class="lineno"> 9121</span>&#160;struct SOAP_ENC__base64 </div><div class="line"><a name="l09122"></a><span class="lineno"> 9122</span>&#160;{ </div><div class="line"><a name="l09123"></a><span class="lineno"> 9123</span>&#160;   unsigned char *__ptr; </div><div class="line"><a name="l09124"></a><span class="lineno"> 9124</span>&#160;   int __size; </div><div class="line"><a name="l09125"></a><span class="lineno"> 9125</span>&#160;};</div><div class="line"><a name="l09126"></a><span class="lineno"> 9126</span>&#160;```</div><div class="line"><a name="l09127"></a><span class="lineno"> 9127</span>&#160;</div><div class="line"><a name="l09128"></a><span class="lineno"> 9128</span>&#160;Or with a `class`:</div><div class="line"><a name="l09129"></a><span class="lineno"> 9129</span>&#160;</div><div class="line"><a name="l09130"></a><span class="lineno"> 9130</span>&#160;```cpp</div><div class="line"><a name="l09131"></a><span class="lineno"> 9131</span>&#160;class SOAP_ENC__base64 </div><div class="line"><a name="l09132"></a><span class="lineno"> 9132</span>&#160;{ </div><div class="line"><a name="l09133"></a><span class="lineno"> 9133</span>&#160;   unsigned char *__ptr; </div><div class="line"><a name="l09134"></a><span class="lineno"> 9134</span>&#160;   int __size; </div><div class="line"><a name="l09135"></a><span class="lineno"> 9135</span>&#160;};</div><div class="line"><a name="l09136"></a><span class="lineno"> 9136</span>&#160;```</div><div class="line"><a name="l09137"></a><span class="lineno"> 9137</span>&#160;</div><div class="line"><a name="l09138"></a><span class="lineno"> 9138</span>&#160;When compiled by the gSOAP `soapcpp2` tool, this header file specification will generate *`SOAP-ENC:base64`* serializers and deserializers.</div><div class="line"><a name="l09139"></a><span class="lineno"> 9139</span>&#160;</div><div class="line"><a name="l09140"></a><span class="lineno"> 9140</span>&#160;The advantage of using a `class` is that methods can be used to initialize and manipulate the `__ptr` and `__size` fields. The user can add methods to this class to do this. For example:</div><div class="line"><a name="l09141"></a><span class="lineno"> 9141</span>&#160;</div><div class="line"><a name="l09142"></a><span class="lineno"> 9142</span>&#160;```cpp</div><div class="line"><a name="l09143"></a><span class="lineno"> 9143</span>&#160;class xsd__base64Binary </div><div class="line"><a name="l09144"></a><span class="lineno"> 9144</span>&#160;{ </div><div class="line"><a name="l09145"></a><span class="lineno"> 9145</span>&#160;   public: </div><div class="line"><a name="l09146"></a><span class="lineno"> 9146</span>&#160;   unsigned char *__ptr; </div><div class="line"><a name="l09147"></a><span class="lineno"> 9147</span>&#160;   int __size; </div><div class="line"><a name="l09148"></a><span class="lineno"> 9148</span>&#160;   xsd__base64Binary(); // Constructor </div><div class="line"><a name="l09149"></a><span class="lineno"> 9149</span>&#160;   xsd__base64Binary(struct soap *soap, int n); // Constructor </div><div class="line"><a name="l09150"></a><span class="lineno"> 9150</span>&#160;   ~xsd__base64Binary(); // Destructor </div><div class="line"><a name="l09151"></a><span class="lineno"> 9151</span>&#160;   unsigned char *location(); // returns the memory location </div><div class="line"><a name="l09152"></a><span class="lineno"> 9152</span>&#160;   int size(); // returns the number of bytes </div><div class="line"><a name="l09153"></a><span class="lineno"> 9153</span>&#160;};</div><div class="line"><a name="l09154"></a><span class="lineno"> 9154</span>&#160;```</div><div class="line"><a name="l09155"></a><span class="lineno"> 9155</span>&#160;</div><div class="line"><a name="l09156"></a><span class="lineno"> 9156</span>&#160;Here are example method implementations:</div><div class="line"><a name="l09157"></a><span class="lineno"> 9157</span>&#160;</div><div class="line"><a name="l09158"></a><span class="lineno"> 9158</span>&#160;```cpp</div><div class="line"><a name="l09159"></a><span class="lineno"> 9159</span>&#160;xsd__base64Binary::xsd__base64Binary() </div><div class="line"><a name="l09160"></a><span class="lineno"> 9160</span>&#160;{ </div><div class="line"><a name="l09161"></a><span class="lineno"> 9161</span>&#160;  __ptr = NULL; </div><div class="line"><a name="l09162"></a><span class="lineno"> 9162</span>&#160;  __size = 0; </div><div class="line"><a name="l09163"></a><span class="lineno"> 9163</span>&#160;} </div><div class="line"><a name="l09164"></a><span class="lineno"> 9164</span>&#160;xsd__base64Binary::xsd__base64Binary(struct soap *soap, int n) </div><div class="line"><a name="l09165"></a><span class="lineno"> 9165</span>&#160;{ </div><div class="line"><a name="l09166"></a><span class="lineno"> 9166</span>&#160;  __ptr = (unsigned char*)soap_malloc(soap, n); </div><div class="line"><a name="l09167"></a><span class="lineno"> 9167</span>&#160;  __size = n; </div><div class="line"><a name="l09168"></a><span class="lineno"> 9168</span>&#160;} </div><div class="line"><a name="l09169"></a><span class="lineno"> 9169</span>&#160;xsd__base64Binary::~xsd__base64Binary() </div><div class="line"><a name="l09170"></a><span class="lineno"> 9170</span>&#160;{ } </div><div class="line"><a name="l09171"></a><span class="lineno"> 9171</span>&#160;unsigned char *xsd__base64Binary::location() </div><div class="line"><a name="l09172"></a><span class="lineno"> 9172</span>&#160;{ </div><div class="line"><a name="l09173"></a><span class="lineno"> 9173</span>&#160;  return __ptr; </div><div class="line"><a name="l09174"></a><span class="lineno"> 9174</span>&#160;} </div><div class="line"><a name="l09175"></a><span class="lineno"> 9175</span>&#160;int xsd__base64Binary::size() </div><div class="line"><a name="l09176"></a><span class="lineno"> 9176</span>&#160;{ </div><div class="line"><a name="l09177"></a><span class="lineno"> 9177</span>&#160;  return __size; </div><div class="line"><a name="l09178"></a><span class="lineno"> 9178</span>&#160;}</div><div class="line"><a name="l09179"></a><span class="lineno"> 9179</span>&#160;```</div><div class="line"><a name="l09180"></a><span class="lineno"> 9180</span>&#160;</div><div class="line"><a name="l09181"></a><span class="lineno"> 9181</span>&#160;The following example in C/C++ reads from a raw image file and encodes the image in SOAP using the *`base64Binary`* type:</div><div class="line"><a name="l09182"></a><span class="lineno"> 9182</span>&#160;</div><div class="line"><a name="l09183"></a><span class="lineno"> 9183</span>&#160;```cpp</div><div class="line"><a name="l09184"></a><span class="lineno"> 9184</span>&#160;... </div><div class="line"><a name="l09185"></a><span class="lineno"> 9185</span>&#160;FILE *fd = fopen(&quot;image.jpg&quot;, &quot;rb&quot;); </div><div class="line"><a name="l09186"></a><span class="lineno"> 9186</span>&#160;xsd__base64Binary image(&amp;soap, filesize(fd)); </div><div class="line"><a name="l09187"></a><span class="lineno"> 9187</span>&#160;fread(image.location(), image.size(), 1, fd); </div><div class="line"><a name="l09188"></a><span class="lineno"> 9188</span>&#160;fclose(fd); </div><div class="line"><a name="l09189"></a><span class="lineno"> 9189</span>&#160;soap_begin_send(&amp;soap); </div><div class="line"><a name="l09190"></a><span class="lineno"> 9190</span>&#160;image.soap_serialize(&amp;soap); </div><div class="line"><a name="l09191"></a><span class="lineno"> 9191</span>&#160;image.soap_put(&amp;soap, &quot;jpegimage&quot;, NULL); </div><div class="line"><a name="l09192"></a><span class="lineno"> 9192</span>&#160;soap_end_send(&amp;soap); </div><div class="line"><a name="l09193"></a><span class="lineno"> 9193</span>&#160;...</div><div class="line"><a name="l09194"></a><span class="lineno"> 9194</span>&#160;```</div><div class="line"><a name="l09195"></a><span class="lineno"> 9195</span>&#160;</div><div class="line"><a name="l09196"></a><span class="lineno"> 9196</span>&#160;where `filesize` is a function that returns the size of a file given a file descriptor.</div><div class="line"><a name="l09197"></a><span class="lineno"> 9197</span>&#160;</div><div class="line"><a name="l09198"></a><span class="lineno"> 9198</span>&#160;Reading the *`xsd:base64Binary`* encoded image.</div><div class="line"><a name="l09199"></a><span class="lineno"> 9199</span>&#160;</div><div class="line"><a name="l09200"></a><span class="lineno"> 9200</span>&#160;```cpp</div><div class="line"><a name="l09201"></a><span class="lineno"> 9201</span>&#160;... </div><div class="line"><a name="l09202"></a><span class="lineno"> 9202</span>&#160;xsd__base64Binary image; </div><div class="line"><a name="l09203"></a><span class="lineno"> 9203</span>&#160;soap_begin_recv(&amp;soap); </div><div class="line"><a name="l09204"></a><span class="lineno"> 9204</span>&#160;image.get(&amp;soap, &quot;jpegimage&quot;); </div><div class="line"><a name="l09205"></a><span class="lineno"> 9205</span>&#160;soap_end_recv(&amp;soap); </div><div class="line"><a name="l09206"></a><span class="lineno"> 9206</span>&#160;...</div><div class="line"><a name="l09207"></a><span class="lineno"> 9207</span>&#160;```</div><div class="line"><a name="l09208"></a><span class="lineno"> 9208</span>&#160;</div><div class="line"><a name="l09209"></a><span class="lineno"> 9209</span>&#160;The `struct` or `class` name `soap_enc__base64` should be used for *`SOAP-ENC:base64`* schema type instead of</div><div class="line"><a name="l09210"></a><span class="lineno"> 9210</span>&#160;`xsd__base64Binary`.</div><div class="line"><a name="l09211"></a><span class="lineno"> 9211</span>&#160;</div><div class="line"><a name="l09212"></a><span class="lineno"> 9212</span>&#160;## hexBinary XML Schema Type Encoding        {#hexbinary}</div><div class="line"><a name="l09213"></a><span class="lineno"> 9213</span>&#160;</div><div class="line"><a name="l09214"></a><span class="lineno"> 9214</span>&#160;The *`hexBinary`* XML Schema type is a special form of dynamic array declared with the name `xsd__hexBinary` and a pointer (`__ptr`) to an `unsigned char` array, similar to the base64Binary type described in the previous section. The only difference with the base64Binary type is the hexadecimal content instead of base64 content. Both types are declared identically, with the exception that the word &quot;`hex`&quot; occurs in the struct/class name.</div><div class="line"><a name="l09215"></a><span class="lineno"> 9215</span>&#160;</div><div class="line"><a name="l09216"></a><span class="lineno"> 9216</span>&#160;For example, using a `struct`:</div><div class="line"><a name="l09217"></a><span class="lineno"> 9217</span>&#160;</div><div class="line"><a name="l09218"></a><span class="lineno"> 9218</span>&#160;```cpp</div><div class="line"><a name="l09219"></a><span class="lineno"> 9219</span>&#160;struct xsd__hexBinary </div><div class="line"><a name="l09220"></a><span class="lineno"> 9220</span>&#160;{ </div><div class="line"><a name="l09221"></a><span class="lineno"> 9221</span>&#160;   unsigned char *__ptr; </div><div class="line"><a name="l09222"></a><span class="lineno"> 9222</span>&#160;   int __size; </div><div class="line"><a name="l09223"></a><span class="lineno"> 9223</span>&#160;};</div><div class="line"><a name="l09224"></a><span class="lineno"> 9224</span>&#160;```</div><div class="line"><a name="l09225"></a><span class="lineno"> 9225</span>&#160;</div><div class="line"><a name="l09226"></a><span class="lineno"> 9226</span>&#160;Or using a `class`:</div><div class="line"><a name="l09227"></a><span class="lineno"> 9227</span>&#160;</div><div class="line"><a name="l09228"></a><span class="lineno"> 9228</span>&#160;```cpp</div><div class="line"><a name="l09229"></a><span class="lineno"> 9229</span>&#160;class xsd__hexBinary </div><div class="line"><a name="l09230"></a><span class="lineno"> 9230</span>&#160;{ </div><div class="line"><a name="l09231"></a><span class="lineno"> 9231</span>&#160;   public: </div><div class="line"><a name="l09232"></a><span class="lineno"> 9232</span>&#160;   unsigned char *__ptr; </div><div class="line"><a name="l09233"></a><span class="lineno"> 9233</span>&#160;   int __size; </div><div class="line"><a name="l09234"></a><span class="lineno"> 9234</span>&#160;};</div><div class="line"><a name="l09235"></a><span class="lineno"> 9235</span>&#160;```</div><div class="line"><a name="l09236"></a><span class="lineno"> 9236</span>&#160;</div><div class="line"><a name="l09237"></a><span class="lineno"> 9237</span>&#160;or if a binary type such as `xsd__base64Binary` is defined, then we can simply use a `typedef` to introduce the hex variant:</div><div class="line"><a name="l09238"></a><span class="lineno"> 9238</span>&#160;</div><div class="line"><a name="l09239"></a><span class="lineno"> 9239</span>&#160;```cpp</div><div class="line"><a name="l09240"></a><span class="lineno"> 9240</span>&#160;class xsd__base64Binary // serializes into base64 content </div><div class="line"><a name="l09241"></a><span class="lineno"> 9241</span>&#160;{ </div><div class="line"><a name="l09242"></a><span class="lineno"> 9242</span>&#160;   public: </div><div class="line"><a name="l09243"></a><span class="lineno"> 9243</span>&#160;   unsigned char *__ptr; </div><div class="line"><a name="l09244"></a><span class="lineno"> 9244</span>&#160;   int __size; </div><div class="line"><a name="l09245"></a><span class="lineno"> 9245</span>&#160;}; </div><div class="line"><a name="l09246"></a><span class="lineno"> 9246</span>&#160;typedef xsd__base64Binary xsd__hexBinary; // serializes into hex content</div><div class="line"><a name="l09247"></a><span class="lineno"> 9247</span>&#160;```</div><div class="line"><a name="l09248"></a><span class="lineno"> 9248</span>&#160;</div><div class="line"><a name="l09249"></a><span class="lineno"> 9249</span>&#160;When compiled by the gSOAP `soapcpp2` tool, this header file specification will generate *`hexBinary`* serializers and deserializers.</div><div class="line"><a name="l09250"></a><span class="lineno"> 9250</span>&#160;</div><div class="line"><a name="l09251"></a><span class="lineno"> 9251</span>&#160;## Literal XML Encoding Style        {#literal}</div><div class="line"><a name="l09252"></a><span class="lineno"> 9252</span>&#160;</div><div class="line"><a name="l09253"></a><span class="lineno"> 9253</span>&#160;gSOAP supports document/literal encoding by default.</div><div class="line"><a name="l09254"></a><span class="lineno"> 9254</span>&#160;Just as with SOAP RPC encoding, literal encoding requires the XML Schema of the message data to be provided</div><div class="line"><a name="l09255"></a><span class="lineno"> 9255</span>&#160;e.g. in WSDL in order for the</div><div class="line"><a name="l09256"></a><span class="lineno"> 9256</span>&#160;gSOAP `soapcpp2` compiler to generate the (de)serialization routines.</div><div class="line"><a name="l09257"></a><span class="lineno"> 9257</span>&#160;</div><div class="line"><a name="l09258"></a><span class="lineno"> 9258</span>&#160;The `//gsoap service encoding`, `//gsoap service method-encoding`, and `//gsoap service method-response-encoding` directives explicitly enable SOAP encoded or literal encoded messages. For example, to enable RPC encoding style for the entire service, use:</div><div class="line"><a name="l09259"></a><span class="lineno"> 9259</span>&#160;</div><div class="line"><a name="l09260"></a><span class="lineno"> 9260</span>&#160;```cpp</div><div class="line"><a name="l09261"></a><span class="lineno"> 9261</span>&#160;//gsoap ns service encoding: encoded</div><div class="line"><a name="l09262"></a><span class="lineno"> 9262</span>&#160;```</div><div class="line"><a name="l09263"></a><span class="lineno"> 9263</span>&#160;</div><div class="line"><a name="l09264"></a><span class="lineno"> 9264</span>&#160;To enable encoding for particular service methods, use:</div><div class="line"><a name="l09265"></a><span class="lineno"> 9265</span>&#160;</div><div class="line"><a name="l09266"></a><span class="lineno"> 9266</span>&#160;```cpp</div><div class="line"><a name="l09267"></a><span class="lineno"> 9267</span>&#160;//gsoap ns service method-encoding: myMethod encoded </div><div class="line"><a name="l09268"></a><span class="lineno"> 9268</span>&#160;int ns__myMethod(...)</div><div class="line"><a name="l09269"></a><span class="lineno"> 9269</span>&#160;```</div><div class="line"><a name="l09270"></a><span class="lineno"> 9270</span>&#160;</div><div class="line"><a name="l09271"></a><span class="lineno"> 9271</span>&#160;To enable encoding for particular service methods responses when the method request is literal, use:</div><div class="line"><a name="l09272"></a><span class="lineno"> 9272</span>&#160;</div><div class="line"><a name="l09273"></a><span class="lineno"> 9273</span>&#160;```cpp</div><div class="line"><a name="l09274"></a><span class="lineno"> 9274</span>&#160;//gsoap ns service method-response-encoding: myMethod encoded </div><div class="line"><a name="l09275"></a><span class="lineno"> 9275</span>&#160;int ns__myMethod(...)</div><div class="line"><a name="l09276"></a><span class="lineno"> 9276</span>&#160;```</div><div class="line"><a name="l09277"></a><span class="lineno"> 9277</span>&#160;</div><div class="line"><a name="l09278"></a><span class="lineno"> 9278</span>&#160;Instead of the `encoded` value, you can use `literal`, or a specific encoding style value.</div><div class="line"><a name="l09279"></a><span class="lineno"> 9279</span>&#160;</div><div class="line"><a name="l09280"></a><span class="lineno"> 9280</span>&#160;Consider the following example that uses the directive to make the literal encoding explicit.</div><div class="line"><a name="l09281"></a><span class="lineno"> 9281</span>&#160;The `LocalTimeByZipCode` service operation of the LocalTime service provides</div><div class="line"><a name="l09282"></a><span class="lineno"> 9282</span>&#160;the local time given a zip code and uses literal encoding (with MS</div><div class="line"><a name="l09283"></a><span class="lineno"> 9283</span>&#160;.NET).  The following header file declares the method:</div><div class="line"><a name="l09284"></a><span class="lineno"> 9284</span>&#160;</div><div class="line"><a name="l09285"></a><span class="lineno"> 9285</span>&#160;```cpp</div><div class="line"><a name="l09286"></a><span class="lineno"> 9286</span>&#160;int LocalTimeByZipCode(char *ZipCode, char **LocalTimeByZipCodeResult);</div><div class="line"><a name="l09287"></a><span class="lineno"> 9287</span>&#160;```</div><div class="line"><a name="l09288"></a><span class="lineno"> 9288</span>&#160;</div><div class="line"><a name="l09289"></a><span class="lineno"> 9289</span>&#160;Note that none of the data types need to be namespace qualified using</div><div class="line"><a name="l09290"></a><span class="lineno"> 9290</span>&#160;namespace prefixes.</div><div class="line"><a name="l09291"></a><span class="lineno"> 9291</span>&#160;</div><div class="line"><a name="l09292"></a><span class="lineno"> 9292</span>&#160;```cpp</div><div class="line"><a name="l09293"></a><span class="lineno"> 9293</span>&#160;//gsoap ns service name: localtime </div><div class="line"><a name="l09294"></a><span class="lineno"> 9294</span>&#160;//gsoap ns service encoding: literal </div><div class="line"><a name="l09295"></a><span class="lineno"> 9295</span>&#160;//gsoap ns service namespace: http://alethea.net/webservices/ </div><div class="line"><a name="l09296"></a><span class="lineno"> 9296</span>&#160;int ns__LocalTimeByZipCode(char *ZipCode, char **LocalTimeByZipCodeResult);</div><div class="line"><a name="l09297"></a><span class="lineno"> 9297</span>&#160;```</div><div class="line"><a name="l09298"></a><span class="lineno"> 9298</span>&#160;</div><div class="line"><a name="l09299"></a><span class="lineno"> 9299</span>&#160;In this case, the method name requires to be associated with a schema through a namespace prefix, e.g. `ns` is used in this example.</div><div class="line"><a name="l09300"></a><span class="lineno"> 9300</span>&#160;See Section \ref directives  for more details on gSOAP directives.</div><div class="line"><a name="l09301"></a><span class="lineno"> 9301</span>&#160;With these directives, the gSOAP `soapcpp2` compiler generates client and server sources with the specified settings.</div><div class="line"><a name="l09302"></a><span class="lineno"> 9302</span>&#160;</div><div class="line"><a name="l09303"></a><span class="lineno"> 9303</span>&#160;The example client program is:</div><div class="line"><a name="l09304"></a><span class="lineno"> 9304</span>&#160;</div><div class="line"><a name="l09305"></a><span class="lineno"> 9305</span>&#160;```cpp</div><div class="line"><a name="l09306"></a><span class="lineno"> 9306</span>&#160;#include &quot;soapH.h&quot; </div><div class="line"><a name="l09307"></a><span class="lineno"> 9307</span>&#160;#include &quot;localtime.nsmap&quot; // include generated map file </div><div class="line"><a name="l09308"></a><span class="lineno"> 9308</span>&#160;int main() </div><div class="line"><a name="l09309"></a><span class="lineno"> 9309</span>&#160;{ </div><div class="line"><a name="l09310"></a><span class="lineno"> 9310</span>&#160;   struct soap soap; </div><div class="line"><a name="l09311"></a><span class="lineno"> 9311</span>&#160;   char *t; </div><div class="line"><a name="l09312"></a><span class="lineno"> 9312</span>&#160;   soap_init(&amp;soap); </div><div class="line"><a name="l09313"></a><span class="lineno"> 9313</span>&#160;   if (soap_call_ns__LocalTimeByZipCode(&amp;soap, &quot;http://alethea.net/webservices/LocalTime.asmx&quot;, &quot;http://alethea.net/webservices/LocalTimeByZipCode&quot;, &quot;32306&quot;, &amp;t)) </div><div class="line"><a name="l09314"></a><span class="lineno"> 9314</span>&#160;     soap_print_fault(&amp;soap, stderr); </div><div class="line"><a name="l09315"></a><span class="lineno"> 9315</span>&#160;   else </div><div class="line"><a name="l09316"></a><span class="lineno"> 9316</span>&#160;     printf(&quot;Time = %s\n&quot;, t); </div><div class="line"><a name="l09317"></a><span class="lineno"> 9317</span>&#160;   return 0; </div><div class="line"><a name="l09318"></a><span class="lineno"> 9318</span>&#160;} </div><div class="line"><a name="l09319"></a><span class="lineno"> 9319</span>&#160;```</div><div class="line"><a name="l09320"></a><span class="lineno"> 9320</span>&#160;</div><div class="line"><a name="l09321"></a><span class="lineno"> 9321</span>&#160;To illustrate the manual doc/literal setting, the following client program sets</div><div class="line"><a name="l09322"></a><span class="lineno"> 9322</span>&#160;the required properties before the call:</div><div class="line"><a name="l09323"></a><span class="lineno"> 9323</span>&#160;</div><div class="line"><a name="l09324"></a><span class="lineno"> 9324</span>&#160;```cpp</div><div class="line"><a name="l09325"></a><span class="lineno"> 9325</span>&#160;#include &quot;soapH.h&quot; </div><div class="line"><a name="l09326"></a><span class="lineno"> 9326</span>&#160;#include &quot;localtime.nsmap&quot; // include generated map file </div><div class="line"><a name="l09327"></a><span class="lineno"> 9327</span>&#160;int main() </div><div class="line"><a name="l09328"></a><span class="lineno"> 9328</span>&#160;{ </div><div class="line"><a name="l09329"></a><span class="lineno"> 9329</span>&#160;   struct soap soap; </div><div class="line"><a name="l09330"></a><span class="lineno"> 9330</span>&#160;   char *t; </div><div class="line"><a name="l09331"></a><span class="lineno"> 9331</span>&#160;   soap_init(&amp;soap); </div><div class="line"><a name="l09332"></a><span class="lineno"> 9332</span>&#160;   soap.encodingStyle = NULL; // don&#39;t use SOAP encoding </div><div class="line"><a name="l09333"></a><span class="lineno"> 9333</span>&#160;   soap_set_omode(&amp;soap, SOAP_XML_TREE);&quot; // don&#39;t produce multi-ref data (but can accept) </div><div class="line"><a name="l09334"></a><span class="lineno"> 9334</span>&#160;   if (soap_call_ns__LocalTimeByZipCode(&amp;soap, &quot;http://alethea.net/webservices/LocalTime.asmx&quot;, &quot;http://alethea.net/webservices/LocalTimeByZipCode&quot;, &quot;32306&quot;, &amp;t)) </div><div class="line"><a name="l09335"></a><span class="lineno"> 9335</span>&#160;     soap_print_fault(&amp;soap, stderr); </div><div class="line"><a name="l09336"></a><span class="lineno"> 9336</span>&#160;   else </div><div class="line"><a name="l09337"></a><span class="lineno"> 9337</span>&#160;     printf(&quot;Time = %s\n&quot;, t); </div><div class="line"><a name="l09338"></a><span class="lineno"> 9338</span>&#160;   return 0; </div><div class="line"><a name="l09339"></a><span class="lineno"> 9339</span>&#160;}</div><div class="line"><a name="l09340"></a><span class="lineno"> 9340</span>&#160;```</div><div class="line"><a name="l09341"></a><span class="lineno"> 9341</span>&#160;</div><div class="line"><a name="l09342"></a><span class="lineno"> 9342</span>&#160;The SOAP request is:</div><div class="line"><a name="l09343"></a><span class="lineno"> 9343</span>&#160;</div><div class="line"><a name="l09344"></a><span class="lineno"> 9344</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l09345"></a><span class="lineno"> 9345</span>&#160;```xml</div><div class="line"><a name="l09346"></a><span class="lineno"> 9346</span>&#160;POST /webservices/LocalTime.asmx HTTP/1.0 </div><div class="line"><a name="l09347"></a><span class="lineno"> 9347</span>&#160;Host: alethea.net </div><div class="line"><a name="l09348"></a><span class="lineno"> 9348</span>&#160;Content-Type: text/xml; charset=utf-8 </div><div class="line"><a name="l09349"></a><span class="lineno"> 9349</span>&#160;Content-Length: 479 </div><div class="line"><a name="l09350"></a><span class="lineno"> 9350</span>&#160;SOAPAction: &quot;http://alethea.net/webservices/LocalTimeByZipCode&quot; </div><div class="line"><a name="l09351"></a><span class="lineno"> 9351</span>&#160;</div><div class="line"><a name="l09352"></a><span class="lineno"> 9352</span>&#160;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; </div><div class="line"><a name="l09353"></a><span class="lineno"> 9353</span>&#160;&lt;SOAP-ENV:Envelope </div><div class="line"><a name="l09354"></a><span class="lineno"> 9354</span>&#160;  xmlns:SOAP-ENV=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; </div><div class="line"><a name="l09355"></a><span class="lineno"> 9355</span>&#160;  xmlns:SOAP-ENC=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot; </div><div class="line"><a name="l09356"></a><span class="lineno"> 9356</span>&#160;  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; </div><div class="line"><a name="l09357"></a><span class="lineno"> 9357</span>&#160;  xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; </div><div class="line"><a name="l09358"></a><span class="lineno"> 9358</span>&#160;  &lt;SOAP-ENV:Body&gt; </div><div class="line"><a name="l09359"></a><span class="lineno"> 9359</span>&#160;    &lt;LocalTimeByZipCode xmlns=&quot;http://alethea.net/webservices/&quot;&gt; </div><div class="line"><a name="l09360"></a><span class="lineno"> 9360</span>&#160;    &lt;ZipCode&gt;32306&lt;/ZipCode&gt;&lt;/LocalTimeByZipCode&gt; </div><div class="line"><a name="l09361"></a><span class="lineno"> 9361</span>&#160;  &lt;/SOAP-ENV:Body&gt; </div><div class="line"><a name="l09362"></a><span class="lineno"> 9362</span>&#160;&lt;/SOAP-ENV:Envelope&gt;</div><div class="line"><a name="l09363"></a><span class="lineno"> 9363</span>&#160;```</div><div class="line"><a name="l09364"></a><span class="lineno"> 9364</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l09365"></a><span class="lineno"> 9365</span>&#160;</div><div class="line"><a name="l09366"></a><span class="lineno"> 9366</span>&#160;### Serializing and Deserializing Mixed Content XML With Strings        {#literal2}</div><div class="line"><a name="l09367"></a><span class="lineno"> 9367</span>&#160;</div><div class="line"><a name="l09368"></a><span class="lineno"> 9368</span>&#160;To declare a literal XML &quot;type&quot; to hold XML documents in regular strings, use:</div><div class="line"><a name="l09369"></a><span class="lineno"> 9369</span>&#160;</div><div class="line"><a name="l09370"></a><span class="lineno"> 9370</span>&#160;```cpp</div><div class="line"><a name="l09371"></a><span class="lineno"> 9371</span>&#160;typedef char *XML;</div><div class="line"><a name="l09372"></a><span class="lineno"> 9372</span>&#160;```</div><div class="line"><a name="l09373"></a><span class="lineno"> 9373</span>&#160;</div><div class="line"><a name="l09374"></a><span class="lineno"> 9374</span>&#160;To declare a literal XML &quot;type&quot; to hold XML documents in wide character strings, use:</div><div class="line"><a name="l09375"></a><span class="lineno"> 9375</span>&#160;</div><div class="line"><a name="l09376"></a><span class="lineno"> 9376</span>&#160;```cpp</div><div class="line"><a name="l09377"></a><span class="lineno"> 9377</span>&#160;typedef wchar_t *XML;</div><div class="line"><a name="l09378"></a><span class="lineno"> 9378</span>&#160;```</div><div class="line"><a name="l09379"></a><span class="lineno"> 9379</span>&#160;</div><div class="line"><a name="l09380"></a><span class="lineno"> 9380</span>&#160;Note: only one of the two storage formats can be used.</div><div class="line"><a name="l09381"></a><span class="lineno"> 9381</span>&#160;The differences between the use of regular strings versus wide character strings for XML documents are:</div><div class="line"><a name="l09382"></a><span class="lineno"> 9382</span>&#160;</div><div class="line"><a name="l09383"></a><span class="lineno"> 9383</span>&#160;</div><div class="line"><a name="l09384"></a><span class="lineno"> 9384</span>&#160;*  Regular strings for XML documents MUST hold UTF-8 encoded XML documents. That is, the string MUST contain the proper UTF-8</div><div class="line"><a name="l09385"></a><span class="lineno"> 9385</span>&#160;encoding to exchange the XML document in SOAP messages.</div><div class="line"><a name="l09386"></a><span class="lineno"> 9386</span>&#160;</div><div class="line"><a name="l09387"></a><span class="lineno"> 9387</span>&#160;*  Wide character strings for XML documents SHOULD NOT hold UTF-8 encoded XML documents. Instead, the UTF-8 translation is done automatically by</div><div class="line"><a name="l09388"></a><span class="lineno"> 9388</span>&#160;the gSOAP runtime marshalling routines.</div><div class="line"><a name="l09389"></a><span class="lineno"> 9389</span>&#160;</div><div class="line"><a name="l09390"></a><span class="lineno"> 9390</span>&#160;Here is a C++ example of a service operation specification in which the parameters of the service operation uses literal XML encoding to pass</div><div class="line"><a name="l09391"></a><span class="lineno"> 9391</span>&#160;an XML document to a service and back:</div><div class="line"><a name="l09392"></a><span class="lineno"> 9392</span>&#160;</div><div class="line"><a name="l09393"></a><span class="lineno"> 9393</span>&#160;```cpp</div><div class="line"><a name="l09394"></a><span class="lineno"> 9394</span>&#160;typedef char *XML; </div><div class="line"><a name="l09395"></a><span class="lineno"> 9395</span>&#160;ns__GetDocument(XML m__XMLDoc, XML &amp;m__XMLDoc_);</div><div class="line"><a name="l09396"></a><span class="lineno"> 9396</span>&#160;```</div><div class="line"><a name="l09397"></a><span class="lineno"> 9397</span>&#160;</div><div class="line"><a name="l09398"></a><span class="lineno"> 9398</span>&#160;and in C:</div><div class="line"><a name="l09399"></a><span class="lineno"> 9399</span>&#160;</div><div class="line"><a name="l09400"></a><span class="lineno"> 9400</span>&#160;```cpp</div><div class="line"><a name="l09401"></a><span class="lineno"> 9401</span>&#160;typedef char *XML; </div><div class="line"><a name="l09402"></a><span class="lineno"> 9402</span>&#160;ns__GetDocument(XML m__XMLDoc, XML *m__XMLDoc_);</div><div class="line"><a name="l09403"></a><span class="lineno"> 9403</span>&#160;```</div><div class="line"><a name="l09404"></a><span class="lineno"> 9404</span>&#160;</div><div class="line"><a name="l09405"></a><span class="lineno"> 9405</span>&#160;The `ns__Document` is essentially a `struct` that forms the root of the XML document.</div><div class="line"><a name="l09406"></a><span class="lineno"> 9406</span>&#160;The use of the underscore in the `ns__Document` response part of the message avoids the name clash between the</div><div class="line"><a name="l09407"></a><span class="lineno"> 9407</span>&#160;`struct`s.</div><div class="line"><a name="l09408"></a><span class="lineno"> 9408</span>&#160;Assuming that the namespace mapping table contains the binding of `ns` to *`http://my.org/`*</div><div class="line"><a name="l09409"></a><span class="lineno"> 9409</span>&#160;and the binding of `m` to *`http://my.org/mydoc.xsd`*, the XML message is:</div><div class="line"><a name="l09410"></a><span class="lineno"> 9410</span>&#160;</div><div class="line"><a name="l09411"></a><span class="lineno"> 9411</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l09412"></a><span class="lineno"> 9412</span>&#160;```xml</div><div class="line"><a name="l09413"></a><span class="lineno"> 9413</span>&#160;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; </div><div class="line"><a name="l09414"></a><span class="lineno"> 9414</span>&#160;&lt;SOAP-ENV:Envelope </div><div class="line"><a name="l09415"></a><span class="lineno"> 9415</span>&#160;   xmlns:SOAP-ENV=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; </div><div class="line"><a name="l09416"></a><span class="lineno"> 9416</span>&#160;   xmlns:SOAP-ENC=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot; </div><div class="line"><a name="l09417"></a><span class="lineno"> 9417</span>&#160;   xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; </div><div class="line"><a name="l09418"></a><span class="lineno"> 9418</span>&#160;   xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; </div><div class="line"><a name="l09419"></a><span class="lineno"> 9419</span>&#160;   xmlns:ns=&quot;http://my.org/&quot; </div><div class="line"><a name="l09420"></a><span class="lineno"> 9420</span>&#160;   xmlns:m=&quot;http://my.org/mydoc.xsd&quot; </div><div class="line"><a name="l09421"></a><span class="lineno"> 9421</span>&#160;   SOAP-ENV:encodingStyle=&quot;&quot;&gt; </div><div class="line"><a name="l09422"></a><span class="lineno"> 9422</span>&#160;   &lt;SOAP-ENV:Body&gt; </div><div class="line"><a name="l09423"></a><span class="lineno"> 9423</span>&#160;     &lt;ns:GetDocument&gt; </div><div class="line"><a name="l09424"></a><span class="lineno"> 9424</span>&#160;       &lt;XMLDoc xmlns=&quot;http://my.org/mydoc.xsd&quot;&gt; </div><div class="line"><a name="l09425"></a><span class="lineno"> 9425</span>&#160;         ... </div><div class="line"><a name="l09426"></a><span class="lineno"> 9426</span>&#160;       &lt;/XMLDoc&gt; </div><div class="line"><a name="l09427"></a><span class="lineno"> 9427</span>&#160;     &lt;/ns:Document&gt; </div><div class="line"><a name="l09428"></a><span class="lineno"> 9428</span>&#160;  &lt;/SOAP-ENV:Body&gt; </div><div class="line"><a name="l09429"></a><span class="lineno"> 9429</span>&#160;&lt;/SOAP-ENV:Envelope&gt;</div><div class="line"><a name="l09430"></a><span class="lineno"> 9430</span>&#160;```</div><div class="line"><a name="l09431"></a><span class="lineno"> 9431</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l09432"></a><span class="lineno"> 9432</span>&#160;</div><div class="line"><a name="l09433"></a><span class="lineno"> 9433</span>&#160;When using literal encoding of method parameters and response as shown in the example above, the literal XML encoding style MUST be specified by setting `soap.encodingStyle`.</div><div class="line"><a name="l09434"></a><span class="lineno"> 9434</span>&#160;For example, to specify no constraints on the encoding style (which is typical) use NULL:</div><div class="line"><a name="l09435"></a><span class="lineno"> 9435</span>&#160;</div><div class="line"><a name="l09436"></a><span class="lineno"> 9436</span>&#160;```cpp</div><div class="line"><a name="l09437"></a><span class="lineno"> 9437</span>&#160;struct soap soap; </div><div class="line"><a name="l09438"></a><span class="lineno"> 9438</span>&#160;soap_init(&amp;soap); </div><div class="line"><a name="l09439"></a><span class="lineno"> 9439</span>&#160;soap.encodingStyle = NULL;</div><div class="line"><a name="l09440"></a><span class="lineno"> 9440</span>&#160;```</div><div class="line"><a name="l09441"></a><span class="lineno"> 9441</span>&#160;</div><div class="line"><a name="l09442"></a><span class="lineno"> 9442</span>&#160;As a result, the *`SOAP-ENV:encodingStyle`* attribute will not appear in the SOAP payload.</div><div class="line"><a name="l09443"></a><span class="lineno"> 9443</span>&#160;</div><div class="line"><a name="l09444"></a><span class="lineno"> 9444</span>&#160;For interoperability with Apache SOAP, use</div><div class="line"><a name="l09445"></a><span class="lineno"> 9445</span>&#160;</div><div class="line"><a name="l09446"></a><span class="lineno"> 9446</span>&#160;```cpp</div><div class="line"><a name="l09447"></a><span class="lineno"> 9447</span>&#160;struct soap soap; </div><div class="line"><a name="l09448"></a><span class="lineno"> 9448</span>&#160;soap_init(&amp;soap); </div><div class="line"><a name="l09449"></a><span class="lineno"> 9449</span>&#160;soap.encodingStyle = &quot;http://xml.apache.org/xml-soap/literalxml&quot;;</div><div class="line"><a name="l09450"></a><span class="lineno"> 9450</span>&#160;```</div><div class="line"><a name="l09451"></a><span class="lineno"> 9451</span>&#160;</div><div class="line"><a name="l09452"></a><span class="lineno"> 9452</span>&#160;When the response parameter is an XML type, it will store the entire XML response content but without the enveloping response element.</div><div class="line"><a name="l09453"></a><span class="lineno"> 9453</span>&#160;</div><div class="line"><a name="l09454"></a><span class="lineno"> 9454</span>&#160;The XML type can be used as part of any data structure to enable the rendering and parsing of custom XML documents. For example:</div><div class="line"><a name="l09455"></a><span class="lineno"> 9455</span>&#160;</div><div class="line"><a name="l09456"></a><span class="lineno"> 9456</span>&#160;```cpp</div><div class="line"><a name="l09457"></a><span class="lineno"> 9457</span>&#160;typedef char *XML; </div><div class="line"><a name="l09458"></a><span class="lineno"> 9458</span>&#160;struct ns__Data /* data in namespace &#39;ns&#39; */ </div><div class="line"><a name="l09459"></a><span class="lineno"> 9459</span>&#160;{ </div><div class="line"><a name="l09460"></a><span class="lineno"> 9460</span>&#160;   int number; </div><div class="line"><a name="l09461"></a><span class="lineno"> 9461</span>&#160;   char *name; </div><div class="line"><a name="l09462"></a><span class="lineno"> 9462</span>&#160;   XML m__document; /* XML document in default namespace &#39;m&#39; */ </div><div class="line"><a name="l09463"></a><span class="lineno"> 9463</span>&#160;}; </div><div class="line"><a name="l09464"></a><span class="lineno"> 9464</span>&#160;ns__Example(struct ns__Data data, struct ns__ExampleResponse { struct ns__Data data; } *out);</div><div class="line"><a name="l09465"></a><span class="lineno"> 9465</span>&#160;```</div><div class="line"><a name="l09466"></a><span class="lineno"> 9466</span>&#160;</div><div class="line"><a name="l09467"></a><span class="lineno"> 9467</span>&#160;# SOAP Fault Processing        {#fault}</div><div class="line"><a name="l09468"></a><span class="lineno"> 9468</span>&#160;</div><div class="line"><a name="l09469"></a><span class="lineno"> 9469</span>&#160;A predeclared standard SOAP Fault data structure is generated by the gSOAP `soapcpp2` tool for exchanging exception messages.</div><div class="line"><a name="l09470"></a><span class="lineno"> 9470</span>&#160;The built-in `struct SOAP_ENV__Fault` data structure is defined as:</div><div class="line"><a name="l09471"></a><span class="lineno"> 9471</span>&#160;</div><div class="line"><a name="l09472"></a><span class="lineno"> 9472</span>&#160;```cpp</div><div class="line"><a name="l09473"></a><span class="lineno"> 9473</span>&#160;struct SOAP_ENV__Fault </div><div class="line"><a name="l09474"></a><span class="lineno"> 9474</span>&#160;{ </div><div class="line"><a name="l09475"></a><span class="lineno"> 9475</span>&#160;   _QName faultcode; // _QName is builtin </div><div class="line"><a name="l09476"></a><span class="lineno"> 9476</span>&#160;   char *faultstring; </div><div class="line"><a name="l09477"></a><span class="lineno"> 9477</span>&#160;   char *faultactor; </div><div class="line"><a name="l09478"></a><span class="lineno"> 9478</span>&#160;   struct SOAP_ENV__Detail *detail; </div><div class="line"><a name="l09479"></a><span class="lineno"> 9479</span>&#160;   struct SOAP_ENV__Code *SOAP_ENV__Code; // MUST be a SOAP_ENV__Code struct defined below </div><div class="line"><a name="l09480"></a><span class="lineno"> 9480</span>&#160;   char *SOAP_ENV__Reason; </div><div class="line"><a name="l09481"></a><span class="lineno"> 9481</span>&#160;   char *SOAP_ENV__Node; </div><div class="line"><a name="l09482"></a><span class="lineno"> 9482</span>&#160;   char *SOAP_ENV__Role; </div><div class="line"><a name="l09483"></a><span class="lineno"> 9483</span>&#160;   struct SOAP_ENV__Detail *SOAP_ENV__Detail; // SOAP 1.2 detail field </div><div class="line"><a name="l09484"></a><span class="lineno"> 9484</span>&#160;}; </div><div class="line"><a name="l09485"></a><span class="lineno"> 9485</span>&#160;struct SOAP_ENV__Code </div><div class="line"><a name="l09486"></a><span class="lineno"> 9486</span>&#160;{ </div><div class="line"><a name="l09487"></a><span class="lineno"> 9487</span>&#160;   _QName SOAP_ENV__Value; </div><div class="line"><a name="l09488"></a><span class="lineno"> 9488</span>&#160;   struct SOAP_ENV__Code *SOAP_ENV__Subcode; </div><div class="line"><a name="l09489"></a><span class="lineno"> 9489</span>&#160;}; </div><div class="line"><a name="l09490"></a><span class="lineno"> 9490</span>&#160;struct SOAP_ENV__Detail </div><div class="line"><a name="l09491"></a><span class="lineno"> 9491</span>&#160;{ </div><div class="line"><a name="l09492"></a><span class="lineno"> 9492</span>&#160;   int __type; // The SOAP_TYPE_ of the object serialized as Fault detail </div><div class="line"><a name="l09493"></a><span class="lineno"> 9493</span>&#160;   void *fault; // pointer to the fault object, or NULL </div><div class="line"><a name="l09494"></a><span class="lineno"> 9494</span>&#160;   char *__any; // any other detail element content (stored in XML format) </div><div class="line"><a name="l09495"></a><span class="lineno"> 9495</span>&#160;};</div><div class="line"><a name="l09496"></a><span class="lineno"> 9496</span>&#160;```</div><div class="line"><a name="l09497"></a><span class="lineno"> 9497</span>&#160;</div><div class="line"><a name="l09498"></a><span class="lineno"> 9498</span>&#160;The first four fields in `SOAP_ENV__Fault` are SOAP 1.1 specific. The last five fields are SOAP 1.2 specific.</div><div class="line"><a name="l09499"></a><span class="lineno"> 9499</span>&#160;You can redefine these structures in the header file. For example, you can use a `class` for the `SOAP_ENV__Fault` and add methods for convenience.</div><div class="line"><a name="l09500"></a><span class="lineno"> 9500</span>&#160;</div><div class="line"><a name="l09501"></a><span class="lineno"> 9501</span>&#160;The data structure content can be changed to the need of an application, but this is generally not necessary because the application-specific SOAP Fault details can be serialized via the `__type` and `fault` fields in the `SOAP_ENV__Detail` field, see Section \ref void  on the serialization of data refered to by `__type` and `fault`.</div><div class="line"><a name="l09502"></a><span class="lineno"> 9502</span>&#160;</div><div class="line"><a name="l09503"></a><span class="lineno"> 9503</span>&#160;The `__type` field allows application data to be serialized as part of the SOAP Fault. The application data SHOULD be defined as XML elements, which requires you to declare the type names with a leading underscore to ensure that the types are compatible with XML elements and not just simpleTypes and complexTypes.</div><div class="line"><a name="l09504"></a><span class="lineno"> 9504</span>&#160;</div><div class="line"><a name="l09505"></a><span class="lineno"> 9505</span>&#160;When the skeleton of a service operation returns an error (see Section \ref errcodes ), then `soap.fault` contains the SOAP</div><div class="line"><a name="l09506"></a><span class="lineno"> 9506</span>&#160;Fault data at the receiving side (client).</div><div class="line"><a name="l09507"></a><span class="lineno"> 9507</span>&#160;</div><div class="line"><a name="l09508"></a><span class="lineno"> 9508</span>&#160;Server-side faults are raised with `soap_sender_fault` or `soap_receiver_fault`. The `soap_sender_fault` call should be used to inform that the sender is at fault and the sender (client) should not resend the request. The `soap_receiver_fault` call should be used to indicate a temporary server-side problem, so a sender (client) can resend the request later. For example:</div><div class="line"><a name="l09509"></a><span class="lineno"> 9509</span>&#160;</div><div class="line"><a name="l09510"></a><span class="lineno"> 9510</span>&#160;```cpp</div><div class="line"><a name="l09511"></a><span class="lineno"> 9511</span>&#160;int ns1__myMethod(struct soap *soap, ...) </div><div class="line"><a name="l09512"></a><span class="lineno"> 9512</span>&#160;{ </div><div class="line"><a name="l09513"></a><span class="lineno"> 9513</span>&#160;   ... </div><div class="line"><a name="l09514"></a><span class="lineno"> 9514</span>&#160;   return soap_receiver_fault(soap, &quot;Resource temporarily unavailable&quot;, NULL); // return fault to sender </div><div class="line"><a name="l09515"></a><span class="lineno"> 9515</span>&#160;}</div><div class="line"><a name="l09516"></a><span class="lineno"> 9516</span>&#160;```</div><div class="line"><a name="l09517"></a><span class="lineno"> 9517</span>&#160;</div><div class="line"><a name="l09518"></a><span class="lineno"> 9518</span>&#160;In the example, the SOAP Fault details were empty (NULL). You may pass an XML fragment, which will be literally included in the SOAP Fault message. For WS-I Basic Profile compliance, you must pass an XML string with one or more namespace qualified elements, such as:</div><div class="line"><a name="l09519"></a><span class="lineno"> 9519</span>&#160;</div><div class="line"><a name="l09520"></a><span class="lineno"> 9520</span>&#160;```cpp</div><div class="line"><a name="l09521"></a><span class="lineno"> 9521</span>&#160;return soap_receiver_fault(soap, &quot;Resource temporarily unavailable&quot;, &quot;&lt;errorcode xmlns=&#39;http://tempuri.org&#39;&gt;123&lt;/errorcode&gt;&lt;errorinfo xmlns=&#39;http://tempuri.org&#39;&gt;abc&lt;/errorinfo&gt;&quot;);</div><div class="line"><a name="l09522"></a><span class="lineno"> 9522</span>&#160;```</div><div class="line"><a name="l09523"></a><span class="lineno"> 9523</span>&#160;</div><div class="line"><a name="l09524"></a><span class="lineno"> 9524</span>&#160;</div><div class="line"><a name="l09525"></a><span class="lineno"> 9525</span>&#160;When a service operation must raise an exception with application SOAP Fault details, it does so by assigning the `soap.fault` field of the current reference to the</div><div class="line"><a name="l09526"></a><span class="lineno"> 9526</span>&#160;runtime context with </div><div class="line"><a name="l09527"></a><span class="lineno"> 9527</span>&#160;appropriate data associated with the exception and by returning the error `SOAP_FAULT`.</div><div class="line"><a name="l09528"></a><span class="lineno"> 9528</span>&#160;For example:</div><div class="line"><a name="l09529"></a><span class="lineno"> 9529</span>&#160;</div><div class="line"><a name="l09530"></a><span class="lineno"> 9530</span>&#160;```cpp</div><div class="line"><a name="l09531"></a><span class="lineno"> 9531</span>&#160;soap_receiver_fault(soap, &quot;Stack dump&quot;, NULL); </div><div class="line"><a name="l09532"></a><span class="lineno"> 9532</span>&#160;if (soap-&gt;version == 2) // SOAP 1.2 is used </div><div class="line"><a name="l09533"></a><span class="lineno"> 9533</span>&#160;{ </div><div class="line"><a name="l09534"></a><span class="lineno"> 9534</span>&#160;  soap-&gt;fault-&gt;SOAP_ENV__Detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail); </div><div class="line"><a name="l09535"></a><span class="lineno"> 9535</span>&#160;  soap-&gt;fault-&gt;SOAP_ENV__Detail-&gt;__type = SOAP_TYPE_ns1__myStackDataType; // stack type </div><div class="line"><a name="l09536"></a><span class="lineno"> 9536</span>&#160;  soap-&gt;fault-&gt;SOAP_ENV__Detail-&gt;fault = sp; // point to stack </div><div class="line"><a name="l09537"></a><span class="lineno"> 9537</span>&#160;  soap-&gt;fault-&gt;SOAP_ENV__Detail-&gt;__any = NULL; // no other XML data </div><div class="line"><a name="l09538"></a><span class="lineno"> 9538</span>&#160;} </div><div class="line"><a name="l09539"></a><span class="lineno"> 9539</span>&#160;else </div><div class="line"><a name="l09540"></a><span class="lineno"> 9540</span>&#160;{ </div><div class="line"><a name="l09541"></a><span class="lineno"> 9541</span>&#160;  soap-&gt;fault-&gt;detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail); </div><div class="line"><a name="l09542"></a><span class="lineno"> 9542</span>&#160;  soap-&gt;fault-&gt;detail-&gt;__type = SOAP_TYPE_ns1__myStackDataType; // stack type </div><div class="line"><a name="l09543"></a><span class="lineno"> 9543</span>&#160;  soap-&gt;fault-&gt;detail-&gt;fault = sp; // point to stack </div><div class="line"><a name="l09544"></a><span class="lineno"> 9544</span>&#160;  soap-&gt;fault-&gt;detail-&gt;__any = NULL; // no other XML data </div><div class="line"><a name="l09545"></a><span class="lineno"> 9545</span>&#160;} </div><div class="line"><a name="l09546"></a><span class="lineno"> 9546</span>&#160;return SOAP_FAULT; // return from service operation call</div><div class="line"><a name="l09547"></a><span class="lineno"> 9547</span>&#160;```</div><div class="line"><a name="l09548"></a><span class="lineno"> 9548</span>&#160;</div><div class="line"><a name="l09549"></a><span class="lineno"> 9549</span>&#160;When `soap_receiver_fault` allocates a fault struct, this data is removed with the `soap_end` call (or `soap_dealloc`).</div><div class="line"><a name="l09550"></a><span class="lineno"> 9550</span>&#160;Note that the `soap_receiver_fault` function is called to allocate the fault struct and set the fault string and detail</div><div class="line"><a name="l09551"></a><span class="lineno"> 9551</span>&#160;fields, i.e. `soap_receiver_fault(soap, &quot;Stack dump&quot;, NULL)`. The advantage is that this is independent of SOAP 1.1 and</div><div class="line"><a name="l09552"></a><span class="lineno"> 9552</span>&#160;SOAP 1.2.  However, setting the custom detail fields requires inspecting the SOAP version used, using the `soap-&gt;version`</div><div class="line"><a name="l09553"></a><span class="lineno"> 9553</span>&#160;attribute which is 1 for SOAP 1.1 and 2 for SOAP 1.2.</div><div class="line"><a name="l09554"></a><span class="lineno"> 9554</span>&#160;</div><div class="line"><a name="l09555"></a><span class="lineno"> 9555</span>&#160;Each service operation implementation in a service application can return a SOAP Fault upon an exception by returning an error code,</div><div class="line"><a name="l09556"></a><span class="lineno"> 9556</span>&#160;see Section \ref example7  for details and an example.</div><div class="line"><a name="l09557"></a><span class="lineno"> 9557</span>&#160;In addition, a SOAP Fault can be returned by a service application through calling the `soap_send_fault` function.</div><div class="line"><a name="l09558"></a><span class="lineno"> 9558</span>&#160;This is useful in case the initialization of the application fails, as illustrated in the example below:</div><div class="line"><a name="l09559"></a><span class="lineno"> 9559</span>&#160;</div><div class="line"><a name="l09560"></a><span class="lineno"> 9560</span>&#160;```cpp</div><div class="line"><a name="l09561"></a><span class="lineno"> 9561</span>&#160;int main() </div><div class="line"><a name="l09562"></a><span class="lineno"> 9562</span>&#160;{</div><div class="line"><a name="l09563"></a><span class="lineno"> 9563</span>&#160;   struct soap soap; </div><div class="line"><a name="l09564"></a><span class="lineno"> 9564</span>&#160;   soap_init(&amp;soap); </div><div class="line"><a name="l09565"></a><span class="lineno"> 9565</span>&#160;   some initialization code </div><div class="line"><a name="l09566"></a><span class="lineno"> 9566</span>&#160;   if (initialization failed) </div><div class="line"><a name="l09567"></a><span class="lineno"> 9567</span>&#160;  {</div><div class="line"><a name="l09568"></a><span class="lineno"> 9568</span>&#160;     soap.error = soap_receiver_fault(&amp;soap, &quot;Init failed&quot;, NULL); // set the error condition (SOAP_FAULT) </div><div class="line"><a name="l09569"></a><span class="lineno"> 9569</span>&#160;     soap_send_fault(&amp;soap); // Send SOAP Fault to client </div><div class="line"><a name="l09570"></a><span class="lineno"> 9570</span>&#160;     return 0; // Terminate </div><div class="line"><a name="l09571"></a><span class="lineno"> 9571</span>&#160;  } </div><div class="line"><a name="l09572"></a><span class="lineno"> 9572</span>&#160;}</div><div class="line"><a name="l09573"></a><span class="lineno"> 9573</span>&#160;```</div><div class="line"><a name="l09574"></a><span class="lineno"> 9574</span>&#160;</div><div class="line"><a name="l09575"></a><span class="lineno"> 9575</span>&#160;# SOAP Header Processing        {#header}</div><div class="line"><a name="l09576"></a><span class="lineno"> 9576</span>&#160;</div><div class="line"><a name="l09577"></a><span class="lineno"> 9577</span>&#160;A predeclared standard SOAP Header data structure is generated by the gSOAP `soapcpp2` tool for exchanging SOAP</div><div class="line"><a name="l09578"></a><span class="lineno"> 9578</span>&#160;messages with SOAP Headers.</div><div class="line"><a name="l09579"></a><span class="lineno"> 9579</span>&#160;This predeclared data structure is:</div><div class="line"><a name="l09580"></a><span class="lineno"> 9580</span>&#160;</div><div class="line"><a name="l09581"></a><span class="lineno"> 9581</span>&#160;```cpp</div><div class="line"><a name="l09582"></a><span class="lineno"> 9582</span>&#160;struct SOAP_ENV__Header { };</div><div class="line"><a name="l09583"></a><span class="lineno"> 9583</span>&#160;```</div><div class="line"><a name="l09584"></a><span class="lineno"> 9584</span>&#160;</div><div class="line"><a name="l09585"></a><span class="lineno"> 9585</span>&#160;which declares and empty header (some C and C++ compilers don&#39;t accept empty structs, use compile flag `-DWITH_NOEMPTYSTRUCT` to avoid these errors).</div><div class="line"><a name="l09586"></a><span class="lineno"> 9586</span>&#160;</div><div class="line"><a name="l09587"></a><span class="lineno"> 9587</span>&#160;To adapt the data structure to a specific need for SOAP Header processing, a</div><div class="line"><a name="l09588"></a><span class="lineno"> 9588</span>&#160;new `struct SOAP_ENV__Header` can be added to the header file input to the gSOAP</div><div class="line"><a name="l09589"></a><span class="lineno"> 9589</span>&#160;compiler.  A `class` for the SOAP Header data structure can be used instead of a `struct`.</div><div class="line"><a name="l09590"></a><span class="lineno"> 9590</span>&#160;</div><div class="line"><a name="l09591"></a><span class="lineno"> 9591</span>&#160;For example, the following header can be used for transaction control:</div><div class="line"><a name="l09592"></a><span class="lineno"> 9592</span>&#160;</div><div class="line"><a name="l09593"></a><span class="lineno"> 9593</span>&#160;```cpp</div><div class="line"><a name="l09594"></a><span class="lineno"> 9594</span>&#160;struct SOAP_ENV__Header </div><div class="line"><a name="l09595"></a><span class="lineno"> 9595</span>&#160;{ char *t__transaction; </div><div class="line"><a name="l09596"></a><span class="lineno"> 9596</span>&#160;};</div><div class="line"><a name="l09597"></a><span class="lineno"> 9597</span>&#160;```</div><div class="line"><a name="l09598"></a><span class="lineno"> 9598</span>&#160;</div><div class="line"><a name="l09599"></a><span class="lineno"> 9599</span>&#160;with client-side code:</div><div class="line"><a name="l09600"></a><span class="lineno"> 9600</span>&#160;</div><div class="line"><a name="l09601"></a><span class="lineno"> 9601</span>&#160;```cpp</div><div class="line"><a name="l09602"></a><span class="lineno"> 9602</span>&#160;   struct soap soap; </div><div class="line"><a name="l09603"></a><span class="lineno"> 9603</span>&#160;   soap_init(&amp;soap); </div><div class="line"><a name="l09604"></a><span class="lineno"> 9604</span>&#160;... </div><div class="line"><a name="l09605"></a><span class="lineno"> 9605</span>&#160;soap.header = NULL; // do not use a SOAP Header for the request (as set with soap_init) </div><div class="line"><a name="l09606"></a><span class="lineno"> 9606</span>&#160;soap.actor = NULL; // do not use an actor (receiver is actor) </div><div class="line"><a name="l09607"></a><span class="lineno"> 9607</span>&#160;soap_call_method(&amp;soap, ...); </div><div class="line"><a name="l09608"></a><span class="lineno"> 9608</span>&#160;if (soap.header) // a SOAP Header was received </div><div class="line"><a name="l09609"></a><span class="lineno"> 9609</span>&#160;   cout &lt;&lt; soap.header-&gt;t__transaction; </div><div class="line"><a name="l09610"></a><span class="lineno"> 9610</span>&#160;// Can reset, modify, or set soap.header here before next call </div><div class="line"><a name="l09611"></a><span class="lineno"> 9611</span>&#160;soap_call_method(&amp;soap, ...); // reuse the SOAP Header of the service response for the request </div><div class="line"><a name="l09612"></a><span class="lineno"> 9612</span>&#160;...</div><div class="line"><a name="l09613"></a><span class="lineno"> 9613</span>&#160;```</div><div class="line"><a name="l09614"></a><span class="lineno"> 9614</span>&#160;</div><div class="line"><a name="l09615"></a><span class="lineno"> 9615</span>&#160;The SOAP Web service response can include a SOAP Header with a transaction number that the client is supposed to use for the next service operation invocation to the service. Therefore, the next request includes a transaction number:</div><div class="line"><a name="l09616"></a><span class="lineno"> 9616</span>&#160;</div><div class="line"><a name="l09617"></a><span class="lineno"> 9617</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l09618"></a><span class="lineno"> 9618</span>&#160;```xml</div><div class="line"><a name="l09619"></a><span class="lineno"> 9619</span>&#160;... </div><div class="line"><a name="l09620"></a><span class="lineno"> 9620</span>&#160;&lt;SOAP-ENV:Envelope ...&gt; </div><div class="line"><a name="l09621"></a><span class="lineno"> 9621</span>&#160;&lt;SOAP-ENV:Header&gt; </div><div class="line"><a name="l09622"></a><span class="lineno"> 9622</span>&#160;&lt;transaction xmlns=&quot;...&quot; xsi:type=&quot;int&quot;&gt;12345&lt;/transaction&gt; </div><div class="line"><a name="l09623"></a><span class="lineno"> 9623</span>&#160;&lt;/SOAP-ENV:Header&gt; </div><div class="line"><a name="l09624"></a><span class="lineno"> 9624</span>&#160;&lt;SOAP-ENV:Body&gt; </div><div class="line"><a name="l09625"></a><span class="lineno"> 9625</span>&#160;... </div><div class="line"><a name="l09626"></a><span class="lineno"> 9626</span>&#160;&lt;/SOAP-ENV:Body&gt; </div><div class="line"><a name="l09627"></a><span class="lineno"> 9627</span>&#160;&lt;/SOAP-ENV:Envelope&gt;</div><div class="line"><a name="l09628"></a><span class="lineno"> 9628</span>&#160;```</div><div class="line"><a name="l09629"></a><span class="lineno"> 9629</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l09630"></a><span class="lineno"> 9630</span>&#160;</div><div class="line"><a name="l09631"></a><span class="lineno"> 9631</span>&#160;This is just an example and the transaction control is not a feature of SOAP but can be added on by the application layer</div><div class="line"><a name="l09632"></a><span class="lineno"> 9632</span>&#160;to implement stateful transactions between clients and services.</div><div class="line"><a name="l09633"></a><span class="lineno"> 9633</span>&#160;At the client side, the `soap.actor` attribute can be set to</div><div class="line"><a name="l09634"></a><span class="lineno"> 9634</span>&#160;indicate the recipient of the header (the SOAP *`SOAP-ENV:actor`* attribute).</div><div class="line"><a name="l09635"></a><span class="lineno"> 9635</span>&#160;</div><div class="line"><a name="l09636"></a><span class="lineno"> 9636</span>&#160;A Web service can read and set the SOAP Header as follows:</div><div class="line"><a name="l09637"></a><span class="lineno"> 9637</span>&#160;</div><div class="line"><a name="l09638"></a><span class="lineno"> 9638</span>&#160;```cpp</div><div class="line"><a name="l09639"></a><span class="lineno"> 9639</span>&#160;int main() </div><div class="line"><a name="l09640"></a><span class="lineno"> 9640</span>&#160;{ </div><div class="line"><a name="l09641"></a><span class="lineno"> 9641</span>&#160;   struct soap soap; </div><div class="line"><a name="l09642"></a><span class="lineno"> 9642</span>&#160;   soap.actor = NULL; // use this to accept all headers (default) </div><div class="line"><a name="l09643"></a><span class="lineno"> 9643</span>&#160;   soap.actor = &quot;http://some/actor&quot;; // accept headers destined for &quot;http://some/actor&quot; only </div><div class="line"><a name="l09644"></a><span class="lineno"> 9644</span>&#160;   soap_serve(&amp;soap);</div><div class="line"><a name="l09645"></a><span class="lineno"> 9645</span>&#160;} </div><div class="line"><a name="l09646"></a><span class="lineno"> 9646</span>&#160;... </div><div class="line"><a name="l09647"></a><span class="lineno"> 9647</span>&#160;int method(struct soap *soap, ...) </div><div class="line"><a name="l09648"></a><span class="lineno"> 9648</span>&#160;{</div><div class="line"><a name="l09649"></a><span class="lineno"> 9649</span>&#160;   if (soap-&gt;header) // a Header was received </div><div class="line"><a name="l09650"></a><span class="lineno"> 9650</span>&#160;     ... = soap-&gt;header-&gt;t__transaction; </div><div class="line"><a name="l09651"></a><span class="lineno"> 9651</span>&#160;   else </div><div class="line"><a name="l09652"></a><span class="lineno"> 9652</span>&#160;     soap-&gt;header = soap_malloc(sizeof(struct SOAP_ENV__Header)); // alloc new header </div><div class="line"><a name="l09653"></a><span class="lineno"> 9653</span>&#160;...</div><div class="line"><a name="l09654"></a><span class="lineno"> 9654</span>&#160;     soap-&gt;header-&gt;t__transaction = ...; </div><div class="line"><a name="l09655"></a><span class="lineno"> 9655</span>&#160;   return SOAP_OK; </div><div class="line"><a name="l09656"></a><span class="lineno"> 9656</span>&#160;}</div><div class="line"><a name="l09657"></a><span class="lineno"> 9657</span>&#160;```</div><div class="line"><a name="l09658"></a><span class="lineno"> 9658</span>&#160;</div><div class="line"><a name="l09659"></a><span class="lineno"> 9659</span>&#160;See Section \ref directives  on how to generate WSDL with the proper method-to-header-part bindings.</div><div class="line"><a name="l09660"></a><span class="lineno"> 9660</span>&#160;</div><div class="line"><a name="l09661"></a><span class="lineno"> 9661</span>&#160;The *`SOAP-ENV:mustUnderstand`* attribute indicates the requirement that the recipient of the SOAP Header (who must</div><div class="line"><a name="l09662"></a><span class="lineno"> 9662</span>&#160;correspond to the *`SOAP-ENV:actor`* attribute when present or when the attribute has the value</div><div class="line"><a name="l09663"></a><span class="lineno"> 9663</span>&#160;*`SOAP-ENV:actor=&quot;http://schemas.xmlsoap.org/soap/actor/next&quot;`*) MUST handle the Header part that carries the attribute.</div><div class="line"><a name="l09664"></a><span class="lineno"> 9664</span>&#160;gSOAP handles this automatically on the background. However, an application still needs to inspect the header part&#39;s value</div><div class="line"><a name="l09665"></a><span class="lineno"> 9665</span>&#160;and handle it appropriately. If a service operation in a Web service is not able to do this, it should return</div><div class="line"><a name="l09666"></a><span class="lineno"> 9666</span>&#160;`SOAP_MUSTUNDERSTAND` to indicate this failure.</div><div class="line"><a name="l09667"></a><span class="lineno"> 9667</span>&#160;</div><div class="line"><a name="l09668"></a><span class="lineno"> 9668</span>&#160;The syntax for the header file input to the gSOAP `soapcpp2` compiler is extended with a special storage qualifier `mustUnderstand`.</div><div class="line"><a name="l09669"></a><span class="lineno"> 9669</span>&#160;This qualifier can be used in the SOAP Header declaration to indicate which parts should carry a `SOAP-ENV:mustUnderstand=&quot;1&quot;`</div><div class="line"><a name="l09670"></a><span class="lineno"> 9670</span>&#160;attribute. For example:</div><div class="line"><a name="l09671"></a><span class="lineno"> 9671</span>&#160;</div><div class="line"><a name="l09672"></a><span class="lineno"> 9672</span>&#160;```cpp</div><div class="line"><a name="l09673"></a><span class="lineno"> 9673</span>&#160;struct SOAP_ENV__Header </div><div class="line"><a name="l09674"></a><span class="lineno"> 9674</span>&#160;{ </div><div class="line"><a name="l09675"></a><span class="lineno"> 9675</span>&#160;   char *t__transaction; </div><div class="line"><a name="l09676"></a><span class="lineno"> 9676</span>&#160;   mustUnderstand char *t__authentication; </div><div class="line"><a name="l09677"></a><span class="lineno"> 9677</span>&#160;};</div><div class="line"><a name="l09678"></a><span class="lineno"> 9678</span>&#160;```</div><div class="line"><a name="l09679"></a><span class="lineno"> 9679</span>&#160;</div><div class="line"><a name="l09680"></a><span class="lineno"> 9680</span>&#160;When both fields are set and `soap.actor=&quot;http://some/actor&quot;` then the message contains:</div><div class="line"><a name="l09681"></a><span class="lineno"> 9681</span>&#160;</div><div class="line"><a name="l09682"></a><span class="lineno"> 9682</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l09683"></a><span class="lineno"> 9683</span>&#160;```xml</div><div class="line"><a name="l09684"></a><span class="lineno"> 9684</span>&#160;&lt;SOAP-ENV:Envelope ...&gt; </div><div class="line"><a name="l09685"></a><span class="lineno"> 9685</span>&#160;&lt;SOAP-ENV:Header&gt; </div><div class="line"><a name="l09686"></a><span class="lineno"> 9686</span>&#160;&lt;transaction xmlns=&quot;...&quot;&gt;5&lt;/transaction&gt; </div><div class="line"><a name="l09687"></a><span class="lineno"> 9687</span>&#160;&lt;authentication xmlns=&quot;...&quot; </div><div class="line"><a name="l09688"></a><span class="lineno"> 9688</span>&#160;   SOAP-ENV:actor=&quot;http://some/actor&quot; SOAP-ENV:mustUnderstand=&quot;1&quot;&gt;XX </div><div class="line"><a name="l09689"></a><span class="lineno"> 9689</span>&#160;&lt;/authentication&gt; </div><div class="line"><a name="l09690"></a><span class="lineno"> 9690</span>&#160;&lt;/SOAP-ENV:Header&gt; </div><div class="line"><a name="l09691"></a><span class="lineno"> 9691</span>&#160;&lt;SOAP-ENV:Body&gt; </div><div class="line"><a name="l09692"></a><span class="lineno"> 9692</span>&#160;... </div><div class="line"><a name="l09693"></a><span class="lineno"> 9693</span>&#160;&lt;/SOAP-ENV:Body&gt; </div><div class="line"><a name="l09694"></a><span class="lineno"> 9694</span>&#160;&lt;/SOAP-ENV:Envelope&gt;</div><div class="line"><a name="l09695"></a><span class="lineno"> 9695</span>&#160;```</div><div class="line"><a name="l09696"></a><span class="lineno"> 9696</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l09697"></a><span class="lineno"> 9697</span>&#160;</div><div class="line"><a name="l09698"></a><span class="lineno"> 9698</span>&#160;# MIME Attachments        {#MIME}</div><div class="line"><a name="l09699"></a><span class="lineno"> 9699</span>&#160;</div><div class="line"><a name="l09700"></a><span class="lineno"> 9700</span>&#160;The gSOAP toolkit supports MIME attachments as per SOAP with Attachments (SwA)</div><div class="line"><a name="l09701"></a><span class="lineno"> 9701</span>&#160;specification (http://www.w3.org/TR/SOAP-attachments). In the following</div><div class="line"><a name="l09702"></a><span class="lineno"> 9702</span>&#160;discussion, MIME attachment data is assumed to be resident in memory for</div><div class="line"><a name="l09703"></a><span class="lineno"> 9703</span>&#160;sending operations and MIME attachments received will be stored in memory. MTOM</div><div class="line"><a name="l09704"></a><span class="lineno"> 9704</span>&#160;and DIME attachments on the other hand can be streamed and therefore MTOM/DIME</div><div class="line"><a name="l09705"></a><span class="lineno"> 9705</span>&#160;attachment data does not need to be stored in memory, see</div><div class="line"><a name="l09706"></a><span class="lineno"> 9706</span>&#160;Section \ref DIME  and \ref MTOM .</div><div class="line"><a name="l09707"></a><span class="lineno"> 9707</span>&#160;</div><div class="line"><a name="l09708"></a><span class="lineno"> 9708</span>&#160;Transmitting multipart/related MIME attachments with a SOAP/XML message is</div><div class="line"><a name="l09709"></a><span class="lineno"> 9709</span>&#160;accomplished with two functions, `soap_set_mime` and</div><div class="line"><a name="l09710"></a><span class="lineno"> 9710</span>&#160;`soap_set_mime_attachment`. The first function is for initialization</div><div class="line"><a name="l09711"></a><span class="lineno"> 9711</span>&#160;purposes and the latter function is used to specify meta data and content data</div><div class="line"><a name="l09712"></a><span class="lineno"> 9712</span>&#160;for each attachment.</div><div class="line"><a name="l09713"></a><span class="lineno"> 9713</span>&#160;</div><div class="line"><a name="l09714"></a><span class="lineno"> 9714</span>&#160;## Sending a Collection of MIME Attachments (SwA)</div><div class="line"><a name="l09715"></a><span class="lineno"> 9715</span>&#160;</div><div class="line"><a name="l09716"></a><span class="lineno"> 9716</span>&#160;The following functions should be used to set up a collection of</div><div class="line"><a name="l09717"></a><span class="lineno"> 9717</span>&#160;multipart/related MIME attachments for transmission with a SOAP/XML message.</div><div class="line"><a name="l09718"></a><span class="lineno"> 9718</span>&#160;</div><div class="line"><a name="l09719"></a><span class="lineno"> 9719</span>&#160;* `void soap_set_mime(struct soap *soap, const char *boundary, const char *start)` </div><div class="line"><a name="l09720"></a><span class="lineno"> 9720</span>&#160;  This function must be called first to initialize MIME attachment send</div><div class="line"><a name="l09721"></a><span class="lineno"> 9721</span>&#160;  operations (receives are automatic). The function specifies a MIME boundary and</div><div class="line"><a name="l09722"></a><span class="lineno"> 9722</span>&#160;  start content ID used for the SOAP message body. When `boundary` is NULL, an</div><div class="line"><a name="l09723"></a><span class="lineno"> 9723</span>&#160;  appropriate MIME boundary will be choosen (important: boundaries cannot occur</div><div class="line"><a name="l09724"></a><span class="lineno"> 9724</span>&#160;  in the SOAP/XML message and cannot occur in any of the MIME attachments</div><div class="line"><a name="l09725"></a><span class="lineno"> 9725</span>&#160;  content). When a specific boundary value is provided, gSOAP will NOT verify</div><div class="line"><a name="l09726"></a><span class="lineno"> 9726</span>&#160;  that the boundary is valid. When `start` is NULL, the start ID of the SOAP</div><div class="line"><a name="l09727"></a><span class="lineno"> 9727</span>&#160;  message is &lt;*`SOAP-ENV:Envelope`*&gt;.</div><div class="line"><a name="l09728"></a><span class="lineno"> 9728</span>&#160;</div><div class="line"><a name="l09729"></a><span class="lineno"> 9729</span>&#160;* `int soap_set_mime_attachment(struct soap *soap, char *ptr, size_t size, enum soap_mime_encoding encoding, const char *type, const char *id, const char *location, const char *description)` </div><div class="line"><a name="l09730"></a><span class="lineno"> 9730</span>&#160;  This function adds a new attachment to the list of attachments, where `ptr`</div><div class="line"><a name="l09731"></a><span class="lineno"> 9731</span>&#160;  and `size` refer to the block of memory that holds the attachment data. The</div><div class="line"><a name="l09732"></a><span class="lineno"> 9732</span>&#160;  `encoding` parameter specifies the content encoding of this block, where the</div><div class="line"><a name="l09733"></a><span class="lineno"> 9733</span>&#160;  value of `encoding` is one of `SOAP_MIME_7BIT`, `SOAP_MIME_8BIT`,</div><div class="line"><a name="l09734"></a><span class="lineno"> 9734</span>&#160;  `SOAP_MIME_BINARY`, `SOAP_MIME_QUOTED_PRINTABLE`, `SOAP_MIME_BASE64`,</div><div class="line"><a name="l09735"></a><span class="lineno"> 9735</span>&#160;  `SOAP_MIME_IETF_TOKEN`, or `SOAP_MIME_X_TOKEN`. These constants reflect the</div><div class="line"><a name="l09736"></a><span class="lineno"> 9736</span>&#160;  content encoding defined in RFC2045 and you MUST adhere to the content</div><div class="line"><a name="l09737"></a><span class="lineno"> 9737</span>&#160;  encoding rules defined by RFC2045. When in doubt, use `SOAP_MIME_BINARY`,</div><div class="line"><a name="l09738"></a><span class="lineno"> 9738</span>&#160;  since this encoding type covers any content. The mandatory `type` string</div><div class="line"><a name="l09739"></a><span class="lineno"> 9739</span>&#160;  parameter is the MIME type of the data. The `id` string parameter is the</div><div class="line"><a name="l09740"></a><span class="lineno"> 9740</span>&#160;  content ID of the MIME attachment. The optional `location` string parameter</div><div class="line"><a name="l09741"></a><span class="lineno"> 9741</span>&#160;  is the content location of the attachment. The optional `description` string</div><div class="line"><a name="l09742"></a><span class="lineno"> 9742</span>&#160;  parameter holds a textual description of the attachment (it may not contain</div><div class="line"><a name="l09743"></a><span class="lineno"> 9743</span>&#160;      any control characters). All parameter values are copied, except `ptr`</div><div class="line"><a name="l09744"></a><span class="lineno"> 9744</span>&#160;  which must point to a valid location of the attachment data during the</div><div class="line"><a name="l09745"></a><span class="lineno"> 9745</span>&#160;  transfer.  The value `SOAP_OK` is returned when the attachment was added.</div><div class="line"><a name="l09746"></a><span class="lineno"> 9746</span>&#160;  Otherwise a gSOAP error code is returned.</div><div class="line"><a name="l09747"></a><span class="lineno"> 9747</span>&#160;</div><div class="line"><a name="l09748"></a><span class="lineno"> 9748</span>&#160;* `void soap_clr_mime(struct soap *soap)` </div><div class="line"><a name="l09749"></a><span class="lineno"> 9749</span>&#160;  Disables MIME attachments, e.g. to avoid MIME attachments to be part of a SOAP Fault response message. </div><div class="line"><a name="l09750"></a><span class="lineno"> 9750</span>&#160;</div><div class="line"><a name="l09751"></a><span class="lineno"> 9751</span>&#160;When providing a MIME boundary with `soap_set_mime`, you have to make</div><div class="line"><a name="l09752"></a><span class="lineno"> 9752</span>&#160;sure the boundary cannot match any SOAP/XML message content.</div><div class="line"><a name="l09753"></a><span class="lineno"> 9753</span>&#160;Or you can simply pass NULL and let gSOAP select a safe boundary for you.</div><div class="line"><a name="l09754"></a><span class="lineno"> 9754</span>&#160;</div><div class="line"><a name="l09755"></a><span class="lineno"> 9755</span>&#160;The internal list of attachments is destroyed with `soap_end`, you should</div><div class="line"><a name="l09756"></a><span class="lineno"> 9756</span>&#160;call this function sometime after the message exchange was completed (the</div><div class="line"><a name="l09757"></a><span class="lineno"> 9757</span>&#160;content of the block of memory referred to by the `ptr` parameter is</div><div class="line"><a name="l09758"></a><span class="lineno"> 9758</span>&#160;unaffected).</div><div class="line"><a name="l09759"></a><span class="lineno"> 9759</span>&#160;</div><div class="line"><a name="l09760"></a><span class="lineno"> 9760</span>&#160;The following example shows how a multipart/related HTTP message with three</div><div class="line"><a name="l09761"></a><span class="lineno"> 9761</span>&#160;MIME attachments is set up and transmitted to a server. The first attachment</div><div class="line"><a name="l09762"></a><span class="lineno"> 9762</span>&#160;contains the SOAP message. The second and third attachments contain image data.</div><div class="line"><a name="l09763"></a><span class="lineno"> 9763</span>&#160;In this example we let the SOAP message body refer to the attachments using</div><div class="line"><a name="l09764"></a><span class="lineno"> 9764</span>&#160;*`href`* attributes.  The `struct claim__form` data type includes a</div><div class="line"><a name="l09765"></a><span class="lineno"> 9765</span>&#160;definition of a `href` attribute for this purpose.</div><div class="line"><a name="l09766"></a><span class="lineno"> 9766</span>&#160;</div><div class="line"><a name="l09767"></a><span class="lineno"> 9767</span>&#160;```cpp</div><div class="line"><a name="l09768"></a><span class="lineno"> 9768</span>&#160;struct claim__form form1, form2; </div><div class="line"><a name="l09769"></a><span class="lineno"> 9769</span>&#160;form1.href = &quot;cid:claim061400a.tiff@claiming-it.com&quot;; </div><div class="line"><a name="l09770"></a><span class="lineno"> 9770</span>&#160;form2.href = &quot;cid:claim061400a.jpeg@claiming-it.com&quot;; </div><div class="line"><a name="l09771"></a><span class="lineno"> 9771</span>&#160;/* initialize and enable MIME */ </div><div class="line"><a name="l09772"></a><span class="lineno"> 9772</span>&#160;soap_set_mime(soap, &quot;MIME_boundary&quot;, &quot;&lt;claim061400a.xml@claiming-it.com&gt;&quot;); </div><div class="line"><a name="l09773"></a><span class="lineno"> 9773</span>&#160;/* add a base64 encoded tiff image (tiffImage points to base64 data) */ </div><div class="line"><a name="l09774"></a><span class="lineno"> 9774</span>&#160;soap_set_mime_attachment(soap, tiffImage, tiffLen, SOAP_MIME_BASE64, &quot;image/tiff&quot;, </div><div class="line"><a name="l09775"></a><span class="lineno"> 9775</span>&#160;       &quot;&lt;claim061400a.tiff@claiming-it.com&gt;&quot;, NULL, NULL); </div><div class="line"><a name="l09776"></a><span class="lineno"> 9776</span>&#160;/* add a raw binary jpeg image (jpegImage points to raw data) */ </div><div class="line"><a name="l09777"></a><span class="lineno"> 9777</span>&#160;soap_set_mime_attachment(soap, jpegImage, jpegLen, SOAP_MIME_BINARY, &quot;image/jpeg&quot;, </div><div class="line"><a name="l09778"></a><span class="lineno"> 9778</span>&#160;       &quot;&lt;claim061400a.jpeg@claiming-it.com&gt;&quot;, NULL, NULL); </div><div class="line"><a name="l09779"></a><span class="lineno"> 9779</span>&#160;/* send the forms as MIME attachments with this invocation */ </div><div class="line"><a name="l09780"></a><span class="lineno"> 9780</span>&#160;if (soap_call_claim__insurance_claim_auto(soap, form1, form2, ...)) </div><div class="line"><a name="l09781"></a><span class="lineno"> 9781</span>&#160;   // an error occurred </div><div class="line"><a name="l09782"></a><span class="lineno"> 9782</span>&#160;else </div><div class="line"><a name="l09783"></a><span class="lineno"> 9783</span>&#160;   // process response</div><div class="line"><a name="l09784"></a><span class="lineno"> 9784</span>&#160;```</div><div class="line"><a name="l09785"></a><span class="lineno"> 9785</span>&#160;</div><div class="line"><a name="l09786"></a><span class="lineno"> 9786</span>&#160;Note: the above example assumes that the boundary `MIME_boundary` does not match any part of the SOAP/XML message.</div><div class="line"><a name="l09787"></a><span class="lineno"> 9787</span>&#160;</div><div class="line"><a name="l09788"></a><span class="lineno"> 9788</span>&#160;The `claim__form` struct is declared in the gSOAP header file as:</div><div class="line"><a name="l09789"></a><span class="lineno"> 9789</span>&#160;</div><div class="line"><a name="l09790"></a><span class="lineno"> 9790</span>&#160;```cpp</div><div class="line"><a name="l09791"></a><span class="lineno"> 9791</span>&#160;struct claim__form </div><div class="line"><a name="l09792"></a><span class="lineno"> 9792</span>&#160;{</div><div class="line"><a name="l09793"></a><span class="lineno"> 9793</span>&#160;  @ char *href; </div><div class="line"><a name="l09794"></a><span class="lineno"> 9794</span>&#160;};</div><div class="line"><a name="l09795"></a><span class="lineno"> 9795</span>&#160;```     </div><div class="line"><a name="l09796"></a><span class="lineno"> 9796</span>&#160;</div><div class="line"><a name="l09797"></a><span class="lineno"> 9797</span>&#160;This data type defines the parameter data of the operation. The claim forms in</div><div class="line"><a name="l09798"></a><span class="lineno"> 9798</span>&#160;the SOAP/XML message consist of *`href`*s to the claim forms attached.  The</div><div class="line"><a name="l09799"></a><span class="lineno"> 9799</span>&#160;produced message is similar to the last example shown in the SOAP with</div><div class="line"><a name="l09800"></a><span class="lineno"> 9800</span>&#160;Attachments specification (http://www.w3.org/TR/SOAP-attachments).  Note that</div><div class="line"><a name="l09801"></a><span class="lineno"> 9801</span>&#160;the use of *`href`* or other attributes for referring to the MIME attachments</div><div class="line"><a name="l09802"></a><span class="lineno"> 9802</span>&#160;is optional according to the SwA standard.</div><div class="line"><a name="l09803"></a><span class="lineno"> 9803</span>&#160;</div><div class="line"><a name="l09804"></a><span class="lineno"> 9804</span>&#160;To associate MIME attachments with the request and response of a service operation in the generated WSDL, please see Section \ref MIMEWSDL .</div><div class="line"><a name="l09805"></a><span class="lineno"> 9805</span>&#160;</div><div class="line"><a name="l09806"></a><span class="lineno"> 9806</span>&#160;The server-side code to transmit MIME attachments back to a client is similar:</div><div class="line"><a name="l09807"></a><span class="lineno"> 9807</span>&#160;</div><div class="line"><a name="l09808"></a><span class="lineno"> 9808</span>&#160;```cpp</div><div class="line"><a name="l09809"></a><span class="lineno"> 9809</span>&#160;int claim__insurance_claim_auto(struct soap *soap, ...) </div><div class="line"><a name="l09810"></a><span class="lineno"> 9810</span>&#160;{ </div><div class="line"><a name="l09811"></a><span class="lineno"> 9811</span>&#160;   soap_set_mime(soap, NULL, NULL); // enable MIME</div><div class="line"><a name="l09812"></a><span class="lineno"> 9812</span>&#160;   // add a HTML document (htmlDoc points to data, where the HTML doc is stored in compliance with 7bit encoding RFC2045) </div><div class="line"><a name="l09813"></a><span class="lineno"> 9813</span>&#160;   if (soap_set_mime_attachment(soap, htmlDoc, strlen(htmlDoc), SOAP_MIME_7BIT, &quot;text/html&quot;, </div><div class="line"><a name="l09814"></a><span class="lineno"> 9814</span>&#160;       &quot;&lt;claim061400a.html@claiming-it.com&gt;&quot;, NULL, NULL)) </div><div class="line"><a name="l09815"></a><span class="lineno"> 9815</span>&#160;   { </div><div class="line"><a name="l09816"></a><span class="lineno"> 9816</span>&#160;     soap_clr_mime(soap); // don&#39;t want fault with attachments </div><div class="line"><a name="l09817"></a><span class="lineno"> 9817</span>&#160;     return soap-&gt;error; </div><div class="line"><a name="l09818"></a><span class="lineno"> 9818</span>&#160;   } </div><div class="line"><a name="l09819"></a><span class="lineno"> 9819</span>&#160;   return SOAP_OK; </div><div class="line"><a name="l09820"></a><span class="lineno"> 9820</span>&#160;}</div><div class="line"><a name="l09821"></a><span class="lineno"> 9821</span>&#160;```</div><div class="line"><a name="l09822"></a><span class="lineno"> 9822</span>&#160;</div><div class="line"><a name="l09823"></a><span class="lineno"> 9823</span>&#160;It is also possible to attach data to a SOAP fault message.</div><div class="line"><a name="l09824"></a><span class="lineno"> 9824</span>&#160;</div><div class="line"><a name="l09825"></a><span class="lineno"> 9825</span>&#160;@warning DIME in MIME is supported. However, gSOAP will not verify whether</div><div class="line"><a name="l09826"></a><span class="lineno"> 9826</span>&#160;the MIME boundary is present in the DIME attachments and therefore will not</div><div class="line"><a name="l09827"></a><span class="lineno"> 9827</span>&#160;select a boundary that is guaranteed to be unique. Therefore, you must provide</div><div class="line"><a name="l09828"></a><span class="lineno"> 9828</span>&#160;a MIME boundary with `soap_set_mime` that is unique when using DIME in</div><div class="line"><a name="l09829"></a><span class="lineno"> 9829</span>&#160;MIME.</div><div class="line"><a name="l09830"></a><span class="lineno"> 9830</span>&#160;</div><div class="line"><a name="l09831"></a><span class="lineno"> 9831</span>&#160;## Retrieving a Collection of MIME Attachments (SwA)</div><div class="line"><a name="l09832"></a><span class="lineno"> 9832</span>&#160;</div><div class="line"><a name="l09833"></a><span class="lineno"> 9833</span>&#160;MIME attachments are automatically parsed and stored in memory.</div><div class="line"><a name="l09834"></a><span class="lineno"> 9834</span>&#160;After receiving a set of MIME attachments, either at the client-side or</div><div class="line"><a name="l09835"></a><span class="lineno"> 9835</span>&#160;the server-side, the list of MIME attachments can be traversed to extract</div><div class="line"><a name="l09836"></a><span class="lineno"> 9836</span>&#160;meta data and the attachment content. The first attachment in the collection of</div><div class="line"><a name="l09837"></a><span class="lineno"> 9837</span>&#160;MIME attachments always contains meta data about the SOAP message</div><div class="line"><a name="l09838"></a><span class="lineno"> 9838</span>&#160;itself (because the SOAP message was processed the attachment does not contain</div><div class="line"><a name="l09839"></a><span class="lineno"> 9839</span>&#160;any useful data).</div><div class="line"><a name="l09840"></a><span class="lineno"> 9840</span>&#160;</div><div class="line"><a name="l09841"></a><span class="lineno"> 9841</span>&#160;To traverse the list of MIME attachments in C, you use a loop similar to:</div><div class="line"><a name="l09842"></a><span class="lineno"> 9842</span>&#160;</div><div class="line"><a name="l09843"></a><span class="lineno"> 9843</span>&#160;```cpp</div><div class="line"><a name="l09844"></a><span class="lineno"> 9844</span>&#160;struct soap_multipart *attachment; </div><div class="line"><a name="l09845"></a><span class="lineno"> 9845</span>&#160;for (attachment = soap.mime.list; attachment; attachment = attachment-&gt;next) </div><div class="line"><a name="l09846"></a><span class="lineno"> 9846</span>&#160;{ </div><div class="line"><a name="l09847"></a><span class="lineno"> 9847</span>&#160;   printf(&quot;MIME attachment:\n&quot;); </div><div class="line"><a name="l09848"></a><span class="lineno"> 9848</span>&#160;   printf(&quot;Memory=%p\n&quot;, (*attachment).ptr); </div><div class="line"><a name="l09849"></a><span class="lineno"> 9849</span>&#160;   printf(&quot;Size=%ul\n&quot;, (*attachment).size); </div><div class="line"><a name="l09850"></a><span class="lineno"> 9850</span>&#160;   printf(&quot;Encoding=%d\n&quot;, (int)(*attachment).encoding); </div><div class="line"><a name="l09851"></a><span class="lineno"> 9851</span>&#160;   printf(&quot;Type=%s\n&quot;, (*attachment).type?(*attachment).type:&quot;null&quot;); </div><div class="line"><a name="l09852"></a><span class="lineno"> 9852</span>&#160;   printf(&quot;ID=%s\n&quot;, (*attachment).id?(*attachment).id:&quot;null&quot;); </div><div class="line"><a name="l09853"></a><span class="lineno"> 9853</span>&#160;   printf(&quot;Location=%s\n&quot;, (*attachment).location?(*attachment).location:&quot;null&quot;); </div><div class="line"><a name="l09854"></a><span class="lineno"> 9854</span>&#160;   printf(&quot;Description=%s\n&quot;, (*attachment).description?(*attachment).description:&quot;null&quot;); </div><div class="line"><a name="l09855"></a><span class="lineno"> 9855</span>&#160;}</div><div class="line"><a name="l09856"></a><span class="lineno"> 9856</span>&#160;```</div><div class="line"><a name="l09857"></a><span class="lineno"> 9857</span>&#160;</div><div class="line"><a name="l09858"></a><span class="lineno"> 9858</span>&#160;C++ programmers can use an iterator instead, as in:</div><div class="line"><a name="l09859"></a><span class="lineno"> 9859</span>&#160;</div><div class="line"><a name="l09860"></a><span class="lineno"> 9860</span>&#160;```cpp</div><div class="line"><a name="l09861"></a><span class="lineno"> 9861</span>&#160;for (soap_multipart::iterator attachment = soap.mime.begin(); attachment != soap.mime.end(); ++attachment) </div><div class="line"><a name="l09862"></a><span class="lineno"> 9862</span>&#160;{ </div><div class="line"><a name="l09863"></a><span class="lineno"> 9863</span>&#160;   cout &lt;&lt; &quot;MIME attachment:&quot; &lt;&lt; endl; </div><div class="line"><a name="l09864"></a><span class="lineno"> 9864</span>&#160;   cout &lt;&lt; &quot;Memory=&quot; &lt;&lt; (void*)(*attachment).ptr &lt;&lt; endl; </div><div class="line"><a name="l09865"></a><span class="lineno"> 9865</span>&#160;   cout &lt;&lt; &quot;Size=&quot; &lt;&lt; (*attachment).size &lt;&lt; endl; </div><div class="line"><a name="l09866"></a><span class="lineno"> 9866</span>&#160;   cout &lt;&lt; &quot;Encoding=&quot; &lt;&lt; (*attachment).encoding &lt;&lt; endl; </div><div class="line"><a name="l09867"></a><span class="lineno"> 9867</span>&#160;   cout &lt;&lt; &quot;Type=&quot; &lt;&lt; ((*attachment).type?(*attachment).type:&quot;null&quot;) &lt;&lt; endl; </div><div class="line"><a name="l09868"></a><span class="lineno"> 9868</span>&#160;   cout &lt;&lt; &quot;ID=&quot; &lt;&lt; ((*attachment).id?(*attachment).id:&quot;null&quot;) &lt;&lt; endl; </div><div class="line"><a name="l09869"></a><span class="lineno"> 9869</span>&#160;   cout &lt;&lt; &quot;Location=&quot; &lt;&lt; ((*attachment).location?(*attachment).location:&quot;null&quot;) &lt;&lt; endl; </div><div class="line"><a name="l09870"></a><span class="lineno"> 9870</span>&#160;   cout &lt;&lt; &quot;Description=&quot; &lt;&lt; ((*attachment).description?(*attachment).description:&quot;null&quot;) &lt;&lt; endl; </div><div class="line"><a name="l09871"></a><span class="lineno"> 9871</span>&#160;}</div><div class="line"><a name="l09872"></a><span class="lineno"> 9872</span>&#160;```</div><div class="line"><a name="l09873"></a><span class="lineno"> 9873</span>&#160;</div><div class="line"><a name="l09874"></a><span class="lineno"> 9874</span>&#160;Note: keep in mind that the first attachment is associated with the SOAP</div><div class="line"><a name="l09875"></a><span class="lineno"> 9875</span>&#160;message and you may want to ignore it if the message has the attachment data</div><div class="line"><a name="l09876"></a><span class="lineno"> 9876</span>&#160;already embedded through its hrefs.</div><div class="line"><a name="l09877"></a><span class="lineno"> 9877</span>&#160;</div><div class="line"><a name="l09878"></a><span class="lineno"> 9878</span>&#160;A call to `soap_end` removes all of the received MIME data. To preserve an</div><div class="line"><a name="l09879"></a><span class="lineno"> 9879</span>&#160;attachment in memory, use `soap_unlink` on the `ptr` field of the</div><div class="line"><a name="l09880"></a><span class="lineno"> 9880</span>&#160;`soap_multipart` struct. Recall that the `soap_unlink` function is</div><div class="line"><a name="l09881"></a><span class="lineno"> 9881</span>&#160;commonly used to prevent deallocation of deserialized data.</div><div class="line"><a name="l09882"></a><span class="lineno"> 9882</span>&#160;</div><div class="line"><a name="l09883"></a><span class="lineno"> 9883</span>&#160;# DIME Attachments        {#DIME}</div><div class="line"><a name="l09884"></a><span class="lineno"> 9884</span>&#160;</div><div class="line"><a name="l09885"></a><span class="lineno"> 9885</span>&#160;The gSOAP toolkit supports DIME attachments as per DIME specification, see</div><div class="line"><a name="l09886"></a><span class="lineno"> 9886</span>&#160;http://msdn.microsoft.com/library/en-us/dnglobspec/html/draft-nielsen-dime-02.txt</div><div class="line"><a name="l09887"></a><span class="lineno"> 9887</span>&#160;</div><div class="line"><a name="l09888"></a><span class="lineno"> 9888</span>&#160;Applications developed with gSOAP can transmit binary DIME attachments with or</div><div class="line"><a name="l09889"></a><span class="lineno"> 9889</span>&#160;without streaming messages. Without streaming, all data is stored and retrieved in</div><div class="line"><a name="l09890"></a><span class="lineno"> 9890</span>&#160;memory, which can be prohibitive when transmitting large files on small</div><div class="line"><a name="l09891"></a><span class="lineno"> 9891</span>&#160;devices. The maximum DIME attachment size is limited to 8 MB by default as set with `SOAP_MAXDIMESIZE` in `stdsoap2.h`. This limit can be changed as needed by recompiling `stdsoap2.c` and `stdsoap2.cpp` with `-DSOAP_MAXDIMESIZE=100000000` for example. In contrast, with DIME streaming, data handlers are used to pass the</div><div class="line"><a name="l09892"></a><span class="lineno"> 9892</span>&#160;data to and from a resource, such as a file or device.  With DIME output</div><div class="line"><a name="l09893"></a><span class="lineno"> 9893</span>&#160;streaming, raw binary data is send from a data source in chunks on the fly</div><div class="line"><a name="l09894"></a><span class="lineno"> 9894</span>&#160;without buffering the entire content to save memory. With DIME input streaming,</div><div class="line"><a name="l09895"></a><span class="lineno"> 9895</span>&#160;raw binary data will be passed to data handlers (callbacks).</div><div class="line"><a name="l09896"></a><span class="lineno"> 9896</span>&#160;</div><div class="line"><a name="l09897"></a><span class="lineno"> 9897</span>&#160;## Sending a Collection of DIME Attachments</div><div class="line"><a name="l09898"></a><span class="lineno"> 9898</span>&#160;</div><div class="line"><a name="l09899"></a><span class="lineno"> 9899</span>&#160;The following functions can be used to explicitly set up a collection of</div><div class="line"><a name="l09900"></a><span class="lineno"> 9900</span>&#160;DIME attachments for transmission with a SOAP/XML message body.</div><div class="line"><a name="l09901"></a><span class="lineno"> 9901</span>&#160;The attachments can be streamed, as described in</div><div class="line"><a name="l09902"></a><span class="lineno"> 9902</span>&#160;Section \ref DIMEstreaming .  Without streaming, each attachment must refer</div><div class="line"><a name="l09903"></a><span class="lineno"> 9903</span>&#160;to a block of data in memory.</div><div class="line"><a name="l09904"></a><span class="lineno"> 9904</span>&#160;</div><div class="line"><a name="l09905"></a><span class="lineno"> 9905</span>&#160;* `void soap_set_dime(struct soap *soap)` </div><div class="line"><a name="l09906"></a><span class="lineno"> 9906</span>&#160;  This function must be called first to initialize DIME attachment send operations (receives are automatic).</div><div class="line"><a name="l09907"></a><span class="lineno"> 9907</span>&#160;</div><div class="line"><a name="l09908"></a><span class="lineno"> 9908</span>&#160;* `int soap_set_dime_attachment(struct soap *soap, char *ptr, size_t size, const char *type, const char *id, unsigned short optype, const char *option)` </div><div class="line"><a name="l09909"></a><span class="lineno"> 9909</span>&#160;  This function adds a new attachment to the list of attachments, where `ptr` and `size` refer to the block of memory that holds the attachment data (except when DIME streaming callback handlers are used as described in Section \ref DIMEstreaming . The `type` string parameter is the MIME type of the data. The `id` string parameter is the content ID of the DIME attachment. The `option` string parameter holds optional text (gSOAP supports DIME options, but it can send only one) and `optype` is a user-defined option type (as per DIME option specification format). All parameter values are copied, except `ptr`.</div><div class="line"><a name="l09910"></a><span class="lineno"> 9910</span>&#160;The value `SOAP_OK` is returned when the attachment was added. Otherwise a gSOAP error code is returned.</div><div class="line"><a name="l09911"></a><span class="lineno"> 9911</span>&#160;</div><div class="line"><a name="l09912"></a><span class="lineno"> 9912</span>&#160;* `void soap_clr_dime(struct soap *soap)` </div><div class="line"><a name="l09913"></a><span class="lineno"> 9913</span>&#160;  Disables DIME attachments, unless the serialized SOAP message contains attachments for transmission.</div><div class="line"><a name="l09914"></a><span class="lineno"> 9914</span>&#160;</div><div class="line"><a name="l09915"></a><span class="lineno"> 9915</span>&#160;These functions allow DIME attachments to be added without requiring message</div><div class="line"><a name="l09916"></a><span class="lineno"> 9916</span>&#160;body references. This is also referred to as the open DIME attachment style.</div><div class="line"><a name="l09917"></a><span class="lineno"> 9917</span>&#160;The closed attachment style requires all DIME attachments to be referenced from</div><div class="line"><a name="l09918"></a><span class="lineno"> 9918</span>&#160;the SOAP message body with *`href`* (or similar) references. For the closed</div><div class="line"><a name="l09919"></a><span class="lineno"> 9919</span>&#160;style, gSOAP supports an automatic binary data serialization method, see</div><div class="line"><a name="l09920"></a><span class="lineno"> 9920</span>&#160;Section \ref DIMEbinary .</div><div class="line"><a name="l09921"></a><span class="lineno"> 9921</span>&#160;</div><div class="line"><a name="l09922"></a><span class="lineno"> 9922</span>&#160;## Retrieving a Collection of DIME Attachments</div><div class="line"><a name="l09923"></a><span class="lineno"> 9923</span>&#160;</div><div class="line"><a name="l09924"></a><span class="lineno"> 9924</span>&#160;DIME attachments are automatically parsed and stored in memory (or passed to</div><div class="line"><a name="l09925"></a><span class="lineno"> 9925</span>&#160;the streaming handlers, when applicable).  After receiving a set of DIME</div><div class="line"><a name="l09926"></a><span class="lineno"> 9926</span>&#160;attachments, either at the client-side or the server-side, the list of DIME</div><div class="line"><a name="l09927"></a><span class="lineno"> 9927</span>&#160;attachments can be traversed to extract meta data and the attachment content.</div><div class="line"><a name="l09928"></a><span class="lineno"> 9928</span>&#160;</div><div class="line"><a name="l09929"></a><span class="lineno"> 9929</span>&#160;To traverse the list of DIME attachments in C, you use a loop similar to:</div><div class="line"><a name="l09930"></a><span class="lineno"> 9930</span>&#160;</div><div class="line"><a name="l09931"></a><span class="lineno"> 9931</span>&#160;```cpp</div><div class="line"><a name="l09932"></a><span class="lineno"> 9932</span>&#160;struct soap_multipart *attachment; </div><div class="line"><a name="l09933"></a><span class="lineno"> 9933</span>&#160;for (attachment = soap.dime.list; attachment; attachment = attachment-&gt;next) </div><div class="line"><a name="l09934"></a><span class="lineno"> 9934</span>&#160;{ </div><div class="line"><a name="l09935"></a><span class="lineno"> 9935</span>&#160;   printf(&quot;DIME attachment:\n&quot;); </div><div class="line"><a name="l09936"></a><span class="lineno"> 9936</span>&#160;   printf(&quot;Memory=%p\n&quot;, (*attachment).ptr); </div><div class="line"><a name="l09937"></a><span class="lineno"> 9937</span>&#160;   printf(&quot;Size=%ul\n&quot;, (*attachment).size); </div><div class="line"><a name="l09938"></a><span class="lineno"> 9938</span>&#160;   printf(&quot;Type=%s\n&quot;, (*attachment).type?(*attachment).type:&quot;null&quot;); </div><div class="line"><a name="l09939"></a><span class="lineno"> 9939</span>&#160;   printf(&quot;ID=%s\n&quot;, (*attachment).id?(*attachment).id:&quot;null&quot;); </div><div class="line"><a name="l09940"></a><span class="lineno"> 9940</span>&#160;}</div><div class="line"><a name="l09941"></a><span class="lineno"> 9941</span>&#160;```</div><div class="line"><a name="l09942"></a><span class="lineno"> 9942</span>&#160;</div><div class="line"><a name="l09943"></a><span class="lineno"> 9943</span>&#160;C++ programmers can use an iterator instead, as in:</div><div class="line"><a name="l09944"></a><span class="lineno"> 9944</span>&#160;</div><div class="line"><a name="l09945"></a><span class="lineno"> 9945</span>&#160;```cpp</div><div class="line"><a name="l09946"></a><span class="lineno"> 9946</span>&#160;for (soap_multipart::iterator attachment = soap.dime.begin(); attachment != soap.dime.end(); ++attachment) </div><div class="line"><a name="l09947"></a><span class="lineno"> 9947</span>&#160;{ </div><div class="line"><a name="l09948"></a><span class="lineno"> 9948</span>&#160;   cout &lt;&lt; &quot;DIME attachment:&quot; &lt;&lt; endl; </div><div class="line"><a name="l09949"></a><span class="lineno"> 9949</span>&#160;   cout &lt;&lt; &quot;Memory=&quot; &lt;&lt; (void*)(*attachment).ptr &lt;&lt; endl; </div><div class="line"><a name="l09950"></a><span class="lineno"> 9950</span>&#160;   cout &lt;&lt; &quot;Size=&quot; &lt;&lt; (*attachment).size &lt;&lt; endl; </div><div class="line"><a name="l09951"></a><span class="lineno"> 9951</span>&#160;   cout &lt;&lt; &quot;Type=&quot; &lt;&lt; ((*attachment).type?(*attachment).type:&quot;null&quot;) &lt;&lt; endl; </div><div class="line"><a name="l09952"></a><span class="lineno"> 9952</span>&#160;   cout &lt;&lt; &quot;ID=&quot; &lt;&lt; ((*attachment).id?(*attachment).id:&quot;null&quot;) &lt;&lt; endl; </div><div class="line"><a name="l09953"></a><span class="lineno"> 9953</span>&#160;}</div><div class="line"><a name="l09954"></a><span class="lineno"> 9954</span>&#160;```</div><div class="line"><a name="l09955"></a><span class="lineno"> 9955</span>&#160;</div><div class="line"><a name="l09956"></a><span class="lineno"> 9956</span>&#160;The `options` field is available as well. The `options` content is</div><div class="line"><a name="l09957"></a><span class="lineno"> 9957</span>&#160;formatted according to the DIME specification: the first two bytes are reserved</div><div class="line"><a name="l09958"></a><span class="lineno"> 9958</span>&#160;for the option type, the next two bytes store the size of the option data,</div><div class="line"><a name="l09959"></a><span class="lineno"> 9959</span>&#160;followed by the (binary) option data.</div><div class="line"><a name="l09960"></a><span class="lineno"> 9960</span>&#160;</div><div class="line"><a name="l09961"></a><span class="lineno"> 9961</span>&#160;A call to `soap_end` removes all of the received DIME data. To preserve an</div><div class="line"><a name="l09962"></a><span class="lineno"> 9962</span>&#160;attachment in memory, use `soap_unlink` on the `ptr` field of the</div><div class="line"><a name="l09963"></a><span class="lineno"> 9963</span>&#160;`soap_multipart` struct. Recall that the `soap_unlink` function is</div><div class="line"><a name="l09964"></a><span class="lineno"> 9964</span>&#160;commonly used to prevent deallocation of deserialized data.</div><div class="line"><a name="l09965"></a><span class="lineno"> 9965</span>&#160;</div><div class="line"><a name="l09966"></a><span class="lineno"> 9966</span>&#160;## Serializing Binary Data in DIME        {#DIMEbinary}</div><div class="line"><a name="l09967"></a><span class="lineno"> 9967</span>&#160;</div><div class="line"><a name="l09968"></a><span class="lineno"> 9968</span>&#160;Binary data stored in extended *`xsd:base64Binary`* and *`xsd:hexBinary`*</div><div class="line"><a name="l09969"></a><span class="lineno"> 9969</span>&#160;types can be serialized and deserialized as DIME attachments. These attachments</div><div class="line"><a name="l09970"></a><span class="lineno"> 9970</span>&#160;will be transmitted prior to the sequence of secondary DIME attachments defined</div><div class="line"><a name="l09971"></a><span class="lineno"> 9971</span>&#160;by the user with `soap_set_dime_attachment` as explained in the</div><div class="line"><a name="l09972"></a><span class="lineno"> 9972</span>&#160;previous section. The serialization process is automated for SOAP encoded</div><div class="line"><a name="l09973"></a><span class="lineno"> 9973</span>&#160;messages and DIME attachments will be send even when `soap_set_dime` or</div><div class="line"><a name="l09974"></a><span class="lineno"> 9974</span>&#160;`soap_set_dime_attachment` are not used.  For non-SOAP-encoded messages</div><div class="line"><a name="l09975"></a><span class="lineno"> 9975</span>&#160;such as document/literal messages you must still call `soap_set_dime` to</div><div class="line"><a name="l09976"></a><span class="lineno"> 9976</span>&#160;enable sending messages with attachments.</div><div class="line"><a name="l09977"></a><span class="lineno"> 9977</span>&#160;</div><div class="line"><a name="l09978"></a><span class="lineno"> 9978</span>&#160;The *`xsd:base64Binary`* XSD type is defined in gSOAP as a struct or class by</div><div class="line"><a name="l09979"></a><span class="lineno"> 9979</span>&#160;</div><div class="line"><a name="l09980"></a><span class="lineno"> 9980</span>&#160;```cpp</div><div class="line"><a name="l09981"></a><span class="lineno"> 9981</span>&#160;struct xsd__base64Binary </div><div class="line"><a name="l09982"></a><span class="lineno"> 9982</span>&#160;{ </div><div class="line"><a name="l09983"></a><span class="lineno"> 9983</span>&#160;   unsigned char *__ptr; // pointer to raw binary data </div><div class="line"><a name="l09984"></a><span class="lineno"> 9984</span>&#160;   int __size; // size of the block of data </div><div class="line"><a name="l09985"></a><span class="lineno"> 9985</span>&#160;};</div><div class="line"><a name="l09986"></a><span class="lineno"> 9986</span>&#160;```</div><div class="line"><a name="l09987"></a><span class="lineno"> 9987</span>&#160;</div><div class="line"><a name="l09988"></a><span class="lineno"> 9988</span>&#160;To enable serialization of the data in DIME, we extend this type with three</div><div class="line"><a name="l09989"></a><span class="lineno"> 9989</span>&#160;additional fields:</div><div class="line"><a name="l09990"></a><span class="lineno"> 9990</span>&#160;</div><div class="line"><a name="l09991"></a><span class="lineno"> 9991</span>&#160;```cpp</div><div class="line"><a name="l09992"></a><span class="lineno"> 9992</span>&#160;struct xsd__base64Binary </div><div class="line"><a name="l09993"></a><span class="lineno"> 9993</span>&#160;{ </div><div class="line"><a name="l09994"></a><span class="lineno"> 9994</span>&#160;   unsigned char *__ptr; </div><div class="line"><a name="l09995"></a><span class="lineno"> 9995</span>&#160;   int __size; </div><div class="line"><a name="l09996"></a><span class="lineno"> 9996</span>&#160;   char *id; </div><div class="line"><a name="l09997"></a><span class="lineno"> 9997</span>&#160;   char *type; </div><div class="line"><a name="l09998"></a><span class="lineno"> 9998</span>&#160;   char *options; </div><div class="line"><a name="l09999"></a><span class="lineno"> 9999</span>&#160;};</div><div class="line"><a name="l10000"></a><span class="lineno">10000</span>&#160;```</div><div class="line"><a name="l10001"></a><span class="lineno">10001</span>&#160;</div><div class="line"><a name="l10002"></a><span class="lineno">10002</span>&#160;The three additional fields consist of an `id` field for attachment</div><div class="line"><a name="l10003"></a><span class="lineno">10003</span>&#160;referencing (typically a content id (CID) or UUID), a `type` field to</div><div class="line"><a name="l10004"></a><span class="lineno">10004</span>&#160;specify the MIME type of the binary data, and an `options` field to</div><div class="line"><a name="l10005"></a><span class="lineno">10005</span>&#160;piggy-back additional information with a DIME attachment.  The order of the</div><div class="line"><a name="l10006"></a><span class="lineno">10006</span>&#160;declaration of the fields is significant. In addition, no other fields or</div><div class="line"><a name="l10007"></a><span class="lineno">10007</span>&#160;methods may be declared before any of these fields in the struct/class, but</div><div class="line"><a name="l10008"></a><span class="lineno">10008</span>&#160;additional fields and methods may appear after the field declarations. An</div><div class="line"><a name="l10009"></a><span class="lineno">10009</span>&#160;extended `xsd__hexBinary` declaration is similar.</div><div class="line"><a name="l10010"></a><span class="lineno">10010</span>&#160;</div><div class="line"><a name="l10011"></a><span class="lineno">10011</span>&#160;The `id` and `type` fields contain text. The set the DIME-specific</div><div class="line"><a name="l10012"></a><span class="lineno">10012</span>&#160;options field, you can use the `soap_dime_option` function:</div><div class="line"><a name="l10013"></a><span class="lineno">10013</span>&#160;</div><div class="line"><a name="l10014"></a><span class="lineno">10014</span>&#160;```cpp</div><div class="line"><a name="l10015"></a><span class="lineno">10015</span>&#160;char *soap_dime_option(struct soap *soap, unsigned short type, const char *option)</div><div class="line"><a name="l10016"></a><span class="lineno">10016</span>&#160;```</div><div class="line"><a name="l10017"></a><span class="lineno">10017</span>&#160;</div><div class="line"><a name="l10018"></a><span class="lineno">10018</span>&#160;returns a string with this encoding. For example</div><div class="line"><a name="l10019"></a><span class="lineno">10019</span>&#160;</div><div class="line"><a name="l10020"></a><span class="lineno">10020</span>&#160;```cpp</div><div class="line"><a name="l10021"></a><span class="lineno">10021</span>&#160;struct xsd__base64Binary image; </div><div class="line"><a name="l10022"></a><span class="lineno">10022</span>&#160;image.__ptr = ...; </div><div class="line"><a name="l10023"></a><span class="lineno">10023</span>&#160;image.__size = ...; </div><div class="line"><a name="l10024"></a><span class="lineno">10024</span>&#160;image.id = &quot;uuid:09233523-345b-4351-b623-5dsf35sgs5d6&quot;; </div><div class="line"><a name="l10025"></a><span class="lineno">10025</span>&#160;image.type = &quot;image/jpeg&quot;; </div><div class="line"><a name="l10026"></a><span class="lineno">10026</span>&#160;image.options = soap_dime_option(soap, 0, &quot;My wedding picture&quot;);</div><div class="line"><a name="l10027"></a><span class="lineno">10027</span>&#160;```</div><div class="line"><a name="l10028"></a><span class="lineno">10028</span>&#160;</div><div class="line"><a name="l10029"></a><span class="lineno">10029</span>&#160;When either the `id` or `type` field values are non-NULL at run time,</div><div class="line"><a name="l10030"></a><span class="lineno">10030</span>&#160;the data will be serialized as a DIME attachment. The SOAP/XML message refers</div><div class="line"><a name="l10031"></a><span class="lineno">10031</span>&#160;to the attachments using *`href`* attributes. This generally works will with</div><div class="line"><a name="l10032"></a><span class="lineno">10032</span>&#160;SOAP RPC, because *`href`* attributes are permitted. However, with document/literal style the referencing mechanism must be explicitly defined</div><div class="line"><a name="l10033"></a><span class="lineno">10033</span>&#160;in the schema of the binary type. The gSOAP</div><div class="line"><a name="l10034"></a><span class="lineno">10034</span>&#160;declaration of an extended binary type is</div><div class="line"><a name="l10035"></a><span class="lineno">10035</span>&#160;</div><div class="line"><a name="l10036"></a><span class="lineno">10036</span>&#160;```cpp</div><div class="line"><a name="l10037"></a><span class="lineno">10037</span>&#160;struct ns__myBinaryDataType </div><div class="line"><a name="l10038"></a><span class="lineno">10038</span>&#160;{ </div><div class="line"><a name="l10039"></a><span class="lineno">10039</span>&#160;   unsigned char *__ptr; </div><div class="line"><a name="l10040"></a><span class="lineno">10040</span>&#160;   int __size; </div><div class="line"><a name="l10041"></a><span class="lineno">10041</span>&#160;   char *id; </div><div class="line"><a name="l10042"></a><span class="lineno">10042</span>&#160;   char *type; </div><div class="line"><a name="l10043"></a><span class="lineno">10043</span>&#160;   char *options; </div><div class="line"><a name="l10044"></a><span class="lineno">10044</span>&#160;};</div><div class="line"><a name="l10045"></a><span class="lineno">10045</span>&#160;```</div><div class="line"><a name="l10046"></a><span class="lineno">10046</span>&#160;</div><div class="line"><a name="l10047"></a><span class="lineno">10047</span>&#160;C++ programmers can use inheritance instead of textual extension required in C, as in</div><div class="line"><a name="l10048"></a><span class="lineno">10048</span>&#160;</div><div class="line"><a name="l10049"></a><span class="lineno">10049</span>&#160;```cpp</div><div class="line"><a name="l10050"></a><span class="lineno">10050</span>&#160;class xsd__base64Binary </div><div class="line"><a name="l10051"></a><span class="lineno">10051</span>&#160;{ </div><div class="line"><a name="l10052"></a><span class="lineno">10052</span>&#160;   unsigned char *__ptr; </div><div class="line"><a name="l10053"></a><span class="lineno">10053</span>&#160;   int __size; </div><div class="line"><a name="l10054"></a><span class="lineno">10054</span>&#160;}; </div><div class="line"><a name="l10055"></a><span class="lineno">10055</span>&#160;class ns__myBinaryDataType : xsd__base64Binary </div><div class="line"><a name="l10056"></a><span class="lineno">10056</span>&#160;{ </div><div class="line"><a name="l10057"></a><span class="lineno">10057</span>&#160;   char *id; </div><div class="line"><a name="l10058"></a><span class="lineno">10058</span>&#160;   char *type; </div><div class="line"><a name="l10059"></a><span class="lineno">10059</span>&#160;   char *options; </div><div class="line"><a name="l10060"></a><span class="lineno">10060</span>&#160;};</div><div class="line"><a name="l10061"></a><span class="lineno">10061</span>&#160;```</div><div class="line"><a name="l10062"></a><span class="lineno">10062</span>&#160;</div><div class="line"><a name="l10063"></a><span class="lineno">10063</span>&#160;This defines an extension of *`xsd:base64Binary`*, such that the data can be </div><div class="line"><a name="l10064"></a><span class="lineno">10064</span>&#160;serialized as DIME attachments using *`href`* attributes for referencing.</div><div class="line"><a name="l10065"></a><span class="lineno">10065</span>&#160;When a different attribute name is in fact used, it must be explicitly defined:</div><div class="line"><a name="l10066"></a><span class="lineno">10066</span>&#160;</div><div class="line"><a name="l10067"></a><span class="lineno">10067</span>&#160;```cpp</div><div class="line"><a name="l10068"></a><span class="lineno">10068</span>&#160;//gsoap WSref schema import: http://schemas.xmlsoap.org/ws/2002/04/reference/ </div><div class="line"><a name="l10069"></a><span class="lineno">10069</span>&#160;struct ns__myBinaryDataType </div><div class="line"><a name="l10070"></a><span class="lineno">10070</span>&#160;{ </div><div class="line"><a name="l10071"></a><span class="lineno">10071</span>&#160;  unsigned char *__ptr; </div><div class="line"><a name="l10072"></a><span class="lineno">10072</span>&#160;  int __size; </div><div class="line"><a name="l10073"></a><span class="lineno">10073</span>&#160;  char *id; </div><div class="line"><a name="l10074"></a><span class="lineno">10074</span>&#160;  char *type; </div><div class="line"><a name="l10075"></a><span class="lineno">10075</span>&#160;  char *options; </div><div class="line"><a name="l10076"></a><span class="lineno">10076</span>&#160;  @ char *WSref__location; </div><div class="line"><a name="l10077"></a><span class="lineno">10077</span>&#160;};</div><div class="line"><a name="l10078"></a><span class="lineno">10078</span>&#160;```</div><div class="line"><a name="l10079"></a><span class="lineno">10079</span>&#160;</div><div class="line"><a name="l10080"></a><span class="lineno">10080</span>&#160;The example above uses the *`location`* attribute defined in the content reference schema, as defined in one of the vendor&#39;s specific WSDL extensions for DIME (http://www.gotdotnet.com/team/xml_wsspecs/dime/WSDL-Extension-for-DIME.htm).</div><div class="line"><a name="l10081"></a><span class="lineno">10081</span>&#160;</div><div class="line"><a name="l10082"></a><span class="lineno">10082</span>&#160;When receiving DIME attachments, the DIME meta data and binary data content is</div><div class="line"><a name="l10083"></a><span class="lineno">10083</span>&#160;stored in binary data types only when the XML parts of the message uses</div><div class="line"><a name="l10084"></a><span class="lineno">10084</span>&#160;*`href`* attributes to refer to these attachments. The gSOAP toolkit may</div><div class="line"><a name="l10085"></a><span class="lineno">10085</span>&#160;support automatic (de)serialization with other user-defined (or WSDL-defined)</div><div class="line"><a name="l10086"></a><span class="lineno">10086</span>&#160;attributes in future releases.</div><div class="line"><a name="l10087"></a><span class="lineno">10087</span>&#160;</div><div class="line"><a name="l10088"></a><span class="lineno">10088</span>&#160;Messages may contain binary data that references external resources not</div><div class="line"><a name="l10089"></a><span class="lineno">10089</span>&#160;provided as attachments. In that case, the `__ptr` field is NULL and the</div><div class="line"><a name="l10090"></a><span class="lineno">10090</span>&#160;`id` field refers to the external data source.</div><div class="line"><a name="l10091"></a><span class="lineno">10091</span>&#160;</div><div class="line"><a name="l10092"></a><span class="lineno">10092</span>&#160;The `dime_id_format` attribute of the current gSOAP run-time context</div><div class="line"><a name="l10093"></a><span class="lineno">10093</span>&#160;can be set to the default format of DIME id fields.  The format string MUST</div><div class="line"><a name="l10094"></a><span class="lineno">10094</span>&#160;contain a `%d` format specifier (or any other `int`-based format</div><div class="line"><a name="l10095"></a><span class="lineno">10095</span>&#160;specifier). The value of this specifier is a non-negative integer, with zero</div><div class="line"><a name="l10096"></a><span class="lineno">10096</span>&#160;being the value of the DIME attachment id for the SOAP message.  For example,</div><div class="line"><a name="l10097"></a><span class="lineno">10097</span>&#160;</div><div class="line"><a name="l10098"></a><span class="lineno">10098</span>&#160;```cpp</div><div class="line"><a name="l10099"></a><span class="lineno">10099</span>&#160;struct soap soap;</div><div class="line"><a name="l10100"></a><span class="lineno">10100</span>&#160;soap_init(&amp;soap); </div><div class="line"><a name="l10101"></a><span class="lineno">10101</span>&#160;soap.dime_id_format = &quot;uuid:09233523-345b-4351-b623-5dsf35sgs5d6-%x&quot;; </div><div class="line"><a name="l10102"></a><span class="lineno">10102</span>&#160;```</div><div class="line"><a name="l10103"></a><span class="lineno">10103</span>&#160;</div><div class="line"><a name="l10104"></a><span class="lineno">10104</span>&#160;As a result, all attachments with a NULL `id` field will use a</div><div class="line"><a name="l10105"></a><span class="lineno">10105</span>&#160;gSOAP-generated id value based on the format string.</div><div class="line"><a name="l10106"></a><span class="lineno">10106</span>&#160;</div><div class="line"><a name="l10107"></a><span class="lineno">10107</span>&#160;@warning Care must be taken not to introduce duplicate content id values,</div><div class="line"><a name="l10108"></a><span class="lineno">10108</span>&#160;when assigning content id values to the id fields of DIME extended binary data</div><div class="line"><a name="l10109"></a><span class="lineno">10109</span>&#160;types. Content ids must be unique.</div><div class="line"><a name="l10110"></a><span class="lineno">10110</span>&#160;</div><div class="line"><a name="l10111"></a><span class="lineno">10111</span>&#160;## Streaming DIME        {#DIMEstreaming}</div><div class="line"><a name="l10112"></a><span class="lineno">10112</span>&#160;</div><div class="line"><a name="l10113"></a><span class="lineno">10113</span>&#160;Streaming DIME is achieved with callback functions to fetch and store data</div><div class="line"><a name="l10114"></a><span class="lineno">10114</span>&#160;during transmission.  Three function callbacks for streaming DIME output and</div><div class="line"><a name="l10115"></a><span class="lineno">10115</span>&#160;three callbacks for streaming DIME input are available.</div><div class="line"><a name="l10116"></a><span class="lineno">10116</span>&#160;</div><div class="line"><a name="l10117"></a><span class="lineno">10117</span>&#160;* `void *(*soap.fdimereadopen)(struct soap *soap, void *handle, const char *id, const char *type, const char *options)` </div><div class="line"><a name="l10118"></a><span class="lineno">10118</span>&#160;  Called by the gSOAP run-time DIME attachment sender to start reading from a</div><div class="line"><a name="l10119"></a><span class="lineno">10119</span>&#160;  (binary) data source for outbound transmission. The content will be read from</div><div class="line"><a name="l10120"></a><span class="lineno">10120</span>&#160;  the application&#39;s data source in chunks using the `fdimeread` callback and</div><div class="line"><a name="l10121"></a><span class="lineno">10121</span>&#160;  streamed into the SOAP/XML/DIME output stream. The `handle` contains the</div><div class="line"><a name="l10122"></a><span class="lineno">10122</span>&#160;  value of the `__ptr` field of an attachment struct/class, which could be a</div><div class="line"><a name="l10123"></a><span class="lineno">10123</span>&#160;  pointer to specific information such as a file descriptor or a pointer to a</div><div class="line"><a name="l10124"></a><span class="lineno">10124</span>&#160;  string to be passed to this callback.  Both `__ptr` and `__size` fields</div><div class="line"><a name="l10125"></a><span class="lineno">10125</span>&#160;  should have been set by the application prior to the serialization of the</div><div class="line"><a name="l10126"></a><span class="lineno">10126</span>&#160;  content. The `id`, `type`, and `options` arguments are the DIME id, type, and</div><div class="line"><a name="l10127"></a><span class="lineno">10127</span>&#160;  options, respectively. The callback should return `handle`, or another</div><div class="line"><a name="l10128"></a><span class="lineno">10128</span>&#160;  pointer value which will be passed as a handle to `fdimeread` and</div><div class="line"><a name="l10129"></a><span class="lineno">10129</span>&#160;  `fdimereadclose`.  The callback should return NULL and set `soap-&gt;error`</div><div class="line"><a name="l10130"></a><span class="lineno">10130</span>&#160;  when an error occurred. The callback should return NULL (and not set</div><div class="line"><a name="l10131"></a><span class="lineno">10131</span>&#160;  `soap-&gt;error`) when this particular DIME attachment is not to be streamed.</div><div class="line"><a name="l10132"></a><span class="lineno">10132</span>&#160;</div><div class="line"><a name="l10133"></a><span class="lineno">10133</span>&#160;* `size_t (*soap.fdimeread)(struct soap *soap, void *handle, char *buf, size_t len)` </div><div class="line"><a name="l10134"></a><span class="lineno">10134</span>&#160;  Called by the gSOAP run-time DIME attachment sender to read more data from a</div><div class="line"><a name="l10135"></a><span class="lineno">10135</span>&#160;  (binary) data source for streaming into the output stream.  The `handle`</div><div class="line"><a name="l10136"></a><span class="lineno">10136</span>&#160;  contains the value returned by the `fdimereadopen` callback.  The `buf`</div><div class="line"><a name="l10137"></a><span class="lineno">10137</span>&#160;  argument is the buffer of length `len` into which a chunk of data should be</div><div class="line"><a name="l10138"></a><span class="lineno">10138</span>&#160;  stored.  The actual amount of data stored in the buffer may be less than</div><div class="line"><a name="l10139"></a><span class="lineno">10139</span>&#160;  `len` and this amount should be returned by the application.  A return value</div><div class="line"><a name="l10140"></a><span class="lineno">10140</span>&#160;  of 0 indicates an error (the callback may set `soap-&gt;errnum` to errno).</div><div class="line"><a name="l10141"></a><span class="lineno">10141</span>&#160;  The `__size` field of the attachment struct/class should have been set by the</div><div class="line"><a name="l10142"></a><span class="lineno">10142</span>&#160;  application prior to the serialization of the content.  The value of `__size`</div><div class="line"><a name="l10143"></a><span class="lineno">10143</span>&#160;  indicates the total size of the content to be transmitted.  When the `__size`</div><div class="line"><a name="l10144"></a><span class="lineno">10144</span>&#160;  is zero then DIME chunked transfers can be used under certain circumstances</div><div class="line"><a name="l10145"></a><span class="lineno">10145</span>&#160;  to stream content without prior determination of attachment size, see Section</div><div class="line"><a name="l10146"></a><span class="lineno">10146</span>&#160;  \ref dimechunking  below.</div><div class="line"><a name="l10147"></a><span class="lineno">10147</span>&#160;</div><div class="line"><a name="l10148"></a><span class="lineno">10148</span>&#160;* `void (*soap.fdimereadclose)(struct soap *soap, void *handle)` </div><div class="line"><a name="l10149"></a><span class="lineno">10149</span>&#160;  Called by the gSOAP run-time DIME attachment sender at the end of the</div><div class="line"><a name="l10150"></a><span class="lineno">10150</span>&#160;  streaming process to close the data source.  The `handle` contains the value</div><div class="line"><a name="l10151"></a><span class="lineno">10151</span>&#160;  returned by the `fdimereadopen` callback.  The `fdimewriteclose` callback is</div><div class="line"><a name="l10152"></a><span class="lineno">10152</span>&#160;  called after successfully transmitting the data or when an error occurred.</div><div class="line"><a name="l10153"></a><span class="lineno">10153</span>&#160;</div><div class="line"><a name="l10154"></a><span class="lineno">10154</span>&#160;* `void *(*soap.fdimewriteopen)(struct soap *soap, const char *id, const char *type, const char *options)` </div><div class="line"><a name="l10155"></a><span class="lineno">10155</span>&#160;  Called by the gSOAP run-time DIME attachment receiver to start writing an</div><div class="line"><a name="l10156"></a><span class="lineno">10156</span>&#160;  inbound DIME attachment to an application&#39;s data store. The content is</div><div class="line"><a name="l10157"></a><span class="lineno">10157</span>&#160;  streamed into an application data store through multiple `fdimewrite` calls</div><div class="line"><a name="l10158"></a><span class="lineno">10158</span>&#160;  from the gSOAP attachment receiver.  The `id`, `type`, and `options`</div><div class="line"><a name="l10159"></a><span class="lineno">10159</span>&#160;  arguments are the DIME id, type, and options respectively. The callback</div><div class="line"><a name="l10160"></a><span class="lineno">10160</span>&#160;  should return a handle which is passed to the `fdimewrite` and</div><div class="line"><a name="l10161"></a><span class="lineno">10161</span>&#160;  `fdimewriteclose` callbacks. The `__ptr` field of the attachment struct/class</div><div class="line"><a name="l10162"></a><span class="lineno">10162</span>&#160;  is set to the value of this handle. The `__size` field is set to the total</div><div class="line"><a name="l10163"></a><span class="lineno">10163</span>&#160;  size of the attachment after receiving the entire content. The size is</div><div class="line"><a name="l10164"></a><span class="lineno">10164</span>&#160;  unknown in advance because DIME attachments may be chunked.</div><div class="line"><a name="l10165"></a><span class="lineno">10165</span>&#160;</div><div class="line"><a name="l10166"></a><span class="lineno">10166</span>&#160;* `int (*soap.fdimewrite)(struct soap *soap, void *handle, const char *buf, size_t len)` </div><div class="line"><a name="l10167"></a><span class="lineno">10167</span>&#160;  Called by the gSOAP run-time DIME attachment receiver to write part of an</div><div class="line"><a name="l10168"></a><span class="lineno">10168</span>&#160;  inbound DIME attachment to an application&#39;s data store.  The `handle`</div><div class="line"><a name="l10169"></a><span class="lineno">10169</span>&#160;  contains the value returned by the `fdimewriteopen` callback.  The `buf`</div><div class="line"><a name="l10170"></a><span class="lineno">10170</span>&#160;  argument contains the data of length `len`.  The callback should return a</div><div class="line"><a name="l10171"></a><span class="lineno">10171</span>&#160;  gSOAP error code (e.g. `SOAP_OK` when no error occurred).</div><div class="line"><a name="l10172"></a><span class="lineno">10172</span>&#160;</div><div class="line"><a name="l10173"></a><span class="lineno">10173</span>&#160;* `void (*soap.fdimewriteclose)(struct soap *soap, void *handle)` </div><div class="line"><a name="l10174"></a><span class="lineno">10174</span>&#160;  Called by the gSOAP run-time DIME attachment receiver at the end of the</div><div class="line"><a name="l10175"></a><span class="lineno">10175</span>&#160;  streaming process to close the data store.  The `fdimewriteclose` callback is</div><div class="line"><a name="l10176"></a><span class="lineno">10176</span>&#160;  called after successfully receiving the data or when an error occurred.  The</div><div class="line"><a name="l10177"></a><span class="lineno">10177</span>&#160;  `handle` contains the value returned by the `fdimewriteopen` callback.</div><div class="line"><a name="l10178"></a><span class="lineno">10178</span>&#160;</div><div class="line"><a name="l10179"></a><span class="lineno">10179</span>&#160;In addition, a `void*user` field in the `struct soap` data structure</div><div class="line"><a name="l10180"></a><span class="lineno">10180</span>&#160;is available to pass user-defined data to the callbacks.  This way, you can set</div><div class="line"><a name="l10181"></a><span class="lineno">10181</span>&#160;`soap.user` to point to application data that the callbacks need such as a</div><div class="line"><a name="l10182"></a><span class="lineno">10182</span>&#160;file name for example.</div><div class="line"><a name="l10183"></a><span class="lineno">10183</span>&#160;</div><div class="line"><a name="l10184"></a><span class="lineno">10184</span>&#160;The following example illustrates the client-side initialization of an image</div><div class="line"><a name="l10185"></a><span class="lineno">10185</span>&#160;attachment struct to stream a file into a DIME attachment:</div><div class="line"><a name="l10186"></a><span class="lineno">10186</span>&#160;</div><div class="line"><a name="l10187"></a><span class="lineno">10187</span>&#160;```cpp</div><div class="line"><a name="l10188"></a><span class="lineno">10188</span>&#160;int main() </div><div class="line"><a name="l10189"></a><span class="lineno">10189</span>&#160;{ </div><div class="line"><a name="l10190"></a><span class="lineno">10190</span>&#160;   struct soap soap; </div><div class="line"><a name="l10191"></a><span class="lineno">10191</span>&#160;   struct xsd__base64Binary image; </div><div class="line"><a name="l10192"></a><span class="lineno">10192</span>&#160;   FILE *fd; </div><div class="line"><a name="l10193"></a><span class="lineno">10193</span>&#160;   struct stat sb; </div><div class="line"><a name="l10194"></a><span class="lineno">10194</span>&#160;   soap_init(&amp;soap); </div><div class="line"><a name="l10195"></a><span class="lineno">10195</span>&#160;   if (!fstat(fileno(fd), &amp;sb) &amp;&amp; sb.st_size &gt; 0) </div><div class="line"><a name="l10196"></a><span class="lineno">10196</span>&#160;   { // because we can get the length of the file, we can stream it </div><div class="line"><a name="l10197"></a><span class="lineno">10197</span>&#160;     soap.fdimereadopen = dime_read_open; </div><div class="line"><a name="l10198"></a><span class="lineno">10198</span>&#160;     soap.fdimereadclose = dime_read_close; </div><div class="line"><a name="l10199"></a><span class="lineno">10199</span>&#160;     soap.fdimeread = dime_read; </div><div class="line"><a name="l10200"></a><span class="lineno">10200</span>&#160;     image.__ptr = (unsigned char*)fd; // must set to non-NULL (this is our fd handle which we need in the callbacks) </div><div class="line"><a name="l10201"></a><span class="lineno">10201</span>&#160;     image.__size = sb.st_size; // must set size </div><div class="line"><a name="l10202"></a><span class="lineno">10202</span>&#160;   } </div><div class="line"><a name="l10203"></a><span class="lineno">10203</span>&#160;   else </div><div class="line"><a name="l10204"></a><span class="lineno">10204</span>&#160;   { // don&#39;t know the size, so buffer it </div><div class="line"><a name="l10205"></a><span class="lineno">10205</span>&#160;     size_t i; </div><div class="line"><a name="l10206"></a><span class="lineno">10206</span>&#160;     int c; </div><div class="line"><a name="l10207"></a><span class="lineno">10207</span>&#160;     image.__ptr = (unsigned char*)soap_malloc(&amp;soap, MAX_FILE_SIZE); </div><div class="line"><a name="l10208"></a><span class="lineno">10208</span>&#160;     for (i = 0; i &lt; MAX_FILE_SIZE; i++) </div><div class="line"><a name="l10209"></a><span class="lineno">10209</span>&#160;     { </div><div class="line"><a name="l10210"></a><span class="lineno">10210</span>&#160;       if ((c = fgetc(fd)) == EOF) </div><div class="line"><a name="l10211"></a><span class="lineno">10211</span>&#160;         break; </div><div class="line"><a name="l10212"></a><span class="lineno">10212</span>&#160;       image.__ptr[i] = c; </div><div class="line"><a name="l10213"></a><span class="lineno">10213</span>&#160;     } </div><div class="line"><a name="l10214"></a><span class="lineno">10214</span>&#160;     fclose(fd); </div><div class="line"><a name="l10215"></a><span class="lineno">10215</span>&#160;     image.__size = i; </div><div class="line"><a name="l10216"></a><span class="lineno">10216</span>&#160;   } </div><div class="line"><a name="l10217"></a><span class="lineno">10217</span>&#160;   image.type = &quot;image/jpeg&quot;; </div><div class="line"><a name="l10218"></a><span class="lineno">10218</span>&#160;   image.options = soap_dime_option(&amp;soap, 0, &quot;My picture&quot;); </div><div class="line"><a name="l10219"></a><span class="lineno">10219</span>&#160;   soap_call_ns__method(&amp;soap, ...); </div><div class="line"><a name="l10220"></a><span class="lineno">10220</span>&#160;   ... </div><div class="line"><a name="l10221"></a><span class="lineno">10221</span>&#160;} </div><div class="line"><a name="l10222"></a><span class="lineno">10222</span>&#160;void *dime_read_open(struct soap *soap, void *handle, const char *id, const char *type, const char *options) </div><div class="line"><a name="l10223"></a><span class="lineno">10223</span>&#160;{</div><div class="line"><a name="l10224"></a><span class="lineno">10224</span>&#160;  return handle; </div><div class="line"><a name="l10225"></a><span class="lineno">10225</span>&#160;} </div><div class="line"><a name="l10226"></a><span class="lineno">10226</span>&#160;void dime_read_close(struct soap *soap, void *handle) </div><div class="line"><a name="l10227"></a><span class="lineno">10227</span>&#160;{ fclose((FILE*)handle); </div><div class="line"><a name="l10228"></a><span class="lineno">10228</span>&#160;} </div><div class="line"><a name="l10229"></a><span class="lineno">10229</span>&#160;size_t dime_read(struct soap *soap, void *handle, char *buf, size_t len) </div><div class="line"><a name="l10230"></a><span class="lineno">10230</span>&#160;{ return fread(buf, 1, len, (FILE*)handle); </div><div class="line"><a name="l10231"></a><span class="lineno">10231</span>&#160;}</div><div class="line"><a name="l10232"></a><span class="lineno">10232</span>&#160;```</div><div class="line"><a name="l10233"></a><span class="lineno">10233</span>&#160;</div><div class="line"><a name="l10234"></a><span class="lineno">10234</span>&#160;The following example illustrates the streaming of a DIME attachment into a file by a client:</div><div class="line"><a name="l10235"></a><span class="lineno">10235</span>&#160;</div><div class="line"><a name="l10236"></a><span class="lineno">10236</span>&#160;```cpp</div><div class="line"><a name="l10237"></a><span class="lineno">10237</span>&#160;int main() </div><div class="line"><a name="l10238"></a><span class="lineno">10238</span>&#160;{ struct soap soap; </div><div class="line"><a name="l10239"></a><span class="lineno">10239</span>&#160;   soap_init(&amp;soap); </div><div class="line"><a name="l10240"></a><span class="lineno">10240</span>&#160;   soap.fdimewriteopen = dime_write_open; </div><div class="line"><a name="l10241"></a><span class="lineno">10241</span>&#160;   soap.fdimewriteclose = dime_write_close; </div><div class="line"><a name="l10242"></a><span class="lineno">10242</span>&#160;   soap.fdimewrite = dime_write; </div><div class="line"><a name="l10243"></a><span class="lineno">10243</span>&#160;   soap_call_ns__method(&amp;soap, ...); </div><div class="line"><a name="l10244"></a><span class="lineno">10244</span>&#160;   ... </div><div class="line"><a name="l10245"></a><span class="lineno">10245</span>&#160;} </div><div class="line"><a name="l10246"></a><span class="lineno">10246</span>&#160;void *dime_write_open(struct soap *soap, const char *id, const char *type, const char *options) </div><div class="line"><a name="l10247"></a><span class="lineno">10247</span>&#160;{ </div><div class="line"><a name="l10248"></a><span class="lineno">10248</span>&#160;   FILE *handle = fopen(&quot;somefile&quot;, &quot;wb&quot;); </div><div class="line"><a name="l10249"></a><span class="lineno">10249</span>&#160;   if (!handle) </div><div class="line"><a name="l10250"></a><span class="lineno">10250</span>&#160;   { </div><div class="line"><a name="l10251"></a><span class="lineno">10251</span>&#160;     soap-&gt;error = SOAP_EOF; </div><div class="line"><a name="l10252"></a><span class="lineno">10252</span>&#160;     soap-&gt;errnum = errno; // get reason </div><div class="line"><a name="l10253"></a><span class="lineno">10253</span>&#160;   } </div><div class="line"><a name="l10254"></a><span class="lineno">10254</span>&#160;   return (void*)handle; </div><div class="line"><a name="l10255"></a><span class="lineno">10255</span>&#160;} </div><div class="line"><a name="l10256"></a><span class="lineno">10256</span>&#160;void dime_write_close(struct soap *soap, void *handle) </div><div class="line"><a name="l10257"></a><span class="lineno">10257</span>&#160;{ fclose((FILE*)handle); </div><div class="line"><a name="l10258"></a><span class="lineno">10258</span>&#160;} </div><div class="line"><a name="l10259"></a><span class="lineno">10259</span>&#160;int dime_write(struct soap *soap, void *handle, const char *buf, size_t len) </div><div class="line"><a name="l10260"></a><span class="lineno">10260</span>&#160;{ </div><div class="line"><a name="l10261"></a><span class="lineno">10261</span>&#160;   size_t nwritten; </div><div class="line"><a name="l10262"></a><span class="lineno">10262</span>&#160;   while (len) </div><div class="line"><a name="l10263"></a><span class="lineno">10263</span>&#160;   { </div><div class="line"><a name="l10264"></a><span class="lineno">10264</span>&#160;     nwritten = fwrite(buf, 1, len, (FILE*)handle); </div><div class="line"><a name="l10265"></a><span class="lineno">10265</span>&#160;     if (!nwritten) </div><div class="line"><a name="l10266"></a><span class="lineno">10266</span>&#160;     { </div><div class="line"><a name="l10267"></a><span class="lineno">10267</span>&#160;       soap-&gt;errnum = errno; // get reason </div><div class="line"><a name="l10268"></a><span class="lineno">10268</span>&#160;       return SOAP_EOF; </div><div class="line"><a name="l10269"></a><span class="lineno">10269</span>&#160;     } </div><div class="line"><a name="l10270"></a><span class="lineno">10270</span>&#160;     len -= nwritten; </div><div class="line"><a name="l10271"></a><span class="lineno">10271</span>&#160;     buf += nwritten; </div><div class="line"><a name="l10272"></a><span class="lineno">10272</span>&#160;   } </div><div class="line"><a name="l10273"></a><span class="lineno">10273</span>&#160;   return SOAP_OK; </div><div class="line"><a name="l10274"></a><span class="lineno">10274</span>&#160;}</div><div class="line"><a name="l10275"></a><span class="lineno">10275</span>&#160;```</div><div class="line"><a name="l10276"></a><span class="lineno">10276</span>&#160;</div><div class="line"><a name="l10277"></a><span class="lineno">10277</span>&#160;Note that compression can be used with DIME to compress the entire message.</div><div class="line"><a name="l10278"></a><span class="lineno">10278</span>&#160;However, compression requires buffering to determine the HTTP content length</div><div class="line"><a name="l10279"></a><span class="lineno">10279</span>&#160;header, which cancels the benefits of streaming DIME. To avoid this, you should</div><div class="line"><a name="l10280"></a><span class="lineno">10280</span>&#160;use chunked HTTP (with the output-mode `SOAP_IO_CHUNK` flag) with</div><div class="line"><a name="l10281"></a><span class="lineno">10281</span>&#160;compression and streaming DIME. At the server side, when you set</div><div class="line"><a name="l10282"></a><span class="lineno">10282</span>&#160;`SOAP_IO_CHUNK` before calling `soap_serve`, gSOAP will</div><div class="line"><a name="l10283"></a><span class="lineno">10283</span>&#160;automatically revert to buffering (`SOAP_IO_STORE` flag is set).  You can</div><div class="line"><a name="l10284"></a><span class="lineno">10284</span>&#160;check this flag with `(soap-&gt;omode &amp; SOAP_IO) == SOAP_IO_CHUNK` to see</div><div class="line"><a name="l10285"></a><span class="lineno">10285</span>&#160;if the client accepts chunking. More information about streaming chunked DIME</div><div class="line"><a name="l10286"></a><span class="lineno">10286</span>&#160;can be found in Section \ref dimechunking .</div><div class="line"><a name="l10287"></a><span class="lineno">10287</span>&#160;</div><div class="line"><a name="l10288"></a><span class="lineno">10288</span>&#160;@warning The `options` field is a DIME-specific data structure,</div><div class="line"><a name="l10289"></a><span class="lineno">10289</span>&#160;consisting of a 4 byte header containing the option type info (hi byte, lo</div><div class="line"><a name="l10290"></a><span class="lineno">10290</span>&#160;byte), option string length (hi byte, lo byte), followed by a non-&#39;\0&#39;</div><div class="line"><a name="l10291"></a><span class="lineno">10291</span>&#160;terminated string. The gSOAP DIME handler recognizes one option at most.</div><div class="line"><a name="l10292"></a><span class="lineno">10292</span>&#160;</div><div class="line"><a name="l10293"></a><span class="lineno">10293</span>&#160;## Streaming Chunked DIME        {#dimechunking}</div><div class="line"><a name="l10294"></a><span class="lineno">10294</span>&#160;</div><div class="line"><a name="l10295"></a><span class="lineno">10295</span>&#160;gSOAP automatically handles inbound chunked DIME attachments (streaming or</div><div class="line"><a name="l10296"></a><span class="lineno">10296</span>&#160;non-streaming).  To transmit outbound DIME attachments, the attachment sizes</div><div class="line"><a name="l10297"></a><span class="lineno">10297</span>&#160;MUST be determined in advance to calculate HTTP message length required to</div><div class="line"><a name="l10298"></a><span class="lineno">10298</span>&#160;stream DIME over HTTP.  However, gSOAP also supports the transmission of</div><div class="line"><a name="l10299"></a><span class="lineno">10299</span>&#160;outbound chunked DIME attachments without prior determination of DIME</div><div class="line"><a name="l10300"></a><span class="lineno">10300</span>&#160;attachment sizes when certain conditions are met.  These conditions require</div><div class="line"><a name="l10301"></a><span class="lineno">10301</span>&#160;either non-HTTP transport (use the output-mode `SOAP_ENC_PLAIN` flag), or</div><div class="line"><a name="l10302"></a><span class="lineno">10302</span>&#160;chunked HTTP transport (use the output-mode `SOAP_IO_CHUNK` flag).  You</div><div class="line"><a name="l10303"></a><span class="lineno">10303</span>&#160;can also use the `SOAP_IO_STORE` flag (which is also used automatically</div><div class="line"><a name="l10304"></a><span class="lineno">10304</span>&#160;with compression to determine the HTTP content length header) but that cancels</div><div class="line"><a name="l10305"></a><span class="lineno">10305</span>&#160;the benefits of streaming DIME.</div><div class="line"><a name="l10306"></a><span class="lineno">10306</span>&#160;</div><div class="line"><a name="l10307"></a><span class="lineno">10307</span>&#160;To stream chunked DIME, set the `__size` field of an attachment to zero</div><div class="line"><a name="l10308"></a><span class="lineno">10308</span>&#160;and enable HTTP chunking.  The DIME `fdimeread` callback then fetches data</div><div class="line"><a name="l10309"></a><span class="lineno">10309</span>&#160;in chunks and it is important to fill the entire buffer unless the end of the</div><div class="line"><a name="l10310"></a><span class="lineno">10310</span>&#160;data has been reached and the last chunk is to be send.  That is,</div><div class="line"><a name="l10311"></a><span class="lineno">10311</span>&#160;`fdimeread` should return the value of the last `len` parameter and</div><div class="line"><a name="l10312"></a><span class="lineno">10312</span>&#160;fill the entire buffer `buf` for all chunks except the last.</div><div class="line"><a name="l10313"></a><span class="lineno">10313</span>&#160;</div><div class="line"><a name="l10314"></a><span class="lineno">10314</span>&#160;## WSDL Bindings for DIME Attachments</div><div class="line"><a name="l10315"></a><span class="lineno">10315</span>&#160;</div><div class="line"><a name="l10316"></a><span class="lineno">10316</span>&#160;The `wsdl2h` WSDL parser recognizes DIME attachments and produces an</div><div class="line"><a name="l10317"></a><span class="lineno">10317</span>&#160;annotated header file. Both open and closed layouts are supported for</div><div class="line"><a name="l10318"></a><span class="lineno">10318</span>&#160;transmitting DIME attachments. For closed formats, all DIME attachments must be</div><div class="line"><a name="l10319"></a><span class="lineno">10319</span>&#160;referenced from the SOAP message, e.g. using hrefs with SOAP encoding and using</div><div class="line"><a name="l10320"></a><span class="lineno">10320</span>&#160;the application-specific reference attribute included in the `base64Binary`</div><div class="line"><a name="l10321"></a><span class="lineno">10321</span>&#160;struct/class for doc/lit.</div><div class="line"><a name="l10322"></a><span class="lineno">10322</span>&#160;</div><div class="line"><a name="l10323"></a><span class="lineno">10323</span>&#160;The gSOAP compiler `soapcpp2` does not produce a WSDL with DIME extensions.</div><div class="line"><a name="l10324"></a><span class="lineno">10324</span>&#160;DIME is an older binary format that has no WSDL protocol support, unlike MIME</div><div class="line"><a name="l10325"></a><span class="lineno">10325</span>&#160;and MTOM.</div><div class="line"><a name="l10326"></a><span class="lineno">10326</span>&#160;</div><div class="line"><a name="l10327"></a><span class="lineno">10327</span>&#160;# MTOM Attachments        {#MTOM}</div><div class="line"><a name="l10328"></a><span class="lineno">10328</span>&#160;</div><div class="line"><a name="l10329"></a><span class="lineno">10329</span>&#160;MTOM (Message Transmission Optimization Mechanism) is a relatively new format</div><div class="line"><a name="l10330"></a><span class="lineno">10330</span>&#160;for transmitting attachments with SOAP messages (see</div><div class="line"><a name="l10331"></a><span class="lineno">10331</span>&#160;&lt;http://www.w3.org/TR/soap12-mtom&gt;). MTOM is a W3C working draft as of this</div><div class="line"><a name="l10332"></a><span class="lineno">10332</span>&#160;writing. MTOM attachments are essentially MIME attachments with standardized</div><div class="line"><a name="l10333"></a><span class="lineno">10333</span>&#160;mechanisms for cross referencing attachments from the SOAP body, which is</div><div class="line"><a name="l10334"></a><span class="lineno">10334</span>&#160;absent in (plain) MIME attachments and optional with DIME attachments.</div><div class="line"><a name="l10335"></a><span class="lineno">10335</span>&#160;</div><div class="line"><a name="l10336"></a><span class="lineno">10336</span>&#160;Unlike the name suggests, the speed by which attached data is transmitted is</div><div class="line"><a name="l10337"></a><span class="lineno">10337</span>&#160;not increased compared to MIME, DIME, or even XML encoded base64 data (at least</div><div class="line"><a name="l10338"></a><span class="lineno">10338</span>&#160;the performance differences in gSOAP will be small). The advantage of the</div><div class="line"><a name="l10339"></a><span class="lineno">10339</span>&#160;format is the standardized attachment reference mechanism, which should improve</div><div class="line"><a name="l10340"></a><span class="lineno">10340</span>&#160;interoperability.</div><div class="line"><a name="l10341"></a><span class="lineno">10341</span>&#160;</div><div class="line"><a name="l10342"></a><span class="lineno">10342</span>&#160;The MTOM specification mandates SOAP 1.2 and the use of the XOP namespace. The</div><div class="line"><a name="l10343"></a><span class="lineno">10343</span>&#160;XOP Include element *`xop:Include`* is used to reference attachment(s) from the SOAP message body.</div><div class="line"><a name="l10344"></a><span class="lineno">10344</span>&#160;</div><div class="line"><a name="l10345"></a><span class="lineno">10345</span>&#160;Because references from within the SOAP message body to attachments are</div><div class="line"><a name="l10346"></a><span class="lineno">10346</span>&#160;mandatory with MTOM, the implementation of the serialization and deserialization of MTOM</div><div class="line"><a name="l10347"></a><span class="lineno">10347</span>&#160;MIME attachments in gSOAP uses the extended binary type comparable to DIME support in gSOAP. This binary type is predefined in the `import/xop.h` file:</div><div class="line"><a name="l10348"></a><span class="lineno">10348</span>&#160;</div><div class="line"><a name="l10349"></a><span class="lineno">10349</span>&#160;```cpp</div><div class="line"><a name="l10350"></a><span class="lineno">10350</span>&#160;//gsoap xop schema import: http://www.w3.org/2004/08/xop/include </div><div class="line"><a name="l10351"></a><span class="lineno">10351</span>&#160;struct _xop__Include </div><div class="line"><a name="l10352"></a><span class="lineno">10352</span>&#160;{ </div><div class="line"><a name="l10353"></a><span class="lineno">10353</span>&#160;   unsigned char *__ptr; </div><div class="line"><a name="l10354"></a><span class="lineno">10354</span>&#160;   int __size; </div><div class="line"><a name="l10355"></a><span class="lineno">10355</span>&#160;   char *id; </div><div class="line"><a name="l10356"></a><span class="lineno">10356</span>&#160;   char *type; </div><div class="line"><a name="l10357"></a><span class="lineno">10357</span>&#160;   char *options; </div><div class="line"><a name="l10358"></a><span class="lineno">10358</span>&#160;}; </div><div class="line"><a name="l10359"></a><span class="lineno">10359</span>&#160;typedef struct _xop__Include _xop__Include;</div><div class="line"><a name="l10360"></a><span class="lineno">10360</span>&#160;```</div><div class="line"><a name="l10361"></a><span class="lineno">10361</span>&#160;</div><div class="line"><a name="l10362"></a><span class="lineno">10362</span>&#160;The additional `id`, `type`, and `option` fields</div><div class="line"><a name="l10363"></a><span class="lineno">10363</span>&#160;enable MTOM attachments for the data pointed to by `__ptr` of size `__size`. The process for sending and receiving MTOM XOP</div><div class="line"><a name="l10364"></a><span class="lineno">10364</span>&#160;attachments is fully automated.</div><div class="line"><a name="l10365"></a><span class="lineno">10365</span>&#160;The `id` field references the attachment (typically a content id CID or UUID). When set to NULL, gSOAP assigns a unique CID. The `type`</div><div class="line"><a name="l10366"></a><span class="lineno">10366</span>&#160;field specifies the required MIME type of the binary data, and the optional</div><div class="line"><a name="l10367"></a><span class="lineno">10367</span>&#160;`options` field can be used to piggy-back descriptive text with an attachment.  The order of the</div><div class="line"><a name="l10368"></a><span class="lineno">10368</span>&#160;declaration of the fields is significant.</div><div class="line"><a name="l10369"></a><span class="lineno">10369</span>&#160;</div><div class="line"><a name="l10370"></a><span class="lineno">10370</span>&#160;You can explicitly import the `xop.h` in your header file to use the MTOM attachments in your service, for example:</div><div class="line"><a name="l10371"></a><span class="lineno">10371</span>&#160;</div><div class="line"><a name="l10372"></a><span class="lineno">10372</span>&#160;```cpp</div><div class="line"><a name="l10373"></a><span class="lineno">10373</span>&#160;#import &quot;import/soap12.h&quot; </div><div class="line"><a name="l10374"></a><span class="lineno">10374</span>&#160;/* alternatively, without the import above, use: </div><div class="line"><a name="l10375"></a><span class="lineno">10375</span>&#160;//gsoap SOAP-ENV schema namespace: http://www.w3.org/2003/05/soap-envelope </div><div class="line"><a name="l10376"></a><span class="lineno">10376</span>&#160;//gsoap SOAP-ENC schema namespace: http://www.w3.org/2003/05/soap-encoding </div><div class="line"><a name="l10377"></a><span class="lineno">10377</span>&#160;*/ </div><div class="line"><a name="l10378"></a><span class="lineno">10378</span>&#160;#import &quot;import/xop.h&quot; </div><div class="line"><a name="l10379"></a><span class="lineno">10379</span>&#160;#import &quot;import/xmime5.h&quot; </div><div class="line"><a name="l10380"></a><span class="lineno">10380</span>&#160;</div><div class="line"><a name="l10381"></a><span class="lineno">10381</span>&#160;//gsoap x schema namespace: http://my.first.mtom.net </div><div class="line"><a name="l10382"></a><span class="lineno">10382</span>&#160;struct x__myData </div><div class="line"><a name="l10383"></a><span class="lineno">10383</span>&#160;{ </div><div class="line"><a name="l10384"></a><span class="lineno">10384</span>&#160;  _xop__Include xop__Include; // attachment </div><div class="line"><a name="l10385"></a><span class="lineno">10385</span>&#160;  @ char *xmime5__contentType; // and its contentType </div><div class="line"><a name="l10386"></a><span class="lineno">10386</span>&#160;}; </div><div class="line"><a name="l10387"></a><span class="lineno">10387</span>&#160;int x__myMTOMtest(struct x__myData *in, struct x__myData *out);</div><div class="line"><a name="l10388"></a><span class="lineno">10388</span>&#160;```</div><div class="line"><a name="l10389"></a><span class="lineno">10389</span>&#160;</div><div class="line"><a name="l10390"></a><span class="lineno">10390</span>&#160;As you can see, there is really no difference between the specification of MTOM</div><div class="line"><a name="l10391"></a><span class="lineno">10391</span>&#160;and DIME attachments in a gSOAP header file. Except that you MUST use SOAP 1.2</div><div class="line"><a name="l10392"></a><span class="lineno">10392</span>&#160;and the `xop__Include` element.</div><div class="line"><a name="l10393"></a><span class="lineno">10393</span>&#160;</div><div class="line"><a name="l10394"></a><span class="lineno">10394</span>&#160;When an instance of `x__myDataType` is serialized and either or both the</div><div class="line"><a name="l10395"></a><span class="lineno">10395</span>&#160;`id` and `type` fields are non-NULL, the data is transmitted as MTOM</div><div class="line"><a name="l10396"></a><span class="lineno">10396</span>&#160;MIME attachment if the `SOAP_ENC_MTOM` flag is set in the gSOAP&#39;s soap</div><div class="line"><a name="l10397"></a><span class="lineno">10397</span>&#160;struct context:</div><div class="line"><a name="l10398"></a><span class="lineno">10398</span>&#160;</div><div class="line"><a name="l10399"></a><span class="lineno">10399</span>&#160;```cpp</div><div class="line"><a name="l10400"></a><span class="lineno">10400</span>&#160;struct soap *soap = soap_new1(SOAP_ENC_MTOM);</div><div class="line"><a name="l10401"></a><span class="lineno">10401</span>&#160;```</div><div class="line"><a name="l10402"></a><span class="lineno">10402</span>&#160;</div><div class="line"><a name="l10403"></a><span class="lineno">10403</span>&#160;Without this flag, the attachments will be transmitted in DIME format</div><div class="line"><a name="l10404"></a><span class="lineno">10404</span>&#160;(Section \ref DIME ). If your current clients and services are based on</div><div class="line"><a name="l10405"></a><span class="lineno">10405</span>&#160;non-streaming DIME attachments using the SOAP body reference mechanism (thus,</div><div class="line"><a name="l10406"></a><span class="lineno">10406</span>&#160;without using the `soap_set_dime_attachment` function) or plain base64</div><div class="line"><a name="l10407"></a><span class="lineno">10407</span>&#160;binary XML data elements, it is very easy to adopt MTOM by renaming the binary types to `xop__Include` and using the</div><div class="line"><a name="l10408"></a><span class="lineno">10408</span>&#160;`SOAP_ENC_MTOM` flag with the SOAP 1.2 namespace.</div><div class="line"><a name="l10409"></a><span class="lineno">10409</span>&#160;</div><div class="line"><a name="l10410"></a><span class="lineno">10410</span>&#160;## Generating MultipartRelated MIME Attachment Bindings in WSDL        {#MIMEWSDL}</div><div class="line"><a name="l10411"></a><span class="lineno">10411</span>&#160;</div><div class="line"><a name="l10412"></a><span class="lineno">10412</span>&#160;To generate multipartRelated bindings in the WSDL file, use the</div><div class="line"><a name="l10413"></a><span class="lineno">10413</span>&#160;</div><div class="line"><a name="l10414"></a><span class="lineno">10414</span>&#160;```cpp</div><div class="line"><a name="l10415"></a><span class="lineno">10415</span>&#160;//gsoap ... service method-mime-type</div><div class="line"><a name="l10416"></a><span class="lineno">10416</span>&#160;```</div><div class="line"><a name="l10417"></a><span class="lineno">10417</span>&#160;</div><div class="line"><a name="l10418"></a><span class="lineno">10418</span>&#160;directive (see also Section \ref directives . The</div><div class="line"><a name="l10419"></a><span class="lineno">10419</span>&#160;directive can be repeated for each attachment you want to associate with a</div><div class="line"><a name="l10420"></a><span class="lineno">10420</span>&#160;method&#39;s request and response messages.</div><div class="line"><a name="l10421"></a><span class="lineno">10421</span>&#160;</div><div class="line"><a name="l10422"></a><span class="lineno">10422</span>&#160;For example:</div><div class="line"><a name="l10423"></a><span class="lineno">10423</span>&#160;</div><div class="line"><a name="l10424"></a><span class="lineno">10424</span>&#160;```cpp</div><div class="line"><a name="l10425"></a><span class="lineno">10425</span>&#160;#import &quot;import/soap12.h&quot; </div><div class="line"><a name="l10426"></a><span class="lineno">10426</span>&#160;#import &quot;import/xop.h&quot; </div><div class="line"><a name="l10427"></a><span class="lineno">10427</span>&#160;#import &quot;import/xmime5.h&quot; </div><div class="line"><a name="l10428"></a><span class="lineno">10428</span>&#160;</div><div class="line"><a name="l10429"></a><span class="lineno">10429</span>&#160;//gsoap x schema namespace: http://my.first.mtom.net </div><div class="line"><a name="l10430"></a><span class="lineno">10430</span>&#160;struct x__myData </div><div class="line"><a name="l10431"></a><span class="lineno">10431</span>&#160;{ </div><div class="line"><a name="l10432"></a><span class="lineno">10432</span>&#160;  _xop__Include xop__Include; // attachment </div><div class="line"><a name="l10433"></a><span class="lineno">10433</span>&#160;  @ char *xmime5__contentType; // and its contentType </div><div class="line"><a name="l10434"></a><span class="lineno">10434</span>&#160;}; </div><div class="line"><a name="l10435"></a><span class="lineno">10435</span>&#160;//gsoap x service method-mime-type: myMTOMtest text/xml </div><div class="line"><a name="l10436"></a><span class="lineno">10436</span>&#160;int x__myMTOMtest(struct x__myData *in, struct x__myData *out);</div><div class="line"><a name="l10437"></a><span class="lineno">10437</span>&#160;```</div><div class="line"><a name="l10438"></a><span class="lineno">10438</span>&#160;</div><div class="line"><a name="l10439"></a><span class="lineno">10439</span>&#160;The `//gsoap x service method-mime-type` directive indicates that this</div><div class="line"><a name="l10440"></a><span class="lineno">10440</span>&#160;operation accepts *`text/xml`* MIME attachments. See the SOAP-with-Attachment</div><div class="line"><a name="l10441"></a><span class="lineno">10441</span>&#160;specification for the MIME types to use (for example, *`*/*`* is a wildcard).</div><div class="line"><a name="l10442"></a><span class="lineno">10442</span>&#160;If the operation has more than one attachment, just repeat this directive for</div><div class="line"><a name="l10443"></a><span class="lineno">10443</span>&#160;each attachment you want to bind to the operation.</div><div class="line"><a name="l10444"></a><span class="lineno">10444</span>&#160;</div><div class="line"><a name="l10445"></a><span class="lineno">10445</span>&#160;To bind attachments only to the request message of an operation, use</div><div class="line"><a name="l10446"></a><span class="lineno">10446</span>&#160;`//gsoap x service method-input-mime-type`. Similarly, to bind attachments</div><div class="line"><a name="l10447"></a><span class="lineno">10447</span>&#160;only to the response message of an operation, use</div><div class="line"><a name="l10448"></a><span class="lineno">10448</span>&#160;</div><div class="line"><a name="l10449"></a><span class="lineno">10449</span>&#160;```cpp</div><div class="line"><a name="l10450"></a><span class="lineno">10450</span>&#160;//gsoap x service method-ouput-mime-type</div><div class="line"><a name="l10451"></a><span class="lineno">10451</span>&#160;```</div><div class="line"><a name="l10452"></a><span class="lineno">10452</span>&#160;</div><div class="line"><a name="l10453"></a><span class="lineno">10453</span>&#160;The `wsdl2h` WSDL parser recognizes MIME attachments and produces an</div><div class="line"><a name="l10454"></a><span class="lineno">10454</span>&#160;annotated header file. However, the ordering of MIME parts in the</div><div class="line"><a name="l10455"></a><span class="lineno">10455</span>&#160;multipartRelated elements is not reflected in the header file. Application</div><div class="line"><a name="l10456"></a><span class="lineno">10456</span>&#160;developers should adhere the standards and ensure that multipart/related</div><div class="line"><a name="l10457"></a><span class="lineno">10457</span>&#160;attachments are transmitted in compliance with the WSDL operation declarations.</div><div class="line"><a name="l10458"></a><span class="lineno">10458</span>&#160;</div><div class="line"><a name="l10459"></a><span class="lineno">10459</span>&#160;## Sending and Receiving MTOM Attachments</div><div class="line"><a name="l10460"></a><span class="lineno">10460</span>&#160;</div><div class="line"><a name="l10461"></a><span class="lineno">10461</span>&#160;A receiver must be informed to recognize MTOM attachments by setting the</div><div class="line"><a name="l10462"></a><span class="lineno">10462</span>&#160;`SOAP_ENC_MTOM` flag of the gSOAP context. Otherwise, the regular MIME</div><div class="line"><a name="l10463"></a><span class="lineno">10463</span>&#160;attachment mechanism (SwA) will be used to store attachments.</div><div class="line"><a name="l10464"></a><span class="lineno">10464</span>&#160;</div><div class="line"><a name="l10465"></a><span class="lineno">10465</span>&#160;When using `wsdl2h` to build clients and/or services, you should use the</div><div class="line"><a name="l10466"></a><span class="lineno">10466</span>&#160;`typemap.dat` file included in the distribution package. The</div><div class="line"><a name="l10467"></a><span class="lineno">10467</span>&#160;`typemap.dat` file defines the XOP namespace and XML MIME namespaces as</div><div class="line"><a name="l10468"></a><span class="lineno">10468</span>&#160;imported namespaces:</div><div class="line"><a name="l10469"></a><span class="lineno">10469</span>&#160;</div><div class="line"><a name="l10470"></a><span class="lineno">10470</span>&#160;```cpp</div><div class="line"><a name="l10471"></a><span class="lineno">10471</span>&#160;xop    = &lt;http://www.w3.org/2004/08/xop/include&gt; </div><div class="line"><a name="l10472"></a><span class="lineno">10472</span>&#160;xmime5 = &lt;http://www.w3.org/2005/05/xmlmime&gt; </div><div class="line"><a name="l10473"></a><span class="lineno">10473</span>&#160;xmime4 = &lt;http://www.w3.org/2004/11/xmlmime&gt;</div><div class="line"><a name="l10474"></a><span class="lineno">10474</span>&#160;```</div><div class="line"><a name="l10475"></a><span class="lineno">10475</span>&#160;</div><div class="line"><a name="l10476"></a><span class="lineno">10476</span>&#160;The `wsdl2h` tool uses the `typemap.dat` file (see also option -t) to</div><div class="line"><a name="l10477"></a><span class="lineno">10477</span>&#160;convert WSDL into a gSOAP header file. In this case we don&#39;t want the</div><div class="line"><a name="l10478"></a><span class="lineno">10478</span>&#160;`wsdl2h` tool to read the XOP schema and translate it, since we have a</div><div class="line"><a name="l10479"></a><span class="lineno">10479</span>&#160;pre-defined `_xop__Include` element to handle XOP for MTOM. This</div><div class="line"><a name="l10480"></a><span class="lineno">10480</span>&#160;`_xop__Include` element is defined in `xop.h`. Therefore, the</div><div class="line"><a name="l10481"></a><span class="lineno">10481</span>&#160;bindings shown above will not translate the XOP and XML MIME schemas to code,</div><div class="line"><a name="l10482"></a><span class="lineno">10482</span>&#160;but generates `#import` statements instead:</div><div class="line"><a name="l10483"></a><span class="lineno">10483</span>&#160;</div><div class="line"><a name="l10484"></a><span class="lineno">10484</span>&#160;```cpp</div><div class="line"><a name="l10485"></a><span class="lineno">10485</span>&#160;#import &quot;xop.h&quot; </div><div class="line"><a name="l10486"></a><span class="lineno">10486</span>&#160;#import &quot;xmime5.h&quot;</div><div class="line"><a name="l10487"></a><span class="lineno">10487</span>&#160;```</div><div class="line"><a name="l10488"></a><span class="lineno">10488</span>&#160;</div><div class="line"><a name="l10489"></a><span class="lineno">10489</span>&#160;The `#import` statements are only added for those namespaces that are</div><div class="line"><a name="l10490"></a><span class="lineno">10490</span>&#160;actually used by the service.</div><div class="line"><a name="l10491"></a><span class="lineno">10491</span>&#160;</div><div class="line"><a name="l10492"></a><span class="lineno">10492</span>&#160;Let&#39;s take a look at an example.</div><div class="line"><a name="l10493"></a><span class="lineno">10493</span>&#160;The `wsdl2h` importer generates a header file with `#import &quot;xop.h&quot;` from a WSDL that references XOP, for example:</div><div class="line"><a name="l10494"></a><span class="lineno">10494</span>&#160;</div><div class="line"><a name="l10495"></a><span class="lineno">10495</span>&#160;```cpp</div><div class="line"><a name="l10496"></a><span class="lineno">10496</span>&#160;#import &quot;xop.h&quot; </div><div class="line"><a name="l10497"></a><span class="lineno">10497</span>&#160;#import &quot;xmime5.h&quot; </div><div class="line"><a name="l10498"></a><span class="lineno">10498</span>&#160;struct ns__Data </div><div class="line"><a name="l10499"></a><span class="lineno">10499</span>&#160;{ </div><div class="line"><a name="l10500"></a><span class="lineno">10500</span>&#160;  _xop__Include xop__Include; </div><div class="line"><a name="l10501"></a><span class="lineno">10501</span>&#160;  @ char *xmime5__contentType;  </div><div class="line"><a name="l10502"></a><span class="lineno">10502</span>&#160;};</div><div class="line"><a name="l10503"></a><span class="lineno">10503</span>&#160;```</div><div class="line"><a name="l10504"></a><span class="lineno">10504</span>&#160;</div><div class="line"><a name="l10505"></a><span class="lineno">10505</span>&#160;Suppose the WSDL defines an operation:</div><div class="line"><a name="l10506"></a><span class="lineno">10506</span>&#160;</div><div class="line"><a name="l10507"></a><span class="lineno">10507</span>&#160;```cpp</div><div class="line"><a name="l10508"></a><span class="lineno">10508</span>&#160;int ns__echoData(struct ns__Data *in, struct ns__Data *out);</div><div class="line"><a name="l10509"></a><span class="lineno">10509</span>&#160;```</div><div class="line"><a name="l10510"></a><span class="lineno">10510</span>&#160;</div><div class="line"><a name="l10511"></a><span class="lineno">10511</span>&#160;After generating the stubs/proxies with the `soapcpp2` compiler, we can invoke the stub at the client side with:</div><div class="line"><a name="l10512"></a><span class="lineno">10512</span>&#160;</div><div class="line"><a name="l10513"></a><span class="lineno">10513</span>&#160;```cpp</div><div class="line"><a name="l10514"></a><span class="lineno">10514</span>&#160;struct soap *soap = soap_new1(SOAP_ENC_MTOM); </div><div class="line"><a name="l10515"></a><span class="lineno">10515</span>&#160;struct ns__Data data; </div><div class="line"><a name="l10516"></a><span class="lineno">10516</span>&#160;data.xop__Include.__ptr = (unsigned char*)&quot;&lt;b&gt;Hello world!&lt;/b&gt;&quot;; </div><div class="line"><a name="l10517"></a><span class="lineno">10517</span>&#160;data.xop__Include.__size = 20; </div><div class="line"><a name="l10518"></a><span class="lineno">10518</span>&#160;data.xop__Include.id = NULL; // CID automatically generated by gSOAP engine </div><div class="line"><a name="l10519"></a><span class="lineno">10519</span>&#160;data.xop__Include.type = &quot;text/html&quot;; // MIME type </div><div class="line"><a name="l10520"></a><span class="lineno">10520</span>&#160;data.xop__Include.options = NULL; // no descriptive info added </div><div class="line"><a name="l10521"></a><span class="lineno">10521</span>&#160;data.xmime5__contentType = &quot;text/html&quot;; // MIME type </div><div class="line"><a name="l10522"></a><span class="lineno">10522</span>&#160;if (soap_call_ns__echoData(soap, endpoint, action, &amp;data, &amp;data))</div><div class="line"><a name="l10523"></a><span class="lineno">10523</span>&#160;   soap_print_fault(soap, stderr);</div><div class="line"><a name="l10524"></a><span class="lineno">10524</span>&#160;else </div><div class="line"><a name="l10525"></a><span class="lineno">10525</span>&#160;   printf(&quot;Got data\n&quot;); </div><div class="line"><a name="l10526"></a><span class="lineno">10526</span>&#160;soap_destroy(soap); // remove deserialized class instances </div><div class="line"><a name="l10527"></a><span class="lineno">10527</span>&#160;soap_end(soap); // remove temporary and deserialized data </div><div class="line"><a name="l10528"></a><span class="lineno">10528</span>&#160;soap_free(soap); // detach and free context</div><div class="line"><a name="l10529"></a><span class="lineno">10529</span>&#160;```</div><div class="line"><a name="l10530"></a><span class="lineno">10530</span>&#160;</div><div class="line"><a name="l10531"></a><span class="lineno">10531</span>&#160;Note that the `xop__Include.type` field must be set to transmit MTOM attachments, otherwise plain base64 XML will be used.</div><div class="line"><a name="l10532"></a><span class="lineno">10532</span>&#160;</div><div class="line"><a name="l10533"></a><span class="lineno">10533</span>&#160;At the server side, we show an example of an operation handler that just copies the input data to output:</div><div class="line"><a name="l10534"></a><span class="lineno">10534</span>&#160;</div><div class="line"><a name="l10535"></a><span class="lineno">10535</span>&#160;```cpp</div><div class="line"><a name="l10536"></a><span class="lineno">10536</span>&#160;int ns__echoData(struct soap *soap, struct ns__Data *in, struct ns__data *out) </div><div class="line"><a name="l10537"></a><span class="lineno">10537</span>&#160;{ </div><div class="line"><a name="l10538"></a><span class="lineno">10538</span>&#160;   *out = *in; </div><div class="line"><a name="l10539"></a><span class="lineno">10539</span>&#160;   return SOAP_OK; </div><div class="line"><a name="l10540"></a><span class="lineno">10540</span>&#160;}</div><div class="line"><a name="l10541"></a><span class="lineno">10541</span>&#160;```</div><div class="line"><a name="l10542"></a><span class="lineno">10542</span>&#160;</div><div class="line"><a name="l10543"></a><span class="lineno">10543</span>&#160;The server must use the `SOAP_ENC_MTOM` flag to initialize the soap struct to receive and send MTOM attachments.</div><div class="line"><a name="l10544"></a><span class="lineno">10544</span>&#160;</div><div class="line"><a name="l10545"></a><span class="lineno">10545</span>&#160;## Streaming MTOM/MIME        {#MTOMstreaming}</div><div class="line"><a name="l10546"></a><span class="lineno">10546</span>&#160;</div><div class="line"><a name="l10547"></a><span class="lineno">10547</span>&#160;Streaming MTOM/MIME is achieved with callback functions to fetch and store data</div><div class="line"><a name="l10548"></a><span class="lineno">10548</span>&#160;during transmission. Three function callbacks for streaming MTOM/MIME output and</div><div class="line"><a name="l10549"></a><span class="lineno">10549</span>&#160;three callbacks for streaming MTOM/MIME input are available.</div><div class="line"><a name="l10550"></a><span class="lineno">10550</span>&#160;</div><div class="line"><a name="l10551"></a><span class="lineno">10551</span>&#160;* `void *(*soap.fmimereadopen)(struct soap *soap, void *handle, const char *id, const char *type, const char *description)` </div><div class="line"><a name="l10552"></a><span class="lineno">10552</span>&#160;  Called by the gSOAP run-time MTOM/MIME attachment sender to start reading</div><div class="line"><a name="l10553"></a><span class="lineno">10553</span>&#160;  from a (binary) data source for outbound transmission. The content will be</div><div class="line"><a name="l10554"></a><span class="lineno">10554</span>&#160;  read from the application&#39;s data source in chunks using the `fmimeread`</div><div class="line"><a name="l10555"></a><span class="lineno">10555</span>&#160;  callback and streamed into the SOAP/XML/MTOM/MIME output stream. The `handle`</div><div class="line"><a name="l10556"></a><span class="lineno">10556</span>&#160;  contains the value of the `__ptr` field of an attachment struct/class, which</div><div class="line"><a name="l10557"></a><span class="lineno">10557</span>&#160;  could be a pointer to specific information such as a file descriptor or a</div><div class="line"><a name="l10558"></a><span class="lineno">10558</span>&#160;  pointer to a string to be passed to this callback.  Both `__ptr` and `__size`</div><div class="line"><a name="l10559"></a><span class="lineno">10559</span>&#160;  fields should have been set by the application prior to the serialization of</div><div class="line"><a name="l10560"></a><span class="lineno">10560</span>&#160;  the content. The `id`, `type`, and `description` arguments are the MTOM/MIME</div><div class="line"><a name="l10561"></a><span class="lineno">10561</span>&#160;  id, type, and description, respectively. The callback should return `handle`,</div><div class="line"><a name="l10562"></a><span class="lineno">10562</span>&#160;  or another pointer value which will be passed as a handle to `fmimeread` and</div><div class="line"><a name="l10563"></a><span class="lineno">10563</span>&#160;  `fmimereadclose`.  The callback should return NULL and set `soap-&gt;error`</div><div class="line"><a name="l10564"></a><span class="lineno">10564</span>&#160;  when an error occurred. The callback should return NULL (and not set</div><div class="line"><a name="l10565"></a><span class="lineno">10565</span>&#160;  `soap-&gt;error`) when this particular MTOM/MIME attachment is not to be</div><div class="line"><a name="l10566"></a><span class="lineno">10566</span>&#160;  streamed.</div><div class="line"><a name="l10567"></a><span class="lineno">10567</span>&#160;</div><div class="line"><a name="l10568"></a><span class="lineno">10568</span>&#160;* `size_t (*soap.fmimeread)(struct soap *soap, void *handle, char *buf, size_t len)` </div><div class="line"><a name="l10569"></a><span class="lineno">10569</span>&#160;  Called by the gSOAP run-time MTOM/MIME attachment sender to read more data</div><div class="line"><a name="l10570"></a><span class="lineno">10570</span>&#160;  from a (binary) data source for streaming into the output stream.  The</div><div class="line"><a name="l10571"></a><span class="lineno">10571</span>&#160;  `handle` contains the value returned by the `fmimereadopen` callback.  The</div><div class="line"><a name="l10572"></a><span class="lineno">10572</span>&#160;  `buf` argument is the buffer of length `len` into which a chunk of data</div><div class="line"><a name="l10573"></a><span class="lineno">10573</span>&#160;  should be stored.  The actual amount of data stored in the buffer may be less</div><div class="line"><a name="l10574"></a><span class="lineno">10574</span>&#160;  than `len` and this amount should be returned by the application.  A return</div><div class="line"><a name="l10575"></a><span class="lineno">10575</span>&#160;  value of 0 indicates an error (the callback may set `soap-&gt;errnum` to errno).</div><div class="line"><a name="l10576"></a><span class="lineno">10576</span>&#160;  The `__size` field of the attachment struct/class should have been set by the</div><div class="line"><a name="l10577"></a><span class="lineno">10577</span>&#160;  application prior to the serialization of the content.  The value of `__size`</div><div class="line"><a name="l10578"></a><span class="lineno">10578</span>&#160;  indicates the total size of the content to be transmitted.  When the `__size`</div><div class="line"><a name="l10579"></a><span class="lineno">10579</span>&#160;  is zero then MTOM/MIME chunked transfers can be used under certain</div><div class="line"><a name="l10580"></a><span class="lineno">10580</span>&#160;  circumstances to stream content without prior determination of attachment</div><div class="line"><a name="l10581"></a><span class="lineno">10581</span>&#160;  size, see Section \ref mimechunking  below.</div><div class="line"><a name="l10582"></a><span class="lineno">10582</span>&#160;</div><div class="line"><a name="l10583"></a><span class="lineno">10583</span>&#160;* `void (*soap.fmimereadclose)(struct soap *soap, void *handle)` </div><div class="line"><a name="l10584"></a><span class="lineno">10584</span>&#160;  Called by the gSOAP run-time MTOM/MIME attachment sender at the end of the</div><div class="line"><a name="l10585"></a><span class="lineno">10585</span>&#160;  streaming process to close the data source.  The `handle` contains the value</div><div class="line"><a name="l10586"></a><span class="lineno">10586</span>&#160;  returned by the `fmimereadopen` callback.  The `fmimewriteclose` callback is</div><div class="line"><a name="l10587"></a><span class="lineno">10587</span>&#160;  called after successfully transmitting the data or when an error occurred.</div><div class="line"><a name="l10588"></a><span class="lineno">10588</span>&#160;</div><div class="line"><a name="l10589"></a><span class="lineno">10589</span>&#160;* `void *(*soap.fmimewriteopen)(struct soap *soap, void *handle, const char *id, const char *type, const char *description, enum soap_mime_encoding encoding)` </div><div class="line"><a name="l10590"></a><span class="lineno">10590</span>&#160;  Called by the gSOAP run-time MTOM/MIME attachment receiver to start writing</div><div class="line"><a name="l10591"></a><span class="lineno">10591</span>&#160;  an inbound MTOM/MIME attachment to an application&#39;s data store. The content</div><div class="line"><a name="l10592"></a><span class="lineno">10592</span>&#160;  is streamed into an application data store through multiple `fmimewrite`</div><div class="line"><a name="l10593"></a><span class="lineno">10593</span>&#160;  calls from the gSOAP attachment receiver.  The `handle` argument is normally</div><div class="line"><a name="l10594"></a><span class="lineno">10594</span>&#160;  NULL, unless `soap_get_mime_attachment` is used that passes the handle to the</div><div class="line"><a name="l10595"></a><span class="lineno">10595</span>&#160;  callback, see Section \ref MTOMpoststreaming . The `id`, `type`, and</div><div class="line"><a name="l10596"></a><span class="lineno">10596</span>&#160;  `description` arguments are the MTOM/MIME id, type, and description</div><div class="line"><a name="l10597"></a><span class="lineno">10597</span>&#160;  respectively. The `encoding` enumeration value indicates the MIME content</div><div class="line"><a name="l10598"></a><span class="lineno">10598</span>&#160;  transfer encoding, which is one of `SOAP_MIME_NONE`, `SOAP_MIME_7BIT`,</div><div class="line"><a name="l10599"></a><span class="lineno">10599</span>&#160;  `SOAP_MIME_8BIT`, `SOAP_MIME_BINARY`, `SOAP_MIME_QUOTED_PRINTABLE`,</div><div class="line"><a name="l10600"></a><span class="lineno">10600</span>&#160;  `SOAP_MIME_BASE64`, `SOAP_MIME_IETF_TOKEN`, `SOAP_MIME_X_TOKEN`.  Content</div><div class="line"><a name="l10601"></a><span class="lineno">10601</span>&#160;  decoding may have to be considered by the application based on this value.</div><div class="line"><a name="l10602"></a><span class="lineno">10602</span>&#160;  The callback should return a non-NULL handle which is passed to the</div><div class="line"><a name="l10603"></a><span class="lineno">10603</span>&#160;  `fmimewrite` and `fmimewriteclose` callbacks. The `__ptr` field of the</div><div class="line"><a name="l10604"></a><span class="lineno">10604</span>&#160;  attachment struct/class is set to the value of this handle. The `__size`</div><div class="line"><a name="l10605"></a><span class="lineno">10605</span>&#160;  field is set to the total size of the attachment after receiving the entire</div><div class="line"><a name="l10606"></a><span class="lineno">10606</span>&#160;  content. The size is unknown in advance because MTOM/MIME attachments may be</div><div class="line"><a name="l10607"></a><span class="lineno">10607</span>&#160;  chunked.</div><div class="line"><a name="l10608"></a><span class="lineno">10608</span>&#160;</div><div class="line"><a name="l10609"></a><span class="lineno">10609</span>&#160;* `int (*soap.fmimewrite)(struct soap *soap, void *handle, const char *buf, size_t len)` </div><div class="line"><a name="l10610"></a><span class="lineno">10610</span>&#160;  Called by the gSOAP run-time MTOM/MIME attachment receiver to write part of</div><div class="line"><a name="l10611"></a><span class="lineno">10611</span>&#160;  an inbound MTOM/MIME attachment to an application&#39;s data store.  The `handle`</div><div class="line"><a name="l10612"></a><span class="lineno">10612</span>&#160;  contains the value returned by the `fmimewriteopen` callback.  The `buf`</div><div class="line"><a name="l10613"></a><span class="lineno">10613</span>&#160;  argument contains the data of length `len`.  The callback should return a</div><div class="line"><a name="l10614"></a><span class="lineno">10614</span>&#160;  gSOAP error code (e.g. `SOAP_OK` when no error occurred).</div><div class="line"><a name="l10615"></a><span class="lineno">10615</span>&#160;</div><div class="line"><a name="l10616"></a><span class="lineno">10616</span>&#160;* `void (*soap.fmimewriteclose)(struct soap *soap, void *handle)` </div><div class="line"><a name="l10617"></a><span class="lineno">10617</span>&#160;  Called by the gSOAP run-time MTOM/MIME attachment receiver at the end of the</div><div class="line"><a name="l10618"></a><span class="lineno">10618</span>&#160;  streaming process to close the data store.  The `fmimewriteclose` callback is</div><div class="line"><a name="l10619"></a><span class="lineno">10619</span>&#160;  called after successfully receiving the data or when an error occurred.  The</div><div class="line"><a name="l10620"></a><span class="lineno">10620</span>&#160;  `handle` contains the value returned by the `fmimewriteopen` callback.</div><div class="line"><a name="l10621"></a><span class="lineno">10621</span>&#160;</div><div class="line"><a name="l10622"></a><span class="lineno">10622</span>&#160;In addition, a `void *user` field in the `struct soap` data structure</div><div class="line"><a name="l10623"></a><span class="lineno">10623</span>&#160;is available to pass user-defined data to the callbacks.  This way, you can set</div><div class="line"><a name="l10624"></a><span class="lineno">10624</span>&#160;`soap.user` to point to application data that the callbacks need such as a</div><div class="line"><a name="l10625"></a><span class="lineno">10625</span>&#160;file name for example.</div><div class="line"><a name="l10626"></a><span class="lineno">10626</span>&#160;</div><div class="line"><a name="l10627"></a><span class="lineno">10627</span>&#160;The following example illustrates the client-side initialization of an image</div><div class="line"><a name="l10628"></a><span class="lineno">10628</span>&#160;attachment struct to stream a file into a MTOM attachment without HTTP chunking (HTTP streaming chunked MTOM transfer is presented in Section \ref mimechunking ):</div><div class="line"><a name="l10629"></a><span class="lineno">10629</span>&#160;</div><div class="line"><a name="l10630"></a><span class="lineno">10630</span>&#160;```cpp</div><div class="line"><a name="l10631"></a><span class="lineno">10631</span>&#160;int main() </div><div class="line"><a name="l10632"></a><span class="lineno">10632</span>&#160;{ </div><div class="line"><a name="l10633"></a><span class="lineno">10633</span>&#160;   struct soap soap; </div><div class="line"><a name="l10634"></a><span class="lineno">10634</span>&#160;   struct xsd__base64Binary image; </div><div class="line"><a name="l10635"></a><span class="lineno">10635</span>&#160;   FILE *fd; </div><div class="line"><a name="l10636"></a><span class="lineno">10636</span>&#160;   struct stat sb; </div><div class="line"><a name="l10637"></a><span class="lineno">10637</span>&#160;   soap_init1(&amp;soap, SOAP_ENC_MTOM); // mandatory to enable MTOM </div><div class="line"><a name="l10638"></a><span class="lineno">10638</span>&#160;   if (!fstat(fileno(fd), &amp;sb) &amp;&amp; sb.st_size &gt; 0) </div><div class="line"><a name="l10639"></a><span class="lineno">10639</span>&#160;   {</div><div class="line"><a name="l10640"></a><span class="lineno">10640</span>&#160;     // because we can get the length of the file, we can stream it without chunking </div><div class="line"><a name="l10641"></a><span class="lineno">10641</span>&#160;     soap.fmimereadopen = mime_read_open; </div><div class="line"><a name="l10642"></a><span class="lineno">10642</span>&#160;     soap.fmimereadclose = mime_read_close; </div><div class="line"><a name="l10643"></a><span class="lineno">10643</span>&#160;     soap.fmimeread = mime_read; </div><div class="line"><a name="l10644"></a><span class="lineno">10644</span>&#160;     image.__ptr = (unsigned char*)fd; // must set to non-NULL (this is our fd handle which we need in the callbacks) </div><div class="line"><a name="l10645"></a><span class="lineno">10645</span>&#160;     image.__size = sb.st_size; // must set size </div><div class="line"><a name="l10646"></a><span class="lineno">10646</span>&#160;   } </div><div class="line"><a name="l10647"></a><span class="lineno">10647</span>&#160;   else </div><div class="line"><a name="l10648"></a><span class="lineno">10648</span>&#160;   {</div><div class="line"><a name="l10649"></a><span class="lineno">10649</span>&#160;     // don&#39;t know the size, so buffer it </div><div class="line"><a name="l10650"></a><span class="lineno">10650</span>&#160;     size_t i; </div><div class="line"><a name="l10651"></a><span class="lineno">10651</span>&#160;     int c; </div><div class="line"><a name="l10652"></a><span class="lineno">10652</span>&#160;     image.__ptr = (unsigned char*)soap_malloc(&amp;soap, MAX_FILE_SIZE); </div><div class="line"><a name="l10653"></a><span class="lineno">10653</span>&#160;     for (i = 0; i &lt; MAX_FILE_SIZE; i++) </div><div class="line"><a name="l10654"></a><span class="lineno">10654</span>&#160;     { </div><div class="line"><a name="l10655"></a><span class="lineno">10655</span>&#160;       if ((c = fgetc(fd)) == EOF) </div><div class="line"><a name="l10656"></a><span class="lineno">10656</span>&#160;         break; </div><div class="line"><a name="l10657"></a><span class="lineno">10657</span>&#160;       image.__ptr[i] = c; </div><div class="line"><a name="l10658"></a><span class="lineno">10658</span>&#160;     } </div><div class="line"><a name="l10659"></a><span class="lineno">10659</span>&#160;     fclose(fd); </div><div class="line"><a name="l10660"></a><span class="lineno">10660</span>&#160;     image.__size = i; </div><div class="line"><a name="l10661"></a><span class="lineno">10661</span>&#160;   } </div><div class="line"><a name="l10662"></a><span class="lineno">10662</span>&#160;   image.type = &quot;image/jpeg&quot;; // MIME type </div><div class="line"><a name="l10663"></a><span class="lineno">10663</span>&#160;   image.options = &quot;This is my picture&quot;; // description of object </div><div class="line"><a name="l10664"></a><span class="lineno">10664</span>&#160;   soap_call_ns__method(&amp;soap, ...); </div><div class="line"><a name="l10665"></a><span class="lineno">10665</span>&#160;   ... </div><div class="line"><a name="l10666"></a><span class="lineno">10666</span>&#160;} </div><div class="line"><a name="l10667"></a><span class="lineno">10667</span>&#160;void *mime_read_open(struct soap *soap, void *handle, const char *id, const char *type, const char *description) </div><div class="line"><a name="l10668"></a><span class="lineno">10668</span>&#160;{</div><div class="line"><a name="l10669"></a><span class="lineno">10669</span>&#160;  return handle; </div><div class="line"><a name="l10670"></a><span class="lineno">10670</span>&#160;} </div><div class="line"><a name="l10671"></a><span class="lineno">10671</span>&#160;void mime_read_close(struct soap *soap, void *handle) </div><div class="line"><a name="l10672"></a><span class="lineno">10672</span>&#160;{</div><div class="line"><a name="l10673"></a><span class="lineno">10673</span>&#160;  fclose((FILE*)handle); </div><div class="line"><a name="l10674"></a><span class="lineno">10674</span>&#160;} </div><div class="line"><a name="l10675"></a><span class="lineno">10675</span>&#160;size_t mime_read(struct soap *soap, void *handle, char *buf, size_t len) </div><div class="line"><a name="l10676"></a><span class="lineno">10676</span>&#160;{</div><div class="line"><a name="l10677"></a><span class="lineno">10677</span>&#160;  return fread(buf, 1, len, (FILE*)handle); </div><div class="line"><a name="l10678"></a><span class="lineno">10678</span>&#160;}</div><div class="line"><a name="l10679"></a><span class="lineno">10679</span>&#160;```</div><div class="line"><a name="l10680"></a><span class="lineno">10680</span>&#160;</div><div class="line"><a name="l10681"></a><span class="lineno">10681</span>&#160;The following example illustrates the streaming of a MTOM/MIME attachment into a file by a client:</div><div class="line"><a name="l10682"></a><span class="lineno">10682</span>&#160;</div><div class="line"><a name="l10683"></a><span class="lineno">10683</span>&#160;```cpp</div><div class="line"><a name="l10684"></a><span class="lineno">10684</span>&#160;int main() </div><div class="line"><a name="l10685"></a><span class="lineno">10685</span>&#160;{</div><div class="line"><a name="l10686"></a><span class="lineno">10686</span>&#160;  struct soap soap; </div><div class="line"><a name="l10687"></a><span class="lineno">10687</span>&#160;  soap_init(&amp;soap); </div><div class="line"><a name="l10688"></a><span class="lineno">10688</span>&#160;  soap.fmimewriteopen = mime_write_open; </div><div class="line"><a name="l10689"></a><span class="lineno">10689</span>&#160;  soap.fmimewriteclose = mime_write_close; </div><div class="line"><a name="l10690"></a><span class="lineno">10690</span>&#160;  soap.fmimewrite = mime_write; </div><div class="line"><a name="l10691"></a><span class="lineno">10691</span>&#160;  soap_call_ns__method(&amp;soap, ...); </div><div class="line"><a name="l10692"></a><span class="lineno">10692</span>&#160;  ... </div><div class="line"><a name="l10693"></a><span class="lineno">10693</span>&#160;} </div><div class="line"><a name="l10694"></a><span class="lineno">10694</span>&#160;void *mime_write_open(struct soap *soap, const char *id, const char *type, const char *description, enum soap_mime_encoding encoding) </div><div class="line"><a name="l10695"></a><span class="lineno">10695</span>&#160;{ </div><div class="line"><a name="l10696"></a><span class="lineno">10696</span>&#160;   FILE *handle = fopen(&quot;somefile&quot;, &quot;wb&quot;); </div><div class="line"><a name="l10697"></a><span class="lineno">10697</span>&#160;   // We ignore the MIME content transfer encoding here, but should check </div><div class="line"><a name="l10698"></a><span class="lineno">10698</span>&#160;   if (!handle) </div><div class="line"><a name="l10699"></a><span class="lineno">10699</span>&#160;   { </div><div class="line"><a name="l10700"></a><span class="lineno">10700</span>&#160;     soap-&gt;error = SOAP_EOF; </div><div class="line"><a name="l10701"></a><span class="lineno">10701</span>&#160;     soap-&gt;errnum = errno; // get reason </div><div class="line"><a name="l10702"></a><span class="lineno">10702</span>&#160;   } </div><div class="line"><a name="l10703"></a><span class="lineno">10703</span>&#160;   return (void*)handle; </div><div class="line"><a name="l10704"></a><span class="lineno">10704</span>&#160;} </div><div class="line"><a name="l10705"></a><span class="lineno">10705</span>&#160;void mime_write_close(struct soap *soap, void *handle) </div><div class="line"><a name="l10706"></a><span class="lineno">10706</span>&#160;{</div><div class="line"><a name="l10707"></a><span class="lineno">10707</span>&#160;  fclose((FILE*)handle); </div><div class="line"><a name="l10708"></a><span class="lineno">10708</span>&#160;} </div><div class="line"><a name="l10709"></a><span class="lineno">10709</span>&#160;int mime_write(struct soap *soap, void *handle, const char *buf, size_t len) </div><div class="line"><a name="l10710"></a><span class="lineno">10710</span>&#160;{ </div><div class="line"><a name="l10711"></a><span class="lineno">10711</span>&#160;   size_t nwritten; </div><div class="line"><a name="l10712"></a><span class="lineno">10712</span>&#160;   while (len) </div><div class="line"><a name="l10713"></a><span class="lineno">10713</span>&#160;   { </div><div class="line"><a name="l10714"></a><span class="lineno">10714</span>&#160;     nwritten = fwrite(buf, 1, len, (FILE*)handle); </div><div class="line"><a name="l10715"></a><span class="lineno">10715</span>&#160;     if (!nwritten) </div><div class="line"><a name="l10716"></a><span class="lineno">10716</span>&#160;     { </div><div class="line"><a name="l10717"></a><span class="lineno">10717</span>&#160;       soap-&gt;errnum = errno; // get reason </div><div class="line"><a name="l10718"></a><span class="lineno">10718</span>&#160;       return SOAP_EOF; </div><div class="line"><a name="l10719"></a><span class="lineno">10719</span>&#160;     } </div><div class="line"><a name="l10720"></a><span class="lineno">10720</span>&#160;     len -= nwritten; </div><div class="line"><a name="l10721"></a><span class="lineno">10721</span>&#160;     buf += nwritten; </div><div class="line"><a name="l10722"></a><span class="lineno">10722</span>&#160;   } </div><div class="line"><a name="l10723"></a><span class="lineno">10723</span>&#160;   return SOAP_OK; </div><div class="line"><a name="l10724"></a><span class="lineno">10724</span>&#160;}</div><div class="line"><a name="l10725"></a><span class="lineno">10725</span>&#160;```</div><div class="line"><a name="l10726"></a><span class="lineno">10726</span>&#160;</div><div class="line"><a name="l10727"></a><span class="lineno">10727</span>&#160;Note that compression can be used with MTOM/MIME to compress the entire message.</div><div class="line"><a name="l10728"></a><span class="lineno">10728</span>&#160;However, compression requires buffering to determine the HTTP content length</div><div class="line"><a name="l10729"></a><span class="lineno">10729</span>&#160;header, which cancels the benefits of streaming MTOM/MIME. To avoid this, you should</div><div class="line"><a name="l10730"></a><span class="lineno">10730</span>&#160;use chunked HTTP (with the output-mode `SOAP_IO_CHUNK` flag) with</div><div class="line"><a name="l10731"></a><span class="lineno">10731</span>&#160;compression and streaming MTOM/MIME. At the server side, when you set</div><div class="line"><a name="l10732"></a><span class="lineno">10732</span>&#160;`SOAP_IO_CHUNK` before calling `soap_serve`, gSOAP will</div><div class="line"><a name="l10733"></a><span class="lineno">10733</span>&#160;automatically revert to buffering (`SOAP_IO_STORE` flag is set).  You can</div><div class="line"><a name="l10734"></a><span class="lineno">10734</span>&#160;check this flag with `(soap-&gt;omode &amp; SOAP_IO) == SOAP_IO_CHUNK` to see</div><div class="line"><a name="l10735"></a><span class="lineno">10735</span>&#160;if the client accepts chunking. More information about streaming chunked MTOM/MIME</div><div class="line"><a name="l10736"></a><span class="lineno">10736</span>&#160;can be found in Section \ref mimechunking .</div><div class="line"><a name="l10737"></a><span class="lineno">10737</span>&#160;</div><div class="line"><a name="l10738"></a><span class="lineno">10738</span>&#160;Note that the example above for `mime_read` uses a handle that points to the open file</div><div class="line"><a name="l10739"></a><span class="lineno">10739</span>&#160;`FILE*`.</div><div class="line"><a name="l10740"></a><span class="lineno">10740</span>&#160;The simple example above is not recommended when the</div><div class="line"><a name="l10741"></a><span class="lineno">10741</span>&#160;platform imposes a limit on the number of open file descriptors.</div><div class="line"><a name="l10742"></a><span class="lineno">10742</span>&#160;You can use the handle to pass along more information than just</div><div class="line"><a name="l10743"></a><span class="lineno">10743</span>&#160;the file descriptor. So for example, when the number of open file descriptors</div><div class="line"><a name="l10744"></a><span class="lineno">10744</span>&#160;is limited on your platform, you should let the handle point to a structure</div><div class="line"><a name="l10745"></a><span class="lineno">10745</span>&#160;with file-related information. The C++ example below illustrates this:</div><div class="line"><a name="l10746"></a><span class="lineno">10746</span>&#160;</div><div class="line"><a name="l10747"></a><span class="lineno">10747</span>&#160;```cpp</div><div class="line"><a name="l10748"></a><span class="lineno">10748</span>&#160;file.xop__Include = soap_new__xop__Include(soap); </div><div class="line"><a name="l10749"></a><span class="lineno">10749</span>&#160;file.xop__Include-&gt;id = NULL; </div><div class="line"><a name="l10750"></a><span class="lineno">10750</span>&#160;file.xop__Include-&gt;type = type; </div><div class="line"><a name="l10751"></a><span class="lineno">10751</span>&#160;file.xop__Include-&gt;options = NULL; </div><div class="line"><a name="l10752"></a><span class="lineno">10752</span>&#160;</div><div class="line"><a name="l10753"></a><span class="lineno">10753</span>&#160;file.xmime5__contentType = type; </div><div class="line"><a name="l10754"></a><span class="lineno">10754</span>&#160;file.filename = filename; </div><div class="line"><a name="l10755"></a><span class="lineno">10755</span>&#160;</div><div class="line"><a name="l10756"></a><span class="lineno">10756</span>&#160;// The object holding all information to read data </div><div class="line"><a name="l10757"></a><span class="lineno">10757</span>&#160;FileStreamIn *ins = new FileStreamIn(errorhandler); </div><div class="line"><a name="l10758"></a><span class="lineno">10758</span>&#160;ins-&gt;setFilePath(path); </div><div class="line"><a name="l10759"></a><span class="lineno">10759</span>&#160;ins-&gt;setFileName(filename); </div><div class="line"><a name="l10760"></a><span class="lineno">10760</span>&#160;</div><div class="line"><a name="l10761"></a><span class="lineno">10761</span>&#160;file.xop__Include-&gt;__size = size; </div><div class="line"><a name="l10762"></a><span class="lineno">10762</span>&#160;file.xop__Include-&gt;__ptr = (unsigned char*)ins;</div><div class="line"><a name="l10763"></a><span class="lineno">10763</span>&#160;```</div><div class="line"><a name="l10764"></a><span class="lineno">10764</span>&#160;</div><div class="line"><a name="l10765"></a><span class="lineno">10765</span>&#160;To read the MTOM data for transmission:</div><div class="line"><a name="l10766"></a><span class="lineno">10766</span>&#160;</div><div class="line"><a name="l10767"></a><span class="lineno">10767</span>&#160;```cpp</div><div class="line"><a name="l10768"></a><span class="lineno">10768</span>&#160;void *mime_read_open(struct soap *soap, void *handle, const char *id, const char *type, const char *description) </div><div class="line"><a name="l10769"></a><span class="lineno">10769</span>&#160;{ </div><div class="line"><a name="l10770"></a><span class="lineno">10770</span>&#160;  if (!handle) </div><div class="line"><a name="l10771"></a><span class="lineno">10771</span>&#160;    return NULL; </div><div class="line"><a name="l10772"></a><span class="lineno">10772</span>&#160;   FileStreamIn *ins = (FileStreamIn*)handle; </div><div class="line"><a name="l10773"></a><span class="lineno">10773</span>&#160;   if (!ins-&gt;open()) </div><div class="line"><a name="l10774"></a><span class="lineno">10774</span>&#160;  { </div><div class="line"><a name="l10775"></a><span class="lineno">10775</span>&#160;     soap-&gt;error = SOAP_ERR; </div><div class="line"><a name="l10776"></a><span class="lineno">10776</span>&#160;     return NULL; </div><div class="line"><a name="l10777"></a><span class="lineno">10777</span>&#160;  } </div><div class="line"><a name="l10778"></a><span class="lineno">10778</span>&#160;   return handle; </div><div class="line"><a name="l10779"></a><span class="lineno">10779</span>&#160;} </div><div class="line"><a name="l10780"></a><span class="lineno">10780</span>&#160;void mime_read_close(struct soap *soap, void *handle) </div><div class="line"><a name="l10781"></a><span class="lineno">10781</span>&#160;{ </div><div class="line"><a name="l10782"></a><span class="lineno">10782</span>&#160;   if (!handle) </div><div class="line"><a name="l10783"></a><span class="lineno">10783</span>&#160;     \return; </div><div class="line"><a name="l10784"></a><span class="lineno">10784</span>&#160;   FileStreamIn *ins = (FileStreamIn*)handle; </div><div class="line"><a name="l10785"></a><span class="lineno">10785</span>&#160;   delete ins; </div><div class="line"><a name="l10786"></a><span class="lineno">10786</span>&#160;} </div><div class="line"><a name="l10787"></a><span class="lineno">10787</span>&#160;size_t mime_read(struct soap *soap, void *handle, char *buf, size_t len) </div><div class="line"><a name="l10788"></a><span class="lineno">10788</span>&#160;{ </div><div class="line"><a name="l10789"></a><span class="lineno">10789</span>&#160;   if (!handle) </div><div class="line"><a name="l10790"></a><span class="lineno">10790</span>&#160;     return 0; </div><div class="line"><a name="l10791"></a><span class="lineno">10791</span>&#160;   FileStreamIn *ins = (FileStreamIn*)handle; </div><div class="line"><a name="l10792"></a><span class="lineno">10792</span>&#160;   size_t nread = ins-&gt;read(buf, len); </div><div class="line"><a name="l10793"></a><span class="lineno">10793</span>&#160;   if (ins-&gt;streamError()) </div><div class="line"><a name="l10794"></a><span class="lineno">10794</span>&#160;  { </div><div class="line"><a name="l10795"></a><span class="lineno">10795</span>&#160;     soap-&gt;error = ins-&gt;streamError(); </div><div class="line"><a name="l10796"></a><span class="lineno">10796</span>&#160;     return 0; </div><div class="line"><a name="l10797"></a><span class="lineno">10797</span>&#160;  } </div><div class="line"><a name="l10798"></a><span class="lineno">10798</span>&#160;   return nread; </div><div class="line"><a name="l10799"></a><span class="lineno">10799</span>&#160;}</div><div class="line"><a name="l10800"></a><span class="lineno">10800</span>&#160;```</div><div class="line"><a name="l10801"></a><span class="lineno">10801</span>&#160;</div><div class="line"><a name="l10802"></a><span class="lineno">10802</span>&#160;## Redirecting Inbound MTOM/MIME Streams Based on SOAP Body Content        {#MTOMpoststreaming}</div><div class="line"><a name="l10803"></a><span class="lineno">10803</span>&#160;</div><div class="line"><a name="l10804"></a><span class="lineno">10804</span>&#160;When it is preferable or required to redirect inbound MTOM/MIME attachment</div><div class="line"><a name="l10805"></a><span class="lineno">10805</span>&#160;streams based on SOAP message body content, where for example the names of the</div><div class="line"><a name="l10806"></a><span class="lineno">10806</span>&#160;resources are listed in the SOAP message body, an alternative mechanism must be</div><div class="line"><a name="l10807"></a><span class="lineno">10807</span>&#160;used. This mechanism can be used both at the client and server side.</div><div class="line"><a name="l10808"></a><span class="lineno">10808</span>&#160;</div><div class="line"><a name="l10809"></a><span class="lineno">10809</span>&#160;Because the routing of the streams is accomplished with explicit function</div><div class="line"><a name="l10810"></a><span class="lineno">10810</span>&#160;calls, this method should only be used when required and should not be</div><div class="line"><a name="l10811"></a><span class="lineno">10811</span>&#160;considered optional. That is, when you enable this method, you MUST check for</div><div class="line"><a name="l10812"></a><span class="lineno">10812</span>&#160;pending MTOM/MIME attachments and handle them appropriately. This is true even</div><div class="line"><a name="l10813"></a><span class="lineno">10813</span>&#160;when you don&#39;t expect MTOM/MIME attachments in the payload, because the peer</div><div class="line"><a name="l10814"></a><span class="lineno">10814</span>&#160;may trick you by sending attachments anyway and you should be prepared to</div><div class="line"><a name="l10815"></a><span class="lineno">10815</span>&#160;accept or reject them.</div><div class="line"><a name="l10816"></a><span class="lineno">10816</span>&#160;</div><div class="line"><a name="l10817"></a><span class="lineno">10817</span>&#160;The explicit MTOM/MIME streaming mechanism consists of three API functions:</div><div class="line"><a name="l10818"></a><span class="lineno">10818</span>&#160;</div><div class="line"><a name="l10819"></a><span class="lineno">10819</span>&#160;* `void soap_post_check_mime_attachments(struct soap *soap)` </div><div class="line"><a name="l10820"></a><span class="lineno">10820</span>&#160;  Enables post-message body inbound streaming MTOM/MIME attachments. The</div><div class="line"><a name="l10821"></a><span class="lineno">10821</span>&#160;  presence of attachments must be explicitly checked using the function below.</div><div class="line"><a name="l10822"></a><span class="lineno">10822</span>&#160;</div><div class="line"><a name="l10823"></a><span class="lineno">10823</span>&#160;* `int soap_check_mime_attachments(struct soap *soap)`</div><div class="line"><a name="l10824"></a><span class="lineno">10824</span>&#160;  Should be called after a client-side call (e.g. `soap_call_ns__method`) to</div><div class="line"><a name="l10825"></a><span class="lineno">10825</span>&#160;  check the presence of attachments. Returns 1 (true) when attachments are</div><div class="line"><a name="l10826"></a><span class="lineno">10826</span>&#160;  present. If present, each attachment MUST be processed with the function</div><div class="line"><a name="l10827"></a><span class="lineno">10827</span>&#160;  below.</div><div class="line"><a name="l10828"></a><span class="lineno">10828</span>&#160;</div><div class="line"><a name="l10829"></a><span class="lineno">10829</span>&#160;* `struct soap_multipart *soap_get_mime_attachment(struct soap *soap, void *handle)` </div><div class="line"><a name="l10830"></a><span class="lineno">10830</span>&#160;  Parses an attachment and invokes the MIME callbacks (when set). The `handle`</div><div class="line"><a name="l10831"></a><span class="lineno">10831</span>&#160;  parameter is passed to `fmimewriteopen`. The handle may contain any data that</div><div class="line"><a name="l10832"></a><span class="lineno">10832</span>&#160;  is extracted from the SOAP message body to guide the redirection of the</div><div class="line"><a name="l10833"></a><span class="lineno">10833</span>&#160;  stream in the callbacks. The return value is a struct with a `char *ptr`</div><div class="line"><a name="l10834"></a><span class="lineno">10834</span>&#160;  field that contains the handle value returned by the `fmimewriteopen`</div><div class="line"><a name="l10835"></a><span class="lineno">10835</span>&#160;  callback, and `char *id`, `char *type`, and `char *description` fields with</div><div class="line"><a name="l10836"></a><span class="lineno">10836</span>&#160;  the optional MIME id, type, and description info.</div><div class="line"><a name="l10837"></a><span class="lineno">10837</span>&#160;</div><div class="line"><a name="l10838"></a><span class="lineno">10838</span>&#160;Example client-side code in C:</div><div class="line"><a name="l10839"></a><span class="lineno">10839</span>&#160;</div><div class="line"><a name="l10840"></a><span class="lineno">10840</span>&#160;```cpp</div><div class="line"><a name="l10841"></a><span class="lineno">10841</span>&#160;struct soap *soap = soap_new1(SOAP_ENC_MTOM); </div><div class="line"><a name="l10842"></a><span class="lineno">10842</span>&#160;soap_post_check_mime_attachments(soap); </div><div class="line"><a name="l10843"></a><span class="lineno">10843</span>&#160;... </div><div class="line"><a name="l10844"></a><span class="lineno">10844</span>&#160;if (soap_call_ns__myMethod(soap, ...)) </div><div class="line"><a name="l10845"></a><span class="lineno">10845</span>&#160;   soap_print_fault(soap, stderr); // an error occurred </div><div class="line"><a name="l10846"></a><span class="lineno">10846</span>&#160;else </div><div class="line"><a name="l10847"></a><span class="lineno">10847</span>&#160;{ </div><div class="line"><a name="l10848"></a><span class="lineno">10848</span>&#160;   if (soap_check_mime_attachments(soap))</div><div class="line"><a name="l10849"></a><span class="lineno">10849</span>&#160;   { // attachments are present, channel is still open </div><div class="line"><a name="l10850"></a><span class="lineno">10850</span>&#160;     { </div><div class="line"><a name="l10851"></a><span class="lineno">10851</span>&#160;       \Do </div><div class="line"><a name="l10852"></a><span class="lineno">10852</span>&#160;       { </div><div class="line"><a name="l10853"></a><span class="lineno">10853</span>&#160;         ... // get data &#39;handle&#39; from SOAP response and pass to callbacks </div><div class="line"><a name="l10854"></a><span class="lineno">10854</span>&#160;         ... // set the fmime callbacks, if needed </div><div class="line"><a name="l10855"></a><span class="lineno">10855</span>&#160;         struct soap_multipart *content = soap_get_mime_attachment(soap, (void*)handle); </div><div class="line"><a name="l10856"></a><span class="lineno">10856</span>&#160;         printf(&quot;Received attachment with id=%s and type=%s\n&quot;, content-&gt;id?content-&gt;id:&quot;&quot;, content-&gt;type?content-&gt;type:&quot;&quot;); </div><div class="line"><a name="l10857"></a><span class="lineno">10857</span>&#160;       } while (content); </div><div class="line"><a name="l10858"></a><span class="lineno">10858</span>&#160;       if (soap-&gt;error) </div><div class="line"><a name="l10859"></a><span class="lineno">10859</span>&#160;         soap_print_fault(soap, stderr); </div><div class="line"><a name="l10860"></a><span class="lineno">10860</span>&#160;     } </div><div class="line"><a name="l10861"></a><span class="lineno">10861</span>&#160;   } </div><div class="line"><a name="l10862"></a><span class="lineno">10862</span>&#160;} </div><div class="line"><a name="l10863"></a><span class="lineno">10863</span>&#160;... </div><div class="line"><a name="l10864"></a><span class="lineno">10864</span>&#160;soap_destroy(soap); </div><div class="line"><a name="l10865"></a><span class="lineno">10865</span>&#160;soap_end(soap); </div><div class="line"><a name="l10866"></a><span class="lineno">10866</span>&#160;soap_free(soap); // detach and free context </div><div class="line"><a name="l10867"></a><span class="lineno">10867</span>&#160;```</div><div class="line"><a name="l10868"></a><span class="lineno">10868</span>&#160;</div><div class="line"><a name="l10869"></a><span class="lineno">10869</span>&#160;The server-side service operations are implemented as usual, but with additional checks for MTOM/MIME attachments:</div><div class="line"><a name="l10870"></a><span class="lineno">10870</span>&#160;</div><div class="line"><a name="l10871"></a><span class="lineno">10871</span>&#160;```cpp</div><div class="line"><a name="l10872"></a><span class="lineno">10872</span>&#160;struct soap *soap = soap_new1(SOAP_ENC_MTOM); </div><div class="line"><a name="l10873"></a><span class="lineno">10873</span>&#160;soap_post_check_mime_attachments(soap); </div><div class="line"><a name="l10874"></a><span class="lineno">10874</span>&#160;... </div><div class="line"><a name="l10875"></a><span class="lineno">10875</span>&#160;soap_serve(soap); </div><div class="line"><a name="l10876"></a><span class="lineno">10876</span>&#160;... </div><div class="line"><a name="l10877"></a><span class="lineno">10877</span>&#160;int ns__myMethod(struct soap *soap, ...) </div><div class="line"><a name="l10878"></a><span class="lineno">10878</span>&#160;{</div><div class="line"><a name="l10879"></a><span class="lineno">10879</span>&#160;   ... // server-side processing logic </div><div class="line"><a name="l10880"></a><span class="lineno">10880</span>&#160;   if (soap_check_mime_attachments(soap))</div><div class="line"><a name="l10881"></a><span class="lineno">10881</span>&#160;   { // attachments are present, channel is still open </div><div class="line"><a name="l10882"></a><span class="lineno">10882</span>&#160;     { </div><div class="line"><a name="l10883"></a><span class="lineno">10883</span>&#160;       \Do </div><div class="line"><a name="l10884"></a><span class="lineno">10884</span>&#160;       { </div><div class="line"><a name="l10885"></a><span class="lineno">10885</span>&#160;         ... // get data &#39;handle&#39; from SOAP request and pass to callbacks </div><div class="line"><a name="l10886"></a><span class="lineno">10886</span>&#160;         ... // set the fmime callbacks, if needed </div><div class="line"><a name="l10887"></a><span class="lineno">10887</span>&#160;         struct soap_multipart *content = soap_get_mime_attachment(soap, (void*)handle); </div><div class="line"><a name="l10888"></a><span class="lineno">10888</span>&#160;         printf(&quot;Received attachment with id=%s and type=%s\n&quot;, content-&gt;id?content-&gt;id:&quot;&quot;, content-&gt;type?content-&gt;type:&quot;&quot;); </div><div class="line"><a name="l10889"></a><span class="lineno">10889</span>&#160;       } while (content); </div><div class="line"><a name="l10890"></a><span class="lineno">10890</span>&#160;       if (soap-&gt;error) </div><div class="line"><a name="l10891"></a><span class="lineno">10891</span>&#160;         return soap-&gt;error; </div><div class="line"><a name="l10892"></a><span class="lineno">10892</span>&#160;     } </div><div class="line"><a name="l10893"></a><span class="lineno">10893</span>&#160;   } </div><div class="line"><a name="l10894"></a><span class="lineno">10894</span>&#160;   ... // server-side processing logic </div><div class="line"><a name="l10895"></a><span class="lineno">10895</span>&#160;   return SOAP_OK; </div><div class="line"><a name="l10896"></a><span class="lineno">10896</span>&#160;}</div><div class="line"><a name="l10897"></a><span class="lineno">10897</span>&#160;```</div><div class="line"><a name="l10898"></a><span class="lineno">10898</span>&#160;</div><div class="line"><a name="l10899"></a><span class="lineno">10899</span>&#160;## Streaming Chunked MTOM/MIME        {#mimechunking}</div><div class="line"><a name="l10900"></a><span class="lineno">10900</span>&#160;</div><div class="line"><a name="l10901"></a><span class="lineno">10901</span>&#160;gSOAP automatically handles inbound chunked MTOM/MIME attachments (streaming or</div><div class="line"><a name="l10902"></a><span class="lineno">10902</span>&#160;non-streaming).  To transmit outbound MTOM/MIME attachments, the attachment sizes</div><div class="line"><a name="l10903"></a><span class="lineno">10903</span>&#160;MUST be determined in advance to calculate HTTP message length required to</div><div class="line"><a name="l10904"></a><span class="lineno">10904</span>&#160;stream MTOM/MIME over HTTP.  However, gSOAP also supports the transmission of</div><div class="line"><a name="l10905"></a><span class="lineno">10905</span>&#160;outbound chunked MTOM/MIME attachments without prior determination of MTOM/MIME</div><div class="line"><a name="l10906"></a><span class="lineno">10906</span>&#160;attachment sizes when certain conditions are met.  These conditions require</div><div class="line"><a name="l10907"></a><span class="lineno">10907</span>&#160;either non-HTTP transport (use the output-mode `SOAP_ENC_PLAIN` flag), or</div><div class="line"><a name="l10908"></a><span class="lineno">10908</span>&#160;chunked HTTP transport (use the output-mode `SOAP_IO_CHUNK` flag).  You</div><div class="line"><a name="l10909"></a><span class="lineno">10909</span>&#160;can also use the `SOAP_IO_STORE` flag (which is also used automatically</div><div class="line"><a name="l10910"></a><span class="lineno">10910</span>&#160;with compression to determine the HTTP content length header) but that cancels</div><div class="line"><a name="l10911"></a><span class="lineno">10911</span>&#160;the benefits of streaming MTOM/MIME.</div><div class="line"><a name="l10912"></a><span class="lineno">10912</span>&#160;</div><div class="line"><a name="l10913"></a><span class="lineno">10913</span>&#160;To stream chunked MTOM/MIME, set the `__size` field of an attachment to</div><div class="line"><a name="l10914"></a><span class="lineno">10914</span>&#160;zero and enable HTTP chunking.  The MTOM/MIME `fmimeread` callback then</div><div class="line"><a name="l10915"></a><span class="lineno">10915</span>&#160;fetches data in chunks of any size between 1 and the value of the `len`</div><div class="line"><a name="l10916"></a><span class="lineno">10916</span>&#160;argument. The `fmimeread` callback should return 0 upon reaching the end of</div><div class="line"><a name="l10917"></a><span class="lineno">10917</span>&#160;the data stream.</div><div class="line"><a name="l10918"></a><span class="lineno">10918</span>&#160;</div><div class="line"><a name="l10919"></a><span class="lineno">10919</span>&#160;# XML Validation        {#validation}</div><div class="line"><a name="l10920"></a><span class="lineno">10920</span>&#160;</div><div class="line"><a name="l10921"></a><span class="lineno">10921</span>&#160;The gSOAP XML parser applies basic rules to validate content. Constraints are not automatically verified unless explicitly</div><div class="line"><a name="l10922"></a><span class="lineno">10922</span>&#160;set using flags.  This helps to avoid interoperability problems with toolkits that do</div><div class="line"><a name="l10923"></a><span class="lineno">10923</span>&#160;not strictly enforce validation rules. In addition, we cannot always use strict</div><div class="line"><a name="l10924"></a><span class="lineno">10924</span>&#160;validation for SOAP RPC encoded messages, since SOAP RPC encoding adopts a very</div><div class="line"><a name="l10925"></a><span class="lineno">10925</span>&#160;loose serialization format.</div><div class="line"><a name="l10926"></a><span class="lineno">10926</span>&#160;</div><div class="line"><a name="l10927"></a><span class="lineno">10927</span>&#160;Validation constraints are enabled with the `SOAP_XML_STRICT` input mode</div><div class="line"><a name="l10928"></a><span class="lineno">10928</span>&#160;flag set, e.g. with `soap_set_imode(soap, SOAP_XML_STRICT)` or</div><div class="line"><a name="l10929"></a><span class="lineno">10929</span>&#160;`soap_new(SOAP_XML_STRICT)`, see Section \ref flags  for the complete list</div><div class="line"><a name="l10930"></a><span class="lineno">10930</span>&#160;of flags. </div><div class="line"><a name="l10931"></a><span class="lineno">10931</span>&#160;</div><div class="line"><a name="l10932"></a><span class="lineno">10932</span>&#160;## Occurrence Constraints</div><div class="line"><a name="l10933"></a><span class="lineno">10933</span>&#160;</div><div class="line"><a name="l10934"></a><span class="lineno">10934</span>&#160;### Default Values</div><div class="line"><a name="l10935"></a><span class="lineno">10935</span>&#160;</div><div class="line"><a name="l10936"></a><span class="lineno">10936</span>&#160;Default values can be defined for optional elements and attributes, which means</div><div class="line"><a name="l10937"></a><span class="lineno">10937</span>&#160;that the default value will be used when the element or attribute value is not</div><div class="line"><a name="l10938"></a><span class="lineno">10938</span>&#160;present in the parsed XML. See also Section \ref default  and  examples in</div><div class="line"><a name="l10939"></a><span class="lineno">10939</span>&#160;subsequent subsections below.</div><div class="line"><a name="l10940"></a><span class="lineno">10940</span>&#160;</div><div class="line"><a name="l10941"></a><span class="lineno">10941</span>&#160;Default values must be primitive types, integer, float, string, etc.</div><div class="line"><a name="l10942"></a><span class="lineno">10942</span>&#160;Default values can be specified for struct and class members, as shown in the example below:</div><div class="line"><a name="l10943"></a><span class="lineno">10943</span>&#160;</div><div class="line"><a name="l10944"></a><span class="lineno">10944</span>&#160;```cpp</div><div class="line"><a name="l10945"></a><span class="lineno">10945</span>&#160;struct ns__MyRecord </div><div class="line"><a name="l10946"></a><span class="lineno">10946</span>&#160;{ </div><div class="line"><a name="l10947"></a><span class="lineno">10947</span>&#160;  int n = 5; // optional element with default value 5 </div><div class="line"><a name="l10948"></a><span class="lineno">10948</span>&#160;  char *name = &quot;none&quot;; // optional element with default value &quot;none&quot; </div><div class="line"><a name="l10949"></a><span class="lineno">10949</span>&#160;  @ enum ns__color { RED, WHITE, BLUE } color = RED; // optional attribute with default value RED </div><div class="line"><a name="l10950"></a><span class="lineno">10950</span>&#160;};</div><div class="line"><a name="l10951"></a><span class="lineno">10951</span>&#160;```</div><div class="line"><a name="l10952"></a><span class="lineno">10952</span>&#160;</div><div class="line"><a name="l10953"></a><span class="lineno">10953</span>&#160;Upon deserialization of absent data, these members will be set accordingly.</div><div class="line"><a name="l10954"></a><span class="lineno">10954</span>&#160;When classes are instantiated with `soap_new_ClassName` the instance will</div><div class="line"><a name="l10955"></a><span class="lineno">10955</span>&#160;be initialized with default values.</div><div class="line"><a name="l10956"></a><span class="lineno">10956</span>&#160;</div><div class="line"><a name="l10957"></a><span class="lineno">10957</span>&#160;### Elements with minOccurs and maxOccurs Restrictions</div><div class="line"><a name="l10958"></a><span class="lineno">10958</span>&#160;</div><div class="line"><a name="l10959"></a><span class="lineno">10959</span>&#160;To force the validation of minOccurs and maxOccurs contraints the `SOAP_XML_STRICT` input mode flag must be set.</div><div class="line"><a name="l10960"></a><span class="lineno">10960</span>&#160;The minOccurs and maxOccurs constraints are specified for fields of a struct and members of a class in a header file using the following syntax:</div><div class="line"><a name="l10961"></a><span class="lineno">10961</span>&#160;</div><div class="line"><a name="l10962"></a><span class="lineno">10962</span>&#160;```cpp</div><div class="line"><a name="l10963"></a><span class="lineno">10963</span>&#160;Type fieldname [optional: nullptr] [optional: minOccurs[optional: :maxOccurs]] [optional: = value]</div><div class="line"><a name="l10964"></a><span class="lineno">10964</span>&#160;```</div><div class="line"><a name="l10965"></a><span class="lineno">10965</span>&#160;</div><div class="line"><a name="l10966"></a><span class="lineno">10966</span>&#160;The minOccurs and maxOccurs values must be integer literals. Also a default initialization value can be provided. When minOccurs is not specified it is assumed to be one (1) for non-pointer `fieldname` members that are elements and zero (0) for `fieldname` members that are pointers or are attributes (i.e. have a `@` qualifier).</div><div class="line"><a name="l10967"></a><span class="lineno">10967</span>&#160;</div><div class="line"><a name="l10968"></a><span class="lineno">10968</span>&#160;The nillable property can by specified by adding a nullptr before the minOccurs (version 2.8.24 or greater).</div><div class="line"><a name="l10969"></a><span class="lineno">10969</span>&#160;</div><div class="line"><a name="l10970"></a><span class="lineno">10970</span>&#160;A fixed initialization value can be specified with `==` (version 2.8.48 or greater).</div><div class="line"><a name="l10971"></a><span class="lineno">10971</span>&#160;</div><div class="line"><a name="l10972"></a><span class="lineno">10972</span>&#160;For example</div><div class="line"><a name="l10973"></a><span class="lineno">10973</span>&#160;</div><div class="line"><a name="l10974"></a><span class="lineno">10974</span>&#160;```cpp</div><div class="line"><a name="l10975"></a><span class="lineno">10975</span>&#160;struct ns__MyRecord </div><div class="line"><a name="l10976"></a><span class="lineno">10976</span>&#160;{ </div><div class="line"><a name="l10977"></a><span class="lineno">10977</span>&#160;   int n 0 = 5; // element with default value 5, minOccurs=0, maxOccurs=1</div><div class="line"><a name="l10978"></a><span class="lineno">10978</span>&#160;   int m; // element with minOccurs=1 </div><div class="line"><a name="l10979"></a><span class="lineno">10979</span>&#160;   int *k nullptr 1; // element with minOccurs=1 and nillable=true </div><div class="line"><a name="l10980"></a><span class="lineno">10980</span>&#160;   int v == 2; // element with minOccurs=1 and fixed value 2 </div><div class="line"><a name="l10981"></a><span class="lineno">10981</span>&#160;   int __size 0:10; // sequence &lt;item&gt; with minOccurs=0, maxOccurs=10</div><div class="line"><a name="l10982"></a><span class="lineno">10982</span>&#160;   int *item; </div><div class="line"><a name="l10983"></a><span class="lineno">10983</span>&#160;   std::vector&lt;double&gt; nums 2; // sequence &lt;nums&gt; with minOccurs=2, maxOccurs=unbounded </div><div class="line"><a name="l10984"></a><span class="lineno">10984</span>&#160;}; </div><div class="line"><a name="l10985"></a><span class="lineno">10985</span>&#160;struct arrayOfint </div><div class="line"><a name="l10986"></a><span class="lineno">10986</span>&#160;{ </div><div class="line"><a name="l10987"></a><span class="lineno">10987</span>&#160;   int *__ptr 1:100; // minOccurs=1, maxOccurs=100 </div><div class="line"><a name="l10988"></a><span class="lineno">10988</span>&#160;   int size; </div><div class="line"><a name="l10989"></a><span class="lineno">10989</span>&#160;};</div><div class="line"><a name="l10990"></a><span class="lineno">10990</span>&#160;```</div><div class="line"><a name="l10991"></a><span class="lineno">10991</span>&#160;</div><div class="line"><a name="l10992"></a><span class="lineno">10992</span>&#160;</div><div class="line"><a name="l10993"></a><span class="lineno">10993</span>&#160;</div><div class="line"><a name="l10994"></a><span class="lineno">10994</span>&#160;### Required and Prohibited Attributes</div><div class="line"><a name="l10995"></a><span class="lineno">10995</span>&#160;</div><div class="line"><a name="l10996"></a><span class="lineno">10996</span>&#160;Similar to the minOccurs and maxOccurs annotations defined in the previous</div><div class="line"><a name="l10997"></a><span class="lineno">10997</span>&#160;section, attributes in a struct or class can be annotated with occurrence</div><div class="line"><a name="l10998"></a><span class="lineno">10998</span>&#160;constraints to make them optional (0), required (1), or prohibited (0:0).</div><div class="line"><a name="l10999"></a><span class="lineno">10999</span>&#160;Default values can be assigned to optional attributes.</div><div class="line"><a name="l11000"></a><span class="lineno">11000</span>&#160;</div><div class="line"><a name="l11001"></a><span class="lineno">11001</span>&#160;For example</div><div class="line"><a name="l11002"></a><span class="lineno">11002</span>&#160;</div><div class="line"><a name="l11003"></a><span class="lineno">11003</span>&#160;```cpp</div><div class="line"><a name="l11004"></a><span class="lineno">11004</span>&#160;struct ns__MyRecord </div><div class="line"><a name="l11005"></a><span class="lineno">11005</span>&#160;{ </div><div class="line"><a name="l11006"></a><span class="lineno">11006</span>&#160;  @ int m 1; // required attribute (occurs at least once) </div><div class="line"><a name="l11007"></a><span class="lineno">11007</span>&#160;  @ int n = 5; // optional attribute with default value 5</div><div class="line"><a name="l11008"></a><span class="lineno">11008</span>&#160;  @ int o 0; // optional attribute (may or may not occur) </div><div class="line"><a name="l11009"></a><span class="lineno">11009</span>&#160;  @ int p 0:0; // prohibited attribute </div><div class="line"><a name="l11010"></a><span class="lineno">11010</span>&#160;};</div><div class="line"><a name="l11011"></a><span class="lineno">11011</span>&#160;```</div><div class="line"><a name="l11012"></a><span class="lineno">11012</span>&#160;</div><div class="line"><a name="l11013"></a><span class="lineno">11013</span>&#160;Remember to set the `SOAP_XML_STRICT` input mode flag to</div><div class="line"><a name="l11014"></a><span class="lineno">11014</span>&#160;enable the validation of attribute occurrence constraints.</div><div class="line"><a name="l11015"></a><span class="lineno">11015</span>&#160;</div><div class="line"><a name="l11016"></a><span class="lineno">11016</span>&#160;## Value Constraints</div><div class="line"><a name="l11017"></a><span class="lineno">11017</span>&#160;</div><div class="line"><a name="l11018"></a><span class="lineno">11018</span>&#160;### Data Length Restrictions</div><div class="line"><a name="l11019"></a><span class="lineno">11019</span>&#160;</div><div class="line"><a name="l11020"></a><span class="lineno">11020</span>&#160;A schema simpleType is defined with a `typedef` by taking a base primitive to defined a derived simpleType.  For example:</div><div class="line"><a name="l11021"></a><span class="lineno">11021</span>&#160;</div><div class="line"><a name="l11022"></a><span class="lineno">11022</span>&#160;```cpp</div><div class="line"><a name="l11023"></a><span class="lineno">11023</span>&#160;typedef int time__seconds;</div><div class="line"><a name="l11024"></a><span class="lineno">11024</span>&#160;```</div><div class="line"><a name="l11025"></a><span class="lineno">11025</span>&#160;</div><div class="line"><a name="l11026"></a><span class="lineno">11026</span>&#160;This defines the following schema type in `time.xsd`:</div><div class="line"><a name="l11027"></a><span class="lineno">11027</span>&#160;</div><div class="line"><a name="l11028"></a><span class="lineno">11028</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l11029"></a><span class="lineno">11029</span>&#160;```xml</div><div class="line"><a name="l11030"></a><span class="lineno">11030</span>&#160;&lt;simpleType name=&quot;seconds&quot;&gt; </div><div class="line"><a name="l11031"></a><span class="lineno">11031</span>&#160;   &lt;restriction base=&quot;xsd:int&quot;/&gt; </div><div class="line"><a name="l11032"></a><span class="lineno">11032</span>&#160;&lt;/simpleType&gt;</div><div class="line"><a name="l11033"></a><span class="lineno">11033</span>&#160;```</div><div class="line"><a name="l11034"></a><span class="lineno">11034</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l11035"></a><span class="lineno">11035</span>&#160;</div><div class="line"><a name="l11036"></a><span class="lineno">11036</span>&#160;A complexType with simpleContent is defined with a wrapper struct/class:</div><div class="line"><a name="l11037"></a><span class="lineno">11037</span>&#160;</div><div class="line"><a name="l11038"></a><span class="lineno">11038</span>&#160;```cpp</div><div class="line"><a name="l11039"></a><span class="lineno">11039</span>&#160;struct time__date </div><div class="line"><a name="l11040"></a><span class="lineno">11040</span>&#160;{ </div><div class="line"><a name="l11041"></a><span class="lineno">11041</span>&#160;  char *__item; // some custom format date (restriction of string) </div><div class="line"><a name="l11042"></a><span class="lineno">11042</span>&#160;  @ enum time__zone { EST, GMT, ... } zone; </div><div class="line"><a name="l11043"></a><span class="lineno">11043</span>&#160;}</div><div class="line"><a name="l11044"></a><span class="lineno">11044</span>&#160;```</div><div class="line"><a name="l11045"></a><span class="lineno">11045</span>&#160;</div><div class="line"><a name="l11046"></a><span class="lineno">11046</span>&#160;This defines the following schema type in `time.xsd`:</div><div class="line"><a name="l11047"></a><span class="lineno">11047</span>&#160;</div><div class="line"><a name="l11048"></a><span class="lineno">11048</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l11049"></a><span class="lineno">11049</span>&#160;```xml</div><div class="line"><a name="l11050"></a><span class="lineno">11050</span>&#160;&lt;complexType name=&quot;date&quot;&gt; </div><div class="line"><a name="l11051"></a><span class="lineno">11051</span>&#160;   &lt;simpleContent&gt; </div><div class="line"><a name="l11052"></a><span class="lineno">11052</span>&#160;     &lt;extension base=&quot;xsd:string&quot;/&gt; </div><div class="line"><a name="l11053"></a><span class="lineno">11053</span>&#160;   &lt;/simpleContent&gt; </div><div class="line"><a name="l11054"></a><span class="lineno">11054</span>&#160;   &lt;attribute name=&quot;zone&quot; type=&quot;time:zone&quot; use=&quot;optional&quot;/&gt; </div><div class="line"><a name="l11055"></a><span class="lineno">11055</span>&#160;&lt;/complexType&gt;</div><div class="line"><a name="l11056"></a><span class="lineno">11056</span>&#160;&lt;simpleType name=&quot;zone&quot;&gt; </div><div class="line"><a name="l11057"></a><span class="lineno">11057</span>&#160;   &lt;restriction base=&quot;xsd:string&quot;&gt; </div><div class="line"><a name="l11058"></a><span class="lineno">11058</span>&#160;     &lt;enumeration value=&quot;EST&quot;/&gt; </div><div class="line"><a name="l11059"></a><span class="lineno">11059</span>&#160;     &lt;enumeration value=&quot;GMT&quot;/&gt; </div><div class="line"><a name="l11060"></a><span class="lineno">11060</span>&#160;     ... </div><div class="line"><a name="l11061"></a><span class="lineno">11061</span>&#160;   &lt;/restriction&gt; </div><div class="line"><a name="l11062"></a><span class="lineno">11062</span>&#160;&lt;/simpleType&gt;</div><div class="line"><a name="l11063"></a><span class="lineno">11063</span>&#160;```</div><div class="line"><a name="l11064"></a><span class="lineno">11064</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l11065"></a><span class="lineno">11065</span>&#160;</div><div class="line"><a name="l11066"></a><span class="lineno">11066</span>&#160;Data value length constraints of simpleTypes and complexTypes with simpleContent are defined as follows.</div><div class="line"><a name="l11067"></a><span class="lineno">11067</span>&#160;</div><div class="line"><a name="l11068"></a><span class="lineno">11068</span>&#160;```cpp</div><div class="line"><a name="l11069"></a><span class="lineno">11069</span>&#160;typedef char *ns__string256 0:256; // simpleType restriction of string with max length 256 characters </div><div class="line"><a name="l11070"></a><span class="lineno">11070</span>&#160;typedef char *ns__string10 10:10; // simpleType restriction of string with length of 10 characters </div><div class="line"><a name="l11071"></a><span class="lineno">11071</span>&#160;typedef std::string *ns__string8 8; // simpleType restriction of string with at least 8 characters </div><div class="line"><a name="l11072"></a><span class="lineno">11072</span>&#160;struct ns__data // simpleContent wrapper </div><div class="line"><a name="l11073"></a><span class="lineno">11073</span>&#160;{ </div><div class="line"><a name="l11074"></a><span class="lineno">11074</span>&#160;  char *__item :256; // simpleContent with at most 256 characters </div><div class="line"><a name="l11075"></a><span class="lineno">11075</span>&#160;  @ char *name 1; // required name attribute </div><div class="line"><a name="l11076"></a><span class="lineno">11076</span>&#160;}; </div><div class="line"><a name="l11077"></a><span class="lineno">11077</span>&#160;struct time__date // simpleContent wrapper </div><div class="line"><a name="l11078"></a><span class="lineno">11078</span>&#160;{ </div><div class="line"><a name="l11079"></a><span class="lineno">11079</span>&#160;  char *__item :100; </div><div class="line"><a name="l11080"></a><span class="lineno">11080</span>&#160;  @ enum time__zone { EST, GMT, ... } zone = GMT; </div><div class="line"><a name="l11081"></a><span class="lineno">11081</span>&#160;}</div><div class="line"><a name="l11082"></a><span class="lineno">11082</span>&#160;```</div><div class="line"><a name="l11083"></a><span class="lineno">11083</span>&#160;</div><div class="line"><a name="l11084"></a><span class="lineno">11084</span>&#160;Remember to set the `SOAP_XML_STRICT` input mode flag to</div><div class="line"><a name="l11085"></a><span class="lineno">11085</span>&#160;enable the validation of value length constraints.</div><div class="line"><a name="l11086"></a><span class="lineno">11086</span>&#160;</div><div class="line"><a name="l11087"></a><span class="lineno">11087</span>&#160;Use compiler flag `WITH_REPLACE_ILLEGAL_UTF8` to force strict UTF-8 text</div><div class="line"><a name="l11088"></a><span class="lineno">11088</span>&#160;conversions, which replaces invalid UTF-8 with U+FFFD.  Compile</div><div class="line"><a name="l11089"></a><span class="lineno">11089</span>&#160;`stdsoap2.c` and `stdsoap2.cpp` with this flag.</div><div class="line"><a name="l11090"></a><span class="lineno">11090</span>&#160;</div><div class="line"><a name="l11091"></a><span class="lineno">11091</span>&#160;### Value Range Restrictions</div><div class="line"><a name="l11092"></a><span class="lineno">11092</span>&#160;</div><div class="line"><a name="l11093"></a><span class="lineno">11093</span>&#160;Similar to data length constraints for string-based data, integer and floatig point value range</div><div class="line"><a name="l11094"></a><span class="lineno">11094</span>&#160;constraints on numeric simpleTypes and complexTypes with simpleContent are</div><div class="line"><a name="l11095"></a><span class="lineno">11095</span>&#160;declared with `low : high`, where `low` and `high` are optional.</div><div class="line"><a name="l11096"></a><span class="lineno">11096</span>&#160;</div><div class="line"><a name="l11097"></a><span class="lineno">11097</span>&#160;As of gSOAP 2.8.26, floating point value ranges and integer ranges can be</div><div class="line"><a name="l11098"></a><span class="lineno">11098</span>&#160;exclusive by adding &lt; on either side of the &#39;`:`&#39; range operator:</div><div class="line"><a name="l11099"></a><span class="lineno">11099</span>&#160;</div><div class="line"><a name="l11100"></a><span class="lineno">11100</span>&#160;Range          | Validitation check</div><div class="line"><a name="l11101"></a><span class="lineno">11101</span>&#160;-------------- | ------------------</div><div class="line"><a name="l11102"></a><span class="lineno">11102</span>&#160;`1           ` | 1 &lt;= x</div><div class="line"><a name="l11103"></a><span class="lineno">11103</span>&#160;`1 :         ` | 1 &lt;= x</div><div class="line"><a name="l11104"></a><span class="lineno">11104</span>&#160;`  : 10      ` | x &lt;= 10</div><div class="line"><a name="l11105"></a><span class="lineno">11105</span>&#160;`1 : 10      ` | 1 &lt;= x &lt;= 10</div><div class="line"><a name="l11106"></a><span class="lineno">11106</span>&#160;`1 &lt; : &lt; 10  ` | 1 &lt; x &lt; 10</div><div class="line"><a name="l11107"></a><span class="lineno">11107</span>&#160;`1     &lt; 10  ` | 1 &lt; x &lt; 10</div><div class="line"><a name="l11108"></a><span class="lineno">11108</span>&#160;`1     : &lt; 10` | 1 &lt;= x &lt; 10 </div><div class="line"><a name="l11109"></a><span class="lineno">11109</span>&#160;`      : &lt; 10` | x &lt; 10</div><div class="line"><a name="l11110"></a><span class="lineno">11110</span>&#160;`        &lt; 10` | x &lt; 10</div><div class="line"><a name="l11111"></a><span class="lineno">11111</span>&#160;`1 &lt; :       ` | 1 &lt; x</div><div class="line"><a name="l11112"></a><span class="lineno">11112</span>&#160;`1 &lt;         ` | 1 &lt; x</div><div class="line"><a name="l11113"></a><span class="lineno">11113</span>&#160;`1 &lt; : 10    ` | 1 &lt; x &lt;= 10</div><div class="line"><a name="l11114"></a><span class="lineno">11114</span>&#160;</div><div class="line"><a name="l11115"></a><span class="lineno">11115</span>&#160;Example:</div><div class="line"><a name="l11116"></a><span class="lineno">11116</span>&#160;</div><div class="line"><a name="l11117"></a><span class="lineno">11117</span>&#160;```cpp</div><div class="line"><a name="l11118"></a><span class="lineno">11118</span>&#160;typedef int ns__int10 0:10; // simpleType restriction of int 0..10 </div><div class="line"><a name="l11119"></a><span class="lineno">11119</span>&#160;typedef LONG64 ns__long -1000000:1000000; // simpleType restriction of long64 -1000000..1000000 </div><div class="line"><a name="l11120"></a><span class="lineno">11120</span>&#160;typedef float ns__float -1.0 &lt;:&lt; 10.5; // simpleType restriction of float in (-1,10.5) </div><div class="line"><a name="l11121"></a><span class="lineno">11121</span>&#160;struct ns__data // simpleContent wrapper </div><div class="line"><a name="l11122"></a><span class="lineno">11122</span>&#160;{ </div><div class="line"><a name="l11123"></a><span class="lineno">11123</span>&#160;  int __item 0:10; // simpleContent range 0..10 </div><div class="line"><a name="l11124"></a><span class="lineno">11124</span>&#160;  @ char *name 1; // required name attribute </div><div class="line"><a name="l11125"></a><span class="lineno">11125</span>&#160;};</div><div class="line"><a name="l11126"></a><span class="lineno">11126</span>&#160;```</div><div class="line"><a name="l11127"></a><span class="lineno">11127</span>&#160;</div><div class="line"><a name="l11128"></a><span class="lineno">11128</span>&#160;Remember to set the `SOAP_XML_STRICT` input mode flag to</div><div class="line"><a name="l11129"></a><span class="lineno">11129</span>&#160;enable the validation of value range constraints.</div><div class="line"><a name="l11130"></a><span class="lineno">11130</span>&#160;</div><div class="line"><a name="l11131"></a><span class="lineno">11131</span>&#160;Use compiler flag `WITH_REPLACE_ILLEGAL_UTF8` to force strict UTF-8 text</div><div class="line"><a name="l11132"></a><span class="lineno">11132</span>&#160;conversions, which replaces invalid UTF-8 with U+FFFD.  Compile</div><div class="line"><a name="l11133"></a><span class="lineno">11133</span>&#160;`stdsoap2.c` and `stdsoap2.cpp` with this flag.</div><div class="line"><a name="l11134"></a><span class="lineno">11134</span>&#160;</div><div class="line"><a name="l11135"></a><span class="lineno">11135</span>&#160;### Pattern Restrictions</div><div class="line"><a name="l11136"></a><span class="lineno">11136</span>&#160;</div><div class="line"><a name="l11137"></a><span class="lineno">11137</span>&#160;Patterns can be defined for simpleType content. However, patterns are currently not enforced in the validation process though possibly in future releases.</div><div class="line"><a name="l11138"></a><span class="lineno">11138</span>&#160;</div><div class="line"><a name="l11139"></a><span class="lineno">11139</span>&#160;To associate a pattern with a simpleType, you can define a simpleType with a `typedef` and a pattern string:</div><div class="line"><a name="l11140"></a><span class="lineno">11140</span>&#160;</div><div class="line"><a name="l11141"></a><span class="lineno">11141</span>&#160;```cpp</div><div class="line"><a name="l11142"></a><span class="lineno">11142</span>&#160;typedef int time__second &quot;[1-5]?[0-9]|60&quot;;</div><div class="line"><a name="l11143"></a><span class="lineno">11143</span>&#160;```</div><div class="line"><a name="l11144"></a><span class="lineno">11144</span>&#160;</div><div class="line"><a name="l11145"></a><span class="lineno">11145</span>&#160;This defines the following schema type in `time.xsd`:</div><div class="line"><a name="l11146"></a><span class="lineno">11146</span>&#160;</div><div class="line"><a name="l11147"></a><span class="lineno">11147</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l11148"></a><span class="lineno">11148</span>&#160;```xml</div><div class="line"><a name="l11149"></a><span class="lineno">11149</span>&#160;&lt;simpleType name=&quot;second&quot;&gt; </div><div class="line"><a name="l11150"></a><span class="lineno">11150</span>&#160;   &lt;restriction base=&quot;xsd:int&quot;&gt; </div><div class="line"><a name="l11151"></a><span class="lineno">11151</span>&#160;     &lt;pattern value=&quot;[1-5]?[0-9]|60&quot;/&gt; </div><div class="line"><a name="l11152"></a><span class="lineno">11152</span>&#160;   &lt;/restriction&gt; </div><div class="line"><a name="l11153"></a><span class="lineno">11153</span>&#160;&lt;/simpleType&gt;</div><div class="line"><a name="l11154"></a><span class="lineno">11154</span>&#160;```</div><div class="line"><a name="l11155"></a><span class="lineno">11155</span>&#160;</div><div class="line"><a name="l11156"></a><span class="lineno">11156</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l11157"></a><span class="lineno">11157</span>&#160;The pattern string MUST contain a valid regular expression.</div><div class="line"><a name="l11158"></a><span class="lineno">11158</span>&#160;</div><div class="line"><a name="l11159"></a><span class="lineno">11159</span>&#160;A special case for C format string patterns is introduced in gSOAP 2.8.18.</div><div class="line"><a name="l11160"></a><span class="lineno">11160</span>&#160;When *`xs:totalDigits`* and *`xs:fractionDigits`* are given in a XSD file,</div><div class="line"><a name="l11161"></a><span class="lineno">11161</span>&#160;then a C format string is produced to output floating point values with the</div><div class="line"><a name="l11162"></a><span class="lineno">11162</span>&#160;proper precision and scale. For example:</div><div class="line"><a name="l11163"></a><span class="lineno">11163</span>&#160;</div><div class="line"><a name="l11164"></a><span class="lineno">11164</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l11165"></a><span class="lineno">11165</span>&#160;```xml</div><div class="line"><a name="l11166"></a><span class="lineno">11166</span>&#160;&lt;simpleType name=&quot;ratio&quot;&gt; </div><div class="line"><a name="l11167"></a><span class="lineno">11167</span>&#160;   &lt;restriction base=&quot;xsd:float&quot;&gt; </div><div class="line"><a name="l11168"></a><span class="lineno">11168</span>&#160;     &lt;totalDigits value=&quot;5&quot;/&gt; </div><div class="line"><a name="l11169"></a><span class="lineno">11169</span>&#160;     &lt;fractionDigits value=&quot;2&quot;/&gt; </div><div class="line"><a name="l11170"></a><span class="lineno">11170</span>&#160;   &lt;/restriction&gt; </div><div class="line"><a name="l11171"></a><span class="lineno">11171</span>&#160;&lt;/simpleType&gt;</div><div class="line"><a name="l11172"></a><span class="lineno">11172</span>&#160;```</div><div class="line"><a name="l11173"></a><span class="lineno">11173</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l11174"></a><span class="lineno">11174</span>&#160;</div><div class="line"><a name="l11175"></a><span class="lineno">11175</span>&#160;produces:</div><div class="line"><a name="l11176"></a><span class="lineno">11176</span>&#160;</div><div class="line"><a name="l11177"></a><span class="lineno">11177</span>&#160;```cpp</div><div class="line"><a name="l11178"></a><span class="lineno">11178</span>&#160;typedef float time__ratio &quot;%5.2f&quot;;</div><div class="line"><a name="l11179"></a><span class="lineno">11179</span>&#160;```</div><div class="line"><a name="l11180"></a><span class="lineno">11180</span>&#160;</div><div class="line"><a name="l11181"></a><span class="lineno">11181</span>&#160;The format string is used to format the output the floating point value in XML.</div><div class="line"><a name="l11182"></a><span class="lineno">11182</span>&#160;</div><div class="line"><a name="l11183"></a><span class="lineno">11183</span>&#160;## Element and Attribute Qualified/Unqualified Forms</div><div class="line"><a name="l11184"></a><span class="lineno">11184</span>&#160;</div><div class="line"><a name="l11185"></a><span class="lineno">11185</span>&#160;Struct, class, and union members represent elements and attributes that are</div><div class="line"><a name="l11186"></a><span class="lineno">11186</span>&#160;automatically qualified or unqualified depending on the schema element and</div><div class="line"><a name="l11187"></a><span class="lineno">11187</span>&#160;attribute default forms specified. The gSOAP engine always validates the prefixes of</div><div class="line"><a name="l11188"></a><span class="lineno">11188</span>&#160;elements and attributes. When a namespace mismatch occurs, the element or</div><div class="line"><a name="l11189"></a><span class="lineno">11189</span>&#160;attribute is not consumed which can lead to a validation error (unless the</div><div class="line"><a name="l11190"></a><span class="lineno">11190</span>&#160;complexType is extensible or when `SOAP_XML_STRICT` is turned off).</div><div class="line"><a name="l11191"></a><span class="lineno">11191</span>&#160;</div><div class="line"><a name="l11192"></a><span class="lineno">11192</span>&#160;See Section \ref idtrans  for details on the</div><div class="line"><a name="l11193"></a><span class="lineno">11193</span>&#160;the struct/class/union member identifier translation rules.</div><div class="line"><a name="l11194"></a><span class="lineno">11194</span>&#160;Consider for example:</div><div class="line"><a name="l11195"></a><span class="lineno">11195</span>&#160;</div><div class="line"><a name="l11196"></a><span class="lineno">11196</span>&#160;```cpp</div><div class="line"><a name="l11197"></a><span class="lineno">11197</span>&#160;//gsoap ns schema elementForm: qualified </div><div class="line"><a name="l11198"></a><span class="lineno">11198</span>&#160;//gsoap ns schema attributeForm: unqualified </div><div class="line"><a name="l11199"></a><span class="lineno">11199</span>&#160;struct ns__record </div><div class="line"><a name="l11200"></a><span class="lineno">11200</span>&#160;{ </div><div class="line"><a name="l11201"></a><span class="lineno">11201</span>&#160;  @ char * type; </div><div class="line"><a name="l11202"></a><span class="lineno">11202</span>&#160;  char * name; </div><div class="line"><a name="l11203"></a><span class="lineno">11203</span>&#160;};</div><div class="line"><a name="l11204"></a><span class="lineno">11204</span>&#160;```</div><div class="line"><a name="l11205"></a><span class="lineno">11205</span>&#160;</div><div class="line"><a name="l11206"></a><span class="lineno">11206</span>&#160;Here, the `ns__record` struct is serialized with qualified element `name` and unqualified attribute `type`:</div><div class="line"><a name="l11207"></a><span class="lineno">11207</span>&#160;</div><div class="line"><a name="l11208"></a><span class="lineno">11208</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l11209"></a><span class="lineno">11209</span>&#160;```xml</div><div class="line"><a name="l11210"></a><span class="lineno">11210</span>&#160;&lt;ns:record type=&quot;...&quot;&gt; </div><div class="line"><a name="l11211"></a><span class="lineno">11211</span>&#160;   &lt;ns:name&gt;...&lt;/ns:name&gt; </div><div class="line"><a name="l11212"></a><span class="lineno">11212</span>&#160;&lt;/ns:record&gt;</div><div class="line"><a name="l11213"></a><span class="lineno">11213</span>&#160;```</div><div class="line"><a name="l11214"></a><span class="lineno">11214</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l11215"></a><span class="lineno">11215</span>&#160;</div><div class="line"><a name="l11216"></a><span class="lineno">11216</span>&#160;The &quot;colon notation&quot; for struct/class/union member field names is used to</div><div class="line"><a name="l11217"></a><span class="lineno">11217</span>&#160;override element and attribute qualified or unqualified forms. </div><div class="line"><a name="l11218"></a><span class="lineno">11218</span>&#160;To override the form for individual members that represent elements and attributes, use a namespace prefix and colon with the member name:</div><div class="line"><a name="l11219"></a><span class="lineno">11219</span>&#160;</div><div class="line"><a name="l11220"></a><span class="lineno">11220</span>&#160;```cpp</div><div class="line"><a name="l11221"></a><span class="lineno">11221</span>&#160;//gsoap ns schema elementForm: qualified </div><div class="line"><a name="l11222"></a><span class="lineno">11222</span>&#160;//gsoap ns schema attributeForm: unqualified </div><div class="line"><a name="l11223"></a><span class="lineno">11223</span>&#160;struct ns__record </div><div class="line"><a name="l11224"></a><span class="lineno">11224</span>&#160;{ </div><div class="line"><a name="l11225"></a><span class="lineno">11225</span>&#160;  @ char * ns:type; </div><div class="line"><a name="l11226"></a><span class="lineno">11226</span>&#160;  char * :name; </div><div class="line"><a name="l11227"></a><span class="lineno">11227</span>&#160;};</div><div class="line"><a name="l11228"></a><span class="lineno">11228</span>&#160;```</div><div class="line"><a name="l11229"></a><span class="lineno">11229</span>&#160;</div><div class="line"><a name="l11230"></a><span class="lineno">11230</span>&#160;where `name` is unqualified and `type` is qualified:</div><div class="line"><a name="l11231"></a><span class="lineno">11231</span>&#160;</div><div class="line"><a name="l11232"></a><span class="lineno">11232</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l11233"></a><span class="lineno">11233</span>&#160;```xml</div><div class="line"><a name="l11234"></a><span class="lineno">11234</span>&#160;&lt;ns:record ns:type=&quot;...&quot;&gt; </div><div class="line"><a name="l11235"></a><span class="lineno">11235</span>&#160;   &lt;name&gt;...&lt;/name&gt; </div><div class="line"><a name="l11236"></a><span class="lineno">11236</span>&#160;&lt;/ns:record&gt;</div><div class="line"><a name="l11237"></a><span class="lineno">11237</span>&#160;```</div><div class="line"><a name="l11238"></a><span class="lineno">11238</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l11239"></a><span class="lineno">11239</span>&#160;</div><div class="line"><a name="l11240"></a><span class="lineno">11240</span>&#160;The colon notation is a syntactic notation used only in the gSOAP header file</div><div class="line"><a name="l11241"></a><span class="lineno">11241</span>&#160;syntax, it is not translated to the C/C++ output.</div><div class="line"><a name="l11242"></a><span class="lineno">11242</span>&#160;</div><div class="line"><a name="l11243"></a><span class="lineno">11243</span>&#160;The colon notation does not avoid name clashes between members. For example:</div><div class="line"><a name="l11244"></a><span class="lineno">11244</span>&#160;</div><div class="line"><a name="l11245"></a><span class="lineno">11245</span>&#160;```cpp</div><div class="line"><a name="l11246"></a><span class="lineno">11246</span>&#160;struct x__record </div><div class="line"><a name="l11247"></a><span class="lineno">11247</span>&#160;{ </div><div class="line"><a name="l11248"></a><span class="lineno">11248</span>&#160;  @ char * name; </div><div class="line"><a name="l11249"></a><span class="lineno">11249</span>&#160;  char * x:name; </div><div class="line"><a name="l11250"></a><span class="lineno">11250</span>&#160;};</div><div class="line"><a name="l11251"></a><span class="lineno">11251</span>&#160;```</div><div class="line"><a name="l11252"></a><span class="lineno">11252</span>&#160;</div><div class="line"><a name="l11253"></a><span class="lineno">11253</span>&#160;results in a redefinition error, since both members have the same name. To avoid name clashes, use a underscore suffix:</div><div class="line"><a name="l11254"></a><span class="lineno">11254</span>&#160;</div><div class="line"><a name="l11255"></a><span class="lineno">11255</span>&#160;```cpp</div><div class="line"><a name="l11256"></a><span class="lineno">11256</span>&#160;struct x__record </div><div class="line"><a name="l11257"></a><span class="lineno">11257</span>&#160;{ </div><div class="line"><a name="l11258"></a><span class="lineno">11258</span>&#160;  @ char * name; </div><div class="line"><a name="l11259"></a><span class="lineno">11259</span>&#160;  char * x:name_; </div><div class="line"><a name="l11260"></a><span class="lineno">11260</span>&#160;};</div><div class="line"><a name="l11261"></a><span class="lineno">11261</span>&#160;```</div><div class="line"><a name="l11262"></a><span class="lineno">11262</span>&#160;</div><div class="line"><a name="l11263"></a><span class="lineno">11263</span>&#160;Not that the namespace prefix convention can be used instead:</div><div class="line"><a name="l11264"></a><span class="lineno">11264</span>&#160;</div><div class="line"><a name="l11265"></a><span class="lineno">11265</span>&#160;```cpp</div><div class="line"><a name="l11266"></a><span class="lineno">11266</span>&#160;struct x__record </div><div class="line"><a name="l11267"></a><span class="lineno">11267</span>&#160;{ </div><div class="line"><a name="l11268"></a><span class="lineno">11268</span>&#160;  @ char * name; </div><div class="line"><a name="l11269"></a><span class="lineno">11269</span>&#160;  char * x__name; </div><div class="line"><a name="l11270"></a><span class="lineno">11270</span>&#160;};</div><div class="line"><a name="l11271"></a><span class="lineno">11271</span>&#160;```</div><div class="line"><a name="l11272"></a><span class="lineno">11272</span>&#160;</div><div class="line"><a name="l11273"></a><span class="lineno">11273</span>&#160;which avoids the name clash. However, the resulting schema is different</div><div class="line"><a name="l11274"></a><span class="lineno">11274</span>&#160;since the last example generates a global `name` element definition that is</div><div class="line"><a name="l11275"></a><span class="lineno">11275</span>&#160;referenced by the local element.</div><div class="line"><a name="l11276"></a><span class="lineno">11276</span>&#160;</div><div class="line"><a name="l11277"></a><span class="lineno">11277</span>&#160;More specifically, the difference between the namespace prefix convention with double underscores</div><div class="line"><a name="l11278"></a><span class="lineno">11278</span>&#160;and colon notation is that the namespace prefix convention generates schema</div><div class="line"><a name="l11279"></a><span class="lineno">11279</span>&#160;element/attribute references to elements/attributes at the top level,</div><div class="line"><a name="l11280"></a><span class="lineno">11280</span>&#160;while the colon notation only affects the local element/attribute namespace</div><div class="line"><a name="l11281"></a><span class="lineno">11281</span>&#160;qualification by form overriding. This is best illustrated by an example:</div><div class="line"><a name="l11282"></a><span class="lineno">11282</span>&#160;</div><div class="line"><a name="l11283"></a><span class="lineno">11283</span>&#160;```cpp</div><div class="line"><a name="l11284"></a><span class="lineno">11284</span>&#160;struct x__record </div><div class="line"><a name="l11285"></a><span class="lineno">11285</span>&#160;{ </div><div class="line"><a name="l11286"></a><span class="lineno">11286</span>&#160;   char * :name; </div><div class="line"><a name="l11287"></a><span class="lineno">11287</span>&#160;   char * x:phone; </div><div class="line"><a name="l11288"></a><span class="lineno">11288</span>&#160;   char * x__fax; </div><div class="line"><a name="l11289"></a><span class="lineno">11289</span>&#160;   char * y__zip; </div><div class="line"><a name="l11290"></a><span class="lineno">11290</span>&#160;};</div><div class="line"><a name="l11291"></a><span class="lineno">11291</span>&#160;```</div><div class="line"><a name="l11292"></a><span class="lineno">11292</span>&#160;</div><div class="line"><a name="l11293"></a><span class="lineno">11293</span>&#160;which generates the following `x.xsd`schema:</div><div class="line"><a name="l11294"></a><span class="lineno">11294</span>&#160;</div><div class="line"><a name="l11295"></a><span class="lineno">11295</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l11296"></a><span class="lineno">11296</span>&#160;```xml</div><div class="line"><a name="l11297"></a><span class="lineno">11297</span>&#160;  &lt;complexType name=&quot;record&quot;&gt; </div><div class="line"><a name="l11298"></a><span class="lineno">11298</span>&#160;     &lt;sequence&gt; </div><div class="line"><a name="l11299"></a><span class="lineno">11299</span>&#160;         &lt;element name=&quot;name&quot; type=&quot;xsd:string&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;1&quot; nillable=&quot;true&quot; form=&quot;unqualified&quot;/&gt; </div><div class="line"><a name="l11300"></a><span class="lineno">11300</span>&#160;         &lt;element name=&quot;phone&quot; type=&quot;xsd:string&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;1&quot; nillable=&quot;true&quot; form=&quot;qualified&quot;/&gt; </div><div class="line"><a name="l11301"></a><span class="lineno">11301</span>&#160;         &lt;element ref=&quot;x:fax&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;1&quot;/&gt; </div><div class="line"><a name="l11302"></a><span class="lineno">11302</span>&#160;         &lt;element ref=&quot;y:zip&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;1&quot;/&gt; </div><div class="line"><a name="l11303"></a><span class="lineno">11303</span>&#160;     &lt;/sequence&gt; </div><div class="line"><a name="l11304"></a><span class="lineno">11304</span>&#160;  &lt;/complexType&gt; </div><div class="line"><a name="l11305"></a><span class="lineno">11305</span>&#160;  &lt;element name=&quot;fax&quot; type=&quot;xsd:string&quot;/&gt;</div><div class="line"><a name="l11306"></a><span class="lineno">11306</span>&#160;```</div><div class="line"><a name="l11307"></a><span class="lineno">11307</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l11308"></a><span class="lineno">11308</span>&#160;</div><div class="line"><a name="l11309"></a><span class="lineno">11309</span>&#160;and the `y.xsd` schema defines contains:</div><div class="line"><a name="l11310"></a><span class="lineno">11310</span>&#160;</div><div class="line"><a name="l11311"></a><span class="lineno">11311</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l11312"></a><span class="lineno">11312</span>&#160;```xml</div><div class="line"><a name="l11313"></a><span class="lineno">11313</span>&#160;  &lt;element name=&quot;zip&quot; type=&quot;xsd:string&quot;/&gt;</div><div class="line"><a name="l11314"></a><span class="lineno">11314</span>&#160;```</div><div class="line"><a name="l11315"></a><span class="lineno">11315</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l11316"></a><span class="lineno">11316</span>&#160;</div><div class="line"><a name="l11317"></a><span class="lineno">11317</span>&#160;# SOAP/XML Over UDP        {#udp}</div><div class="line"><a name="l11318"></a><span class="lineno">11318</span>&#160;</div><div class="line"><a name="l11319"></a><span class="lineno">11319</span>&#160;UDP is a simple, unreliable datagram protocol: UDP sockets are connectionless.</div><div class="line"><a name="l11320"></a><span class="lineno">11320</span>&#160;UDP address formats are identical to those used by TCP.  In particular UDP</div><div class="line"><a name="l11321"></a><span class="lineno">11321</span>&#160;provides a port identifier in addition to the normal Internet address format.</div><div class="line"><a name="l11322"></a><span class="lineno">11322</span>&#160;The UDP port space is separate from the TCP port space (i.e. a UDP port may not</div><div class="line"><a name="l11323"></a><span class="lineno">11323</span>&#160;be &quot;connected&quot; to a TCP port).  In addition broadcast packets may be sent</div><div class="line"><a name="l11324"></a><span class="lineno">11324</span>&#160;(assuming the underlying network supports this) by using a reserved &quot;broadcast</div><div class="line"><a name="l11325"></a><span class="lineno">11325</span>&#160;address&quot;; this address is network interface dependent.</div><div class="line"><a name="l11326"></a><span class="lineno">11326</span>&#160;</div><div class="line"><a name="l11327"></a><span class="lineno">11327</span>&#160;Client-side messages with SOAP-over-UDP endpoint URLs</div><div class="line"><a name="l11328"></a><span class="lineno">11328</span>&#160;(`soap.udp://...`) will be automatically transmitted as datagrams.</div><div class="line"><a name="l11329"></a><span class="lineno">11329</span>&#160;Server-side applications should set the `SOAP_IO_UDP` mode flag to</div><div class="line"><a name="l11330"></a><span class="lineno">11330</span>&#160;accept UDP requests, e.g. using `soap_init1` or `soap_set_mode`.</div><div class="line"><a name="l11331"></a><span class="lineno">11331</span>&#160;</div><div class="line"><a name="l11332"></a><span class="lineno">11332</span>&#160;The maximum message length for datagram packets is restricted by the buffer</div><div class="line"><a name="l11333"></a><span class="lineno">11333</span>&#160;size `SOAP_BUFLEN`, which is 65536 by default, unless</div><div class="line"><a name="l11334"></a><span class="lineno">11334</span>&#160;compiled with `WITH_LEAN` to support small-scale embedded systems.</div><div class="line"><a name="l11335"></a><span class="lineno">11335</span>&#160;For UDP transport `SOAP_BUFLEN` must not exceed the maximum UDP packet size</div><div class="line"><a name="l11336"></a><span class="lineno">11336</span>&#160;65536 (the size of datagram messages is constrained by the</div><div class="line"><a name="l11337"></a><span class="lineno">11337</span>&#160;UDP packet size 2^16=65536 as per UDP standard). You can use gzip compression</div><div class="line"><a name="l11338"></a><span class="lineno">11338</span>&#160;to reduce the message size, but note that compressed SOAP-over-UDP is a</div><div class="line"><a name="l11339"></a><span class="lineno">11339</span>&#160;gSOAP-specific feature because it is not part of the SOAP-over-UDP</div><div class="line"><a name="l11340"></a><span class="lineno">11340</span>&#160;specification.</div><div class="line"><a name="l11341"></a><span class="lineno">11341</span>&#160;</div><div class="line"><a name="l11342"></a><span class="lineno">11342</span>&#160;The SOAP-over-UDP specification relies on WS-Addressing. The `wsa.h`</div><div class="line"><a name="l11343"></a><span class="lineno">11343</span>&#160;file in the `import` directory defines the WS-Addressing elements for</div><div class="line"><a name="l11344"></a><span class="lineno">11344</span>&#160;client and server applications.</div><div class="line"><a name="l11345"></a><span class="lineno">11345</span>&#160;</div><div class="line"><a name="l11346"></a><span class="lineno">11346</span>&#160;The gSOAP implementation conforms to the SOAP-over-UDP requirements:</div><div class="line"><a name="l11347"></a><span class="lineno">11347</span>&#160;</div><div class="line"><a name="l11348"></a><span class="lineno">11348</span>&#160;</div><div class="line"><a name="l11349"></a><span class="lineno">11349</span>&#160;*  SOAP-over-UDP server endpoint URL format: *soap.udp://host:port/path*</div><div class="line"><a name="l11350"></a><span class="lineno">11350</span>&#160;</div><div class="line"><a name="l11351"></a><span class="lineno">11351</span>&#160;*  Support one-way message-exchange pattern (MEP) where a SOAP envelope is</div><div class="line"><a name="l11352"></a><span class="lineno">11352</span>&#160;  carried in a user datagram.</div><div class="line"><a name="l11353"></a><span class="lineno">11353</span>&#160;</div><div class="line"><a name="l11354"></a><span class="lineno">11354</span>&#160;*  Support request-response message-exchange pattern (MEP) where SOAP envelopes</div><div class="line"><a name="l11355"></a><span class="lineno">11355</span>&#160;  are carried in user datagrams.</div><div class="line"><a name="l11356"></a><span class="lineno">11356</span>&#160;</div><div class="line"><a name="l11357"></a><span class="lineno">11357</span>&#160;*  Support multicast transmission of SOAP envelopes carried in user datagrams.</div><div class="line"><a name="l11358"></a><span class="lineno">11358</span>&#160;</div><div class="line"><a name="l11359"></a><span class="lineno">11359</span>&#160;*  Support both SOAP 1.1 and SOAP 1.2 envelopes.</div><div class="line"><a name="l11360"></a><span class="lineno">11360</span>&#160;</div><div class="line"><a name="l11361"></a><span class="lineno">11361</span>&#160;The following additional features are also available, but are not supported by the SOAP-over-UDP specification:</div><div class="line"><a name="l11362"></a><span class="lineno">11362</span>&#160;</div><div class="line"><a name="l11363"></a><span class="lineno">11363</span>&#160;</div><div class="line"><a name="l11364"></a><span class="lineno">11364</span>&#160;*  Zlib/gzip message compression (compile `-DWITH_GZIP`).</div><div class="line"><a name="l11365"></a><span class="lineno">11365</span>&#160;</div><div class="line"><a name="l11366"></a><span class="lineno">11366</span>&#160;*  SOAP with DIME attachments over UDP.</div><div class="line"><a name="l11367"></a><span class="lineno">11367</span>&#160;</div><div class="line"><a name="l11368"></a><span class="lineno">11368</span>&#160;*  SOAP with MIME attachments (SwA) over UDP.</div><div class="line"><a name="l11369"></a><span class="lineno">11369</span>&#160;</div><div class="line"><a name="l11370"></a><span class="lineno">11370</span>&#160;*  Support for IPv6 (compile `-DWITH_IPV6`)</div><div class="line"><a name="l11371"></a><span class="lineno">11371</span>&#160;</div><div class="line"><a name="l11372"></a><span class="lineno">11372</span>&#160;</div><div class="line"><a name="l11373"></a><span class="lineno">11373</span>&#160;## Using WS-Addressing with SOAP-over-UDP        {#udp.h}</div><div class="line"><a name="l11374"></a><span class="lineno">11374</span>&#160;</div><div class="line"><a name="l11375"></a><span class="lineno">11375</span>&#160;A SOAP-over-UDP application MUST use WS-Addressing to control message delivery</div><div class="line"><a name="l11376"></a><span class="lineno">11376</span>&#160;as per SOAP-over-UDP specification.</div><div class="line"><a name="l11377"></a><span class="lineno">11377</span>&#160;</div><div class="line"><a name="l11378"></a><span class="lineno">11378</span>&#160;The `wsa.h` file in the `import` directory defines the</div><div class="line"><a name="l11379"></a><span class="lineno">11379</span>&#160;WS-Addressing elements.  To include the WS-Addressing elements in the SOAP</div><div class="line"><a name="l11380"></a><span class="lineno">11380</span>&#160;Header for messaging, a `struct SOAP_ENV__Header` structure must be</div><div class="line"><a name="l11381"></a><span class="lineno">11381</span>&#160;defined in your header file with the appropriate WS-Addressing elements.</div><div class="line"><a name="l11382"></a><span class="lineno">11382</span>&#160;For example:</div><div class="line"><a name="l11383"></a><span class="lineno">11383</span>&#160;</div><div class="line"><a name="l11384"></a><span class="lineno">11384</span>&#160;```cpp</div><div class="line"><a name="l11385"></a><span class="lineno">11385</span>&#160;#import &quot;wsa.h&quot; </div><div class="line"><a name="l11386"></a><span class="lineno">11386</span>&#160;struct SOAP_ENV__Header </div><div class="line"><a name="l11387"></a><span class="lineno">11387</span>&#160;{ </div><div class="line"><a name="l11388"></a><span class="lineno">11388</span>&#160;   mustUnderstand _wsa__MessageID  wsa__MessageID 0; </div><div class="line"><a name="l11389"></a><span class="lineno">11389</span>&#160;   mustUnderstand _wsa__RelatesTo *wsa__RelatesTo 0; </div><div class="line"><a name="l11390"></a><span class="lineno">11390</span>&#160;   mustUnderstand _wsa__From      *wsa__From      0; </div><div class="line"><a name="l11391"></a><span class="lineno">11391</span>&#160;   mustUnderstand _wsa__ReplyTo   *wsa__ReplyTo   0; </div><div class="line"><a name="l11392"></a><span class="lineno">11392</span>&#160;   mustUnderstand _wsa__FaultTo   *wsa__FaultTo   0; </div><div class="line"><a name="l11393"></a><span class="lineno">11393</span>&#160;   mustUnderstand _wsa__To         wsa__To        0; </div><div class="line"><a name="l11394"></a><span class="lineno">11394</span>&#160;   mustUnderstand _wsa__Action     wsa__Action    0; </div><div class="line"><a name="l11395"></a><span class="lineno">11395</span>&#160;};</div><div class="line"><a name="l11396"></a><span class="lineno">11396</span>&#160;```</div><div class="line"><a name="l11397"></a><span class="lineno">11397</span>&#160;</div><div class="line"><a name="l11398"></a><span class="lineno">11398</span>&#160;We also included a `//gsoap wsa schema import` directive in the `wsa.h` file to enable the generation of WSDL</div><div class="line"><a name="l11399"></a><span class="lineno">11399</span>&#160;specifications that import (instead of includes) the WS-Addressing elements.</div><div class="line"><a name="l11400"></a><span class="lineno">11400</span>&#160;Note that the `//gsoapopt w` directive must not be present in your header file to enable WSDL generation.</div><div class="line"><a name="l11401"></a><span class="lineno">11401</span>&#160;</div><div class="line"><a name="l11402"></a><span class="lineno">11402</span>&#160;One-way SOAP-over-UDP messages (see Section \ref oneway1 ) should be</div><div class="line"><a name="l11403"></a><span class="lineno">11403</span>&#160;declared to include the `wsa:MessageID`, `wsa:To`, and `wsa:Action`</div><div class="line"><a name="l11404"></a><span class="lineno">11404</span>&#160;elements in the SOAP Header of the request message as follows:</div><div class="line"><a name="l11405"></a><span class="lineno">11405</span>&#160;</div><div class="line"><a name="l11406"></a><span class="lineno">11406</span>&#160;```cpp</div><div class="line"><a name="l11407"></a><span class="lineno">11407</span>&#160;//gsoap ns service method-header-part:          sendString wsa__MessageID </div><div class="line"><a name="l11408"></a><span class="lineno">11408</span>&#160;//gsoap ns service method-header-part:          sendString wsa__To </div><div class="line"><a name="l11409"></a><span class="lineno">11409</span>&#160;//gsoap ns service method-header-part:          sendString wsa__Action </div><div class="line"><a name="l11410"></a><span class="lineno">11410</span>&#160;int ns__sendString(char *str, void);</div><div class="line"><a name="l11411"></a><span class="lineno">11411</span>&#160;```</div><div class="line"><a name="l11412"></a><span class="lineno">11412</span>&#160;</div><div class="line"><a name="l11413"></a><span class="lineno">11413</span>&#160;Request-response SOAP-over-UDP messages should be declared to include the</div><div class="line"><a name="l11414"></a><span class="lineno">11414</span>&#160;`wsa:MessageID`, `wsa:To`, `wsa:Action`, and `wsa:ReplyTo`</div><div class="line"><a name="l11415"></a><span class="lineno">11415</span>&#160;elements in the SOAP Header of the request message, and the the</div><div class="line"><a name="l11416"></a><span class="lineno">11416</span>&#160;`wsa:MessageID`, `wsa:To`, `wsa:Action`, and `wsa:RelatesTo`</div><div class="line"><a name="l11417"></a><span class="lineno">11417</span>&#160;elements in the SOAP Header of the response message:</div><div class="line"><a name="l11418"></a><span class="lineno">11418</span>&#160;</div><div class="line"><a name="l11419"></a><span class="lineno">11419</span>&#160;```cpp</div><div class="line"><a name="l11420"></a><span class="lineno">11420</span>&#160;//gsoap ns service method-header-part:          echoString wsa__MessageID </div><div class="line"><a name="l11421"></a><span class="lineno">11421</span>&#160;//gsoap ns service method-header-part:          echoString wsa__To </div><div class="line"><a name="l11422"></a><span class="lineno">11422</span>&#160;//gsoap ns service method-header-part:          echoString wsa__Action </div><div class="line"><a name="l11423"></a><span class="lineno">11423</span>&#160;//gsoap ns service method-input-header-part:    sendString wsa__ReplyTo </div><div class="line"><a name="l11424"></a><span class="lineno">11424</span>&#160;//gsoap ns service method-output-header-part:   echoString wsa__RelatesTo </div><div class="line"><a name="l11425"></a><span class="lineno">11425</span>&#160;int ns__echoString(char *str, char **res);</div><div class="line"><a name="l11426"></a><span class="lineno">11426</span>&#160;```</div><div class="line"><a name="l11427"></a><span class="lineno">11427</span>&#160;</div><div class="line"><a name="l11428"></a><span class="lineno">11428</span>&#160;For the content requirements of these elements, please consult the</div><div class="line"><a name="l11429"></a><span class="lineno">11429</span>&#160;SOAP-over-UDP specification and/or read the next sections explaining</div><div class="line"><a name="l11430"></a><span class="lineno">11430</span>&#160;SOAP-over-UDP unicast, multicast, one-way, and request-response client and</div><div class="line"><a name="l11431"></a><span class="lineno">11431</span>&#160;server applications.</div><div class="line"><a name="l11432"></a><span class="lineno">11432</span>&#160;</div><div class="line"><a name="l11433"></a><span class="lineno">11433</span>&#160;## Client-side One-way Unicast</div><div class="line"><a name="l11434"></a><span class="lineno">11434</span>&#160;</div><div class="line"><a name="l11435"></a><span class="lineno">11435</span>&#160;This example assumes that the gSOAP header file includes the SOAP Header with</div><div class="line"><a name="l11436"></a><span class="lineno">11436</span>&#160;WS-Addressing elements and the `ns__sendString` function discussed in</div><div class="line"><a name="l11437"></a><span class="lineno">11437</span>&#160;Section \ref udp.h </div><div class="line"><a name="l11438"></a><span class="lineno">11438</span>&#160;</div><div class="line"><a name="l11439"></a><span class="lineno">11439</span>&#160;```cpp</div><div class="line"><a name="l11440"></a><span class="lineno">11440</span>&#160;struct soap soap; </div><div class="line"><a name="l11441"></a><span class="lineno">11441</span>&#160;struct SOAP_ENV__Header header; // the SOAP Header </div><div class="line"><a name="l11442"></a><span class="lineno">11442</span>&#160;soap_init(&amp;soap); </div><div class="line"><a name="l11443"></a><span class="lineno">11443</span>&#160;soap.send_timeout = 5; // 5 seconds max socket delay </div><div class="line"><a name="l11444"></a><span class="lineno">11444</span>&#160;soap_default_SOAP_ENV__Header(&amp;soap, &amp;header); // init SOAP Header </div><div class="line"><a name="l11445"></a><span class="lineno">11445</span>&#160;header.wsa__MessageID = &quot;*message ID*&quot;; </div><div class="line"><a name="l11446"></a><span class="lineno">11446</span>&#160;header.wsa__To = &quot;*server URL*&quot;; </div><div class="line"><a name="l11447"></a><span class="lineno">11447</span>&#160;header.wsa__Action = &quot;*server action*&quot;; </div><div class="line"><a name="l11448"></a><span class="lineno">11448</span>&#160;soap.header = &amp;header; // bind the SOAP Header for transport </div><div class="line"><a name="l11449"></a><span class="lineno">11449</span>&#160;// Send the message over UDP: </div><div class="line"><a name="l11450"></a><span class="lineno">11450</span>&#160;if (soap_send_ns__echoString(&amp;soap, &quot;soap.udp://...&quot;, NULL, &quot;hello world!&quot;)) </div><div class="line"><a name="l11451"></a><span class="lineno">11451</span>&#160;   soap_print_fault(&amp;soap, stderr); // report error </div><div class="line"><a name="l11452"></a><span class="lineno">11452</span>&#160;soap_end(&amp;soap); // cleanup </div><div class="line"><a name="l11453"></a><span class="lineno">11453</span>&#160;soap_destroy(&amp;soap); // cleanup </div><div class="line"><a name="l11454"></a><span class="lineno">11454</span>&#160;soap_done(&amp;soap); // close connection (should not use soap struct after this)</div><div class="line"><a name="l11455"></a><span class="lineno">11455</span>&#160;```</div><div class="line"><a name="l11456"></a><span class="lineno">11456</span>&#160;</div><div class="line"><a name="l11457"></a><span class="lineno">11457</span>&#160;## Client-side One-way Multicast</div><div class="line"><a name="l11458"></a><span class="lineno">11458</span>&#160;</div><div class="line"><a name="l11459"></a><span class="lineno">11459</span>&#160;This example is similar to the one-way unicast example discussed above, but</div><div class="line"><a name="l11460"></a><span class="lineno">11460</span>&#160;uses a broadcast address and the `SO_BROADCAST` socket option:</div><div class="line"><a name="l11461"></a><span class="lineno">11461</span>&#160;</div><div class="line"><a name="l11462"></a><span class="lineno">11462</span>&#160;```cpp</div><div class="line"><a name="l11463"></a><span class="lineno">11463</span>&#160;struct soap soap; </div><div class="line"><a name="l11464"></a><span class="lineno">11464</span>&#160;struct SOAP_ENV__Header header; // the SOAP Header </div><div class="line"><a name="l11465"></a><span class="lineno">11465</span>&#160;in_addr_t addr = inet_addr(&quot;1.2.3.4&quot;); // optional </div><div class="line"><a name="l11466"></a><span class="lineno">11466</span>&#160;soap_init(&amp;soap); </div><div class="line"><a name="l11467"></a><span class="lineno">11467</span>&#160;soap.send_timeout = 5; // 5 seconds max socket delay \</div><div class="line"><a name="l11468"></a><span class="lineno">11468</span>&#160;soap.connect_flags = SO_BROADCAST; // required for broadcast </div><div class="line"><a name="l11469"></a><span class="lineno">11469</span>&#160;soap.ipv4_multicast_if = &amp;addr; // optional for IPv4: see setsockopt IPPROTO_IP IP_MULTICAST_IF </div><div class="line"><a name="l11470"></a><span class="lineno">11470</span>&#160;soap.ipv6_multicast_if = addr; // optional for IPv6: multicast sin6_scope_id </div><div class="line"><a name="l11471"></a><span class="lineno">11471</span>&#160;soap.ipv4_multicast_ttl = 1; // optional, see setsockopt IPPROTO_IP, IP_MULTICAST_TTL </div><div class="line"><a name="l11472"></a><span class="lineno">11472</span>&#160;soap_default_SOAP_ENV__Header(&amp;soap, &amp;header); // init SOAP Header </div><div class="line"><a name="l11473"></a><span class="lineno">11473</span>&#160;header.wsa__MessageID = &quot;*message ID*&quot;; </div><div class="line"><a name="l11474"></a><span class="lineno">11474</span>&#160;header.wsa__To = &quot;*server URL*&quot;; </div><div class="line"><a name="l11475"></a><span class="lineno">11475</span>&#160;header.wsa__Action = &quot;*server action*&quot;; </div><div class="line"><a name="l11476"></a><span class="lineno">11476</span>&#160;soap.header = &amp;header; // bind the SOAP Header for transport </div><div class="line"><a name="l11477"></a><span class="lineno">11477</span>&#160;// Send the message over UDP to a broadcast address: </div><div class="line"><a name="l11478"></a><span class="lineno">11478</span>&#160;if (soap_send_ns__echoString(&amp;soap, &quot;soap.udp://...&quot;, NULL, &quot;hello world!&quot;)) </div><div class="line"><a name="l11479"></a><span class="lineno">11479</span>&#160;   soap_print_fault(&amp;soap, stderr); // report error </div><div class="line"><a name="l11480"></a><span class="lineno">11480</span>&#160;soap_destroy(&amp;soap); // cleanup </div><div class="line"><a name="l11481"></a><span class="lineno">11481</span>&#160;soap_end(&amp;soap); // cleanup </div><div class="line"><a name="l11482"></a><span class="lineno">11482</span>&#160;soap_done(&amp;soap); // close connection (should not use soap struct after this)</div><div class="line"><a name="l11483"></a><span class="lineno">11483</span>&#160;```</div><div class="line"><a name="l11484"></a><span class="lineno">11484</span>&#160;</div><div class="line"><a name="l11485"></a><span class="lineno">11485</span>&#160;Please refer to the socket options for `IPPROTO_IP IP_MULTICAST_IF`</div><div class="line"><a name="l11486"></a><span class="lineno">11486</span>&#160;to specify</div><div class="line"><a name="l11487"></a><span class="lineno">11487</span>&#160;the default interface for multicast datagrams to be sent from. This</div><div class="line"><a name="l11488"></a><span class="lineno">11488</span>&#160;is a `struct in_addr` (`in_addr_t` for `sin6_scope_id`)</div><div class="line"><a name="l11489"></a><span class="lineno">11489</span>&#160;interface value. Otherwise, the default interface set by the system</div><div class="line"><a name="l11490"></a><span class="lineno">11490</span>&#160;administrator will be used (if any).</div><div class="line"><a name="l11491"></a><span class="lineno">11491</span>&#160;</div><div class="line"><a name="l11492"></a><span class="lineno">11492</span>&#160;Please refer to the socket options for `IPPROTO_IP IP_MULTICAST_TTL` to limit</div><div class="line"><a name="l11493"></a><span class="lineno">11493</span>&#160;the lifetime of the packet. Multicast datagrams are sent with a default value</div><div class="line"><a name="l11494"></a><span class="lineno">11494</span>&#160;of 1, to prevent them to be forwarded beyond the local network. This parameter</div><div class="line"><a name="l11495"></a><span class="lineno">11495</span>&#160;can be set between 1 to 255.</div><div class="line"><a name="l11496"></a><span class="lineno">11496</span>&#160;</div><div class="line"><a name="l11497"></a><span class="lineno">11497</span>&#160;## Client-side Request-Response Unicast</div><div class="line"><a name="l11498"></a><span class="lineno">11498</span>&#160;</div><div class="line"><a name="l11499"></a><span class="lineno">11499</span>&#160;This example assumes that the gSOAP header file includes the SOAP Header with</div><div class="line"><a name="l11500"></a><span class="lineno">11500</span>&#160;WS-Addressing elements and the `ns__echoString` function discussed in</div><div class="line"><a name="l11501"></a><span class="lineno">11501</span>&#160;Section \ref udp.h </div><div class="line"><a name="l11502"></a><span class="lineno">11502</span>&#160;</div><div class="line"><a name="l11503"></a><span class="lineno">11503</span>&#160;```cpp</div><div class="line"><a name="l11504"></a><span class="lineno">11504</span>&#160;struct soap soap; </div><div class="line"><a name="l11505"></a><span class="lineno">11505</span>&#160;struct SOAP_ENV__Header header; // the SOAP Header </div><div class="line"><a name="l11506"></a><span class="lineno">11506</span>&#160;struct wsa__EndpointReferenceType replyTo; // (anonymous) reply address </div><div class="line"><a name="l11507"></a><span class="lineno">11507</span>&#160;char *res; // server response </div><div class="line"><a name="l11508"></a><span class="lineno">11508</span>&#160;soap_init(&amp;soap); </div><div class="line"><a name="l11509"></a><span class="lineno">11509</span>&#160;soap.send_timeout = 5; // 5 seconds max socket delay </div><div class="line"><a name="l11510"></a><span class="lineno">11510</span>&#160;soap.recv_timeout = 5; // 5 seconds max socket delay </div><div class="line"><a name="l11511"></a><span class="lineno">11511</span>&#160;soap_default_SOAP_ENV__Header(&amp;soap, &amp;header); // init SOAP Header </div><div class="line"><a name="l11512"></a><span class="lineno">11512</span>&#160;soap_default_wsa__EndpointReferenceType(&amp;soap, &amp;replyTo); // init reply address </div><div class="line"><a name="l11513"></a><span class="lineno">11513</span>&#160;replyTo.Address = &quot;http://schemas.xmlsoap.org/ws/2004/08/addressing/role/anonymous&quot;; </div><div class="line"><a name="l11514"></a><span class="lineno">11514</span>&#160;header.wsa__MessageID = &quot;*message ID*&quot;; </div><div class="line"><a name="l11515"></a><span class="lineno">11515</span>&#160;header.wsa__To = &quot;*server URL*&quot;; </div><div class="line"><a name="l11516"></a><span class="lineno">11516</span>&#160;header.wsa__Action = &quot;*server action*&quot;; </div><div class="line"><a name="l11517"></a><span class="lineno">11517</span>&#160;header.wsa__ReplyTo = &amp;replyTo; </div><div class="line"><a name="l11518"></a><span class="lineno">11518</span>&#160;soap.header = &amp;header; // bind the SOAP Header for transport </div><div class="line"><a name="l11519"></a><span class="lineno">11519</span>&#160;// Send and receive messages over UDP: </div><div class="line"><a name="l11520"></a><span class="lineno">11520</span>&#160;if (soap_call_ns__echoString(&amp;soap, &quot;soap.udp://...&quot;, NULL, &quot;hello world!&quot;, &amp;res)) </div><div class="line"><a name="l11521"></a><span class="lineno">11521</span>&#160;{ </div><div class="line"><a name="l11522"></a><span class="lineno">11522</span>&#160;   if (soap.error == SOAP_EOF &amp;&amp; soap.errnum == 0) </div><div class="line"><a name="l11523"></a><span class="lineno">11523</span>&#160;     // Timeout: no response from server (message already delivered?) </div><div class="line"><a name="l11524"></a><span class="lineno">11524</span>&#160;   else </div><div class="line"><a name="l11525"></a><span class="lineno">11525</span>&#160;     soap_print_fault(&amp;soap, stderr); </div><div class="line"><a name="l11526"></a><span class="lineno">11526</span>&#160;} </div><div class="line"><a name="l11527"></a><span class="lineno">11527</span>&#160;else </div><div class="line"><a name="l11528"></a><span class="lineno">11528</span>&#160;   // UDP server response is stored in &#39;res&#39; </div><div class="line"><a name="l11529"></a><span class="lineno">11529</span>&#160;// check SOAP header received, if applicable </div><div class="line"><a name="l11530"></a><span class="lineno">11530</span>&#160;check_header(&amp;soap.header); </div><div class="line"><a name="l11531"></a><span class="lineno">11531</span>&#160;soap_destroy(&amp;soap); // cleanup </div><div class="line"><a name="l11532"></a><span class="lineno">11532</span>&#160;soap_end(&amp;soap); // cleanup </div><div class="line"><a name="l11533"></a><span class="lineno">11533</span>&#160;soap_done(&amp;soap); // close connection (should not use soap struct after this)</div><div class="line"><a name="l11534"></a><span class="lineno">11534</span>&#160;```</div><div class="line"><a name="l11535"></a><span class="lineno">11535</span>&#160;</div><div class="line"><a name="l11536"></a><span class="lineno">11536</span>&#160;## Client-side Request-Response Multicast</div><div class="line"><a name="l11537"></a><span class="lineno">11537</span>&#160;</div><div class="line"><a name="l11538"></a><span class="lineno">11538</span>&#160;This example is similar to the request-response unicast example discussed</div><div class="line"><a name="l11539"></a><span class="lineno">11539</span>&#160;above, but uses a broadcast address and the `SO_BROADCAST` socket option.</div><div class="line"><a name="l11540"></a><span class="lineno">11540</span>&#160;Because we expect to receive multiple responses, we also need to use separate</div><div class="line"><a name="l11541"></a><span class="lineno">11541</span>&#160;request-response messages to send one request and consume multiple responses.</div><div class="line"><a name="l11542"></a><span class="lineno">11542</span>&#160;In this example we defined a `bcastString` request and a</div><div class="line"><a name="l11543"></a><span class="lineno">11543</span>&#160;`bcastStringResponse` response message, which are essentially declared as</div><div class="line"><a name="l11544"></a><span class="lineno">11544</span>&#160;one-way messages in the header file:</div><div class="line"><a name="l11545"></a><span class="lineno">11545</span>&#160;</div><div class="line"><a name="l11546"></a><span class="lineno">11546</span>&#160;```cpp</div><div class="line"><a name="l11547"></a><span class="lineno">11547</span>&#160;//gsoap ns service method-header-part:          bcastString wsa__MessageID </div><div class="line"><a name="l11548"></a><span class="lineno">11548</span>&#160;//gsoap ns service method-header-part:          bcastString wsa__To </div><div class="line"><a name="l11549"></a><span class="lineno">11549</span>&#160;//gsoap ns service method-header-part:          bcastString wsa__Action </div><div class="line"><a name="l11550"></a><span class="lineno">11550</span>&#160;//gsoap ns service method-header-part:          bcastString wsa__ReplyTo </div><div class="line"><a name="l11551"></a><span class="lineno">11551</span>&#160;int ns__bcastString(char *str, void); </div><div class="line"><a name="l11552"></a><span class="lineno">11552</span>&#160;//gsoap ns service method-header-part:          bcastStringResponse wsa__MessageID </div><div class="line"><a name="l11553"></a><span class="lineno">11553</span>&#160;//gsoap ns service method-header-part:          bcastStringResponse wsa__To </div><div class="line"><a name="l11554"></a><span class="lineno">11554</span>&#160;//gsoap ns service method-header-part:          bcastStringResponse wsa__Action </div><div class="line"><a name="l11555"></a><span class="lineno">11555</span>&#160;//gsoap ns service method-header-part:          bcastStringResponse wsa__RelatesTo </div><div class="line"><a name="l11556"></a><span class="lineno">11556</span>&#160;int ns__bcastStringResponse(char *res, void);</div><div class="line"><a name="l11557"></a><span class="lineno">11557</span>&#160;```</div><div class="line"><a name="l11558"></a><span class="lineno">11558</span>&#160;</div><div class="line"><a name="l11559"></a><span class="lineno">11559</span>&#160;To obtain response one-way operations, use the wsdl2h `-b` option.</div><div class="line"><a name="l11560"></a><span class="lineno">11560</span>&#160;</div><div class="line"><a name="l11561"></a><span class="lineno">11561</span>&#160;The client code includes a loop to receive response messages until a timeout occurs:</div><div class="line"><a name="l11562"></a><span class="lineno">11562</span>&#160;</div><div class="line"><a name="l11563"></a><span class="lineno">11563</span>&#160;```cpp</div><div class="line"><a name="l11564"></a><span class="lineno">11564</span>&#160;struct soap soap; </div><div class="line"><a name="l11565"></a><span class="lineno">11565</span>&#160;struct SOAP_ENV__Header header; </div><div class="line"><a name="l11566"></a><span class="lineno">11566</span>&#160;struct wsa__EndpointReferenceType replyTo; </div><div class="line"><a name="l11567"></a><span class="lineno">11567</span>&#160;char *res; </div><div class="line"><a name="l11568"></a><span class="lineno">11568</span>&#160;soap_init(&amp;soap); </div><div class="line"><a name="l11569"></a><span class="lineno">11569</span>&#160;soap.connect_flags = SO_BROADCAST; </div><div class="line"><a name="l11570"></a><span class="lineno">11570</span>&#160;soap.send_timeout = 5; // 5 seconds max socket delay </div><div class="line"><a name="l11571"></a><span class="lineno">11571</span>&#160;soap.recv_timeout = 5; // 5 seconds max socket delay </div><div class="line"><a name="l11572"></a><span class="lineno">11572</span>&#160;soap_default_SOAP_ENV__Header(&amp;soap, &amp;header); </div><div class="line"><a name="l11573"></a><span class="lineno">11573</span>&#160;soap.header = &amp;header; </div><div class="line"><a name="l11574"></a><span class="lineno">11574</span>&#160;soap_default_wsa__EndpointReferenceType(&amp;soap, &amp;replyTo); </div><div class="line"><a name="l11575"></a><span class="lineno">11575</span>&#160;replyTo.Address = &quot;http://schemas.xmlsoap.org/ws/2004/08/addressing/role/anonymous&quot;; </div><div class="line"><a name="l11576"></a><span class="lineno">11576</span>&#160;header.wsa__MessageID = &quot;*message ID*&quot;; </div><div class="line"><a name="l11577"></a><span class="lineno">11577</span>&#160;header.wsa__To = &quot;*server URL*&quot;; </div><div class="line"><a name="l11578"></a><span class="lineno">11578</span>&#160;header.wsa__Action = &quot;*server action*&quot;; </div><div class="line"><a name="l11579"></a><span class="lineno">11579</span>&#160;header.wsa__ReplyTo = &amp;replyTo; </div><div class="line"><a name="l11580"></a><span class="lineno">11580</span>&#160;if (soap_send_ns__bcastString(&amp;soap, &quot;soap.udp://...&quot;, NULL, &quot;hello world!&quot;)) </div><div class="line"><a name="l11581"></a><span class="lineno">11581</span>&#160;   soap_print_fault(&amp;soap, stderr); </div><div class="line"><a name="l11582"></a><span class="lineno">11582</span>&#160;else </div><div class="line"><a name="l11583"></a><span class="lineno">11583</span>&#160;{ </div><div class="line"><a name="l11584"></a><span class="lineno">11584</span>&#160;   for (;;) </div><div class="line"><a name="l11585"></a><span class="lineno">11585</span>&#160;   { </div><div class="line"><a name="l11586"></a><span class="lineno">11586</span>&#160;     if (soap_recv_ns__bcastStringResponse(&amp;soap, &amp;res)) </div><div class="line"><a name="l11587"></a><span class="lineno">11587</span>&#160;       break; </div><div class="line"><a name="l11588"></a><span class="lineno">11588</span>&#160;     // Got response &#39;res&#39; from a server </div><div class="line"><a name="l11589"></a><span class="lineno">11589</span>&#160;   } </div><div class="line"><a name="l11590"></a><span class="lineno">11590</span>&#160;   if (soap.error == SOAP_EOF &amp;&amp; soap.errnum == 0) </div><div class="line"><a name="l11591"></a><span class="lineno">11591</span>&#160;     // Timeout: no more messages received </div><div class="line"><a name="l11592"></a><span class="lineno">11592</span>&#160;   else </div><div class="line"><a name="l11593"></a><span class="lineno">11593</span>&#160;     soap_print_fault(&amp;soap, stderr); </div><div class="line"><a name="l11594"></a><span class="lineno">11594</span>&#160;} </div><div class="line"><a name="l11595"></a><span class="lineno">11595</span>&#160;soap_destroy(&amp;soap); // cleanup </div><div class="line"><a name="l11596"></a><span class="lineno">11596</span>&#160;soap_end(&amp;soap); // cleanup </div><div class="line"><a name="l11597"></a><span class="lineno">11597</span>&#160;soap_done(&amp;soap); // close connection (should not use soap struct after this)</div><div class="line"><a name="l11598"></a><span class="lineno">11598</span>&#160;```</div><div class="line"><a name="l11599"></a><span class="lineno">11599</span>&#160;</div><div class="line"><a name="l11600"></a><span class="lineno">11600</span>&#160;Note that a server for the `bcastString` does not need to use two-one way</div><div class="line"><a name="l11601"></a><span class="lineno">11601</span>&#160;messages.  Thus, multicast request-response message pattern can be declared and</div><div class="line"><a name="l11602"></a><span class="lineno">11602</span>&#160;implemented as request-response operations at the server side.</div><div class="line"><a name="l11603"></a><span class="lineno">11603</span>&#160;</div><div class="line"><a name="l11604"></a><span class="lineno">11604</span>&#160;## SOAP-over-UDP Server        {#soapoverudp}</div><div class="line"><a name="l11605"></a><span class="lineno">11605</span>&#160;</div><div class="line"><a name="l11606"></a><span class="lineno">11606</span>&#160;The following example code illustrates a SOAP-over-UDP server for one-way `sendString` and request-response `echoString` messages.</div><div class="line"><a name="l11607"></a><span class="lineno">11607</span>&#160;This example assumes that the gSOAP header file includes the SOAP Header with</div><div class="line"><a name="l11608"></a><span class="lineno">11608</span>&#160;WS-Addressing elements and the `ns__echoString` function discussed in</div><div class="line"><a name="l11609"></a><span class="lineno">11609</span>&#160;Section \ref udp.h .</div><div class="line"><a name="l11610"></a><span class="lineno">11610</span>&#160;</div><div class="line"><a name="l11611"></a><span class="lineno">11611</span>&#160;```cpp</div><div class="line"><a name="l11612"></a><span class="lineno">11612</span>&#160;int main() </div><div class="line"><a name="l11613"></a><span class="lineno">11613</span>&#160;{ </div><div class="line"><a name="l11614"></a><span class="lineno">11614</span>&#160;   struct soap soap; </div><div class="line"><a name="l11615"></a><span class="lineno">11615</span>&#160;   soap_init1(&amp;soap, SOAP_IO_UDP); // must set UDP flag </div><div class="line"><a name="l11616"></a><span class="lineno">11616</span>&#160;   // bind to host (NULL=current host) and port: </div><div class="line"><a name="l11617"></a><span class="lineno">11617</span>&#160;   if (!soap_valid_socket(soap_bind(&amp;soap, host, port, 100))) </div><div class="line"><a name="l11618"></a><span class="lineno">11618</span>&#160;   { </div><div class="line"><a name="l11619"></a><span class="lineno">11619</span>&#160;     soap_print_fault(&amp;soap, stderr); </div><div class="line"><a name="l11620"></a><span class="lineno">11620</span>&#160;     exit(1); </div><div class="line"><a name="l11621"></a><span class="lineno">11621</span>&#160;   } </div><div class="line"><a name="l11622"></a><span class="lineno">11622</span>&#160;   for (;;) </div><div class="line"><a name="l11623"></a><span class="lineno">11623</span>&#160;   { </div><div class="line"><a name="l11624"></a><span class="lineno">11624</span>&#160;     if (soap_serve(&amp;soap)) </div><div class="line"><a name="l11625"></a><span class="lineno">11625</span>&#160;       soap_print_fault(&amp;soap, stderr); // report the problem </div><div class="line"><a name="l11626"></a><span class="lineno">11626</span>&#160;     soap_destroy(&amp;soap); </div><div class="line"><a name="l11627"></a><span class="lineno">11627</span>&#160;     soap_end(&amp;soap); </div><div class="line"><a name="l11628"></a><span class="lineno">11628</span>&#160;   } </div><div class="line"><a name="l11629"></a><span class="lineno">11629</span>&#160;   soap_done(&amp;soap); // close connection </div><div class="line"><a name="l11630"></a><span class="lineno">11630</span>&#160;} </div><div class="line"><a name="l11631"></a><span class="lineno">11631</span>&#160;int ns__echoString(struct soap *soap, char *str, char **res) </div><div class="line"><a name="l11632"></a><span class="lineno">11632</span>&#160;{ </div><div class="line"><a name="l11633"></a><span class="lineno">11633</span>&#160;   if (!soap-&gt;header) </div><div class="line"><a name="l11634"></a><span class="lineno">11634</span>&#160;     return soap_sender_fault(soap, &quot;No SOAP header&quot;, NULL); </div><div class="line"><a name="l11635"></a><span class="lineno">11635</span>&#160;   if (!soap-&gt;header-&gt;wsa__MessageID) </div><div class="line"><a name="l11636"></a><span class="lineno">11636</span>&#160;     return soap_sender_fault(soap, &quot;No WS-Addressing MessageID&quot;, NULL); </div><div class="line"><a name="l11637"></a><span class="lineno">11637</span>&#160;   soap-&gt;header-&gt;wsa__RelatesTo = (struct wsa__Relationship*)soap_malloc(soap, sizeof(struct wsa__Relationship)); </div><div class="line"><a name="l11638"></a><span class="lineno">11638</span>&#160;   soap_default_wsa__Relationship(soap, soap-&gt;header-&gt;wsa__RelatesTo); </div><div class="line"><a name="l11639"></a><span class="lineno">11639</span>&#160;   soap-&gt;header-&gt;wsa__RelatesTo-&gt;__item = soap-&gt;header-&gt;wsa__MessageID; </div><div class="line"><a name="l11640"></a><span class="lineno">11640</span>&#160;   // must check for duplicate messages </div><div class="line"><a name="l11641"></a><span class="lineno">11641</span>&#160;   if (check_received(soap-&gt;header-&gt;wsa__MessageID)) </div><div class="line"><a name="l11642"></a><span class="lineno">11642</span>&#160;   { </div><div class="line"><a name="l11643"></a><span class="lineno">11643</span>&#160;     // Request message already received </div><div class="line"><a name="l11644"></a><span class="lineno">11644</span>&#160;     return SOAP_STOP; // don&#39;t return response </div><div class="line"><a name="l11645"></a><span class="lineno">11645</span>&#160;   } </div><div class="line"><a name="l11646"></a><span class="lineno">11646</span>&#160;   if (!soap-&gt;header-&gt;wsa__ReplyTo || !soap-&gt;header-&gt;wsa__ReplyTo-&gt;Address) </div><div class="line"><a name="l11647"></a><span class="lineno">11647</span>&#160;     return soap_sender_fault(soap, &quot;No WS-Addressing ReplyTo address&quot;, NULL); </div><div class="line"><a name="l11648"></a><span class="lineno">11648</span>&#160;   soap-&gt;header-&gt;wsa__To = soap-&gt;header-&gt;wsa__ReplyTo-&gt;Address; </div><div class="line"><a name="l11649"></a><span class="lineno">11649</span>&#160;   soap-&gt;header-&gt;wsa__MessageID = soap_strdup(soap, soap_int2s(soap, id_count++)) ; </div><div class="line"><a name="l11650"></a><span class="lineno">11650</span>&#160;   soap-&gt;header-&gt;wsa__Action = &quot;http://genivia.com/udp/echoStringResponse&quot;; </div><div class="line"><a name="l11651"></a><span class="lineno">11651</span>&#160;   *res = str; </div><div class="line"><a name="l11652"></a><span class="lineno">11652</span>&#160;   return SOAP_OK; </div><div class="line"><a name="l11653"></a><span class="lineno">11653</span>&#160;} </div><div class="line"><a name="l11654"></a><span class="lineno">11654</span>&#160;int ns__sendString(struct soap *soap, char *str) </div><div class="line"><a name="l11655"></a><span class="lineno">11655</span>&#160;{ </div><div class="line"><a name="l11656"></a><span class="lineno">11656</span>&#160;   if (!soap-&gt;header) </div><div class="line"><a name="l11657"></a><span class="lineno">11657</span>&#160;     return SOAP_STOP; </div><div class="line"><a name="l11658"></a><span class="lineno">11658</span>&#160;   if (!soap-&gt;header-&gt;wsa__MessageID) </div><div class="line"><a name="l11659"></a><span class="lineno">11659</span>&#160;     return SOAP_STOP; </div><div class="line"><a name="l11660"></a><span class="lineno">11660</span>&#160;   // must check for duplicate messages </div><div class="line"><a name="l11661"></a><span class="lineno">11661</span>&#160;   if (check_received(soap-&gt;header-&gt;wsa__MessageID)) </div><div class="line"><a name="l11662"></a><span class="lineno">11662</span>&#160;     return SOAP_STOP; </div><div class="line"><a name="l11663"></a><span class="lineno">11663</span>&#160;   return SOAP_OK; </div><div class="line"><a name="l11664"></a><span class="lineno">11664</span>&#160;} </div><div class="line"><a name="l11665"></a><span class="lineno">11665</span>&#160;int ns__sendStringResponse(struct soap *soap, char *res) </div><div class="line"><a name="l11666"></a><span class="lineno">11666</span>&#160;{ return SOAP_NO_METHOD; } // we don&#39;t expect to serve this message</div><div class="line"><a name="l11667"></a><span class="lineno">11667</span>&#160;```</div><div class="line"><a name="l11668"></a><span class="lineno">11668</span>&#160;</div><div class="line"><a name="l11669"></a><span class="lineno">11669</span>&#160;The server binds to a host and port and accepts messages in a tight sequential</div><div class="line"><a name="l11670"></a><span class="lineno">11670</span>&#160;loop.  Because UDP does not have the equivalent of an accept the messages</div><div class="line"><a name="l11671"></a><span class="lineno">11671</span>&#160;cannot be dispatched to threads, the `soap_serve` waits for a message and</div><div class="line"><a name="l11672"></a><span class="lineno">11672</span>&#160;immediately accepts it. You can use a receive timeout to make `soap_serve`</div><div class="line"><a name="l11673"></a><span class="lineno">11673</span>&#160;non-blocking.</div><div class="line"><a name="l11674"></a><span class="lineno">11674</span>&#160;</div><div class="line"><a name="l11675"></a><span class="lineno">11675</span>&#160;To obtain response one-way operations from a WSDL, use the wsdl2h `-b` option. This produces additional one-way operations to support asynchronous handling of response messages in the same way requests are handled.</div><div class="line"><a name="l11676"></a><span class="lineno">11676</span>&#160;</div><div class="line"><a name="l11677"></a><span class="lineno">11677</span>&#160;## SOAP-over-UDP Multicast Receiving Server</div><div class="line"><a name="l11678"></a><span class="lineno">11678</span>&#160;</div><div class="line"><a name="l11679"></a><span class="lineno">11679</span>&#160;For UDP multicast support, follow the suggestions in</div><div class="line"><a name="l11680"></a><span class="lineno">11680</span>&#160;Section \ref soapoverudp  and change the initialization parts of the code</div><div class="line"><a name="l11681"></a><span class="lineno">11681</span>&#160;to enable UDP multicast port binding by to telliing the kernel which multicast</div><div class="line"><a name="l11682"></a><span class="lineno">11682</span>&#160;groups you are interested in:</div><div class="line"><a name="l11683"></a><span class="lineno">11683</span>&#160;</div><div class="line"><a name="l11684"></a><span class="lineno">11684</span>&#160;```cpp</div><div class="line"><a name="l11685"></a><span class="lineno">11685</span>&#160;int main() </div><div class="line"><a name="l11686"></a><span class="lineno">11686</span>&#160;{ </div><div class="line"><a name="l11687"></a><span class="lineno">11687</span>&#160;   struct soap soap; </div><div class="line"><a name="l11688"></a><span class="lineno">11688</span>&#160;   struct ip_mreq mcast; </div><div class="line"><a name="l11689"></a><span class="lineno">11689</span>&#160;   soap_init1(&amp;soap, SOAP_IO_UDP); </div><div class="line"><a name="l11690"></a><span class="lineno">11690</span>&#160;   if (!soap_valid_socket(soap_bind(&amp;soap, host, port, 100))) </div><div class="line"><a name="l11691"></a><span class="lineno">11691</span>&#160;   { </div><div class="line"><a name="l11692"></a><span class="lineno">11692</span>&#160;     soap_print_fault(&amp;soap, stderr); </div><div class="line"><a name="l11693"></a><span class="lineno">11693</span>&#160;     exit(1); </div><div class="line"><a name="l11694"></a><span class="lineno">11694</span>&#160;   } </div><div class="line"><a name="l11695"></a><span class="lineno">11695</span>&#160;   mcast.imr_multiaddr.s_addr = inet_addr(&quot;{\tt put IP multicast address of group here}&quot;); </div><div class="line"><a name="l11696"></a><span class="lineno">11696</span>&#160;   mcast.imr_interface.s_addr = htonl(INADDR_ANY); </div><div class="line"><a name="l11697"></a><span class="lineno">11697</span>&#160;   if (setsockopt(soap.master, IPPROTO_IP, IP_ADD_MEMBERSHIP, &amp;mcast, sizeof(mcast))&lt;0) </div><div class="line"><a name="l11698"></a><span class="lineno">11698</span>&#160;     ... error ...</div><div class="line"><a name="l11699"></a><span class="lineno">11699</span>&#160;```</div><div class="line"><a name="l11700"></a><span class="lineno">11700</span>&#160;</div><div class="line"><a name="l11701"></a><span class="lineno">11701</span>&#160;# Advanced Features        {#advanced}</div><div class="line"><a name="l11702"></a><span class="lineno">11702</span>&#160;</div><div class="line"><a name="l11703"></a><span class="lineno">11703</span>&#160;## Internationalization</div><div class="line"><a name="l11704"></a><span class="lineno">11704</span>&#160;</div><div class="line"><a name="l11705"></a><span class="lineno">11705</span>&#160;gSOAP uses regular strings by default.  Regular strings cannot be used to hold</div><div class="line"><a name="l11706"></a><span class="lineno">11706</span>&#160;UCS characters outside of the character range [1,255].  gSOAP can handle</div><div class="line"><a name="l11707"></a><span class="lineno">11707</span>&#160;wide-character content in two ways. First, applications can utilize</div><div class="line"><a name="l11708"></a><span class="lineno">11708</span>&#160;wide-character strings (`wchar_t*`) instead of regular strings to store</div><div class="line"><a name="l11709"></a><span class="lineno">11709</span>&#160;wide-character content.  For example, the *`xsd:string`* string schema type</div><div class="line"><a name="l11710"></a><span class="lineno">11710</span>&#160;can be declared as a wide-character string and used subsequently:</div><div class="line"><a name="l11711"></a><span class="lineno">11711</span>&#160;</div><div class="line"><a name="l11712"></a><span class="lineno">11712</span>&#160;```cpp</div><div class="line"><a name="l11713"></a><span class="lineno">11713</span>&#160;typedef wchar_t *xsd__string; </div><div class="line"><a name="l11714"></a><span class="lineno">11714</span>&#160;... </div><div class="line"><a name="l11715"></a><span class="lineno">11715</span>&#160;int ns__myMethod(xsd__string input, xsd__string *output);</div><div class="line"><a name="l11716"></a><span class="lineno">11716</span>&#160;```</div><div class="line"><a name="l11717"></a><span class="lineno">11717</span>&#160;</div><div class="line"><a name="l11718"></a><span class="lineno">11718</span>&#160;Second, regular strings can be used to hold wide-character content in UTF-8</div><div class="line"><a name="l11719"></a><span class="lineno">11719</span>&#160;format.  This is accomplished with the `SOAP_C_UTFSTRING` flag (for both input/output mode), see Section \ref flags .</div><div class="line"><a name="l11720"></a><span class="lineno">11720</span>&#160;With this flag set, gSOAP will deserialize XML into</div><div class="line"><a name="l11721"></a><span class="lineno">11721</span>&#160;regular strings in UTF-8 format.  An application is responsible for filling</div><div class="line"><a name="l11722"></a><span class="lineno">11722</span>&#160;regular strings with UTF-8 content to ensure that strings can be correctly serialized XML.</div><div class="line"><a name="l11723"></a><span class="lineno">11723</span>&#160;Third, the `SOAP_C_MBSTRING` flag (for both input/output mode) can be used to activate multibyte character support. Multibyte support depends on the locale settings for dealing with extended natural language encodings.</div><div class="line"><a name="l11724"></a><span class="lineno">11724</span>&#160;</div><div class="line"><a name="l11725"></a><span class="lineno">11725</span>&#160;Both regular strings and wide-character strings can be used together within an application.</div><div class="line"><a name="l11726"></a><span class="lineno">11726</span>&#160;For example, the following header file declaration introduces two string schema types:</div><div class="line"><a name="l11727"></a><span class="lineno">11727</span>&#160;</div><div class="line"><a name="l11728"></a><span class="lineno">11728</span>&#160;```cpp</div><div class="line"><a name="l11729"></a><span class="lineno">11729</span>&#160;typedef wchar_t *xsd__string; </div><div class="line"><a name="l11730"></a><span class="lineno">11730</span>&#160;typedef char *xsd__string_; // trailing &#39;_&#39; avoids name clash </div><div class="line"><a name="l11731"></a><span class="lineno">11731</span>&#160;... </div><div class="line"><a name="l11732"></a><span class="lineno">11732</span>&#160;int ns__myMethod(xsd__string input, xsd__string_ *output);</div><div class="line"><a name="l11733"></a><span class="lineno">11733</span>&#160;```</div><div class="line"><a name="l11734"></a><span class="lineno">11734</span>&#160;</div><div class="line"><a name="l11735"></a><span class="lineno">11735</span>&#160;The `input` string parameter is a wide-character string and the `output` string</div><div class="line"><a name="l11736"></a><span class="lineno">11736</span>&#160;parameter is a regular string.  The regular string has UCS character content </div><div class="line"><a name="l11737"></a><span class="lineno">11737</span>&#160;in the range [1,255] unless the</div><div class="line"><a name="l11738"></a><span class="lineno">11738</span>&#160;`SOAP_C_UTFSTRING` flag is set.  With this flag, the string has UTF-8</div><div class="line"><a name="l11739"></a><span class="lineno">11739</span>&#160;encoded content.</div><div class="line"><a name="l11740"></a><span class="lineno">11740</span>&#160;</div><div class="line"><a name="l11741"></a><span class="lineno">11741</span>&#160;Please consult the UTF-8 specification for details on the UTF-8 format.</div><div class="line"><a name="l11742"></a><span class="lineno">11742</span>&#160;Note that the ASCII character set [1-127] is a subset of UTF-8. Therefore, with the `SOAP_C_UTFSTRING` flag set, strings may hold ASCII character data and UTF-8 extensions.</div><div class="line"><a name="l11743"></a><span class="lineno">11743</span>&#160;</div><div class="line"><a name="l11744"></a><span class="lineno">11744</span>&#160;## Customizing the WSDL and Namespace Mapping Table File Contents With gSOAP Directives        {#directives}</div><div class="line"><a name="l11745"></a><span class="lineno">11745</span>&#160;</div><div class="line"><a name="l11746"></a><span class="lineno">11746</span>&#160;A header file can be augmented with directives for the gSOAP `soapcpp2` tool to automatically generate customized WSDL and namespace mapping tables contents. The WSDL and namespace mapping table files do not need to be modified by hand (Sections \ref wsdl  and \ref nstable ).</div><div class="line"><a name="l11747"></a><span class="lineno">11747</span>&#160;In addition, the sample SOAP/XML request and response files generated by the compiler are valid provided that XML Schema namespace</div><div class="line"><a name="l11748"></a><span class="lineno">11748</span>&#160;information is added to the header file with directives so that the gSOAP `soapcpp2` compiler can produce example SOAP/XML messages that are correctly namespace qualified.</div><div class="line"><a name="l11749"></a><span class="lineno">11749</span>&#160;These compiler directive are specified as `//`-comments.</div><div class="line"><a name="l11750"></a><span class="lineno">11750</span>&#160;(Note: blanks can be used anywhere in the directive, except between `//` and `gsoap`.)</div><div class="line"><a name="l11751"></a><span class="lineno">11751</span>&#160;</div><div class="line"><a name="l11752"></a><span class="lineno">11752</span>&#160;Three directives are currently supported that can be used to specify details associated with namespace prefixes used by the service operation</div><div class="line"><a name="l11753"></a><span class="lineno">11753</span>&#160;names in the header file.</div><div class="line"><a name="l11754"></a><span class="lineno">11754</span>&#160;To specify the name of a Web Service in the header file, use:</div><div class="line"><a name="l11755"></a><span class="lineno">11755</span>&#160;</div><div class="line"><a name="l11756"></a><span class="lineno">11756</span>&#160;```cpp</div><div class="line"><a name="l11757"></a><span class="lineno">11757</span>&#160;//gsoap *namespace-prefix* service name: *service-name*</div><div class="line"><a name="l11758"></a><span class="lineno">11758</span>&#160;```</div><div class="line"><a name="l11759"></a><span class="lineno">11759</span>&#160;</div><div class="line"><a name="l11760"></a><span class="lineno">11760</span>&#160;where *namespace-prefix* is a namespace prefix used by identifiers in the header file and *service-name* is the name</div><div class="line"><a name="l11761"></a><span class="lineno">11761</span>&#160;of a Web Service (only required to create new Web Services).</div><div class="line"><a name="l11762"></a><span class="lineno">11762</span>&#160;The name may be followed by text up to the end of the line which is incorporated into the WSDL service documentation. Alternatively, the service documentation can be provided with the directive below.</div><div class="line"><a name="l11763"></a><span class="lineno">11763</span>&#160;</div><div class="line"><a name="l11764"></a><span class="lineno">11764</span>&#160;To specify the name of the WSDL definitions in the header file, use:</div><div class="line"><a name="l11765"></a><span class="lineno">11765</span>&#160;</div><div class="line"><a name="l11766"></a><span class="lineno">11766</span>&#160;```cpp</div><div class="line"><a name="l11767"></a><span class="lineno">11767</span>&#160;//gsoap *namespace-prefix* service definitions: *definitions-name*</div><div class="line"><a name="l11768"></a><span class="lineno">11768</span>&#160;```</div><div class="line"><a name="l11769"></a><span class="lineno">11769</span>&#160;</div><div class="line"><a name="l11770"></a><span class="lineno">11770</span>&#160;where *namespace-prefix* is a namespace prefix used by identifiers in the header file and *definitions-name* is the name of the WSDL definitions. By default, the WSDL definitions name is the same as the service name.</div><div class="line"><a name="l11771"></a><span class="lineno">11771</span>&#160;</div><div class="line"><a name="l11772"></a><span class="lineno">11772</span>&#160;To specify the documentation of a Web Service in the header file, use:</div><div class="line"><a name="l11773"></a><span class="lineno">11773</span>&#160;</div><div class="line"><a name="l11774"></a><span class="lineno">11774</span>&#160;```cpp</div><div class="line"><a name="l11775"></a><span class="lineno">11775</span>&#160;//gsoap *namespace-prefix* service documentation: *text*</div><div class="line"><a name="l11776"></a><span class="lineno">11776</span>&#160;```</div><div class="line"><a name="l11777"></a><span class="lineno">11777</span>&#160;</div><div class="line"><a name="l11778"></a><span class="lineno">11778</span>&#160;or shorthand:</div><div class="line"><a name="l11779"></a><span class="lineno">11779</span>&#160;</div><div class="line"><a name="l11780"></a><span class="lineno">11780</span>&#160;```cpp</div><div class="line"><a name="l11781"></a><span class="lineno">11781</span>&#160;//gsoap *namespace-prefix* service doc: *text*</div><div class="line"><a name="l11782"></a><span class="lineno">11782</span>&#160;```</div><div class="line"><a name="l11783"></a><span class="lineno">11783</span>&#160;</div><div class="line"><a name="l11784"></a><span class="lineno">11784</span>&#160;where *namespace-prefix* is a namespace prefix used by identifiers in the header file and *text* is the documentation text up to the end of the line.</div><div class="line"><a name="l11785"></a><span class="lineno">11785</span>&#160;The text is incorporated into the WSDL service documentation.</div><div class="line"><a name="l11786"></a><span class="lineno">11786</span>&#160;</div><div class="line"><a name="l11787"></a><span class="lineno">11787</span>&#160;To specify the portType of a Web Service in the header file, use:</div><div class="line"><a name="l11788"></a><span class="lineno">11788</span>&#160;</div><div class="line"><a name="l11789"></a><span class="lineno">11789</span>&#160;```cpp</div><div class="line"><a name="l11790"></a><span class="lineno">11790</span>&#160;//gsoap *namespace-prefix* service portType: *portType-name*</div><div class="line"><a name="l11791"></a><span class="lineno">11791</span>&#160;```</div><div class="line"><a name="l11792"></a><span class="lineno">11792</span>&#160;</div><div class="line"><a name="l11793"></a><span class="lineno">11793</span>&#160;or just</div><div class="line"><a name="l11794"></a><span class="lineno">11794</span>&#160;</div><div class="line"><a name="l11795"></a><span class="lineno">11795</span>&#160;```cpp</div><div class="line"><a name="l11796"></a><span class="lineno">11796</span>&#160;//gsoap *namespace-prefix* service type: *portType-name*</div><div class="line"><a name="l11797"></a><span class="lineno">11797</span>&#160;```</div><div class="line"><a name="l11798"></a><span class="lineno">11798</span>&#160;</div><div class="line"><a name="l11799"></a><span class="lineno">11799</span>&#160;or using WSDL 2.0 terms</div><div class="line"><a name="l11800"></a><span class="lineno">11800</span>&#160;</div><div class="line"><a name="l11801"></a><span class="lineno">11801</span>&#160;```cpp</div><div class="line"><a name="l11802"></a><span class="lineno">11802</span>&#160;//gsoap *namespace-prefix* service interface: *portType-name*</div><div class="line"><a name="l11803"></a><span class="lineno">11803</span>&#160;```</div><div class="line"><a name="l11804"></a><span class="lineno">11804</span>&#160;</div><div class="line"><a name="l11805"></a><span class="lineno">11805</span>&#160;where *namespace-prefix* is a namespace prefix used by identifiers in the header file and *portType-name* is the portType name of the WSDL service portType.</div><div class="line"><a name="l11806"></a><span class="lineno">11806</span>&#160;</div><div class="line"><a name="l11807"></a><span class="lineno">11807</span>&#160;To specify the port name of a Web Service in the header file, use:</div><div class="line"><a name="l11808"></a><span class="lineno">11808</span>&#160;</div><div class="line"><a name="l11809"></a><span class="lineno">11809</span>&#160;```cpp</div><div class="line"><a name="l11810"></a><span class="lineno">11810</span>&#160;//gsoap *namespace-prefix* service portName: *port-name*</div><div class="line"><a name="l11811"></a><span class="lineno">11811</span>&#160;```</div><div class="line"><a name="l11812"></a><span class="lineno">11812</span>&#160;</div><div class="line"><a name="l11813"></a><span class="lineno">11813</span>&#160;where *namespace-prefix* is a namespace prefix used by identifiers in the header file and *port-name* is the name of the WSDL service port element. By default, the port name is the same as the service name.</div><div class="line"><a name="l11814"></a><span class="lineno">11814</span>&#160;</div><div class="line"><a name="l11815"></a><span class="lineno">11815</span>&#160;To specify the binding name of a Web Service in the header file, use:</div><div class="line"><a name="l11816"></a><span class="lineno">11816</span>&#160;</div><div class="line"><a name="l11817"></a><span class="lineno">11817</span>&#160;```cpp</div><div class="line"><a name="l11818"></a><span class="lineno">11818</span>&#160;//gsoap *namespace-prefix* service binding: *binding-name*</div><div class="line"><a name="l11819"></a><span class="lineno">11819</span>&#160;```</div><div class="line"><a name="l11820"></a><span class="lineno">11820</span>&#160;</div><div class="line"><a name="l11821"></a><span class="lineno">11821</span>&#160;where *namespace-prefix* is a namespace prefix used by identifiers in the header file and *binding-name* is the binding name of the WSDL service binding element. By default, the binding name is the same as the service name.</div><div class="line"><a name="l11822"></a><span class="lineno">11822</span>&#160;</div><div class="line"><a name="l11823"></a><span class="lineno">11823</span>&#160;To specify the binding&#39;s transport protocol of a Web Service in the header file, use:</div><div class="line"><a name="l11824"></a><span class="lineno">11824</span>&#160;</div><div class="line"><a name="l11825"></a><span class="lineno">11825</span>&#160;```cpp</div><div class="line"><a name="l11826"></a><span class="lineno">11826</span>&#160;//gsoap *namespace-prefix* service transport: *transport-URL*</div><div class="line"><a name="l11827"></a><span class="lineno">11827</span>&#160;```</div><div class="line"><a name="l11828"></a><span class="lineno">11828</span>&#160;</div><div class="line"><a name="l11829"></a><span class="lineno">11829</span>&#160;where *namespace-prefix* is a namespace prefix used by identifiers in the header file and *transport-URL* is the URL of the transport protocol such as `http://schemas.xmlsoap.org/soap/http` for HTTP. HTTP transport is assumed by default.</div><div class="line"><a name="l11830"></a><span class="lineno">11830</span>&#160;</div><div class="line"><a name="l11831"></a><span class="lineno">11831</span>&#160;To specify the location (or port endpoint) of a Web Service in the header file, use:</div><div class="line"><a name="l11832"></a><span class="lineno">11832</span>&#160;</div><div class="line"><a name="l11833"></a><span class="lineno">11833</span>&#160;```cpp</div><div class="line"><a name="l11834"></a><span class="lineno">11834</span>&#160;//gsoap *namespace-prefix* service location: *URL*</div><div class="line"><a name="l11835"></a><span class="lineno">11835</span>&#160;```</div><div class="line"><a name="l11836"></a><span class="lineno">11836</span>&#160;</div><div class="line"><a name="l11837"></a><span class="lineno">11837</span>&#160;or alternatively</div><div class="line"><a name="l11838"></a><span class="lineno">11838</span>&#160;</div><div class="line"><a name="l11839"></a><span class="lineno">11839</span>&#160;```cpp</div><div class="line"><a name="l11840"></a><span class="lineno">11840</span>&#160;//gsoap *namespace-prefix* service endpoint: *URL*</div><div class="line"><a name="l11841"></a><span class="lineno">11841</span>&#160;```</div><div class="line"><a name="l11842"></a><span class="lineno">11842</span>&#160;</div><div class="line"><a name="l11843"></a><span class="lineno">11843</span>&#160;or</div><div class="line"><a name="l11844"></a><span class="lineno">11844</span>&#160;</div><div class="line"><a name="l11845"></a><span class="lineno">11845</span>&#160;```cpp</div><div class="line"><a name="l11846"></a><span class="lineno">11846</span>&#160;//gsoap *namespace-prefix* service port: *URL*</div><div class="line"><a name="l11847"></a><span class="lineno">11847</span>&#160;```</div><div class="line"><a name="l11848"></a><span class="lineno">11848</span>&#160;</div><div class="line"><a name="l11849"></a><span class="lineno">11849</span>&#160;where *URL* is the location of the Web Service (only required to create new Web Services).</div><div class="line"><a name="l11850"></a><span class="lineno">11850</span>&#160;The *URL* specifies the path to the service executable (so URL/service-executable</div><div class="line"><a name="l11851"></a><span class="lineno">11851</span>&#160;is the actual location of the executable when declared).</div><div class="line"><a name="l11852"></a><span class="lineno">11852</span>&#160;</div><div class="line"><a name="l11853"></a><span class="lineno">11853</span>&#160;To specify the name of the executable of a Web Service in the header file, use:</div><div class="line"><a name="l11854"></a><span class="lineno">11854</span>&#160;</div><div class="line"><a name="l11855"></a><span class="lineno">11855</span>&#160;```cpp</div><div class="line"><a name="l11856"></a><span class="lineno">11856</span>&#160;//gsoap *namespace-prefix* service executable: *executable-name*</div><div class="line"><a name="l11857"></a><span class="lineno">11857</span>&#160;```</div><div class="line"><a name="l11858"></a><span class="lineno">11858</span>&#160;</div><div class="line"><a name="l11859"></a><span class="lineno">11859</span>&#160;where *executable-name* is the name of the executable of the Web Service.</div><div class="line"><a name="l11860"></a><span class="lineno">11860</span>&#160;</div><div class="line"><a name="l11861"></a><span class="lineno">11861</span>&#160;When doc/literal encoding is required for the entire service, the service encoding can be specified in the header file as follows:</div><div class="line"><a name="l11862"></a><span class="lineno">11862</span>&#160;</div><div class="line"><a name="l11863"></a><span class="lineno">11863</span>&#160;```cpp</div><div class="line"><a name="l11864"></a><span class="lineno">11864</span>&#160;//gsoap *namespace-prefix* service encoding: literal</div><div class="line"><a name="l11865"></a><span class="lineno">11865</span>&#160;```</div><div class="line"><a name="l11866"></a><span class="lineno">11866</span>&#160;</div><div class="line"><a name="l11867"></a><span class="lineno">11867</span>&#160;or when the *`SOAP-ENV:encodingStyle`* attribute is different from the SOAP 1.1/1.2 encoding style:</div><div class="line"><a name="l11868"></a><span class="lineno">11868</span>&#160;</div><div class="line"><a name="l11869"></a><span class="lineno">11869</span>&#160;```cpp</div><div class="line"><a name="l11870"></a><span class="lineno">11870</span>&#160;//gsoap *namespace-prefix* service encoding: *encoding-style*</div><div class="line"><a name="l11871"></a><span class="lineno">11871</span>&#160;```</div><div class="line"><a name="l11872"></a><span class="lineno">11872</span>&#160;</div><div class="line"><a name="l11873"></a><span class="lineno">11873</span>&#160;To specify the namespace URI of a Web Service in the header file, use:</div><div class="line"><a name="l11874"></a><span class="lineno">11874</span>&#160;</div><div class="line"><a name="l11875"></a><span class="lineno">11875</span>&#160;```cpp</div><div class="line"><a name="l11876"></a><span class="lineno">11876</span>&#160;//gsoap *namespace-prefix* service namespace: *namespace-URI*</div><div class="line"><a name="l11877"></a><span class="lineno">11877</span>&#160;```</div><div class="line"><a name="l11878"></a><span class="lineno">11878</span>&#160;</div><div class="line"><a name="l11879"></a><span class="lineno">11879</span>&#160;where *namespace-URI* is the URI associated with the namespace prefix.</div><div class="line"><a name="l11880"></a><span class="lineno">11880</span>&#160;</div><div class="line"><a name="l11881"></a><span class="lineno">11881</span>&#160;In addition, the schema namespace URI can be specified in the header file:</div><div class="line"><a name="l11882"></a><span class="lineno">11882</span>&#160;</div><div class="line"><a name="l11883"></a><span class="lineno">11883</span>&#160;```cpp</div><div class="line"><a name="l11884"></a><span class="lineno">11884</span>&#160;//gsoap *namespace-prefix* schema namespace: *namespace-URI*</div><div class="line"><a name="l11885"></a><span class="lineno">11885</span>&#160;```</div><div class="line"><a name="l11886"></a><span class="lineno">11886</span>&#160;</div><div class="line"><a name="l11887"></a><span class="lineno">11887</span>&#160;where *namespace-URI* is the schema URI associated with the namespace prefix.</div><div class="line"><a name="l11888"></a><span class="lineno">11888</span>&#160;If present, it defines the schema-part of the generated WSDL file and the URI in the namespace mapping table.</div><div class="line"><a name="l11889"></a><span class="lineno">11889</span>&#160;This declaration is useful when the service declares its own data types that need to be associated with a namespace.</div><div class="line"><a name="l11890"></a><span class="lineno">11890</span>&#160;Furthermore, the header file for client applications do not need the full service details and the specification of the schema</div><div class="line"><a name="l11891"></a><span class="lineno">11891</span>&#160;namespaces for namespace prefixes suffices.</div><div class="line"><a name="l11892"></a><span class="lineno">11892</span>&#160;In addition, a second namespace can be defined that is only used to match the namespaces of inbound XML:</div><div class="line"><a name="l11893"></a><span class="lineno">11893</span>&#160;</div><div class="line"><a name="l11894"></a><span class="lineno">11894</span>&#160;```cpp</div><div class="line"><a name="l11895"></a><span class="lineno">11895</span>&#160;//gsoap *namespace-prefix* schema namespace2: *namespace-URI-pattern*</div><div class="line"><a name="l11896"></a><span class="lineno">11896</span>&#160;```</div><div class="line"><a name="l11897"></a><span class="lineno">11897</span>&#160;</div><div class="line"><a name="l11898"></a><span class="lineno">11898</span>&#160;If the first namespace does not match the inbound parsed XML, then the second</div><div class="line"><a name="l11899"></a><span class="lineno">11899</span>&#160;will be tried. This pattern may contain `*` multichar wildcards and `-` single</div><div class="line"><a name="l11900"></a><span class="lineno">11900</span>&#160;chard wildcards. This allows two or more namespace versions to be handled by</div><div class="line"><a name="l11901"></a><span class="lineno">11901</span>&#160;the same namespace prefix.</div><div class="line"><a name="l11902"></a><span class="lineno">11902</span>&#160;</div><div class="line"><a name="l11903"></a><span class="lineno">11903</span>&#160;The directive above specifies a new schema and the gSOAP `soapcpp2` compiler generates a schema files (.xsd) file for the schema.</div><div class="line"><a name="l11904"></a><span class="lineno">11904</span>&#160;An existing schema namespace URI can be imported with:</div><div class="line"><a name="l11905"></a><span class="lineno">11905</span>&#160;</div><div class="line"><a name="l11906"></a><span class="lineno">11906</span>&#160;```cpp</div><div class="line"><a name="l11907"></a><span class="lineno">11907</span>&#160;//gsoap *namespace-prefix* schema import: *namespace-URI*</div><div class="line"><a name="l11908"></a><span class="lineno">11908</span>&#160;```</div><div class="line"><a name="l11909"></a><span class="lineno">11909</span>&#160;</div><div class="line"><a name="l11910"></a><span class="lineno">11910</span>&#160;where *namespace-URI* is the schema URI associated with the namespace prefix.</div><div class="line"><a name="l11911"></a><span class="lineno">11911</span>&#160;gSOAP does not produce XML Schema files for imported schemas and imports the schema namespaces in the generated WSDL file.</div><div class="line"><a name="l11912"></a><span class="lineno">11912</span>&#160;</div><div class="line"><a name="l11913"></a><span class="lineno">11913</span>&#160;A schema namespace URI can be imported from a location with:</div><div class="line"><a name="l11914"></a><span class="lineno">11914</span>&#160;</div><div class="line"><a name="l11915"></a><span class="lineno">11915</span>&#160;```cpp</div><div class="line"><a name="l11916"></a><span class="lineno">11916</span>&#160;//gsoap *namespace-prefix* schema namespace: *namespace-URI* </div><div class="line"><a name="l11917"></a><span class="lineno">11917</span>&#160;//gsoap *namespace-prefix* schema import: *schema-location*</div><div class="line"><a name="l11918"></a><span class="lineno">11918</span>&#160;```</div><div class="line"><a name="l11919"></a><span class="lineno">11919</span>&#160;</div><div class="line"><a name="l11920"></a><span class="lineno">11920</span>&#160;The elementFormDefault and attributeFormDefault qualification of a schema can be defined with:</div><div class="line"><a name="l11921"></a><span class="lineno">11921</span>&#160;</div><div class="line"><a name="l11922"></a><span class="lineno">11922</span>&#160;```cpp</div><div class="line"><a name="l11923"></a><span class="lineno">11923</span>&#160;//gsoap *namespace-prefix* schema elementForm: qualified </div><div class="line"><a name="l11924"></a><span class="lineno">11924</span>&#160;//gsoap *namespace-prefix* schema attributeForm: qualified</div><div class="line"><a name="l11925"></a><span class="lineno">11925</span>&#160;```</div><div class="line"><a name="l11926"></a><span class="lineno">11926</span>&#160;</div><div class="line"><a name="l11927"></a><span class="lineno">11927</span>&#160;or:</div><div class="line"><a name="l11928"></a><span class="lineno">11928</span>&#160;</div><div class="line"><a name="l11929"></a><span class="lineno">11929</span>&#160;```cpp</div><div class="line"><a name="l11930"></a><span class="lineno">11930</span>&#160;//gsoap *namespace-prefix* schema elementForm: unqualified </div><div class="line"><a name="l11931"></a><span class="lineno">11931</span>&#160;//gsoap *namespace-prefix* schema attributeForm: unqualified</div><div class="line"><a name="l11932"></a><span class="lineno">11932</span>&#160;```</div><div class="line"><a name="l11933"></a><span class="lineno">11933</span>&#160;</div><div class="line"><a name="l11934"></a><span class="lineno">11934</span>&#160;A shortcut to define the default qualification of elements and attributes of a schema:</div><div class="line"><a name="l11935"></a><span class="lineno">11935</span>&#160;</div><div class="line"><a name="l11936"></a><span class="lineno">11936</span>&#160;```cpp</div><div class="line"><a name="l11937"></a><span class="lineno">11937</span>&#160;//gsoap *namespace-prefix* schema form: qualified</div><div class="line"><a name="l11938"></a><span class="lineno">11938</span>&#160;```</div><div class="line"><a name="l11939"></a><span class="lineno">11939</span>&#160;</div><div class="line"><a name="l11940"></a><span class="lineno">11940</span>&#160;or:</div><div class="line"><a name="l11941"></a><span class="lineno">11941</span>&#160;</div><div class="line"><a name="l11942"></a><span class="lineno">11942</span>&#160;```cpp</div><div class="line"><a name="l11943"></a><span class="lineno">11943</span>&#160;//gsoap *namespace-prefix* schema form: unqualified</div><div class="line"><a name="l11944"></a><span class="lineno">11944</span>&#160;```</div><div class="line"><a name="l11945"></a><span class="lineno">11945</span>&#160;</div><div class="line"><a name="l11946"></a><span class="lineno">11946</span>&#160;To include *`xsi:type`* attributes in the runtime XML element output for specific schemas, use:</div><div class="line"><a name="l11947"></a><span class="lineno">11947</span>&#160;</div><div class="line"><a name="l11948"></a><span class="lineno">11948</span>&#160;```cpp</div><div class="line"><a name="l11949"></a><span class="lineno">11949</span>&#160;//gsoap *namespace-prefix* schema typed: yes</div><div class="line"><a name="l11950"></a><span class="lineno">11950</span>&#160;```</div><div class="line"><a name="l11951"></a><span class="lineno">11951</span>&#160;</div><div class="line"><a name="l11952"></a><span class="lineno">11952</span>&#160;Note that `soapcpp2 -t` enables *`xsi:type`* for all elements in the runtime XML output.</div><div class="line"><a name="l11953"></a><span class="lineno">11953</span>&#160;</div><div class="line"><a name="l11954"></a><span class="lineno">11954</span>&#160;To document a data type, use:</div><div class="line"><a name="l11955"></a><span class="lineno">11955</span>&#160;</div><div class="line"><a name="l11956"></a><span class="lineno">11956</span>&#160;```cpp</div><div class="line"><a name="l11957"></a><span class="lineno">11957</span>&#160;//gsoap *namespace-prefix* schema type-documentation: *type-name* //*text*</div><div class="line"><a name="l11958"></a><span class="lineno">11958</span>&#160;```</div><div class="line"><a name="l11959"></a><span class="lineno">11959</span>&#160;</div><div class="line"><a name="l11960"></a><span class="lineno">11960</span>&#160;or shorthand:</div><div class="line"><a name="l11961"></a><span class="lineno">11961</span>&#160;</div><div class="line"><a name="l11962"></a><span class="lineno">11962</span>&#160;```cpp</div><div class="line"><a name="l11963"></a><span class="lineno">11963</span>&#160;//gsoap *namespace-prefix* schema type: *type-name* //*text*</div><div class="line"><a name="l11964"></a><span class="lineno">11964</span>&#160;```</div><div class="line"><a name="l11965"></a><span class="lineno">11965</span>&#160;</div><div class="line"><a name="l11966"></a><span class="lineno">11966</span>&#160;where *type-name* is the unqualified name of the data type and *text*</div><div class="line"><a name="l11967"></a><span class="lineno">11967</span>&#160;is a line of text terminated by a newline. Do not use any XML reserved</div><div class="line"><a name="l11968"></a><span class="lineno">11968</span>&#160;characters in *text* such as `&lt;` and `&gt;`. Use well-formed XML and XHTML markup instead.</div><div class="line"><a name="l11969"></a><span class="lineno">11969</span>&#160;For example:</div><div class="line"><a name="l11970"></a><span class="lineno">11970</span>&#160;</div><div class="line"><a name="l11971"></a><span class="lineno">11971</span>&#160;```cpp</div><div class="line"><a name="l11972"></a><span class="lineno">11972</span>&#160;//gsoap ns schema type: tdata stores &lt;a href=&quot;transaction.html&quot;&gt;transaction&lt;/a&gt; data </div><div class="line"><a name="l11973"></a><span class="lineno">11973</span>&#160;class ns__tdata </div><div class="line"><a name="l11974"></a><span class="lineno">11974</span>&#160;{ ... }</div><div class="line"><a name="l11975"></a><span class="lineno">11975</span>&#160;```</div><div class="line"><a name="l11976"></a><span class="lineno">11976</span>&#160;</div><div class="line"><a name="l11977"></a><span class="lineno">11977</span>&#160;To document a data type&#39;s fields and members, use:</div><div class="line"><a name="l11978"></a><span class="lineno">11978</span>&#160;</div><div class="line"><a name="l11979"></a><span class="lineno">11979</span>&#160;```cpp</div><div class="line"><a name="l11980"></a><span class="lineno">11980</span>&#160;//gsoap *namespace-prefix* schema type-documentation: *type-name::field* //*text*</div><div class="line"><a name="l11981"></a><span class="lineno">11981</span>&#160;```</div><div class="line"><a name="l11982"></a><span class="lineno">11982</span>&#160;</div><div class="line"><a name="l11983"></a><span class="lineno">11983</span>&#160;or shorthand</div><div class="line"><a name="l11984"></a><span class="lineno">11984</span>&#160;</div><div class="line"><a name="l11985"></a><span class="lineno">11985</span>&#160;```cpp</div><div class="line"><a name="l11986"></a><span class="lineno">11986</span>&#160;//gsoap *namespace-prefix* schema type: *type-name::field* //*text*</div><div class="line"><a name="l11987"></a><span class="lineno">11987</span>&#160;```</div><div class="line"><a name="l11988"></a><span class="lineno">11988</span>&#160;</div><div class="line"><a name="l11989"></a><span class="lineno">11989</span>&#160;where *type-name* is the unqualified name of the data type, *field* is a field, member, or enum name, and *text*</div><div class="line"><a name="l11990"></a><span class="lineno">11990</span>&#160;is a line of text terminated by a newline. Do not use any XML reserved</div><div class="line"><a name="l11991"></a><span class="lineno">11991</span>&#160;characters in *text* such as `&lt;` and `&gt;`. Use well-formed XML and XHTML markup instead.</div><div class="line"><a name="l11992"></a><span class="lineno">11992</span>&#160;For example:</div><div class="line"><a name="l11993"></a><span class="lineno">11993</span>&#160;</div><div class="line"><a name="l11994"></a><span class="lineno">11994</span>&#160;```cpp</div><div class="line"><a name="l11995"></a><span class="lineno">11995</span>&#160;//gsoap ns schema type: tdata::id the transaction number </div><div class="line"><a name="l11996"></a><span class="lineno">11996</span>&#160;//gsoap ns schema type: tdata::state transaction state  </div><div class="line"><a name="l11997"></a><span class="lineno">11997</span>&#160;//gsoap ns schema type: tstate::INIT initial state  </div><div class="line"><a name="l11998"></a><span class="lineno">11998</span>&#160;//gsoap ns schema type: tstate::DONE final state  </div><div class="line"><a name="l11999"></a><span class="lineno">11999</span>&#160;class ns__tdata </div><div class="line"><a name="l12000"></a><span class="lineno">12000</span>&#160;{</div><div class="line"><a name="l12001"></a><span class="lineno">12001</span>&#160;  @ int id; </div><div class="line"><a name="l12002"></a><span class="lineno">12002</span>&#160;  enum ns__tstate { INIT, DONE } state; </div><div class="line"><a name="l12003"></a><span class="lineno">12003</span>&#160;   ... </div><div class="line"><a name="l12004"></a><span class="lineno">12004</span>&#160;}</div><div class="line"><a name="l12005"></a><span class="lineno">12005</span>&#160;```</div><div class="line"><a name="l12006"></a><span class="lineno">12006</span>&#160;</div><div class="line"><a name="l12007"></a><span class="lineno">12007</span>&#160;The documentation form above can also be used to document SOAP/XML message</div><div class="line"><a name="l12008"></a><span class="lineno">12008</span>&#160;parts in the generated WSDL. For the type-name use the function name. For the field names, you can use the function name and/or the function argument names.</div><div class="line"><a name="l12009"></a><span class="lineno">12009</span>&#160;</div><div class="line"><a name="l12010"></a><span class="lineno">12010</span>&#160;To document a method, use:</div><div class="line"><a name="l12011"></a><span class="lineno">12011</span>&#160;</div><div class="line"><a name="l12012"></a><span class="lineno">12012</span>&#160;```cpp</div><div class="line"><a name="l12013"></a><span class="lineno">12013</span>&#160;//gsoap *namespace-prefix* service method-documentation: *method-name* *text*</div><div class="line"><a name="l12014"></a><span class="lineno">12014</span>&#160;```</div><div class="line"><a name="l12015"></a><span class="lineno">12015</span>&#160;</div><div class="line"><a name="l12016"></a><span class="lineno">12016</span>&#160;or shorthand:</div><div class="line"><a name="l12017"></a><span class="lineno">12017</span>&#160;</div><div class="line"><a name="l12018"></a><span class="lineno">12018</span>&#160;```cpp</div><div class="line"><a name="l12019"></a><span class="lineno">12019</span>&#160;//gsoap *namespace-prefix* service method: *method-name* *text*</div><div class="line"><a name="l12020"></a><span class="lineno">12020</span>&#160;```</div><div class="line"><a name="l12021"></a><span class="lineno">12021</span>&#160;</div><div class="line"><a name="l12022"></a><span class="lineno">12022</span>&#160;where *method-name* is the unqualified name of the method and *text*</div><div class="line"><a name="l12023"></a><span class="lineno">12023</span>&#160;is a line of text terminated by a newline. Do not use any XML reserved</div><div class="line"><a name="l12024"></a><span class="lineno">12024</span>&#160;characters in *text* such as &lt; and &gt;. Use well-formed XML and XHTML markup instead.</div><div class="line"><a name="l12025"></a><span class="lineno">12025</span>&#160;For example:</div><div class="line"><a name="l12026"></a><span class="lineno">12026</span>&#160;</div><div class="line"><a name="l12027"></a><span class="lineno">12027</span>&#160;```cpp</div><div class="line"><a name="l12028"></a><span class="lineno">12028</span>&#160;//gsoap ns service method: getQuote returns a &lt;i&gt;stock quote&lt;/i&gt; </div><div class="line"><a name="l12029"></a><span class="lineno">12029</span>&#160;int ns__getQuote(char *symbol, float &amp;_result);</div><div class="line"><a name="l12030"></a><span class="lineno">12030</span>&#160;```</div><div class="line"><a name="l12031"></a><span class="lineno">12031</span>&#160;</div><div class="line"><a name="l12032"></a><span class="lineno">12032</span>&#160;To specify the SOAP Action for a SOAP method, use:</div><div class="line"><a name="l12033"></a><span class="lineno">12033</span>&#160;</div><div class="line"><a name="l12034"></a><span class="lineno">12034</span>&#160;```cpp</div><div class="line"><a name="l12035"></a><span class="lineno">12035</span>&#160;//gsoap *namespace-prefix* service method-action: *method-name* *action*</div><div class="line"><a name="l12036"></a><span class="lineno">12036</span>&#160;```</div><div class="line"><a name="l12037"></a><span class="lineno">12037</span>&#160;</div><div class="line"><a name="l12038"></a><span class="lineno">12038</span>&#160;where *method-name* is the unqualified name of the method and *action*</div><div class="line"><a name="l12039"></a><span class="lineno">12039</span>&#160;is a string without spaces and blanks (the string can be quoted when preferred).</div><div class="line"><a name="l12040"></a><span class="lineno">12040</span>&#160;For example:</div><div class="line"><a name="l12041"></a><span class="lineno">12041</span>&#160;</div><div class="line"><a name="l12042"></a><span class="lineno">12042</span>&#160;```cpp</div><div class="line"><a name="l12043"></a><span class="lineno">12043</span>&#160;//gsoap ns service method-action: getQuote &quot;&quot; </div><div class="line"><a name="l12044"></a><span class="lineno">12044</span>&#160;int ns__getQuote(char *symbol, float &amp;_result);</div><div class="line"><a name="l12045"></a><span class="lineno">12045</span>&#160;```</div><div class="line"><a name="l12046"></a><span class="lineno">12046</span>&#160;</div><div class="line"><a name="l12047"></a><span class="lineno">12047</span>&#160;Or, alternatively for the input action (part of the request):</div><div class="line"><a name="l12048"></a><span class="lineno">12048</span>&#160;</div><div class="line"><a name="l12049"></a><span class="lineno">12049</span>&#160;```cpp</div><div class="line"><a name="l12050"></a><span class="lineno">12050</span>&#160;//gsoap ns service method-input-action: getQuote &quot;&quot; </div><div class="line"><a name="l12051"></a><span class="lineno">12051</span>&#160;int ns__getQuote(char *symbol, float &amp;_result);</div><div class="line"><a name="l12052"></a><span class="lineno">12052</span>&#160;```</div><div class="line"><a name="l12053"></a><span class="lineno">12053</span>&#160;</div><div class="line"><a name="l12054"></a><span class="lineno">12054</span>&#160;To specify the HTTP &quot;location&quot; of REST methods to a perform POST/GET/PUT action, use:</div><div class="line"><a name="l12055"></a><span class="lineno">12055</span>&#160;</div><div class="line"><a name="l12056"></a><span class="lineno">12056</span>&#160;```cpp</div><div class="line"><a name="l12057"></a><span class="lineno">12057</span>&#160;//gsoap *namespace-prefix* service method-action: *method-name* *action*</div><div class="line"><a name="l12058"></a><span class="lineno">12058</span>&#160;```</div><div class="line"><a name="l12059"></a><span class="lineno">12059</span>&#160;</div><div class="line"><a name="l12060"></a><span class="lineno">12060</span>&#160;where *method-name* is the unqualified name of the method and *action*</div><div class="line"><a name="l12061"></a><span class="lineno">12061</span>&#160;is a string without spaces and blanks (the string can be quoted when preferred).</div><div class="line"><a name="l12062"></a><span class="lineno">12062</span>&#160;This directive requires that the `protocol:` directive for this method is set to HTTP, POST, GET, or PUT.</div><div class="line"><a name="l12063"></a><span class="lineno">12063</span>&#160;</div><div class="line"><a name="l12064"></a><span class="lineno">12064</span>&#160;A response action and fault action are defined by:</div><div class="line"><a name="l12065"></a><span class="lineno">12065</span>&#160;</div><div class="line"><a name="l12066"></a><span class="lineno">12066</span>&#160;```cpp</div><div class="line"><a name="l12067"></a><span class="lineno">12067</span>&#160;//gsoap *namespace-prefix* service method-output-action: *method-name* *action*</div><div class="line"><a name="l12068"></a><span class="lineno">12068</span>&#160;//gsoap *namespace-prefix* service method-fault-action: *method-name* *action*</div><div class="line"><a name="l12069"></a><span class="lineno">12069</span>&#160;```</div><div class="line"><a name="l12070"></a><span class="lineno">12070</span>&#160;</div><div class="line"><a name="l12071"></a><span class="lineno">12071</span>&#160;To override the SOAP or REST protocol of an operation (SOAP by default), use:</div><div class="line"><a name="l12072"></a><span class="lineno">12072</span>&#160;</div><div class="line"><a name="l12073"></a><span class="lineno">12073</span>&#160;```cpp</div><div class="line"><a name="l12074"></a><span class="lineno">12074</span>&#160;//gsoap *namespace-prefix* service method-protocol: *method-name* *protocol*</div><div class="line"><a name="l12075"></a><span class="lineno">12075</span>&#160;```</div><div class="line"><a name="l12076"></a><span class="lineno">12076</span>&#160;</div><div class="line"><a name="l12077"></a><span class="lineno">12077</span>&#160;where *protocol* is one of</div><div class="line"><a name="l12078"></a><span class="lineno">12078</span>&#160;</div><div class="line"><a name="l12079"></a><span class="lineno">12079</span>&#160;*protocol*    | result</div><div class="line"><a name="l12080"></a><span class="lineno">12080</span>&#160;------------- | ------</div><div class="line"><a name="l12081"></a><span class="lineno">12081</span>&#160;`SOAP`        | default SOAP transport (supports 1.1 and 1.2) </div><div class="line"><a name="l12082"></a><span class="lineno">12082</span>&#160;`SOAP1.1`     | SOAP 1.1 only </div><div class="line"><a name="l12083"></a><span class="lineno">12083</span>&#160;`SOAP1.2`     | SOAP 1.2 only </div><div class="line"><a name="l12084"></a><span class="lineno">12084</span>&#160;`SOAP-GET`    | one-way SOAP with HTTP GET </div><div class="line"><a name="l12085"></a><span class="lineno">12085</span>&#160;`SOAP1.1-GET` | one-way SOAP 1.1 with HTTP GET </div><div class="line"><a name="l12086"></a><span class="lineno">12086</span>&#160;`SOAP1.2-GET` | one-way SOAP 1.2 with HTTP GET </div><div class="line"><a name="l12087"></a><span class="lineno">12087</span>&#160;`HTTP`        | REST HTTP (POST or one-way PUT) </div><div class="line"><a name="l12088"></a><span class="lineno">12088</span>&#160;`POST`        | REST HTTP POST </div><div class="line"><a name="l12089"></a><span class="lineno">12089</span>&#160;`GET`         | one-way REST HTTP GET </div><div class="line"><a name="l12090"></a><span class="lineno">12090</span>&#160;`PUT`         | one-way REST HTTP PUT </div><div class="line"><a name="l12091"></a><span class="lineno">12091</span>&#160;`DELETE`      | REST HTTP DELETE </div><div class="line"><a name="l12092"></a><span class="lineno">12092</span>&#160;</div><div class="line"><a name="l12093"></a><span class="lineno">12093</span>&#160;When document style is preferred for a particular service method, use:</div><div class="line"><a name="l12094"></a><span class="lineno">12094</span>&#160;</div><div class="line"><a name="l12095"></a><span class="lineno">12095</span>&#160;```cpp</div><div class="line"><a name="l12096"></a><span class="lineno">12096</span>&#160;//gsoap *namespace-prefix* service method-style: *method-name* document</div><div class="line"><a name="l12097"></a><span class="lineno">12097</span>&#160;```</div><div class="line"><a name="l12098"></a><span class="lineno">12098</span>&#160;</div><div class="line"><a name="l12099"></a><span class="lineno">12099</span>&#160;When SOAP RPC encoding is required for a particular service method, use:</div><div class="line"><a name="l12100"></a><span class="lineno">12100</span>&#160;</div><div class="line"><a name="l12101"></a><span class="lineno">12101</span>&#160;```cpp</div><div class="line"><a name="l12102"></a><span class="lineno">12102</span>&#160;//gsoap *namespace-prefix* service method-encoding: *method-name* encoded</div><div class="line"><a name="l12103"></a><span class="lineno">12103</span>&#160;```</div><div class="line"><a name="l12104"></a><span class="lineno">12104</span>&#160;</div><div class="line"><a name="l12105"></a><span class="lineno">12105</span>&#160;When literal encoding is required for a particular service method, use:</div><div class="line"><a name="l12106"></a><span class="lineno">12106</span>&#160;</div><div class="line"><a name="l12107"></a><span class="lineno">12107</span>&#160;```cpp</div><div class="line"><a name="l12108"></a><span class="lineno">12108</span>&#160;//gsoap *namespace-prefix* service method-encoding: *method-name* literal</div><div class="line"><a name="l12109"></a><span class="lineno">12109</span>&#160;```</div><div class="line"><a name="l12110"></a><span class="lineno">12110</span>&#160;</div><div class="line"><a name="l12111"></a><span class="lineno">12111</span>&#160;or when the *`SOAP-ENV:encodingStyle`* attribute is different from the SOAP 1.1/1.2 encoding style, use:</div><div class="line"><a name="l12112"></a><span class="lineno">12112</span>&#160;</div><div class="line"><a name="l12113"></a><span class="lineno">12113</span>&#160;```cpp</div><div class="line"><a name="l12114"></a><span class="lineno">12114</span>&#160;//gsoap *namespace-prefix* service method-encoding: *method-name* *encoding-style*</div><div class="line"><a name="l12115"></a><span class="lineno">12115</span>&#160;```</div><div class="line"><a name="l12116"></a><span class="lineno">12116</span>&#160;</div><div class="line"><a name="l12117"></a><span class="lineno">12117</span>&#160;When SOAP RPC encoding is required for a particular service method response when the request message is literal, use:</div><div class="line"><a name="l12118"></a><span class="lineno">12118</span>&#160;</div><div class="line"><a name="l12119"></a><span class="lineno">12119</span>&#160;```cpp</div><div class="line"><a name="l12120"></a><span class="lineno">12120</span>&#160;//gsoap *namespace-prefix* service method-response-encoding: *method-name* encoded</div><div class="line"><a name="l12121"></a><span class="lineno">12121</span>&#160;```</div><div class="line"><a name="l12122"></a><span class="lineno">12122</span>&#160;</div><div class="line"><a name="l12123"></a><span class="lineno">12123</span>&#160;When literal encoding is required for a particular service method response when the request message is encoded, use:</div><div class="line"><a name="l12124"></a><span class="lineno">12124</span>&#160;</div><div class="line"><a name="l12125"></a><span class="lineno">12125</span>&#160;```cpp</div><div class="line"><a name="l12126"></a><span class="lineno">12126</span>&#160;//gsoap *namespace-prefix* service method-response-encoding: *method-name* literal</div><div class="line"><a name="l12127"></a><span class="lineno">12127</span>&#160;```</div><div class="line"><a name="l12128"></a><span class="lineno">12128</span>&#160;</div><div class="line"><a name="l12129"></a><span class="lineno">12129</span>&#160;or when the *`SOAP-ENV:encodingStyle`* attribute is different from the SOAP 1.1/1.2 encoding style, use:</div><div class="line"><a name="l12130"></a><span class="lineno">12130</span>&#160;</div><div class="line"><a name="l12131"></a><span class="lineno">12131</span>&#160;```cpp</div><div class="line"><a name="l12132"></a><span class="lineno">12132</span>&#160;//gsoap *namespace-prefix* service method-response-encoding: *method-name* *encoding-style*</div><div class="line"><a name="l12133"></a><span class="lineno">12133</span>&#160;```</div><div class="line"><a name="l12134"></a><span class="lineno">12134</span>&#160;</div><div class="line"><a name="l12135"></a><span class="lineno">12135</span>&#160;Note that the `method-response-encoding` is set to the value of `method-encoding` by default.</div><div class="line"><a name="l12136"></a><span class="lineno">12136</span>&#160;</div><div class="line"><a name="l12137"></a><span class="lineno">12137</span>&#160;When header processing is required, each method declared in the WSDL should provide a binding to the parts of the header that may</div><div class="line"><a name="l12138"></a><span class="lineno">12138</span>&#160;appear as part of a method request message. Such a binding is given by:</div><div class="line"><a name="l12139"></a><span class="lineno">12139</span>&#160;</div><div class="line"><a name="l12140"></a><span class="lineno">12140</span>&#160;```cpp</div><div class="line"><a name="l12141"></a><span class="lineno">12141</span>&#160;//gsoap *namespace-prefix* service method-header-part: *method-name* *header-part*</div><div class="line"><a name="l12142"></a><span class="lineno">12142</span>&#160;```</div><div class="line"><a name="l12143"></a><span class="lineno">12143</span>&#160;</div><div class="line"><a name="l12144"></a><span class="lineno">12144</span>&#160;For example:</div><div class="line"><a name="l12145"></a><span class="lineno">12145</span>&#160;</div><div class="line"><a name="l12146"></a><span class="lineno">12146</span>&#160;```cpp</div><div class="line"><a name="l12147"></a><span class="lineno">12147</span>&#160;struct SOAP_ENV__Header </div><div class="line"><a name="l12148"></a><span class="lineno">12148</span>&#160;{ </div><div class="line"><a name="l12149"></a><span class="lineno">12149</span>&#160;   char *h__transaction; </div><div class="line"><a name="l12150"></a><span class="lineno">12150</span>&#160;   struct UserAuth *h__authentication; </div><div class="line"><a name="l12151"></a><span class="lineno">12151</span>&#160;};</div><div class="line"><a name="l12152"></a><span class="lineno">12152</span>&#160;```</div><div class="line"><a name="l12153"></a><span class="lineno">12153</span>&#160;</div><div class="line"><a name="l12154"></a><span class="lineno">12154</span>&#160;Suppose method `ns__login` uses both header parts (at most), then this is declared as:</div><div class="line"><a name="l12155"></a><span class="lineno">12155</span>&#160;</div><div class="line"><a name="l12156"></a><span class="lineno">12156</span>&#160;```cpp</div><div class="line"><a name="l12157"></a><span class="lineno">12157</span>&#160;//gsoap ns service method-header-part: login h__transaction </div><div class="line"><a name="l12158"></a><span class="lineno">12158</span>&#160;//gsoap ns service method-header-part: login h__authentication </div><div class="line"><a name="l12159"></a><span class="lineno">12159</span>&#160;int ns__login(...);</div><div class="line"><a name="l12160"></a><span class="lineno">12160</span>&#160;```</div><div class="line"><a name="l12161"></a><span class="lineno">12161</span>&#160;</div><div class="line"><a name="l12162"></a><span class="lineno">12162</span>&#160;Suppose method `ns__search` uses only the first header part, then this is declared as:</div><div class="line"><a name="l12163"></a><span class="lineno">12163</span>&#160;</div><div class="line"><a name="l12164"></a><span class="lineno">12164</span>&#160;```cpp</div><div class="line"><a name="l12165"></a><span class="lineno">12165</span>&#160;//gsoap ns service method-header-part: search h__transaction </div><div class="line"><a name="l12166"></a><span class="lineno">12166</span>&#160;int ns__search(...);</div><div class="line"><a name="l12167"></a><span class="lineno">12167</span>&#160;```</div><div class="line"><a name="l12168"></a><span class="lineno">12168</span>&#160;</div><div class="line"><a name="l12169"></a><span class="lineno">12169</span>&#160;Note that the method name and header part names MUST be namespace qualified.</div><div class="line"><a name="l12170"></a><span class="lineno">12170</span>&#160;The headers MUST be present in all operations that declared the header parts.</div><div class="line"><a name="l12171"></a><span class="lineno">12171</span>&#160;</div><div class="line"><a name="l12172"></a><span class="lineno">12172</span>&#160;To specify the header parts for the method input (method request message), use:</div><div class="line"><a name="l12173"></a><span class="lineno">12173</span>&#160;</div><div class="line"><a name="l12174"></a><span class="lineno">12174</span>&#160;```cpp</div><div class="line"><a name="l12175"></a><span class="lineno">12175</span>&#160;//gsoap *namespace-prefix* service method-input-header-part: *method-name* *header-part*</div><div class="line"><a name="l12176"></a><span class="lineno">12176</span>&#160;```</div><div class="line"><a name="l12177"></a><span class="lineno">12177</span>&#160;</div><div class="line"><a name="l12178"></a><span class="lineno">12178</span>&#160;Similarly, to specify the header parts for the method output (method response message), use:</div><div class="line"><a name="l12179"></a><span class="lineno">12179</span>&#160;</div><div class="line"><a name="l12180"></a><span class="lineno">12180</span>&#160;```cpp</div><div class="line"><a name="l12181"></a><span class="lineno">12181</span>&#160;//gsoap *namespace-prefix* service method-output-header-part: *method-name* *header-part*</div><div class="line"><a name="l12182"></a><span class="lineno">12182</span>&#160;```</div><div class="line"><a name="l12183"></a><span class="lineno">12183</span>&#160;</div><div class="line"><a name="l12184"></a><span class="lineno">12184</span>&#160;The declarations only affect the WSDL.</div><div class="line"><a name="l12185"></a><span class="lineno">12185</span>&#160;For example:</div><div class="line"><a name="l12186"></a><span class="lineno">12186</span>&#160;</div><div class="line"><a name="l12187"></a><span class="lineno">12187</span>&#160;```cpp</div><div class="line"><a name="l12188"></a><span class="lineno">12188</span>&#160;struct SOAP_ENV__Header </div><div class="line"><a name="l12189"></a><span class="lineno">12189</span>&#160;{ </div><div class="line"><a name="l12190"></a><span class="lineno">12190</span>&#160;   char *h__transaction; </div><div class="line"><a name="l12191"></a><span class="lineno">12191</span>&#160;   struct UserAuth *h__authentication; </div><div class="line"><a name="l12192"></a><span class="lineno">12192</span>&#160;}; </div><div class="line"><a name="l12193"></a><span class="lineno">12193</span>&#160;//gsoap ns service method-input-header-part: login h__authentication </div><div class="line"><a name="l12194"></a><span class="lineno">12194</span>&#160;//gsoap ns service method-input-header-part: login h__transaction </div><div class="line"><a name="l12195"></a><span class="lineno">12195</span>&#160;//gsoap ns service method-output-header-part: login h__transaction </div><div class="line"><a name="l12196"></a><span class="lineno">12196</span>&#160;int ns__login(...);</div><div class="line"><a name="l12197"></a><span class="lineno">12197</span>&#160;```</div><div class="line"><a name="l12198"></a><span class="lineno">12198</span>&#160;</div><div class="line"><a name="l12199"></a><span class="lineno">12199</span>&#160;The headers MUST be present in all operations that declared the header parts.</div><div class="line"><a name="l12200"></a><span class="lineno">12200</span>&#160;</div><div class="line"><a name="l12201"></a><span class="lineno">12201</span>&#160;When SOAP Faults include custom fault information, the SOAP Fault detail element contains one or more elements with this information.  Assuming that the SOAP Fault detail structure contains one or more members that correspond to the optional detail elements, a method may be associated with one or more of these members by using:</div><div class="line"><a name="l12202"></a><span class="lineno">12202</span>&#160;</div><div class="line"><a name="l12203"></a><span class="lineno">12203</span>&#160;```cpp</div><div class="line"><a name="l12204"></a><span class="lineno">12204</span>&#160;//gsoap *namespace-prefix* service method-fault: *method-name* *fault-detail*</div><div class="line"><a name="l12205"></a><span class="lineno">12205</span>&#160;```</div><div class="line"><a name="l12206"></a><span class="lineno">12206</span>&#160;</div><div class="line"><a name="l12207"></a><span class="lineno">12207</span>&#160;The declarations only affect the WSDL.</div><div class="line"><a name="l12208"></a><span class="lineno">12208</span>&#160;For example:</div><div class="line"><a name="l12209"></a><span class="lineno">12209</span>&#160;</div><div class="line"><a name="l12210"></a><span class="lineno">12210</span>&#160;```cpp</div><div class="line"><a name="l12211"></a><span class="lineno">12211</span>&#160;struct SOAP_ENV__Header </div><div class="line"><a name="l12212"></a><span class="lineno">12212</span>&#160;{ </div><div class="line"><a name="l12213"></a><span class="lineno">12213</span>&#160;   char *h__transaction; </div><div class="line"><a name="l12214"></a><span class="lineno">12214</span>&#160;   struct UserAuth *h__authentication; </div><div class="line"><a name="l12215"></a><span class="lineno">12215</span>&#160;}; </div><div class="line"><a name="l12216"></a><span class="lineno">12216</span>&#160;//gsoap ns service method-fault: login f__invalid </div><div class="line"><a name="l12217"></a><span class="lineno">12217</span>&#160;//gsoap ns service method-fault: login f__unavailable </div><div class="line"><a name="l12218"></a><span class="lineno">12218</span>&#160;int ns__login(...);</div><div class="line"><a name="l12219"></a><span class="lineno">12219</span>&#160;```</div><div class="line"><a name="l12220"></a><span class="lineno">12220</span>&#160;</div><div class="line"><a name="l12221"></a><span class="lineno">12221</span>&#160;The fault members MUST be present in the `SOAP_ENV__Detail` structure, for example, `f__invalid` must be a pointer-based member of the `SOAP_ENV__Detail` struct, see Section \ref fault .  Alternatively to adding members to the structure, use the `__type` field that can be set to point to an object that is serialized as the SOAP Fault detail element.</div><div class="line"><a name="l12222"></a><span class="lineno">12222</span>&#160;</div><div class="line"><a name="l12223"></a><span class="lineno">12223</span>&#160;To specify MIME attachments for the method input and output (method request and response messages), use:</div><div class="line"><a name="l12224"></a><span class="lineno">12224</span>&#160;</div><div class="line"><a name="l12225"></a><span class="lineno">12225</span>&#160;```cpp</div><div class="line"><a name="l12226"></a><span class="lineno">12226</span>&#160;//gsoap *namespace-prefix* service method-mime-type: *method-name* *mime-type*</div><div class="line"><a name="l12227"></a><span class="lineno">12227</span>&#160;```</div><div class="line"><a name="l12228"></a><span class="lineno">12228</span>&#160;</div><div class="line"><a name="l12229"></a><span class="lineno">12229</span>&#160;You can repeat this directive for all multipartRelated MIME attachments you want to associate with the method.</div><div class="line"><a name="l12230"></a><span class="lineno">12230</span>&#160;</div><div class="line"><a name="l12231"></a><span class="lineno">12231</span>&#160;To specify MIME attachments for the method input (method request message), use:</div><div class="line"><a name="l12232"></a><span class="lineno">12232</span>&#160;</div><div class="line"><a name="l12233"></a><span class="lineno">12233</span>&#160;```cpp</div><div class="line"><a name="l12234"></a><span class="lineno">12234</span>&#160;//gsoap *namespace-prefix* service method-input-mime-type: *method-name* *mime-type*</div><div class="line"><a name="l12235"></a><span class="lineno">12235</span>&#160;```</div><div class="line"><a name="l12236"></a><span class="lineno">12236</span>&#160;</div><div class="line"><a name="l12237"></a><span class="lineno">12237</span>&#160;Similarly, to specify MIME attachments for the method output (method response message), use:</div><div class="line"><a name="l12238"></a><span class="lineno">12238</span>&#160;</div><div class="line"><a name="l12239"></a><span class="lineno">12239</span>&#160;```cpp</div><div class="line"><a name="l12240"></a><span class="lineno">12240</span>&#160;//gsoap *namespace-prefix* service method-output-mime-type: *method-name* *mime-type*</div><div class="line"><a name="l12241"></a><span class="lineno">12241</span>&#160;```</div><div class="line"><a name="l12242"></a><span class="lineno">12242</span>&#160;</div><div class="line"><a name="l12243"></a><span class="lineno">12243</span>&#160;You can repeat these directives for all multipartRelated MIME attachments you want to associate with the method.</div><div class="line"><a name="l12244"></a><span class="lineno">12244</span>&#160;</div><div class="line"><a name="l12245"></a><span class="lineno">12245</span>&#160;### Example</div><div class="line"><a name="l12246"></a><span class="lineno">12246</span>&#160;</div><div class="line"><a name="l12247"></a><span class="lineno">12247</span>&#160;The use of directives is best illustrated with an example. The example uses a</div><div class="line"><a name="l12248"></a><span class="lineno">12248</span>&#160;hypothetical stock quote service and exchange rate service, actual services </div><div class="line"><a name="l12249"></a><span class="lineno">12249</span>&#160;such as these are available for free on the web.</div><div class="line"><a name="l12250"></a><span class="lineno">12250</span>&#160;</div><div class="line"><a name="l12251"></a><span class="lineno">12251</span>&#160;```cpp</div><div class="line"><a name="l12252"></a><span class="lineno">12252</span>&#160;//gsoap ns1 service namespace:  urn:GetQuote </div><div class="line"><a name="l12253"></a><span class="lineno">12253</span>&#160;int ns1__getQuote(char *symbol, float &amp;result); </div><div class="line"><a name="l12254"></a><span class="lineno">12254</span>&#160; </div><div class="line"><a name="l12255"></a><span class="lineno">12255</span>&#160;//gsoap ns2 service namespace:  urn:CurrencyExchange </div><div class="line"><a name="l12256"></a><span class="lineno">12256</span>&#160;int ns2__getRate(char *country1, char *country2, float &amp;result); </div><div class="line"><a name="l12257"></a><span class="lineno">12257</span>&#160; </div><div class="line"><a name="l12258"></a><span class="lineno">12258</span>&#160;//gsoap ns3 service name:       quotex </div><div class="line"><a name="l12259"></a><span class="lineno">12259</span>&#160;//gsoap ns3 service style:      rpc </div><div class="line"><a name="l12260"></a><span class="lineno">12260</span>&#160;//gsoap ns3 service encoding:   encoded </div><div class="line"><a name="l12261"></a><span class="lineno">12261</span>&#160;//gsoap ns3 service port:       http://www.mydomain.com/quotex.cgi </div><div class="line"><a name="l12262"></a><span class="lineno">12262</span>&#160;//gsoap ns3 service namespace:  urn:quotex </div><div class="line"><a name="l12263"></a><span class="lineno">12263</span>&#160;int ns3__getQuote(char *symbol, char *country, float &amp;result);</div><div class="line"><a name="l12264"></a><span class="lineno">12264</span>&#160;```</div><div class="line"><a name="l12265"></a><span class="lineno">12265</span>&#160;</div><div class="line"><a name="l12266"></a><span class="lineno">12266</span>&#160;The `quotex.h` example is a new Web Service created by combining two existing Web Services:</div><div class="line"><a name="l12267"></a><span class="lineno">12267</span>&#160;a Stock Quote service and a Currency Exchange service.</div><div class="line"><a name="l12268"></a><span class="lineno">12268</span>&#160;</div><div class="line"><a name="l12269"></a><span class="lineno">12269</span>&#160;Namespace prefix `ns3` is used for the new `quotex` Web Service with namespace URI `urn:quotex`,</div><div class="line"><a name="l12270"></a><span class="lineno">12270</span>&#160;service name `quotex`, and endpoint port `http://www.mydomain.com/quotex.cgi`.</div><div class="line"><a name="l12271"></a><span class="lineno">12271</span>&#160;</div><div class="line"><a name="l12272"></a><span class="lineno">12272</span>&#160;Since the new Web Service invokes the `ns1__getQuote` and `ns2__getRate` service operations,</div><div class="line"><a name="l12273"></a><span class="lineno">12273</span>&#160;the service namespaces and other details such as style and encoding of these methods are given by directives.</div><div class="line"><a name="l12274"></a><span class="lineno">12274</span>&#160;After invoking the gSOAP `soapcpp2` tool on the `quotex.h` header file:</div><div class="line"><a name="l12275"></a><span class="lineno">12275</span>&#160;</div><div class="line"><a name="l12276"></a><span class="lineno">12276</span>&#160;    &gt; soapcpp2 quotex.h</div><div class="line"><a name="l12277"></a><span class="lineno">12277</span>&#160;</div><div class="line"><a name="l12278"></a><span class="lineno">12278</span>&#160;the WSDL of the new `quotex` Web Service is saved as `quotex.wsdl`.</div><div class="line"><a name="l12279"></a><span class="lineno">12279</span>&#160;Since the service name, endpoint port, and namespace URI</div><div class="line"><a name="l12280"></a><span class="lineno">12280</span>&#160;were provided in the header file, the generated WSDL file can be published</div><div class="line"><a name="l12281"></a><span class="lineno">12281</span>&#160;together with the compiled Web Service installed as a CGI application.</div><div class="line"><a name="l12282"></a><span class="lineno">12282</span>&#160;</div><div class="line"><a name="l12283"></a><span class="lineno">12283</span>&#160;The namespace mapping table for the `quotex.cpp` Web Service implementation</div><div class="line"><a name="l12284"></a><span class="lineno">12284</span>&#160;is saved as `quotex.nsmap`.  This file can be directly included in</div><div class="line"><a name="l12285"></a><span class="lineno">12285</span>&#160;`quotex.cpp` instead of specified by hand in the source of</div><div class="line"><a name="l12286"></a><span class="lineno">12286</span>&#160;`quotex.cpp`:</div><div class="line"><a name="l12287"></a><span class="lineno">12287</span>&#160;</div><div class="line"><a name="l12288"></a><span class="lineno">12288</span>&#160;```cpp</div><div class="line"><a name="l12289"></a><span class="lineno">12289</span>&#160;#include &quot;quotex.nsmap&quot;</div><div class="line"><a name="l12290"></a><span class="lineno">12290</span>&#160;```</div><div class="line"><a name="l12291"></a><span class="lineno">12291</span>&#160;</div><div class="line"><a name="l12292"></a><span class="lineno">12292</span>&#160;The automatic generation and inclusion of the namespace mapping table requires</div><div class="line"><a name="l12293"></a><span class="lineno">12293</span>&#160;compiler directives for **all** namespace prefixes to associate each</div><div class="line"><a name="l12294"></a><span class="lineno">12294</span>&#160;namespace prefix with a namespace URI. Otherwise, namespace URIs have to be</div><div class="line"><a name="l12295"></a><span class="lineno">12295</span>&#160;manually added to the table (they appear as `http://tempuri.org`).</div><div class="line"><a name="l12296"></a><span class="lineno">12296</span>&#160;</div><div class="line"><a name="l12297"></a><span class="lineno">12297</span>&#160;## Transient Data Types        {#transient}</div><div class="line"><a name="l12298"></a><span class="lineno">12298</span>&#160;</div><div class="line"><a name="l12299"></a><span class="lineno">12299</span>&#160;There are situations when certain data types have to be ignored by gSOAP for</div><div class="line"><a name="l12300"></a><span class="lineno">12300</span>&#160;the compilation of (de)marshalling routines.  For example, in certain cases</div><div class="line"><a name="l12301"></a><span class="lineno">12301</span>&#160;only a few members of a class or struct need not be (de)serialized, or the base</div><div class="line"><a name="l12302"></a><span class="lineno">12302</span>&#160;class of a derived class should not be (de)serialized. Certain built-in classes</div><div class="line"><a name="l12303"></a><span class="lineno">12303</span>&#160;such as `ostream` cannot be (de)serialized.  Data parts that should be kept</div><div class="line"><a name="l12304"></a><span class="lineno">12304</span>&#160;invisible to gSOAP are called &quot;transient&quot;.  Transient data types and</div><div class="line"><a name="l12305"></a><span class="lineno">12305</span>&#160;transient struct/class members are declared with the `\extern` keyword or</div><div class="line"><a name="l12306"></a><span class="lineno">12306</span>&#160;are declared within `[` and `]` blocks in the header file.  The</div><div class="line"><a name="l12307"></a><span class="lineno">12307</span>&#160;`\extern` keyword has a special meaning to the gSOAP `soapcpp2` compiler and won&#39;t</div><div class="line"><a name="l12308"></a><span class="lineno">12308</span>&#160;affect the generated codes.  The special `[` and `]` block construct</div><div class="line"><a name="l12309"></a><span class="lineno">12309</span>&#160;can be used with data type declarations and within `struct` and</div><div class="line"><a name="l12310"></a><span class="lineno">12310</span>&#160;`class` declarations. The use of `\extern` or `[ ]` achieve the</div><div class="line"><a name="l12311"></a><span class="lineno">12311</span>&#160;same effect, but `[ ]` may be more convenient to encapsulate transient</div><div class="line"><a name="l12312"></a><span class="lineno">12312</span>&#160;types in a larger part of the header file. The use of `\extern` with</div><div class="line"><a name="l12313"></a><span class="lineno">12313</span>&#160;`typedef` is reserved for the declaration of user-defined external</div><div class="line"><a name="l12314"></a><span class="lineno">12314</span>&#160;(de)serializers for data types, see Section \ref extern .</div><div class="line"><a name="l12315"></a><span class="lineno">12315</span>&#160;</div><div class="line"><a name="l12316"></a><span class="lineno">12316</span>&#160;First example:</div><div class="line"><a name="l12317"></a><span class="lineno">12317</span>&#160;</div><div class="line"><a name="l12318"></a><span class="lineno">12318</span>&#160;```cpp</div><div class="line"><a name="l12319"></a><span class="lineno">12319</span>&#160;extern class ostream; // ostream can&#39;t be (de)serialized, but need to be declared to make it visible to gSOAP </div><div class="line"><a name="l12320"></a><span class="lineno">12320</span>&#160;class ns__myClass </div><div class="line"><a name="l12321"></a><span class="lineno">12321</span>&#160;{ ... </div><div class="line"><a name="l12322"></a><span class="lineno">12322</span>&#160;   virtual void print(ostream &amp;s) const; // need ostream here </div><div class="line"><a name="l12323"></a><span class="lineno">12323</span>&#160;   ... </div><div class="line"><a name="l12324"></a><span class="lineno">12324</span>&#160;};</div><div class="line"><a name="l12325"></a><span class="lineno">12325</span>&#160;```</div><div class="line"><a name="l12326"></a><span class="lineno">12326</span>&#160;</div><div class="line"><a name="l12327"></a><span class="lineno">12327</span>&#160;Second example:</div><div class="line"><a name="l12328"></a><span class="lineno">12328</span>&#160;</div><div class="line"><a name="l12329"></a><span class="lineno">12329</span>&#160;```cpp</div><div class="line"><a name="l12330"></a><span class="lineno">12330</span>&#160;[ </div><div class="line"><a name="l12331"></a><span class="lineno">12331</span>&#160;   class myBase // base class need not be (de)serialized </div><div class="line"><a name="l12332"></a><span class="lineno">12332</span>&#160;   { ... }; </div><div class="line"><a name="l12333"></a><span class="lineno">12333</span>&#160;] </div><div class="line"><a name="l12334"></a><span class="lineno">12334</span>&#160;class ns__myDerived : myBase </div><div class="line"><a name="l12335"></a><span class="lineno">12335</span>&#160;{ ... }; </div><div class="line"><a name="l12336"></a><span class="lineno">12336</span>&#160;```</div><div class="line"><a name="l12337"></a><span class="lineno">12337</span>&#160;</div><div class="line"><a name="l12338"></a><span class="lineno">12338</span>&#160;Third example:</div><div class="line"><a name="l12339"></a><span class="lineno">12339</span>&#160;</div><div class="line"><a name="l12340"></a><span class="lineno">12340</span>&#160;```cpp</div><div class="line"><a name="l12341"></a><span class="lineno">12341</span>&#160;[ typedef int transientInt; ] </div><div class="line"><a name="l12342"></a><span class="lineno">12342</span>&#160;class ns__myClass </div><div class="line"><a name="l12343"></a><span class="lineno">12343</span>&#160;{ </div><div class="line"><a name="l12344"></a><span class="lineno">12344</span>&#160;   int a; // will be (de)serialized </div><div class="line"><a name="l12345"></a><span class="lineno">12345</span>&#160;   [ </div><div class="line"><a name="l12346"></a><span class="lineno">12346</span>&#160;   int b; // transient field </div><div class="line"><a name="l12347"></a><span class="lineno">12347</span>&#160;   char s[256]; // transient field </div><div class="line"><a name="l12348"></a><span class="lineno">12348</span>&#160;   ]  </div><div class="line"><a name="l12349"></a><span class="lineno">12349</span>&#160;   extern float d; // transient field </div><div class="line"><a name="l12350"></a><span class="lineno">12350</span>&#160;   char *t; // will be (de)serialized </div><div class="line"><a name="l12351"></a><span class="lineno">12351</span>&#160;   transientInt *n; // transient field </div><div class="line"><a name="l12352"></a><span class="lineno">12352</span>&#160;   [ </div><div class="line"><a name="l12353"></a><span class="lineno">12353</span>&#160;   virtual void method(char buf[1024]); // does not create a char[1024] (de)serializer </div><div class="line"><a name="l12354"></a><span class="lineno">12354</span>&#160;   ]  </div><div class="line"><a name="l12355"></a><span class="lineno">12355</span>&#160;};</div><div class="line"><a name="l12356"></a><span class="lineno">12356</span>&#160;```</div><div class="line"><a name="l12357"></a><span class="lineno">12357</span>&#160;</div><div class="line"><a name="l12358"></a><span class="lineno">12358</span>&#160;In this example, `class ns__myClass` has three transient fields:</div><div class="line"><a name="l12359"></a><span class="lineno">12359</span>&#160;`b`, `s`, and `n` which will not be (de)serialized in SOAP. Field</div><div class="line"><a name="l12360"></a><span class="lineno">12360</span>&#160;`n` is transient because the type is declared within a transient block.</div><div class="line"><a name="l12361"></a><span class="lineno">12361</span>&#160;Pointers, references, and arrays of transient types are transient.  The single</div><div class="line"><a name="l12362"></a><span class="lineno">12362</span>&#160;class method is encapsulated within `[` and `]` to prevent gSOAP from</div><div class="line"><a name="l12363"></a><span class="lineno">12363</span>&#160;creating (de)serializers for the `char[1024]` type. gSOAP will generate</div><div class="line"><a name="l12364"></a><span class="lineno">12364</span>&#160;(de)serializers for all types that are not declared within a `[` and</div><div class="line"><a name="l12365"></a><span class="lineno">12365</span>&#160;`]` transient block.</div><div class="line"><a name="l12366"></a><span class="lineno">12366</span>&#160;</div><div class="line"><a name="l12367"></a><span class="lineno">12367</span>&#160;## Serialization &quot;{as is&quot; with Volatile Data Types}        {#volatile}</div><div class="line"><a name="l12368"></a><span class="lineno">12368</span>&#160;</div><div class="line"><a name="l12369"></a><span class="lineno">12369</span>&#160;Volatile-declared data types in gSOAP are assumed to be part of an</div><div class="line"><a name="l12370"></a><span class="lineno">12370</span>&#160;existing non-modifiable software package, such as a built-in library. It would</div><div class="line"><a name="l12371"></a><span class="lineno">12371</span>&#160;not make sense to redefine the data types in a gSOAP header file. In certain</div><div class="line"><a name="l12372"></a><span class="lineno">12372</span>&#160;cases it could also be problematic to have classes augmented with serializer</div><div class="line"><a name="l12373"></a><span class="lineno">12373</span>&#160;methods. When you need to (de)serialize such data types &quot;as is&quot;, you must</div><div class="line"><a name="l12374"></a><span class="lineno">12374</span>&#160;declare them in a gSOAP header file and use the `volatile` qualifier.</div><div class="line"><a name="l12375"></a><span class="lineno">12375</span>&#160;</div><div class="line"><a name="l12376"></a><span class="lineno">12376</span>&#160;Consider for example `struct tm`, declared in `time.h`. The structure may actually vary between platforms, but the tm structure includes at least the following fields:</div><div class="line"><a name="l12377"></a><span class="lineno">12377</span>&#160;</div><div class="line"><a name="l12378"></a><span class="lineno">12378</span>&#160;```cpp</div><div class="line"><a name="l12379"></a><span class="lineno">12379</span>&#160;volatile struct tm </div><div class="line"><a name="l12380"></a><span class="lineno">12380</span>&#160;{ </div><div class="line"><a name="l12381"></a><span class="lineno">12381</span>&#160;   int tm_sec;         /* seconds (0 - 60) */ </div><div class="line"><a name="l12382"></a><span class="lineno">12382</span>&#160;   int tm_min;         /* minutes (0 - 59) */ </div><div class="line"><a name="l12383"></a><span class="lineno">12383</span>&#160;   int tm_hour;        /* hours (0 - 23) */ </div><div class="line"><a name="l12384"></a><span class="lineno">12384</span>&#160;   int tm_mday;        /* day of month (1 - 31) */ </div><div class="line"><a name="l12385"></a><span class="lineno">12385</span>&#160;   int tm_mon;         /* month of year (0 - 11) */ </div><div class="line"><a name="l12386"></a><span class="lineno">12386</span>&#160;   int tm_year;        /* year - 1900 */ </div><div class="line"><a name="l12387"></a><span class="lineno">12387</span>&#160;   int tm_wday;        /* day of week (Sunday = 0) */ </div><div class="line"><a name="l12388"></a><span class="lineno">12388</span>&#160;   int tm_yday;        /* day of year (0 - 365) */ </div><div class="line"><a name="l12389"></a><span class="lineno">12389</span>&#160;   int tm_isdst;       /* is summer time in effect? */ </div><div class="line"><a name="l12390"></a><span class="lineno">12390</span>&#160;   char *tm_zone;        /* abbreviation of timezone name */ </div><div class="line"><a name="l12391"></a><span class="lineno">12391</span>&#160;   long tm_gmtoff;      /* offset from UTC in seconds */ </div><div class="line"><a name="l12392"></a><span class="lineno">12392</span>&#160;};</div><div class="line"><a name="l12393"></a><span class="lineno">12393</span>&#160;```</div><div class="line"><a name="l12394"></a><span class="lineno">12394</span>&#160;</div><div class="line"><a name="l12395"></a><span class="lineno">12395</span>&#160;Note that we qualified the structure `volatile` in the gSOAP header file to inform the gSOAP `soapcpp2` compiler that it should not attempt to redeclare it.</div><div class="line"><a name="l12396"></a><span class="lineno">12396</span>&#160;We can now readily serialize and deserialize the tm structure. The following program fragment serializes the local time stored in a tm structure to stdout:</div><div class="line"><a name="l12397"></a><span class="lineno">12397</span>&#160;</div><div class="line"><a name="l12398"></a><span class="lineno">12398</span>&#160;```cpp</div><div class="line"><a name="l12399"></a><span class="lineno">12399</span>&#160;struct soap *soap = soap_new(); </div><div class="line"><a name="l12400"></a><span class="lineno">12400</span>&#160;... </div><div class="line"><a name="l12401"></a><span class="lineno">12401</span>&#160;time_t T = time(NULL); </div><div class="line"><a name="l12402"></a><span class="lineno">12402</span>&#160;struct tm *t = localtime(&amp;T); </div><div class="line"><a name="l12403"></a><span class="lineno">12403</span>&#160;struct soap *soap = soap_new(); </div><div class="line"><a name="l12404"></a><span class="lineno">12404</span>&#160;soap_write_tm(soap, t); </div><div class="line"><a name="l12405"></a><span class="lineno">12405</span>&#160;soap_destroy(soap); </div><div class="line"><a name="l12406"></a><span class="lineno">12406</span>&#160;soap_end(soap); </div><div class="line"><a name="l12407"></a><span class="lineno">12407</span>&#160;soap_free(soap); // detach and free context </div><div class="line"><a name="l12408"></a><span class="lineno">12408</span>&#160;```</div><div class="line"><a name="l12409"></a><span class="lineno">12409</span>&#160;</div><div class="line"><a name="l12410"></a><span class="lineno">12410</span>&#160;It is also possible to serialize the tm fields as XML attributes using the</div><div class="line"><a name="l12411"></a><span class="lineno">12411</span>&#160;`@` qualifier, see Section \ref attributes .</div><div class="line"><a name="l12412"></a><span class="lineno">12412</span>&#160;</div><div class="line"><a name="l12413"></a><span class="lineno">12413</span>&#160;If you must produce a schema file, say `time.xsd`, that defines an XML</div><div class="line"><a name="l12414"></a><span class="lineno">12414</span>&#160;schema and namespace for the tm struct, you can add a `typedef`</div><div class="line"><a name="l12415"></a><span class="lineno">12415</span>&#160;declaration to the header file:</div><div class="line"><a name="l12416"></a><span class="lineno">12416</span>&#160;</div><div class="line"><a name="l12417"></a><span class="lineno">12417</span>&#160;```cpp</div><div class="line"><a name="l12418"></a><span class="lineno">12418</span>&#160;typedef struct tm time__struct_tm;</div><div class="line"><a name="l12419"></a><span class="lineno">12419</span>&#160;```</div><div class="line"><a name="l12420"></a><span class="lineno">12420</span>&#160;</div><div class="line"><a name="l12421"></a><span class="lineno">12421</span>&#160;We used the `typedef` name `time__struct_tm` rather than `time__tm`, because a schema name clash will occur with the latter since taking off</div><div class="line"><a name="l12422"></a><span class="lineno">12422</span>&#160;the `time` prefix will result in the same name being used.</div><div class="line"><a name="l12423"></a><span class="lineno">12423</span>&#160;</div><div class="line"><a name="l12424"></a><span class="lineno">12424</span>&#160;Classes should be declared volatile to prevent modification of these classes by ithe gSOAP `soapcpp2` source code output.</div><div class="line"><a name="l12425"></a><span class="lineno">12425</span>&#160;Note that gSOAP adds serialization methods to classes to support polymorphism.  However,</div><div class="line"><a name="l12426"></a><span class="lineno">12426</span>&#160;this is a problem when you can&#39;t modify class declarations because they are</div><div class="line"><a name="l12427"></a><span class="lineno">12427</span>&#160;part of a non-modifiable software package.  The solution is to declare these</div><div class="line"><a name="l12428"></a><span class="lineno">12428</span>&#160;classes `volatile`, similar to the tm structure example illustrated above. </div><div class="line"><a name="l12429"></a><span class="lineno">12429</span>&#160;You can also use a `typedef` to associate a schema with a class.</div><div class="line"><a name="l12430"></a><span class="lineno">12430</span>&#160;</div><div class="line"><a name="l12431"></a><span class="lineno">12431</span>&#160;## How to Declare User-Defined Serializers and Deserializers        {#extern}</div><div class="line"><a name="l12432"></a><span class="lineno">12432</span>&#160;</div><div class="line"><a name="l12433"></a><span class="lineno">12433</span>&#160;Users can declare their own (de)serializers for specific data types instead of relying on the gSOAP-generated (de)serializers.</div><div class="line"><a name="l12434"></a><span class="lineno">12434</span>&#160;To declare a external (de)serializer, declare a type with `extern typedef`. gSOAP will not generate the (de)serializers</div><div class="line"><a name="l12435"></a><span class="lineno">12435</span>&#160;for the type name that is declared. For example:</div><div class="line"><a name="l12436"></a><span class="lineno">12436</span>&#160;</div><div class="line"><a name="l12437"></a><span class="lineno">12437</span>&#160;```cpp</div><div class="line"><a name="l12438"></a><span class="lineno">12438</span>&#160;extern typedef char *MyData; </div><div class="line"><a name="l12439"></a><span class="lineno">12439</span>&#160;struct Sample </div><div class="line"><a name="l12440"></a><span class="lineno">12440</span>&#160;{ </div><div class="line"><a name="l12441"></a><span class="lineno">12441</span>&#160;   MyData s; // use user-defined (de)serializer for this field </div><div class="line"><a name="l12442"></a><span class="lineno">12442</span>&#160;   char *t; // use gSOAP (de)serializer for this field </div><div class="line"><a name="l12443"></a><span class="lineno">12443</span>&#160;};</div><div class="line"><a name="l12444"></a><span class="lineno">12444</span>&#160;```</div><div class="line"><a name="l12445"></a><span class="lineno">12445</span>&#160;</div><div class="line"><a name="l12446"></a><span class="lineno">12446</span>&#160;The user is required to supply the following routines for each `extern typedef`&#39;ed name T:</div><div class="line"><a name="l12447"></a><span class="lineno">12447</span>&#160;</div><div class="line"><a name="l12448"></a><span class="lineno">12448</span>&#160;```cpp</div><div class="line"><a name="l12449"></a><span class="lineno">12449</span>&#160;int soap_serialize_T(struct soap *soap, const T *a) </div><div class="line"><a name="l12450"></a><span class="lineno">12450</span>&#160;void soap_default_T(struct soap *soap, T *a) </div><div class="line"><a name="l12451"></a><span class="lineno">12451</span>&#160;int soap_out_T(struct soap *soap, const char *tag, int id, const T *a, const char *type) </div><div class="line"><a name="l12452"></a><span class="lineno">12452</span>&#160;T *soap_in_T(struct soap *soap, const char *tag, T *a, const char *type) </div><div class="line"><a name="l12453"></a><span class="lineno">12453</span>&#160;```</div><div class="line"><a name="l12454"></a><span class="lineno">12454</span>&#160;</div><div class="line"><a name="l12455"></a><span class="lineno">12455</span>&#160;The function prototypes can be found in `soapH.h`.</div><div class="line"><a name="l12456"></a><span class="lineno">12456</span>&#160;</div><div class="line"><a name="l12457"></a><span class="lineno">12457</span>&#160;For example, the (de)serialization of `MyData` can be done with the following code:</div><div class="line"><a name="l12458"></a><span class="lineno">12458</span>&#160;</div><div class="line"><a name="l12459"></a><span class="lineno">12459</span>&#160;```cpp</div><div class="line"><a name="l12460"></a><span class="lineno">12460</span>&#160;int soap_serialize_MyData(struct soap *soap, MyData const*a) </div><div class="line"><a name="l12461"></a><span class="lineno">12461</span>&#160;{ return SOAP_OK; } // no need to mark this node (for multi-ref and cycle detection) </div><div class="line"><a name="l12462"></a><span class="lineno">12462</span>&#160;void soap_default_MyData(struct soap *soap, MyData *a) </div><div class="line"><a name="l12463"></a><span class="lineno">12463</span>&#160;{ *a = NULL } </div><div class="line"><a name="l12464"></a><span class="lineno">12464</span>&#160;int soap_out_MyData(struct soap *soap, const char *tag, int id, MyData const*a, const char *type) </div><div class="line"><a name="l12465"></a><span class="lineno">12465</span>&#160;{ </div><div class="line"><a name="l12466"></a><span class="lineno">12466</span>&#160;   if (soap_element_begin_out(soap, tag, id, type) // print XML beginning tag </div><div class="line"><a name="l12467"></a><span class="lineno">12467</span>&#160;   || soap_send(soap, *a) // just print the string (no XML conversion) </div><div class="line"><a name="l12468"></a><span class="lineno">12468</span>&#160;   || soap_element_end_out(soap, tag)) // print XML ending tag </div><div class="line"><a name="l12469"></a><span class="lineno">12469</span>&#160;     return soap-&gt;error; </div><div class="line"><a name="l12470"></a><span class="lineno">12470</span>&#160;   return SOAP_OK; </div><div class="line"><a name="l12471"></a><span class="lineno">12471</span>&#160;} </div><div class="line"><a name="l12472"></a><span class="lineno">12472</span>&#160;MyData **soap_in_MyData(struct soap *soap, const char *tag, MyData *a, const char *type) </div><div class="line"><a name="l12473"></a><span class="lineno">12473</span>&#160;{ </div><div class="line"><a name="l12474"></a><span class="lineno">12474</span>&#160;   if (soap_element_begin_in(soap, tag)) </div><div class="line"><a name="l12475"></a><span class="lineno">12475</span>&#160;     return NULL; </div><div class="line"><a name="l12476"></a><span class="lineno">12476</span>&#160;   if (!a) </div><div class="line"><a name="l12477"></a><span class="lineno">12477</span>&#160;     a = (MyData*)soap_malloc(soap, sizeof(MyData)); </div><div class="line"><a name="l12478"></a><span class="lineno">12478</span>&#160;   if (soap-&gt;null) </div><div class="line"><a name="l12479"></a><span class="lineno">12479</span>&#160;     *a = NULL; // xsi:nil element </div><div class="line"><a name="l12480"></a><span class="lineno">12480</span>&#160;   if (*soap-&gt;type &amp;&amp; soap_match_tag(soap, soap-&gt;type, type)) </div><div class="line"><a name="l12481"></a><span class="lineno">12481</span>&#160;   { </div><div class="line"><a name="l12482"></a><span class="lineno">12482</span>&#160;     soap-&gt;error = SOAP_TYPE; </div><div class="line"><a name="l12483"></a><span class="lineno">12483</span>&#160;     return NULL; // type mismatch </div><div class="line"><a name="l12484"></a><span class="lineno">12484</span>&#160;   } </div><div class="line"><a name="l12485"></a><span class="lineno">12485</span>&#160;   if (*soap-&gt;href) </div><div class="line"><a name="l12486"></a><span class="lineno">12486</span>&#160;     a = (MyData**)soap_id_forward(soap, soap-&gt;href, a, 0, SOAP_TYPE_MyData, 0, sizeof(MyData), 0, NULL, NULL) </div><div class="line"><a name="l12487"></a><span class="lineno">12487</span>&#160;   else if (soap-&gt;body) </div><div class="line"><a name="l12488"></a><span class="lineno">12488</span>&#160;   { </div><div class="line"><a name="l12489"></a><span class="lineno">12489</span>&#160;     char *s = soap_value(soap); // fill buffer </div><div class="line"><a name="l12490"></a><span class="lineno">12490</span>&#160;     *a = (char*)soap_malloc(soap, strlen(s)+1); </div><div class="line"><a name="l12491"></a><span class="lineno">12491</span>&#160;     strcpy(*a, s); </div><div class="line"><a name="l12492"></a><span class="lineno">12492</span>&#160;   } </div><div class="line"><a name="l12493"></a><span class="lineno">12493</span>&#160;   if (soap-&gt;body &amp;&amp; soap_element_end_in(soap, tag)) </div><div class="line"><a name="l12494"></a><span class="lineno">12494</span>&#160;     return NULL; </div><div class="line"><a name="l12495"></a><span class="lineno">12495</span>&#160;   return a; </div><div class="line"><a name="l12496"></a><span class="lineno">12496</span>&#160;}</div><div class="line"><a name="l12497"></a><span class="lineno">12497</span>&#160;```</div><div class="line"><a name="l12498"></a><span class="lineno">12498</span>&#160;</div><div class="line"><a name="l12499"></a><span class="lineno">12499</span>&#160;More information on custom (de)serialization is available in the package in the gsoap/custom directory where you can also find several examples of custom serializers.</div><div class="line"><a name="l12500"></a><span class="lineno">12500</span>&#160;Note that (de)serializer code requires the use of the low-level gSOAP API that may differ in older gSOAP releases.  If in doubt, we recommend to follow the material and examples in gsoap/custom.</div><div class="line"><a name="l12501"></a><span class="lineno">12501</span>&#160;</div><div class="line"><a name="l12502"></a><span class="lineno">12502</span>&#160;## How to Serialize Data Without Generating xsi:type Attributes</div><div class="line"><a name="l12503"></a><span class="lineno">12503</span>&#160;</div><div class="line"><a name="l12504"></a><span class="lineno">12504</span>&#160;gSOAP serializes data in XML with *`xsi:type`* attributes when the types are</div><div class="line"><a name="l12505"></a><span class="lineno">12505</span>&#160;declared with namespace prefixes to indicate the schema type of the data</div><div class="line"><a name="l12506"></a><span class="lineno">12506</span>&#160;contained in the elements. SOAP 1.1 and 1.2 requires *`xsi:type`* attributes</div><div class="line"><a name="l12507"></a><span class="lineno">12507</span>&#160;in the presence of polymorphic data or when the type of the data cannot be</div><div class="line"><a name="l12508"></a><span class="lineno">12508</span>&#160;deduced from the SOAP payload.  The namespace prefixes are associated with the</div><div class="line"><a name="l12509"></a><span class="lineno">12509</span>&#160;type names of `typedef`s (Section \ref primitive ) for primitive data</div><div class="line"><a name="l12510"></a><span class="lineno">12510</span>&#160;types, `struct`/`class` names, and `enum` names.</div><div class="line"><a name="l12511"></a><span class="lineno">12511</span>&#160;</div><div class="line"><a name="l12512"></a><span class="lineno">12512</span>&#160;To prevent the output of these *`xsi:type`* attributes in the XML</div><div class="line"><a name="l12513"></a><span class="lineno">12513</span>&#160;serialization, you can simply use type declarations that do not include these</div><div class="line"><a name="l12514"></a><span class="lineno">12514</span>&#160;namespace prefixes.  That is, don&#39;t use the `typedef`s for primitive types</div><div class="line"><a name="l12515"></a><span class="lineno">12515</span>&#160;and use unqualified type names with `struct`s, `class`es, and</div><div class="line"><a name="l12516"></a><span class="lineno">12516</span>&#160;`enum`s.</div><div class="line"><a name="l12517"></a><span class="lineno">12517</span>&#160;</div><div class="line"><a name="l12518"></a><span class="lineno">12518</span>&#160;However, there are two issues.  Firstly, if you want to use a primitive schema</div><div class="line"><a name="l12519"></a><span class="lineno">12519</span>&#160;type that has no C/C++ counterpart, you must declare it as a `typedef`</div><div class="line"><a name="l12520"></a><span class="lineno">12520</span>&#160;name with a leading underscore, as in:</div><div class="line"><a name="l12521"></a><span class="lineno">12521</span>&#160;</div><div class="line"><a name="l12522"></a><span class="lineno">12522</span>&#160;```cpp</div><div class="line"><a name="l12523"></a><span class="lineno">12523</span>&#160;typedef char *_xsd__date;</div><div class="line"><a name="l12524"></a><span class="lineno">12524</span>&#160;```</div><div class="line"><a name="l12525"></a><span class="lineno">12525</span>&#160;</div><div class="line"><a name="l12526"></a><span class="lineno">12526</span>&#160;This will produce the necessary *`xsd:date`* information in the WSDL output</div><div class="line"><a name="l12527"></a><span class="lineno">12527</span>&#160;by the gSOAP `soapcpp2` compiler.  But the XML serialization of this type at run time</div><div class="line"><a name="l12528"></a><span class="lineno">12528</span>&#160;won&#39;t include the *`xsi:type`* attribute.  Secondly, to include the proper</div><div class="line"><a name="l12529"></a><span class="lineno">12529</span>&#160;schema definitions in the WSDL produced by the gSOAP `soapcpp2` compiler, you should</div><div class="line"><a name="l12530"></a><span class="lineno">12530</span>&#160;use qualified `struct`, `class`, and `enum` names with a leading</div><div class="line"><a name="l12531"></a><span class="lineno">12531</span>&#160;underscore, as in: </div><div class="line"><a name="l12532"></a><span class="lineno">12532</span>&#160;</div><div class="line"><a name="l12533"></a><span class="lineno">12533</span>&#160;```cpp</div><div class="line"><a name="l12534"></a><span class="lineno">12534</span>&#160;struct _ns__myStruct </div><div class="line"><a name="l12535"></a><span class="lineno">12535</span>&#160;{ ... };</div><div class="line"><a name="l12536"></a><span class="lineno">12536</span>&#160;```</div><div class="line"><a name="l12537"></a><span class="lineno">12537</span>&#160;</div><div class="line"><a name="l12538"></a><span class="lineno">12538</span>&#160;This ensures that `myStruct` is associated with a schema, and therefore</div><div class="line"><a name="l12539"></a><span class="lineno">12539</span>&#160;included in the appropriate schema in the generated WSDL.  The leading</div><div class="line"><a name="l12540"></a><span class="lineno">12540</span>&#160;underscore prevents the XML serialization of *`xsi:type`* attributes for this</div><div class="line"><a name="l12541"></a><span class="lineno">12541</span>&#160;type in the SOAP/XML payload.</div><div class="line"><a name="l12542"></a><span class="lineno">12542</span>&#160;</div><div class="line"><a name="l12543"></a><span class="lineno">12543</span>&#160;## Function Callbacks for Customized I/O and HTTP Handling        {#callback}</div><div class="line"><a name="l12544"></a><span class="lineno">12544</span>&#160;</div><div class="line"><a name="l12545"></a><span class="lineno">12545</span>&#160;gSOAP provides five callback functions for customized I/O and HTTP handling:</div><div class="line"><a name="l12546"></a><span class="lineno">12546</span>&#160;</div><div class="line"><a name="l12547"></a><span class="lineno">12547</span>&#160;* `SOAP_SOCKET (*soap.fopen)(struct soap *soap, const char *endpoint, const char *host, int port)` </div><div class="line"><a name="l12548"></a><span class="lineno">12548</span>&#160;  Called from a client proxy to open a connection to a Web Service located at</div><div class="line"><a name="l12549"></a><span class="lineno">12549</span>&#160;  `endpoint`.  Input parameters `host` and `port` are micro-parsed from</div><div class="line"><a name="l12550"></a><span class="lineno">12550</span>&#160;  `endpoint`.  Should return a valid file descriptor, or `SOAP_INVALID_SOCKET`</div><div class="line"><a name="l12551"></a><span class="lineno">12551</span>&#160;  and `soap-&gt;error` set to an error code.  Built-in gSOAP function:</div><div class="line"><a name="l12552"></a><span class="lineno">12552</span>&#160;  `tcp_connect`</div><div class="line"><a name="l12553"></a><span class="lineno">12553</span>&#160;</div><div class="line"><a name="l12554"></a><span class="lineno">12554</span>&#160;* `int (*soap.fclose)(struct soap *soap)` </div><div class="line"><a name="l12555"></a><span class="lineno">12555</span>&#160;  Called by client proxy **multiple times**, to close a socket connection</div><div class="line"><a name="l12556"></a><span class="lineno">12556</span>&#160;  before a new socket connection is established and at the end of</div><div class="line"><a name="l12557"></a><span class="lineno">12557</span>&#160;  communications when the `SOAP_IO_KEEPALIVE` flag is not set and</div><div class="line"><a name="l12558"></a><span class="lineno">12558</span>&#160;  `soap.keep_alive != 0` (indicating that the other party supports keep</div><div class="line"><a name="l12559"></a><span class="lineno">12559</span>&#160;  alive).  Should return `SOAP_OK`, or a gSOAP error code.  Built-in gSOAP</div><div class="line"><a name="l12560"></a><span class="lineno">12560</span>&#160;  function: `tcp_disconnect`</div><div class="line"><a name="l12561"></a><span class="lineno">12561</span>&#160;</div><div class="line"><a name="l12562"></a><span class="lineno">12562</span>&#160;* `int (*soap.fget)(struct soap *soap)` </div><div class="line"><a name="l12563"></a><span class="lineno">12563</span>&#160;  Called by the main server loop upon an HTTP GET request. The</div><div class="line"><a name="l12564"></a><span class="lineno">12564</span>&#160;  `SOAP_GET_METHOD` error is returned by default. This callback can be used to</div><div class="line"><a name="l12565"></a><span class="lineno">12565</span>&#160;  respond to HTTP GET methods with content, see Section \ref get .  Should</div><div class="line"><a name="l12566"></a><span class="lineno">12566</span>&#160;  return `SOAP_OK`, or a gSOAP error code.  Built-in gSOAP function: `http_get`</div><div class="line"><a name="l12567"></a><span class="lineno">12567</span>&#160;</div><div class="line"><a name="l12568"></a><span class="lineno">12568</span>&#160;* `int (*soap.fput)(struct soap *soap)` </div><div class="line"><a name="l12569"></a><span class="lineno">12569</span>&#160;  Called by the main server loop upon an HTTP PUT request. The</div><div class="line"><a name="l12570"></a><span class="lineno">12570</span>&#160;  `SOAP_PUT_METHOD` error is returned by default. This callback can be used to</div><div class="line"><a name="l12571"></a><span class="lineno">12571</span>&#160;  respond to HTTP PUT.  Should return `SOAP_OK`, or a gSOAP error code.</div><div class="line"><a name="l12572"></a><span class="lineno">12572</span>&#160;  Built-in gSOAP function: `http_put`</div><div class="line"><a name="l12573"></a><span class="lineno">12573</span>&#160;</div><div class="line"><a name="l12574"></a><span class="lineno">12574</span>&#160;* `int (*soap.fdel)(struct soap *soap)` </div><div class="line"><a name="l12575"></a><span class="lineno">12575</span>&#160;  Called by the main server loop upon an HTTP DELETE request. The</div><div class="line"><a name="l12576"></a><span class="lineno">12576</span>&#160;  `SOAP_DELETE_METHOD` error is returned by default. This callback can be used</div><div class="line"><a name="l12577"></a><span class="lineno">12577</span>&#160;  to respond to HTTP DELETE methods.  Should return `SOAP_OK`, or a gSOAP error</div><div class="line"><a name="l12578"></a><span class="lineno">12578</span>&#160;  code.  Built-in gSOAP function: `http_del`</div><div class="line"><a name="l12579"></a><span class="lineno">12579</span>&#160;</div><div class="line"><a name="l12580"></a><span class="lineno">12580</span>&#160;* `int (*soap.fhead)(struct soap *soap)` </div><div class="line"><a name="l12581"></a><span class="lineno">12581</span>&#160;  Called by the main server loop upon an HTTP HEAD request. The</div><div class="line"><a name="l12582"></a><span class="lineno">12582</span>&#160;  `SOAP_HEAD_METHOD` error is returned by default. This callback can be used to</div><div class="line"><a name="l12583"></a><span class="lineno">12583</span>&#160;  respond to HTTP HEAD methods.  Should return `SOAP_OK`, or a gSOAP error</div><div class="line"><a name="l12584"></a><span class="lineno">12584</span>&#160;  code.  Built-in gSOAP function: `http_get`</div><div class="line"><a name="l12585"></a><span class="lineno">12585</span>&#160;</div><div class="line"><a name="l12586"></a><span class="lineno">12586</span>&#160;* `int (*soap.fform)(struct soap *soap)` </div><div class="line"><a name="l12587"></a><span class="lineno">12587</span>&#160;  Called by the main server loop when a user-defined `fparsehdr` callback</div><div class="line"><a name="l12588"></a><span class="lineno">12588</span>&#160;  returned `SOAP_FORM` to signal that the HTTP body must be processed by this</div><div class="line"><a name="l12589"></a><span class="lineno">12589</span>&#160;  form handler callback. The HTTP POST form data MUST be read, otherwise</div><div class="line"><a name="l12590"></a><span class="lineno">12590</span>&#160;  keep-alive messages will end up out of sync.  Should return `SOAP_OK` or a</div><div class="line"><a name="l12591"></a><span class="lineno">12591</span>&#160;  gSOAP error code.  Built-in gSOAP function: none.</div><div class="line"><a name="l12592"></a><span class="lineno">12592</span>&#160;</div><div class="line"><a name="l12593"></a><span class="lineno">12593</span>&#160;* `int (*soap.fpost)(struct soap *soap, const char *endpoint, const char *host, int port, const char *path, const char *action, size_t count)` </div><div class="line"><a name="l12594"></a><span class="lineno">12594</span>&#160;  Called from a client proxy to generate the HTTP header to connect to</div><div class="line"><a name="l12595"></a><span class="lineno">12595</span>&#160;  `endpoint`.  Input parameters `host`, `port`, and `path` are micro-parsed</div><div class="line"><a name="l12596"></a><span class="lineno">12596</span>&#160;  from `endpoint`, `action` is the SOAP action, and `count` is the length of</div><div class="line"><a name="l12597"></a><span class="lineno">12597</span>&#160;  the SOAP message or 0 when `SOAP_ENC_PLAIN` is set or when `SOAP_IO_LENGTH`</div><div class="line"><a name="l12598"></a><span class="lineno">12598</span>&#160;  is reset.  Use function `soap_send(struct soap *soap, char *s)` to write the</div><div class="line"><a name="l12599"></a><span class="lineno">12599</span>&#160;  header contents.  Should return `SOAP_OK`, or a gSOAP error code.  Built-in</div><div class="line"><a name="l12600"></a><span class="lineno">12600</span>&#160;  gSOAP function: `http_post`.</div><div class="line"><a name="l12601"></a><span class="lineno">12601</span>&#160;</div><div class="line"><a name="l12602"></a><span class="lineno">12602</span>&#160;* `int (*soap.fposthdr)(struct soap *soap, const char *key, const char *val)` </div><div class="line"><a name="l12603"></a><span class="lineno">12603</span>&#160;  Called by `http_post` and `http_response` (through the callbacks).  Emits</div><div class="line"><a name="l12604"></a><span class="lineno">12604</span>&#160;  HTTP `key`: `val` header entries.  Should return `SOAP_OK`, or a gSOAP error</div><div class="line"><a name="l12605"></a><span class="lineno">12605</span>&#160;  code.  Built-in gSOAP function: `http_post_header`.</div><div class="line"><a name="l12606"></a><span class="lineno">12606</span>&#160;</div><div class="line"><a name="l12607"></a><span class="lineno">12607</span>&#160;* `int (*soap.fresponse)(struct soap *soap, int soap_error_code, size_t count)` </div><div class="line"><a name="l12608"></a><span class="lineno">12608</span>&#160;  Called from a service to generate the response HTTP header.  Input parameter</div><div class="line"><a name="l12609"></a><span class="lineno">12609</span>&#160;  `soap_error_code` is a gSOAP error code (see Section \ref errcodes  and</div><div class="line"><a name="l12610"></a><span class="lineno">12610</span>&#160;  `count` is the length of the SOAP message or 0 when `SOAP_ENC_PLAIN` is</div><div class="line"><a name="l12611"></a><span class="lineno">12611</span>&#160;  set or when `SOAP_IO_LENGTH` is reset.  Use function `soap_send(struct soap</div><div class="line"><a name="l12612"></a><span class="lineno">12612</span>&#160;  *soap, char *s)` to write the header contents.  Should return `SOAP_OK`, or a</div><div class="line"><a name="l12613"></a><span class="lineno">12613</span>&#160;  gSOAP error code Built-in gSOAP function: `http_response`</div><div class="line"><a name="l12614"></a><span class="lineno">12614</span>&#160;</div><div class="line"><a name="l12615"></a><span class="lineno">12615</span>&#160;* `int (*soap.fparse)(struct soap *soap)` </div><div class="line"><a name="l12616"></a><span class="lineno">12616</span>&#160;  Called by client proxy and service to parse an HTTP header (if present).</div><div class="line"><a name="l12617"></a><span class="lineno">12617</span>&#160;  When user-defined, this routine must at least skip the header.  Use function</div><div class="line"><a name="l12618"></a><span class="lineno">12618</span>&#160;  `int soap_getline(struct soap *soap, char *buf, int len)` to read HTTP header</div><div class="line"><a name="l12619"></a><span class="lineno">12619</span>&#160;  lines into a buffer `buf` of length `len` (returns empty line at end of HTTP</div><div class="line"><a name="l12620"></a><span class="lineno">12620</span>&#160;    header).  Should return `SOAP_OK`, or a gSOAP error code.  Built-in gSOAP</div><div class="line"><a name="l12621"></a><span class="lineno">12621</span>&#160;  function: `http_parse`</div><div class="line"><a name="l12622"></a><span class="lineno">12622</span>&#160;</div><div class="line"><a name="l12623"></a><span class="lineno">12623</span>&#160;* `int (*soap.fparsehdr)(struct soap *soap, const char *key, const char *val)` </div><div class="line"><a name="l12624"></a><span class="lineno">12624</span>&#160;  Called by `http_parse` (through the `fparse` callback).  Handles HTTP `key`:</div><div class="line"><a name="l12625"></a><span class="lineno">12625</span>&#160;  `val` header entries to set gSOAP&#39;s internals.  Should return `SOAP_OK`,</div><div class="line"><a name="l12626"></a><span class="lineno">12626</span>&#160;  `SOAP_STOP` (see `fstop`) or a gSOAP error code.  Built-in gSOAP function:</div><div class="line"><a name="l12627"></a><span class="lineno">12627</span>&#160;  `http_parse_header`</div><div class="line"><a name="l12628"></a><span class="lineno">12628</span>&#160;</div><div class="line"><a name="l12629"></a><span class="lineno">12629</span>&#160;* `int (*soap.fsend)(struct soap *soap, const char *s, size_t n)` </div><div class="line"><a name="l12630"></a><span class="lineno">12630</span>&#160;  Called for all send operations to emit contents of `s` of length `n`.  Should</div><div class="line"><a name="l12631"></a><span class="lineno">12631</span>&#160;  return `SOAP_OK`, or a gSOAP error code.  Built-in gSOAP function: `fsend`</div><div class="line"><a name="l12632"></a><span class="lineno">12632</span>&#160;</div><div class="line"><a name="l12633"></a><span class="lineno">12633</span>&#160;* `size_t (*soap.frecv)(struct soap *soap, char *s, size_t n)` </div><div class="line"><a name="l12634"></a><span class="lineno">12634</span>&#160;  Called for all receive operations to fill buffer `s` of maximum length `n`.</div><div class="line"><a name="l12635"></a><span class="lineno">12635</span>&#160;  Should return the number of bytes read or 0 in case of an error, e.g. EOF.</div><div class="line"><a name="l12636"></a><span class="lineno">12636</span>&#160;  Built-in gSOAP function: `frecv`</div><div class="line"><a name="l12637"></a><span class="lineno">12637</span>&#160;</div><div class="line"><a name="l12638"></a><span class="lineno">12638</span>&#160;* `int (*soap.fignore)(struct soap *soap, const char *tag)` </div><div class="line"><a name="l12639"></a><span class="lineno">12639</span>&#160;  Called when an unknown XML element was encountered on the input. The `tag`</div><div class="line"><a name="l12640"></a><span class="lineno">12640</span>&#160;  parameter is the offending XML element tag name.  Should return `SOAP_OK`, or</div><div class="line"><a name="l12641"></a><span class="lineno">12641</span>&#160;  a gSOAP error code such as `SOAP_TAG_MISMATCH` to stop processing.  Can be</div><div class="line"><a name="l12642"></a><span class="lineno">12642</span>&#160;  used to override *`mustUnderstand=&quot;true&quot;`* attributes on unrecognized SOAP</div><div class="line"><a name="l12643"></a><span class="lineno">12643</span>&#160;  Header elements that raise faults.  Check `soap-&gt;mustUnderstand != 0` in</div><div class="line"><a name="l12644"></a><span class="lineno">12644</span>&#160;  `fignore` function for presence of mustUnderstand attribute.  Built-in gSOAP</div><div class="line"><a name="l12645"></a><span class="lineno">12645</span>&#160;  function: none.</div><div class="line"><a name="l12646"></a><span class="lineno">12646</span>&#160;</div><div class="line"><a name="l12647"></a><span class="lineno">12647</span>&#160;* `int (*soap.fconnect)(struct soap *soap, const char *endpoint, const char *host, int port)` </div><div class="line"><a name="l12648"></a><span class="lineno">12648</span>&#160;  When non-NULL, this callback is called for all client-to-server connect</div><div class="line"><a name="l12649"></a><span class="lineno">12649</span>&#160;  operations instead of the built-in socket connect code. Therefore, it can be</div><div class="line"><a name="l12650"></a><span class="lineno">12650</span>&#160;  used to override the built-in connection establishment. Parameter `endpoint`</div><div class="line"><a name="l12651"></a><span class="lineno">12651</span>&#160;  contains the server endpoint URL, `host` the domain name or IP, and `port`</div><div class="line"><a name="l12652"></a><span class="lineno">12652</span>&#160;  the port number.  Should return `SOAP_OK`, or a gSOAP error code.  Built-in</div><div class="line"><a name="l12653"></a><span class="lineno">12653</span>&#160;  gSOAP function: none</div><div class="line"><a name="l12654"></a><span class="lineno">12654</span>&#160;</div><div class="line"><a name="l12655"></a><span class="lineno">12655</span>&#160;* `SOAP_SOCKET (*soap.faccept)(struct soap *soap, SOAP_SOCKERT s, struct sockaddr *a, int *n)` </div><div class="line"><a name="l12656"></a><span class="lineno">12656</span>&#160;  Called by `soap_accept`. This is a wrapper routine for `accept`.  Given</div><div class="line"><a name="l12657"></a><span class="lineno">12657</span>&#160;  master socket `s` should return a valid socket descriptor or</div><div class="line"><a name="l12658"></a><span class="lineno">12658</span>&#160;  `SOAP_INVALID_SOCKET` and set `soap-&gt;error` to an error code.  Built-in gSOAP</div><div class="line"><a name="l12659"></a><span class="lineno">12659</span>&#160;  function: `tcp_accept`</div><div class="line"><a name="l12660"></a><span class="lineno">12660</span>&#160;</div><div class="line"><a name="l12661"></a><span class="lineno">12661</span>&#160;* `int (*soap.fresolve)(struct soap *soap, const char *addr, struct in_addr *inaddr)` </div><div class="line"><a name="l12662"></a><span class="lineno">12662</span>&#160;  Called by `soap_bind` if a host name is given and `soap_connect` to resolve a</div><div class="line"><a name="l12663"></a><span class="lineno">12663</span>&#160;  domain name `addr`.  Should set `in_addr *a` and return `SOAP_OK` or return</div><div class="line"><a name="l12664"></a><span class="lineno">12664</span>&#160;  `SOAP_ERR` upon failure.  Built-in gSOAP function: `tcp_gethost` </div><div class="line"><a name="l12665"></a><span class="lineno">12665</span>&#160;</div><div class="line"><a name="l12666"></a><span class="lineno">12666</span>&#160;* `int (*soap.fpoll)(struct soap *soap)` </div><div class="line"><a name="l12667"></a><span class="lineno">12667</span>&#160;  Used by clients to check if the server is still responsive.</div><div class="line"><a name="l12668"></a><span class="lineno">12668</span>&#160;  Built-in gSOAP function: `soap_poll` </div><div class="line"><a name="l12669"></a><span class="lineno">12669</span>&#160;</div><div class="line"><a name="l12670"></a><span class="lineno">12670</span>&#160;* `int (*soap.fserveloop)(struct soap *soap)` </div><div class="line"><a name="l12671"></a><span class="lineno">12671</span>&#160;  Called after successful invocation of a server operation in the server loop,</div><div class="line"><a name="l12672"></a><span class="lineno">12672</span>&#160;  immediately after sending the response to a client.  Can be used to clean up</div><div class="line"><a name="l12673"></a><span class="lineno">12673</span>&#160;  resources (e.g. using `soap_end()`) while serving a long sequence of</div><div class="line"><a name="l12674"></a><span class="lineno">12674</span>&#160;  keep-alive connections.  Should return `SOAP_OK`, or set `soap-&gt;error` to a</div><div class="line"><a name="l12675"></a><span class="lineno">12675</span>&#160;  gSOAP error code and return `soap-&gt;error`.  Built-in gSOAP function: none.</div><div class="line"><a name="l12676"></a><span class="lineno">12676</span>&#160;</div><div class="line"><a name="l12677"></a><span class="lineno">12677</span>&#160;* `void (*soap.fmalloc)(struct soap *soap, size_t n)` </div><div class="line"><a name="l12678"></a><span class="lineno">12678</span>&#160;  Use to override memory allocation for deserialized C data. Memory allocated</div><div class="line"><a name="l12679"></a><span class="lineno">12679</span>&#160;  via this callback will *not* be automatically released by the gSOAP engine.</div><div class="line"><a name="l12680"></a><span class="lineno">12680</span>&#160;  The application must release this data by keeping track of the allocations.</div><div class="line"><a name="l12681"></a><span class="lineno">12681</span>&#160;  Note: it is not safe to traverse deserialized data structures and free each</div><div class="line"><a name="l12682"></a><span class="lineno">12682</span>&#160;  node, since data might be shared (SOAP multiref) and some allocated data such</div><div class="line"><a name="l12683"></a><span class="lineno">12683</span>&#160;  as the HTTP SOAPAction might no be part of the structure.</div><div class="line"><a name="l12684"></a><span class="lineno">12684</span>&#160;  Built-in gSOAP function: none.</div><div class="line"><a name="l12685"></a><span class="lineno">12685</span>&#160;</div><div class="line"><a name="l12686"></a><span class="lineno">12686</span>&#160;* `int (*soap.fheader)(struct soap *soap)` </div><div class="line"><a name="l12687"></a><span class="lineno">12687</span>&#160;  Called immediately after parsing a SOAP Header. The SOAP Header struct</div><div class="line"><a name="l12688"></a><span class="lineno">12688</span>&#160;  referenced by `soap-&gt;header` can be inspected and verified. The function</div><div class="line"><a name="l12689"></a><span class="lineno">12689</span>&#160;  should return `SOAP_OK` or a fault.  Built-in gSOAP function: none.</div><div class="line"><a name="l12690"></a><span class="lineno">12690</span>&#160;</div><div class="line"><a name="l12691"></a><span class="lineno">12691</span>&#160;* `int (*soap.fsvalidate)(struct soap *soap, const char *pattern, const char *string)` </div><div class="line"><a name="l12692"></a><span class="lineno">12692</span>&#160;  Called to validate a non-NULL string against a non-NULL pattern. Patterns use</div><div class="line"><a name="l12693"></a><span class="lineno">12693</span>&#160;  XML schema regex syntax. Allows user-defined pattern validation. Should</div><div class="line"><a name="l12694"></a><span class="lineno">12694</span>&#160;  return `SOAP_OK` when the string matches the pattern or `SOAP_TYPE` when the</div><div class="line"><a name="l12695"></a><span class="lineno">12695</span>&#160;  string does not match.  Built-in gSOAP function: none.</div><div class="line"><a name="l12696"></a><span class="lineno">12696</span>&#160;</div><div class="line"><a name="l12697"></a><span class="lineno">12697</span>&#160;* `int (*soap.fwvalidate)(struct soap *soap, const char *pattern, const wchar_t *string)` </div><div class="line"><a name="l12698"></a><span class="lineno">12698</span>&#160;  Called to validate a non-NULL wide string against a non-NULL pattern.</div><div class="line"><a name="l12699"></a><span class="lineno">12699</span>&#160;  Patterns use XML schema regex syntax. Allows user-defined pattern validation.</div><div class="line"><a name="l12700"></a><span class="lineno">12700</span>&#160;  Should return `SOAP_OK` when the string matches the pattern or `SOAP_TYPE`</div><div class="line"><a name="l12701"></a><span class="lineno">12701</span>&#160;  when the string does not match.  Built-in gSOAP function: none.</div><div class="line"><a name="l12702"></a><span class="lineno">12702</span>&#160;</div><div class="line"><a name="l12703"></a><span class="lineno">12703</span>&#160;* `void (*soap.fseterror)(struct soap *soap, const char **code, const char **string)` </div><div class="line"><a name="l12704"></a><span class="lineno">12704</span>&#160;  Called to set the SOAP Fault `code` and `string` values based on the value of</div><div class="line"><a name="l12705"></a><span class="lineno">12705</span>&#160;  `soap-&gt;error`. Allows user-defined messages to be associated with gSOAP error</div><div class="line"><a name="l12706"></a><span class="lineno">12706</span>&#160;  codes to override gSOAP&#39;s built-in error messages.  Built-in gSOAP function:</div><div class="line"><a name="l12707"></a><span class="lineno">12707</span>&#160;  none.</div><div class="line"><a name="l12708"></a><span class="lineno">12708</span>&#160;</div><div class="line"><a name="l12709"></a><span class="lineno">12709</span>&#160;In addition, a `void *user` field in the `struct soap` data structure is available to pass user-defined data to the callbacks.</div><div class="line"><a name="l12710"></a><span class="lineno">12710</span>&#160;</div><div class="line"><a name="l12711"></a><span class="lineno">12711</span>&#160;The following example uses I/O function callbacks for customized serialization of data into a fixed-size buffer and deserialization back into a</div><div class="line"><a name="l12712"></a><span class="lineno">12712</span>&#160;datastructure:</div><div class="line"><a name="l12713"></a><span class="lineno">12713</span>&#160;</div><div class="line"><a name="l12714"></a><span class="lineno">12714</span>&#160;```cpp</div><div class="line"><a name="l12715"></a><span class="lineno">12715</span>&#160;char buf[10000]; // XML buffer </div><div class="line"><a name="l12716"></a><span class="lineno">12716</span>&#160;int len1 = 0;   // #chars written </div><div class="line"><a name="l12717"></a><span class="lineno">12717</span>&#160;int len2 = 0;   // #chars read </div><div class="line"><a name="l12718"></a><span class="lineno">12718</span>&#160;// mysend: put XML in buf[] </div><div class="line"><a name="l12719"></a><span class="lineno">12719</span>&#160;int mysend(struct soap *soap, const char *s, size_t n) </div><div class="line"><a name="l12720"></a><span class="lineno">12720</span>&#160;{ </div><div class="line"><a name="l12721"></a><span class="lineno">12721</span>&#160;   if (len1 + n &gt; sizeof(buf)) </div><div class="line"><a name="l12722"></a><span class="lineno">12722</span>&#160;     return SOAP_EOF; </div><div class="line"><a name="l12723"></a><span class="lineno">12723</span>&#160;   strcpy(buf + len1, s); </div><div class="line"><a name="l12724"></a><span class="lineno">12724</span>&#160;   len1 += n; </div><div class="line"><a name="l12725"></a><span class="lineno">12725</span>&#160;   return SOAP_OK; </div><div class="line"><a name="l12726"></a><span class="lineno">12726</span>&#160;} </div><div class="line"><a name="l12727"></a><span class="lineno">12727</span>&#160;// myrecv: get XML from buf[] </div><div class="line"><a name="l12728"></a><span class="lineno">12728</span>&#160;size_t myrecv(struct soap *soap, char *s, size_t n) </div><div class="line"><a name="l12729"></a><span class="lineno">12729</span>&#160;{ </div><div class="line"><a name="l12730"></a><span class="lineno">12730</span>&#160;   if (len2 + n &gt; len1) </div><div class="line"><a name="l12731"></a><span class="lineno">12731</span>&#160;     n = len1 - len2; </div><div class="line"><a name="l12732"></a><span class="lineno">12732</span>&#160;   strncpy(s, buf + len2, n); </div><div class="line"><a name="l12733"></a><span class="lineno">12733</span>&#160;   len2 += n; </div><div class="line"><a name="l12734"></a><span class="lineno">12734</span>&#160;   return n; </div><div class="line"><a name="l12735"></a><span class="lineno">12735</span>&#160;} </div><div class="line"><a name="l12736"></a><span class="lineno">12736</span>&#160;int main() </div><div class="line"><a name="l12737"></a><span class="lineno">12737</span>&#160;{ </div><div class="line"><a name="l12738"></a><span class="lineno">12738</span>&#160;   struct soap soap; </div><div class="line"><a name="l12739"></a><span class="lineno">12739</span>&#160;   struct ns__person p; </div><div class="line"><a name="l12740"></a><span class="lineno">12740</span>&#160;   soap_init(&amp;soap); </div><div class="line"><a name="l12741"></a><span class="lineno">12741</span>&#160;   len1 = len2 = 0;     // reset buffer pointers </div><div class="line"><a name="l12742"></a><span class="lineno">12742</span>&#160;   p.name = &quot;John Doe&quot;; </div><div class="line"><a name="l12743"></a><span class="lineno">12743</span>&#160;   p.age = 25; </div><div class="line"><a name="l12744"></a><span class="lineno">12744</span>&#160;   soap.fsend = mysend; // assign callback </div><div class="line"><a name="l12745"></a><span class="lineno">12745</span>&#160;   soap.frecv = myrecv; // assign callback </div><div class="line"><a name="l12746"></a><span class="lineno">12746</span>&#160;   soap_begin_send(&amp;soap); </div><div class="line"><a name="l12747"></a><span class="lineno">12747</span>&#160;   soap_set_omode(&amp;soap, SOAP_XML_TREE); </div><div class="line"><a name="l12748"></a><span class="lineno">12748</span>&#160;   soap_serialize_ns__person(&amp;soap, &amp;p); </div><div class="line"><a name="l12749"></a><span class="lineno">12749</span>&#160;   soap_put_ns__person(&amp;soap, &amp;p, &quot;ns:person&quot;, NULL); </div><div class="line"><a name="l12750"></a><span class="lineno">12750</span>&#160;   soap_end_send(&amp;soap); </div><div class="line"><a name="l12751"></a><span class="lineno">12751</span>&#160;   if (soap.error) </div><div class="line"><a name="l12752"></a><span class="lineno">12752</span>&#160;   { </div><div class="line"><a name="l12753"></a><span class="lineno">12753</span>&#160;     soap_print_fault(&amp;soap, stdout); </div><div class="line"><a name="l12754"></a><span class="lineno">12754</span>&#160;     exit(1); </div><div class="line"><a name="l12755"></a><span class="lineno">12755</span>&#160;   } </div><div class="line"><a name="l12756"></a><span class="lineno">12756</span>&#160;   soap_begin_recv(&amp;soap); </div><div class="line"><a name="l12757"></a><span class="lineno">12757</span>&#160;   soap_get_ns__person(&amp;soap, &amp;p, &quot;ns:person&quot;, NULL); </div><div class="line"><a name="l12758"></a><span class="lineno">12758</span>&#160;   soap_end_recv(&amp;soap); </div><div class="line"><a name="l12759"></a><span class="lineno">12759</span>&#160;   if (soap.error) </div><div class="line"><a name="l12760"></a><span class="lineno">12760</span>&#160;   { </div><div class="line"><a name="l12761"></a><span class="lineno">12761</span>&#160;     soap_print_fault(&amp;soap, stdout); </div><div class="line"><a name="l12762"></a><span class="lineno">12762</span>&#160;     exit(1); </div><div class="line"><a name="l12763"></a><span class="lineno">12763</span>&#160;   } </div><div class="line"><a name="l12764"></a><span class="lineno">12764</span>&#160;   soap_destroy(&amp;soap); </div><div class="line"><a name="l12765"></a><span class="lineno">12765</span>&#160;   soap_end(&amp;soap); </div><div class="line"><a name="l12766"></a><span class="lineno">12766</span>&#160;   soap_done(&amp;soap); // disable callbacks </div><div class="line"><a name="l12767"></a><span class="lineno">12767</span>&#160;}</div><div class="line"><a name="l12768"></a><span class="lineno">12768</span>&#160;```</div><div class="line"><a name="l12769"></a><span class="lineno">12769</span>&#160;</div><div class="line"><a name="l12770"></a><span class="lineno">12770</span>&#160;A fixed-size buffer to store the outbound message sent is not flexible to handle large content. To store the message in an expanding buffer, use for example:</div><div class="line"><a name="l12771"></a><span class="lineno">12771</span>&#160;</div><div class="line"><a name="l12772"></a><span class="lineno">12772</span>&#160;```cpp</div><div class="line"><a name="l12773"></a><span class="lineno">12773</span>&#160;struct buffer </div><div class="line"><a name="l12774"></a><span class="lineno">12774</span>&#160;{ </div><div class="line"><a name="l12775"></a><span class="lineno">12775</span>&#160;   size_t len; </div><div class="line"><a name="l12776"></a><span class="lineno">12776</span>&#160;   size_t max; </div><div class="line"><a name="l12777"></a><span class="lineno">12777</span>&#160;   char *buf; </div><div class="line"><a name="l12778"></a><span class="lineno">12778</span>&#160;}; </div><div class="line"><a name="l12779"></a><span class="lineno">12779</span>&#160;int main() </div><div class="line"><a name="l12780"></a><span class="lineno">12780</span>&#160;{ </div><div class="line"><a name="l12781"></a><span class="lineno">12781</span>&#160;   struct buffer *h = malloc(sizeof(struct buffer)); </div><div class="line"><a name="l12782"></a><span class="lineno">12782</span>&#160;   h-&gt;len = 0; </div><div class="line"><a name="l12783"></a><span class="lineno">12783</span>&#160;   h-&gt;max = 0; </div><div class="line"><a name="l12784"></a><span class="lineno">12784</span>&#160;   h-&gt;buf = NULL; </div><div class="line"><a name="l12785"></a><span class="lineno">12785</span>&#160;   soap.user = (void *)h; // pass buffer as a handle to the callback </div><div class="line"><a name="l12786"></a><span class="lineno">12786</span>&#160;   soap.fsend = mysend; // assign callback </div><div class="line"><a name="l12787"></a><span class="lineno">12787</span>&#160;   ... </div><div class="line"><a name="l12788"></a><span class="lineno">12788</span>&#160;   if (h-&gt;len) </div><div class="line"><a name="l12789"></a><span class="lineno">12789</span>&#160;   { </div><div class="line"><a name="l12790"></a><span class="lineno">12790</span>&#160;     ... // use h-&gt;buf[0..h-&gt;len-1] content </div><div class="line"><a name="l12791"></a><span class="lineno">12791</span>&#160;     // then cleanup: </div><div class="line"><a name="l12792"></a><span class="lineno">12792</span>&#160;     h-&gt;len = 0; </div><div class="line"><a name="l12793"></a><span class="lineno">12793</span>&#160;     h-&gt;max = 0; </div><div class="line"><a name="l12794"></a><span class="lineno">12794</span>&#160;     free(h-&gt;buf); </div><div class="line"><a name="l12795"></a><span class="lineno">12795</span>&#160;     h-&gt;buf = NULL; </div><div class="line"><a name="l12796"></a><span class="lineno">12796</span>&#160;   } </div><div class="line"><a name="l12797"></a><span class="lineno">12797</span>&#160;   ... </div><div class="line"><a name="l12798"></a><span class="lineno">12798</span>&#160;} </div><div class="line"><a name="l12799"></a><span class="lineno">12799</span>&#160;int mysend(struct soap *soap, const char *s, size_t n) </div><div class="line"><a name="l12800"></a><span class="lineno">12800</span>&#160;{ </div><div class="line"><a name="l12801"></a><span class="lineno">12801</span>&#160;   struct buffer *h = (struct buffer*)soap-&gt;user; // get buffer through handle </div><div class="line"><a name="l12802"></a><span class="lineno">12802</span>&#160;   int m = h-&gt;max, k = h-&gt;len + n; </div><div class="line"><a name="l12803"></a><span class="lineno">12803</span>&#160;   // need to increase space? </div><div class="line"><a name="l12804"></a><span class="lineno">12804</span>&#160;   if (m == 0) </div><div class="line"><a name="l12805"></a><span class="lineno">12805</span>&#160;     m = 1024; </div><div class="line"><a name="l12806"></a><span class="lineno">12806</span>&#160;   else </div><div class="line"><a name="l12807"></a><span class="lineno">12807</span>&#160;     while (k &gt;= m) </div><div class="line"><a name="l12808"></a><span class="lineno">12808</span>&#160;       m *= 2; </div><div class="line"><a name="l12809"></a><span class="lineno">12809</span>&#160;   if (m != h-&gt;max) </div><div class="line"><a name="l12810"></a><span class="lineno">12810</span>&#160;   { </div><div class="line"><a name="l12811"></a><span class="lineno">12811</span>&#160;     char *buf = malloc(m); </div><div class="line"><a name="l12812"></a><span class="lineno">12812</span>&#160;     memcpy(buf, h-&gt;buf, h-&gt;len); </div><div class="line"><a name="l12813"></a><span class="lineno">12813</span>&#160;     h-&gt;max = m; </div><div class="line"><a name="l12814"></a><span class="lineno">12814</span>&#160;     if (h-&gt;buf) </div><div class="line"><a name="l12815"></a><span class="lineno">12815</span>&#160;       free(h-&gt;buf); </div><div class="line"><a name="l12816"></a><span class="lineno">12816</span>&#160;     h-&gt;buf = buf; </div><div class="line"><a name="l12817"></a><span class="lineno">12817</span>&#160;   } </div><div class="line"><a name="l12818"></a><span class="lineno">12818</span>&#160;   memcpy(h-&gt;buf + h-&gt;len, s, n); </div><div class="line"><a name="l12819"></a><span class="lineno">12819</span>&#160;   h-&gt;len += n; </div><div class="line"><a name="l12820"></a><span class="lineno">12820</span>&#160;   return SOAP_OK; </div><div class="line"><a name="l12821"></a><span class="lineno">12821</span>&#160;}</div><div class="line"><a name="l12822"></a><span class="lineno">12822</span>&#160;```</div><div class="line"><a name="l12823"></a><span class="lineno">12823</span>&#160;</div><div class="line"><a name="l12824"></a><span class="lineno">12824</span>&#160;The `soap_done` function can be called to reset the callback to the default internal gSOAP I/O and HTTP handlers.</div><div class="line"><a name="l12825"></a><span class="lineno">12825</span>&#160;</div><div class="line"><a name="l12826"></a><span class="lineno">12826</span>&#160;The following example illustrates customized I/O and (HTTP) header handling. The SOAP request is saved to a file. The client proxy</div><div class="line"><a name="l12827"></a><span class="lineno">12827</span>&#160;then reads the file contents as the service response. To perform this trick, the service response has exactly the same structure as the</div><div class="line"><a name="l12828"></a><span class="lineno">12828</span>&#160;request. This is declared by the `struct ns__test` output parameter part of the service operation declaration.</div><div class="line"><a name="l12829"></a><span class="lineno">12829</span>&#160;This struct resembles the service request (see the generated `soapStub.h` file created from the header file).</div><div class="line"><a name="l12830"></a><span class="lineno">12830</span>&#160;</div><div class="line"><a name="l12831"></a><span class="lineno">12831</span>&#160;The header file is:</div><div class="line"><a name="l12832"></a><span class="lineno">12832</span>&#160;</div><div class="line"><a name="l12833"></a><span class="lineno">12833</span>&#160;```cpp</div><div class="line"><a name="l12834"></a><span class="lineno">12834</span>&#160;//gsoap ns service name: callback </div><div class="line"><a name="l12835"></a><span class="lineno">12835</span>&#160;//gsoap ns service namespace: urn:callback </div><div class="line"><a name="l12836"></a><span class="lineno">12836</span>&#160;struct ns__person </div><div class="line"><a name="l12837"></a><span class="lineno">12837</span>&#160;{ </div><div class="line"><a name="l12838"></a><span class="lineno">12838</span>&#160;   char *name; </div><div class="line"><a name="l12839"></a><span class="lineno">12839</span>&#160;   int age; </div><div class="line"><a name="l12840"></a><span class="lineno">12840</span>&#160;}; </div><div class="line"><a name="l12841"></a><span class="lineno">12841</span>&#160;int ns__test(struct ns__person in, struct ns__test &amp;out);</div><div class="line"><a name="l12842"></a><span class="lineno">12842</span>&#160;```</div><div class="line"><a name="l12843"></a><span class="lineno">12843</span>&#160;</div><div class="line"><a name="l12844"></a><span class="lineno">12844</span>&#160;The client program is:</div><div class="line"><a name="l12845"></a><span class="lineno">12845</span>&#160;</div><div class="line"><a name="l12846"></a><span class="lineno">12846</span>&#160;```cpp</div><div class="line"><a name="l12847"></a><span class="lineno">12847</span>&#160;#include &quot;soapH.h&quot; </div><div class="line"><a name="l12848"></a><span class="lineno">12848</span>&#160;... </div><div class="line"><a name="l12849"></a><span class="lineno">12849</span>&#160;SOAP_SOCKET myopen(struct soap *soap, const char *endpoint, const char *host, int port) </div><div class="line"><a name="l12850"></a><span class="lineno">12850</span>&#160;{ </div><div class="line"><a name="l12851"></a><span class="lineno">12851</span>&#160;   if (strncmp(endpoint, &quot;file:&quot;, 5)) </div><div class="line"><a name="l12852"></a><span class="lineno">12852</span>&#160;   { </div><div class="line"><a name="l12853"></a><span class="lineno">12853</span>&#160;     printf(&quot;File name expected\n&quot;); </div><div class="line"><a name="l12854"></a><span class="lineno">12854</span>&#160;     return SOAP_INVALID_SOCKET; </div><div class="line"><a name="l12855"></a><span class="lineno">12855</span>&#160;   } </div><div class="line"><a name="l12856"></a><span class="lineno">12856</span>&#160;   if ((soap-&gt;sendfd = soap-&gt;recvfd = open(host, O_RDWR|O_CREAT, S_IWUSR|S_IRUSR)) &lt; 0) </div><div class="line"><a name="l12857"></a><span class="lineno">12857</span>&#160;     return SOAP_INVALID_SOCKET; </div><div class="line"><a name="l12858"></a><span class="lineno">12858</span>&#160;   return soap-&gt;sendfd; </div><div class="line"><a name="l12859"></a><span class="lineno">12859</span>&#160;} </div><div class="line"><a name="l12860"></a><span class="lineno">12860</span>&#160;void myclose(struct soap *soap) </div><div class="line"><a name="l12861"></a><span class="lineno">12861</span>&#160;{ </div><div class="line"><a name="l12862"></a><span class="lineno">12862</span>&#160;   if (soap-&gt;sendfd &gt; 2) // still open? </div><div class="line"><a name="l12863"></a><span class="lineno">12863</span>&#160;     close(soap-&gt;sendfd); // then close it </div><div class="line"><a name="l12864"></a><span class="lineno">12864</span>&#160;   soap-&gt;recvfd = 0; // set back to stdin </div><div class="line"><a name="l12865"></a><span class="lineno">12865</span>&#160;   soap-&gt;sendfd = 1; // set back to stdout </div><div class="line"><a name="l12866"></a><span class="lineno">12866</span>&#160;} </div><div class="line"><a name="l12867"></a><span class="lineno">12867</span>&#160;int mypost(struct soap *soap, const char *endpoint, const char *host, const char *path, const char *action, size_t count) </div><div class="line"><a name="l12868"></a><span class="lineno">12868</span>&#160;{ </div><div class="line"><a name="l12869"></a><span class="lineno">12869</span>&#160;   return soap_send(soap, &quot;Custom-generated file\n&quot;); // writes to soap-&gt;sendfd </div><div class="line"><a name="l12870"></a><span class="lineno">12870</span>&#160;} </div><div class="line"><a name="l12871"></a><span class="lineno">12871</span>&#160;int myparse(struct soap *soap) </div><div class="line"><a name="l12872"></a><span class="lineno">12872</span>&#160;{ </div><div class="line"><a name="l12873"></a><span class="lineno">12873</span>&#160;   char buf[256]; </div><div class="line"><a name="l12874"></a><span class="lineno">12874</span>&#160;   if (lseek(soap-&gt;recvfd, 0, SEEK_SET) &lt; 0 || soap_getline(soap, buf, 256)) // go to begin and skip custom header </div><div class="line"><a name="l12875"></a><span class="lineno">12875</span>&#160;     return SOAP_EOF; </div><div class="line"><a name="l12876"></a><span class="lineno">12876</span>&#160;   return SOAP_OK; </div><div class="line"><a name="l12877"></a><span class="lineno">12877</span>&#160;} </div><div class="line"><a name="l12878"></a><span class="lineno">12878</span>&#160;int main() </div><div class="line"><a name="l12879"></a><span class="lineno">12879</span>&#160;{ </div><div class="line"><a name="l12880"></a><span class="lineno">12880</span>&#160;   struct soap soap; </div><div class="line"><a name="l12881"></a><span class="lineno">12881</span>&#160;   struct ns__test r; </div><div class="line"><a name="l12882"></a><span class="lineno">12882</span>&#160;   struct ns__person p; </div><div class="line"><a name="l12883"></a><span class="lineno">12883</span>&#160;   soap_init(&amp;soap); // reset </div><div class="line"><a name="l12884"></a><span class="lineno">12884</span>&#160;   p.name = &quot;John Doe&quot;; </div><div class="line"><a name="l12885"></a><span class="lineno">12885</span>&#160;   p.age = 99; </div><div class="line"><a name="l12886"></a><span class="lineno">12886</span>&#160;   soap.fopen = myopen; // use custom open </div><div class="line"><a name="l12887"></a><span class="lineno">12887</span>&#160;   soap.fpost = mypost; // use custom post </div><div class="line"><a name="l12888"></a><span class="lineno">12888</span>&#160;   soap.fparse = myparse; // use custom response parser </div><div class="line"><a name="l12889"></a><span class="lineno">12889</span>&#160;   soap.fclose = myclose; // use custom close </div><div class="line"><a name="l12890"></a><span class="lineno">12890</span>&#160;   soap_call_ns__test(&amp;soap, &quot;file://test.xml&quot;, &quot;&quot;, p, r); </div><div class="line"><a name="l12891"></a><span class="lineno">12891</span>&#160;   if (soap.error) </div><div class="line"><a name="l12892"></a><span class="lineno">12892</span>&#160;   { </div><div class="line"><a name="l12893"></a><span class="lineno">12893</span>&#160;     soap_print_fault(&amp;soap, stdout); </div><div class="line"><a name="l12894"></a><span class="lineno">12894</span>&#160;     exit(1); </div><div class="line"><a name="l12895"></a><span class="lineno">12895</span>&#160;   } </div><div class="line"><a name="l12896"></a><span class="lineno">12896</span>&#160;   soap_end(&amp;soap); </div><div class="line"><a name="l12897"></a><span class="lineno">12897</span>&#160;   soap_init(&amp;soap); // reset to default callbacks </div><div class="line"><a name="l12898"></a><span class="lineno">12898</span>&#160;}</div><div class="line"><a name="l12899"></a><span class="lineno">12899</span>&#160;```</div><div class="line"><a name="l12900"></a><span class="lineno">12900</span>&#160;</div><div class="line"><a name="l12901"></a><span class="lineno">12901</span>&#160;SOAP 1.1 and 1.2 specify that XML elements may be ignored when present in a SOAP payload on the receiving side.</div><div class="line"><a name="l12902"></a><span class="lineno">12902</span>&#160;gSOAP ignores XML elements that are unknown, unless the XML attribute *`mustUnderstand=&quot;true&quot;`* is present in the XML element.</div><div class="line"><a name="l12903"></a><span class="lineno">12903</span>&#160;It may be undesirable for elements to be ignored when the outcome of the omission is uncertain.</div><div class="line"><a name="l12904"></a><span class="lineno">12904</span>&#160;The `soap.fignore` callback can be set to a function that returns `SOAP_OK` in case the element can be safely ignored, or</div><div class="line"><a name="l12905"></a><span class="lineno">12905</span>&#160;`SOAP_MUSTUNDERSTAND` to throw an exception, or to perform some application-specific action.</div><div class="line"><a name="l12906"></a><span class="lineno">12906</span>&#160;For example, to throw an exception as soon as an unknown element is encountered on the input, use:</div><div class="line"><a name="l12907"></a><span class="lineno">12907</span>&#160;</div><div class="line"><a name="l12908"></a><span class="lineno">12908</span>&#160;```cpp</div><div class="line"><a name="l12909"></a><span class="lineno">12909</span>&#160;int myignore(struct soap *soap, const char *tag) </div><div class="line"><a name="l12910"></a><span class="lineno">12910</span>&#160;{ </div><div class="line"><a name="l12911"></a><span class="lineno">12911</span>&#160;   return SOAP_MUSTUNDERSTAND; // never skip elements (secure) </div><div class="line"><a name="l12912"></a><span class="lineno">12912</span>&#160;} </div><div class="line"><a name="l12913"></a><span class="lineno">12913</span>&#160;... </div><div class="line"><a name="l12914"></a><span class="lineno">12914</span>&#160;soap.fignore = myignore; </div><div class="line"><a name="l12915"></a><span class="lineno">12915</span>&#160;soap_call_ns__method(&amp;soap, ...); // or soap_serve(&amp;soap);</div><div class="line"><a name="l12916"></a><span class="lineno">12916</span>&#160;```</div><div class="line"><a name="l12917"></a><span class="lineno">12917</span>&#160;</div><div class="line"><a name="l12918"></a><span class="lineno">12918</span>&#160;To selectively throw an exception when *`mustUnderstand=&quot;true&quot;`* SOAP Header element is encountered or when an unknown element is encountered except for element *`ns:xyz`*, use:</div><div class="line"><a name="l12919"></a><span class="lineno">12919</span>&#160;</div><div class="line"><a name="l12920"></a><span class="lineno">12920</span>&#160;```cpp</div><div class="line"><a name="l12921"></a><span class="lineno">12921</span>&#160;int myignore(struct soap *soap, const char *tag) </div><div class="line"><a name="l12922"></a><span class="lineno">12922</span>&#160;{ </div><div class="line"><a name="l12923"></a><span class="lineno">12923</span>&#160;   if (soap-&gt;mustUnderstand) </div><div class="line"><a name="l12924"></a><span class="lineno">12924</span>&#160;     return SOAP_MUSTUNDERSTAND; // do not ignore mustUnderstand=&quot;true&quot; </div><div class="line"><a name="l12925"></a><span class="lineno">12925</span>&#160;   if (soap_match_tag(soap, tag, &quot;ns:xyz&quot;) != SOAP_OK) </div><div class="line"><a name="l12926"></a><span class="lineno">12926</span>&#160;     return SOAP_MUSTUNDERSTAND; </div><div class="line"><a name="l12927"></a><span class="lineno">12927</span>&#160;   return SOAP_OK; </div><div class="line"><a name="l12928"></a><span class="lineno">12928</span>&#160;} </div><div class="line"><a name="l12929"></a><span class="lineno">12929</span>&#160;... </div><div class="line"><a name="l12930"></a><span class="lineno">12930</span>&#160;soap.fignore = myignore; </div><div class="line"><a name="l12931"></a><span class="lineno">12931</span>&#160;soap_call_ns__method(&amp;soap, ...); // or soap_serve(&amp;soap) </div><div class="line"><a name="l12932"></a><span class="lineno">12932</span>&#160;... </div><div class="line"><a name="l12933"></a><span class="lineno">12933</span>&#160;struct Namespace namespaces[] = </div><div class="line"><a name="l12934"></a><span class="lineno">12934</span>&#160;{ </div><div class="line"><a name="l12935"></a><span class="lineno">12935</span>&#160;   {&quot;SOAP-ENV&quot;, &quot;http://schemas.xmlsoap.org/soap/envelope/&quot;}, </div><div class="line"><a name="l12936"></a><span class="lineno">12936</span>&#160;   {&quot;SOAP-ENC&quot;,&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;}, </div><div class="line"><a name="l12937"></a><span class="lineno">12937</span>&#160;   {&quot;xsi&quot;, &quot;http://www.w3.org/2001/XMLSchema-instance&quot;}, </div><div class="line"><a name="l12938"></a><span class="lineno">12938</span>&#160;   {&quot;xsd&quot;, &quot;http://www.w3.org/2001/XMLSchema&quot;}, </div><div class="line"><a name="l12939"></a><span class="lineno">12939</span>&#160;   {&quot;ns&quot;, &quot;some-URI&quot;}, // the namespace of element ns:xyz </div><div class="line"><a name="l12940"></a><span class="lineno">12940</span>&#160;   {NULL, NULL} </div><div class="line"><a name="l12941"></a><span class="lineno">12941</span>&#160;```</div><div class="line"><a name="l12942"></a><span class="lineno">12942</span>&#160;</div><div class="line"><a name="l12943"></a><span class="lineno">12943</span>&#160;Function `soap_match_tag` compares two tags. The third parameter may be a pattern where `*` is a wildcard</div><div class="line"><a name="l12944"></a><span class="lineno">12944</span>&#160;and `-` is a single character wildcard. So for example</div><div class="line"><a name="l12945"></a><span class="lineno">12945</span>&#160;`soap_match_tag(tag, &quot;ns:*&quot;)` will match any element in namespace `ns` or when no namespace prefix is present in the XML</div><div class="line"><a name="l12946"></a><span class="lineno">12946</span>&#160;message.</div><div class="line"><a name="l12947"></a><span class="lineno">12947</span>&#160;</div><div class="line"><a name="l12948"></a><span class="lineno">12948</span>&#160;The callback can also be used to keep track of unknown elements in an internal data structure such as a list:</div><div class="line"><a name="l12949"></a><span class="lineno">12949</span>&#160;</div><div class="line"><a name="l12950"></a><span class="lineno">12950</span>&#160;```cpp</div><div class="line"><a name="l12951"></a><span class="lineno">12951</span>&#160;struct Unknown </div><div class="line"><a name="l12952"></a><span class="lineno">12952</span>&#160;{ </div><div class="line"><a name="l12953"></a><span class="lineno">12953</span>&#160;   char *tag; </div><div class="line"><a name="l12954"></a><span class="lineno">12954</span>&#160;   struct Unknown *next; </div><div class="line"><a name="l12955"></a><span class="lineno">12955</span>&#160;}; </div><div class="line"><a name="l12956"></a><span class="lineno">12956</span>&#160;int myignore(struct soap *soap, const char *tag) </div><div class="line"><a name="l12957"></a><span class="lineno">12957</span>&#160;{ </div><div class="line"><a name="l12958"></a><span class="lineno">12958</span>&#160;   char *s = (char*)soap_malloc(soap, strlen(tag)+1); </div><div class="line"><a name="l12959"></a><span class="lineno">12959</span>&#160;   struct Unknown *u = (struct Unknown*)soap_malloc(soap, sizeof(struct Unknown)); </div><div class="line"><a name="l12960"></a><span class="lineno">12960</span>&#160;   if (s &amp;&amp; u) </div><div class="line"><a name="l12961"></a><span class="lineno">12961</span>&#160;   { </div><div class="line"><a name="l12962"></a><span class="lineno">12962</span>&#160;     strcpy(s, tag); </div><div class="line"><a name="l12963"></a><span class="lineno">12963</span>&#160;     u-&gt;tag = s; </div><div class="line"><a name="l12964"></a><span class="lineno">12964</span>&#160;     u-&gt;next = ulist; </div><div class="line"><a name="l12965"></a><span class="lineno">12965</span>&#160;     ulist = u; </div><div class="line"><a name="l12966"></a><span class="lineno">12966</span>&#160;   } </div><div class="line"><a name="l12967"></a><span class="lineno">12967</span>&#160;} </div><div class="line"><a name="l12968"></a><span class="lineno">12968</span>&#160;... </div><div class="line"><a name="l12969"></a><span class="lineno">12969</span>&#160;struct soap *soap; </div><div class="line"><a name="l12970"></a><span class="lineno">12970</span>&#160;struct Unknown *ulist = NULL; </div><div class="line"><a name="l12971"></a><span class="lineno">12971</span>&#160;soap_init(&amp;soap); </div><div class="line"><a name="l12972"></a><span class="lineno">12972</span>&#160;soap.fignore = myignore; </div><div class="line"><a name="l12973"></a><span class="lineno">12973</span>&#160;soap_call_ns__method(&amp;soap, ...); // or soap_serve(&amp;soap) </div><div class="line"><a name="l12974"></a><span class="lineno">12974</span>&#160;// print the list of unknown elements </div><div class="line"><a name="l12975"></a><span class="lineno">12975</span>&#160;soap_end(&amp;soap); // clean up</div><div class="line"><a name="l12976"></a><span class="lineno">12976</span>&#160;```</div><div class="line"><a name="l12977"></a><span class="lineno">12977</span>&#160;</div><div class="line"><a name="l12978"></a><span class="lineno">12978</span>&#160;## HTTP 1.0 and 1.1</div><div class="line"><a name="l12979"></a><span class="lineno">12979</span>&#160;</div><div class="line"><a name="l12980"></a><span class="lineno">12980</span>&#160;gSOAP uses HTTP 1.1 by default. You can revert to HTTP 1.0 as follows:</div><div class="line"><a name="l12981"></a><span class="lineno">12981</span>&#160;</div><div class="line"><a name="l12982"></a><span class="lineno">12982</span>&#160;```cpp</div><div class="line"><a name="l12983"></a><span class="lineno">12983</span>&#160;struct soap soap; </div><div class="line"><a name="l12984"></a><span class="lineno">12984</span>&#160;soap_init(&amp;soap); </div><div class="line"><a name="l12985"></a><span class="lineno">12985</span>&#160;... </div><div class="line"><a name="l12986"></a><span class="lineno">12986</span>&#160;soap.http_version = &quot;1.0&quot;;</div><div class="line"><a name="l12987"></a><span class="lineno">12987</span>&#160;```</div><div class="line"><a name="l12988"></a><span class="lineno">12988</span>&#160;</div><div class="line"><a name="l12989"></a><span class="lineno">12989</span>&#160;This sets the HTTP version and reconfigures the engine to revert to HTTP 1.0.</div><div class="line"><a name="l12990"></a><span class="lineno">12990</span>&#160;Note that you cannot use HTTP chunking with HTTP 1.0.</div><div class="line"><a name="l12991"></a><span class="lineno">12991</span>&#160;</div><div class="line"><a name="l12992"></a><span class="lineno">12992</span>&#160;## HTTP 307 Temporary Redirect Support</div><div class="line"><a name="l12993"></a><span class="lineno">12993</span>&#160;</div><div class="line"><a name="l12994"></a><span class="lineno">12994</span>&#160;The client-side handling of HTTP 307 code &quot;Temporary Redirect&quot; and any of the redirect codes 301, 302, and 303 are not automated in gSOAP. Client application developers may want to consider adding a few lines of code to support redirects. It was decided not to automatically support redirects for the following reasons:</div><div class="line"><a name="l12995"></a><span class="lineno">12995</span>&#160;</div><div class="line"><a name="l12996"></a><span class="lineno">12996</span>&#160;</div><div class="line"><a name="l12997"></a><span class="lineno">12997</span>&#160;*  Redirecting a secure HTTPS address to a non-secure HTTP address via 307 creates a security vulnerability.</div><div class="line"><a name="l12998"></a><span class="lineno">12998</span>&#160;</div><div class="line"><a name="l12999"></a><span class="lineno">12999</span>&#160;*  Cyclic redirects must be detected (e.g. allowing only a limited number of redirect levels).</div><div class="line"><a name="l13000"></a><span class="lineno">13000</span>&#160;</div><div class="line"><a name="l13001"></a><span class="lineno">13001</span>&#160;*  Redirecting HTTP POST will result in re-serialization and re-post of the entire SOAP request. The SOAP request message must be re-posted in its entirity when re-issuing the SOAP operation to a new address.</div><div class="line"><a name="l13002"></a><span class="lineno">13002</span>&#160;</div><div class="line"><a name="l13003"></a><span class="lineno">13003</span>&#160;To implement client-side 307 redirect, add the following lines of code:</div><div class="line"><a name="l13004"></a><span class="lineno">13004</span>&#160;</div><div class="line"><a name="l13005"></a><span class="lineno">13005</span>&#160;```cpp</div><div class="line"><a name="l13006"></a><span class="lineno">13006</span>&#160;char *endpoint = NULL; // use default endpoint given in WSDL (or add another one here) </div><div class="line"><a name="l13007"></a><span class="lineno">13007</span>&#160;int n = 10; // max redirect count </div><div class="line"><a name="l13008"></a><span class="lineno">13008</span>&#160;while (n--) </div><div class="line"><a name="l13009"></a><span class="lineno">13009</span>&#160;{ </div><div class="line"><a name="l13010"></a><span class="lineno">13010</span>&#160;   if (soap_call_ns1__myMethod(soap, endpoint, ...)) </div><div class="line"><a name="l13011"></a><span class="lineno">13011</span>&#160;   { </div><div class="line"><a name="l13012"></a><span class="lineno">13012</span>&#160;     if ((soap-&gt;error &gt;= 301 &amp;&amp; soap-&gt;error &lt;= 303) || soap-&gt;error == 307) </div><div class="line"><a name="l13013"></a><span class="lineno">13013</span>&#160;       endpoint = soap_strdup(soap, soap-&gt;endpoint); // endpoint from HTTP 301, 302, 303, 307 Location header </div><div class="line"><a name="l13014"></a><span class="lineno">13014</span>&#160;     else </div><div class="line"><a name="l13015"></a><span class="lineno">13015</span>&#160;       { ... report and handle error </div><div class="line"><a name="l13016"></a><span class="lineno">13016</span>&#160;         break; </div><div class="line"><a name="l13017"></a><span class="lineno">13017</span>&#160;       } </div><div class="line"><a name="l13018"></a><span class="lineno">13018</span>&#160;   } </div><div class="line"><a name="l13019"></a><span class="lineno">13019</span>&#160;   else </div><div class="line"><a name="l13020"></a><span class="lineno">13020</span>&#160;     break; </div><div class="line"><a name="l13021"></a><span class="lineno">13021</span>&#160;}</div><div class="line"><a name="l13022"></a><span class="lineno">13022</span>&#160;```</div><div class="line"><a name="l13023"></a><span class="lineno">13023</span>&#160;</div><div class="line"><a name="l13024"></a><span class="lineno">13024</span>&#160;## HTTP GET Support        {#get}</div><div class="line"><a name="l13025"></a><span class="lineno">13025</span>&#160;</div><div class="line"><a name="l13026"></a><span class="lineno">13026</span>&#160;To implement your own HTTP (HTTPS) GET request responses, you need to set the `soap.fget` callback. The callback is required to produce a response to the request in textual form, such as a Web page or a SOAP/XML response. This method does not work with CGI.</div><div class="line"><a name="l13027"></a><span class="lineno">13027</span>&#160;</div><div class="line"><a name="l13028"></a><span class="lineno">13028</span>&#160;The following example produces a Web page upon a HTTP GET request (e.g. from a browser):</div><div class="line"><a name="l13029"></a><span class="lineno">13029</span>&#160;</div><div class="line"><a name="l13030"></a><span class="lineno">13030</span>&#160;```cpp</div><div class="line"><a name="l13031"></a><span class="lineno">13031</span>&#160;struct soap *soap = soap_new(); </div><div class="line"><a name="l13032"></a><span class="lineno">13032</span>&#160;soap-&gt;fget = http_get; </div><div class="line"><a name="l13033"></a><span class="lineno">13033</span>&#160;... </div><div class="line"><a name="l13034"></a><span class="lineno">13034</span>&#160;soap_serve(soap); </div><div class="line"><a name="l13035"></a><span class="lineno">13035</span>&#160;... </div><div class="line"><a name="l13036"></a><span class="lineno">13036</span>&#160;int http_get(struct soap *soap) </div><div class="line"><a name="l13037"></a><span class="lineno">13037</span>&#160;{ </div><div class="line"><a name="l13038"></a><span class="lineno">13038</span>&#160;   soap_response(soap, SOAP_HTML); // HTTP response header with text/html </div><div class="line"><a name="l13039"></a><span class="lineno">13039</span>&#160;   soap_send(soap, &quot;&lt;HTML&gt;My Web server is operational.&lt;/HTML&gt;&quot;); </div><div class="line"><a name="l13040"></a><span class="lineno">13040</span>&#160;   soap_end_send(soap); </div><div class="line"><a name="l13041"></a><span class="lineno">13041</span>&#160;   return SOAP_OK; </div><div class="line"><a name="l13042"></a><span class="lineno">13042</span>&#160;}</div><div class="line"><a name="l13043"></a><span class="lineno">13043</span>&#160;```</div><div class="line"><a name="l13044"></a><span class="lineno">13044</span>&#160;</div><div class="line"><a name="l13045"></a><span class="lineno">13045</span>&#160;The example below produces a WSDL file upon a HTTP GET with path `?wsdl`:</div><div class="line"><a name="l13046"></a><span class="lineno">13046</span>&#160;</div><div class="line"><a name="l13047"></a><span class="lineno">13047</span>&#160;```cpp</div><div class="line"><a name="l13048"></a><span class="lineno">13048</span>&#160;int http_get(struct soap *soap) </div><div class="line"><a name="l13049"></a><span class="lineno">13049</span>&#160;{ </div><div class="line"><a name="l13050"></a><span class="lineno">13050</span>&#160;   FILE *fd = NULL;</div><div class="line"><a name="l13051"></a><span class="lineno">13051</span>&#160;   char *s = strchr(soap-&gt;path, &#39;?&#39;); </div><div class="line"><a name="l13052"></a><span class="lineno">13052</span>&#160;   if (!s || strcmp(s, &quot;?wsdl&quot;)) </div><div class="line"><a name="l13053"></a><span class="lineno">13053</span>&#160;     return SOAP_GET_METHOD; </div><div class="line"><a name="l13054"></a><span class="lineno">13054</span>&#160;   fd = fopen(&quot;myservice.wsdl&quot;, &quot;rb&quot;); // open WSDL file to copy </div><div class="line"><a name="l13055"></a><span class="lineno">13055</span>&#160;   if (!fd) </div><div class="line"><a name="l13056"></a><span class="lineno">13056</span>&#160;     return 404; // return HTTP not found error </div><div class="line"><a name="l13057"></a><span class="lineno">13057</span>&#160;   soap-&gt;http_content = &quot;text/xml&quot;; // HTTP header with text/xml content </div><div class="line"><a name="l13058"></a><span class="lineno">13058</span>&#160;   soap_response(soap, SOAP_FILE); </div><div class="line"><a name="l13059"></a><span class="lineno">13059</span>&#160;   for (;;) </div><div class="line"><a name="l13060"></a><span class="lineno">13060</span>&#160;   { </div><div class="line"><a name="l13061"></a><span class="lineno">13061</span>&#160;     size_t r = fread(soap-&gt;tmpbuf, 1, sizeof(soap-&gt;tmpbuf), fd); </div><div class="line"><a name="l13062"></a><span class="lineno">13062</span>&#160;     if (!r) </div><div class="line"><a name="l13063"></a><span class="lineno">13063</span>&#160;       break; </div><div class="line"><a name="l13064"></a><span class="lineno">13064</span>&#160;     if (soap_send_raw(soap, soap-&gt;tmpbuf, r)) </div><div class="line"><a name="l13065"></a><span class="lineno">13065</span>&#160;       break; // can&#39;t send, but little we can do about that </div><div class="line"><a name="l13066"></a><span class="lineno">13066</span>&#160;   } </div><div class="line"><a name="l13067"></a><span class="lineno">13067</span>&#160;   fclose(fd); </div><div class="line"><a name="l13068"></a><span class="lineno">13068</span>&#160;   soap_end_send(soap); </div><div class="line"><a name="l13069"></a><span class="lineno">13069</span>&#160;   return SOAP_OK; </div><div class="line"><a name="l13070"></a><span class="lineno">13070</span>&#160;}</div><div class="line"><a name="l13071"></a><span class="lineno">13071</span>&#160;```</div><div class="line"><a name="l13072"></a><span class="lineno">13072</span>&#160;</div><div class="line"><a name="l13073"></a><span class="lineno">13073</span>&#160;Using one-way SOAP/XML message, you can also return a SOAP/XML response:</div><div class="line"><a name="l13074"></a><span class="lineno">13074</span>&#160;</div><div class="line"><a name="l13075"></a><span class="lineno">13075</span>&#160;```cpp</div><div class="line"><a name="l13076"></a><span class="lineno">13076</span>&#160;int http_get(struct soap *soap) </div><div class="line"><a name="l13077"></a><span class="lineno">13077</span>&#160;{ </div><div class="line"><a name="l13078"></a><span class="lineno">13078</span>&#160;   if ((soap-&gt;omode &amp; SOAP_IO) != SOAP_IO_CHUNK) </div><div class="line"><a name="l13079"></a><span class="lineno">13079</span>&#160;     soap_set_omode(soap, SOAP_IO_STORE); // if not chunking we MUST buffer entire content to determine content length </div><div class="line"><a name="l13080"></a><span class="lineno">13080</span>&#160;   soap_response(soap, SOAP_OK); </div><div class="line"><a name="l13081"></a><span class="lineno">13081</span>&#160;   return soap_send_ns1__mySendMethodResponse(soap, &quot;&quot;, NULL, ... params ...); </div><div class="line"><a name="l13082"></a><span class="lineno">13082</span>&#160;} </div><div class="line"><a name="l13083"></a><span class="lineno">13083</span>&#160;```</div><div class="line"><a name="l13084"></a><span class="lineno">13084</span>&#160;</div><div class="line"><a name="l13085"></a><span class="lineno">13085</span>&#160;where `ns1__mySendMethodResponse` is a one-way message declared in a gSOAP header file as:</div><div class="line"><a name="l13086"></a><span class="lineno">13086</span>&#160;</div><div class="line"><a name="l13087"></a><span class="lineno">13087</span>&#160;```cpp</div><div class="line"><a name="l13088"></a><span class="lineno">13088</span>&#160;int ns1__mySendMethodResponse(... params ..., void);</div><div class="line"><a name="l13089"></a><span class="lineno">13089</span>&#160;```</div><div class="line"><a name="l13090"></a><span class="lineno">13090</span>&#160;</div><div class="line"><a name="l13091"></a><span class="lineno">13091</span>&#160;The generated `soapClient.cpp` includes the sending-side stub function.</div><div class="line"><a name="l13092"></a><span class="lineno">13092</span>&#160;</div><div class="line"><a name="l13093"></a><span class="lineno">13093</span>&#160;## TCP and HTTP Keep-Alive        {#keepalive}</div><div class="line"><a name="l13094"></a><span class="lineno">13094</span>&#160;</div><div class="line"><a name="l13095"></a><span class="lineno">13095</span>&#160;gSOAP supports keep-alive socket connections. To activate keep-alive support,</div><div class="line"><a name="l13096"></a><span class="lineno">13096</span>&#160;set the `SOAP_IO_KEEPALIVE` flag for both input and output modes, see Section \ref flags .</div><div class="line"><a name="l13097"></a><span class="lineno">13097</span>&#160;For example</div><div class="line"><a name="l13098"></a><span class="lineno">13098</span>&#160;</div><div class="line"><a name="l13099"></a><span class="lineno">13099</span>&#160;```cpp</div><div class="line"><a name="l13100"></a><span class="lineno">13100</span>&#160;struct soap soap; </div><div class="line"><a name="l13101"></a><span class="lineno">13101</span>&#160;soap_init2(&amp;soap, SOAP_IO_KEEPALIVE, SOAP_IO_KEEPALIVE); </div><div class="line"><a name="l13102"></a><span class="lineno">13102</span>&#160;```</div><div class="line"><a name="l13103"></a><span class="lineno">13103</span>&#160;</div><div class="line"><a name="l13104"></a><span class="lineno">13104</span>&#160;When a client or a service communicates with another client or service that supports keep alive, the</div><div class="line"><a name="l13105"></a><span class="lineno">13105</span>&#160;attribute `soap.keep_alive` will be set to 1, otherwise it is reset to 0 (indicating that the other party </div><div class="line"><a name="l13106"></a><span class="lineno">13106</span>&#160;will close the connection).</div><div class="line"><a name="l13107"></a><span class="lineno">13107</span>&#160;The connection maybe terminated on either end before the communication completed, for example when the server keep-alive</div><div class="line"><a name="l13108"></a><span class="lineno">13108</span>&#160;connection has timed out.</div><div class="line"><a name="l13109"></a><span class="lineno">13109</span>&#160;This generates a &quot;Broken Pipe&quot; signal on Unix/Linux platforms. This signal can be caught with a signal handler:</div><div class="line"><a name="l13110"></a><span class="lineno">13110</span>&#160;</div><div class="line"><a name="l13111"></a><span class="lineno">13111</span>&#160;```cpp</div><div class="line"><a name="l13112"></a><span class="lineno">13112</span>&#160;signal(SIGPIPE, sigpipe_handle);</div><div class="line"><a name="l13113"></a><span class="lineno">13113</span>&#160;```</div><div class="line"><a name="l13114"></a><span class="lineno">13114</span>&#160;</div><div class="line"><a name="l13115"></a><span class="lineno">13115</span>&#160;where, for example:</div><div class="line"><a name="l13116"></a><span class="lineno">13116</span>&#160;</div><div class="line"><a name="l13117"></a><span class="lineno">13117</span>&#160;```cpp</div><div class="line"><a name="l13118"></a><span class="lineno">13118</span>&#160;void sigpipe_handle(int x) { }</div><div class="line"><a name="l13119"></a><span class="lineno">13119</span>&#160;```</div><div class="line"><a name="l13120"></a><span class="lineno">13120</span>&#160;</div><div class="line"><a name="l13121"></a><span class="lineno">13121</span>&#160;Alternatively, broken pipes can be kept silent by setting:</div><div class="line"><a name="l13122"></a><span class="lineno">13122</span>&#160;</div><div class="line"><a name="l13123"></a><span class="lineno">13123</span>&#160;```cpp</div><div class="line"><a name="l13124"></a><span class="lineno">13124</span>&#160;soap.socket_flags = MSG_NOSIGNAL;</div><div class="line"><a name="l13125"></a><span class="lineno">13125</span>&#160;```</div><div class="line"><a name="l13126"></a><span class="lineno">13126</span>&#160;</div><div class="line"><a name="l13127"></a><span class="lineno">13127</span>&#160;This setting will not generate a sigpipe but read/write operations return `SOAP_EOF` instead.</div><div class="line"><a name="l13128"></a><span class="lineno">13128</span>&#160;Note that Win32 systems do not support signals and lack the `MSG_NOSIGNAL` flag.</div><div class="line"><a name="l13129"></a><span class="lineno">13129</span>&#160;The sigpipe handling and flags are not very portable.</div><div class="line"><a name="l13130"></a><span class="lineno">13130</span>&#160;</div><div class="line"><a name="l13131"></a><span class="lineno">13131</span>&#160;A connection will be kept open only if the request contains an HTTP 1.0 header</div><div class="line"><a name="l13132"></a><span class="lineno">13132</span>&#160;with &quot;*`Connection: Keep-Alive`*&quot; or an HTTP 1.1 header that does not contain</div><div class="line"><a name="l13133"></a><span class="lineno">13133</span>&#160;&quot;*`Connection: close`*&quot;. This means that a gSOAP client method call should</div><div class="line"><a name="l13134"></a><span class="lineno">13134</span>&#160;use &quot;*`http://`*&quot; in the endpoint URL of the request to the stand-alone</div><div class="line"><a name="l13135"></a><span class="lineno">13135</span>&#160;service to ensure HTTP headers are used.</div><div class="line"><a name="l13136"></a><span class="lineno">13136</span>&#160;</div><div class="line"><a name="l13137"></a><span class="lineno">13137</span>&#160;If the client does not close the connection, the server will wait forever when</div><div class="line"><a name="l13138"></a><span class="lineno">13138</span>&#160;no `recv_timeout` is specified.  In addition, other clients will be denied</div><div class="line"><a name="l13139"></a><span class="lineno">13139</span>&#160;service as long as a client keeps the connection to the server open.  To</div><div class="line"><a name="l13140"></a><span class="lineno">13140</span>&#160;prevent this from happening, the service should be multi-threaded such that</div><div class="line"><a name="l13141"></a><span class="lineno">13141</span>&#160;each thread handles the client connection:</div><div class="line"><a name="l13142"></a><span class="lineno">13142</span>&#160;</div><div class="line"><a name="l13143"></a><span class="lineno">13143</span>&#160;```cpp</div><div class="line"><a name="l13144"></a><span class="lineno">13144</span>&#160;int main(int argc, char **argv) </div><div class="line"><a name="l13145"></a><span class="lineno">13145</span>&#160;{ </div><div class="line"><a name="l13146"></a><span class="lineno">13146</span>&#160;   struct soap soap, *tsoap; </div><div class="line"><a name="l13147"></a><span class="lineno">13147</span>&#160;   pthread_t tid; </div><div class="line"><a name="l13148"></a><span class="lineno">13148</span>&#160;   int m, s; </div><div class="line"><a name="l13149"></a><span class="lineno">13149</span>&#160;   soap_init2(&amp;soap, SOAP_IO_KEEPALIVE, SOAP_IO_KEEPALIVE); </div><div class="line"><a name="l13150"></a><span class="lineno">13150</span>&#160;   soap.max_keep_alive = 100; // at most 100 calls per keep-alive session </div><div class="line"><a name="l13151"></a><span class="lineno">13151</span>&#160;   soap.accept_timeout = 600; // optional: let server time out after ten minutes of inactivity </div><div class="line"><a name="l13152"></a><span class="lineno">13152</span>&#160;   m = soap_bind(&amp;soap, NULL, 18000, BACKLOG); // use port 18000 on the current machine </div><div class="line"><a name="l13153"></a><span class="lineno">13153</span>&#160;   if (m &lt; 0) </div><div class="line"><a name="l13154"></a><span class="lineno">13154</span>&#160;   { </div><div class="line"><a name="l13155"></a><span class="lineno">13155</span>&#160;     soap_print_fault(&amp;soap, stderr); </div><div class="line"><a name="l13156"></a><span class="lineno">13156</span>&#160;     exit(1); </div><div class="line"><a name="l13157"></a><span class="lineno">13157</span>&#160;   } </div><div class="line"><a name="l13158"></a><span class="lineno">13158</span>&#160;   fprintf(stderr, &quot;Socket connection successful %d\n&quot;, m); </div><div class="line"><a name="l13159"></a><span class="lineno">13159</span>&#160;   for (count = 0; count &gt;= 0; count++) </div><div class="line"><a name="l13160"></a><span class="lineno">13160</span>&#160;   { </div><div class="line"><a name="l13161"></a><span class="lineno">13161</span>&#160;     soap.socket_flags = MSG_NOSIGNAL; // use this </div><div class="line"><a name="l13162"></a><span class="lineno">13162</span>&#160;     soap.accept_flags = SO_NOSIGPIPE; // or this to prevent sigpipe </div><div class="line"><a name="l13163"></a><span class="lineno">13163</span>&#160;     s = soap_accept(&amp;soap); </div><div class="line"><a name="l13164"></a><span class="lineno">13164</span>&#160;     if (s &lt; 0) </div><div class="line"><a name="l13165"></a><span class="lineno">13165</span>&#160;     { </div><div class="line"><a name="l13166"></a><span class="lineno">13166</span>&#160;       if (soap.errnum) </div><div class="line"><a name="l13167"></a><span class="lineno">13167</span>&#160;         soap_print_fault(&amp;soap, stderr); </div><div class="line"><a name="l13168"></a><span class="lineno">13168</span>&#160;       else </div><div class="line"><a name="l13169"></a><span class="lineno">13169</span>&#160;         fprintf(stderr, &quot;Server timed out\n&quot;); // Assume timeout is long enough for threads to complete serving requests </div><div class="line"><a name="l13170"></a><span class="lineno">13170</span>&#160;       break; </div><div class="line"><a name="l13171"></a><span class="lineno">13171</span>&#160;     } </div><div class="line"><a name="l13172"></a><span class="lineno">13172</span>&#160;     fprintf(stderr, &quot;Accepts socket %d connection from IP %d.%d.%d.%d\n&quot;, s, (int)(soap.ip&gt;&gt;24)&amp;0xFF, (int)(soap.ip&gt;&gt;16)&amp;0xFF, (int)(soap.ip&gt;&gt;8)&amp;0xFF, (int)soap.ip&amp;0xFF); </div><div class="line"><a name="l13173"></a><span class="lineno">13173</span>&#160;     tsoap = soap_copy(&amp;soap); </div><div class="line"><a name="l13174"></a><span class="lineno">13174</span>&#160;     pthread_create(&amp;tid, NULL, (void*(*)(void*))process_request, (void*)tsoap); </div><div class="line"><a name="l13175"></a><span class="lineno">13175</span>&#160;   } </div><div class="line"><a name="l13176"></a><span class="lineno">13176</span>&#160;   return 0; </div><div class="line"><a name="l13177"></a><span class="lineno">13177</span>&#160;} </div><div class="line"><a name="l13178"></a><span class="lineno">13178</span>&#160;void *process_request(void *soap) </div><div class="line"><a name="l13179"></a><span class="lineno">13179</span>&#160;{ </div><div class="line"><a name="l13180"></a><span class="lineno">13180</span>&#160;   pthread_detach(pthread_self()); </div><div class="line"><a name="l13181"></a><span class="lineno">13181</span>&#160;   ((struct soap*)soap)-&gt;recv_timeout = 60; // Timeout after 1 minute stall on recv </div><div class="line"><a name="l13182"></a><span class="lineno">13182</span>&#160;   ((struct soap*)soap)-&gt;send_timeout = 10; // Timeout after 10 second stall on send </div><div class="line"><a name="l13183"></a><span class="lineno">13183</span>&#160;   soap_serve((struct soap*)soap); </div><div class="line"><a name="l13184"></a><span class="lineno">13184</span>&#160;   soap_destroy((struct soap*)soap); </div><div class="line"><a name="l13185"></a><span class="lineno">13185</span>&#160;   soap_end((struct soap*)soap); </div><div class="line"><a name="l13186"></a><span class="lineno">13186</span>&#160;   soap_free((struct soap*)soap); </div><div class="line"><a name="l13187"></a><span class="lineno">13187</span>&#160;   return NULL; </div><div class="line"><a name="l13188"></a><span class="lineno">13188</span>&#160;}</div><div class="line"><a name="l13189"></a><span class="lineno">13189</span>&#160;```</div><div class="line"><a name="l13190"></a><span class="lineno">13190</span>&#160;</div><div class="line"><a name="l13191"></a><span class="lineno">13191</span>&#160;To prevent a malicious client from keeping a thread waiting forever by keeping</div><div class="line"><a name="l13192"></a><span class="lineno">13192</span>&#160;the connection open, timeouts are set in the `process_request` routine as</div><div class="line"><a name="l13193"></a><span class="lineno">13193</span>&#160;shown.  See Section \ref timeout  for more details on timeout settings.</div><div class="line"><a name="l13194"></a><span class="lineno">13194</span>&#160;</div><div class="line"><a name="l13195"></a><span class="lineno">13195</span>&#160;A gSOAP client call will automatically attempt to re-establish a connection to</div><div class="line"><a name="l13196"></a><span class="lineno">13196</span>&#160;a server when the server has terminated the connection for any reason.  This</div><div class="line"><a name="l13197"></a><span class="lineno">13197</span>&#160;way, a sequence of calls can be made to the server while keeping the connection</div><div class="line"><a name="l13198"></a><span class="lineno">13198</span>&#160;open.  Client stubs will poll the server to check if the connection is still</div><div class="line"><a name="l13199"></a><span class="lineno">13199</span>&#160;open.  When the connection was terminated by the server, the client will</div><div class="line"><a name="l13200"></a><span class="lineno">13200</span>&#160;automatically reconnect.  </div><div class="line"><a name="l13201"></a><span class="lineno">13201</span>&#160;</div><div class="line"><a name="l13202"></a><span class="lineno">13202</span>&#160;A client should reset `SOAP_IO_KEEPALIVE` just before the last call to a</div><div class="line"><a name="l13203"></a><span class="lineno">13203</span>&#160;server to close the connection after this last call. This will close the socket</div><div class="line"><a name="l13204"></a><span class="lineno">13204</span>&#160;after the call and also informs the server to gracefully close the connection.</div><div class="line"><a name="l13205"></a><span class="lineno">13205</span>&#160;</div><div class="line"><a name="l13206"></a><span class="lineno">13206</span>&#160;The client-side can also set the TCP keep-alive socket properties, using the `soap.tcp_keep_alive` flag (set to 1 to enable), `soap.tcp_keep_idle` to set the TCP_KEEPIDLE value, `soap.tcp_keep_intvl` to set the TCP_KEEPINTVL value, and `soap.tcp_keep_cnt` to set the TCP_KEEPCNT value.</div><div class="line"><a name="l13207"></a><span class="lineno">13207</span>&#160;</div><div class="line"><a name="l13208"></a><span class="lineno">13208</span>&#160;If a client is in the middle of soap call that might take a long time and the</div><div class="line"><a name="l13209"></a><span class="lineno">13209</span>&#160;server goes away/down the caller does not get any feedback until the</div><div class="line"><a name="l13210"></a><span class="lineno">13210</span>&#160;`soap.recv_timeout` is reached. Enabling TCP keep alive on systems that</div><div class="line"><a name="l13211"></a><span class="lineno">13211</span>&#160;support it allows for a faster connection teardown detection for applications</div><div class="line"><a name="l13212"></a><span class="lineno">13212</span>&#160;that need it.</div><div class="line"><a name="l13213"></a><span class="lineno">13213</span>&#160;</div><div class="line"><a name="l13214"></a><span class="lineno">13214</span>&#160;## HTTP Chunked Transfer Encoding        {#chunked}</div><div class="line"><a name="l13215"></a><span class="lineno">13215</span>&#160;</div><div class="line"><a name="l13216"></a><span class="lineno">13216</span>&#160;gSOAP supports HTTP chunked transfer encoding. Un-chunking of inbound messages</div><div class="line"><a name="l13217"></a><span class="lineno">13217</span>&#160;takes place automatically. Outbound messages are never chunked, except when the</div><div class="line"><a name="l13218"></a><span class="lineno">13218</span>&#160;`SOAP_IO_CHUNK` flag is set for the output mode.  Most Web services,</div><div class="line"><a name="l13219"></a><span class="lineno">13219</span>&#160;however, will not accept chunked inbound messages.</div><div class="line"><a name="l13220"></a><span class="lineno">13220</span>&#160;</div><div class="line"><a name="l13221"></a><span class="lineno">13221</span>&#160;## HTTP Buffered Sends</div><div class="line"><a name="l13222"></a><span class="lineno">13222</span>&#160;</div><div class="line"><a name="l13223"></a><span class="lineno">13223</span>&#160;The entire outbound message can be stored to determine the HTTP content length</div><div class="line"><a name="l13224"></a><span class="lineno">13224</span>&#160;rather than the two-phase encoding used by gSOAP which requires a separate pass</div><div class="line"><a name="l13225"></a><span class="lineno">13225</span>&#160;over the data to determine the length of the outbound message.  Setting the</div><div class="line"><a name="l13226"></a><span class="lineno">13226</span>&#160;flag `SOAP_IO_STORE` for the output mode will buffer the entire message.</div><div class="line"><a name="l13227"></a><span class="lineno">13227</span>&#160;This can speed up the transmission of messages, depending on the content, but</div><div class="line"><a name="l13228"></a><span class="lineno">13228</span>&#160;may require significant storage space to hold the verbose XML message.</div><div class="line"><a name="l13229"></a><span class="lineno">13229</span>&#160;</div><div class="line"><a name="l13230"></a><span class="lineno">13230</span>&#160;Zlib compressed transfers require buffering. The `SOAP_IO_STORE` flag is</div><div class="line"><a name="l13231"></a><span class="lineno">13231</span>&#160;set when the `SOAP_ENC_ZLIB` flag is set to send compressed messages. The use of chunking</div><div class="line"><a name="l13232"></a><span class="lineno">13232</span>&#160;significantly reduces memory usage and may speed up the transmission of compressed SOAP/XML messages.</div><div class="line"><a name="l13233"></a><span class="lineno">13233</span>&#160;This is accomplished by setting the `SOAP_IO_CHUNK` flag with</div><div class="line"><a name="l13234"></a><span class="lineno">13234</span>&#160;`SOAP_ENC_ZLIB` for the output mode.</div><div class="line"><a name="l13235"></a><span class="lineno">13235</span>&#160;</div><div class="line"><a name="l13236"></a><span class="lineno">13236</span>&#160;## HTTP Authentication</div><div class="line"><a name="l13237"></a><span class="lineno">13237</span>&#160;</div><div class="line"><a name="l13238"></a><span class="lineno">13238</span>&#160;HTTP authentication (basic) is enabled at the client-side by setting the</div><div class="line"><a name="l13239"></a><span class="lineno">13239</span>&#160;`soap.userid` and `soap.passwd` strings to a username and password,</div><div class="line"><a name="l13240"></a><span class="lineno">13240</span>&#160;respectively.  A server may request user authentication</div><div class="line"><a name="l13241"></a><span class="lineno">13241</span>&#160;and denies access (HTTP 401 error) when the client tries to connect without HTTP authentication (or with the wrong authentication information).</div><div class="line"><a name="l13242"></a><span class="lineno">13242</span>&#160;</div><div class="line"><a name="l13243"></a><span class="lineno">13243</span>&#160;Here is an example client code fragment to set the HTTP authentication username and password:</div><div class="line"><a name="l13244"></a><span class="lineno">13244</span>&#160;</div><div class="line"><a name="l13245"></a><span class="lineno">13245</span>&#160;```cpp</div><div class="line"><a name="l13246"></a><span class="lineno">13246</span>&#160;struct soap soap; </div><div class="line"><a name="l13247"></a><span class="lineno">13247</span>&#160;soap_init(&amp;soap); </div><div class="line"><a name="l13248"></a><span class="lineno">13248</span>&#160;soap.userid = &quot;guest&quot;; </div><div class="line"><a name="l13249"></a><span class="lineno">13249</span>&#160;soap.passwd = &quot;visit&quot;; </div><div class="line"><a name="l13250"></a><span class="lineno">13250</span>&#160;...</div><div class="line"><a name="l13251"></a><span class="lineno">13251</span>&#160;```</div><div class="line"><a name="l13252"></a><span class="lineno">13252</span>&#160;</div><div class="line"><a name="l13253"></a><span class="lineno">13253</span>&#160;A client SOAP request will have the following HTTP header:</div><div class="line"><a name="l13254"></a><span class="lineno">13254</span>&#160;</div><div class="line"><a name="l13255"></a><span class="lineno">13255</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l13256"></a><span class="lineno">13256</span>&#160;```xml</div><div class="line"><a name="l13257"></a><span class="lineno">13257</span>&#160;POST /XXX HTTP/1.0 </div><div class="line"><a name="l13258"></a><span class="lineno">13258</span>&#160;Host: YYY </div><div class="line"><a name="l13259"></a><span class="lineno">13259</span>&#160;User-Agent: gSOAP/2.2 </div><div class="line"><a name="l13260"></a><span class="lineno">13260</span>&#160;Content-Type: text/xml; charset=utf-8 </div><div class="line"><a name="l13261"></a><span class="lineno">13261</span>&#160;Content-Length: nnn </div><div class="line"><a name="l13262"></a><span class="lineno">13262</span>&#160;Authorization: Basic Z3Vlc3Q6Z3Vlc3Q= </div><div class="line"><a name="l13263"></a><span class="lineno">13263</span>&#160;...</div><div class="line"><a name="l13264"></a><span class="lineno">13264</span>&#160;```</div><div class="line"><a name="l13265"></a><span class="lineno">13265</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l13266"></a><span class="lineno">13266</span>&#160;</div><div class="line"><a name="l13267"></a><span class="lineno">13267</span>&#160;A client MUST set the `soap.userid` and `soap.passwd` strings for each call that requires client authentication. The strings are reset after each successful or unsuccessful call.</div><div class="line"><a name="l13268"></a><span class="lineno">13268</span>&#160;</div><div class="line"><a name="l13269"></a><span class="lineno">13269</span>&#160;When present, the value of the `WWW-Authenticate` HTTP header with the authentication realm can be obtained from the `soap.authrealm` string. This is useful for clients to respond intelligently to authentication requests.</div><div class="line"><a name="l13270"></a><span class="lineno">13270</span>&#160;</div><div class="line"><a name="l13271"></a><span class="lineno">13271</span>&#160;A stand-alone gSOAP Web Service can enforce HTTP authentication upon clients, by checking the `soap.userid` and `soap.passwd` strings. These strings are set when a client request contains HTTP authentication headers. The strings SHOULD be checked in each service method (that requires authentication to execute).</div><div class="line"><a name="l13272"></a><span class="lineno">13272</span>&#160;</div><div class="line"><a name="l13273"></a><span class="lineno">13273</span>&#160;Here is an example service method implementation that enforced client authentication:</div><div class="line"><a name="l13274"></a><span class="lineno">13274</span>&#160;</div><div class="line"><a name="l13275"></a><span class="lineno">13275</span>&#160;```cpp</div><div class="line"><a name="l13276"></a><span class="lineno">13276</span>&#160;int ns__method(struct soap *soap, ...) </div><div class="line"><a name="l13277"></a><span class="lineno">13277</span>&#160;{ </div><div class="line"><a name="l13278"></a><span class="lineno">13278</span>&#160;   if (!soap-&gt;.userid || !soap-&gt;.passwd ||</div><div class="line"><a name="l13279"></a><span class="lineno">13279</span>&#160;strcmp(soap-&gt;.userid, &quot;guest&quot;) ||</div><div class="line"><a name="l13280"></a><span class="lineno">13280</span>&#160;strcmp(soap-&gt;.passwd, &quot;visit&quot;)) </div><div class="line"><a name="l13281"></a><span class="lineno">13281</span>&#160;     return 401; </div><div class="line"><a name="l13282"></a><span class="lineno">13282</span>&#160;... </div><div class="line"><a name="l13283"></a><span class="lineno">13283</span>&#160;}</div><div class="line"><a name="l13284"></a><span class="lineno">13284</span>&#160;```</div><div class="line"><a name="l13285"></a><span class="lineno">13285</span>&#160;</div><div class="line"><a name="l13286"></a><span class="lineno">13286</span>&#160;When the authentication fails, the service response with a SOAP Fault message and a HTTP error code &quot;401 Unauthorized&quot;.</div><div class="line"><a name="l13287"></a><span class="lineno">13287</span>&#160;The HTTP error codes are described in Section \ref errcodes .</div><div class="line"><a name="l13288"></a><span class="lineno">13288</span>&#160;</div><div class="line"><a name="l13289"></a><span class="lineno">13289</span>&#160;## HTTP NTLM Authentication</div><div class="line"><a name="l13290"></a><span class="lineno">13290</span>&#160;</div><div class="line"><a name="l13291"></a><span class="lineno">13291</span>&#160;HTTP NTLM authentication is enabled at the client-side by installing</div><div class="line"><a name="l13292"></a><span class="lineno">13292</span>&#160;`libntlm` from &lt;http://www.nongnu.org/libntlm&gt; and compiling all</div><div class="line"><a name="l13293"></a><span class="lineno">13293</span>&#160;project source codes with `-DWITH_NTLM`.</div><div class="line"><a name="l13294"></a><span class="lineno">13294</span>&#160;</div><div class="line"><a name="l13295"></a><span class="lineno">13295</span>&#160;In your application code set the `soap.userid`, `soap.passwd`, and</div><div class="line"><a name="l13296"></a><span class="lineno">13296</span>&#160;`soap.authrealm` strings to a username, password,</div><div class="line"><a name="l13297"></a><span class="lineno">13297</span>&#160;and the authentication domain respectively. A server may request NTLM</div><div class="line"><a name="l13298"></a><span class="lineno">13298</span>&#160;authentication and denies access (HTTP 401 authentication required or HTTP 407 HTTP proxy authentication required) when the client tries to</div><div class="line"><a name="l13299"></a><span class="lineno">13299</span>&#160;connect without HTTP authentication (or with the wrong authentication</div><div class="line"><a name="l13300"></a><span class="lineno">13300</span>&#160;information).</div><div class="line"><a name="l13301"></a><span class="lineno">13301</span>&#160;</div><div class="line"><a name="l13302"></a><span class="lineno">13302</span>&#160;Here is an example client code fragment to set the NTLM authentication username and password:</div><div class="line"><a name="l13303"></a><span class="lineno">13303</span>&#160;</div><div class="line"><a name="l13304"></a><span class="lineno">13304</span>&#160;```cpp</div><div class="line"><a name="l13305"></a><span class="lineno">13305</span>&#160;struct soap soap; </div><div class="line"><a name="l13306"></a><span class="lineno">13306</span>&#160;soap_init1(&amp;soap, SOAP_IO_KEEPALIVE); </div><div class="line"><a name="l13307"></a><span class="lineno">13307</span>&#160;if (soap_call_ns__method(&amp;soap, ...)) </div><div class="line"><a name="l13308"></a><span class="lineno">13308</span>&#160;{ if (soap.error == 401) </div><div class="line"><a name="l13309"></a><span class="lineno">13309</span>&#160;  { soap.userid = &quot;Zaphod&quot;; </div><div class="line"><a name="l13310"></a><span class="lineno">13310</span>&#160;     soap.passwd = &quot;Beeblebrox&quot;; </div><div class="line"><a name="l13311"></a><span class="lineno">13311</span>&#160;     soap.authrealm = &quot;Ursa-Minor&quot;; </div><div class="line"><a name="l13312"></a><span class="lineno">13312</span>&#160;     if (soap_call_ns__method(&amp;soap, ...)) </div><div class="line"><a name="l13313"></a><span class="lineno">13313</span>&#160;        ...</div><div class="line"><a name="l13314"></a><span class="lineno">13314</span>&#160;```</div><div class="line"><a name="l13315"></a><span class="lineno">13315</span>&#160;</div><div class="line"><a name="l13316"></a><span class="lineno">13316</span>&#160;The following NTLM handshake between the client C and server S is performed:</div><div class="line"><a name="l13317"></a><span class="lineno">13317</span>&#160;</div><div class="line"><a name="l13318"></a><span class="lineno">13318</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l13319"></a><span class="lineno">13319</span>&#160;```xml</div><div class="line"><a name="l13320"></a><span class="lineno">13320</span>&#160;1: C  --&gt; S &amp; POST ... </div><div class="line"><a name="l13321"></a><span class="lineno">13321</span>&#160;            &amp; Content-Type: text/xml; charset=utf-8 </div><div class="line"><a name="l13322"></a><span class="lineno">13322</span>&#160;     </div><div class="line"><a name="l13323"></a><span class="lineno">13323</span>&#160;2: C &lt;--  S &amp; 401 Unauthorized </div><div class="line"><a name="l13324"></a><span class="lineno">13324</span>&#160;            &amp; WWW-Authenticate: NTLM </div><div class="line"><a name="l13325"></a><span class="lineno">13325</span>&#160;     </div><div class="line"><a name="l13326"></a><span class="lineno">13326</span>&#160;3: C  --&gt; S &amp; GET ... </div><div class="line"><a name="l13327"></a><span class="lineno">13327</span>&#160;            &amp; Authorization: NTLM &lt;base64-encoded type-1-message&gt; </div><div class="line"><a name="l13328"></a><span class="lineno">13328</span>&#160;     </div><div class="line"><a name="l13329"></a><span class="lineno">13329</span>&#160;4: C &lt;--  S &amp; 401 Unauthorized </div><div class="line"><a name="l13330"></a><span class="lineno">13330</span>&#160;            &amp; WWW-Authenticate: NTLM &lt;base64-encoded type-2-message&gt; </div><div class="line"><a name="l13331"></a><span class="lineno">13331</span>&#160;     </div><div class="line"><a name="l13332"></a><span class="lineno">13332</span>&#160;5: C  --&gt; S &amp; POST ... </div><div class="line"><a name="l13333"></a><span class="lineno">13333</span>&#160;            &amp; Content-Type: text/xml; charset=utf-8 </div><div class="line"><a name="l13334"></a><span class="lineno">13334</span>&#160;            &amp; Authorization: NTLM &lt;base64-encoded type-3-message&gt; </div><div class="line"><a name="l13335"></a><span class="lineno">13335</span>&#160;     </div><div class="line"><a name="l13336"></a><span class="lineno">13336</span>&#160;6: C &lt;--  S &amp; 200 OK</div><div class="line"><a name="l13337"></a><span class="lineno">13337</span>&#160;```</div><div class="line"><a name="l13338"></a><span class="lineno">13338</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l13339"></a><span class="lineno">13339</span>&#160;</div><div class="line"><a name="l13340"></a><span class="lineno">13340</span>&#160;where stages 1 and 2 indicates a client attempting to connect without</div><div class="line"><a name="l13341"></a><span class="lineno">13341</span>&#160;authorization information, which is the first method call in the code above. Stage 3 to 6 happen with the proper client</div><div class="line"><a name="l13342"></a><span class="lineno">13342</span>&#160;authentication set with `soap.userid`, `soap.passwd`, and</div><div class="line"><a name="l13343"></a><span class="lineno">13343</span>&#160;`soap.authrealm` provided. NTLM authenticates connections, not requests. When the connection is kept alive, subsequent messages can be exchanged without re-authentication.</div><div class="line"><a name="l13344"></a><span class="lineno">13344</span>&#160;</div><div class="line"><a name="l13345"></a><span class="lineno">13345</span>&#160;To avoid the overhead of the first rejected call, use:</div><div class="line"><a name="l13346"></a><span class="lineno">13346</span>&#160;</div><div class="line"><a name="l13347"></a><span class="lineno">13347</span>&#160;```cpp</div><div class="line"><a name="l13348"></a><span class="lineno">13348</span>&#160;struct soap soap; </div><div class="line"><a name="l13349"></a><span class="lineno">13349</span>&#160;soap_init1(&amp;soap, SOAP_IO_KEEPALIVE); </div><div class="line"><a name="l13350"></a><span class="lineno">13350</span>&#160;soap.userid = &quot;Zaphod&quot;; </div><div class="line"><a name="l13351"></a><span class="lineno">13351</span>&#160;soap.passwd = &quot;Beeblebrox&quot;; </div><div class="line"><a name="l13352"></a><span class="lineno">13352</span>&#160;soap.authrealm = &quot;Ursa-Minor&quot;; </div><div class="line"><a name="l13353"></a><span class="lineno">13353</span>&#160;soap.ntlm_challenge = &quot;&quot;; </div><div class="line"><a name="l13354"></a><span class="lineno">13354</span>&#160;if (soap_call_ns__method(&amp;soap, ...)) </div><div class="line"><a name="l13355"></a><span class="lineno">13355</span>&#160;   ...</div><div class="line"><a name="l13356"></a><span class="lineno">13356</span>&#160;```</div><div class="line"><a name="l13357"></a><span class="lineno">13357</span>&#160;</div><div class="line"><a name="l13358"></a><span class="lineno">13358</span>&#160;When the authentication fails (stage 1 and 2), the service response with a SOAP</div><div class="line"><a name="l13359"></a><span class="lineno">13359</span>&#160;Fault message and a HTTP error code &quot;401 Unauthorized&quot;. The HTTP error codes</div><div class="line"><a name="l13360"></a><span class="lineno">13360</span>&#160;are described in Section \ref errcodes .</div><div class="line"><a name="l13361"></a><span class="lineno">13361</span>&#160;</div><div class="line"><a name="l13362"></a><span class="lineno">13362</span>&#160;On windows, an alternative is to use the WinInet module, which has built-in</div><div class="line"><a name="l13363"></a><span class="lineno">13363</span>&#160;NTLM support. The WinInet for gSOAP module is available in the `mod_gsoap`</div><div class="line"><a name="l13364"></a><span class="lineno">13364</span>&#160;directory of the gSOAP package. Instructions for WinInet use are included there.</div><div class="line"><a name="l13365"></a><span class="lineno">13365</span>&#160;</div><div class="line"><a name="l13366"></a><span class="lineno">13366</span>&#160;## HTTP Proxy NTLM Authentication</div><div class="line"><a name="l13367"></a><span class="lineno">13367</span>&#160;</div><div class="line"><a name="l13368"></a><span class="lineno">13368</span>&#160;For HTTP 407 Proxy Authentication Required, set the proxy userid and passwd:</div><div class="line"><a name="l13369"></a><span class="lineno">13369</span>&#160;</div><div class="line"><a name="l13370"></a><span class="lineno">13370</span>&#160;```cpp</div><div class="line"><a name="l13371"></a><span class="lineno">13371</span>&#160;struct soap soap; </div><div class="line"><a name="l13372"></a><span class="lineno">13372</span>&#160;soap_init1(&amp;soap, SOAP_IO_KEEPALIVE); </div><div class="line"><a name="l13373"></a><span class="lineno">13373</span>&#160;soap.proxy_host = &quot;...&quot;; </div><div class="line"><a name="l13374"></a><span class="lineno">13374</span>&#160;soap.proxy_port = ...; </div><div class="line"><a name="l13375"></a><span class="lineno">13375</span>&#160;if (soap_call_ns__method(&amp;soap, ...)) </div><div class="line"><a name="l13376"></a><span class="lineno">13376</span>&#160;{ if (soap.error == 407) </div><div class="line"><a name="l13377"></a><span class="lineno">13377</span>&#160;  { soap.proxy_userid = &quot;Zaphod&quot;; </div><div class="line"><a name="l13378"></a><span class="lineno">13378</span>&#160;     soap.proxy_passwd = &quot;Beeblebrox&quot;; </div><div class="line"><a name="l13379"></a><span class="lineno">13379</span>&#160;     soap.authrealm = &quot;Ursa-Minor&quot;; </div><div class="line"><a name="l13380"></a><span class="lineno">13380</span>&#160;     if (soap_call_ns__method(&amp;soap, ...)) </div><div class="line"><a name="l13381"></a><span class="lineno">13381</span>&#160;       ...</div><div class="line"><a name="l13382"></a><span class="lineno">13382</span>&#160;```</div><div class="line"><a name="l13383"></a><span class="lineno">13383</span>&#160;</div><div class="line"><a name="l13384"></a><span class="lineno">13384</span>&#160;To avoid the overhead of the first rejected call, use:</div><div class="line"><a name="l13385"></a><span class="lineno">13385</span>&#160;</div><div class="line"><a name="l13386"></a><span class="lineno">13386</span>&#160;```cpp</div><div class="line"><a name="l13387"></a><span class="lineno">13387</span>&#160;struct soap soap; </div><div class="line"><a name="l13388"></a><span class="lineno">13388</span>&#160;soap_init1(&amp;soap, SOAP_IO_KEEPALIVE); </div><div class="line"><a name="l13389"></a><span class="lineno">13389</span>&#160;soap.proxy_host = &quot;...&quot;; </div><div class="line"><a name="l13390"></a><span class="lineno">13390</span>&#160;soap.proxy_port = ...; </div><div class="line"><a name="l13391"></a><span class="lineno">13391</span>&#160;soap.proxy_userid = &quot;Zaphod&quot;; </div><div class="line"><a name="l13392"></a><span class="lineno">13392</span>&#160;soap.proxy_passwd = &quot;Beeblebrox&quot;; </div><div class="line"><a name="l13393"></a><span class="lineno">13393</span>&#160;soap.authrealm = &quot;Ursa-Minor&quot;; </div><div class="line"><a name="l13394"></a><span class="lineno">13394</span>&#160;soap.ntlm_challenge = &quot;&quot;; </div><div class="line"><a name="l13395"></a><span class="lineno">13395</span>&#160;if (soap_call_ns__method(&amp;soap, ...)) </div><div class="line"><a name="l13396"></a><span class="lineno">13396</span>&#160;   ...</div><div class="line"><a name="l13397"></a><span class="lineno">13397</span>&#160;```</div><div class="line"><a name="l13398"></a><span class="lineno">13398</span>&#160;</div><div class="line"><a name="l13399"></a><span class="lineno">13399</span>&#160;## HTTP Proxy Basic Authentication</div><div class="line"><a name="l13400"></a><span class="lineno">13400</span>&#160;</div><div class="line"><a name="l13401"></a><span class="lineno">13401</span>&#160;HTTP proxy authentication (basic) is enabled at the client-side by setting the</div><div class="line"><a name="l13402"></a><span class="lineno">13402</span>&#160;`soap.proxy_userid` and `soap.proxy_passwd` strings to a username and</div><div class="line"><a name="l13403"></a><span class="lineno">13403</span>&#160;password, respectively.  For example, a proxy server may request user</div><div class="line"><a name="l13404"></a><span class="lineno">13404</span>&#160;authentication. Otherwise, access is denied by the proxy (HTTP 407 error).</div><div class="line"><a name="l13405"></a><span class="lineno">13405</span>&#160;Example client code fragment to set proxy server, username, and password:</div><div class="line"><a name="l13406"></a><span class="lineno">13406</span>&#160;</div><div class="line"><a name="l13407"></a><span class="lineno">13407</span>&#160;```cpp</div><div class="line"><a name="l13408"></a><span class="lineno">13408</span>&#160;struct soap soap; </div><div class="line"><a name="l13409"></a><span class="lineno">13409</span>&#160;soap_init(&amp;soap); </div><div class="line"><a name="l13410"></a><span class="lineno">13410</span>&#160;soap.proxy_host = &quot;xx.xx.xx.xx&quot;; // IP or domain </div><div class="line"><a name="l13411"></a><span class="lineno">13411</span>&#160;soap.proxy_port = 8080; </div><div class="line"><a name="l13412"></a><span class="lineno">13412</span>&#160;soap.proxy_userid = &quot;guest&quot;; </div><div class="line"><a name="l13413"></a><span class="lineno">13413</span>&#160;soap.proxy_passwd = &quot;guest&quot;; </div><div class="line"><a name="l13414"></a><span class="lineno">13414</span>&#160;...</div><div class="line"><a name="l13415"></a><span class="lineno">13415</span>&#160;```</div><div class="line"><a name="l13416"></a><span class="lineno">13416</span>&#160;</div><div class="line"><a name="l13417"></a><span class="lineno">13417</span>&#160;A client SOAP request will have the following HTTP header:</div><div class="line"><a name="l13418"></a><span class="lineno">13418</span>&#160;</div><div class="line"><a name="l13419"></a><span class="lineno">13419</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l13420"></a><span class="lineno">13420</span>&#160;```xml</div><div class="line"><a name="l13421"></a><span class="lineno">13421</span>&#160;POST /XXX HTTP/1.0 </div><div class="line"><a name="l13422"></a><span class="lineno">13422</span>&#160;Host: YYY </div><div class="line"><a name="l13423"></a><span class="lineno">13423</span>&#160;User-Agent: gSOAP/2.2 </div><div class="line"><a name="l13424"></a><span class="lineno">13424</span>&#160;Content-Type: text/xml; charset=utf-8 </div><div class="line"><a name="l13425"></a><span class="lineno">13425</span>&#160;Content-Length: nnn </div><div class="line"><a name="l13426"></a><span class="lineno">13426</span>&#160;Proxy-Authorization: Basic Z3Vlc3Q6Z3Vlc3Q= </div><div class="line"><a name="l13427"></a><span class="lineno">13427</span>&#160;...</div><div class="line"><a name="l13428"></a><span class="lineno">13428</span>&#160;```</div><div class="line"><a name="l13429"></a><span class="lineno">13429</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l13430"></a><span class="lineno">13430</span>&#160;</div><div class="line"><a name="l13431"></a><span class="lineno">13431</span>&#160;When X-Forwarded-For headers are returned by the proxy, the header can be accessed in the `soap.proxy_from` string.</div><div class="line"><a name="l13432"></a><span class="lineno">13432</span>&#160;</div><div class="line"><a name="l13433"></a><span class="lineno">13433</span>&#160;The CONNECT method is used for HTTP proxy authentication:</div><div class="line"><a name="l13434"></a><span class="lineno">13434</span>&#160;</div><div class="line"><a name="l13435"></a><span class="lineno">13435</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l13436"></a><span class="lineno">13436</span>&#160;```xml</div><div class="line"><a name="l13437"></a><span class="lineno">13437</span>&#160;CONNECT server.example.com:80 HTTP/1.1</div><div class="line"><a name="l13438"></a><span class="lineno">13438</span>&#160;```</div><div class="line"><a name="l13439"></a><span class="lineno">13439</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l13440"></a><span class="lineno">13440</span>&#160;</div><div class="line"><a name="l13441"></a><span class="lineno">13441</span>&#160;In some cases, it may be necessary to use the Host HTTP header with the CONNECT</div><div class="line"><a name="l13442"></a><span class="lineno">13442</span>&#160;protocol:</div><div class="line"><a name="l13443"></a><span class="lineno">13443</span>&#160;</div><div class="line"><a name="l13444"></a><span class="lineno">13444</span>&#160;&lt;div class=&quot;alt&quot;&gt;</div><div class="line"><a name="l13445"></a><span class="lineno">13445</span>&#160;```xml</div><div class="line"><a name="l13446"></a><span class="lineno">13446</span>&#160;CONNECT server.example.com:80 HTTP/1.1 </div><div class="line"><a name="l13447"></a><span class="lineno">13447</span>&#160;Host: server.example.com:80</div><div class="line"><a name="l13448"></a><span class="lineno">13448</span>&#160;```</div><div class="line"><a name="l13449"></a><span class="lineno">13449</span>&#160;&lt;/div&gt;</div><div class="line"><a name="l13450"></a><span class="lineno">13450</span>&#160;</div><div class="line"><a name="l13451"></a><span class="lineno">13451</span>&#160;If so, compile the gSOAP code with `-DWITH_CONNECT_HOST` to include the</div><div class="line"><a name="l13452"></a><span class="lineno">13452</span>&#160;Host HTTP header with the CONNECT protocol.</div><div class="line"><a name="l13453"></a><span class="lineno">13453</span>&#160;</div><div class="line"><a name="l13454"></a><span class="lineno">13454</span>&#160;## Messaging Speed and Performance Improvement Tips</div><div class="line"><a name="l13455"></a><span class="lineno">13455</span>&#160;</div><div class="line"><a name="l13456"></a><span class="lineno">13456</span>&#160;Here are some tips you can use to speed up gSOAP. gSOAP&#39;s default settings are choosen to maximize portability and compatibility. The settings can be tweaked to optimize the performance as follows:</div><div class="line"><a name="l13457"></a><span class="lineno">13457</span>&#160;</div><div class="line"><a name="l13458"></a><span class="lineno">13458</span>&#160;</div><div class="line"><a name="l13459"></a><span class="lineno">13459</span>&#160;*  Increase the buffer size `SOAP_BUFLEN` by changing the `SOAP_BUFLEN` macro in `stdsoap2.h`. Use buffer size 2^18=262144 for example.</div><div class="line"><a name="l13460"></a><span class="lineno">13460</span>&#160;</div><div class="line"><a name="l13461"></a><span class="lineno">13461</span>&#160;*  Use HTTP keep-alive at the client-side, see \ref keepalive , when the client needs to make a series of calls to the same server. Server-side keep-alive support can greatly improve performance of both client and server. But be aware that clients and services under Unix/Linux require signal handlers to catch dropped connections.</div><div class="line"><a name="l13462"></a><span class="lineno">13462</span>&#160;</div><div class="line"><a name="l13463"></a><span class="lineno">13463</span>&#160;*  Use HTTP chunked transfers, see \ref chunked .</div><div class="line"><a name="l13464"></a><span class="lineno">13464</span>&#160;</div><div class="line"><a name="l13465"></a><span class="lineno">13465</span>&#160;*  Do NOT use gzip compression, since the overhead of compression is typically higher than the bandwidth gains.</div><div class="line"><a name="l13466"></a><span class="lineno">13466</span>&#160;</div><div class="line"><a name="l13467"></a><span class="lineno">13467</span>&#160;*  Set the `SOAP_XML_TREE` flag to disable id-ref multi-ref object (de)serialization. This boosts performance significantly and works with SOAP document/literal style (i.e. no id-ref graph serialization as required with SOAP encoding style).</div><div class="line"><a name="l13468"></a><span class="lineno">13468</span>&#160;</div><div class="line"><a name="l13469"></a><span class="lineno">13469</span>&#160;*  Compile `stdsoap2.c` and `stdsoap2.cpp` and all other source codes with `-DWITH_NOIDREF` to improve performance even better by permanently disabling id-ref multi-ref object (de)serialization.</div><div class="line"><a name="l13470"></a><span class="lineno">13470</span>&#160;</div><div class="line"><a name="l13471"></a><span class="lineno">13471</span>&#160;*  Do NOT use DEBUG mode, since the overhead of logging is significant.</div><div class="line"><a name="l13472"></a><span class="lineno">13472</span>&#160;</div><div class="line"><a name="l13473"></a><span class="lineno">13473</span>&#160;</div><div class="line"><a name="l13474"></a><span class="lineno">13474</span>&#160;## XML Parsing Options to set Safety Guards        {#safety}</div><div class="line"><a name="l13475"></a><span class="lineno">13475</span>&#160;</div><div class="line"><a name="l13476"></a><span class="lineno">13476</span>&#160;The XML parser is configured to restrict the XML nesting depth level to `SOAP_MAXLEVEL` and restricts the repeated occurrence of elements that are deserialized into arrays and containers by `SOAP_MAXOCCURS`. These macros can be changed, but you can also change the following context attributes at runtime, e.g. to enhance the safety for specific service and/or client operations:</div><div class="line"><a name="l13477"></a><span class="lineno">13477</span>&#160;</div><div class="line"><a name="l13478"></a><span class="lineno">13478</span>&#160;</div><div class="line"><a name="l13479"></a><span class="lineno">13479</span>&#160;</div><div class="line"><a name="l13480"></a><span class="lineno">13480</span>&#160;*  `soap.maxlevel` is an `unsigned int` to restrict the XML nesting depth level, where the default value is `SOAP_MAXLEVEL=10000`.</div><div class="line"><a name="l13481"></a><span class="lineno">13481</span>&#160;</div><div class="line"><a name="l13482"></a><span class="lineno">13482</span>&#160;*  `soap.maxoccurs` is a `size_t` to restrict the number of repeated occurrences of elements that are deserialized into arrays and structs, where the default value is `SOAP_MAXOCCURS=100000`.</div><div class="line"><a name="l13483"></a><span class="lineno">13483</span>&#160;</div><div class="line"><a name="l13484"></a><span class="lineno">13484</span>&#160;*  `soap.maxlength` is a positive `long` length that restricts the length of strings deserialized from XML.  A zero or negative value is unrestricted length. When restricted, the XML schema validation maxLength takes precedence over this length restriction. So setting a smaller value will not interfere with the XML validation rules. The default value is `SOAP_MAXLENGTH=0`. Note that string length is expressed in number of characters, not bytes. So UTF-8 encodings are not truncated.</div><div class="line"><a name="l13485"></a><span class="lineno">13485</span>&#160;</div><div class="line"><a name="l13486"></a><span class="lineno">13486</span>&#160;XML schema validation constraints are enforced with the `SOAP_XML_STRICT` context flag. The schema maxLength validation constraint overrules the `soap.maxlength` guard. The schema maxOccurs validation constraint DOES NOT overrule the `soap.maxoccurs` guard, so arrays and containers are always restricted in length by this guard.</div><div class="line"><a name="l13487"></a><span class="lineno">13487</span>&#160;</div><div class="line"><a name="l13488"></a><span class="lineno">13488</span>&#160;## Timeout Management for Non-Blocking Operations        {#timeout}</div><div class="line"><a name="l13489"></a><span class="lineno">13489</span>&#160;</div><div class="line"><a name="l13490"></a><span class="lineno">13490</span>&#160;Socket connect, accept, send, and receive timeout values can be set to manage</div><div class="line"><a name="l13491"></a><span class="lineno">13491</span>&#160;socket communication timeouts.  The `soap.connect_timeout`,</div><div class="line"><a name="l13492"></a><span class="lineno">13492</span>&#160;`soap.accept_timeout`, `soap.send_timeout`,</div><div class="line"><a name="l13493"></a><span class="lineno">13493</span>&#160;`soap.recv_timeout` and `soap.transfer_timeout` context attributes of</div><div class="line"><a name="l13494"></a><span class="lineno">13494</span>&#160;the current gSOAP runtime context `soap` can be set to the appropriate</div><div class="line"><a name="l13495"></a><span class="lineno">13495</span>&#160;user-defined socket send, receive, and accept timeout values. A positive value</div><div class="line"><a name="l13496"></a><span class="lineno">13496</span>&#160;measures the timeout in seconds. A negative timeout value measures the timeout</div><div class="line"><a name="l13497"></a><span class="lineno">13497</span>&#160;in microseconds (10^-6 sec).</div><div class="line"><a name="l13498"></a><span class="lineno">13498</span>&#160;</div><div class="line"><a name="l13499"></a><span class="lineno">13499</span>&#160;The `soap.connect_timeout` specifies the timeout for</div><div class="line"><a name="l13500"></a><span class="lineno">13500</span>&#160;`soap_call_ns__method` calls.</div><div class="line"><a name="l13501"></a><span class="lineno">13501</span>&#160;</div><div class="line"><a name="l13502"></a><span class="lineno">13502</span>&#160;The `soap.accept_timeout` specifies the timeout for</div><div class="line"><a name="l13503"></a><span class="lineno">13503</span>&#160;`soap_accept(&amp;soap)` calls.</div><div class="line"><a name="l13504"></a><span class="lineno">13504</span>&#160;</div><div class="line"><a name="l13505"></a><span class="lineno">13505</span>&#160;The `soap.send_timeout` and `soap.recv_timeout` specify the timeout</div><div class="line"><a name="l13506"></a><span class="lineno">13506</span>&#160;for non-blocking socket I/O operations.  This is the maximum delay on the socket operation permitted.</div><div class="line"><a name="l13507"></a><span class="lineno">13507</span>&#160;</div><div class="line"><a name="l13508"></a><span class="lineno">13508</span>&#160;The `soap.transfer_timeout` is new since 2.8.48 and limits the time a message send and a message receive operation can take.  This value should be used in combination with `soap.send_timeout` and `soap.recv_timeout` for accurate timeout control.</div><div class="line"><a name="l13509"></a><span class="lineno">13509</span>&#160;</div><div class="line"><a name="l13510"></a><span class="lineno">13510</span>&#160;Example:</div><div class="line"><a name="l13511"></a><span class="lineno">13511</span>&#160;</div><div class="line"><a name="l13512"></a><span class="lineno">13512</span>&#160;```cpp</div><div class="line"><a name="l13513"></a><span class="lineno">13513</span>&#160;struct soap soap; </div><div class="line"><a name="l13514"></a><span class="lineno">13514</span>&#160;soap_init(&amp;soap); </div><div class="line"><a name="l13515"></a><span class="lineno">13515</span>&#160;soap.send_timeout = 10; </div><div class="line"><a name="l13516"></a><span class="lineno">13516</span>&#160;soap.recv_timeout = 10; </div><div class="line"><a name="l13517"></a><span class="lineno">13517</span>&#160;soap.recv_timeout = 60; </div><div class="line"><a name="l13518"></a><span class="lineno">13518</span>&#160;```</div><div class="line"><a name="l13519"></a><span class="lineno">13519</span>&#160;</div><div class="line"><a name="l13520"></a><span class="lineno">13520</span>&#160;This will result in a timeout if no data can be send in 10 seconds and no data is received within 10 seconds after initiating</div><div class="line"><a name="l13521"></a><span class="lineno">13521</span>&#160;a send or receive operation over the socket. A value of zero disables timeout, for example:</div><div class="line"><a name="l13522"></a><span class="lineno">13522</span>&#160;</div><div class="line"><a name="l13523"></a><span class="lineno">13523</span>&#160;```cpp</div><div class="line"><a name="l13524"></a><span class="lineno">13524</span>&#160;soap.send_timeout = 0; </div><div class="line"><a name="l13525"></a><span class="lineno">13525</span>&#160;soap.recv_timeout = 0;  </div><div class="line"><a name="l13526"></a><span class="lineno">13526</span>&#160;soap.recv_timeout = 0; </div><div class="line"><a name="l13527"></a><span class="lineno">13527</span>&#160;```</div><div class="line"><a name="l13528"></a><span class="lineno">13528</span>&#160;</div><div class="line"><a name="l13529"></a><span class="lineno">13529</span>&#160;When a timeout occurs in the send or receive operations, a `SOAP_EOF` exception will be raised (&quot;end of file or no input&quot;).</div><div class="line"><a name="l13530"></a><span class="lineno">13530</span>&#160;Negative timeout values measure timeouts in microseconds, for example:</div><div class="line"><a name="l13531"></a><span class="lineno">13531</span>&#160;</div><div class="line"><a name="l13532"></a><span class="lineno">13532</span>&#160;```cpp</div><div class="line"><a name="l13533"></a><span class="lineno">13533</span>&#160;#define uSec *-1 </div><div class="line"><a name="l13534"></a><span class="lineno">13534</span>&#160;#define mSec *-1000 </div><div class="line"><a name="l13535"></a><span class="lineno">13535</span>&#160;soap.accept_timeout = 10 uSec; </div><div class="line"><a name="l13536"></a><span class="lineno">13536</span>&#160;soap.send_timeout = 20 mSec; </div><div class="line"><a name="l13537"></a><span class="lineno">13537</span>&#160;soap.recv_timeout = 20 mSec; </div><div class="line"><a name="l13538"></a><span class="lineno">13538</span>&#160;soap.recv_timeout = 10;</div><div class="line"><a name="l13539"></a><span class="lineno">13539</span>&#160;```</div><div class="line"><a name="l13540"></a><span class="lineno">13540</span>&#160;</div><div class="line"><a name="l13541"></a><span class="lineno">13541</span>&#160;The macros improve readability.</div><div class="line"><a name="l13542"></a><span class="lineno">13542</span>&#160;</div><div class="line"><a name="l13543"></a><span class="lineno">13543</span>&#160;@warning many Linux versions do not support non-blocking `connect()`.</div><div class="line"><a name="l13544"></a><span class="lineno">13544</span>&#160;Therefore, setting `soap.connect_timeout` for non-blocking</div><div class="line"><a name="l13545"></a><span class="lineno">13545</span>&#160;`soap_call_ns__method` calls may not work under Linux.</div><div class="line"><a name="l13546"></a><span class="lineno">13546</span>&#160;</div><div class="line"><a name="l13547"></a><span class="lineno">13547</span>&#160;@warning interrupts (EINTR) can affect the blocking time in I/O operations.</div><div class="line"><a name="l13548"></a><span class="lineno">13548</span>&#160;The maximum number of EINTR that will not trigger an error is set by</div><div class="line"><a name="l13549"></a><span class="lineno">13549</span>&#160;`SOAP_MAXEINTR` in `stdsoap2.h`, which is 10 by default. Each EINTR</div><div class="line"><a name="l13550"></a><span class="lineno">13550</span>&#160;may increase the blocking time by up to one second, up to `SOAP_MAXEINTR`</div><div class="line"><a name="l13551"></a><span class="lineno">13551</span>&#160;seconds total.</div><div class="line"><a name="l13552"></a><span class="lineno">13552</span>&#160;</div><div class="line"><a name="l13553"></a><span class="lineno">13553</span>&#160;## Socket Options and Flags</div><div class="line"><a name="l13554"></a><span class="lineno">13554</span>&#160;</div><div class="line"><a name="l13555"></a><span class="lineno">13555</span>&#160;gSOAP&#39;s socket communications can be controlled with socket options and flags.</div><div class="line"><a name="l13556"></a><span class="lineno">13556</span>&#160;The gSOAP run-time context `struct soap` flags are:</div><div class="line"><a name="l13557"></a><span class="lineno">13557</span>&#160;`int soap.socket_flags` to control socket send() and recv() calls,</div><div class="line"><a name="l13558"></a><span class="lineno">13558</span>&#160;`int soap.connect_flags` to set client connection socket options,</div><div class="line"><a name="l13559"></a><span class="lineno">13559</span>&#160;`int soap.bind_flags` to set server-side port bind socket options,</div><div class="line"><a name="l13560"></a><span class="lineno">13560</span>&#160;`int soap.accept_flags` to set server-side request message accept</div><div class="line"><a name="l13561"></a><span class="lineno">13561</span>&#160;socket options. See the manual pages of `send` and `recv` for</div><div class="line"><a name="l13562"></a><span class="lineno">13562</span>&#160;`soap.socket_flags` values and see the manual pages of</div><div class="line"><a name="l13563"></a><span class="lineno">13563</span>&#160;`setsockopt` for</div><div class="line"><a name="l13564"></a><span class="lineno">13564</span>&#160;`soap.connect_flags`, `soap.bind_flags`, and</div><div class="line"><a name="l13565"></a><span class="lineno">13565</span>&#160;`soap.accept_flags` (SOL_SOCKET) values.</div><div class="line"><a name="l13566"></a><span class="lineno">13566</span>&#160;These `SO_` socket option flags (see `setsockopt` manual pages)</div><div class="line"><a name="l13567"></a><span class="lineno">13567</span>&#160;can be bit-wise or-ed to set multiple</div><div class="line"><a name="l13568"></a><span class="lineno">13568</span>&#160;socket options at once.</div><div class="line"><a name="l13569"></a><span class="lineno">13569</span>&#160;The client-side flag `soap.connect_flags=SO_LINGER` is supported with values `l_onoff=1` and `l_linger=soap.linger_time`. The `soap.linger_time` determines the wait time (the time resolution is system dependent, though according to some experts only zero and nonzero values matter). The linger option can be used to manage the number of connections that remain in TIME_WAIT state at the server side.</div><div class="line"><a name="l13570"></a><span class="lineno">13570</span>&#160;</div><div class="line"><a name="l13571"></a><span class="lineno">13571</span>&#160;For example, to disable sigpipe signals on Unix/Linux platforms use: </div><div class="line"><a name="l13572"></a><span class="lineno">13572</span>&#160;`soap.socket_flags = MSG_NOSIGNAL` and/or</div><div class="line"><a name="l13573"></a><span class="lineno">13573</span>&#160;`soap.connect_flags = SO_NOSIGPIPE` (i.e. client-side connect) depending</div><div class="line"><a name="l13574"></a><span class="lineno">13574</span>&#160;on your platform.</div><div class="line"><a name="l13575"></a><span class="lineno">13575</span>&#160;</div><div class="line"><a name="l13576"></a><span class="lineno">13576</span>&#160;Use `soap.bind_flags=SO_REUSEADDR` to enable server-side port reuse and local port</div><div class="line"><a name="l13577"></a><span class="lineno">13577</span>&#160;sharing (but be aware of the possible security implications such as port hijacking).</div><div class="line"><a name="l13578"></a><span class="lineno">13578</span>&#160;</div><div class="line"><a name="l13579"></a><span class="lineno">13579</span>&#160;Note that multiple socket options can be explicitly set with `setsockopt` as follows:</div><div class="line"><a name="l13580"></a><span class="lineno">13580</span>&#160;</div><div class="line"><a name="l13581"></a><span class="lineno">13581</span>&#160;```cpp</div><div class="line"><a name="l13582"></a><span class="lineno">13582</span>&#160;int sock = soap_bind(soap, host, port, backlog); </div><div class="line"><a name="l13583"></a><span class="lineno">13583</span>&#160;if (soap_valid_socket(sock)) </div><div class="line"><a name="l13584"></a><span class="lineno">13584</span>&#160;{ </div><div class="line"><a name="l13585"></a><span class="lineno">13585</span>&#160;   setsockopt(sock, ..., ..., ..., ...);</div><div class="line"><a name="l13586"></a><span class="lineno">13586</span>&#160;   setsockopt(sock, ..., ..., ..., ...);</div><div class="line"><a name="l13587"></a><span class="lineno">13587</span>&#160;```</div><div class="line"><a name="l13588"></a><span class="lineno">13588</span>&#160;</div><div class="line"><a name="l13589"></a><span class="lineno">13589</span>&#160;## Overriding the Host and Port to Connect</div><div class="line"><a name="l13590"></a><span class="lineno">13590</span>&#160;</div><div class="line"><a name="l13591"></a><span class="lineno">13591</span>&#160;To override the host and port of the client connecting to a server, set `soap.override_host` and `soap.override_port`:</div><div class="line"><a name="l13592"></a><span class="lineno">13592</span>&#160;</div><div class="line"><a name="l13593"></a><span class="lineno">13593</span>&#160;```cpp</div><div class="line"><a name="l13594"></a><span class="lineno">13594</span>&#160;soap.override_host = &quot;example.com&quot;; // host name or IP address </div><div class="line"><a name="l13595"></a><span class="lineno">13595</span>&#160;soap.override_port = 80; // port number to use when overriding the address</div><div class="line"><a name="l13596"></a><span class="lineno">13596</span>&#160;```</div><div class="line"><a name="l13597"></a><span class="lineno">13597</span>&#160;</div><div class="line"><a name="l13598"></a><span class="lineno">13598</span>&#160;## Secure Web Services with HTTPS/SSL~        {#serveropenssl}</div><div class="line"><a name="l13599"></a><span class="lineno">13599</span>&#160;</div><div class="line"><a name="l13600"></a><span class="lineno">13600</span>&#160;When a Web Service is installed as CGI, it uses standard I/O that is encrypted/decrypted by the Web server that runs the CGI</div><div class="line"><a name="l13601"></a><span class="lineno">13601</span>&#160;application.</div><div class="line"><a name="l13602"></a><span class="lineno">13602</span>&#160;HTTPS/SSL support must be configured for the Web server (not CGI-based Web Service application itself).</div><div class="line"><a name="l13603"></a><span class="lineno">13603</span>&#160;</div><div class="line"><a name="l13604"></a><span class="lineno">13604</span>&#160;To enable SSL for stand-alone gSOAP servers, first install OpenSSL and use option `-DWITH_OPENSSL` to compile the sources with your C or C++ compiler (or use `-DWITH_GNUTLS` if you prefer GNUTLS), for example:</div><div class="line"><a name="l13605"></a><span class="lineno">13605</span>&#160;</div><div class="line"><a name="l13606"></a><span class="lineno">13606</span>&#160;    &gt; c++ -DWITH_OPENSSL -o myprog myprog.cpp stdsoap2.cpp soapC.cpp soapServer.cpp -lssl -lcrypto</div><div class="line"><a name="l13607"></a><span class="lineno">13607</span>&#160;</div><div class="line"><a name="l13608"></a><span class="lineno">13608</span>&#160;With GNUTLS:</div><div class="line"><a name="l13609"></a><span class="lineno">13609</span>&#160;</div><div class="line"><a name="l13610"></a><span class="lineno">13610</span>&#160;    &gt; c++ -DWITH_GNUTLS -o myprog myprog.cpp stdsoap2.cpp soapC.cpp soapServer.cpp -lgnutls -lgcrypt -lgpg-error</div><div class="line"><a name="l13611"></a><span class="lineno">13611</span>&#160;</div><div class="line"><a name="l13612"></a><span class="lineno">13612</span>&#160;SSL support for stand-alone gSOAP Web services is enabled by calling `soap_ssl_accept` to perform the SSL/TLS handshake after `soap_accept`.</div><div class="line"><a name="l13613"></a><span class="lineno">13613</span>&#160;In addition, a key file, a CA file (or path to certificates), DH file (if RSA is not used), and password need to be supplied. Instructions on how to do this can be found in the</div><div class="line"><a name="l13614"></a><span class="lineno">13614</span>&#160;OpenSSL documentation `http://www.openssl.org`. See also Section \ref ssl .</div><div class="line"><a name="l13615"></a><span class="lineno">13615</span>&#160;</div><div class="line"><a name="l13616"></a><span class="lineno">13616</span>&#160;Let&#39;s take a look at an example SSL secure</div><div class="line"><a name="l13617"></a><span class="lineno">13617</span>&#160;multi-threaded stand-alone SOAP Web Service:</div><div class="line"><a name="l13618"></a><span class="lineno">13618</span>&#160;</div><div class="line"><a name="l13619"></a><span class="lineno">13619</span>&#160;```cpp</div><div class="line"><a name="l13620"></a><span class="lineno">13620</span>&#160;int main() </div><div class="line"><a name="l13621"></a><span class="lineno">13621</span>&#160;{ </div><div class="line"><a name="l13622"></a><span class="lineno">13622</span>&#160;   int m, s; </div><div class="line"><a name="l13623"></a><span class="lineno">13623</span>&#160;   pthread_t tid; </div><div class="line"><a name="l13624"></a><span class="lineno">13624</span>&#160;   struct soap soap, *tsoap; </div><div class="line"><a name="l13625"></a><span class="lineno">13625</span>&#160;   soap_ssl_init(); /* init OpenSSL (skipping this or calling multiple times is OK, since the engine will init SSL automatically) */</div><div class="line"><a name="l13626"></a><span class="lineno">13626</span>&#160;   // soap_ssl_noinit(); /* do not init OpenSSL (if SSL is already initialized elsewhere) */</div><div class="line"><a name="l13627"></a><span class="lineno">13627</span>&#160;   if (CRYPTO_thread_setup()) // OpenSSL </div><div class="line"><a name="l13628"></a><span class="lineno">13628</span>&#160;   { </div><div class="line"><a name="l13629"></a><span class="lineno">13629</span>&#160;     fprintf(stderr, &quot;Cannot setup thread mutex\n&quot;); </div><div class="line"><a name="l13630"></a><span class="lineno">13630</span>&#160;     exit(1); </div><div class="line"><a name="l13631"></a><span class="lineno">13631</span>&#160;   } </div><div class="line"><a name="l13632"></a><span class="lineno">13632</span>&#160;   soap_init(&amp;soap); </div><div class="line"><a name="l13633"></a><span class="lineno">13633</span>&#160;   if (soap_ssl_server_context(&amp;soap, </div><div class="line"><a name="l13634"></a><span class="lineno">13634</span>&#160;     SOAP_SSL_DEFAULT, </div><div class="line"><a name="l13635"></a><span class="lineno">13635</span>&#160;     &quot;server.pem&quot;,      /* keyfile: required when server must authenticate to clients (see SSL docs on how to obtain this file) */ </div><div class="line"><a name="l13636"></a><span class="lineno">13636</span>&#160;     &quot;password&quot;,        /* password to read the key file (not used with GNUTLS) */ </div><div class="line"><a name="l13637"></a><span class="lineno">13637</span>&#160;     &quot;cacert.pem&quot;,      /* optional cacert file to store trusted certificates */ </div><div class="line"><a name="l13638"></a><span class="lineno">13638</span>&#160;     NULL,              /* optional capath to directory with trusted certificates */ </div><div class="line"><a name="l13639"></a><span class="lineno">13639</span>&#160;     &quot;dh512.pem&quot;,       /* DH file name or DH key len bits (minimum is 512, e.g. &quot;512&quot;) to generate DH param, if NULL use RSA */ </div><div class="line"><a name="l13640"></a><span class="lineno">13640</span>&#160;     NULL,              /* if randfile!=NULL: use a file with random data to seed randomness */  </div><div class="line"><a name="l13641"></a><span class="lineno">13641</span>&#160;     NULL               /* optional server identification to enable SSL session cache (must be a unique name) */</div><div class="line"><a name="l13642"></a><span class="lineno">13642</span>&#160;   )) </div><div class="line"><a name="l13643"></a><span class="lineno">13643</span>&#160;   { </div><div class="line"><a name="l13644"></a><span class="lineno">13644</span>&#160;     soap_print_fault(&amp;soap, stderr); </div><div class="line"><a name="l13645"></a><span class="lineno">13645</span>&#160;     exit(1); </div><div class="line"><a name="l13646"></a><span class="lineno">13646</span>&#160;   } </div><div class="line"><a name="l13647"></a><span class="lineno">13647</span>&#160;   m = soap_bind(&amp;soap, NULL, 18000, 100); // use port 18000 </div><div class="line"><a name="l13648"></a><span class="lineno">13648</span>&#160;   if (m &lt; 0) </div><div class="line"><a name="l13649"></a><span class="lineno">13649</span>&#160;   { </div><div class="line"><a name="l13650"></a><span class="lineno">13650</span>&#160;     soap_print_fault(&amp;soap, stderr); </div><div class="line"><a name="l13651"></a><span class="lineno">13651</span>&#160;     exit(1); </div><div class="line"><a name="l13652"></a><span class="lineno">13652</span>&#160;   } </div><div class="line"><a name="l13653"></a><span class="lineno">13653</span>&#160;   fprintf(stderr, &quot;Socket connection successful: master socket = %d\n&quot;, m); </div><div class="line"><a name="l13654"></a><span class="lineno">13654</span>&#160;   for (;;) </div><div class="line"><a name="l13655"></a><span class="lineno">13655</span>&#160;   { </div><div class="line"><a name="l13656"></a><span class="lineno">13656</span>&#160;     s = soap_accept(&amp;soap); </div><div class="line"><a name="l13657"></a><span class="lineno">13657</span>&#160;     fprintf(stderr, &quot;Socket connection successful: slave socket = %d\n&quot;, s); </div><div class="line"><a name="l13658"></a><span class="lineno">13658</span>&#160;     if (s &lt; 0) </div><div class="line"><a name="l13659"></a><span class="lineno">13659</span>&#160;     { </div><div class="line"><a name="l13660"></a><span class="lineno">13660</span>&#160;       soap_print_fault(&amp;soap, stderr); </div><div class="line"><a name="l13661"></a><span class="lineno">13661</span>&#160;       break; </div><div class="line"><a name="l13662"></a><span class="lineno">13662</span>&#160;     } </div><div class="line"><a name="l13663"></a><span class="lineno">13663</span>&#160;     tsoap = soap_copy(&amp;soap); /* should call soap_ssl_accept on a copy */ </div><div class="line"><a name="l13664"></a><span class="lineno">13664</span>&#160;     if (!tsoap) </div><div class="line"><a name="l13665"></a><span class="lineno">13665</span>&#160;       break; </div><div class="line"><a name="l13666"></a><span class="lineno">13666</span>&#160;     pthread_create(&amp;tid, NULL, &amp;process_request, (void*)tsoap); </div><div class="line"><a name="l13667"></a><span class="lineno">13667</span>&#160;   } </div><div class="line"><a name="l13668"></a><span class="lineno">13668</span>&#160;   soap_done(&amp;soap); /* deallocates SSL context */</div><div class="line"><a name="l13669"></a><span class="lineno">13669</span>&#160;   CRYPTO_thread_cleanup(); // OpenSSL </div><div class="line"><a name="l13670"></a><span class="lineno">13670</span>&#160;   return 0; </div><div class="line"><a name="l13671"></a><span class="lineno">13671</span>&#160;}  </div><div class="line"><a name="l13672"></a><span class="lineno">13672</span>&#160;void *process_request(void *soap) </div><div class="line"><a name="l13673"></a><span class="lineno">13673</span>&#160;{ </div><div class="line"><a name="l13674"></a><span class="lineno">13674</span>&#160;   pthread_detach(pthread_self()); </div><div class="line"><a name="l13675"></a><span class="lineno">13675</span>&#160;   if (soap_ssl_accept((struct soap*)soap)) </div><div class="line"><a name="l13676"></a><span class="lineno">13676</span>&#160;     soap_print_fault(tsoap, stderr); </div><div class="line"><a name="l13677"></a><span class="lineno">13677</span>&#160;   else </div><div class="line"><a name="l13678"></a><span class="lineno">13678</span>&#160;     soap_serve((struct soap*)soap); </div><div class="line"><a name="l13679"></a><span class="lineno">13679</span>&#160;   soap_destroy((struct soap*)soap); </div><div class="line"><a name="l13680"></a><span class="lineno">13680</span>&#160;   soap_end((struct soap*)soap); </div><div class="line"><a name="l13681"></a><span class="lineno">13681</span>&#160;   soap_free((struct soap*)soap); // done and free context </div><div class="line"><a name="l13682"></a><span class="lineno">13682</span>&#160;   return NULL; </div><div class="line"><a name="l13683"></a><span class="lineno">13683</span>&#160;}</div><div class="line"><a name="l13684"></a><span class="lineno">13684</span>&#160;```</div><div class="line"><a name="l13685"></a><span class="lineno">13685</span>&#160;</div><div class="line"><a name="l13686"></a><span class="lineno">13686</span>&#160;The `soap_ssl_server_context` function initializes the server-side SSL context. The `server.pem` key file is the server&#39;s private key concatenated with its certificate. The `cacert.pem` is used to authenticate clients and contains the client certificates. Alternatively a directory name can be specified. This directory is assumed to contain the certificates. The `dh512.pem` file specifies that DH will be used for key agreement instead of RSA. A numeric value greater than 512 can be provided instead as a string constant (e.g. `&quot;512&quot;`) to allow the engine to generate the DH parameters on the fly (this can take a while) rather than retrieving them from a file. The randfile entry can be used to seed the PRNG. The last entry enable server-side session caching. A unique server name is required.</div><div class="line"><a name="l13687"></a><span class="lineno">13687</span>&#160;</div><div class="line"><a name="l13688"></a><span class="lineno">13688</span>&#160;The GNUTLS mutex lock setup is automatically peformed in the gSOAP engine, but only when POSIX threads are detected and available.</div><div class="line"><a name="l13689"></a><span class="lineno">13689</span>&#160;</div><div class="line"><a name="l13690"></a><span class="lineno">13690</span>&#160;OpenSSL requires mutex locks to be explicitly setup in your code for multithreaded applications, for which we need to call `CRYPTO_thread_setup()` and `CRYPTO_thread_cleanup()`. These routines can be found in `openssl/crypto/threads/th-lock.c` and are also used in the SSL example codes `samples/ssl`. These routines are required to setup locks for multi-threaded applications that use SSL.</div><div class="line"><a name="l13691"></a><span class="lineno">13691</span>&#160;</div><div class="line"><a name="l13692"></a><span class="lineno">13692</span>&#160;We give a Windows and POSIX threads implementation of these here:</div><div class="line"><a name="l13693"></a><span class="lineno">13693</span>&#160;</div><div class="line"><a name="l13694"></a><span class="lineno">13694</span>&#160;```cpp</div><div class="line"><a name="l13695"></a><span class="lineno">13695</span>&#160;#include &lt;unistd.h&gt;             /* defines _POSIX_THREADS if pthreads are available */ </div><div class="line"><a name="l13696"></a><span class="lineno">13696</span>&#160;#ifdef _POSIX_THREADS </div><div class="line"><a name="l13697"></a><span class="lineno">13697</span>&#160;# include &lt;pthread.h&gt; </div><div class="line"><a name="l13698"></a><span class="lineno">13698</span>&#160;#endif </div><div class="line"><a name="l13699"></a><span class="lineno">13699</span>&#160;#if defined(WIN32) </div><div class="line"><a name="l13700"></a><span class="lineno">13700</span>&#160;# define MUTEX_TYPE             HANDLE </div><div class="line"><a name="l13701"></a><span class="lineno">13701</span>&#160;# define MUTEX_SETUP(x)         (x) = CreateMutex(NULL, FALSE, NULL) </div><div class="line"><a name="l13702"></a><span class="lineno">13702</span>&#160;# define MUTEX_CLEANUP(x)       CloseHandle(x) </div><div class="line"><a name="l13703"></a><span class="lineno">13703</span>&#160;# define MUTEX_LOCK(x)          WaitForSingleObject((x), INFINITE) </div><div class="line"><a name="l13704"></a><span class="lineno">13704</span>&#160;# define MUTEX_UNLOCK(x)        ReleaseMutex(x) </div><div class="line"><a name="l13705"></a><span class="lineno">13705</span>&#160;# define THREAD_ID              GetCurrentThreadID() </div><div class="line"><a name="l13706"></a><span class="lineno">13706</span>&#160;#elif defined(_POSIX_THREADS) </div><div class="line"><a name="l13707"></a><span class="lineno">13707</span>&#160;# define MUTEX_TYPE             pthread_mutex_t </div><div class="line"><a name="l13708"></a><span class="lineno">13708</span>&#160;# define MUTEX_SETUP(x)         pthread_mutex_init(&amp;(x), NULL) </div><div class="line"><a name="l13709"></a><span class="lineno">13709</span>&#160;# define MUTEX_CLEANUP(x)       pthread_mutex_destroy(&amp;(x)) </div><div class="line"><a name="l13710"></a><span class="lineno">13710</span>&#160;# define MUTEX_LOCK(x)          pthread_mutex_lock(&amp;(x)) </div><div class="line"><a name="l13711"></a><span class="lineno">13711</span>&#160;# define MUTEX_UNLOCK(x)        pthread_mutex_unlock(&amp;(x)) </div><div class="line"><a name="l13712"></a><span class="lineno">13712</span>&#160;# define THREAD_ID              pthread_self() </div><div class="line"><a name="l13713"></a><span class="lineno">13713</span>&#160;#else </div><div class="line"><a name="l13714"></a><span class="lineno">13714</span>&#160;# error &quot;You must define mutex operations appropriate for your platform&quot; </div><div class="line"><a name="l13715"></a><span class="lineno">13715</span>&#160;# error &quot;See OpenSSL /threads/th-lock.c on how to implement mutex on your platform&quot; </div><div class="line"><a name="l13716"></a><span class="lineno">13716</span>&#160;#endif </div><div class="line"><a name="l13717"></a><span class="lineno">13717</span>&#160;struct CRYPTO_dynlock_value { MUTEX_TYPE mutex; }; </div><div class="line"><a name="l13718"></a><span class="lineno">13718</span>&#160;static MUTEX_TYPE *mutex_buf; </div><div class="line"><a name="l13719"></a><span class="lineno">13719</span>&#160;static struct CRYPTO_dynlock_value *dyn_create_function(const char *file, int line) </div><div class="line"><a name="l13720"></a><span class="lineno">13720</span>&#160;{ </div><div class="line"><a name="l13721"></a><span class="lineno">13721</span>&#160;   struct CRYPTO_dynlock_value *value; </div><div class="line"><a name="l13722"></a><span class="lineno">13722</span>&#160;   value = (struct CRYPTO_dynlock_value*)malloc(sizeof(struct CRYPTO_dynlock_value)); </div><div class="line"><a name="l13723"></a><span class="lineno">13723</span>&#160;   if (value) </div><div class="line"><a name="l13724"></a><span class="lineno">13724</span>&#160;     MUTEX_SETUP(value-&gt;mutex); </div><div class="line"><a name="l13725"></a><span class="lineno">13725</span>&#160;   return value; </div><div class="line"><a name="l13726"></a><span class="lineno">13726</span>&#160;} </div><div class="line"><a name="l13727"></a><span class="lineno">13727</span>&#160;static void dyn_lock_function(int mode, struct CRYPTO_dynlock_value *l, const char *file, int line) </div><div class="line"><a name="l13728"></a><span class="lineno">13728</span>&#160;{ </div><div class="line"><a name="l13729"></a><span class="lineno">13729</span>&#160;   if (mode &amp; CRYPTO_LOCK) </div><div class="line"><a name="l13730"></a><span class="lineno">13730</span>&#160;     MUTEX_LOCK(l-&gt;mutex); </div><div class="line"><a name="l13731"></a><span class="lineno">13731</span>&#160;   else </div><div class="line"><a name="l13732"></a><span class="lineno">13732</span>&#160;     MUTEX_UNLOCK(l-&gt;mutex); </div><div class="line"><a name="l13733"></a><span class="lineno">13733</span>&#160;} </div><div class="line"><a name="l13734"></a><span class="lineno">13734</span>&#160;static void dyn_destroy_function(struct CRYPTO_dynlock_value *l, const char *file, int line) </div><div class="line"><a name="l13735"></a><span class="lineno">13735</span>&#160;{ </div><div class="line"><a name="l13736"></a><span class="lineno">13736</span>&#160;   MUTEX_CLEANUP(l-&gt;mutex); </div><div class="line"><a name="l13737"></a><span class="lineno">13737</span>&#160;   free(l); </div><div class="line"><a name="l13738"></a><span class="lineno">13738</span>&#160;} </div><div class="line"><a name="l13739"></a><span class="lineno">13739</span>&#160;void locking_function(int mode, int n, const char *file, int line) </div><div class="line"><a name="l13740"></a><span class="lineno">13740</span>&#160;{ </div><div class="line"><a name="l13741"></a><span class="lineno">13741</span>&#160;   if (mode &amp; CRYPTO_LOCK) </div><div class="line"><a name="l13742"></a><span class="lineno">13742</span>&#160;     MUTEX_LOCK(mutex_buf[n]); </div><div class="line"><a name="l13743"></a><span class="lineno">13743</span>&#160;   else </div><div class="line"><a name="l13744"></a><span class="lineno">13744</span>&#160;     MUTEX_UNLOCK(mutex_buf[n]); </div><div class="line"><a name="l13745"></a><span class="lineno">13745</span>&#160;} </div><div class="line"><a name="l13746"></a><span class="lineno">13746</span>&#160;unsigned long id_function() </div><div class="line"><a name="l13747"></a><span class="lineno">13747</span>&#160;{ </div><div class="line"><a name="l13748"></a><span class="lineno">13748</span>&#160;   return (unsigned long)THREAD_ID; </div><div class="line"><a name="l13749"></a><span class="lineno">13749</span>&#160;} </div><div class="line"><a name="l13750"></a><span class="lineno">13750</span>&#160;int CRYPTO_thread_setup() </div><div class="line"><a name="l13751"></a><span class="lineno">13751</span>&#160;{ </div><div class="line"><a name="l13752"></a><span class="lineno">13752</span>&#160;   int i; </div><div class="line"><a name="l13753"></a><span class="lineno">13753</span>&#160;   mutex_buf = (MUTEX_TYPE*)malloc(CRYPTO_num_locks() * sizeof(MUTEX_TYPE)); </div><div class="line"><a name="l13754"></a><span class="lineno">13754</span>&#160;   if (!mutex_buf) </div><div class="line"><a name="l13755"></a><span class="lineno">13755</span>&#160;     return SOAP_EOM; </div><div class="line"><a name="l13756"></a><span class="lineno">13756</span>&#160;   for (i = 0; i &lt; CRYPTO_num_locks(); i++) </div><div class="line"><a name="l13757"></a><span class="lineno">13757</span>&#160;     MUTEX_SETUP(mutex_buf[i]); </div><div class="line"><a name="l13758"></a><span class="lineno">13758</span>&#160;   CRYPTO_set_id_callback(id_function); </div><div class="line"><a name="l13759"></a><span class="lineno">13759</span>&#160;   CRYPTO_set_locking_callback(locking_function); </div><div class="line"><a name="l13760"></a><span class="lineno">13760</span>&#160;   CRYPTO_set_dynlock_create_callback(dyn_create_function); </div><div class="line"><a name="l13761"></a><span class="lineno">13761</span>&#160;   CRYPTO_set_dynlock_lock_callback(dyn_lock_function); </div><div class="line"><a name="l13762"></a><span class="lineno">13762</span>&#160;   CRYPTO_set_dynlock_destroy_callback(dyn_destroy_function); </div><div class="line"><a name="l13763"></a><span class="lineno">13763</span>&#160;   return SOAP_OK; </div><div class="line"><a name="l13764"></a><span class="lineno">13764</span>&#160;} </div><div class="line"><a name="l13765"></a><span class="lineno">13765</span>&#160;void CRYPTO_thread_cleanup() </div><div class="line"><a name="l13766"></a><span class="lineno">13766</span>&#160;{ </div><div class="line"><a name="l13767"></a><span class="lineno">13767</span>&#160;   int i; </div><div class="line"><a name="l13768"></a><span class="lineno">13768</span>&#160;   if (!mutex_buf) </div><div class="line"><a name="l13769"></a><span class="lineno">13769</span>&#160;     \return; </div><div class="line"><a name="l13770"></a><span class="lineno">13770</span>&#160;   CRYPTO_set_id_callback(NULL); </div><div class="line"><a name="l13771"></a><span class="lineno">13771</span>&#160;   CRYPTO_set_locking_callback(NULL); </div><div class="line"><a name="l13772"></a><span class="lineno">13772</span>&#160;   CRYPTO_set_dynlock_create_callback(NULL); </div><div class="line"><a name="l13773"></a><span class="lineno">13773</span>&#160;   CRYPTO_set_dynlock_lock_callback(NULL); </div><div class="line"><a name="l13774"></a><span class="lineno">13774</span>&#160;   CRYPTO_set_dynlock_destroy_callback(NULL); </div><div class="line"><a name="l13775"></a><span class="lineno">13775</span>&#160;   for (i = 0; i &lt; CRYPTO_num_locks(); i++) </div><div class="line"><a name="l13776"></a><span class="lineno">13776</span>&#160;     MUTEX_CLEANUP(mutex_buf[i]); </div><div class="line"><a name="l13777"></a><span class="lineno">13777</span>&#160;   free(mutex_buf); </div><div class="line"><a name="l13778"></a><span class="lineno">13778</span>&#160;   mutex_buf = NULL; </div><div class="line"><a name="l13779"></a><span class="lineno">13779</span>&#160;}</div><div class="line"><a name="l13780"></a><span class="lineno">13780</span>&#160;```</div><div class="line"><a name="l13781"></a><span class="lineno">13781</span>&#160;</div><div class="line"><a name="l13782"></a><span class="lineno">13782</span>&#160;For Unix and Linux, make sure you have signal handlers set in your service and/or client applications to catch broken connections (`SIGPIPE`):</div><div class="line"><a name="l13783"></a><span class="lineno">13783</span>&#160;</div><div class="line"><a name="l13784"></a><span class="lineno">13784</span>&#160;```cpp</div><div class="line"><a name="l13785"></a><span class="lineno">13785</span>&#160;signal(SIGPIPE, sigpipe_handle);</div><div class="line"><a name="l13786"></a><span class="lineno">13786</span>&#160;```</div><div class="line"><a name="l13787"></a><span class="lineno">13787</span>&#160;</div><div class="line"><a name="l13788"></a><span class="lineno">13788</span>&#160;where, for example:</div><div class="line"><a name="l13789"></a><span class="lineno">13789</span>&#160;</div><div class="line"><a name="l13790"></a><span class="lineno">13790</span>&#160;```cpp</div><div class="line"><a name="l13791"></a><span class="lineno">13791</span>&#160;void sigpipe_handle(int x) { }</div><div class="line"><a name="l13792"></a><span class="lineno">13792</span>&#160;```</div><div class="line"><a name="l13793"></a><span class="lineno">13793</span>&#160;</div><div class="line"><a name="l13794"></a><span class="lineno">13794</span>&#160;By default, clients are not required to authenticate. To support client authentication use the following:</div><div class="line"><a name="l13795"></a><span class="lineno">13795</span>&#160;</div><div class="line"><a name="l13796"></a><span class="lineno">13796</span>&#160;```cpp</div><div class="line"><a name="l13797"></a><span class="lineno">13797</span>&#160;if (soap_ssl_server_context(&amp;soap, </div><div class="line"><a name="l13798"></a><span class="lineno">13798</span>&#160;    SOAP_SSL_REQUIRE_CLIENT_AUTHENTICATION, </div><div class="line"><a name="l13799"></a><span class="lineno">13799</span>&#160;    &quot;server.pem&quot;, </div><div class="line"><a name="l13800"></a><span class="lineno">13800</span>&#160;    &quot;password&quot;, </div><div class="line"><a name="l13801"></a><span class="lineno">13801</span>&#160;    &quot;cacert.pem&quot;, </div><div class="line"><a name="l13802"></a><span class="lineno">13802</span>&#160;    NULL, </div><div class="line"><a name="l13803"></a><span class="lineno">13803</span>&#160;    &quot;dh512.pem&quot;, </div><div class="line"><a name="l13804"></a><span class="lineno">13804</span>&#160;    NULL, </div><div class="line"><a name="l13805"></a><span class="lineno">13805</span>&#160;    NULL)) </div><div class="line"><a name="l13806"></a><span class="lineno">13806</span>&#160;{ </div><div class="line"><a name="l13807"></a><span class="lineno">13807</span>&#160;  soap_print_fault(&amp;soap, stderr); </div><div class="line"><a name="l13808"></a><span class="lineno">13808</span>&#160;  exit(1); </div><div class="line"><a name="l13809"></a><span class="lineno">13809</span>&#160;}</div><div class="line"><a name="l13810"></a><span class="lineno">13810</span>&#160;```</div><div class="line"><a name="l13811"></a><span class="lineno">13811</span>&#160;</div><div class="line"><a name="l13812"></a><span class="lineno">13812</span>&#160;This requires each client to authenticate with its certificate.</div><div class="line"><a name="l13813"></a><span class="lineno">13813</span>&#160;</div><div class="line"><a name="l13814"></a><span class="lineno">13814</span>&#160;Since release version 2.8.20 SSL v3 is disabled. To enable SSL v3 together with TLS v1.0, v1.1, and v1.2  use `SOAP_SSLv3_TLSv1` in `soap_ssl_server_context`. To use TLS v1.1 only use `SOAP_TLSv1_1`. To use TLS v1.2 only use `SOAP_TLSv1_2`. To use SSL v3 only use `SOAP_SSLv3`.</div><div class="line"><a name="l13815"></a><span class="lineno">13815</span>&#160;</div><div class="line"><a name="l13816"></a><span class="lineno">13816</span>&#160;The `cacert` file and `capath` are optional. Either one can be</div><div class="line"><a name="l13817"></a><span class="lineno">13817</span>&#160;specified when clients must run on non-trusted systems (`capath` is not used with GNUTLS). We want to avoid</div><div class="line"><a name="l13818"></a><span class="lineno">13818</span>&#160;storing trusted certificates in the default location on the file system when</div><div class="line"><a name="l13819"></a><span class="lineno">13819</span>&#160;that is not secure. Therefore, a flat `cacert.pem` file or directory can be</div><div class="line"><a name="l13820"></a><span class="lineno">13820</span>&#160;specified to store trusted certificates.</div><div class="line"><a name="l13821"></a><span class="lineno">13821</span>&#160;</div><div class="line"><a name="l13822"></a><span class="lineno">13822</span>&#160;The gSOAP distribution includes a `cacerts.pem` file with the certificates</div><div class="line"><a name="l13823"></a><span class="lineno">13823</span>&#160;of all certificate authorities such as Verisign. You can use this file to</div><div class="line"><a name="l13824"></a><span class="lineno">13824</span>&#160;verify the authentication of servers that provide certificates issued by these</div><div class="line"><a name="l13825"></a><span class="lineno">13825</span>&#160;CAs.</div><div class="line"><a name="l13826"></a><span class="lineno">13826</span>&#160;</div><div class="line"><a name="l13827"></a><span class="lineno">13827</span>&#160;The `cacert.pem`, `client.pem`, and `server.pem` files in the gSOAP</div><div class="line"><a name="l13828"></a><span class="lineno">13828</span>&#160;distribution are examples of self-signed certificates.</div><div class="line"><a name="l13829"></a><span class="lineno">13829</span>&#160;The `client.pem` and `server.pem` contain the client/server private key</div><div class="line"><a name="l13830"></a><span class="lineno">13830</span>&#160;concatenated with the certificate. The keyfiles (`client.pem` and</div><div class="line"><a name="l13831"></a><span class="lineno">13831</span>&#160;`server.pem`) are created by concatenating the private key PEM with the</div><div class="line"><a name="l13832"></a><span class="lineno">13832</span>&#160;certificate PEM. The keyfile SHOULD NEVER be shared with any party. With</div><div class="line"><a name="l13833"></a><span class="lineno">13833</span>&#160;OpenSSL, you can encrypt the keyfiles with a password to offer some protection</div><div class="line"><a name="l13834"></a><span class="lineno">13834</span>&#160;and the password is used in the client/server code to read the keyfile. GNUTLS</div><div class="line"><a name="l13835"></a><span class="lineno">13835</span>&#160;does not support this feature and cannot encrypt or decrypt a keyfile.</div><div class="line"><a name="l13836"></a><span class="lineno">13836</span>&#160;</div><div class="line"><a name="l13837"></a><span class="lineno">13837</span>&#160;@warning it is important that the `WITH_OPENSSL` macro MUST be consistently defined to</div><div class="line"><a name="l13838"></a><span class="lineno">13838</span>&#160;compile the sources, such as `stdsoap2.cpp`, `soapC.cpp`,</div><div class="line"><a name="l13839"></a><span class="lineno">13839</span>&#160;`soapClient.cpp`, `soapServer.cpp`, and all application sources that</div><div class="line"><a name="l13840"></a><span class="lineno">13840</span>&#160;include `stdsoap2.h` or `soapH.h`. If the macros are not consistently</div><div class="line"><a name="l13841"></a><span class="lineno">13841</span>&#160;used, the application will crash due to a mismatches in the declaration and</div><div class="line"><a name="l13842"></a><span class="lineno">13842</span>&#160;access of the gSOAP context.</div><div class="line"><a name="l13843"></a><span class="lineno">13843</span>&#160;</div><div class="line"><a name="l13844"></a><span class="lineno">13844</span>&#160;## Secure Clients with HTTPS/SSL        {#clientopenssl}</div><div class="line"><a name="l13845"></a><span class="lineno">13845</span>&#160;</div><div class="line"><a name="l13846"></a><span class="lineno">13846</span>&#160;To utilize HTTPS/SSL, you need to install the OpenSSL library on your platform or GNUTLS for a light-weight SSL/TLS library.</div><div class="line"><a name="l13847"></a><span class="lineno">13847</span>&#160;After installation, compile all the sources of your application with option `-DWITH_OPENSSL` (or `-DWITH_GNUTLS` when using GNUTLS). For example on Linux:</div><div class="line"><a name="l13848"></a><span class="lineno">13848</span>&#160;</div><div class="line"><a name="l13849"></a><span class="lineno">13849</span>&#160;    &gt; c++ -DWITH_OPENSSL myclient.cpp stdsoap.cpp soapC.cpp soapClient.cpp -lssl -lcrypto</div><div class="line"><a name="l13850"></a><span class="lineno">13850</span>&#160;</div><div class="line"><a name="l13851"></a><span class="lineno">13851</span>&#160;or Unix:</div><div class="line"><a name="l13852"></a><span class="lineno">13852</span>&#160;</div><div class="line"><a name="l13853"></a><span class="lineno">13853</span>&#160;    &gt; c++ -DWITH_OPENSSL myclient.cpp stdsoap.cpp soapC.cpp soapClient.cpp -lxnet -lsocket -lnsl -lssl -lcrypto</div><div class="line"><a name="l13854"></a><span class="lineno">13854</span>&#160;</div><div class="line"><a name="l13855"></a><span class="lineno">13855</span>&#160;or you can add the following line to `soapdefs.h`:</div><div class="line"><a name="l13856"></a><span class="lineno">13856</span>&#160;</div><div class="line"><a name="l13857"></a><span class="lineno">13857</span>&#160;```cpp</div><div class="line"><a name="l13858"></a><span class="lineno">13858</span>&#160;#define WITH_OPENSSL</div><div class="line"><a name="l13859"></a><span class="lineno">13859</span>&#160;```</div><div class="line"><a name="l13860"></a><span class="lineno">13860</span>&#160;</div><div class="line"><a name="l13861"></a><span class="lineno">13861</span>&#160;and compile with option `-DWITH_SOAPDEFS_H` to include `soapdefs.h` in your project.</div><div class="line"><a name="l13862"></a><span class="lineno">13862</span>&#160;Alternatively, compile with GNUTLS:</div><div class="line"><a name="l13863"></a><span class="lineno">13863</span>&#160;</div><div class="line"><a name="l13864"></a><span class="lineno">13864</span>&#160;    &gt; c++ -DWITH_GNUTLS myclient.cpp stdsoap.cpp soapC.cpp soapClient.cpp -lgnutls -lgcrypt -lgpg-error</div><div class="line"><a name="l13865"></a><span class="lineno">13865</span>&#160;</div><div class="line"><a name="l13866"></a><span class="lineno">13866</span>&#160;</div><div class="line"><a name="l13867"></a><span class="lineno">13867</span>&#160;A client program simply uses the prefix `https:` instead of `http:` in the endpoint URL of a service operation call to a</div><div class="line"><a name="l13868"></a><span class="lineno">13868</span>&#160;Web Service to use encrypted transfers (if the service supports HTTPS). You need to specify the client-side key file and password of the keyfile:</div><div class="line"><a name="l13869"></a><span class="lineno">13869</span>&#160;</div><div class="line"><a name="l13870"></a><span class="lineno">13870</span>&#160;```cpp</div><div class="line"><a name="l13871"></a><span class="lineno">13871</span>&#160;soap_ssl_init(); /* init OpenSSL (skipping this or calling multiple times is OK, since the engine will init SSL automatically) */</div><div class="line"><a name="l13872"></a><span class="lineno">13872</span>&#160;// soap_ssl_noinit(); /* do not init OpenSSL (if SSL is already initialized elsewhere) */</div><div class="line"><a name="l13873"></a><span class="lineno">13873</span>&#160;if (soap_ssl_client_context(&amp;soap, </div><div class="line"><a name="l13874"></a><span class="lineno">13874</span>&#160;   SOAP_SSL_DEFAULT, </div><div class="line"><a name="l13875"></a><span class="lineno">13875</span>&#160;   &quot;client.pem&quot;,        /* keyfile: required only when client must authenticate to server (see SSL docs on how to obtain this file) */ </div><div class="line"><a name="l13876"></a><span class="lineno">13876</span>&#160;   &quot;password&quot;,          /* password to read the key file (not used with GNUTLS) */ </div><div class="line"><a name="l13877"></a><span class="lineno">13877</span>&#160;   &quot;cacerts.pem&quot;,       /* cacert file to store trusted certificates (needed to verify server) */ </div><div class="line"><a name="l13878"></a><span class="lineno">13878</span>&#160;   NULL,                /* capath to directory with trusted certificates */ </div><div class="line"><a name="l13879"></a><span class="lineno">13879</span>&#160;   NULL         /* if randfile!=NULL: use a file with random data to seed randomness */  </div><div class="line"><a name="l13880"></a><span class="lineno">13880</span>&#160;)) </div><div class="line"><a name="l13881"></a><span class="lineno">13881</span>&#160;{ </div><div class="line"><a name="l13882"></a><span class="lineno">13882</span>&#160;   soap_print_fault(&amp;soap, stderr); </div><div class="line"><a name="l13883"></a><span class="lineno">13883</span>&#160;   exit(1); </div><div class="line"><a name="l13884"></a><span class="lineno">13884</span>&#160;} </div><div class="line"><a name="l13885"></a><span class="lineno">13885</span>&#160;soap_call_ns__mymethod(&amp;soap, &quot;https://domain/path/secure.cgi&quot;, &quot;&quot;, ...);</div><div class="line"><a name="l13886"></a><span class="lineno">13886</span>&#160;```</div><div class="line"><a name="l13887"></a><span class="lineno">13887</span>&#160;</div><div class="line"><a name="l13888"></a><span class="lineno">13888</span>&#160;By default, server authentication is enabled and the `cacerts.pem` or</div><div class="line"><a name="l13889"></a><span class="lineno">13889</span>&#160;`capath` (not used with GNUTLS) must be set so that the CA certificates of the server(s) are</div><div class="line"><a name="l13890"></a><span class="lineno">13890</span>&#160;accessible at run time. The `cacerts.pem` file included in the package</div><div class="line"><a name="l13891"></a><span class="lineno">13891</span>&#160;contains the certificates of common CAs. This file must be supplied with the</div><div class="line"><a name="l13892"></a><span class="lineno">13892</span>&#160;client, if server authentication is required. Althernatively, you can use the</div><div class="line"><a name="l13893"></a><span class="lineno">13893</span>&#160;`plugin/cacerts.h` and `plugin/cacerts.c` code to embed CA certificates</div><div class="line"><a name="l13894"></a><span class="lineno">13894</span>&#160;in your client code.</div><div class="line"><a name="l13895"></a><span class="lineno">13895</span>&#160;</div><div class="line"><a name="l13896"></a><span class="lineno">13896</span>&#160;Other client-side SSL options are `SOAP_SSL_SKIP_HOST_CHECK` to skip the host name verification check and `SOAP_SSL_ALLOW_EXPIRED_CERTIFICATE` to allow connecting to a host with an expired certificate. For example,</div><div class="line"><a name="l13897"></a><span class="lineno">13897</span>&#160;</div><div class="line"><a name="l13898"></a><span class="lineno">13898</span>&#160;```cpp</div><div class="line"><a name="l13899"></a><span class="lineno">13899</span>&#160;soap_ssl_init(); /* init OpenSSL (skipping this or calling multiple times is OK, since the engine will init SSL automatically) */</div><div class="line"><a name="l13900"></a><span class="lineno">13900</span>&#160;// soap_ssl_noinit(); /* do not init OpenSSL (if SSL is already initialized elsewhere) */</div><div class="line"><a name="l13901"></a><span class="lineno">13901</span>&#160;if (soap_ssl_client_context(&amp;soap, </div><div class="line"><a name="l13902"></a><span class="lineno">13902</span>&#160;   SOAP_SSL_REQUIRE_SERVER_AUTHENTICATION  </div><div class="line"><a name="l13903"></a><span class="lineno">13903</span>&#160;   | SOAP_SSL_SKIP_HOST_CHECK, </div><div class="line"><a name="l13904"></a><span class="lineno">13904</span>&#160;   | SOAP_SSL_ALLOW_EXPIRED_CERTIFICATE, </div><div class="line"><a name="l13905"></a><span class="lineno">13905</span>&#160;   &quot;client.pem&quot;,        /* keyfile: required only when client must authenticate to server (see SSL docs on how to obtain this file) */ </div><div class="line"><a name="l13906"></a><span class="lineno">13906</span>&#160;   &quot;password&quot;,          /* password to read the key file (not used with GNUTLS) */ </div><div class="line"><a name="l13907"></a><span class="lineno">13907</span>&#160;   &quot;cacerts.pem&quot;,       /* cacert file to store trusted certificates (needed to verify server) */</div><div class="line"><a name="l13908"></a><span class="lineno">13908</span>&#160;   NULL,                /* capath to directory with trusted certificates */ </div><div class="line"><a name="l13909"></a><span class="lineno">13909</span>&#160;   NULL         /* if randfile!=NULL: use a file with random data to seed randomness */  </div><div class="line"><a name="l13910"></a><span class="lineno">13910</span>&#160;)) </div><div class="line"><a name="l13911"></a><span class="lineno">13911</span>&#160;{ </div><div class="line"><a name="l13912"></a><span class="lineno">13912</span>&#160;   soap_print_fault(&amp;soap, stderr); </div><div class="line"><a name="l13913"></a><span class="lineno">13913</span>&#160;   exit(1); </div><div class="line"><a name="l13914"></a><span class="lineno">13914</span>&#160;} </div><div class="line"><a name="l13915"></a><span class="lineno">13915</span>&#160;soap_call_ns__mymethod(&amp;soap, &quot;https://domain/path/secure.cgi&quot;, &quot;&quot;, ...);</div><div class="line"><a name="l13916"></a><span class="lineno">13916</span>&#160;```</div><div class="line"><a name="l13917"></a><span class="lineno">13917</span>&#160;</div><div class="line"><a name="l13918"></a><span class="lineno">13918</span>&#160;For systems based on Microsoft windows, the WinInet module can be used instead, see `mod_gsoap/gsoap_win/wininet`.</div><div class="line"><a name="l13919"></a><span class="lineno">13919</span>&#160;</div><div class="line"><a name="l13920"></a><span class="lineno">13920</span>&#160;Since release version 2.8.20 SSL v3 is disabled. To enable SSL v3 together with TLS v1.0, v1.1, and v1.2  use `SOAP_SSLv3_TLSv1` in `soap_ssl_server_context`. To use TLS v1.1 only use `SOAP_TLSv1_1`. To use TLS v1.2 only use `SOAP_TLSv1_2`. To use SSL v3 only use `SOAP_SSLv3`.</div><div class="line"><a name="l13921"></a><span class="lineno">13921</span>&#160;</div><div class="line"><a name="l13922"></a><span class="lineno">13922</span>&#160;To disable server authentication for testing purposes, use the following:</div><div class="line"><a name="l13923"></a><span class="lineno">13923</span>&#160;</div><div class="line"><a name="l13924"></a><span class="lineno">13924</span>&#160;```cpp</div><div class="line"><a name="l13925"></a><span class="lineno">13925</span>&#160;if (soap_ssl_client_context(&amp;soap, </div><div class="line"><a name="l13926"></a><span class="lineno">13926</span>&#160;   SOAP_SSL_NO_AUTHENTICATION, </div><div class="line"><a name="l13927"></a><span class="lineno">13927</span>&#160;   NULL, </div><div class="line"><a name="l13928"></a><span class="lineno">13928</span>&#160;   NULL, </div><div class="line"><a name="l13929"></a><span class="lineno">13929</span>&#160;   NULL, </div><div class="line"><a name="l13930"></a><span class="lineno">13930</span>&#160;   NULL, </div><div class="line"><a name="l13931"></a><span class="lineno">13931</span>&#160;   NULL </div><div class="line"><a name="l13932"></a><span class="lineno">13932</span>&#160;)) </div><div class="line"><a name="l13933"></a><span class="lineno">13933</span>&#160;{ </div><div class="line"><a name="l13934"></a><span class="lineno">13934</span>&#160;   soap_print_fault(&amp;soap, stderr); </div><div class="line"><a name="l13935"></a><span class="lineno">13935</span>&#160;   exit(1); </div><div class="line"><a name="l13936"></a><span class="lineno">13936</span>&#160;} </div><div class="line"><a name="l13937"></a><span class="lineno">13937</span>&#160;```</div><div class="line"><a name="l13938"></a><span class="lineno">13938</span>&#160;</div><div class="line"><a name="l13939"></a><span class="lineno">13939</span>&#160;This also assumes that the server does not require clients to authenticate (the keyfile is absent).</div><div class="line"><a name="l13940"></a><span class="lineno">13940</span>&#160;</div><div class="line"><a name="l13941"></a><span class="lineno">13941</span>&#160;Make sure you have signal handlers set in your application to catch broken connections (`SIGPIPE`):</div><div class="line"><a name="l13942"></a><span class="lineno">13942</span>&#160;</div><div class="line"><a name="l13943"></a><span class="lineno">13943</span>&#160;```cpp</div><div class="line"><a name="l13944"></a><span class="lineno">13944</span>&#160;signal(SIGPIPE, sigpipe_handle);</div><div class="line"><a name="l13945"></a><span class="lineno">13945</span>&#160;```</div><div class="line"><a name="l13946"></a><span class="lineno">13946</span>&#160;</div><div class="line"><a name="l13947"></a><span class="lineno">13947</span>&#160;where, for example:</div><div class="line"><a name="l13948"></a><span class="lineno">13948</span>&#160;</div><div class="line"><a name="l13949"></a><span class="lineno">13949</span>&#160;```cpp</div><div class="line"><a name="l13950"></a><span class="lineno">13950</span>&#160;void sigpipe_handle(int x) { }</div><div class="line"><a name="l13951"></a><span class="lineno">13951</span>&#160;```</div><div class="line"><a name="l13952"></a><span class="lineno">13952</span>&#160;</div><div class="line"><a name="l13953"></a><span class="lineno">13953</span>&#160;@warning it is important that the `WITH_OPENSSL` macro MUST be consistently defined to</div><div class="line"><a name="l13954"></a><span class="lineno">13954</span>&#160;compile the sources, such as `stdsoap2.cpp`, `soapC.cpp`,</div><div class="line"><a name="l13955"></a><span class="lineno">13955</span>&#160;`soapClient.cpp`, `soapServer.cpp`, and all application sources that</div><div class="line"><a name="l13956"></a><span class="lineno">13956</span>&#160;include `stdsoap2.h` or `soapH.h`. If the macros are not consistently</div><div class="line"><a name="l13957"></a><span class="lineno">13957</span>&#160;used, the application will crash due to a mismatches in the declaration and</div><div class="line"><a name="l13958"></a><span class="lineno">13958</span>&#160;access of the gSOAP context.</div><div class="line"><a name="l13959"></a><span class="lineno">13959</span>&#160;@warning concurrent client calls MUST be made using separate soap structs copied with `soap_copy` from an originating struct initialized with `soap_ssl_client_context`. In addition, the thread initialization code discussed in Section \ref serveropenssl  MUST be used to properly setup OpenSSL in a multi-threaded client application.</div><div class="line"><a name="l13960"></a><span class="lineno">13960</span>&#160;</div><div class="line"><a name="l13961"></a><span class="lineno">13961</span>&#160;## SSL Authentication Callbacks</div><div class="line"><a name="l13962"></a><span class="lineno">13962</span>&#160;</div><div class="line"><a name="l13963"></a><span class="lineno">13963</span>&#160;The `fsslauth` callback function controls OpenSSL/GNUTLS authentication initialization:</div><div class="line"><a name="l13964"></a><span class="lineno">13964</span>&#160;</div><div class="line"><a name="l13965"></a><span class="lineno">13965</span>&#160;* `int (*soap.fsslauth)(struct soap *soap)` </div><div class="line"><a name="l13966"></a><span class="lineno">13966</span>&#160;  Initialize the authentication information for clients and services, such as</div><div class="line"><a name="l13967"></a><span class="lineno">13967</span>&#160;  the certificate chain, password, read the key and/or DH file, generate an RSA</div><div class="line"><a name="l13968"></a><span class="lineno">13968</span>&#160;  key, and initialization of the RNG.  Should return a gSOAP error code or</div><div class="line"><a name="l13969"></a><span class="lineno">13969</span>&#160;  `SOAP_OK`.  Built-in gSOAP function: `ssl_auth_init`</div><div class="line"><a name="l13970"></a><span class="lineno">13970</span>&#160;</div><div class="line"><a name="l13971"></a><span class="lineno">13971</span>&#160;The `fsslverify` callback function controls OpenSSL peer certificate</div><div class="line"><a name="l13972"></a><span class="lineno">13972</span>&#160;verification, via internally invoking `SSL_CTX_set_verify`:</div><div class="line"><a name="l13973"></a><span class="lineno">13973</span>&#160;</div><div class="line"><a name="l13974"></a><span class="lineno">13974</span>&#160;* `int (*soap.fssverify)(int ok, X509_STORE_CTX *store` </div><div class="line"><a name="l13975"></a><span class="lineno">13975</span>&#160;  Used to control the certificate verification behaviour when the</div><div class="line"><a name="l13976"></a><span class="lineno">13976</span>&#160;  `SOAP_SSL_REQUIRE_CLIENT_AUTHENTICATION` or</div><div class="line"><a name="l13977"></a><span class="lineno">13977</span>&#160;  `SOAP_SSL_REQUIRE_SERVER_AUTHENTICATION` flags are specified with</div><div class="line"><a name="l13978"></a><span class="lineno">13978</span>&#160;  `soap_ssl_client_context` and `soap_ssl_server_context`. It receives two</div><div class="line"><a name="l13979"></a><span class="lineno">13979</span>&#160;  arguments: `ok` indicates, whether the verification of the certificate in</div><div class="line"><a name="l13980"></a><span class="lineno">13980</span>&#160;  question was passed (`ok=1`) or not (]blk{ok=0}).  If the callback returns 0,</div><div class="line"><a name="l13981"></a><span class="lineno">13981</span>&#160;  the verification process is immediately stopped with &quot;verification failed&quot;</div><div class="line"><a name="l13982"></a><span class="lineno">13982</span>&#160;  state. A verification failure alert is sent to the peer and the TLS/SSL</div><div class="line"><a name="l13983"></a><span class="lineno">13983</span>&#160;  handshake is terminated. If the callback returns 1, the verification process</div><div class="line"><a name="l13984"></a><span class="lineno">13984</span>&#160;  is continued.  Built-in gSOAP function: `ssl_verify_callback` and</div><div class="line"><a name="l13985"></a><span class="lineno">13985</span>&#160;  `ssl_verify_callback_allow_expired_certificate`. These functions are used</div><div class="line"><a name="l13986"></a><span class="lineno">13986</span>&#160;  when `fsslverify` is initially set to `NULL` and were not reassigned before</div><div class="line"><a name="l13987"></a><span class="lineno">13987</span>&#160;  `soap_ssl_client_context` or `soap_ssl_server_context` are called.</div><div class="line"><a name="l13988"></a><span class="lineno">13988</span>&#160;</div><div class="line"><a name="l13989"></a><span class="lineno">13989</span>&#160;## SSL Certificates and Key Files        {#ssl}</div><div class="line"><a name="l13990"></a><span class="lineno">13990</span>&#160;</div><div class="line"><a name="l13991"></a><span class="lineno">13991</span>&#160;The gSOAP distribution includes a `cacerts.pem` file with the certificates</div><div class="line"><a name="l13992"></a><span class="lineno">13992</span>&#160;of all certificate authorities (such as Verisign). You can use this file to</div><div class="line"><a name="l13993"></a><span class="lineno">13993</span>&#160;verify the authentication of servers that provide certificates issued by these</div><div class="line"><a name="l13994"></a><span class="lineno">13994</span>&#160;CAs. Just set the `cafile` parameter to the location of this file on your</div><div class="line"><a name="l13995"></a><span class="lineno">13995</span>&#160;file system.  Therefore, when you obtain a certifice signed by a trusted CA</div><div class="line"><a name="l13996"></a><span class="lineno">13996</span>&#160;such as Verisign, you can simply use the `cacerts.pem` file to develop</div><div class="line"><a name="l13997"></a><span class="lineno">13997</span>&#160;client applications that can verify the authenticity of your server.</div><div class="line"><a name="l13998"></a><span class="lineno">13998</span>&#160;</div><div class="line"><a name="l13999"></a><span class="lineno">13999</span>&#160;Althernatively, you can use the `plugin/cacerts.h` and</div><div class="line"><a name="l14000"></a><span class="lineno">14000</span>&#160;`plugin/cacerts.c` code to embed CA certificates in your client code.</div><div class="line"><a name="l14001"></a><span class="lineno">14001</span>&#160;</div><div class="line"><a name="l14002"></a><span class="lineno">14002</span>&#160;For systems based on Microsoft windows, the WinInet module can be used instead,</div><div class="line"><a name="l14003"></a><span class="lineno">14003</span>&#160;see the `README.txt` located in the package under</div><div class="line"><a name="l14004"></a><span class="lineno">14004</span>&#160;`mod_gsoap/gsoap_win/wininet`.</div><div class="line"><a name="l14005"></a><span class="lineno">14005</span>&#160;</div><div class="line"><a name="l14006"></a><span class="lineno">14006</span>&#160;The other `.pem` files in the gSOAP distribution are examples</div><div class="line"><a name="l14007"></a><span class="lineno">14007</span>&#160;of self-signed certificates for testing purposes (`cacert.pem`, `client.pem`, `server.pem`). The `client.pem` and `server.pem` contain the private key and certificate of the client or server, respectively. The keyfiles (`client.pem` and `server.pem`) are created by concatenating the private key PEM with the certificate PEM. The keyfile SHOULD NEVER be shared with any party. With OpenSSL, you can encrypt the keyfiles with a password to offer some protection and the password is used in the client/server code to read the keyfile. GNUTLS does not support this feature and cannot encrypt or decrypt a keyfile.</div><div class="line"><a name="l14008"></a><span class="lineno">14008</span>&#160;</div><div class="line"><a name="l14009"></a><span class="lineno">14009</span>&#160;You can also create your own self-signed certificates.  There is more than one</div><div class="line"><a name="l14010"></a><span class="lineno">14010</span>&#160;way to generate the necessary files for clients and servers.</div><div class="line"><a name="l14011"></a><span class="lineno">14011</span>&#160;See `http://www.openssl.org` for information on OpenSSL and</div><div class="line"><a name="l14012"></a><span class="lineno">14012</span>&#160;`http://sial.org/howto/openssl/ca/` on how to setup and manage a local CA</div><div class="line"><a name="l14013"></a><span class="lineno">14013</span>&#160;and `http://sial.org/howto/openssl/self-signed/` on how to setup self-signed</div><div class="line"><a name="l14014"></a><span class="lineno">14014</span>&#160;test certificates.</div><div class="line"><a name="l14015"></a><span class="lineno">14015</span>&#160;</div><div class="line"><a name="l14016"></a><span class="lineno">14016</span>&#160;It is possible to convert IIS-generated certificates to PEM format with the openssl library and openssl command-line tool:</div><div class="line"><a name="l14017"></a><span class="lineno">14017</span>&#160;</div><div class="line"><a name="l14018"></a><span class="lineno">14018</span>&#160;```cpp</div><div class="line"><a name="l14019"></a><span class="lineno">14019</span>&#160;openssl x509 -in mycert.cer -inform DER -out mycert.pem -outform PEM</div><div class="line"><a name="l14020"></a><span class="lineno">14020</span>&#160;```</div><div class="line"><a name="l14021"></a><span class="lineno">14021</span>&#160;</div><div class="line"><a name="l14022"></a><span class="lineno">14022</span>&#160;This converts the CRT-formatted mycert.cer to PEM-formatted mycert.pem.</div><div class="line"><a name="l14023"></a><span class="lineno">14023</span>&#160;</div><div class="line"><a name="l14024"></a><span class="lineno">14024</span>&#160;Here is the simplest way to setup self-signed certificates. First you need to create a private Certificate Authority (CA).  The CA is used in SSL to verify the authenticity of a given</div><div class="line"><a name="l14025"></a><span class="lineno">14025</span>&#160;certificate. The CA acts as a trusted third party who has authenticated the</div><div class="line"><a name="l14026"></a><span class="lineno">14026</span>&#160;user of the signed certificate as being who they say. The certificate is</div><div class="line"><a name="l14027"></a><span class="lineno">14027</span>&#160;signed by the CA, and if the client trusts the CA, it will trust your</div><div class="line"><a name="l14028"></a><span class="lineno">14028</span>&#160;certificate. For use within your organization, a private CA will probably</div><div class="line"><a name="l14029"></a><span class="lineno">14029</span>&#160;serve your needs. However, if you intend use your certificates for a public</div><div class="line"><a name="l14030"></a><span class="lineno">14030</span>&#160;service, you should probably obtain a certificate from a known CA (e.g. VeriSign).</div><div class="line"><a name="l14031"></a><span class="lineno">14031</span>&#160;In addition to identification, your certificate is also used for encryption.</div><div class="line"><a name="l14032"></a><span class="lineno">14032</span>&#160;</div><div class="line"><a name="l14033"></a><span class="lineno">14033</span>&#160;Creating certificates should be done through a CA to obtain signed certificates. But you can create your own certificates for testing purposes as follows.</div><div class="line"><a name="l14034"></a><span class="lineno">14034</span>&#160;</div><div class="line"><a name="l14035"></a><span class="lineno">14035</span>&#160;</div><div class="line"><a name="l14036"></a><span class="lineno">14036</span>&#160;*  Go to the OpenSSL bin directory (`/usr/local/ssl` by default and</div><div class="line"><a name="l14037"></a><span class="lineno">14037</span>&#160;`/System/Library/OpenSSL` on Mac OS X)</div><div class="line"><a name="l14038"></a><span class="lineno">14038</span>&#160;</div><div class="line"><a name="l14039"></a><span class="lineno">14039</span>&#160;*  There should be a file called openssl.cnf</div><div class="line"><a name="l14040"></a><span class="lineno">14040</span>&#160;</div><div class="line"><a name="l14041"></a><span class="lineno">14041</span>&#160;*  Create a new directory in your home account, e.g. $HOME/CA, and copy the openssl.cnf file to this directory</div><div class="line"><a name="l14042"></a><span class="lineno">14042</span>&#160;</div><div class="line"><a name="l14043"></a><span class="lineno">14043</span>&#160;*  Modify openssl.cnf by changing the &#39;dir&#39; value to HOME/CA</div><div class="line"><a name="l14044"></a><span class="lineno">14044</span>&#160;</div><div class="line"><a name="l14045"></a><span class="lineno">14045</span>&#160;*  Copy the README.txt, root.sh, and cert.sh scripts from the gSOAP distribution package located in the samples/ssl directory to HOME/CA</div><div class="line"><a name="l14046"></a><span class="lineno">14046</span>&#160;</div><div class="line"><a name="l14047"></a><span class="lineno">14047</span>&#160;*  Follow the README.txt instructions</div><div class="line"><a name="l14048"></a><span class="lineno">14048</span>&#160;</div><div class="line"><a name="l14049"></a><span class="lineno">14049</span>&#160;You now have a self-signed CA root certificate cacert.pem and a server.pem (or client.pem) certificate in PEM format.</div><div class="line"><a name="l14050"></a><span class="lineno">14050</span>&#160;The cacert.pem certificate is used in the `cafile` parameter of the `soap_ssl_client_context` (or `soap_ssl_server_context`) at the client (or server) side to verify the authenticity of the peer. You can also provide a capath parameter to these trusted certificates. The server.pem (or client.pem) must be provided with the `soap_ssl_server_context` at the server side (or `soap_ssl_client_context` at the client side) together with the password you entered when generating the certificate using cert.sh to access the file. These certificates must be present to grant authentication requests by peers. In addition, the server.pem (and client.pem) include the host name of the machine on which the application runs (e.g. localhost), so you need to generate new certificates when migrating a server (or client).</div><div class="line"><a name="l14051"></a><span class="lineno">14051</span>&#160;</div><div class="line"><a name="l14052"></a><span class="lineno">14052</span>&#160;Finally, you need to generate Diffie-Helmann (DH) parameters for the server if</div><div class="line"><a name="l14053"></a><span class="lineno">14053</span>&#160;you wish to use DH instead of RSA. There are two options:</div><div class="line"><a name="l14054"></a><span class="lineno">14054</span>&#160;</div><div class="line"><a name="l14055"></a><span class="lineno">14055</span>&#160;</div><div class="line"><a name="l14056"></a><span class="lineno">14056</span>&#160;*  Set the `dhfile` parameter to the numeric DH prime length in bits</div><div class="line"><a name="l14057"></a><span class="lineno">14057</span>&#160;required (for example &quot;1024&quot;) to let the engine generate DH parameters at</div><div class="line"><a name="l14058"></a><span class="lineno">14058</span>&#160;initialization. This can be time consuming.</div><div class="line"><a name="l14059"></a><span class="lineno">14059</span>&#160;</div><div class="line"><a name="l14060"></a><span class="lineno">14060</span>&#160;*  Provide a file name for the `dhfile` parameter of</div><div class="line"><a name="l14061"></a><span class="lineno">14061</span>&#160;`soap_ssl_server_context`. The file should be generated beforehand. To</div><div class="line"><a name="l14062"></a><span class="lineno">14062</span>&#160;do so with the OpenSSL command line tool, use:</div><div class="line"><a name="l14063"></a><span class="lineno">14063</span>&#160;</div><div class="line"><a name="l14064"></a><span class="lineno">14064</span>&#160;    &gt; openssl dhparam -outform PEM -out dh.pem 512</div><div class="line"><a name="l14065"></a><span class="lineno">14065</span>&#160;</div><div class="line"><a name="l14066"></a><span class="lineno">14066</span>&#160;File `dh512.pem` is the output file and 512 is the number of bits used.</div><div class="line"><a name="l14067"></a><span class="lineno">14067</span>&#160;</div><div class="line"><a name="l14068"></a><span class="lineno">14068</span>&#160;</div><div class="line"><a name="l14069"></a><span class="lineno">14069</span>&#160;## SSL Hardware Acceleration</div><div class="line"><a name="l14070"></a><span class="lineno">14070</span>&#160;</div><div class="line"><a name="l14071"></a><span class="lineno">14071</span>&#160;You can specify a hardware engine to enable hardware support for cryptographic acceleration. This can be done once in a server or client with the following statements:</div><div class="line"><a name="l14072"></a><span class="lineno">14072</span>&#160;</div><div class="line"><a name="l14073"></a><span class="lineno">14073</span>&#160;```cpp</div><div class="line"><a name="l14074"></a><span class="lineno">14074</span>&#160;static const char *engine = &quot;cswift&quot;; /* engine name */ </div><div class="line"><a name="l14075"></a><span class="lineno">14075</span>&#160;int main() </div><div class="line"><a name="l14076"></a><span class="lineno">14076</span>&#160;{ </div><div class="line"><a name="l14077"></a><span class="lineno">14077</span>&#160;   ... </div><div class="line"><a name="l14078"></a><span class="lineno">14078</span>&#160;   ENGINE *e; </div><div class="line"><a name="l14079"></a><span class="lineno">14079</span>&#160;   if (!(e = ENGINE_by_id(engine))) </div><div class="line"><a name="l14080"></a><span class="lineno">14080</span>&#160;     fprintf(stderr, &quot;Error finding engine %s\n&quot;, engine); </div><div class="line"><a name="l14081"></a><span class="lineno">14081</span>&#160;   else if (!ENGINE_set_default(e, ENGINE_METHOD_ALL)) </div><div class="line"><a name="l14082"></a><span class="lineno">14082</span>&#160;     fprintf(stderr, &quot;Error using engine %s\n&quot;, engine); </div><div class="line"><a name="l14083"></a><span class="lineno">14083</span>&#160;   ...</div><div class="line"><a name="l14084"></a><span class="lineno">14084</span>&#160;```</div><div class="line"><a name="l14085"></a><span class="lineno">14085</span>&#160;</div><div class="line"><a name="l14086"></a><span class="lineno">14086</span>&#160;The following table lists the names of the hardware and software engines:</div><div class="line"><a name="l14087"></a><span class="lineno">14087</span>&#160;</div><div class="line"><a name="l14088"></a><span class="lineno">14088</span>&#160;engine               | result</div><div class="line"><a name="l14089"></a><span class="lineno">14089</span>&#160;-------------------- | ------</div><div class="line"><a name="l14090"></a><span class="lineno">14090</span>&#160;`openssl`            | The default software engine for cryptographic operations </div><div class="line"><a name="l14091"></a><span class="lineno">14091</span>&#160;`openbsd_dev_crypto` | OpenBSD supports kernel level cryptography </div><div class="line"><a name="l14092"></a><span class="lineno">14092</span>&#160;`cswift`             | CryptoSwift acceleration hardware </div><div class="line"><a name="l14093"></a><span class="lineno">14093</span>&#160;`chil`               | nCipher CHIL acceleration hardware </div><div class="line"><a name="l14094"></a><span class="lineno">14094</span>&#160;`atalla`             | Compaq Atalla acceleration hardware </div><div class="line"><a name="l14095"></a><span class="lineno">14095</span>&#160;`nuron`              | Nuron acceleration hardware </div><div class="line"><a name="l14096"></a><span class="lineno">14096</span>&#160;`ubsec`              | Broadcom uBSec acceleration hardware </div><div class="line"><a name="l14097"></a><span class="lineno">14097</span>&#160;`aep`                | Aep acceleration hardware </div><div class="line"><a name="l14098"></a><span class="lineno">14098</span>&#160;`sureware`           | SureWare acceleration hardware </div><div class="line"><a name="l14099"></a><span class="lineno">14099</span>&#160;</div><div class="line"><a name="l14100"></a><span class="lineno">14100</span>&#160;## SSL on Windows</div><div class="line"><a name="l14101"></a><span class="lineno">14101</span>&#160;</div><div class="line"><a name="l14102"></a><span class="lineno">14102</span>&#160;Set the full path to libssl.lib and libcrypto.lib </div><div class="line"><a name="l14103"></a><span class="lineno">14103</span>&#160;under the MSVC++ &quot;Projects&quot; menu, then choose &quot;Link&quot;: &quot;Object/Modules&quot;.</div><div class="line"><a name="l14104"></a><span class="lineno">14104</span>&#160;Please make sure `libssl32.dll` and `libeay32.dll` can be loaded by</div><div class="line"><a name="l14105"></a><span class="lineno">14105</span>&#160;gSOAP applications, thus they must be installed properly on the target</div><div class="line"><a name="l14106"></a><span class="lineno">14106</span>&#160;machine.</div><div class="line"><a name="l14107"></a><span class="lineno">14107</span>&#160;</div><div class="line"><a name="l14108"></a><span class="lineno">14108</span>&#160;If you&#39;re using compilation settings such as `/MTd` then link to the correct `libeay32MTd.lib` and `ssleay32MTd.lib` libraries.</div><div class="line"><a name="l14109"></a><span class="lineno">14109</span>&#160;</div><div class="line"><a name="l14110"></a><span class="lineno">14110</span>&#160;Alternatively, you can use the WinInet interface available in the `mod_gsoap` directory of the gSOAP package. API instructions are included in the source.</div><div class="line"><a name="l14111"></a><span class="lineno">14111</span>&#160;</div><div class="line"><a name="l14112"></a><span class="lineno">14112</span>&#160;## Zlib Compression        {#compression}</div><div class="line"><a name="l14113"></a><span class="lineno">14113</span>&#160;</div><div class="line"><a name="l14114"></a><span class="lineno">14114</span>&#160;To enable deflate and gzip compression with Zlib, install Zlib from</div><div class="line"><a name="l14115"></a><span class="lineno">14115</span>&#160;http://www.zlib.org if not already installed on your system.  Compile</div><div class="line"><a name="l14116"></a><span class="lineno">14116</span>&#160;`stdsoap2.cpp` (or `stdsoap2.c`) and **all** your sources that include</div><div class="line"><a name="l14117"></a><span class="lineno">14117</span>&#160;`stdsoap2.h` or `soapH.h` with compiler option `-DWITH_GZIP` and</div><div class="line"><a name="l14118"></a><span class="lineno">14118</span>&#160;link your code with the Zlib library, e.g. `-lz` on Unix/Linux platforms.</div><div class="line"><a name="l14119"></a><span class="lineno">14119</span>&#160;</div><div class="line"><a name="l14120"></a><span class="lineno">14120</span>&#160;The gzip compression is orthogonal to all transport encodings such as HTTP,</div><div class="line"><a name="l14121"></a><span class="lineno">14121</span>&#160;SSL, DIME, and can be used with other transport layers.  You can even save and</div><div class="line"><a name="l14122"></a><span class="lineno">14122</span>&#160;load compressed XML data to/from files.</div><div class="line"><a name="l14123"></a><span class="lineno">14123</span>&#160;</div><div class="line"><a name="l14124"></a><span class="lineno">14124</span>&#160;gSOAP supports two compression formats: deflate and gzip. The gzip format is</div><div class="line"><a name="l14125"></a><span class="lineno">14125</span>&#160;used by default. The gzip format has several benefits over deflate. Firstly,</div><div class="line"><a name="l14126"></a><span class="lineno">14126</span>&#160;gSOAP can automatically detect gzip compressed inbound messages, even without</div><div class="line"><a name="l14127"></a><span class="lineno">14127</span>&#160;HTTP headers, by checking for the presence of a gzip header in the message</div><div class="line"><a name="l14128"></a><span class="lineno">14128</span>&#160;content. Secondly, gzip includes a CRC32 checksum to ensure messages have been</div><div class="line"><a name="l14129"></a><span class="lineno">14129</span>&#160;correctly received. Thirdly, gzip compressed content can be decompressed with</div><div class="line"><a name="l14130"></a><span class="lineno">14130</span>&#160;other compression software, so you can decompress XML data saved by gSOAP in</div><div class="line"><a name="l14131"></a><span class="lineno">14131</span>&#160;gzip format.</div><div class="line"><a name="l14132"></a><span class="lineno">14132</span>&#160;</div><div class="line"><a name="l14133"></a><span class="lineno">14133</span>&#160;Gzip compression is enabled by compiling the sources with `-DWITH_GZIP`.</div><div class="line"><a name="l14134"></a><span class="lineno">14134</span>&#160;To transmit gzip compressed SOAP/XML data, set the output mode flags to</div><div class="line"><a name="l14135"></a><span class="lineno">14135</span>&#160;`SOAP_ENC_ZLIB`. For example:</div><div class="line"><a name="l14136"></a><span class="lineno">14136</span>&#160;</div><div class="line"><a name="l14137"></a><span class="lineno">14137</span>&#160;```cpp</div><div class="line"><a name="l14138"></a><span class="lineno">14138</span>&#160;soap_init(&amp;soap); </div><div class="line"><a name="l14139"></a><span class="lineno">14139</span>&#160;... </div><div class="line"><a name="l14140"></a><span class="lineno">14140</span>&#160;soap_set_omode(&amp;soap, SOAP_ENC_ZLIB); // enable Zlib&#39;s gzip </div><div class="line"><a name="l14141"></a><span class="lineno">14141</span>&#160;if (soap_call_ns__myMethod(&amp;soap, ...)) </div><div class="line"><a name="l14142"></a><span class="lineno">14142</span>&#160;... </div><div class="line"><a name="l14143"></a><span class="lineno">14143</span>&#160;soap_clr_omode(&amp;soap, SOAP_ENC_ZLIB); // disable Zlib&#39;s gzip </div><div class="line"><a name="l14144"></a><span class="lineno">14144</span>&#160;...</div><div class="line"><a name="l14145"></a><span class="lineno">14145</span>&#160;```</div><div class="line"><a name="l14146"></a><span class="lineno">14146</span>&#160;</div><div class="line"><a name="l14147"></a><span class="lineno">14147</span>&#160;This will send a compressed SOAP/XML request to a service, provided that Zlib is</div><div class="line"><a name="l14148"></a><span class="lineno">14148</span>&#160;installed and linked with the application and the `-DWITH_GZIP` option was used to compile the sources.</div><div class="line"><a name="l14149"></a><span class="lineno">14149</span>&#160;Receiving compressed SOAP/XML over HTTP either in gzip or deflate formats is automatic. The `SOAP_ENC_ZLIB` flag does not have</div><div class="line"><a name="l14150"></a><span class="lineno">14150</span>&#160;to be set at the server side to accept compressed messages. Reading and receiving gzip compressed SOAP/XML without HTTP headers (e.g. with other transport protocols) is also automatic.</div><div class="line"><a name="l14151"></a><span class="lineno">14151</span>&#160;</div><div class="line"><a name="l14152"></a><span class="lineno">14152</span>&#160;To control the level of compression for outbound messages, you can set the `soap.z_level` to a value between 1 and 9, where 1 is the best speed and 9 is the best compression (default is 6).  For example</div><div class="line"><a name="l14153"></a><span class="lineno">14153</span>&#160;</div><div class="line"><a name="l14154"></a><span class="lineno">14154</span>&#160;```cpp</div><div class="line"><a name="l14155"></a><span class="lineno">14155</span>&#160;soap_init(&amp;soap); </div><div class="line"><a name="l14156"></a><span class="lineno">14156</span>&#160;... </div><div class="line"><a name="l14157"></a><span class="lineno">14157</span>&#160;soap_set_omode(&amp;soap, SOAP_ENC_ZLIB); </div><div class="line"><a name="l14158"></a><span class="lineno">14158</span>&#160;soap.z_level = 9; // best compression </div><div class="line"><a name="l14159"></a><span class="lineno">14159</span>&#160;...</div><div class="line"><a name="l14160"></a><span class="lineno">14160</span>&#160;```</div><div class="line"><a name="l14161"></a><span class="lineno">14161</span>&#160;</div><div class="line"><a name="l14162"></a><span class="lineno">14162</span>&#160;To verify and monitor compression rates, you can use the values `soap.z_ratio_in` and `soap.z_ratio_out`. These two float values lie between 0.0 and 1.0 and express the ratio of the compressed message length over uncompressed message length.</div><div class="line"><a name="l14163"></a><span class="lineno">14163</span>&#160;</div><div class="line"><a name="l14164"></a><span class="lineno">14164</span>&#160;```cpp</div><div class="line"><a name="l14165"></a><span class="lineno">14165</span>&#160;soap_call_ns__myMethod(&amp;soap, ...); </div><div class="line"><a name="l14166"></a><span class="lineno">14166</span>&#160;... </div><div class="line"><a name="l14167"></a><span class="lineno">14167</span>&#160;printf(&quot;Compression ratio: %f%% (in) %f%% (out)\n&quot;, 100*soap.z_ratio_out, 100*soap.z_ratio_in); </div><div class="line"><a name="l14168"></a><span class="lineno">14168</span>&#160;...</div><div class="line"><a name="l14169"></a><span class="lineno">14169</span>&#160;```</div><div class="line"><a name="l14170"></a><span class="lineno">14170</span>&#160;</div><div class="line"><a name="l14171"></a><span class="lineno">14171</span>&#160;Note: lower ratios mean higher compression rates.</div><div class="line"><a name="l14172"></a><span class="lineno">14172</span>&#160;</div><div class="line"><a name="l14173"></a><span class="lineno">14173</span>&#160;Compressed transfers require buffering the entire output message to determine HTTP message length.</div><div class="line"><a name="l14174"></a><span class="lineno">14174</span>&#160;This means that the `SOAP_IO_STORE` flag is</div><div class="line"><a name="l14175"></a><span class="lineno">14175</span>&#160;automatically set when the `SOAP_ENC_ZLIB` flag is set to send compressed messages. The use of HTTP chunking</div><div class="line"><a name="l14176"></a><span class="lineno">14176</span>&#160;significantly reduces memory usage and may speed up the transmission of compressed SOAP/XML messages.</div><div class="line"><a name="l14177"></a><span class="lineno">14177</span>&#160;This is accomplished by setting the `SOAP_IO_CHUNK` flag with</div><div class="line"><a name="l14178"></a><span class="lineno">14178</span>&#160;`SOAP_ENC_ZLIB` for the output mode.</div><div class="line"><a name="l14179"></a><span class="lineno">14179</span>&#160;However, some Web servers do not accept HTTP chunked request messages (even when they return HTTP chunked messages!). Stand-alone gSOAP services always accept chunked request messages.</div><div class="line"><a name="l14180"></a><span class="lineno">14180</span>&#160;</div><div class="line"><a name="l14181"></a><span class="lineno">14181</span>&#160;To restrict the compression to the deflate format only, compile the sources with `-DWITH_ZLIB`. This limits compression and decompression to the deflate format. Only plain and deflated messages can be exchanged, gzip is not supported with this option.</div><div class="line"><a name="l14182"></a><span class="lineno">14182</span>&#160;Receiving gzip compressed content is automatic, even in the absence of HTTP headers.</div><div class="line"><a name="l14183"></a><span class="lineno">14183</span>&#160;Receiving deflate compressed content is not automatic in the absence of HTTP headers and requires the flag</div><div class="line"><a name="l14184"></a><span class="lineno">14184</span>&#160;`SOAP_ENC_ZLIB` to be set for the input mode to decompress deflated data.</div><div class="line"><a name="l14185"></a><span class="lineno">14185</span>&#160;</div><div class="line"><a name="l14186"></a><span class="lineno">14186</span>&#160;@warning it is important that the `WITH_GZIP` and `WITH_ZLIB` macros MUST be consistently defined to</div><div class="line"><a name="l14187"></a><span class="lineno">14187</span>&#160;compile the sources, such as `stdsoap2.cpp`, `soapC.cpp`,</div><div class="line"><a name="l14188"></a><span class="lineno">14188</span>&#160;`soapClient.cpp`, `soapServer.cpp`, and all application sources that</div><div class="line"><a name="l14189"></a><span class="lineno">14189</span>&#160;include `stdsoap2.h` or `soapH.h`. If the macros are not consistently</div><div class="line"><a name="l14190"></a><span class="lineno">14190</span>&#160;used, the application will crash due to a mismatches in the declaration and</div><div class="line"><a name="l14191"></a><span class="lineno">14191</span>&#160;access of the gSOAP context.</div><div class="line"><a name="l14192"></a><span class="lineno">14192</span>&#160;</div><div class="line"><a name="l14193"></a><span class="lineno">14193</span>&#160;## Client-Side Cookie Support        {#clientcookie}</div><div class="line"><a name="l14194"></a><span class="lineno">14194</span>&#160;</div><div class="line"><a name="l14195"></a><span class="lineno">14195</span>&#160;Client-side cookie support is optional. To enable cookie support, compile all sources with option `-DWITH_COOKIES`, for example:</div><div class="line"><a name="l14196"></a><span class="lineno">14196</span>&#160;</div><div class="line"><a name="l14197"></a><span class="lineno">14197</span>&#160;    &gt; c++ -DWITH_COOKIES -o myclient stdsoap2.cpp soapC.cpp soapClient.cpp</div><div class="line"><a name="l14198"></a><span class="lineno">14198</span>&#160;</div><div class="line"><a name="l14199"></a><span class="lineno">14199</span>&#160;or add the following line to `stdsoap.h`:</div><div class="line"><a name="l14200"></a><span class="lineno">14200</span>&#160;</div><div class="line"><a name="l14201"></a><span class="lineno">14201</span>&#160;```cpp</div><div class="line"><a name="l14202"></a><span class="lineno">14202</span>&#160;#define WITH_COOKIES</div><div class="line"><a name="l14203"></a><span class="lineno">14203</span>&#160;```</div><div class="line"><a name="l14204"></a><span class="lineno">14204</span>&#160;</div><div class="line"><a name="l14205"></a><span class="lineno">14205</span>&#160;Client-side cookie support is fully automatic. So just (re)compile `stdsoap2.cpp` with `-DWITH_COOKIES` to enable</div><div class="line"><a name="l14206"></a><span class="lineno">14206</span>&#160;cookie-based session control in your client.</div><div class="line"><a name="l14207"></a><span class="lineno">14207</span>&#160;</div><div class="line"><a name="l14208"></a><span class="lineno">14208</span>&#160;A database of cookies is kept and returned to the appropriate servers.</div><div class="line"><a name="l14209"></a><span class="lineno">14209</span>&#160;Cookies are not automatically saved to a file by a client. An example cookie</div><div class="line"><a name="l14210"></a><span class="lineno">14210</span>&#160;file manager is included as an extras in the distribution. You should</div><div class="line"><a name="l14211"></a><span class="lineno">14211</span>&#160;explicitly remove all cookies before terminating a gSOAP context by</div><div class="line"><a name="l14212"></a><span class="lineno">14212</span>&#160;calling `soap_free_cookies(soap)` or by calling `soap_done(soap)`.</div><div class="line"><a name="l14213"></a><span class="lineno">14213</span>&#160;</div><div class="line"><a name="l14214"></a><span class="lineno">14214</span>&#160;To avoid &quot;cookie storms&quot; caused by malicious servers that return an </div><div class="line"><a name="l14215"></a><span class="lineno">14215</span>&#160;unreasonable amount of cookies, gSOAP clients/servers are restricted to</div><div class="line"><a name="l14216"></a><span class="lineno">14216</span>&#160;a database size that the user can limit (32 cookies by default), for example:</div><div class="line"><a name="l14217"></a><span class="lineno">14217</span>&#160;</div><div class="line"><a name="l14218"></a><span class="lineno">14218</span>&#160;```cpp</div><div class="line"><a name="l14219"></a><span class="lineno">14219</span>&#160;struct soap soap; </div><div class="line"><a name="l14220"></a><span class="lineno">14220</span>&#160;soap_init(&amp;soap); </div><div class="line"><a name="l14221"></a><span class="lineno">14221</span>&#160;soap.cookie_max = 10;</div><div class="line"><a name="l14222"></a><span class="lineno">14222</span>&#160;```</div><div class="line"><a name="l14223"></a><span class="lineno">14223</span>&#160;</div><div class="line"><a name="l14224"></a><span class="lineno">14224</span>&#160;The cookie database is a linked list pointed to by `soap.cookies` where each node is declared as:</div><div class="line"><a name="l14225"></a><span class="lineno">14225</span>&#160;</div><div class="line"><a name="l14226"></a><span class="lineno">14226</span>&#160;```cpp</div><div class="line"><a name="l14227"></a><span class="lineno">14227</span>&#160;struct soap_cookie </div><div class="line"><a name="l14228"></a><span class="lineno">14228</span>&#160;{ </div><div class="line"><a name="l14229"></a><span class="lineno">14229</span>&#160;   char *name; </div><div class="line"><a name="l14230"></a><span class="lineno">14230</span>&#160;   char *value; </div><div class="line"><a name="l14231"></a><span class="lineno">14231</span>&#160;   char *domain; </div><div class="line"><a name="l14232"></a><span class="lineno">14232</span>&#160;   char *path; </div><div class="line"><a name="l14233"></a><span class="lineno">14233</span>&#160;   long expire; /* client-side: local time to expire; server-side: seconds to expire */ </div><div class="line"><a name="l14234"></a><span class="lineno">14234</span>&#160;   unsigned int version; </div><div class="line"><a name="l14235"></a><span class="lineno">14235</span>&#160;   short secure; </div><div class="line"><a name="l14236"></a><span class="lineno">14236</span>&#160;   short session; /* server-side */ </div><div class="line"><a name="l14237"></a><span class="lineno">14237</span>&#160;   short env; /* server-side: 1 = got cookie from client */ </div><div class="line"><a name="l14238"></a><span class="lineno">14238</span>&#160;   short modified; /* server-side: 1 = client cookie was modified */ </div><div class="line"><a name="l14239"></a><span class="lineno">14239</span>&#160;   struct soap_cookie *next; </div><div class="line"><a name="l14240"></a><span class="lineno">14240</span>&#160;};</div><div class="line"><a name="l14241"></a><span class="lineno">14241</span>&#160;```</div><div class="line"><a name="l14242"></a><span class="lineno">14242</span>&#160;</div><div class="line"><a name="l14243"></a><span class="lineno">14243</span>&#160;Since the cookie database is linked to a `soap` struct, each thread has a local cookie database in a multi-threaded</div><div class="line"><a name="l14244"></a><span class="lineno">14244</span>&#160;implementation.</div><div class="line"><a name="l14245"></a><span class="lineno">14245</span>&#160;</div><div class="line"><a name="l14246"></a><span class="lineno">14246</span>&#160;## Server-Side Cookie Support        {#servercookie}</div><div class="line"><a name="l14247"></a><span class="lineno">14247</span>&#160;</div><div class="line"><a name="l14248"></a><span class="lineno">14248</span>&#160;Server-side cookie support is optional. To enable cookie support, compile all sources with option `-DWITH_COOKIES`, for example:</div><div class="line"><a name="l14249"></a><span class="lineno">14249</span>&#160;</div><div class="line"><a name="l14250"></a><span class="lineno">14250</span>&#160;    &gt; c++ -DWITH_COOKIES -o myserver ...</div><div class="line"><a name="l14251"></a><span class="lineno">14251</span>&#160;</div><div class="line"><a name="l14252"></a><span class="lineno">14252</span>&#160;gSOAP provides the following cookie API for server-side cookie session control:</div><div class="line"><a name="l14253"></a><span class="lineno">14253</span>&#160;</div><div class="line"><a name="l14254"></a><span class="lineno">14254</span>&#160;* `struct soap_cookie *soap_set_cookie(struct soap *soap, const char *name, const char *value, const char *domain, const char *path);` </div><div class="line"><a name="l14255"></a><span class="lineno">14255</span>&#160;  Add a cookie to the database with name `name` and value `value`.  `domain`</div><div class="line"><a name="l14256"></a><span class="lineno">14256</span>&#160;  and `path` may be NULL to use the current domain and path given by</div><div class="line"><a name="l14257"></a><span class="lineno">14257</span>&#160;  `soap_cookie_domain` and `soap_cookie_path`.  If successful, returns pointer</div><div class="line"><a name="l14258"></a><span class="lineno">14258</span>&#160;  to a cookie node in the linked list, or NULL otherwise.</div><div class="line"><a name="l14259"></a><span class="lineno">14259</span>&#160;</div><div class="line"><a name="l14260"></a><span class="lineno">14260</span>&#160;* `struct soap_cookie *soap_cookie(struct soap *soap, const char *name, const char *domain, const char *path);` </div><div class="line"><a name="l14261"></a><span class="lineno">14261</span>&#160;  Find a cookie in the database with name `name` and value `value`.  `domain`</div><div class="line"><a name="l14262"></a><span class="lineno">14262</span>&#160;  and `path` may be NULL to use the current domain and path given by</div><div class="line"><a name="l14263"></a><span class="lineno">14263</span>&#160;  `soap_cookie_domain` and `soap_cookie_path`.  If successful, returns pointer</div><div class="line"><a name="l14264"></a><span class="lineno">14264</span>&#160;  to a cookie node in the linked list, or NULL otherwise.</div><div class="line"><a name="l14265"></a><span class="lineno">14265</span>&#160;</div><div class="line"><a name="l14266"></a><span class="lineno">14266</span>&#160;* `char *soap_cookie_value(struct soap *soap, const char *name, const char *domain, const char *path);` </div><div class="line"><a name="l14267"></a><span class="lineno">14267</span>&#160;  Get value of a cookie in the database with name `name`.  `domain` and `path`</div><div class="line"><a name="l14268"></a><span class="lineno">14268</span>&#160;  may be NULL to use the current domain and path given by `soap_cookie_domain`</div><div class="line"><a name="l14269"></a><span class="lineno">14269</span>&#160;  and `soap_cookie_path`.  If successful, returns the string pointer to the</div><div class="line"><a name="l14270"></a><span class="lineno">14270</span>&#160;  value, or NULL otherwise.</div><div class="line"><a name="l14271"></a><span class="lineno">14271</span>&#160;</div><div class="line"><a name="l14272"></a><span class="lineno">14272</span>&#160;* `long soap_cookie_expire(struct soap *soap, const char *name, const char *domain, const char *path);` </div><div class="line"><a name="l14273"></a><span class="lineno">14273</span>&#160;  Get expiration value of the cookie in the database with name `name` (in</div><div class="line"><a name="l14274"></a><span class="lineno">14274</span>&#160;      seconds).  `domain` and `path` may be NULL to use the current domain and</div><div class="line"><a name="l14275"></a><span class="lineno">14275</span>&#160;  path given by `soap_cookie_domain` and `soap_cookie_path`.  Returns the</div><div class="line"><a name="l14276"></a><span class="lineno">14276</span>&#160;  expiration value, or -1 if cookie does not exist.</div><div class="line"><a name="l14277"></a><span class="lineno">14277</span>&#160;</div><div class="line"><a name="l14278"></a><span class="lineno">14278</span>&#160;* `int soap_set_cookie_expire(struct soap *soap, const char *name, long expire, const char *domain, const char *path);` </div><div class="line"><a name="l14279"></a><span class="lineno">14279</span>&#160;  Set expiration value `expire` of the cookie in the database with name `name`</div><div class="line"><a name="l14280"></a><span class="lineno">14280</span>&#160;  (in seconds).  `domain` and `path` may be NULL to use the current domain and</div><div class="line"><a name="l14281"></a><span class="lineno">14281</span>&#160;  path given by `soap_cookie_domain` and `soap_cookie_path`.  If successful,</div><div class="line"><a name="l14282"></a><span class="lineno">14282</span>&#160;  returns `SOAP_OK`, or `SOAP_EOF` otherwise.</div><div class="line"><a name="l14283"></a><span class="lineno">14283</span>&#160;</div><div class="line"><a name="l14284"></a><span class="lineno">14284</span>&#160;* `int soap_set_cookie_session(struct soap *soap, const char *name, const char *domain, const char *path);` </div><div class="line"><a name="l14285"></a><span class="lineno">14285</span>&#160;  Set cookie in the database with name `name` to be a session cookie.  This</div><div class="line"><a name="l14286"></a><span class="lineno">14286</span>&#160;  means that the cookie will be returned to the client.  (Only cookies that are</div><div class="line"><a name="l14287"></a><span class="lineno">14287</span>&#160;  modified are returned to the client).  `domain` and `path` may be NULL to</div><div class="line"><a name="l14288"></a><span class="lineno">14288</span>&#160;  use the current domain and path given by `soap_cookie_domain` and</div><div class="line"><a name="l14289"></a><span class="lineno">14289</span>&#160;  `soap_cookie_path`.  If successful, returns `SOAP_OK`, or `SOAP_EOF`</div><div class="line"><a name="l14290"></a><span class="lineno">14290</span>&#160;  otherwise.</div><div class="line"><a name="l14291"></a><span class="lineno">14291</span>&#160;</div><div class="line"><a name="l14292"></a><span class="lineno">14292</span>&#160;* `int soap_clr_cookie_session(struct soap *soap, const char *name, const char *domain, const char *path);` </div><div class="line"><a name="l14293"></a><span class="lineno">14293</span>&#160;  Clear cookie in the database with name `name` to be a session cookie.</div><div class="line"><a name="l14294"></a><span class="lineno">14294</span>&#160;  `domain` and `path` may be NULL to use the current domain and path given by</div><div class="line"><a name="l14295"></a><span class="lineno">14295</span>&#160;  `soap_cookie_domain` and `soap_cookie_path`.  If successful, returns</div><div class="line"><a name="l14296"></a><span class="lineno">14296</span>&#160;  `SOAP_OK`, or `SOAP_EOF` otherwise.</div><div class="line"><a name="l14297"></a><span class="lineno">14297</span>&#160;</div><div class="line"><a name="l14298"></a><span class="lineno">14298</span>&#160;* `void soap_clr_cookie(struct soap *soap, const char *name, const char *domain, const char *path);` </div><div class="line"><a name="l14299"></a><span class="lineno">14299</span>&#160;  Remove cookie from the database with name `name`.  `domain` and `path` may be</div><div class="line"><a name="l14300"></a><span class="lineno">14300</span>&#160;  NULL to use the current domain and path given by `soap_cookie_domain` and</div><div class="line"><a name="l14301"></a><span class="lineno">14301</span>&#160;  `soap_cookie_path`.</div><div class="line"><a name="l14302"></a><span class="lineno">14302</span>&#160;</div><div class="line"><a name="l14303"></a><span class="lineno">14303</span>&#160;* `int soap_getenv_cookies(struct soap *soap);` </div><div class="line"><a name="l14304"></a><span class="lineno">14304</span>&#160;  Initializes cookie database by reading the `HTTP_COOKIE` environment</div><div class="line"><a name="l14305"></a><span class="lineno">14305</span>&#160;  variable.  This provides a means for a CGI application to read cookies send</div><div class="line"><a name="l14306"></a><span class="lineno">14306</span>&#160;  by a client.  If successful, returns `SOAP_OK`, or `SOAP_EOF` otherwise.</div><div class="line"><a name="l14307"></a><span class="lineno">14307</span>&#160;</div><div class="line"><a name="l14308"></a><span class="lineno">14308</span>&#160;* `void soap_free_cookies(struct soap *soap);` </div><div class="line"><a name="l14309"></a><span class="lineno">14309</span>&#160;  Release cookie database. </div><div class="line"><a name="l14310"></a><span class="lineno">14310</span>&#160;</div><div class="line"><a name="l14311"></a><span class="lineno">14311</span>&#160;The following global variables are used to define the current domain and path:</div><div class="line"><a name="l14312"></a><span class="lineno">14312</span>&#160;</div><div class="line"><a name="l14313"></a><span class="lineno">14313</span>&#160;* `const char *cookie_domain` MUST be set to the domain (host) of the service </div><div class="line"><a name="l14314"></a><span class="lineno">14314</span>&#160;</div><div class="line"><a name="l14315"></a><span class="lineno">14315</span>&#160;* `const char *cookie_path` MAY be set to the default path to the service </div><div class="line"><a name="l14316"></a><span class="lineno">14316</span>&#160;</div><div class="line"><a name="l14317"></a><span class="lineno">14317</span>&#160;* `int cookie_max` maximum cookie database size (default=32) </div><div class="line"><a name="l14318"></a><span class="lineno">14318</span>&#160;</div><div class="line"><a name="l14319"></a><span class="lineno">14319</span>&#160;The `cookie_path` value is used to filter cookies intended for this service according to the path prefix rules outlined in</div><div class="line"><a name="l14320"></a><span class="lineno">14320</span>&#160;RFC2109.</div><div class="line"><a name="l14321"></a><span class="lineno">14321</span>&#160;</div><div class="line"><a name="l14322"></a><span class="lineno">14322</span>&#160;The following example server adopts cookies for session control:</div><div class="line"><a name="l14323"></a><span class="lineno">14323</span>&#160;</div><div class="line"><a name="l14324"></a><span class="lineno">14324</span>&#160;```cpp</div><div class="line"><a name="l14325"></a><span class="lineno">14325</span>&#160;int main() </div><div class="line"><a name="l14326"></a><span class="lineno">14326</span>&#160;{ </div><div class="line"><a name="l14327"></a><span class="lineno">14327</span>&#160;   struct soap soap; </div><div class="line"><a name="l14328"></a><span class="lineno">14328</span>&#160;   int m, s; </div><div class="line"><a name="l14329"></a><span class="lineno">14329</span>&#160;   soap_init(&amp;soap); </div><div class="line"><a name="l14330"></a><span class="lineno">14330</span>&#160;   soap.cookie_domain = &quot;...&quot;; </div><div class="line"><a name="l14331"></a><span class="lineno">14331</span>&#160;   soap.cookie_path = &quot;/&quot;; // the path which is used to filter/set cookies with this destination </div><div class="line"><a name="l14332"></a><span class="lineno">14332</span>&#160;   if (argc &lt; 2) </div><div class="line"><a name="l14333"></a><span class="lineno">14333</span>&#160;   { </div><div class="line"><a name="l14334"></a><span class="lineno">14334</span>&#160;     soap_getenv_cookies(&amp;soap); // CGI app: grab cookies from &#39;HTTP_COOKIE&#39; env var </div><div class="line"><a name="l14335"></a><span class="lineno">14335</span>&#160;     soap_serve(&amp;soap); </div><div class="line"><a name="l14336"></a><span class="lineno">14336</span>&#160;   } </div><div class="line"><a name="l14337"></a><span class="lineno">14337</span>&#160;   else </div><div class="line"><a name="l14338"></a><span class="lineno">14338</span>&#160;   { </div><div class="line"><a name="l14339"></a><span class="lineno">14339</span>&#160;     m = soap_bind(&amp;soap, NULL, atoi(argv[1]), 100); </div><div class="line"><a name="l14340"></a><span class="lineno">14340</span>&#160;     if (m &lt; 0) </div><div class="line"><a name="l14341"></a><span class="lineno">14341</span>&#160;       exit(1); </div><div class="line"><a name="l14342"></a><span class="lineno">14342</span>&#160;     for (int i = 1; ; i++) </div><div class="line"><a name="l14343"></a><span class="lineno">14343</span>&#160;     { </div><div class="line"><a name="l14344"></a><span class="lineno">14344</span>&#160;       s = soap_accept(&amp;soap); </div><div class="line"><a name="l14345"></a><span class="lineno">14345</span>&#160;       if (s &lt; 0) </div><div class="line"><a name="l14346"></a><span class="lineno">14346</span>&#160;         exit(1); </div><div class="line"><a name="l14347"></a><span class="lineno">14347</span>&#160;       soap_serve(&amp;soap); </div><div class="line"><a name="l14348"></a><span class="lineno">14348</span>&#160;       soap_end(&amp;soap);         // clean up  </div><div class="line"><a name="l14349"></a><span class="lineno">14349</span>&#160;       soap_free_cookies(&amp;soap);        // remove all old cookies from database so no interference occurs with the arrival of new cookies </div><div class="line"><a name="l14350"></a><span class="lineno">14350</span>&#160;     } </div><div class="line"><a name="l14351"></a><span class="lineno">14351</span>&#160;   } </div><div class="line"><a name="l14352"></a><span class="lineno">14352</span>&#160;   return 0; </div><div class="line"><a name="l14353"></a><span class="lineno">14353</span>&#160;} </div><div class="line"><a name="l14354"></a><span class="lineno">14354</span>&#160;int ck__demo(struct soap *soap, ...) </div><div class="line"><a name="l14355"></a><span class="lineno">14355</span>&#160;{ </div><div class="line"><a name="l14356"></a><span class="lineno">14356</span>&#160;   int n; </div><div class="line"><a name="l14357"></a><span class="lineno">14357</span>&#160;   const char *s; </div><div class="line"><a name="l14358"></a><span class="lineno">14358</span>&#160;   s = soap_cookie_value(soap, &quot;demo&quot;, NULL, NULL); // cookie returned by client? </div><div class="line"><a name="l14359"></a><span class="lineno">14359</span>&#160;   if (!s) </div><div class="line"><a name="l14360"></a><span class="lineno">14360</span>&#160;     s = &quot;init-value&quot;; // no: set initial cookie value </div><div class="line"><a name="l14361"></a><span class="lineno">14361</span>&#160;   else </div><div class="line"><a name="l14362"></a><span class="lineno">14362</span>&#160;     ... // modify &#39;s&#39; to reflect session control </div><div class="line"><a name="l14363"></a><span class="lineno">14363</span>&#160;   soap_set_cookie(soap, &quot;demo&quot;, s, NULL, NULL); </div><div class="line"><a name="l14364"></a><span class="lineno">14364</span>&#160;   soap_set_cookie_expire(soap, &quot;demo&quot;, 5, NULL, NULL); // cookie may expire at client-side in 5 seconds </div><div class="line"><a name="l14365"></a><span class="lineno">14365</span>&#160;   return SOAP_OK; </div><div class="line"><a name="l14366"></a><span class="lineno">14366</span>&#160;}</div><div class="line"><a name="l14367"></a><span class="lineno">14367</span>&#160;```</div><div class="line"><a name="l14368"></a><span class="lineno">14368</span>&#160;</div><div class="line"><a name="l14369"></a><span class="lineno">14369</span>&#160;## Connecting Clients Through Proxy Servers</div><div class="line"><a name="l14370"></a><span class="lineno">14370</span>&#160;</div><div class="line"><a name="l14371"></a><span class="lineno">14371</span>&#160;When a client needs to connect to a Web Service through a proxy server, set the `soap.proxy_host` string and</div><div class="line"><a name="l14372"></a><span class="lineno">14372</span>&#160;`soap.proxy_port` integer attributes of the current `soap` runtime context to the proxy&#39;s host name and port, respectively. For example:</div><div class="line"><a name="l14373"></a><span class="lineno">14373</span>&#160;</div><div class="line"><a name="l14374"></a><span class="lineno">14374</span>&#160;```cpp</div><div class="line"><a name="l14375"></a><span class="lineno">14375</span>&#160;struct soap soap; </div><div class="line"><a name="l14376"></a><span class="lineno">14376</span>&#160;soap_init(&amp;soap); </div><div class="line"><a name="l14377"></a><span class="lineno">14377</span>&#160;soap.proxy_host = &quot;proxyhostname&quot;; </div><div class="line"><a name="l14378"></a><span class="lineno">14378</span>&#160;soap.proxy_port = 8080; </div><div class="line"><a name="l14379"></a><span class="lineno">14379</span>&#160;if (soap_call_ns__method(&amp;soap, &quot;http://host:port/path&quot;, &quot;action&quot;, ...)) </div><div class="line"><a name="l14380"></a><span class="lineno">14380</span>&#160;   soap_print_fault(&amp;soap, stderr); </div><div class="line"><a name="l14381"></a><span class="lineno">14381</span>&#160;else </div><div class="line"><a name="l14382"></a><span class="lineno">14382</span>&#160;   ...</div><div class="line"><a name="l14383"></a><span class="lineno">14383</span>&#160;```</div><div class="line"><a name="l14384"></a><span class="lineno">14384</span>&#160;</div><div class="line"><a name="l14385"></a><span class="lineno">14385</span>&#160;The context attributes `soap.proxy_host` and `soap.proxy_port` keep their values through a sequence of service operation calls,</div><div class="line"><a name="l14386"></a><span class="lineno">14386</span>&#160;so they only need to be set once.</div><div class="line"><a name="l14387"></a><span class="lineno">14387</span>&#160;</div><div class="line"><a name="l14388"></a><span class="lineno">14388</span>&#160;When X-Forwarded-For headers are returned by the proxy, the header can be accessed in the `soap.proxy_from` string.</div><div class="line"><a name="l14389"></a><span class="lineno">14389</span>&#160;</div><div class="line"><a name="l14390"></a><span class="lineno">14390</span>&#160;## Bind Before Connect and Setting the Client Interface Address</div><div class="line"><a name="l14391"></a><span class="lineno">14391</span>&#160;</div><div class="line"><a name="l14392"></a><span class="lineno">14392</span>&#160;To bind the client to a port before connect, set the `soap.client_port` to a non-negative port number:</div><div class="line"><a name="l14393"></a><span class="lineno">14393</span>&#160;</div><div class="line"><a name="l14394"></a><span class="lineno">14394</span>&#160;```cpp</div><div class="line"><a name="l14395"></a><span class="lineno">14395</span>&#160;struct soap soap; </div><div class="line"><a name="l14396"></a><span class="lineno">14396</span>&#160;soap_init(&amp;soap); </div><div class="line"><a name="l14397"></a><span class="lineno">14397</span>&#160;soap.client_port = ...; // non-negative port number </div><div class="line"><a name="l14398"></a><span class="lineno">14398</span>&#160;if (soap_call_ns__method(&amp;soap, &quot;http://host:port/path&quot;, &quot;action&quot;, ...)) </div><div class="line"><a name="l14399"></a><span class="lineno">14399</span>&#160;   soap_print_fault(&amp;soap, stderr); </div><div class="line"><a name="l14400"></a><span class="lineno">14400</span>&#160;else </div><div class="line"><a name="l14401"></a><span class="lineno">14401</span>&#160;   ...</div><div class="line"><a name="l14402"></a><span class="lineno">14402</span>&#160;```</div><div class="line"><a name="l14403"></a><span class="lineno">14403</span>&#160;</div><div class="line"><a name="l14404"></a><span class="lineno">14404</span>&#160;This port number is used only once and reset to -1 (disabled).  Set it again for the next call.</div><div class="line"><a name="l14405"></a><span class="lineno">14405</span>&#160;</div><div class="line"><a name="l14406"></a><span class="lineno">14406</span>&#160;To set a client interface address for the connection that is an IP address of the client:</div><div class="line"><a name="l14407"></a><span class="lineno">14407</span>&#160;</div><div class="line"><a name="l14408"></a><span class="lineno">14408</span>&#160;```cpp</div><div class="line"><a name="l14409"></a><span class="lineno">14409</span>&#160;struct soap soap; </div><div class="line"><a name="l14410"></a><span class="lineno">14410</span>&#160;soap_init(&amp;soap); </div><div class="line"><a name="l14411"></a><span class="lineno">14411</span>&#160;soap.client_interface = &quot;...&quot;; // IP address </div><div class="line"><a name="l14412"></a><span class="lineno">14412</span>&#160;if (soap_call_ns__method(&amp;soap, &quot;http://host:port/path&quot;, &quot;action&quot;, ...)) </div><div class="line"><a name="l14413"></a><span class="lineno">14413</span>&#160;   soap_print_fault(&amp;soap, stderr); </div><div class="line"><a name="l14414"></a><span class="lineno">14414</span>&#160;else </div><div class="line"><a name="l14415"></a><span class="lineno">14415</span>&#160;   ...</div><div class="line"><a name="l14416"></a><span class="lineno">14416</span>&#160;```</div><div class="line"><a name="l14417"></a><span class="lineno">14417</span>&#160;</div><div class="line"><a name="l14418"></a><span class="lineno">14418</span>&#160;This client interface address string is used only once and reset to NULL (disabled).  Set it again for the next call.  This feature is not available when compiling the code on windows.</div><div class="line"><a name="l14419"></a><span class="lineno">14419</span>&#160;</div><div class="line"><a name="l14420"></a><span class="lineno">14420</span>&#160;## FastCGI Support        {#fastcgi}</div><div class="line"><a name="l14421"></a><span class="lineno">14421</span>&#160;</div><div class="line"><a name="l14422"></a><span class="lineno">14422</span>&#160;To enable FastCGI support, install FastCGI and compile *all* sources (do</div><div class="line"><a name="l14423"></a><span class="lineno">14423</span>&#160;not use `libgsoap` but compile `stdsoap2.c`) and your application</div><div class="line"><a name="l14424"></a><span class="lineno">14424</span>&#160;sources with option `-DWITH_FASTCGI` or add</div><div class="line"><a name="l14425"></a><span class="lineno">14425</span>&#160;</div><div class="line"><a name="l14426"></a><span class="lineno">14426</span>&#160;```cpp</div><div class="line"><a name="l14427"></a><span class="lineno">14427</span>&#160;#define WITH_FASTCGI</div><div class="line"><a name="l14428"></a><span class="lineno">14428</span>&#160;```</div><div class="line"><a name="l14429"></a><span class="lineno">14429</span>&#160;</div><div class="line"><a name="l14430"></a><span class="lineno">14430</span>&#160;to `stdsoap2.h` and recompile the project code.</div><div class="line"><a name="l14431"></a><span class="lineno">14431</span>&#160;</div><div class="line"><a name="l14432"></a><span class="lineno">14432</span>&#160;@warning Do not link against the `libgsoap` libraries as these are not</div><div class="line"><a name="l14433"></a><span class="lineno">14433</span>&#160;suitable for FastCGI. Compile `stdsoap2.c` (or `stdsoap2.cpp`) instead.</div><div class="line"><a name="l14434"></a><span class="lineno">14434</span>&#160;</div><div class="line"><a name="l14435"></a><span class="lineno">14435</span>&#160;## How to Create gSOAP Applications With a Small Memory Footprint        {#lean}</div><div class="line"><a name="l14436"></a><span class="lineno">14436</span>&#160;</div><div class="line"><a name="l14437"></a><span class="lineno">14437</span>&#160;To compile gSOAP applications intended for small memory devices, you may want</div><div class="line"><a name="l14438"></a><span class="lineno">14438</span>&#160;to remove all non-essential features that consume precious code and data space.</div><div class="line"><a name="l14439"></a><span class="lineno">14439</span>&#160;To do this, compile the gSOAP sources with `-DWITH_LEAN` (i.e. `#define WITH_LEAN`) to remove many</div><div class="line"><a name="l14440"></a><span class="lineno">14440</span>&#160;non-essential features. The features that will be disabled are:</div><div class="line"><a name="l14441"></a><span class="lineno">14441</span>&#160;</div><div class="line"><a name="l14442"></a><span class="lineno">14442</span>&#160;</div><div class="line"><a name="l14443"></a><span class="lineno">14443</span>&#160;*  No I/O timeouts. Note that many socket operations already obey some form of timeout handling, such as a connect timeout for example.</div><div class="line"><a name="l14444"></a><span class="lineno">14444</span>&#160;</div><div class="line"><a name="l14445"></a><span class="lineno">14445</span>&#160;*  No UDP support</div><div class="line"><a name="l14446"></a><span class="lineno">14446</span>&#160;</div><div class="line"><a name="l14447"></a><span class="lineno">14447</span>&#160;*  No HTTP keep alive</div><div class="line"><a name="l14448"></a><span class="lineno">14448</span>&#160;</div><div class="line"><a name="l14449"></a><span class="lineno">14449</span>&#160;*  No HTTP cookies</div><div class="line"><a name="l14450"></a><span class="lineno">14450</span>&#160;</div><div class="line"><a name="l14451"></a><span class="lineno">14451</span>&#160;*  No HTTP authentication</div><div class="line"><a name="l14452"></a><span class="lineno">14452</span>&#160;</div><div class="line"><a name="l14453"></a><span class="lineno">14453</span>&#160;*  No HTTP chunked output (but input is OK)</div><div class="line"><a name="l14454"></a><span class="lineno">14454</span>&#160;</div><div class="line"><a name="l14455"></a><span class="lineno">14455</span>&#160;*  No HTTP compressed output (but input is OK when compiled with `WITH_GZIP`)</div><div class="line"><a name="l14456"></a><span class="lineno">14456</span>&#160;</div><div class="line"><a name="l14457"></a><span class="lineno">14457</span>&#160;*  No send/recv timeouts</div><div class="line"><a name="l14458"></a><span class="lineno">14458</span>&#160;</div><div class="line"><a name="l14459"></a><span class="lineno">14459</span>&#160;*  No socket flags (no `soap.socket_flag, soap.connect_flag, soap.bind_flag, soap.accept_flag`)</div><div class="line"><a name="l14460"></a><span class="lineno">14460</span>&#160;</div><div class="line"><a name="l14461"></a><span class="lineno">14461</span>&#160;*  No canonical XML output</div><div class="line"><a name="l14462"></a><span class="lineno">14462</span>&#160;</div><div class="line"><a name="l14463"></a><span class="lineno">14463</span>&#160;*  No logging</div><div class="line"><a name="l14464"></a><span class="lineno">14464</span>&#160;</div><div class="line"><a name="l14465"></a><span class="lineno">14465</span>&#160;*  Limited TCP/IP and HTTP error diagnostic messages</div><div class="line"><a name="l14466"></a><span class="lineno">14466</span>&#160;</div><div class="line"><a name="l14467"></a><span class="lineno">14467</span>&#160;*  No support for `time_t` serialization</div><div class="line"><a name="l14468"></a><span class="lineno">14468</span>&#160;</div><div class="line"><a name="l14469"></a><span class="lineno">14469</span>&#160;*  No support for `hexBinary` XML attribute serialization (remap `hexBinary` to strings by adding a remap entry to typemap.dat)</div><div class="line"><a name="l14470"></a><span class="lineno">14470</span>&#160;</div><div class="line"><a name="l14471"></a><span class="lineno">14471</span>&#160;Use `-DWITH_LEANER` to make the executable even smaller by removing DIME</div><div class="line"><a name="l14472"></a><span class="lineno">14472</span>&#160;and MIME attachment handling, `LONG64` (64 bit) serialization, `wchar_t*` serialization, and support for XML DOM operations.</div><div class="line"><a name="l14473"></a><span class="lineno">14473</span>&#160;Note that DIME/MIME attachments are not essential to achieve</div><div class="line"><a name="l14474"></a><span class="lineno">14474</span>&#160;SOAP/XML interoperability.  DIME attachments are a convenient way to exchange</div><div class="line"><a name="l14475"></a><span class="lineno">14475</span>&#160;non-text-based (i.e. binary) content, but are not required for basic SOAP/XML</div><div class="line"><a name="l14476"></a><span class="lineno">14476</span>&#160;interoperability.  Attachment requirements are predictable.  That is,</div><div class="line"><a name="l14477"></a><span class="lineno">14477</span>&#160;applications won&#39;t suddenly decide to use DIME or MIME instead of XML to exchange</div><div class="line"><a name="l14478"></a><span class="lineno">14478</span>&#160;content.</div><div class="line"><a name="l14479"></a><span class="lineno">14479</span>&#160;</div><div class="line"><a name="l14480"></a><span class="lineno">14480</span>&#160;It is safe to try to compile your application with `-DWITH_LEAN`, provided</div><div class="line"><a name="l14481"></a><span class="lineno">14481</span>&#160;that your application does not rely on I/O timeouts. When no linkage error</div><div class="line"><a name="l14482"></a><span class="lineno">14482</span>&#160;occurs in the compilation process, it is safe to assume that your application</div><div class="line"><a name="l14483"></a><span class="lineno">14483</span>&#160;will run just fine.</div><div class="line"><a name="l14484"></a><span class="lineno">14484</span>&#160;</div><div class="line"><a name="l14485"></a><span class="lineno">14485</span>&#160;## How to Eliminate BSD Socket Library Linkage        {#noio}</div><div class="line"><a name="l14486"></a><span class="lineno">14486</span>&#160;</div><div class="line"><a name="l14487"></a><span class="lineno">14487</span>&#160;The `stdsoap2.c` and `stdsoap2.cpp` gSOAP runtime libraries should be linked with a BSD socket library in the project build, e.g. winsock2 for Win32. To eliminate the need to link a socket library, you can compile `stdsoap2.c` (for C) and `stdsoap2.cpp` (for C++) with the `-DWITH_NOIO` macro set (i.e. `#define WITH_NOIO`). This eliminates the dependency on the BSD socket API, IO streams, `FILE` type, and `errno`.</div><div class="line"><a name="l14488"></a><span class="lineno">14488</span>&#160;</div><div class="line"><a name="l14489"></a><span class="lineno">14489</span>&#160;As a consequence, you MUST define callbacks to replace the missing socket stack. To do so, add to your code the following definitions:</div><div class="line"><a name="l14490"></a><span class="lineno">14490</span>&#160;</div><div class="line"><a name="l14491"></a><span class="lineno">14491</span>&#160;```cpp</div><div class="line"><a name="l14492"></a><span class="lineno">14492</span>&#160;struct soap soap; </div><div class="line"><a name="l14493"></a><span class="lineno">14493</span>&#160;soap_init(&amp;soap); </div><div class="line"><a name="l14494"></a><span class="lineno">14494</span>&#160;/* fsend is used to transmit data in blocks */ </div><div class="line"><a name="l14495"></a><span class="lineno">14495</span>&#160;soap.fsend = my_send; </div><div class="line"><a name="l14496"></a><span class="lineno">14496</span>&#160;/* frecv is used to receive data in blocks */ </div><div class="line"><a name="l14497"></a><span class="lineno">14497</span>&#160;soap.frecv = my_recv; </div><div class="line"><a name="l14498"></a><span class="lineno">14498</span>&#160;/* fopen is used to connect */ </div><div class="line"><a name="l14499"></a><span class="lineno">14499</span>&#160;soap.fopen = my_tcp_connect; </div><div class="line"><a name="l14500"></a><span class="lineno">14500</span>&#160;/* fclose is used to disconnect */ </div><div class="line"><a name="l14501"></a><span class="lineno">14501</span>&#160;soap.fclose = my_tcp_disconnect; </div><div class="line"><a name="l14502"></a><span class="lineno">14502</span>&#160;/* fclosesocket is used only to close the master socket in a server upon soap_done() */ </div><div class="line"><a name="l14503"></a><span class="lineno">14503</span>&#160;soap.fclosesocket = my_tcp_closesocket; </div><div class="line"><a name="l14504"></a><span class="lineno">14504</span>&#160;/* fshutdownsocket is used after completing a send operation to send TCP FIN */ </div><div class="line"><a name="l14505"></a><span class="lineno">14505</span>&#160;soap.fshutdownsocket = my_tcp_shutdownsocket; </div><div class="line"><a name="l14506"></a><span class="lineno">14506</span>&#160;/* setting fpoll is optional, leave it NULL to omit polling the server */ </div><div class="line"><a name="l14507"></a><span class="lineno">14507</span>&#160;soap.fpoll = my_poll; </div><div class="line"><a name="l14508"></a><span class="lineno">14508</span>&#160;/* faccept is used only by a server application */ </div><div class="line"><a name="l14509"></a><span class="lineno">14509</span>&#160;soap.faccept = my_accept;</div><div class="line"><a name="l14510"></a><span class="lineno">14510</span>&#160;```</div><div class="line"><a name="l14511"></a><span class="lineno">14511</span>&#160;</div><div class="line"><a name="l14512"></a><span class="lineno">14512</span>&#160;These functions are supposed to provide a (minimal) transport stack.</div><div class="line"><a name="l14513"></a><span class="lineno">14513</span>&#160;See Section \ref callback  for more details on the use of these callbacks.</div><div class="line"><a name="l14514"></a><span class="lineno">14514</span>&#160;All callback function pointers should be non-NULL, except `fpoll`.</div><div class="line"><a name="l14515"></a><span class="lineno">14515</span>&#160;</div><div class="line"><a name="l14516"></a><span class="lineno">14516</span>&#160;You cannot use `soap_print_fault` and `soap_print_fault_location` to print error diagnostics. Instead, the value of `soap.error`, which contains the gSOAP error code, can be used to determine the cause of a fault.</div><div class="line"><a name="l14517"></a><span class="lineno">14517</span>&#160;</div><div class="line"><a name="l14518"></a><span class="lineno">14518</span>&#160;## How to Combine Multiple Client and Server Implementations into one Executable</div><div class="line"><a name="l14519"></a><span class="lineno">14519</span>&#160;</div><div class="line"><a name="l14520"></a><span class="lineno">14520</span>&#160;The `wsdl2h` tool can be used to import multiple WSDLs and schemas at once.</div><div class="line"><a name="l14521"></a><span class="lineno">14521</span>&#160;The service definitions are combined in one header file to be parsed by</div><div class="line"><a name="l14522"></a><span class="lineno">14522</span>&#160;`soapcpp2`. It is important to assign namespace prefixes to namespace URIs</div><div class="line"><a name="l14523"></a><span class="lineno">14523</span>&#160;using the `typemap.dat` file. Otherwise, `wsdl2h` will assign namespace</div><div class="line"><a name="l14524"></a><span class="lineno">14524</span>&#160;prefixes `ns1`, `ns2`, and so on to the service operations and schema</div><div class="line"><a name="l14525"></a><span class="lineno">14525</span>&#160;types. Thus, any change to a WSDL or schema may result in a new prefix</div><div class="line"><a name="l14526"></a><span class="lineno">14526</span>&#160;assignment. For more details, please see Section \ref typemap .</div><div class="line"><a name="l14527"></a><span class="lineno">14527</span>&#160;</div><div class="line"><a name="l14528"></a><span class="lineno">14528</span>&#160;Another approach to combine multiple client and service applications into one</div><div class="line"><a name="l14529"></a><span class="lineno">14529</span>&#160;executable is by using C++ namespaces to structurally separate the definitions</div><div class="line"><a name="l14530"></a><span class="lineno">14530</span>&#160;or by creating C libraries for the client/server objects as explained in</div><div class="line"><a name="l14531"></a><span class="lineno">14531</span>&#160;subsequent sections. This is automated with `wsdl2h` option `-q`.</div><div class="line"><a name="l14532"></a><span class="lineno">14532</span>&#160;</div><div class="line"><a name="l14533"></a><span class="lineno">14533</span>&#160;Both approaches are demonstrated by example in the gSOAP distribution, the `samples/link` (C only) and `samples/link++` (C++ with C++ namespaces) examples.</div><div class="line"><a name="l14534"></a><span class="lineno">14534</span>&#160;</div><div class="line"><a name="l14535"></a><span class="lineno">14535</span>&#160;## How to Build a Client or Server in a C++ Code Namespace        {#codenamespace}</div><div class="line"><a name="l14536"></a><span class="lineno">14536</span>&#160;</div><div class="line"><a name="l14537"></a><span class="lineno">14537</span>&#160;You can use a C++ code namespace of your choice in your header file to build</div><div class="line"><a name="l14538"></a><span class="lineno">14538</span>&#160;a client or server in that code namespace. In this way, you can create multiple</div><div class="line"><a name="l14539"></a><span class="lineno">14539</span>&#160;clients and servers that can be combined and linked together without conflicts,</div><div class="line"><a name="l14540"></a><span class="lineno">14540</span>&#160;which is explained in more detail in the next section (which also shows an</div><div class="line"><a name="l14541"></a><span class="lineno">14541</span>&#160;example combining two client libraries defined in two C++ code namespaces).</div><div class="line"><a name="l14542"></a><span class="lineno">14542</span>&#160;</div><div class="line"><a name="l14543"></a><span class="lineno">14543</span>&#160;Use `wsdl2h` option `-q`*name* to generate definitions in the C++ *name* namespace. This option can also be used in combination with C++ proxy and server object generation, using `soapcpp2` options `-i` (or `-j`) and `-p`.</div><div class="line"><a name="l14544"></a><span class="lineno">14544</span>&#160;</div><div class="line"><a name="l14545"></a><span class="lineno">14545</span>&#160;At most one namespace can be defined for the entire gSOAP header file. The code</div><div class="line"><a name="l14546"></a><span class="lineno">14546</span>&#160;namespace MUST completely encapsulate the entire contents of the header file:</div><div class="line"><a name="l14547"></a><span class="lineno">14547</span>&#160;</div><div class="line"><a name="l14548"></a><span class="lineno">14548</span>&#160;```cpp</div><div class="line"><a name="l14549"></a><span class="lineno">14549</span>&#160;namespace myNamespaceName { </div><div class="line"><a name="l14550"></a><span class="lineno">14550</span>&#160;... gSOAP header file contents ... </div><div class="line"><a name="l14551"></a><span class="lineno">14551</span>&#160;}</div><div class="line"><a name="l14552"></a><span class="lineno">14552</span>&#160;```</div><div class="line"><a name="l14553"></a><span class="lineno">14553</span>&#160;</div><div class="line"><a name="l14554"></a><span class="lineno">14554</span>&#160;When compiling this header file with the gSOAP `soapcpp2` compiler, all type definitions,</div><div class="line"><a name="l14555"></a><span class="lineno">14555</span>&#160;the (de)serializers for these types, and the stub/skeleton codes will be placed</div><div class="line"><a name="l14556"></a><span class="lineno">14556</span>&#160;in this namespace. The XML namespace mapping table (saved in a `.nsmap`</div><div class="line"><a name="l14557"></a><span class="lineno">14557</span>&#160;file) will not be placed in the code namespace to allow it to be linked as a</div><div class="line"><a name="l14558"></a><span class="lineno">14558</span>&#160;global object. You can use option `-n` to create local XML namespace</div><div class="line"><a name="l14559"></a><span class="lineno">14559</span>&#160;tables, see Section \ref options  (but remember that you explicitly need to</div><div class="line"><a name="l14560"></a><span class="lineno">14560</span>&#160;initialize the `soap.namespaces` to point to a table at run time). The</div><div class="line"><a name="l14561"></a><span class="lineno">14561</span>&#160;generated files are prefixed with the code namespace name instead of the usual</div><div class="line"><a name="l14562"></a><span class="lineno">14562</span>&#160;`soap` file name prefix to enable multiple client/server codes to be build</div><div class="line"><a name="l14563"></a><span class="lineno">14563</span>&#160;in the same project directory (a code namespace automatically sets the `-p`</div><div class="line"><a name="l14564"></a><span class="lineno">14564</span>&#160;compiler option, see Section \ref options  for options).</div><div class="line"><a name="l14565"></a><span class="lineno">14565</span>&#160;</div><div class="line"><a name="l14566"></a><span class="lineno">14566</span>&#160;Because the SOAP Header and Fault serialization codes will also be placed in</div><div class="line"><a name="l14567"></a><span class="lineno">14567</span>&#160;the namespace, they cannot be called from the `stdsoap2.cpp` run time</div><div class="line"><a name="l14568"></a><span class="lineno">14568</span>&#160;library code and are therefore rendered unusable. Therefore, these serializers</div><div class="line"><a name="l14569"></a><span class="lineno">14569</span>&#160;are not compiled at all (enforced with `#define WITH_NOGLOBAL`). To add SOAP</div><div class="line"><a name="l14570"></a><span class="lineno">14570</span>&#160;Header and Fault serializers, you MUST compile them separately as follows.</div><div class="line"><a name="l14571"></a><span class="lineno">14571</span>&#160;First, create a new header file `env.h` with the SOAP Header and Fault</div><div class="line"><a name="l14572"></a><span class="lineno">14572</span>&#160;definitions.  You can leave this header file empty if you want to use the</div><div class="line"><a name="l14573"></a><span class="lineno">14573</span>&#160;default SOAP Header and Fault. Then compile this header file with:</div><div class="line"><a name="l14574"></a><span class="lineno">14574</span>&#160;</div><div class="line"><a name="l14575"></a><span class="lineno">14575</span>&#160;    &gt; soapcpp2 -penv env.h</div><div class="line"><a name="l14576"></a><span class="lineno">14576</span>&#160;</div><div class="line"><a name="l14577"></a><span class="lineno">14577</span>&#160;The generated `envC.cpp` file holds the SOAP Header and Fault serializers and you can</div><div class="line"><a name="l14578"></a><span class="lineno">14578</span>&#160;link this file with your client or server application.</div><div class="line"><a name="l14579"></a><span class="lineno">14579</span>&#160;</div><div class="line"><a name="l14580"></a><span class="lineno">14580</span>&#160;## How to Create Client/Server Libraries        {#dylibs}</div><div class="line"><a name="l14581"></a><span class="lineno">14581</span>&#160;</div><div class="line"><a name="l14582"></a><span class="lineno">14582</span>&#160;The gSOAP `soapcpp2` compiler produces `soapClientLib.cpp` and `soapServerLib.cpp`</div><div class="line"><a name="l14583"></a><span class="lineno">14583</span>&#160;codes that are specifically intended for building static or dynamic</div><div class="line"><a name="l14584"></a><span class="lineno">14584</span>&#160;client/server libraries. These codes export the stubs and skeletons, but keep</div><div class="line"><a name="l14585"></a><span class="lineno">14585</span>&#160;all marshaling code (i.e. parameter serializers and deserializers) local (i.e. </div><div class="line"><a name="l14586"></a><span class="lineno">14586</span>&#160;as static functions) to avoid link symbol conflicts when combining multiple</div><div class="line"><a name="l14587"></a><span class="lineno">14587</span>&#160;clients and/or servers into one executable. Note that it is far simpler to use</div><div class="line"><a name="l14588"></a><span class="lineno">14588</span>&#160;the `wsdl2h` tool on multiple WSDL files to generate a header file that</div><div class="line"><a name="l14589"></a><span class="lineno">14589</span>&#160;combines all service definitions. However, the approach presented in this</div><div class="line"><a name="l14590"></a><span class="lineno">14590</span>&#160;section is useful when creating (dynamic) libraries for client and server</div><div class="line"><a name="l14591"></a><span class="lineno">14591</span>&#160;objects, such as DLLs as described in Section \ref dll .</div><div class="line"><a name="l14592"></a><span class="lineno">14592</span>&#160;</div><div class="line"><a name="l14593"></a><span class="lineno">14593</span>&#160;Do not link `soapClientLib.cpp` or `soapServerLib.cpp` together with `soapC.cpp`, `soapClient.cpp`, and `soapServer.cpp`. The library versions already include all of the necessary definitions.</div><div class="line"><a name="l14594"></a><span class="lineno">14594</span>&#160;</div><div class="line"><a name="l14595"></a><span class="lineno">14595</span>&#160;To build multiple libraries in the same project directory, you can define a C++</div><div class="line"><a name="l14596"></a><span class="lineno">14596</span>&#160;code namespace in your header file (see Section \ref codenamespace ) or you</div><div class="line"><a name="l14597"></a><span class="lineno">14597</span>&#160;can use `soapcpp2` with option `-p` to rename the generated</div><div class="line"><a name="l14598"></a><span class="lineno">14598</span>&#160;`soapClientLib.cpp` and `soapServerLib.cpp` (and associated) files. The</div><div class="line"><a name="l14599"></a><span class="lineno">14599</span>&#160;`-p` option specifies the file name prefix to replace the `soap`</div><div class="line"><a name="l14600"></a><span class="lineno">14600</span>&#160;prefix.  The libraries don&#39;t have to be C++ codes. You can use option `-c`</div><div class="line"><a name="l14601"></a><span class="lineno">14601</span>&#160;to generate C code. A clean separation of libraries can also be achieved with</div><div class="line"><a name="l14602"></a><span class="lineno">14602</span>&#160;C++ code namespaces, see Section \ref codenamespace .</div><div class="line"><a name="l14603"></a><span class="lineno">14603</span>&#160;</div><div class="line"><a name="l14604"></a><span class="lineno">14604</span>&#160;The library codes do not define SOAP Header and Fault serializers.  You MUST</div><div class="line"><a name="l14605"></a><span class="lineno">14605</span>&#160;add SOAP Header and Fault serializers to your application, which are compiled</div><div class="line"><a name="l14606"></a><span class="lineno">14606</span>&#160;separately as follows.  First, create a new header file `env.h` with the</div><div class="line"><a name="l14607"></a><span class="lineno">14607</span>&#160;SOAP Header and Fault definitions.  You can leave this header file empty if you</div><div class="line"><a name="l14608"></a><span class="lineno">14608</span>&#160;want to use the default SOAP Header and Fault. Then compile this header file</div><div class="line"><a name="l14609"></a><span class="lineno">14609</span>&#160;with:</div><div class="line"><a name="l14610"></a><span class="lineno">14610</span>&#160;</div><div class="line"><a name="l14611"></a><span class="lineno">14611</span>&#160;    &gt; soapcpp2 -penv env.h</div><div class="line"><a name="l14612"></a><span class="lineno">14612</span>&#160;</div><div class="line"><a name="l14613"></a><span class="lineno">14613</span>&#160;The generated `envC.cpp` file holds the SOAP Header and Fault serializers and you can</div><div class="line"><a name="l14614"></a><span class="lineno">14614</span>&#160;create a (dynamic) library for it to link this code with your client or server application.</div><div class="line"><a name="l14615"></a><span class="lineno">14615</span>&#160;</div><div class="line"><a name="l14616"></a><span class="lineno">14616</span>&#160;You MUST compile the `stdsoap2.cpp` library using `-DWITH_NONAMESPACES`:</div><div class="line"><a name="l14617"></a><span class="lineno">14617</span>&#160;</div><div class="line"><a name="l14618"></a><span class="lineno">14618</span>&#160;    &gt; c++ -DWITH_NONAMESPACES -c stdsoap2.cpp</div><div class="line"><a name="l14619"></a><span class="lineno">14619</span>&#160;</div><div class="line"><a name="l14620"></a><span class="lineno">14620</span>&#160;This omits the reference to the global namespaces table, which is nowhere</div><div class="line"><a name="l14621"></a><span class="lineno">14621</span>&#160;to be defined since we will use XML namespaces for each client/service separately. Therefore, you MUST explicitly set the</div><div class="line"><a name="l14622"></a><span class="lineno">14622</span>&#160;namespaces value of the gSOAP context in your code every time after initialization of the soap struct with the `soap_set_namespaces(struct soap*, const struct Namespace*)` function.</div><div class="line"><a name="l14623"></a><span class="lineno">14623</span>&#160;</div><div class="line"><a name="l14624"></a><span class="lineno">14624</span>&#160;For example, suppose we have two clients defined in header files `client1.h` and `client2.h`. We first generate the `envH.h` file for the SOAP Header and Fault definitions:</div><div class="line"><a name="l14625"></a><span class="lineno">14625</span>&#160;</div><div class="line"><a name="l14626"></a><span class="lineno">14626</span>&#160;    &gt; soapcpp2 -c -penv env.h</div><div class="line"><a name="l14627"></a><span class="lineno">14627</span>&#160;</div><div class="line"><a name="l14628"></a><span class="lineno">14628</span>&#160;Then we generate the code for client1 and client2:</div><div class="line"><a name="l14629"></a><span class="lineno">14629</span>&#160;</div><div class="line"><a name="l14630"></a><span class="lineno">14630</span>&#160;    &gt; soapcpp2 -c -n -pmyClient1 client1.h</div><div class="line"><a name="l14631"></a><span class="lineno">14631</span>&#160;    &gt; soapcpp2 -c -n -pmyClient2 client2.h</div><div class="line"><a name="l14632"></a><span class="lineno">14632</span>&#160;</div><div class="line"><a name="l14633"></a><span class="lineno">14633</span>&#160;This generates `myClient1ClientLib.c` and `myClient2ClientLib.c` (among many other files).</div><div class="line"><a name="l14634"></a><span class="lineno">14634</span>&#160;These two files should be compiled and linked with your application.</div><div class="line"><a name="l14635"></a><span class="lineno">14635</span>&#160;The source code of your application should include the generated `envH.h`, `myClient1H.h`, `myClient2.h` files and `myClient1.nsmap`, `myClient2.nsmap` files:</div><div class="line"><a name="l14636"></a><span class="lineno">14636</span>&#160;</div><div class="line"><a name="l14637"></a><span class="lineno">14637</span>&#160;```cpp</div><div class="line"><a name="l14638"></a><span class="lineno">14638</span>&#160;#include &quot;myClient1H.h&quot; // include client 1 stubs </div><div class="line"><a name="l14639"></a><span class="lineno">14639</span>&#160;#include &quot;myClient2H.h&quot; // include client 2 stubs </div><div class="line"><a name="l14640"></a><span class="lineno">14640</span>&#160;#include &quot;envH.h&quot; </div><div class="line"><a name="l14641"></a><span class="lineno">14641</span>&#160;... </div><div class="line"><a name="l14642"></a><span class="lineno">14642</span>&#160;#include &quot;myClient1H.nsmap&quot; // include client 1 nsmap </div><div class="line"><a name="l14643"></a><span class="lineno">14643</span>&#160;#include &quot;myClient2H.nsmap&quot; // include client 2 nsmap </div><div class="line"><a name="l14644"></a><span class="lineno">14644</span>&#160;... </div><div class="line"><a name="l14645"></a><span class="lineno">14645</span>&#160;soap_init(&amp;soap); </div><div class="line"><a name="l14646"></a><span class="lineno">14646</span>&#160;soap_set_namespaces(&amp;soap, myClient1_namespaces); </div><div class="line"><a name="l14647"></a><span class="lineno">14647</span>&#160;... make Client 1 invocations ... </div><div class="line"><a name="l14648"></a><span class="lineno">14648</span>&#160;... </div><div class="line"><a name="l14649"></a><span class="lineno">14649</span>&#160;soap_set_namespaces(&amp;soap, myClient2_namespaces); </div><div class="line"><a name="l14650"></a><span class="lineno">14650</span>&#160;... make Client 2 invocations ...</div><div class="line"><a name="l14651"></a><span class="lineno">14651</span>&#160;```</div><div class="line"><a name="l14652"></a><span class="lineno">14652</span>&#160;</div><div class="line"><a name="l14653"></a><span class="lineno">14653</span>&#160;It is important to use `soapcpp2` option `-n`, see Section \ref options , to rename the namespace tables so we can include them all without running into redefinitions.</div><div class="line"><a name="l14654"></a><span class="lineno">14654</span>&#160;</div><div class="line"><a name="l14655"></a><span class="lineno">14655</span>&#160;Note: Link conflicts may still occur in the unlikely situation that identical service operation names are defined in</div><div class="line"><a name="l14656"></a><span class="lineno">14656</span>&#160;two or more client stubs or server skeletons when these methods share the same XML namespace prefix.  You may have to use C++ code</div><div class="line"><a name="l14657"></a><span class="lineno">14657</span>&#160;namespaces to avoid these link conflicts or rename the namespace prefixes used by the service operation defined in the header files.</div><div class="line"><a name="l14658"></a><span class="lineno">14658</span>&#160;</div><div class="line"><a name="l14659"></a><span class="lineno">14659</span>&#160;### C++ Clients Example</div><div class="line"><a name="l14660"></a><span class="lineno">14660</span>&#160;</div><div class="line"><a name="l14661"></a><span class="lineno">14661</span>&#160;As an example we will build a Delayed Stock Quote client library and a Currency Exchange Rate client library.</div><div class="line"><a name="l14662"></a><span class="lineno">14662</span>&#160;</div><div class="line"><a name="l14663"></a><span class="lineno">14663</span>&#160;First, we create an empty header file `env.h` (which may contain optional SOAP Header and Fault definitions), and compile it as follows:</div><div class="line"><a name="l14664"></a><span class="lineno">14664</span>&#160;</div><div class="line"><a name="l14665"></a><span class="lineno">14665</span>&#160;    &gt; soapcpp2 -penv env.h</div><div class="line"><a name="l14666"></a><span class="lineno">14666</span>&#160;    &gt; c++ -c envC.cpp</div><div class="line"><a name="l14667"></a><span class="lineno">14667</span>&#160;</div><div class="line"><a name="l14668"></a><span class="lineno">14668</span>&#160;We also compile `stdsoap2.cpp` without namespaces:</div><div class="line"><a name="l14669"></a><span class="lineno">14669</span>&#160;</div><div class="line"><a name="l14670"></a><span class="lineno">14670</span>&#160;    &gt; c++ -c -DWITH_NONAMESPACES stdsoap2.cpp</div><div class="line"><a name="l14671"></a><span class="lineno">14671</span>&#160;</div><div class="line"><a name="l14672"></a><span class="lineno">14672</span>&#160;Note: when you forget to use `-DWITH_NONAMESPACES` you will get an unresolved link error for the global `namespaces` table. You can define a dummy table to avoid having to recompile `stdsoap2.cpp`.</div><div class="line"><a name="l14673"></a><span class="lineno">14673</span>&#160;</div><div class="line"><a name="l14674"></a><span class="lineno">14674</span>&#160;Second, we create the Delayed Stock Quote header file specification, which may be obtained using the WSDL importer. If you want to use C++ namespaces then you need to manually add the `namespace` declaration to the generated header file:</div><div class="line"><a name="l14675"></a><span class="lineno">14675</span>&#160;</div><div class="line"><a name="l14676"></a><span class="lineno">14676</span>&#160;```cpp</div><div class="line"><a name="l14677"></a><span class="lineno">14677</span>&#160;namespace quote { </div><div class="line"><a name="l14678"></a><span class="lineno">14678</span>&#160;//gsoap ns service name: Service </div><div class="line"><a name="l14679"></a><span class="lineno">14679</span>&#160;//gsoap ns service style: rpc </div><div class="line"><a name="l14680"></a><span class="lineno">14680</span>&#160;//gsoap ns service encoding: encoded </div><div class="line"><a name="l14681"></a><span class="lineno">14681</span>&#160;//gsoap ns service location: http://services.xmethods.net/soap </div><div class="line"><a name="l14682"></a><span class="lineno">14682</span>&#160;//gsoap ns schema namespace: urn:xmethods-delayed-quotes </div><div class="line"><a name="l14683"></a><span class="lineno">14683</span>&#160;//gsoap ns service method-action: getQuote &quot;&quot; </div><div class="line"><a name="l14684"></a><span class="lineno">14684</span>&#160;int ns__getQuote(char *symbol, float &amp;Result); </div><div class="line"><a name="l14685"></a><span class="lineno">14685</span>&#160;}</div><div class="line"><a name="l14686"></a><span class="lineno">14686</span>&#160;```</div><div class="line"><a name="l14687"></a><span class="lineno">14687</span>&#160;</div><div class="line"><a name="l14688"></a><span class="lineno">14688</span>&#160;We then compile it as a library and we use option `-n` to rename the namespace table to avoid link conflicts later:</div><div class="line"><a name="l14689"></a><span class="lineno">14689</span>&#160;</div><div class="line"><a name="l14690"></a><span class="lineno">14690</span>&#160;    &gt; soapcpp2 -n quote.h</div><div class="line"><a name="l14691"></a><span class="lineno">14691</span>&#160;    &gt; c++ -c quoteClientLib.cpp</div><div class="line"><a name="l14692"></a><span class="lineno">14692</span>&#160;</div><div class="line"><a name="l14693"></a><span class="lineno">14693</span>&#160;If you don&#39;t want to use a C++ code namespace, you should compile `quote.h` &quot;as is&quot; with soapcpp2 option `-pquote`:</div><div class="line"><a name="l14694"></a><span class="lineno">14694</span>&#160;</div><div class="line"><a name="l14695"></a><span class="lineno">14695</span>&#160;    &gt; soapcpp2 -n -pquote quote.h</div><div class="line"><a name="l14696"></a><span class="lineno">14696</span>&#160;    &gt; c++ -c quoteClientLib.cpp</div><div class="line"><a name="l14697"></a><span class="lineno">14697</span>&#160;</div><div class="line"><a name="l14698"></a><span class="lineno">14698</span>&#160;Third, we create the Currency Exchange Rate header file specification:</div><div class="line"><a name="l14699"></a><span class="lineno">14699</span>&#160;</div><div class="line"><a name="l14700"></a><span class="lineno">14700</span>&#160;```cpp</div><div class="line"><a name="l14701"></a><span class="lineno">14701</span>&#160;namespace rate { </div><div class="line"><a name="l14702"></a><span class="lineno">14702</span>&#160;//gsoap ns service name: Service </div><div class="line"><a name="l14703"></a><span class="lineno">14703</span>&#160;//gsoap ns service style: rpc </div><div class="line"><a name="l14704"></a><span class="lineno">14704</span>&#160;//gsoap ns service encoding: encoded </div><div class="line"><a name="l14705"></a><span class="lineno">14705</span>&#160;//gsoap ns service location: http://services.xmethods.net/soap </div><div class="line"><a name="l14706"></a><span class="lineno">14706</span>&#160;//gsoap ns schema namespace: urn:xmethods-CurrencyExchange </div><div class="line"><a name="l14707"></a><span class="lineno">14707</span>&#160;//gsoap ns service method-action: getRate &quot;&quot; </div><div class="line"><a name="l14708"></a><span class="lineno">14708</span>&#160;int ns__getRate(char *country1, char *country2, float &amp;Result); </div><div class="line"><a name="l14709"></a><span class="lineno">14709</span>&#160;}</div><div class="line"><a name="l14710"></a><span class="lineno">14710</span>&#160;```</div><div class="line"><a name="l14711"></a><span class="lineno">14711</span>&#160;</div><div class="line"><a name="l14712"></a><span class="lineno">14712</span>&#160;Similar to the Quote example above, we compile it as a library and we use option `-n` to rename the namespace table to avoid link conflicts:</div><div class="line"><a name="l14713"></a><span class="lineno">14713</span>&#160;</div><div class="line"><a name="l14714"></a><span class="lineno">14714</span>&#160;    &gt; soapcpp2 -n rate.h</div><div class="line"><a name="l14715"></a><span class="lineno">14715</span>&#160;</div><div class="line"><a name="l14716"></a><span class="lineno">14716</span>&#160;Fourth, we consider linking the libraries to the main program.</div><div class="line"><a name="l14717"></a><span class="lineno">14717</span>&#160;The main program can import the `quoteServiceProxy.h` and `rateServiceProxy.h` files to obtain client proxies to invoke the services. The proxy implementations are defined in `quoteClient.cpp`.</div><div class="line"><a name="l14718"></a><span class="lineno">14718</span>&#160;The `-n` option also affects the generation of the C++ proxy codes to ensure that the gSOAP context is properly initialized with the appropriate namespace table (so you don&#39;t have to initialize explicitly -- this feature is only available with C++ proxy and server object classes).</div><div class="line"><a name="l14719"></a><span class="lineno">14719</span>&#160;</div><div class="line"><a name="l14720"></a><span class="lineno">14720</span>&#160;```cpp</div><div class="line"><a name="l14721"></a><span class="lineno">14721</span>&#160;#include &quot;quoteServiceProxy.h&quot; // get quote Service proxy </div><div class="line"><a name="l14722"></a><span class="lineno">14722</span>&#160;#include &quot;rateServiceProxy.h&quot; // get rate Service proxy </div><div class="line"><a name="l14723"></a><span class="lineno">14723</span>&#160;#include &quot;quote.nsmap&quot; // get quote namespace bindings </div><div class="line"><a name="l14724"></a><span class="lineno">14724</span>&#160;#include &quot;rate.nsmap&quot; // get rate namespace bindings </div><div class="line"><a name="l14725"></a><span class="lineno">14725</span>&#160;int main(int argc, char *argv[]) </div><div class="line"><a name="l14726"></a><span class="lineno">14726</span>&#160;{ </div><div class="line"><a name="l14727"></a><span class="lineno">14727</span>&#160;   if (argc &lt;= 1) </div><div class="line"><a name="l14728"></a><span class="lineno">14728</span>&#160;   { </div><div class="line"><a name="l14729"></a><span class="lineno">14729</span>&#160;     std::cerr &lt;&lt; &quot;Usage: main ticker [currency]&quot; &lt;&lt; std::endl </div><div class="line"><a name="l14730"></a><span class="lineno">14730</span>&#160;     exit(0); </div><div class="line"><a name="l14731"></a><span class="lineno">14731</span>&#160;   } </div><div class="line"><a name="l14732"></a><span class="lineno">14732</span>&#160;   quote::Service quote; </div><div class="line"><a name="l14733"></a><span class="lineno">14733</span>&#160;   float q; </div><div class="line"><a name="l14734"></a><span class="lineno">14734</span>&#160;   if (quote.getQuote(argv[1], q)) // get quote </div><div class="line"><a name="l14735"></a><span class="lineno">14735</span>&#160;     soap_print_fault(quote.soap, stderr); </div><div class="line"><a name="l14736"></a><span class="lineno">14736</span>&#160;   else </div><div class="line"><a name="l14737"></a><span class="lineno">14737</span>&#160;   { </div><div class="line"><a name="l14738"></a><span class="lineno">14738</span>&#160;     if (argc &gt; 2) </div><div class="line"><a name="l14739"></a><span class="lineno">14739</span>&#160;     { </div><div class="line"><a name="l14740"></a><span class="lineno">14740</span>&#160;       rate::Service rate; </div><div class="line"><a name="l14741"></a><span class="lineno">14741</span>&#160;       float r; </div><div class="line"><a name="l14742"></a><span class="lineno">14742</span>&#160;       if (rate.getRate(&quot;us&quot;, argv[2], r)) // get rate in US dollars </div><div class="line"><a name="l14743"></a><span class="lineno">14743</span>&#160;         soap_print_fault(rate.soap, stderr); </div><div class="line"><a name="l14744"></a><span class="lineno">14744</span>&#160;       else </div><div class="line"><a name="l14745"></a><span class="lineno">14745</span>&#160;         q *= r; // convert the quote </div><div class="line"><a name="l14746"></a><span class="lineno">14746</span>&#160;     } </div><div class="line"><a name="l14747"></a><span class="lineno">14747</span>&#160;     std::cout &lt;&lt; argv[1] &lt;&lt; &quot;: &quot; &lt;&lt; q &lt;&lt; std::endl; </div><div class="line"><a name="l14748"></a><span class="lineno">14748</span>&#160;   } </div><div class="line"><a name="l14749"></a><span class="lineno">14749</span>&#160;   return 0; </div><div class="line"><a name="l14750"></a><span class="lineno">14750</span>&#160;}</div><div class="line"><a name="l14751"></a><span class="lineno">14751</span>&#160;```</div><div class="line"><a name="l14752"></a><span class="lineno">14752</span>&#160;</div><div class="line"><a name="l14753"></a><span class="lineno">14753</span>&#160;Compile and link this application with `stdsoap2.o`, `envC.o`, `quoteServerProxy.o`, and `rateServerProxy.o`.</div><div class="line"><a name="l14754"></a><span class="lineno">14754</span>&#160;</div><div class="line"><a name="l14755"></a><span class="lineno">14755</span>&#160;To compile and link a server object is very similar. For example, assume that we need to implement a calculator service and we want to create a library for it.</div><div class="line"><a name="l14756"></a><span class="lineno">14756</span>&#160;</div><div class="line"><a name="l14757"></a><span class="lineno">14757</span>&#160;```cpp</div><div class="line"><a name="l14758"></a><span class="lineno">14758</span>&#160;namespace calc { </div><div class="line"><a name="l14759"></a><span class="lineno">14759</span>&#160;//gsoap ns service name: Service </div><div class="line"><a name="l14760"></a><span class="lineno">14760</span>&#160;//gsoap ns service style: rpc </div><div class="line"><a name="l14761"></a><span class="lineno">14761</span>&#160;//gsoap ns service encoding: encoded </div><div class="line"><a name="l14762"></a><span class="lineno">14762</span>&#160;//gsoap ns service location: http://www.cs.fsu.edu/~engelen/calc.cgi </div><div class="line"><a name="l14763"></a><span class="lineno">14763</span>&#160;//gsoap ns schema namespace: urn:calc </div><div class="line"><a name="l14764"></a><span class="lineno">14764</span>&#160;int ns__add(double a, double b, double &amp;result); </div><div class="line"><a name="l14765"></a><span class="lineno">14765</span>&#160;int ns__sub(double a, double b, double &amp;result); </div><div class="line"><a name="l14766"></a><span class="lineno">14766</span>&#160;int ns__mul(double a, double b, double &amp;result); </div><div class="line"><a name="l14767"></a><span class="lineno">14767</span>&#160;int ns__div(double a, double b, double &amp;result); </div><div class="line"><a name="l14768"></a><span class="lineno">14768</span>&#160;}</div><div class="line"><a name="l14769"></a><span class="lineno">14769</span>&#160;```</div><div class="line"><a name="l14770"></a><span class="lineno">14770</span>&#160;</div><div class="line"><a name="l14771"></a><span class="lineno">14771</span>&#160;We compile this with:</div><div class="line"><a name="l14772"></a><span class="lineno">14772</span>&#160;</div><div class="line"><a name="l14773"></a><span class="lineno">14773</span>&#160;    &gt; soapcpp2 -n calc.h</div><div class="line"><a name="l14774"></a><span class="lineno">14774</span>&#160;</div><div class="line"><a name="l14775"></a><span class="lineno">14775</span>&#160;The effect of the `-n` option is that it creates local namespace tables, and a modified `calcServiceObject.h` server class definitions that properly initialize the gSOAP run time with the table.</div><div class="line"><a name="l14776"></a><span class="lineno">14776</span>&#160;</div><div class="line"><a name="l14777"></a><span class="lineno">14777</span>&#160;```cpp</div><div class="line"><a name="l14778"></a><span class="lineno">14778</span>&#160;#include &quot;calcServiceObject.h&quot; // get Service object </div><div class="line"><a name="l14779"></a><span class="lineno">14779</span>&#160;#include &quot;calc.nsmap&quot; // get calc namespace bindings </div><div class="line"><a name="l14780"></a><span class="lineno">14780</span>&#160;... </div><div class="line"><a name="l14781"></a><span class="lineno">14781</span>&#160;calc::Service calc; </div><div class="line"><a name="l14782"></a><span class="lineno">14782</span>&#160;calc.serve(); // calls request dispatcher to invoke one of the functions below </div><div class="line"><a name="l14783"></a><span class="lineno">14783</span>&#160;... </div><div class="line"><a name="l14784"></a><span class="lineno">14784</span>&#160;int calc::Service::add(double a, double b, double &amp;result); </div><div class="line"><a name="l14785"></a><span class="lineno">14785</span>&#160;{ result = a + b; return SOAP_OK; } </div><div class="line"><a name="l14786"></a><span class="lineno">14786</span>&#160;int calc::Service::sub(double a, double b, double &amp;result); </div><div class="line"><a name="l14787"></a><span class="lineno">14787</span>&#160;{ result = a - b; return SOAP_OK; } </div><div class="line"><a name="l14788"></a><span class="lineno">14788</span>&#160;int calc::Service::mul(double a, double b, double &amp;result); </div><div class="line"><a name="l14789"></a><span class="lineno">14789</span>&#160;{ result = a * b; return SOAP_OK; } </div><div class="line"><a name="l14790"></a><span class="lineno">14790</span>&#160;int calc::Service::div(double a, double b, double &amp;result); </div><div class="line"><a name="l14791"></a><span class="lineno">14791</span>&#160;{ result = a / b; return SOAP_OK; } </div><div class="line"><a name="l14792"></a><span class="lineno">14792</span>&#160;```</div><div class="line"><a name="l14793"></a><span class="lineno">14793</span>&#160;</div><div class="line"><a name="l14794"></a><span class="lineno">14794</span>&#160;In fact, the `calc::Service` class is derived from the `struct soap`. So the context</div><div class="line"><a name="l14795"></a><span class="lineno">14795</span>&#160;is available as `this`, which can be passed to all gSOAP functions that require a soap struct</div><div class="line"><a name="l14796"></a><span class="lineno">14796</span>&#160;context.</div><div class="line"><a name="l14797"></a><span class="lineno">14797</span>&#160;</div><div class="line"><a name="l14798"></a><span class="lineno">14798</span>&#160;The example above serves requests over stdin/out. Use the bind and accept calls to create a stand-alone server to service inbound requests over sockets, see \ref stand-alone .</div><div class="line"><a name="l14799"></a><span class="lineno">14799</span>&#160;</div><div class="line"><a name="l14800"></a><span class="lineno">14800</span>&#160;### C Clients Example</div><div class="line"><a name="l14801"></a><span class="lineno">14801</span>&#160;</div><div class="line"><a name="l14802"></a><span class="lineno">14802</span>&#160;This is the same example as above, but the clients are build with pure C.</div><div class="line"><a name="l14803"></a><span class="lineno">14803</span>&#160;</div><div class="line"><a name="l14804"></a><span class="lineno">14804</span>&#160;We create a `env.h` that contains the joint SOAP Header and SOAP Fault</div><div class="line"><a name="l14805"></a><span class="lineno">14805</span>&#160;definitions. You may have to copy-paste these from the other header files.</div><div class="line"><a name="l14806"></a><span class="lineno">14806</span>&#160;Then, compile it as follows:</div><div class="line"><a name="l14807"></a><span class="lineno">14807</span>&#160;</div><div class="line"><a name="l14808"></a><span class="lineno">14808</span>&#160;    &gt; soapcpp2 -c -penv env.h</div><div class="line"><a name="l14809"></a><span class="lineno">14809</span>&#160;    &gt; cc -c envC.c</div><div class="line"><a name="l14810"></a><span class="lineno">14810</span>&#160;</div><div class="line"><a name="l14811"></a><span class="lineno">14811</span>&#160;We also compile `stdsoap2.c` without namespaces:</div><div class="line"><a name="l14812"></a><span class="lineno">14812</span>&#160;</div><div class="line"><a name="l14813"></a><span class="lineno">14813</span>&#160;    &gt; cc -c -DWITH_NONAMESPACES stdsoap2.c</div><div class="line"><a name="l14814"></a><span class="lineno">14814</span>&#160;</div><div class="line"><a name="l14815"></a><span class="lineno">14815</span>&#160;Second, we create the Delayed Stock Quote header file specification, which may be obtained using the WSDL importer.</div><div class="line"><a name="l14816"></a><span class="lineno">14816</span>&#160;</div><div class="line"><a name="l14817"></a><span class="lineno">14817</span>&#160;```cpp</div><div class="line"><a name="l14818"></a><span class="lineno">14818</span>&#160;//gsoap ns service name: Service </div><div class="line"><a name="l14819"></a><span class="lineno">14819</span>&#160;//gsoap ns service style: rpc </div><div class="line"><a name="l14820"></a><span class="lineno">14820</span>&#160;//gsoap ns service encoding: encoded </div><div class="line"><a name="l14821"></a><span class="lineno">14821</span>&#160;//gsoap ns service location: http://services.xmethods.net/soap </div><div class="line"><a name="l14822"></a><span class="lineno">14822</span>&#160;//gsoap ns schema namespace: urn:xmethods-delayed-quotes </div><div class="line"><a name="l14823"></a><span class="lineno">14823</span>&#160;//gsoap ns service method-action: getQuote &quot;&quot; </div><div class="line"><a name="l14824"></a><span class="lineno">14824</span>&#160;int ns__getQuote(char *symbol, float *Result);</div><div class="line"><a name="l14825"></a><span class="lineno">14825</span>&#160;```</div><div class="line"><a name="l14826"></a><span class="lineno">14826</span>&#160;</div><div class="line"><a name="l14827"></a><span class="lineno">14827</span>&#160;We compile it as a library and we use options `-n` and `-p` to rename the namespace table to avoid link conflicts:</div><div class="line"><a name="l14828"></a><span class="lineno">14828</span>&#160;</div><div class="line"><a name="l14829"></a><span class="lineno">14829</span>&#160;    &gt; soapcpp2 -c -n -pquote quote.h</div><div class="line"><a name="l14830"></a><span class="lineno">14830</span>&#160;    &gt; cc -c quoteClientLib.c</div><div class="line"><a name="l14831"></a><span class="lineno">14831</span>&#160;</div><div class="line"><a name="l14832"></a><span class="lineno">14832</span>&#160;Third, we create the Currency Exchange Rate header file specification:</div><div class="line"><a name="l14833"></a><span class="lineno">14833</span>&#160;</div><div class="line"><a name="l14834"></a><span class="lineno">14834</span>&#160;```cpp</div><div class="line"><a name="l14835"></a><span class="lineno">14835</span>&#160;//gsoap ns service name: Service </div><div class="line"><a name="l14836"></a><span class="lineno">14836</span>&#160;//gsoap ns service style: rpc </div><div class="line"><a name="l14837"></a><span class="lineno">14837</span>&#160;//gsoap ns service encoding: encoded </div><div class="line"><a name="l14838"></a><span class="lineno">14838</span>&#160;//gsoap ns service location: http://services.xmethods.net/soap </div><div class="line"><a name="l14839"></a><span class="lineno">14839</span>&#160;//gsoap ns schema namespace: urn:xmethods-CurrencyExchange </div><div class="line"><a name="l14840"></a><span class="lineno">14840</span>&#160;//gsoap ns service method-action: getRate &quot;&quot; </div><div class="line"><a name="l14841"></a><span class="lineno">14841</span>&#160;int ns__getRate(char *country1, char *country2, float *Result);</div><div class="line"><a name="l14842"></a><span class="lineno">14842</span>&#160;```</div><div class="line"><a name="l14843"></a><span class="lineno">14843</span>&#160;</div><div class="line"><a name="l14844"></a><span class="lineno">14844</span>&#160;We compile it as a library and we use options `-n` and `-p` to rename the namespace table to avoid link conflicts:</div><div class="line"><a name="l14845"></a><span class="lineno">14845</span>&#160;</div><div class="line"><a name="l14846"></a><span class="lineno">14846</span>&#160;    &gt; soapcpp2 -c -n -prate rate.h</div><div class="line"><a name="l14847"></a><span class="lineno">14847</span>&#160;    &gt; cc -c rateClientLib.c</div><div class="line"><a name="l14848"></a><span class="lineno">14848</span>&#160;</div><div class="line"><a name="l14849"></a><span class="lineno">14849</span>&#160;The main program is:</div><div class="line"><a name="l14850"></a><span class="lineno">14850</span>&#160;</div><div class="line"><a name="l14851"></a><span class="lineno">14851</span>&#160;```cpp</div><div class="line"><a name="l14852"></a><span class="lineno">14852</span>&#160;#include &quot;quoteStub.h&quot; // get quote Service stub </div><div class="line"><a name="l14853"></a><span class="lineno">14853</span>&#160;#include &quot;rateStub.h&quot; // get rate Service stub </div><div class="line"><a name="l14854"></a><span class="lineno">14854</span>&#160;#include &quot;quote.nsmap&quot; // get quote namespace bindings </div><div class="line"><a name="l14855"></a><span class="lineno">14855</span>&#160;#include &quot;rate.nsmap&quot; // get rate namespace bindings </div><div class="line"><a name="l14856"></a><span class="lineno">14856</span>&#160;int main(int argc, char *argv[]) </div><div class="line"><a name="l14857"></a><span class="lineno">14857</span>&#160;{ </div><div class="line"><a name="l14858"></a><span class="lineno">14858</span>&#160;   if (argc &lt;= 1) </div><div class="line"><a name="l14859"></a><span class="lineno">14859</span>&#160;   { </div><div class="line"><a name="l14860"></a><span class="lineno">14860</span>&#160;     fprintf(stderr, &quot;Usage: main ticker [currency]\n&quot;); </div><div class="line"><a name="l14861"></a><span class="lineno">14861</span>&#160;     exit(0); </div><div class="line"><a name="l14862"></a><span class="lineno">14862</span>&#160;   } </div><div class="line"><a name="l14863"></a><span class="lineno">14863</span>&#160;   struct soap soap; </div><div class="line"><a name="l14864"></a><span class="lineno">14864</span>&#160;   float q; </div><div class="line"><a name="l14865"></a><span class="lineno">14865</span>&#160;   soap_init(&amp;soap); </div><div class="line"><a name="l14866"></a><span class="lineno">14866</span>&#160;   soap_set_namespaces(&amp;soap, quote_namespaces); </div><div class="line"><a name="l14867"></a><span class="lineno">14867</span>&#160;   if (soap_call_ns__getQuote(&amp;soap, &quot;http://services.xmethods.net/soap&quot;, &quot;&quot;, argv[1], &amp;q)) // get quote </div><div class="line"><a name="l14868"></a><span class="lineno">14868</span>&#160;     soap_print_fault(&amp;soap, stderr); </div><div class="line"><a name="l14869"></a><span class="lineno">14869</span>&#160;   else </div><div class="line"><a name="l14870"></a><span class="lineno">14870</span>&#160;   { </div><div class="line"><a name="l14871"></a><span class="lineno">14871</span>&#160;     if (argc &gt; 2) </div><div class="line"><a name="l14872"></a><span class="lineno">14872</span>&#160;     { </div><div class="line"><a name="l14873"></a><span class="lineno">14873</span>&#160;       soap_set_namespaces(&amp;soap, rate_namespaces); </div><div class="line"><a name="l14874"></a><span class="lineno">14874</span>&#160;       float r; </div><div class="line"><a name="l14875"></a><span class="lineno">14875</span>&#160;       if (soap_call_ns__getRate(&amp;soap, &quot;http://services.xmethods.net/soap&quot;, &quot;&quot;, &quot;us&quot;, argv[2], &amp;r)) // get rate in US dollars </div><div class="line"><a name="l14876"></a><span class="lineno">14876</span>&#160;         soap_print_fault(&amp;soap, stderr); </div><div class="line"><a name="l14877"></a><span class="lineno">14877</span>&#160;       else </div><div class="line"><a name="l14878"></a><span class="lineno">14878</span>&#160;         q *= r; // convert the quote </div><div class="line"><a name="l14879"></a><span class="lineno">14879</span>&#160;     } </div><div class="line"><a name="l14880"></a><span class="lineno">14880</span>&#160;     printf(&quot;%s: %f \n&quot;, argv[1], q); </div><div class="line"><a name="l14881"></a><span class="lineno">14881</span>&#160;   } </div><div class="line"><a name="l14882"></a><span class="lineno">14882</span>&#160;   return 0; </div><div class="line"><a name="l14883"></a><span class="lineno">14883</span>&#160;}</div><div class="line"><a name="l14884"></a><span class="lineno">14884</span>&#160;```</div><div class="line"><a name="l14885"></a><span class="lineno">14885</span>&#160;</div><div class="line"><a name="l14886"></a><span class="lineno">14886</span>&#160;Compile and link this application with `stdsoap2.o`, `envC.o`, `quoteClientLib.o`, and `rateClientLib.o`.</div><div class="line"><a name="l14887"></a><span class="lineno">14887</span>&#160;</div><div class="line"><a name="l14888"></a><span class="lineno">14888</span>&#160;To compile and link a server library is very similar. Assuming that the server is named &quot;`calc`&quot; (as specified with options `-n` and `-p`), the application needs to include the `calcStub.h` file, link the `calcServerLib.o` file, and call `calc_serve(&amp;soap)` function at run time.</div><div class="line"><a name="l14889"></a><span class="lineno">14889</span>&#160;</div><div class="line"><a name="l14890"></a><span class="lineno">14890</span>&#160;### C Services Chaining Example</div><div class="line"><a name="l14891"></a><span class="lineno">14891</span>&#160;</div><div class="line"><a name="l14892"></a><span class="lineno">14892</span>&#160;We build a C application for multiple services served on one port.</div><div class="line"><a name="l14893"></a><span class="lineno">14893</span>&#160;</div><div class="line"><a name="l14894"></a><span class="lineno">14894</span>&#160;We create a `env.h` that contains the joint SOAP Header and SOAP Fault</div><div class="line"><a name="l14895"></a><span class="lineno">14895</span>&#160;definitions. You may have to copy-paste these from the other header files.</div><div class="line"><a name="l14896"></a><span class="lineno">14896</span>&#160;Then, compile it as follows:</div><div class="line"><a name="l14897"></a><span class="lineno">14897</span>&#160;</div><div class="line"><a name="l14898"></a><span class="lineno">14898</span>&#160;    &gt; soapcpp2 -c -penv env.h</div><div class="line"><a name="l14899"></a><span class="lineno">14899</span>&#160;    &gt; cc -c envC.c</div><div class="line"><a name="l14900"></a><span class="lineno">14900</span>&#160;</div><div class="line"><a name="l14901"></a><span class="lineno">14901</span>&#160;We also compile `stdsoap2.c` without namespaces:</div><div class="line"><a name="l14902"></a><span class="lineno">14902</span>&#160;</div><div class="line"><a name="l14903"></a><span class="lineno">14903</span>&#160;    &gt; cc -c -DWITH_NONAMESPACES stdsoap2.c</div><div class="line"><a name="l14904"></a><span class="lineno">14904</span>&#160;</div><div class="line"><a name="l14905"></a><span class="lineno">14905</span>&#160;Say we have a service definition in `quote.h`. We compile it as a library and we use options `-n` and `-p` to rename the namespace table to avoid link conflicts:</div><div class="line"><a name="l14906"></a><span class="lineno">14906</span>&#160;</div><div class="line"><a name="l14907"></a><span class="lineno">14907</span>&#160;    &gt; soapcpp2 -c -n -pquote quote.h</div><div class="line"><a name="l14908"></a><span class="lineno">14908</span>&#160;    &gt; cc -c quoteClientLib.c</div><div class="line"><a name="l14909"></a><span class="lineno">14909</span>&#160;</div><div class="line"><a name="l14910"></a><span class="lineno">14910</span>&#160;We do the same for a service definition in `rate.h`:</div><div class="line"><a name="l14911"></a><span class="lineno">14911</span>&#160;</div><div class="line"><a name="l14912"></a><span class="lineno">14912</span>&#160;    &gt; soapcpp2 -c -n -prate rate.h</div><div class="line"><a name="l14913"></a><span class="lineno">14913</span>&#160;    &gt; cc -c rateClientLib.c</div><div class="line"><a name="l14914"></a><span class="lineno">14914</span>&#160;</div><div class="line"><a name="l14915"></a><span class="lineno">14915</span>&#160;To serve both the quote and rate services on the same port, we chain the service dispatchers as follows:</div><div class="line"><a name="l14916"></a><span class="lineno">14916</span>&#160;</div><div class="line"><a name="l14917"></a><span class="lineno">14917</span>&#160;```cpp</div><div class="line"><a name="l14918"></a><span class="lineno">14918</span>&#160;struct soap *soap = soap_new(); </div><div class="line"><a name="l14919"></a><span class="lineno">14919</span>&#160;soap_bind(soap, NULL, 8080, 100); </div><div class="line"><a name="l14920"></a><span class="lineno">14920</span>&#160;soap_accept(soap); </div><div class="line"><a name="l14921"></a><span class="lineno">14921</span>&#160;if (soap_begin_serve(soap)) </div><div class="line"><a name="l14922"></a><span class="lineno">14922</span>&#160;   soap_send_fault(&amp;abc); // send fault to client </div><div class="line"><a name="l14923"></a><span class="lineno">14923</span>&#160;else if (quote_serve_request(soap) == SOAP_NO_METHOD) </div><div class="line"><a name="l14924"></a><span class="lineno">14924</span>&#160;{ </div><div class="line"><a name="l14925"></a><span class="lineno">14925</span>&#160;   if (rate_serve_request(soap))</div><div class="line"><a name="l14926"></a><span class="lineno">14926</span>&#160;     soap_send_fault(soap); // send fault to client </div><div class="line"><a name="l14927"></a><span class="lineno">14927</span>&#160;} </div><div class="line"><a name="l14928"></a><span class="lineno">14928</span>&#160;else if (soap.error) </div><div class="line"><a name="l14929"></a><span class="lineno">14929</span>&#160;   soap_send_fault(soap); // send fault to client </div><div class="line"><a name="l14930"></a><span class="lineno">14930</span>&#160;soap_destroy(soap); </div><div class="line"><a name="l14931"></a><span class="lineno">14931</span>&#160;soap_end(soap); </div><div class="line"><a name="l14932"></a><span class="lineno">14932</span>&#160;soap_free(soap);</div><div class="line"><a name="l14933"></a><span class="lineno">14933</span>&#160;```</div><div class="line"><a name="l14934"></a><span class="lineno">14934</span>&#160;</div><div class="line"><a name="l14935"></a><span class="lineno">14935</span>&#160;This chaining can be arbitrarily deep. When the previous request fails with a `SOAP_NO_METHOD` then next request dispatcher can be tried.</div><div class="line"><a name="l14936"></a><span class="lineno">14936</span>&#160;</div><div class="line"><a name="l14937"></a><span class="lineno">14937</span>&#160;The server should also define the service operations:</div><div class="line"><a name="l14938"></a><span class="lineno">14938</span>&#160;</div><div class="line"><a name="l14939"></a><span class="lineno">14939</span>&#160;```cpp</div><div class="line"><a name="l14940"></a><span class="lineno">14940</span>&#160;int ns__getQuote(struct soap *soap, char *symbol, float *Result); </div><div class="line"><a name="l14941"></a><span class="lineno">14941</span>&#160;{ *Result = ... ; </div><div class="line"><a name="l14942"></a><span class="lineno">14942</span>&#160;     return SOAP_OK; </div><div class="line"><a name="l14943"></a><span class="lineno">14943</span>&#160;} </div><div class="line"><a name="l14944"></a><span class="lineno">14944</span>&#160;int ns__getRate(struct soap *soap, char *country1, char *country2, float *Result); </div><div class="line"><a name="l14945"></a><span class="lineno">14945</span>&#160;{ *Result = ... ; </div><div class="line"><a name="l14946"></a><span class="lineno">14946</span>&#160;     return SOAP_OK; </div><div class="line"><a name="l14947"></a><span class="lineno">14947</span>&#160;}</div><div class="line"><a name="l14948"></a><span class="lineno">14948</span>&#160;```</div><div class="line"><a name="l14949"></a><span class="lineno">14949</span>&#160;</div><div class="line"><a name="l14950"></a><span class="lineno">14950</span>&#160;## How to Create DLLs        {#dll}</div><div class="line"><a name="l14951"></a><span class="lineno">14951</span>&#160;</div><div class="line"><a name="l14952"></a><span class="lineno">14952</span>&#160;### Create the Base stdsoap2.dll</div><div class="line"><a name="l14953"></a><span class="lineno">14953</span>&#160;</div><div class="line"><a name="l14954"></a><span class="lineno">14954</span>&#160;First, create a new header file `env.h` with the SOAP Header and Fault</div><div class="line"><a name="l14955"></a><span class="lineno">14955</span>&#160;definitions.  You can leave this header file empty if you want to use the</div><div class="line"><a name="l14956"></a><span class="lineno">14956</span>&#160;default SOAP Header and Fault. Then compile this header file with:</div><div class="line"><a name="l14957"></a><span class="lineno">14957</span>&#160;</div><div class="line"><a name="l14958"></a><span class="lineno">14958</span>&#160;    &gt; soapcpp2 -penv env.h</div><div class="line"><a name="l14959"></a><span class="lineno">14959</span>&#160;</div><div class="line"><a name="l14960"></a><span class="lineno">14960</span>&#160;The generated `envC.cpp` file holds the SOAP Header and Fault serializers, which need to be part of the base library functions.  The SOAP Header and Fault structures are generated by wsdl2h and are also located in the `.h` files for plugins such as `wsse.h`.  You should copy these Header and Fault structures into `env.h` to ensure processing by these plugins succeeds.</div><div class="line"><a name="l14961"></a><span class="lineno">14961</span>&#160;</div><div class="line"><a name="l14962"></a><span class="lineno">14962</span>&#160;The next step is to create `stdsoap2.dll` which consists of the file</div><div class="line"><a name="l14963"></a><span class="lineno">14963</span>&#160;`stdsoap2.cpp` and `envC.cpp` and optionally the plugins you want to use such as `wsseapi.c` (rename to .cpp to avoid warnings). This DLL contains all common functions</div><div class="line"><a name="l14964"></a><span class="lineno">14964</span>&#160;needed for all other clients and servers based on gSOAP.  Compile</div><div class="line"><a name="l14965"></a><span class="lineno">14965</span>&#160;`envC.cpp` and `stdsoap2.cpp` into `stdsoap2.dll` using the</div><div class="line"><a name="l14966"></a><span class="lineno">14966</span>&#160;compiler option `-DWITH_NONAMESPACES` and the MSVC Pre-Processor</div><div class="line"><a name="l14967"></a><span class="lineno">14967</span>&#160;definitions `SOAP_FMAC1=__declspec(dllexport)`, `SOAP_FMAC3=__declspec(dllexport)`, and the `SOAP_STD_EXPORTS` macro set as shown below from the MSVC command prompt:</div><div class="line"><a name="l14968"></a><span class="lineno">14968</span>&#160;</div><div class="line"><a name="l14969"></a><span class="lineno">14969</span>&#160;    C: cl /c /I. /EHsc /DWITH_NONAMESPACES /DSOAP_FMAC1=__declspec(dllexport) /DSOAP_FMAC3=__declspec(dllexport) /DSOAP_STD_EXPORTS envC.cpp stdsoap2.cpp</div><div class="line"><a name="l14970"></a><span class="lineno">14970</span>&#160;    C: link /LIBPATH ws2_32.lib /OUT:mygsoap.dll /DLL envC.obj stdsoap2.obj</div><div class="line"><a name="l14971"></a><span class="lineno">14971</span>&#160;</div><div class="line"><a name="l14972"></a><span class="lineno">14972</span>&#160;Note: as of gSOAP 2.8.30 and later, the DLL export macros shown here are all set with one pre-processor definition `SOAP_STD_EXPORTS`.</div><div class="line"><a name="l14973"></a><span class="lineno">14973</span>&#160;</div><div class="line"><a name="l14974"></a><span class="lineno">14974</span>&#160;Alternatively, you can compile with</div><div class="line"><a name="l14975"></a><span class="lineno">14975</span>&#160;`-DWITH_SOAPDEFS_H` and put the macro definitions in `soapdefs.h`.</div><div class="line"><a name="l14976"></a><span class="lineno">14976</span>&#160;This exports all functions which are preceded by the macro `SOAP_FMAC1` in</div><div class="line"><a name="l14977"></a><span class="lineno">14977</span>&#160;the `soapcpp2.cpp` source file and macro `SOAP_FMAC3` in the `envC.cpp` source file.</div><div class="line"><a name="l14978"></a><span class="lineno">14978</span>&#160;</div><div class="line"><a name="l14979"></a><span class="lineno">14979</span>&#160;Finally, note that the gSOAP distribution package contains a number of .c</div><div class="line"><a name="l14980"></a><span class="lineno">14980</span>&#160;files.  Mixing .c with .cpp files is not recommended with Visual Studio and</div><div class="line"><a name="l14981"></a><span class="lineno">14981</span>&#160;will lead to runtime errors when building DLLs.  Therefore, always rename .c</div><div class="line"><a name="l14982"></a><span class="lineno">14982</span>&#160;files to .cpp files when creating DLLs.</div><div class="line"><a name="l14983"></a><span class="lineno">14983</span>&#160;</div><div class="line"><a name="l14984"></a><span class="lineno">14984</span>&#160;### Creating Client and Server DLLs</div><div class="line"><a name="l14985"></a><span class="lineno">14985</span>&#160;</div><div class="line"><a name="l14986"></a><span class="lineno">14986</span>&#160;Compile the `soapClientLib.cpp` and `soapServerLib.cpp` sources as DLLs</div><div class="line"><a name="l14987"></a><span class="lineno">14987</span>&#160;by using the MSVC Pre-Processor definitions `SOAP_FMAC5=__declspec(dllexport)` and `SOAP_CMAC=__declspec(dllexport)`, and by using the C++ compiler option `-DWITH_NONAMESPACES`. All of these macros are set as a shorthand with one pre-processor definition `SOAP_STD_EXPORTS` (requires gSOAP 2.8.30 or later).</div><div class="line"><a name="l14988"></a><span class="lineno">14988</span>&#160;</div><div class="line"><a name="l14989"></a><span class="lineno">14989</span>&#160;This DLL links to `stdsoap2.dll`.</div><div class="line"><a name="l14990"></a><span class="lineno">14990</span>&#160;</div><div class="line"><a name="l14991"></a><span class="lineno">14991</span>&#160;To create multiple DLLs in the same project directory, you SHOULD use option</div><div class="line"><a name="l14992"></a><span class="lineno">14992</span>&#160;`-p` to rename the generated `soapClientLib.cpp` and</div><div class="line"><a name="l14993"></a><span class="lineno">14993</span>&#160;`soapServerLib.cpp` (and associated) files. The `-p` option specifies</div><div class="line"><a name="l14994"></a><span class="lineno">14994</span>&#160;the file name prefix to replace the `soap` prefix.</div><div class="line"><a name="l14995"></a><span class="lineno">14995</span>&#160;A clean separation of libraries can also be achieved with C++ namespaces, see Section \ref codenamespace .</div><div class="line"><a name="l14996"></a><span class="lineno">14996</span>&#160;</div><div class="line"><a name="l14997"></a><span class="lineno">14997</span>&#160;Unless you use the client proxy and server object classes (`soapXProxy.h` and `soapXObject.h` where `X` is the name of the service), all client and server applications MUST explicitly set the namespaces value of the gSOAP context:</div><div class="line"><a name="l14998"></a><span class="lineno">14998</span>&#160;</div><div class="line"><a name="l14999"></a><span class="lineno">14999</span>&#160;```cpp</div><div class="line"><a name="l15000"></a><span class="lineno">15000</span>&#160;soap_init(&amp;soap); </div><div class="line"><a name="l15001"></a><span class="lineno">15001</span>&#160;soap_set_namespaces(&amp;soap, namespaces);</div><div class="line"><a name="l15002"></a><span class="lineno">15002</span>&#160;```</div><div class="line"><a name="l15003"></a><span class="lineno">15003</span>&#160;</div><div class="line"><a name="l15004"></a><span class="lineno">15004</span>&#160;where the `namespaces[]` table should be defined in the client/server source. These tables are generated in the `.nsmap` files. You can rename the tables using option `-n`, see Section \ref options .</div><div class="line"><a name="l15005"></a><span class="lineno">15005</span>&#160;</div><div class="line"><a name="l15006"></a><span class="lineno">15006</span>&#160;## gSOAP Plug-ins        {#plugins}</div><div class="line"><a name="l15007"></a><span class="lineno">15007</span>&#160;</div><div class="line"><a name="l15008"></a><span class="lineno">15008</span>&#160;The gSOAP plug-in feature enables a convenient extension mechanism of gSOAP</div><div class="line"><a name="l15009"></a><span class="lineno">15009</span>&#160;capabilities. When the plug-in registers with gSOAP, it has full access</div><div class="line"><a name="l15010"></a><span class="lineno">15010</span>&#160;to the run-time settings and the gSOAP function callbacks.</div><div class="line"><a name="l15011"></a><span class="lineno">15011</span>&#160;Upon registry, the plug-in&#39;s local data is associated with the gSOAP run-time.</div><div class="line"><a name="l15012"></a><span class="lineno">15012</span>&#160;By overriding gSOAP&#39;s function callbacks with the plug-in&#39;s function callbacks,</div><div class="line"><a name="l15013"></a><span class="lineno">15013</span>&#160;the plug-in can extend gSOAP&#39;s capabilities. The local plug-in data can be</div><div class="line"><a name="l15014"></a><span class="lineno">15014</span>&#160;accessed through a lookup function, usually invoked within a callback function</div><div class="line"><a name="l15015"></a><span class="lineno">15015</span>&#160;to access the plug-in data. </div><div class="line"><a name="l15016"></a><span class="lineno">15016</span>&#160;The registry and lookup functions are:</div><div class="line"><a name="l15017"></a><span class="lineno">15017</span>&#160;</div><div class="line"><a name="l15018"></a><span class="lineno">15018</span>&#160;```cpp</div><div class="line"><a name="l15019"></a><span class="lineno">15019</span>&#160;int soap_register_plugin_arg(struct soap *soap, int (*fcreate)(struct soap *soap, struct soap_plugin *p, void *arg), void *arg)</div><div class="line"><a name="l15020"></a><span class="lineno">15020</span>&#160;void* soap_lookup_plugin(struct soap*, const char*);</div><div class="line"><a name="l15021"></a><span class="lineno">15021</span>&#160;```</div><div class="line"><a name="l15022"></a><span class="lineno">15022</span>&#160;</div><div class="line"><a name="l15023"></a><span class="lineno">15023</span>&#160;Other functions that deal with plug-ins are:</div><div class="line"><a name="l15024"></a><span class="lineno">15024</span>&#160;</div><div class="line"><a name="l15025"></a><span class="lineno">15025</span>&#160;```cpp</div><div class="line"><a name="l15026"></a><span class="lineno">15026</span>&#160;int soap_copy(struct soap *soap); </div><div class="line"><a name="l15027"></a><span class="lineno">15027</span>&#160;void soap_done(struct soap *soap);</div><div class="line"><a name="l15028"></a><span class="lineno">15028</span>&#160;```</div><div class="line"><a name="l15029"></a><span class="lineno">15029</span>&#160;</div><div class="line"><a name="l15030"></a><span class="lineno">15030</span>&#160;The `soap_copy` function returns a new dynamically allocated gSOAP</div><div class="line"><a name="l15031"></a><span class="lineno">15031</span>&#160;context that is a copy of another, such that no data is shared between the</div><div class="line"><a name="l15032"></a><span class="lineno">15032</span>&#160;copy and the original context. The `soap_copy` function invokes the</div><div class="line"><a name="l15033"></a><span class="lineno">15033</span>&#160;plug-in copy callbacks to copy the plug-ins&#39; local data.</div><div class="line"><a name="l15034"></a><span class="lineno">15034</span>&#160;The `soap_copy` function returns a gSOAP error code or `SOAP_OK`.</div><div class="line"><a name="l15035"></a><span class="lineno">15035</span>&#160;The `soap_done` function de-registers all plugin-ins, so this function</div><div class="line"><a name="l15036"></a><span class="lineno">15036</span>&#160;should be called to cleanly terminate a gSOAP run-time context.</div><div class="line"><a name="l15037"></a><span class="lineno">15037</span>&#160;</div><div class="line"><a name="l15038"></a><span class="lineno">15038</span>&#160;An example will be used to illustrate these functions.</div><div class="line"><a name="l15039"></a><span class="lineno">15039</span>&#160;This example overrides the send and receive callbacks to copy all messages</div><div class="line"><a name="l15040"></a><span class="lineno">15040</span>&#160;that are sent and received to the terminal (stderr).</div><div class="line"><a name="l15041"></a><span class="lineno">15041</span>&#160;</div><div class="line"><a name="l15042"></a><span class="lineno">15042</span>&#160;First, we write a header file `plugin.h` to define the local plug-in data</div><div class="line"><a name="l15043"></a><span class="lineno">15043</span>&#160;structure(s) and we define a global name to identify the plug-in:</div><div class="line"><a name="l15044"></a><span class="lineno">15044</span>&#160;</div><div class="line"><a name="l15045"></a><span class="lineno">15045</span>&#160;```cpp</div><div class="line"><a name="l15046"></a><span class="lineno">15046</span>&#160;#include &quot;stdsoap2.h&quot; </div><div class="line"><a name="l15047"></a><span class="lineno">15047</span>&#160;#define PLUGIN_ID &quot;PLUGIN-1.0&quot; // some name to identify plugin </div><div class="line"><a name="l15048"></a><span class="lineno">15048</span>&#160;struct plugin_data // local plugin data </div><div class="line"><a name="l15049"></a><span class="lineno">15049</span>&#160;{ </div><div class="line"><a name="l15050"></a><span class="lineno">15050</span>&#160;   int (*fsend)(struct soap*, const char*, size_t); // to save and use send callback </div><div class="line"><a name="l15051"></a><span class="lineno">15051</span>&#160;   size_t (*frecv)(struct soap*, char*, size_t); // to save and use recv callback </div><div class="line"><a name="l15052"></a><span class="lineno">15052</span>&#160;}; </div><div class="line"><a name="l15053"></a><span class="lineno">15053</span>&#160;int plugin(struct soap *soap, struct soap_plugin *plugin, void *arg);</div><div class="line"><a name="l15054"></a><span class="lineno">15054</span>&#160;```</div><div class="line"><a name="l15055"></a><span class="lineno">15055</span>&#160;</div><div class="line"><a name="l15056"></a><span class="lineno">15056</span>&#160;Then, we write the plugin registry function and the callbacks:</div><div class="line"><a name="l15057"></a><span class="lineno">15057</span>&#160;</div><div class="line"><a name="l15058"></a><span class="lineno">15058</span>&#160;```cpp</div><div class="line"><a name="l15059"></a><span class="lineno">15059</span>&#160;#include &quot;plugin.h&quot; </div><div class="line"><a name="l15060"></a><span class="lineno">15060</span>&#160;static const char plugin_id[] = PLUGIN_ID; // the plugin id </div><div class="line"><a name="l15061"></a><span class="lineno">15061</span>&#160;static int plugin_init(struct soap *soap, struct plugin_data *data); </div><div class="line"><a name="l15062"></a><span class="lineno">15062</span>&#160;static int plugin_copy(struct soap *soap, struct soap_plugin *dst, struct soap_plugin *src); </div><div class="line"><a name="l15063"></a><span class="lineno">15063</span>&#160;static void plugin_delete(struct soap *soap, struct soap_plugin *p); </div><div class="line"><a name="l15064"></a><span class="lineno">15064</span>&#160;static int plugin_send(struct soap *soap, const char *buf, size_t len); </div><div class="line"><a name="l15065"></a><span class="lineno">15065</span>&#160;static size_t plugin_recv(struct soap *soap, char *buf, size_t len); </div><div class="line"><a name="l15066"></a><span class="lineno">15066</span>&#160;// the registry function: </div><div class="line"><a name="l15067"></a><span class="lineno">15067</span>&#160;int plugin(struct soap *soap, struct soap_plugin *p, void *arg) </div><div class="line"><a name="l15068"></a><span class="lineno">15068</span>&#160;{ </div><div class="line"><a name="l15069"></a><span class="lineno">15069</span>&#160;   p-&gt;id = plugin_id; </div><div class="line"><a name="l15070"></a><span class="lineno">15070</span>&#160;   p-&gt;data = (void*)malloc(sizeof(struct plugin_data)); </div><div class="line"><a name="l15071"></a><span class="lineno">15071</span>&#160;   p-&gt;fcopy = plugin_copy; /* optional: when set the plugin must copy its local data */</div><div class="line"><a name="l15072"></a><span class="lineno">15072</span>&#160;   p-&gt;fdelete = plugin_delete; </div><div class="line"><a name="l15073"></a><span class="lineno">15073</span>&#160;   if (p-&gt;data) </div><div class="line"><a name="l15074"></a><span class="lineno">15074</span>&#160;     if (plugin_init(soap, (struct plugin_data*)p-&gt;data)) </div><div class="line"><a name="l15075"></a><span class="lineno">15075</span>&#160;     { </div><div class="line"><a name="l15076"></a><span class="lineno">15076</span>&#160;       free(p-&gt;data); // error: could not init </div><div class="line"><a name="l15077"></a><span class="lineno">15077</span>&#160;       return SOAP_EOM; // return error </div><div class="line"><a name="l15078"></a><span class="lineno">15078</span>&#160;     } </div><div class="line"><a name="l15079"></a><span class="lineno">15079</span>&#160;   return SOAP_OK; </div><div class="line"><a name="l15080"></a><span class="lineno">15080</span>&#160;} </div><div class="line"><a name="l15081"></a><span class="lineno">15081</span>&#160;static int plugin_init(struct soap *soap, struct plugin_data *data) </div><div class="line"><a name="l15082"></a><span class="lineno">15082</span>&#160;{ </div><div class="line"><a name="l15083"></a><span class="lineno">15083</span>&#160;   data-&gt;fsend = soap-&gt;fsend; // save old recv callback </div><div class="line"><a name="l15084"></a><span class="lineno">15084</span>&#160;   data-&gt;frecv = soap-&gt;frecv; // save old send callback </div><div class="line"><a name="l15085"></a><span class="lineno">15085</span>&#160;   soap-&gt;fsend = plugin_send; // replace send callback with new </div><div class="line"><a name="l15086"></a><span class="lineno">15086</span>&#160;   soap-&gt;frecv = plugin_recv; // replace recv callback with new </div><div class="line"><a name="l15087"></a><span class="lineno">15087</span>&#160;   return SOAP_OK; </div><div class="line"><a name="l15088"></a><span class="lineno">15088</span>&#160;} </div><div class="line"><a name="l15089"></a><span class="lineno">15089</span>&#160;// copy plugin data, called by soap_copy()</div><div class="line"><a name="l15090"></a><span class="lineno">15090</span>&#160;// This is important: we need a deep copy to avoid data sharing by two run-time contexts </div><div class="line"><a name="l15091"></a><span class="lineno">15091</span>&#160;static int plugin_copy(struct soap *soap, struct soap_plugin *dst, struct soap_plugin *src) </div><div class="line"><a name="l15092"></a><span class="lineno">15092</span>&#160;{ </div><div class="line"><a name="l15093"></a><span class="lineno">15093</span>&#160;   if (!(dst-&gt;data = (struct plugin_data*)malloc(sizeof(struct plugin_data)))) </div><div class="line"><a name="l15094"></a><span class="lineno">15094</span>&#160;     return SOAP_EOM; </div><div class="line"><a name="l15095"></a><span class="lineno">15095</span>&#160;   *dst-&gt;data = *src-&gt;data; </div><div class="line"><a name="l15096"></a><span class="lineno">15096</span>&#160;   return SOAP_OK; </div><div class="line"><a name="l15097"></a><span class="lineno">15097</span>&#160;} </div><div class="line"><a name="l15098"></a><span class="lineno">15098</span>&#160;// plugin deletion, called by soap_done() </div><div class="line"><a name="l15099"></a><span class="lineno">15099</span>&#160;static void plugin_delete(struct soap *soap, struct soap_plugin *p) </div><div class="line"><a name="l15100"></a><span class="lineno">15100</span>&#160;{ free(p-&gt;data); // free allocated plugin data </div><div class="line"><a name="l15101"></a><span class="lineno">15101</span>&#160;} </div><div class="line"><a name="l15102"></a><span class="lineno">15102</span>&#160;// the new send callback </div><div class="line"><a name="l15103"></a><span class="lineno">15103</span>&#160;static int plugin_send(struct soap *soap, const char *buf, size_t len) </div><div class="line"><a name="l15104"></a><span class="lineno">15104</span>&#160;{ </div><div class="line"><a name="l15105"></a><span class="lineno">15105</span>&#160;   struct plugin_data *data = (struct plugin_data*)soap_lookup_plugin(soap, plugin_id); // fetch plugin&#39;s local data </div><div class="line"><a name="l15106"></a><span class="lineno">15106</span>&#160;   fwrite(buf, len, 1, stderr); // write message to stderr </div><div class="line"><a name="l15107"></a><span class="lineno">15107</span>&#160;   return data-&gt;fsend(soap, buf, len); // pass data on to old send callback </div><div class="line"><a name="l15108"></a><span class="lineno">15108</span>&#160;} </div><div class="line"><a name="l15109"></a><span class="lineno">15109</span>&#160;// the new receive callback </div><div class="line"><a name="l15110"></a><span class="lineno">15110</span>&#160;static size_t plugin_recv(struct soap *soap, char *buf, size_t len) </div><div class="line"><a name="l15111"></a><span class="lineno">15111</span>&#160;{ </div><div class="line"><a name="l15112"></a><span class="lineno">15112</span>&#160;   struct plugin_data *data = (struct plugin_data*)soap_lookup_plugin(soap, plugin_id); // fetch plugin&#39;s local data </div><div class="line"><a name="l15113"></a><span class="lineno">15113</span>&#160;   size_t res = data-&gt;frecv(soap, buf, len); // get data from old recv callback </div><div class="line"><a name="l15114"></a><span class="lineno">15114</span>&#160;   fwrite(buf, res, 1, stderr); </div><div class="line"><a name="l15115"></a><span class="lineno">15115</span>&#160;   return res; </div><div class="line"><a name="l15116"></a><span class="lineno">15116</span>&#160;}</div><div class="line"><a name="l15117"></a><span class="lineno">15117</span>&#160;```</div><div class="line"><a name="l15118"></a><span class="lineno">15118</span>&#160;</div><div class="line"><a name="l15119"></a><span class="lineno">15119</span>&#160;The `fdelete` callback of `struct soap_plugin`</div><div class="line"><a name="l15120"></a><span class="lineno">15120</span>&#160;MUST be set to register the plugin. It is the responsibility of the plug-in to</div><div class="line"><a name="l15121"></a><span class="lineno">15121</span>&#160;handle registry (init), copy, and deletion of the plug-in data and callbacks.</div><div class="line"><a name="l15122"></a><span class="lineno">15122</span>&#160;</div><div class="line"><a name="l15123"></a><span class="lineno">15123</span>&#160;A plugin is copied with the `soap_copy()` call. This function copies a soap struct</div><div class="line"><a name="l15124"></a><span class="lineno">15124</span>&#160;and the chain of plugins. It is up to the plugin implementation to share the plugin data</div><div class="line"><a name="l15125"></a><span class="lineno">15125</span>&#160;or not: </div><div class="line"><a name="l15126"></a><span class="lineno">15126</span>&#160;</div><div class="line"><a name="l15127"></a><span class="lineno">15127</span>&#160;</div><div class="line"><a name="l15128"></a><span class="lineno">15128</span>&#160;*  if the `fcopy()` callback is set by the plugin initialization, this callback will be called to allow</div><div class="line"><a name="l15129"></a><span class="lineno">15129</span>&#160;the plugin to copy its local data upon a `soap_copy()` call. When `soap_done()` is called on</div><div class="line"><a name="l15130"></a><span class="lineno">15130</span>&#160;the soap struct copy, the `fdelete()` callback is called for deallocation and cleanup of the local data.</div><div class="line"><a name="l15131"></a><span class="lineno">15131</span>&#160;</div><div class="line"><a name="l15132"></a><span class="lineno">15132</span>&#160;* </div><div class="line"><a name="l15133"></a><span class="lineno">15133</span>&#160;if the `fcopy()` callback is not set, then the plugin data</div><div class="line"><a name="l15134"></a><span class="lineno">15134</span>&#160;will be shared (i.e. the data pointer points to the same address).</div><div class="line"><a name="l15135"></a><span class="lineno">15135</span>&#160;The `fdelete()` callback will not be called upon a `soap_done()` on a</div><div class="line"><a name="l15136"></a><span class="lineno">15136</span>&#160;copy of the soap struct. The `fdelete()` callback will be called for</div><div class="line"><a name="l15137"></a><span class="lineno">15137</span>&#160;the original soap struct with which the plugin was registered.</div><div class="line"><a name="l15138"></a><span class="lineno">15138</span>&#160;</div><div class="line"><a name="l15139"></a><span class="lineno">15139</span>&#160;The example plug-in should be used as follows:</div><div class="line"><a name="l15140"></a><span class="lineno">15140</span>&#160;</div><div class="line"><a name="l15141"></a><span class="lineno">15141</span>&#160;```cpp</div><div class="line"><a name="l15142"></a><span class="lineno">15142</span>&#160;struct soap soap; </div><div class="line"><a name="l15143"></a><span class="lineno">15143</span>&#160;soap_init(&amp;soap); </div><div class="line"><a name="l15144"></a><span class="lineno">15144</span>&#160;soap_register_plugin(&amp;soap, plugin); </div><div class="line"><a name="l15145"></a><span class="lineno">15145</span>&#160;... </div><div class="line"><a name="l15146"></a><span class="lineno">15146</span>&#160;soap_done(&amp;soap);</div><div class="line"><a name="l15147"></a><span class="lineno">15147</span>&#160;```</div><div class="line"><a name="l15148"></a><span class="lineno">15148</span>&#160;</div><div class="line"><a name="l15149"></a><span class="lineno">15149</span>&#160;Note: `soap_register_plugin(...)` is an alias for</div><div class="line"><a name="l15150"></a><span class="lineno">15150</span>&#160;`soap_register_plugin_arg(..., NULL)`. That is, it passes NULL as an</div><div class="line"><a name="l15151"></a><span class="lineno">15151</span>&#160;argument to plug-in&#39;s registry callback.</div><div class="line"><a name="l15152"></a><span class="lineno">15152</span>&#160;</div><div class="line"><a name="l15153"></a><span class="lineno">15153</span>&#160;A number of example plug-ins are included in the gSOAP package&#39;s `plugin` directory. Some of these plug-ins are discussed.</div><div class="line"><a name="l15154"></a><span class="lineno">15154</span>&#160;</div><div class="line"><a name="l15155"></a><span class="lineno">15155</span>&#160;### The Message Logging and Statistics Plug-in</div><div class="line"><a name="l15156"></a><span class="lineno">15156</span>&#160;</div><div class="line"><a name="l15157"></a><span class="lineno">15157</span>&#160;The message logging and access statistics plug-in can be used to selectively log inbound and outbound messages to a file or stream. It also keeps access statistics to log the total number of bytes sent and received.</div><div class="line"><a name="l15158"></a><span class="lineno">15158</span>&#160;</div><div class="line"><a name="l15159"></a><span class="lineno">15159</span>&#160;To use the plug-in, compile and link your application with `logging.c` located in the `plugin` directory of the package.</div><div class="line"><a name="l15160"></a><span class="lineno">15160</span>&#160;To enable the plug-in in your code, register the plug-in and set the streams as follows:</div><div class="line"><a name="l15161"></a><span class="lineno">15161</span>&#160;</div><div class="line"><a name="l15162"></a><span class="lineno">15162</span>&#160;```cpp</div><div class="line"><a name="l15163"></a><span class="lineno">15163</span>&#160;#include &quot;logging.h&quot; </div><div class="line"><a name="l15164"></a><span class="lineno">15164</span>&#160;size_t bytes_in; </div><div class="line"><a name="l15165"></a><span class="lineno">15165</span>&#160;size_t bytes_out; </div><div class="line"><a name="l15166"></a><span class="lineno">15166</span>&#160;... </div><div class="line"><a name="l15167"></a><span class="lineno">15167</span>&#160;if (soap_register_plugin(&amp;soap, logging)) </div><div class="line"><a name="l15168"></a><span class="lineno">15168</span>&#160;   soap_print_fault(&amp;soap, stderr); // failed to register </div><div class="line"><a name="l15169"></a><span class="lineno">15169</span>&#160;... </div><div class="line"><a name="l15170"></a><span class="lineno">15170</span>&#160;soap_set_logging_inbound(&amp;soap, stdout); </div><div class="line"><a name="l15171"></a><span class="lineno">15171</span>&#160;soap_set_logging_outbound(&amp;soap, stdout); </div><div class="line"><a name="l15172"></a><span class="lineno">15172</span>&#160;... process messages ... </div><div class="line"><a name="l15173"></a><span class="lineno">15173</span>&#160;soap_set_logging_inbound(&amp;soap, NULL); // disable logging </div><div class="line"><a name="l15174"></a><span class="lineno">15174</span>&#160;soap_set_logging_outbound(&amp;soap, NULL); // disable logging </div><div class="line"><a name="l15175"></a><span class="lineno">15175</span>&#160;soap_get_logging_stats(&amp;soap, &amp;bytes_out, &amp;bytes_in);</div><div class="line"><a name="l15176"></a><span class="lineno">15176</span>&#160;```</div><div class="line"><a name="l15177"></a><span class="lineno">15177</span>&#160;</div><div class="line"><a name="l15178"></a><span class="lineno">15178</span>&#160;If you use `soap_copy` to copy the soap struct with the plug-in, the plug-in&#39;s data will be shared by the copy.</div><div class="line"><a name="l15179"></a><span class="lineno">15179</span>&#160;Therefore, the statistics are not 100% guaranteed to be accurate for multi-threaded services since race conditions on the counters may occur. Mutex is not used to update the counters to avoid introducing expensive synchronization points. If 100% server-side accuracy is required, add mutex at the points indicated in the `logging.c` code.</div><div class="line"><a name="l15180"></a><span class="lineno">15180</span>&#160;</div><div class="line"><a name="l15181"></a><span class="lineno">15181</span>&#160;### RESTful Client-Side API</div><div class="line"><a name="l15182"></a><span class="lineno">15182</span>&#160;</div><div class="line"><a name="l15183"></a><span class="lineno">15183</span>&#160;The soapcpp2 tool generates the following functions for client-side REST operations:</div><div class="line"><a name="l15184"></a><span class="lineno">15184</span>&#160;</div><div class="line"><a name="l15185"></a><span class="lineno">15185</span>&#160;`soap_PUT_`*Name*`(struct soap *soap, const char *URL, `*Type*`* data)`</div><div class="line"><a name="l15186"></a><span class="lineno">15186</span>&#160;REST PUT XML of type *Type* to the endoint at the specified URL.</div><div class="line"><a name="l15187"></a><span class="lineno">15187</span>&#160;</div><div class="line"><a name="l15188"></a><span class="lineno">15188</span>&#160;`soap_POST_send_`*Name*`(struct soap *soap, const char *URL, `*Type*`* data)`</div><div class="line"><a name="l15189"></a><span class="lineno">15189</span>&#160;REST POST send XML of type *Type* to the endoint at the specified URL, which MUST be followed by a REST POST receive (see below) to receive response data.</div><div class="line"><a name="l15190"></a><span class="lineno">15190</span>&#160;</div><div class="line"><a name="l15191"></a><span class="lineno">15191</span>&#160;`soap_GET_`*Name*`(struct soap *soap, const char *URL, `*Type*`* data)`</div><div class="line"><a name="l15192"></a><span class="lineno">15192</span>&#160;REST GET XML of type *Type* from the endoint at the specified URL.</div><div class="line"><a name="l15193"></a><span class="lineno">15193</span>&#160;</div><div class="line"><a name="l15194"></a><span class="lineno">15194</span>&#160;`soap_POST_recv_`*Name*`(struct soap *soap, `*Type*`* data)`</div><div class="line"><a name="l15195"></a><span class="lineno">15195</span>&#160;REST POST receive XML of type *Type* after REST POST send.</div><div class="line"><a name="l15196"></a><span class="lineno">15196</span>&#160;</div><div class="line"><a name="l15197"></a><span class="lineno">15197</span>&#160;The REST POST operation is a two-step process, first a POST send of the data</div><div class="line"><a name="l15198"></a><span class="lineno">15198</span>&#160;followed by a POST receive of the response data.</div><div class="line"><a name="l15199"></a><span class="lineno">15199</span>&#160;</div><div class="line"><a name="l15200"></a><span class="lineno">15200</span>&#160;### RESTful Server-Side API: The HTTP GET Plug-in</div><div class="line"><a name="l15201"></a><span class="lineno">15201</span>&#160;</div><div class="line"><a name="l15202"></a><span class="lineno">15202</span>&#160;Server-side use of RESTful HTTP GET operations is supported with the HTTP GET</div><div class="line"><a name="l15203"></a><span class="lineno">15203</span>&#160;plug-in `plugin/httpget.c`.</div><div class="line"><a name="l15204"></a><span class="lineno">15204</span>&#160;</div><div class="line"><a name="l15205"></a><span class="lineno">15205</span>&#160;The HTTP GET plug-in allows your server to handle RESTful HTTP GET requests and</div><div class="line"><a name="l15206"></a><span class="lineno">15206</span>&#160;at the same time still serve SOAP-based POST requests. The plug-in provides</div><div class="line"><a name="l15207"></a><span class="lineno">15207</span>&#160;support to client applications to issue HTTP GET operations to a server.</div><div class="line"><a name="l15208"></a><span class="lineno">15208</span>&#160;</div><div class="line"><a name="l15209"></a><span class="lineno">15209</span>&#160;Note that HTTP GET requests can also be handled at the server side with the</div><div class="line"><a name="l15210"></a><span class="lineno">15210</span>&#160;`fget` callback, see Section \ref callback . However, the HTTP GET</div><div class="line"><a name="l15211"></a><span class="lineno">15211</span>&#160;plug-in also keeps statistics on the number of successful POST and GET</div><div class="line"><a name="l15212"></a><span class="lineno">15212</span>&#160;exchanges and failed operations (HTTP faults, SOAP Faults, etc.). It also keeps</div><div class="line"><a name="l15213"></a><span class="lineno">15213</span>&#160;hit histograms accumulated for up to a year of runtime.</div><div class="line"><a name="l15214"></a><span class="lineno">15214</span>&#160;</div><div class="line"><a name="l15215"></a><span class="lineno">15215</span>&#160;To use the plug-in, compile and link your application with `httpget.c` located in the `plugin` directory of the package.</div><div class="line"><a name="l15216"></a><span class="lineno">15216</span>&#160;To enable the plug-in in your code, register the plug-in with your HTTP GET handler function as follows:</div><div class="line"><a name="l15217"></a><span class="lineno">15217</span>&#160;</div><div class="line"><a name="l15218"></a><span class="lineno">15218</span>&#160;```cpp</div><div class="line"><a name="l15219"></a><span class="lineno">15219</span>&#160;#include &quot;httpget.h&quot; </div><div class="line"><a name="l15220"></a><span class="lineno">15220</span>&#160;... </div><div class="line"><a name="l15221"></a><span class="lineno">15221</span>&#160;if (soap_register_plugin_arg(&amp;soap, httpget, (void*)my_http_get_handler)) </div><div class="line"><a name="l15222"></a><span class="lineno">15222</span>&#160;   soap_print_fault(&amp;soap, stderr); // failed to register </div><div class="line"><a name="l15223"></a><span class="lineno">15223</span>&#160;... </div><div class="line"><a name="l15224"></a><span class="lineno">15224</span>&#160;struct http_get_data *httpgetdata; </div><div class="line"><a name="l15225"></a><span class="lineno">15225</span>&#160;httpgetdata = (struct http_get_data*)soap_lookup_plugin(&amp;soap, http_get_id); </div><div class="line"><a name="l15226"></a><span class="lineno">15226</span>&#160;if (!httpgetdata) </div><div class="line"><a name="l15227"></a><span class="lineno">15227</span>&#160;   ... // if the plug-in registered OK, there is certainly data but can&#39;t hurt to check </div><div class="line"><a name="l15228"></a><span class="lineno">15228</span>&#160;... process messages ... </div><div class="line"><a name="l15229"></a><span class="lineno">15229</span>&#160;size_t get_ok = httpgetdata-&gt;stat_get; </div><div class="line"><a name="l15230"></a><span class="lineno">15230</span>&#160;size_t post_ok = httpgetdata-&gt;stat_post; </div><div class="line"><a name="l15231"></a><span class="lineno">15231</span>&#160;size_t errors = httpgetdata-&gt;stat_fail; </div><div class="line"><a name="l15232"></a><span class="lineno">15232</span>&#160;... </div><div class="line"><a name="l15233"></a><span class="lineno">15233</span>&#160;time_t now = time(NULL); </div><div class="line"><a name="l15234"></a><span class="lineno">15234</span>&#160;struct tm *T; </div><div class="line"><a name="l15235"></a><span class="lineno">15235</span>&#160;T = localtime(&amp;now); </div><div class="line"><a name="l15236"></a><span class="lineno">15236</span>&#160;size_t hitsthisminute = httpgetdata-&gt;min[T-&gt;tm_min]; </div><div class="line"><a name="l15237"></a><span class="lineno">15237</span>&#160;size_t hitsthishour = httpgetdata-&gt;hour[T-&gt;tm_hour]; </div><div class="line"><a name="l15238"></a><span class="lineno">15238</span>&#160;size_t hitstoday = httpgetdata-&gt;day[T-&gt;tm_yday];</div><div class="line"><a name="l15239"></a><span class="lineno">15239</span>&#160;```</div><div class="line"><a name="l15240"></a><span class="lineno">15240</span>&#160;</div><div class="line"><a name="l15241"></a><span class="lineno">15241</span>&#160;An HTTP GET handler can simply produce some HTML content, or any other type of content by sending data:</div><div class="line"><a name="l15242"></a><span class="lineno">15242</span>&#160;</div><div class="line"><a name="l15243"></a><span class="lineno">15243</span>&#160;```cpp</div><div class="line"><a name="l15244"></a><span class="lineno">15244</span>&#160;int my_http_get_handler(struct *soap) </div><div class="line"><a name="l15245"></a><span class="lineno">15245</span>&#160;{ </div><div class="line"><a name="l15246"></a><span class="lineno">15246</span>&#160;   soap-&gt;http_content = &quot;text/html&quot;; </div><div class="line"><a name="l15247"></a><span class="lineno">15247</span>&#160;   soap_response(soap, SOAP_FILE); </div><div class="line"><a name="l15248"></a><span class="lineno">15248</span>&#160;   soap_send(soap, &quot;&lt;html&gt;Hello&lt;/html&gt;&quot;); </div><div class="line"><a name="l15249"></a><span class="lineno">15249</span>&#160;   soap_end_send(soap); </div><div class="line"><a name="l15250"></a><span class="lineno">15250</span>&#160;   return SOAP_OK; // return SOAP_OK or HTTP error code, e.g. 404 </div><div class="line"><a name="l15251"></a><span class="lineno">15251</span>&#160;}</div><div class="line"><a name="l15252"></a><span class="lineno">15252</span>&#160;```</div><div class="line"><a name="l15253"></a><span class="lineno">15253</span>&#160;</div><div class="line"><a name="l15254"></a><span class="lineno">15254</span>&#160;If you use `soap_copy` to copy the soap struct with the plug-in, the plug-in&#39;s data will be shared by the copy.</div><div class="line"><a name="l15255"></a><span class="lineno">15255</span>&#160;Therefore, the statistics are not 100% guaranteed to be accurate for multi-threaded services since race conditions on the counters may occur. Mutex is not used to update the counters to avoid introducing expensive synchronization points. If 100% server-side accuracy is required, add mutex at the points indicated in the `httpget.c` code.</div><div class="line"><a name="l15256"></a><span class="lineno">15256</span>&#160;</div><div class="line"><a name="l15257"></a><span class="lineno">15257</span>&#160;The client-side use of HTTP GET is provided by the `soap_get_connect` operation. To receive a SOAP/XML (response) message *`ns:methodResponse`*, use:</div><div class="line"><a name="l15258"></a><span class="lineno">15258</span>&#160;</div><div class="line"><a name="l15259"></a><span class="lineno">15259</span>&#160;```cpp</div><div class="line"><a name="l15260"></a><span class="lineno">15260</span>&#160;#include &quot;httpget.h&quot; </div><div class="line"><a name="l15261"></a><span class="lineno">15261</span>&#160;... </div><div class="line"><a name="l15262"></a><span class="lineno">15262</span>&#160;soap_register_plugin(&amp;soap, http_get); </div><div class="line"><a name="l15263"></a><span class="lineno">15263</span>&#160;... </div><div class="line"><a name="l15264"></a><span class="lineno">15264</span>&#160;if (soap_get_connect(&amp;soap, endpoint, action)) </div><div class="line"><a name="l15265"></a><span class="lineno">15265</span>&#160;   ... connect error ... </div><div class="line"><a name="l15266"></a><span class="lineno">15266</span>&#160;else if (soap_recv_ns__methodResponse(&amp;soap, ... params ...)) </div><div class="line"><a name="l15267"></a><span class="lineno">15267</span>&#160;   ... error ... </div><div class="line"><a name="l15268"></a><span class="lineno">15268</span>&#160;else </div><div class="line"><a name="l15269"></a><span class="lineno">15269</span>&#160;   ... ok ... </div><div class="line"><a name="l15270"></a><span class="lineno">15270</span>&#160;soap_destroy(&amp;soap); </div><div class="line"><a name="l15271"></a><span class="lineno">15271</span>&#160;soap_end(&amp;soap); </div><div class="line"><a name="l15272"></a><span class="lineno">15272</span>&#160;soap_done(&amp;soap);</div><div class="line"><a name="l15273"></a><span class="lineno">15273</span>&#160;```</div><div class="line"><a name="l15274"></a><span class="lineno">15274</span>&#160;</div><div class="line"><a name="l15275"></a><span class="lineno">15275</span>&#160;To receive any HTTP Body data into a buffer, use:</div><div class="line"><a name="l15276"></a><span class="lineno">15276</span>&#160;</div><div class="line"><a name="l15277"></a><span class="lineno">15277</span>&#160;```cpp</div><div class="line"><a name="l15278"></a><span class="lineno">15278</span>&#160;#include &quot;httpget.h&quot; </div><div class="line"><a name="l15279"></a><span class="lineno">15279</span>&#160;... </div><div class="line"><a name="l15280"></a><span class="lineno">15280</span>&#160;char *response = NULL; </div><div class="line"><a name="l15281"></a><span class="lineno">15281</span>&#160;soap_register_plugin(&amp;soap, http_get); </div><div class="line"><a name="l15282"></a><span class="lineno">15282</span>&#160;... </div><div class="line"><a name="l15283"></a><span class="lineno">15283</span>&#160;if (soap_get_connect(&amp;soap, endpoint, NULL)) </div><div class="line"><a name="l15284"></a><span class="lineno">15284</span>&#160;   ... connect error ... </div><div class="line"><a name="l15285"></a><span class="lineno">15285</span>&#160;else if (soap_begin_recv(&amp;soap)) </div><div class="line"><a name="l15286"></a><span class="lineno">15286</span>&#160;   ... error ... </div><div class="line"><a name="l15287"></a><span class="lineno">15287</span>&#160;else </div><div class="line"><a name="l15288"></a><span class="lineno">15288</span>&#160;   response = soap_get_http_body(&amp;soap); </div><div class="line"><a name="l15289"></a><span class="lineno">15289</span>&#160;soap_end_recv(&amp;soap); </div><div class="line"><a name="l15290"></a><span class="lineno">15290</span>&#160;... use the &#39;response&#39; string (NULL indicates no body or error) </div><div class="line"><a name="l15291"></a><span class="lineno">15291</span>&#160;soap_destroy(&amp;soap); </div><div class="line"><a name="l15292"></a><span class="lineno">15292</span>&#160;soap_end(&amp;soap); </div><div class="line"><a name="l15293"></a><span class="lineno">15293</span>&#160;soap_done(&amp;soap);</div><div class="line"><a name="l15294"></a><span class="lineno">15294</span>&#160;```</div><div class="line"><a name="l15295"></a><span class="lineno">15295</span>&#160;</div><div class="line"><a name="l15296"></a><span class="lineno">15296</span>&#160;### RESTful Server-Side API: The HTTP POST Plug-in</div><div class="line"><a name="l15297"></a><span class="lineno">15297</span>&#160;</div><div class="line"><a name="l15298"></a><span class="lineno">15298</span>&#160;Server-side use of RESTful HTTP POST, PUT, and DELETE operations are supported</div><div class="line"><a name="l15299"></a><span class="lineno">15299</span>&#160;with the HTTP POST plug-in `plugin/httppost.c`.</div><div class="line"><a name="l15300"></a><span class="lineno">15300</span>&#160;</div><div class="line"><a name="l15301"></a><span class="lineno">15301</span>&#160;The HTTP POST plug-in allows your server to handle RESTful HTTP POST requests</div><div class="line"><a name="l15302"></a><span class="lineno">15302</span>&#160;and at the same time still serve SOAP-based POST requests. The plug-in also</div><div class="line"><a name="l15303"></a><span class="lineno">15303</span>&#160;provides support for client applications to issue HTTP POST operations to a</div><div class="line"><a name="l15304"></a><span class="lineno">15304</span>&#160;server.</div><div class="line"><a name="l15305"></a><span class="lineno">15305</span>&#160;</div><div class="line"><a name="l15306"></a><span class="lineno">15306</span>&#160;To simplify the server-side handling of POST requests, handlers can be associated with media types:</div><div class="line"><a name="l15307"></a><span class="lineno">15307</span>&#160;</div><div class="line"><a name="l15308"></a><span class="lineno">15308</span>&#160;```cpp</div><div class="line"><a name="l15309"></a><span class="lineno">15309</span>&#160;struct http_post_handlers my_handlers[] = </div><div class="line"><a name="l15310"></a><span class="lineno">15310</span>&#160;{ { &quot;image/jpg&quot;, jpeg_handler }, </div><div class="line"><a name="l15311"></a><span class="lineno">15311</span>&#160;   { &quot;image/ *&quot;,   image_handler }, </div><div class="line"><a name="l15312"></a><span class="lineno">15312</span>&#160;   { &quot;text/html&quot;, html_handler }, </div><div class="line"><a name="l15313"></a><span class="lineno">15313</span>&#160;   { &quot;text/ *&quot;,    text_handler }, </div><div class="line"><a name="l15314"></a><span class="lineno">15314</span>&#160;   { &quot;text/ *;*&quot;,  text_handler }, </div><div class="line"><a name="l15315"></a><span class="lineno">15315</span>&#160;   { &quot;POST&quot;,  generic_POST_handler }, </div><div class="line"><a name="l15316"></a><span class="lineno">15316</span>&#160;   { &quot;PUT&quot;,  generic_PUT_handler }, </div><div class="line"><a name="l15317"></a><span class="lineno">15317</span>&#160;   { &quot;DELETE&quot;,  generic_DELETE_handler }, </div><div class="line"><a name="l15318"></a><span class="lineno">15318</span>&#160;   { NULL } </div><div class="line"><a name="l15319"></a><span class="lineno">15319</span>&#160;};</div><div class="line"><a name="l15320"></a><span class="lineno">15320</span>&#160;```</div><div class="line"><a name="l15321"></a><span class="lineno">15321</span>&#160;</div><div class="line"><a name="l15322"></a><span class="lineno">15322</span>&#160;Note that `*` can be used as a wildcard and some media types may have</div><div class="line"><a name="l15323"></a><span class="lineno">15323</span>&#160;optional parameters (after `;`). The handlers are functions that will be</div><div class="line"><a name="l15324"></a><span class="lineno">15324</span>&#160;invoked when a POSTed request message matching media type is send to the</div><div class="line"><a name="l15325"></a><span class="lineno">15325</span>&#160;server.</div><div class="line"><a name="l15326"></a><span class="lineno">15326</span>&#160;</div><div class="line"><a name="l15327"></a><span class="lineno">15327</span>&#160;An example image handler that checks the specific image type:</div><div class="line"><a name="l15328"></a><span class="lineno">15328</span>&#160;</div><div class="line"><a name="l15329"></a><span class="lineno">15329</span>&#160;```cpp</div><div class="line"><a name="l15330"></a><span class="lineno">15330</span>&#160;int image_handler(struct soap *soap) </div><div class="line"><a name="l15331"></a><span class="lineno">15331</span>&#160;{ const char *buf; </div><div class="line"><a name="l15332"></a><span class="lineno">15332</span>&#160;   size_t len; </div><div class="line"><a name="l15333"></a><span class="lineno">15333</span>&#160;   // if necessary, check type in soap-&gt;http_content </div><div class="line"><a name="l15334"></a><span class="lineno">15334</span>&#160;   if (soap-&gt;http_content &amp;&amp; !soap_tag_cmp(soap-&gt;http_content, &quot;image/gif&quot;) </div><div class="line"><a name="l15335"></a><span class="lineno">15335</span>&#160;     return 404; // HTTP error 404 </div><div class="line"><a name="l15336"></a><span class="lineno">15336</span>&#160;   if (soap_http_body(soap, &amp;buf, &amp;len) != SOAP_OK) </div><div class="line"><a name="l15337"></a><span class="lineno">15337</span>&#160;     return soap-&gt;error; </div><div class="line"><a name="l15338"></a><span class="lineno">15338</span>&#160;   // ... now process image in buf </div><div class="line"><a name="l15339"></a><span class="lineno">15339</span>&#160;   // reply with empty HTTP OK response: </div><div class="line"><a name="l15340"></a><span class="lineno">15340</span>&#160;   soap_response(soap, SOAP_OK); </div><div class="line"><a name="l15341"></a><span class="lineno">15341</span>&#160;   soap_end_send(soap); </div><div class="line"><a name="l15342"></a><span class="lineno">15342</span>&#160;   return SOAP_OK; </div><div class="line"><a name="l15343"></a><span class="lineno">15343</span>&#160;}</div><div class="line"><a name="l15344"></a><span class="lineno">15344</span>&#160;```</div><div class="line"><a name="l15345"></a><span class="lineno">15345</span>&#160;</div><div class="line"><a name="l15346"></a><span class="lineno">15346</span>&#160;The HTTP POST plug-in provides a `soap_http_body` operation as illustrated above to copy the HTTP Body content into a buffer.</div><div class="line"><a name="l15347"></a><span class="lineno">15347</span>&#160;</div><div class="line"><a name="l15348"></a><span class="lineno">15348</span>&#160;The above example returns HTTP OK. If content is supposed to be returned, then use:</div><div class="line"><a name="l15349"></a><span class="lineno">15349</span>&#160;</div><div class="line"><a name="l15350"></a><span class="lineno">15350</span>&#160;```cpp</div><div class="line"><a name="l15351"></a><span class="lineno">15351</span>&#160;   soap-&gt;http_content = &quot;image/jpeg&quot;; // a jpeg image to return back </div><div class="line"><a name="l15352"></a><span class="lineno">15352</span>&#160;   soap_response(soap, SOAP_FILE); // SOAP_FILE sets custom http content </div><div class="line"><a name="l15353"></a><span class="lineno">15353</span>&#160;   soap_send_raw(soap, buf, len); // send image </div><div class="line"><a name="l15354"></a><span class="lineno">15354</span>&#160;   soap_end_send(soap);</div><div class="line"><a name="l15355"></a><span class="lineno">15355</span>&#160;```</div><div class="line"><a name="l15356"></a><span class="lineno">15356</span>&#160;</div><div class="line"><a name="l15357"></a><span class="lineno">15357</span>&#160;For client applications to use HTTP POST, use the `soap_post_connect` operation:</div><div class="line"><a name="l15358"></a><span class="lineno">15358</span>&#160;</div><div class="line"><a name="l15359"></a><span class="lineno">15359</span>&#160;```cpp</div><div class="line"><a name="l15360"></a><span class="lineno">15360</span>&#160;char *buf; // holds the HTTP request/response body data </div><div class="line"><a name="l15361"></a><span class="lineno">15361</span>&#160;size_t len; // length of data </div><div class="line"><a name="l15362"></a><span class="lineno">15362</span>&#160;... </div><div class="line"><a name="l15363"></a><span class="lineno">15363</span>&#160;if (soap_post_connect(soap, &quot;URL&quot;, &quot;SOAP action or NULL&quot;, &quot;media type&quot;) </div><div class="line"><a name="l15364"></a><span class="lineno">15364</span>&#160;   || soap_send_raw(soap, buf, len); </div><div class="line"><a name="l15365"></a><span class="lineno">15365</span>&#160;   || soap_end_send(soap)) </div><div class="line"><a name="l15366"></a><span class="lineno">15366</span>&#160;   ... error ... </div><div class="line"><a name="l15367"></a><span class="lineno">15367</span>&#160;if (soap_begin_recv(&amp;soap) </div><div class="line"><a name="l15368"></a><span class="lineno">15368</span>&#160;   || soap_http_body(&amp;soap, &amp;buf, &amp;len) </div><div class="line"><a name="l15369"></a><span class="lineno">15369</span>&#160;   || soap_end_recv(&amp;soap)) </div><div class="line"><a name="l15370"></a><span class="lineno">15370</span>&#160;   ... error ... </div><div class="line"><a name="l15371"></a><span class="lineno">15371</span>&#160;// ... use buf[0..len-1] </div><div class="line"><a name="l15372"></a><span class="lineno">15372</span>&#160;soap_end(soap);</div><div class="line"><a name="l15373"></a><span class="lineno">15373</span>&#160;```</div><div class="line"><a name="l15374"></a><span class="lineno">15374</span>&#160;</div><div class="line"><a name="l15375"></a><span class="lineno">15375</span>&#160;Similarly, `soap_put_connect` and `soap_delete_connect` commands are provided for PUT and DELETE handling.</div><div class="line"><a name="l15376"></a><span class="lineno">15376</span>&#160;</div><div class="line"><a name="l15377"></a><span class="lineno">15377</span>&#160;### The HTTP MD5 Checksum Plug-in</div><div class="line"><a name="l15378"></a><span class="lineno">15378</span>&#160;</div><div class="line"><a name="l15379"></a><span class="lineno">15379</span>&#160;The HTTP MD5 plug-in works in the background to automatically verify the</div><div class="line"><a name="l15380"></a><span class="lineno">15380</span>&#160;content of messages using MD5 checksums. With the plug-in, messages can be</div><div class="line"><a name="l15381"></a><span class="lineno">15381</span>&#160;transferred over (trusted but) unreliable connections. The plug-in can be used</div><div class="line"><a name="l15382"></a><span class="lineno">15382</span>&#160;on the client side and server side.</div><div class="line"><a name="l15383"></a><span class="lineno">15383</span>&#160;</div><div class="line"><a name="l15384"></a><span class="lineno">15384</span>&#160;To use the plug-in, compile and link your application with `httpmd5.c` and `md5evp.c` located in the `plugin` directory of the package. The `md5evp.c` implementation uses the EVP interface to compute MD5 checksums with OpenSSL (compiled with `-DWITH_OPENSSL`).</div><div class="line"><a name="l15385"></a><span class="lineno">15385</span>&#160;</div><div class="line"><a name="l15386"></a><span class="lineno">15386</span>&#160;To enable the plug-in in your code, register the plug-in as follows:</div><div class="line"><a name="l15387"></a><span class="lineno">15387</span>&#160;</div><div class="line"><a name="l15388"></a><span class="lineno">15388</span>&#160;```cpp</div><div class="line"><a name="l15389"></a><span class="lineno">15389</span>&#160;#include &quot;httpmd5.h&quot; </div><div class="line"><a name="l15390"></a><span class="lineno">15390</span>&#160;... </div><div class="line"><a name="l15391"></a><span class="lineno">15391</span>&#160;if (soap_register_plugin(&amp;soap, http_md5)) </div><div class="line"><a name="l15392"></a><span class="lineno">15392</span>&#160;   soap_print_fault(&amp;soap, stderr); // failed to register</div><div class="line"><a name="l15393"></a><span class="lineno">15393</span>&#160;```</div><div class="line"><a name="l15394"></a><span class="lineno">15394</span>&#160;</div><div class="line"><a name="l15395"></a><span class="lineno">15395</span>&#160;Once registered, MD5 checksums are produced for all outbound messages. Inbound messages with MD5 checksums in the HTTP header are automatically verified.</div><div class="line"><a name="l15396"></a><span class="lineno">15396</span>&#160;</div><div class="line"><a name="l15397"></a><span class="lineno">15397</span>&#160;The plug-in requires you to set the `SOAP_IO_STORE` flag when sending SOAP with attachments:</div><div class="line"><a name="l15398"></a><span class="lineno">15398</span>&#160;</div><div class="line"><a name="l15399"></a><span class="lineno">15399</span>&#160;```cpp</div><div class="line"><a name="l15400"></a><span class="lineno">15400</span>&#160;#include &quot;httpmd5.h&quot; </div><div class="line"><a name="l15401"></a><span class="lineno">15401</span>&#160;... </div><div class="line"><a name="l15402"></a><span class="lineno">15402</span>&#160;struct soap soap; </div><div class="line"><a name="l15403"></a><span class="lineno">15403</span>&#160;soap_init1(&amp;soap, SOAP_IO_STORE); </div><div class="line"><a name="l15404"></a><span class="lineno">15404</span>&#160;if (soap_register_plugin(&amp;soap, http_md5) </div><div class="line"><a name="l15405"></a><span class="lineno">15405</span>&#160;   soap_print_fault(&amp;soap, stderr); // failed to register </div><div class="line"><a name="l15406"></a><span class="lineno">15406</span>&#160;... now safe to send SOAP with attachments ...</div><div class="line"><a name="l15407"></a><span class="lineno">15407</span>&#160;```</div><div class="line"><a name="l15408"></a><span class="lineno">15408</span>&#160;</div><div class="line"><a name="l15409"></a><span class="lineno">15409</span>&#160;Unfortunately, this eliminates streaming.</div><div class="line"><a name="l15410"></a><span class="lineno">15410</span>&#160;</div><div class="line"><a name="l15411"></a><span class="lineno">15411</span>&#160;### The HTTP Digest Authentication Plug-in</div><div class="line"><a name="l15412"></a><span class="lineno">15412</span>&#160;</div><div class="line"><a name="l15413"></a><span class="lineno">15413</span>&#160;The HTTP digest authentication plug-in enables a more secure authentication</div><div class="line"><a name="l15414"></a><span class="lineno">15414</span>&#160;scheme compared to basic authentication. HTTP basic authentication sends</div><div class="line"><a name="l15415"></a><span class="lineno">15415</span>&#160;unencrypted userids and passwords over the net, while digest authentication</div><div class="line"><a name="l15416"></a><span class="lineno">15416</span>&#160;does not exchange passwords but exchanges checksums of passwords (and other</div><div class="line"><a name="l15417"></a><span class="lineno">15417</span>&#160;data such as nonces to avoid replay attacks). For more details, please see</div><div class="line"><a name="l15418"></a><span class="lineno">15418</span>&#160;RFC 2617.</div><div class="line"><a name="l15419"></a><span class="lineno">15419</span>&#160;</div><div class="line"><a name="l15420"></a><span class="lineno">15420</span>&#160;The HTTP digest authentication can be used next to the built-in basic</div><div class="line"><a name="l15421"></a><span class="lineno">15421</span>&#160;authentication, or basic authentication can be rejected to tighten security.</div><div class="line"><a name="l15422"></a><span class="lineno">15422</span>&#160;The server must have a database with userid&#39;s and passwords (in plain text</div><div class="line"><a name="l15423"></a><span class="lineno">15423</span>&#160;form). The client, when challenged by the server, checks the authentication</div><div class="line"><a name="l15424"></a><span class="lineno">15424</span>&#160;realm provided by the server and sets the userid and passwords for digest</div><div class="line"><a name="l15425"></a><span class="lineno">15425</span>&#160;authentication. The client application can temporarily store the userid and</div><div class="line"><a name="l15426"></a><span class="lineno">15426</span>&#160;password for a sequence of message exchanges with the server, which is faster</div><div class="line"><a name="l15427"></a><span class="lineno">15427</span>&#160;than repeated authorization challenges and authentication responses.</div><div class="line"><a name="l15428"></a><span class="lineno">15428</span>&#160;</div><div class="line"><a name="l15429"></a><span class="lineno">15429</span>&#160;At the client side, the plug-in is registered and service invocations are</div><div class="line"><a name="l15430"></a><span class="lineno">15430</span>&#160;checked for authorization challenges (HTTP error code 401). When the server</div><div class="line"><a name="l15431"></a><span class="lineno">15431</span>&#160;challenges the client, the client should set the userid and password and retry</div><div class="line"><a name="l15432"></a><span class="lineno">15432</span>&#160;the invocation. The client can determine the userid and password based on the</div><div class="line"><a name="l15433"></a><span class="lineno">15433</span>&#160;authentication realm part of the server&#39;s challenge. The authentication information can be temporarily saved for multiple invocations.</div><div class="line"><a name="l15434"></a><span class="lineno">15434</span>&#160;</div><div class="line"><a name="l15435"></a><span class="lineno">15435</span>&#160;Client-side example:</div><div class="line"><a name="l15436"></a><span class="lineno">15436</span>&#160;</div><div class="line"><a name="l15437"></a><span class="lineno">15437</span>&#160;```cpp</div><div class="line"><a name="l15438"></a><span class="lineno">15438</span>&#160;#include &quot;httpda.h&quot; </div><div class="line"><a name="l15439"></a><span class="lineno">15439</span>&#160;... </div><div class="line"><a name="l15440"></a><span class="lineno">15440</span>&#160;if soap_register_plugin(&amp;soap, http_da)) </div><div class="line"><a name="l15441"></a><span class="lineno">15441</span>&#160;   soap_print_fault(&amp;soap, stderr); // failed to register </div><div class="line"><a name="l15442"></a><span class="lineno">15442</span>&#160;... </div><div class="line"><a name="l15443"></a><span class="lineno">15443</span>&#160;if (soap_call_ns__method(&amp;soap, ...) != SOAP_OK) </div><div class="line"><a name="l15444"></a><span class="lineno">15444</span>&#160;{ </div><div class="line"><a name="l15445"></a><span class="lineno">15445</span>&#160;   if (soap.error == 401) // challenge: HTTP authentication required </div><div class="line"><a name="l15446"></a><span class="lineno">15446</span>&#160;   { </div><div class="line"><a name="l15447"></a><span class="lineno">15447</span>&#160;     if (!strcmp(soap.authrealm, authrealm)) // determine authentication realm</div><div class="line"><a name="l15448"></a><span class="lineno">15448</span>&#160;     { </div><div class="line"><a name="l15449"></a><span class="lineno">15449</span>&#160;       struct http_da_info info; // to store userid and passwd </div><div class="line"><a name="l15450"></a><span class="lineno">15450</span>&#160;       http_da_save(&amp;soap, &amp;info, authrealm, userid, passwd); // set userid and passwd for this realm</div><div class="line"><a name="l15451"></a><span class="lineno">15451</span>&#160;       if (soap_call_ns__method(&amp;soap, ...) == SOAP_OK) // retry </div><div class="line"><a name="l15452"></a><span class="lineno">15452</span>&#160;       { ... </div><div class="line"><a name="l15453"></a><span class="lineno">15453</span>&#160;         soap_end(&amp;soap); // userid and passwd were deallocated </div><div class="line"><a name="l15454"></a><span class="lineno">15454</span>&#160;         http_da_restore(&amp;soap, &amp;info); // restore userid and passwd </div><div class="line"><a name="l15455"></a><span class="lineno">15455</span>&#160;         if (!soap_call_ns__method(&amp;soap, ...) == SOAP_OK) // another call </div><div class="line"><a name="l15456"></a><span class="lineno">15456</span>&#160;           ... </div><div class="line"><a name="l15457"></a><span class="lineno">15457</span>&#160;         http_da_release(&amp;soap, &amp;info); // remove userid and passwd</div><div class="line"><a name="l15458"></a><span class="lineno">15458</span>&#160;```</div><div class="line"><a name="l15459"></a><span class="lineno">15459</span>&#160;</div><div class="line"><a name="l15460"></a><span class="lineno">15460</span>&#160;This code supports both basic and digest authentication.</div><div class="line"><a name="l15461"></a><span class="lineno">15461</span>&#160;</div><div class="line"><a name="l15462"></a><span class="lineno">15462</span>&#160;The server can challenge a client using HTTP code 401. With the plug-in, HTTP digest authentication challenges are send. Without the plug-in, basic authentication challenges are send.</div><div class="line"><a name="l15463"></a><span class="lineno">15463</span>&#160;</div><div class="line"><a name="l15464"></a><span class="lineno">15464</span>&#160;Each server method can implement authentication as desired and may enforce</div><div class="line"><a name="l15465"></a><span class="lineno">15465</span>&#160;digest authentication or may also accept basic authentication responses. To</div><div class="line"><a name="l15466"></a><span class="lineno">15466</span>&#160;verify digest authentication responses, the server should compute and compare</div><div class="line"><a name="l15467"></a><span class="lineno">15467</span>&#160;the checksums using the plug-in&#39;s `http_da_verify_post` function for</div><div class="line"><a name="l15468"></a><span class="lineno">15468</span>&#160;HTTP POST requests (and `http_da_verify_get` for HTTP GET requests with</div><div class="line"><a name="l15469"></a><span class="lineno">15469</span>&#160;the HTTP GET plugin) as follows:</div><div class="line"><a name="l15470"></a><span class="lineno">15470</span>&#160;</div><div class="line"><a name="l15471"></a><span class="lineno">15471</span>&#160;```cpp</div><div class="line"><a name="l15472"></a><span class="lineno">15472</span>&#160;#include &quot;httpda.h&quot; </div><div class="line"><a name="l15473"></a><span class="lineno">15473</span>&#160;... </div><div class="line"><a name="l15474"></a><span class="lineno">15474</span>&#160;if (soap_register_plugin(&amp;soap, http_da)) </div><div class="line"><a name="l15475"></a><span class="lineno">15475</span>&#160;   soap_print_fault(&amp;soap, stderr); // failed to register </div><div class="line"><a name="l15476"></a><span class="lineno">15476</span>&#160;... </div><div class="line"><a name="l15477"></a><span class="lineno">15477</span>&#160;soap_serve(&amp;soap); </div><div class="line"><a name="l15478"></a><span class="lineno">15478</span>&#160;... </div><div class="line"><a name="l15479"></a><span class="lineno">15479</span>&#160;int ns__method(struct soap *soap, ...) </div><div class="line"><a name="l15480"></a><span class="lineno">15480</span>&#160;{ </div><div class="line"><a name="l15481"></a><span class="lineno">15481</span>&#160;   if (soap-&gt;userid &amp;&amp; soap-&gt;passwd) // client used basic authentication </div><div class="line"><a name="l15482"></a><span class="lineno">15482</span>&#160;   { // may decide not to handle, but if ok then go ahead and compare info: </div><div class="line"><a name="l15483"></a><span class="lineno">15483</span>&#160;     if (!strcmp(soap-&gt;userid, userid) &amp;&amp; !strcmp(soap-&gt;passwd, passwd)) </div><div class="line"><a name="l15484"></a><span class="lineno">15484</span>&#160;     { ... handle request ... </div><div class="line"><a name="l15485"></a><span class="lineno">15485</span>&#160;       return SOAP_OK; </div><div class="line"><a name="l15486"></a><span class="lineno">15486</span>&#160;     } </div><div class="line"><a name="l15487"></a><span class="lineno">15487</span>&#160;   } </div><div class="line"><a name="l15488"></a><span class="lineno">15488</span>&#160;   else if (soap-&gt;authrealm &amp;&amp; soap-&gt;userid) // Digest authentication </div><div class="line"><a name="l15489"></a><span class="lineno">15489</span>&#160;   { </div><div class="line"><a name="l15490"></a><span class="lineno">15490</span>&#160;     passwd = ... // database lookup on userid and authrealm to find passwd </div><div class="line"><a name="l15491"></a><span class="lineno">15491</span>&#160;     if (!strcmp(soap-&gt;authrealm, authrealm) &amp;&amp; !strcmp(soap-&gt;userid, userid)) </div><div class="line"><a name="l15492"></a><span class="lineno">15492</span>&#160;     { </div><div class="line"><a name="l15493"></a><span class="lineno">15493</span>&#160;       if (!http_da_verify_post(soap, passwd)) </div><div class="line"><a name="l15494"></a><span class="lineno">15494</span>&#160;       { ... handle request ... </div><div class="line"><a name="l15495"></a><span class="lineno">15495</span>&#160;         return SOAP_OK; </div><div class="line"><a name="l15496"></a><span class="lineno">15496</span>&#160;       } </div><div class="line"><a name="l15497"></a><span class="lineno">15497</span>&#160;     } </div><div class="line"><a name="l15498"></a><span class="lineno">15498</span>&#160;   } </div><div class="line"><a name="l15499"></a><span class="lineno">15499</span>&#160;   soap-&gt;authrealm = authrealm; // set realm for challenge </div><div class="line"><a name="l15500"></a><span class="lineno">15500</span>&#160;   return 401; // Not authorized, challenge digest authentication </div><div class="line"><a name="l15501"></a><span class="lineno">15501</span>&#160;}</div><div class="line"><a name="l15502"></a><span class="lineno">15502</span>&#160;```</div><div class="line"><a name="l15503"></a><span class="lineno">15503</span>&#160;</div><div class="line"><a name="l15504"></a><span class="lineno">15504</span>&#160;For more details, including how to configure HTTP Digest authentication for</div><div class="line"><a name="l15505"></a><span class="lineno">15505</span>&#160;proxies, please see the `doc/httpda/html/index.html` documentation in the gSOAP package.</div><div class="line"><a name="l15506"></a><span class="lineno">15506</span>&#160;</div><div class="line"><a name="l15507"></a><span class="lineno">15507</span>&#160;### The WS-Addressing Plug-in</div><div class="line"><a name="l15508"></a><span class="lineno">15508</span>&#160;</div><div class="line"><a name="l15509"></a><span class="lineno">15509</span>&#160;The WSA WS-Addressing plug-in and the source code are extensively documented in</div><div class="line"><a name="l15510"></a><span class="lineno">15510</span>&#160;the `doc/wsa` directory of the gSOAP package. Please refer to the documentation</div><div class="line"><a name="l15511"></a><span class="lineno">15511</span>&#160;included in the package.</div><div class="line"><a name="l15512"></a><span class="lineno">15512</span>&#160;</div><div class="line"><a name="l15513"></a><span class="lineno">15513</span>&#160;The plug-in code is located in the `plugin` directory containing</div><div class="line"><a name="l15514"></a><span class="lineno">15514</span>&#160;`wsaapi.h` and `wsaapi.c` (C and C++).</div><div class="line"><a name="l15515"></a><span class="lineno">15515</span>&#160;</div><div class="line"><a name="l15516"></a><span class="lineno">15516</span>&#160;To enable WS-Addressing 2005 (and support for 8/2004), the service definitions header file for `soapcpp2` should include the following imports:</div><div class="line"><a name="l15517"></a><span class="lineno">15517</span>&#160;</div><div class="line"><a name="l15518"></a><span class="lineno">15518</span>&#160;```cpp</div><div class="line"><a name="l15519"></a><span class="lineno">15519</span>&#160;#import &quot;import/wsa5.h&quot;</div><div class="line"><a name="l15520"></a><span class="lineno">15520</span>&#160;```</div><div class="line"><a name="l15521"></a><span class="lineno">15521</span>&#160;</div><div class="line"><a name="l15522"></a><span class="lineno">15522</span>&#160;This imports the SOAP header elements required by WS-Addressing.</div><div class="line"><a name="l15523"></a><span class="lineno">15523</span>&#160;</div><div class="line"><a name="l15524"></a><span class="lineno">15524</span>&#160;For more details, please see the `doc/wsa/html/index.html` documentation in the gSOAP package.</div><div class="line"><a name="l15525"></a><span class="lineno">15525</span>&#160;</div><div class="line"><a name="l15526"></a><span class="lineno">15526</span>&#160;### The WS-ReliableMessaging Plug-in</div><div class="line"><a name="l15527"></a><span class="lineno">15527</span>&#160;</div><div class="line"><a name="l15528"></a><span class="lineno">15528</span>&#160;The WSRM WS-ReliableMessaging plug-in and the source code are extensively documented in</div><div class="line"><a name="l15529"></a><span class="lineno">15529</span>&#160;the `doc/wsrm` directory of the gSOAP package. Please refer to the documentation</div><div class="line"><a name="l15530"></a><span class="lineno">15530</span>&#160;included in the package.</div><div class="line"><a name="l15531"></a><span class="lineno">15531</span>&#160;</div><div class="line"><a name="l15532"></a><span class="lineno">15532</span>&#160;The plug-in code is located in the `plugin` directory containing `wsrmapi.h` and `wsrmapi.c` (C and C++).</div><div class="line"><a name="l15533"></a><span class="lineno">15533</span>&#160;</div><div class="line"><a name="l15534"></a><span class="lineno">15534</span>&#160;Also needed are: `threads.h` and `threads.c` for multithreading and locking support.</div><div class="line"><a name="l15535"></a><span class="lineno">15535</span>&#160;</div><div class="line"><a name="l15536"></a><span class="lineno">15536</span>&#160;To enable WS-ReliableMessaging, the service definitions header file for `soapcpp2` should include the following imports:</div><div class="line"><a name="l15537"></a><span class="lineno">15537</span>&#160;</div><div class="line"><a name="l15538"></a><span class="lineno">15538</span>&#160;```cpp</div><div class="line"><a name="l15539"></a><span class="lineno">15539</span>&#160;#import &quot;import/wsrm.h&quot; </div><div class="line"><a name="l15540"></a><span class="lineno">15540</span>&#160;#import &quot;import/wsa5.h&quot;</div><div class="line"><a name="l15541"></a><span class="lineno">15541</span>&#160;```</div><div class="line"><a name="l15542"></a><span class="lineno">15542</span>&#160;</div><div class="line"><a name="l15543"></a><span class="lineno">15543</span>&#160;This imports the SOAP header elements required by WS-ReliableMessaging.</div><div class="line"><a name="l15544"></a><span class="lineno">15544</span>&#160;</div><div class="line"><a name="l15545"></a><span class="lineno">15545</span>&#160;For more details, please see the `doc/wsrm/html/index.html` documentation in the gSOAP package.</div><div class="line"><a name="l15546"></a><span class="lineno">15546</span>&#160;</div><div class="line"><a name="l15547"></a><span class="lineno">15547</span>&#160;### The WS-Security Plug-in</div><div class="line"><a name="l15548"></a><span class="lineno">15548</span>&#160;</div><div class="line"><a name="l15549"></a><span class="lineno">15549</span>&#160;The WSSE WS-Security plug-in and the source code are extensively documented in</div><div class="line"><a name="l15550"></a><span class="lineno">15550</span>&#160;the `doc/wsse` directory of the gSOAP package. Please refer to the</div><div class="line"><a name="l15551"></a><span class="lineno">15551</span>&#160;documentation included in the package for details.</div><div class="line"><a name="l15552"></a><span class="lineno">15552</span>&#160;</div><div class="line"><a name="l15553"></a><span class="lineno">15553</span>&#160;The plug-in code is located in the `plugin` directory containing `wsseapi.h` and `wsseapi.c` (C and C++).</div><div class="line"><a name="l15554"></a><span class="lineno">15554</span>&#160;</div><div class="line"><a name="l15555"></a><span class="lineno">15555</span>&#160;Also needed are: `smdevp.h` and `smdevp.c` for streaming XML signature and message digest engine,</div><div class="line"><a name="l15556"></a><span class="lineno">15556</span>&#160;`mecevp.h` and `mecevp.c` for streaming XML encryption engine, `threads.h` and `threads.c` for multithreading and locking support.</div><div class="line"><a name="l15557"></a><span class="lineno">15557</span>&#160;</div><div class="line"><a name="l15558"></a><span class="lineno">15558</span>&#160;To enable WS-Secrutiy, the service definitions header file for `soapcpp2` should include the following imports:</div><div class="line"><a name="l15559"></a><span class="lineno">15559</span>&#160;</div><div class="line"><a name="l15560"></a><span class="lineno">15560</span>&#160;```cpp</div><div class="line"><a name="l15561"></a><span class="lineno">15561</span>&#160;#import &quot;import/wsse.h&quot;</div><div class="line"><a name="l15562"></a><span class="lineno">15562</span>&#160;```</div><div class="line"><a name="l15563"></a><span class="lineno">15563</span>&#160;</div><div class="line"><a name="l15564"></a><span class="lineno">15564</span>&#160;This imports the SOAP header elements required by WS-Security.</div><div class="line"><a name="l15565"></a><span class="lineno">15565</span>&#160;</div><div class="line"><a name="l15566"></a><span class="lineno">15566</span>&#160;For more details, please see the `doc/wsse/html/index.html` documentation in the gSOAP package.</div><div class="line"><a name="l15567"></a><span class="lineno">15567</span>&#160;</div><div class="line"><a name="l15568"></a><span class="lineno">15568</span>&#160;### WS-Discovery</div><div class="line"><a name="l15569"></a><span class="lineno">15569</span>&#160;</div><div class="line"><a name="l15570"></a><span class="lineno">15570</span>&#160;The WS-Discovery implementation is documented in the `doc/wsdd` directory</div><div class="line"><a name="l15571"></a><span class="lineno">15571</span>&#160;of the gSOAP package. Please refer to the documentation included in the package</div><div class="line"><a name="l15572"></a><span class="lineno">15572</span>&#160;for details.</div><div class="line"><a name="l15573"></a><span class="lineno">15573</span>&#160;</div><div class="line"><a name="l15574"></a><span class="lineno">15574</span>&#160;Basically, to add WS-Discovery support the following event handlers must be</div><div class="line"><a name="l15575"></a><span class="lineno">15575</span>&#160;defined and linked:</div><div class="line"><a name="l15576"></a><span class="lineno">15576</span>&#160;</div><div class="line"><a name="l15577"></a><span class="lineno">15577</span>&#160;```cpp</div><div class="line"><a name="l15578"></a><span class="lineno">15578</span>&#160;void wsdd_event_Hello(struct soap *soap, </div><div class="line"><a name="l15579"></a><span class="lineno">15579</span>&#160;unsigned int InstanceId, </div><div class="line"><a name="l15580"></a><span class="lineno">15580</span>&#160;const char *SequenceId, </div><div class="line"><a name="l15581"></a><span class="lineno">15581</span>&#160;unsigned int MessageNumber, </div><div class="line"><a name="l15582"></a><span class="lineno">15582</span>&#160;const char *MessageID, </div><div class="line"><a name="l15583"></a><span class="lineno">15583</span>&#160;const char *RelatesTo, </div><div class="line"><a name="l15584"></a><span class="lineno">15584</span>&#160;const char *EndpointReference, </div><div class="line"><a name="l15585"></a><span class="lineno">15585</span>&#160;const char *Types, </div><div class="line"><a name="l15586"></a><span class="lineno">15586</span>&#160;const char *Scopes, </div><div class="line"><a name="l15587"></a><span class="lineno">15587</span>&#160;const char *MatchBy, </div><div class="line"><a name="l15588"></a><span class="lineno">15588</span>&#160;const char *XAddrs, </div><div class="line"><a name="l15589"></a><span class="lineno">15589</span>&#160;unsigned int MetadataVersion)</div><div class="line"><a name="l15590"></a><span class="lineno">15590</span>&#160;```</div><div class="line"><a name="l15591"></a><span class="lineno">15591</span>&#160;</div><div class="line"><a name="l15592"></a><span class="lineno">15592</span>&#160;```cpp</div><div class="line"><a name="l15593"></a><span class="lineno">15593</span>&#160;void wsdd_event_Bye(struct soap *soap, </div><div class="line"><a name="l15594"></a><span class="lineno">15594</span>&#160;unsigned int InstanceId, </div><div class="line"><a name="l15595"></a><span class="lineno">15595</span>&#160;const char *SequenceId, </div><div class="line"><a name="l15596"></a><span class="lineno">15596</span>&#160;unsigned int MessageNumber, </div><div class="line"><a name="l15597"></a><span class="lineno">15597</span>&#160;const char *MessageID, </div><div class="line"><a name="l15598"></a><span class="lineno">15598</span>&#160;const char *RelatesTo, </div><div class="line"><a name="l15599"></a><span class="lineno">15599</span>&#160;const char *EndpointReference, </div><div class="line"><a name="l15600"></a><span class="lineno">15600</span>&#160;const char *Types, </div><div class="line"><a name="l15601"></a><span class="lineno">15601</span>&#160;const char *Scopes, </div><div class="line"><a name="l15602"></a><span class="lineno">15602</span>&#160;const char *MatchBy, </div><div class="line"><a name="l15603"></a><span class="lineno">15603</span>&#160;const char *XAddrs, </div><div class="line"><a name="l15604"></a><span class="lineno">15604</span>&#160;unsigned int MetadataVersion)</div><div class="line"><a name="l15605"></a><span class="lineno">15605</span>&#160;```</div><div class="line"><a name="l15606"></a><span class="lineno">15606</span>&#160;</div><div class="line"><a name="l15607"></a><span class="lineno">15607</span>&#160;```cpp</div><div class="line"><a name="l15608"></a><span class="lineno">15608</span>&#160;soap_wsdd_mode wsdd_event_Probe(struct soap *soap, </div><div class="line"><a name="l15609"></a><span class="lineno">15609</span>&#160;const char *MessageID, </div><div class="line"><a name="l15610"></a><span class="lineno">15610</span>&#160;const char *ReplyTo, </div><div class="line"><a name="l15611"></a><span class="lineno">15611</span>&#160;const char *Types, </div><div class="line"><a name="l15612"></a><span class="lineno">15612</span>&#160;const char *Scopes, </div><div class="line"><a name="l15613"></a><span class="lineno">15613</span>&#160;const char *MatchBy, </div><div class="line"><a name="l15614"></a><span class="lineno">15614</span>&#160;struct wsdd__ProbeMatchesType *ProbeMatches)</div><div class="line"><a name="l15615"></a><span class="lineno">15615</span>&#160;```</div><div class="line"><a name="l15616"></a><span class="lineno">15616</span>&#160;</div><div class="line"><a name="l15617"></a><span class="lineno">15617</span>&#160;```cpp</div><div class="line"><a name="l15618"></a><span class="lineno">15618</span>&#160;void wsdd_event_ProbeMatches(struct soap *soap, </div><div class="line"><a name="l15619"></a><span class="lineno">15619</span>&#160;unsigned int InstanceId, </div><div class="line"><a name="l15620"></a><span class="lineno">15620</span>&#160;const char *SequenceId, </div><div class="line"><a name="l15621"></a><span class="lineno">15621</span>&#160;unsigned int MessageNumber, </div><div class="line"><a name="l15622"></a><span class="lineno">15622</span>&#160;const char *MessageID, </div><div class="line"><a name="l15623"></a><span class="lineno">15623</span>&#160;const char *RelatesTo, </div><div class="line"><a name="l15624"></a><span class="lineno">15624</span>&#160;struct wsdd__ProbeMatchesType *ProbeMatches)</div><div class="line"><a name="l15625"></a><span class="lineno">15625</span>&#160;```</div><div class="line"><a name="l15626"></a><span class="lineno">15626</span>&#160;</div><div class="line"><a name="l15627"></a><span class="lineno">15627</span>&#160;```cpp</div><div class="line"><a name="l15628"></a><span class="lineno">15628</span>&#160;soap_wsdd_mode wsdd_event_Resolve(struct soap *soap, </div><div class="line"><a name="l15629"></a><span class="lineno">15629</span>&#160;const char *MessageID, </div><div class="line"><a name="l15630"></a><span class="lineno">15630</span>&#160;const char *ReplyTo, </div><div class="line"><a name="l15631"></a><span class="lineno">15631</span>&#160;const char *EndpointReference, </div><div class="line"><a name="l15632"></a><span class="lineno">15632</span>&#160;struct wsdd__ResolveMatchesType *ResolveMatches)</div><div class="line"><a name="l15633"></a><span class="lineno">15633</span>&#160;```</div><div class="line"><a name="l15634"></a><span class="lineno">15634</span>&#160;</div><div class="line"><a name="l15635"></a><span class="lineno">15635</span>&#160;```cpp</div><div class="line"><a name="l15636"></a><span class="lineno">15636</span>&#160;void wsdd_event_ResolveMatches(struct soap *soap, </div><div class="line"><a name="l15637"></a><span class="lineno">15637</span>&#160;unsigned int InstanceId, </div><div class="line"><a name="l15638"></a><span class="lineno">15638</span>&#160;const char *SequenceId, </div><div class="line"><a name="l15639"></a><span class="lineno">15639</span>&#160;unsigned int MessageNumber, </div><div class="line"><a name="l15640"></a><span class="lineno">15640</span>&#160;const char *MessageID, </div><div class="line"><a name="l15641"></a><span class="lineno">15641</span>&#160;const char *RelatesTo, </div><div class="line"><a name="l15642"></a><span class="lineno">15642</span>&#160;const char *EndpointReference, </div><div class="line"><a name="l15643"></a><span class="lineno">15643</span>&#160;const char *Types, </div><div class="line"><a name="l15644"></a><span class="lineno">15644</span>&#160;const char *Scopes, </div><div class="line"><a name="l15645"></a><span class="lineno">15645</span>&#160;const char *MatchBy, </div><div class="line"><a name="l15646"></a><span class="lineno">15646</span>&#160;const char *XAddrs, </div><div class="line"><a name="l15647"></a><span class="lineno">15647</span>&#160;unsigned int MetadataVersion)</div><div class="line"><a name="l15648"></a><span class="lineno">15648</span>&#160;```</div><div class="line"><a name="l15649"></a><span class="lineno">15649</span>&#160;</div><div class="line"><a name="l15650"></a><span class="lineno">15650</span>&#160;These event handlers will be invoked when inbound WS-Discovery messages arrive using:</div><div class="line"><a name="l15651"></a><span class="lineno">15651</span>&#160;</div><div class="line"><a name="l15652"></a><span class="lineno">15652</span>&#160;```cpp</div><div class="line"><a name="l15653"></a><span class="lineno">15653</span>&#160;if (!soap_valid_socket(soap_bind(soap, NULL, port, 100))) </div><div class="line"><a name="l15654"></a><span class="lineno">15654</span>&#160;   .. error </div><div class="line"><a name="l15655"></a><span class="lineno">15655</span>&#160;if (soap_wsdd_listen(soap, timeout)) </div><div class="line"><a name="l15656"></a><span class="lineno">15656</span>&#160;   ... error</div><div class="line"><a name="l15657"></a><span class="lineno">15657</span>&#160;```</div><div class="line"><a name="l15658"></a><span class="lineno">15658</span>&#160;</div><div class="line"><a name="l15659"></a><span class="lineno">15659</span>&#160;which will listen for `timeout` seconds to inbound WS-Discovery messages</div><div class="line"><a name="l15660"></a><span class="lineno">15660</span>&#160;on a port and dispatches them to the event handlers. A negative `timeout` is measured</div><div class="line"><a name="l15661"></a><span class="lineno">15661</span>&#160;in ns.</div><div class="line"><a name="l15662"></a><span class="lineno">15662</span>&#160;</div><div class="line"><a name="l15663"></a><span class="lineno">15663</span>&#160;Copyright (c) 2017, Robert van Engelen, Genivia Inc. All rights reserved.</div></div><!-- fragment --></div><!-- contents -->
</div><!-- doc-content -->
<hr class="footer">
<address class="footer">
Copyright (C) 2017, Robert van Engelen, Genivia Inc., All Rights Reserved.
</address>
<address class="footer"><small>
Converted on Tue Jul 4 2017 08:51:33 by <a target="_blank" href="http://www.doxygen.org/index.html">Doxygen</a> 1.8.11</small></address>
<br>
<div style="height: 246px; background: #DBDBDB;">
</body>
</html>
