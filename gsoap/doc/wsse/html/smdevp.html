<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>gSOAP WS-Security: The smdevp signed message digest engine</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">gSOAP WS-Security&#160;<span id="projectnumber">2.8 Stable</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">The smdevp signed message digest engine </div>  </div>
</div>
<div class="contents">
<div class="textblock"><p>The gSOAP smdevp engine computes signed/unsigned message digests over any type of data using the EVP interface of OpenSSL. It currently supports MD5, SHA1, HMAC_SHA1, DSA_SHA1, and RSA_SHA1.</p>
<p>A digest or signature algorithm is selected with one the following:</p>
<ul>
<li><a class="el" href="smdevp_8h.html#a66e616b88f16506cfad0e9f05445d130">SOAP_SMD_DGST_MD5</a> to compute MD5 128-bit digests</li>
<li><a class="el" href="smdevp_8h.html#ad8bbfdd0e7b1656123d888bf86a516e9">SOAP_SMD_DGST_SHA1</a> to compute MD5 160-bit digests</li>
<li><a class="el" href="smdevp_8h.html#a7d00704c43ee044926905cd327a712ef">SOAP_SMD_HMAC_SHA1</a> to compute HMAC-SHA1 message authentication code</li>
<li><a class="el" href="smdevp_8h.html#a647cb5d798442d34c8191c62a2aeebf6">SOAP_SMD_SIGN_DSA_SHA1</a> to compute DSA-SHA1 signatures</li>
<li><a class="el" href="smdevp_8h.html#acbb90951064d98a13af03724dbed2aa8">SOAP_SMD_SIGN_RSA_SHA1</a> to compute RSA-SHA1 signatures</li>
<li><a class="el" href="smdevp_8h.html#a448c4d5953ca007263ff6a5bd055cfdc">SOAP_SMD_VRFY_DSA_SHA1</a> to verify DSA-SHA1 signatures</li>
<li><a class="el" href="smdevp_8h.html#aa395a40932c9c057cd264c03716c9d6e">SOAP_SMD_VRFY_RSA_SHA1</a> to verify RSA-SHA1 signatures</li>
</ul>
<p>Algorithm options:</p>
<ul>
<li><a class="el" href="smdevp_8h.html#a72aec9a04db9a1e00d26b1ccb5e5da03">SOAP_SMD_PASSTHRU</a> to pass XML through the smdevp engine</li>
</ul>
<p>The smdevp engine wraps the EVP API with three new functions:</p>
<ul>
<li><a class="el" href="smdevp_8c.html#a8835cbedd7b123915f673bf7b0e8f0cc">soap_smd_init</a> to initialize the engine</li>
<li><a class="el" href="smdevp_8c.html#a1f9631955eabdcf338d0178d2d90ea50">soap_smd_update</a> to update the state with a message part</li>
<li><a class="el" href="smdevp_8c.html#a8d7f8b4fdcfe0afc13fef37fd8c46f5d">soap_smd_final</a> to compute the digest, signature, or verify a signature and deallocate the engine</li>
</ul>
<p>A higher-level interface for computing (signed) message digests over messages produced by the gSOAP engine is defined by two new functions:</p>
<ul>
<li><a class="el" href="smdevp_8c.html#ad8b665c8e8844eca8916f4b16b0ce9c5">soap_smd_begin</a> to start a digest or signature computation/verification</li>
<li><a class="el" href="smdevp_8c.html#a8f18dbae37de8942e080d45dd3480a7b">soap_smd_end</a> to finalize the digest or signature and clean up</li>
</ul>
<p>Compile all source codes with -DWITH_OPENSSL and link with ssl and crypto libraries.</p>
<p>Here is an example to sign an XML serialized C++ object using an RSA private key applied to the SHA1 digest of the serialized object:</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">    #include &quot;<a class="code" href="smdevp_8h.html">smdevp.h</a>&quot;</span>
    ns__Object object;
    <span class="keywordtype">int</span> alg = <a class="code" href="smdevp_8h.html#acbb90951064d98a13af03724dbed2aa8">SOAP_SMD_SIGN_RSA_SHA1</a>;
    FILE *fd = fopen(<span class="stringliteral">&quot;key.pem&quot;</span>, <span class="stringliteral">&quot;r&quot;</span>);
    EVP_PKEY *key = PEM_read_PrivateKey(fd, NULL, NULL, <span class="stringliteral">&quot;password&quot;</span>);
    <span class="keywordtype">char</span> *sig = (<span class="keywordtype">char</span>*)soap_malloc(soap, <a class="code" href="smdevp_8h.html#a358684027d81577215163533f34b971f" title="Returns the number of octets needed to store the digest or signature returned by soap_smd_end.">soap_smd_size</a>(alg, key));
    <span class="keywordtype">int</span> siglen;
    fclose(fd);
    <span class="keywordflow">if</span> (<a class="code" href="smdevp_8h.html#ad8b665c8e8844eca8916f4b16b0ce9c5" title="Initiates a digest or signature computation.">soap_smd_begin</a>(soap, alg, key, 0)
     || soap_out_ns__Object(soap, <span class="stringliteral">&quot;ns:Object&quot;</span>, 0, &amp;<span class="keywordtype">object</span>, NULL))
    { <a class="code" href="smdevp_8h.html#a8f18dbae37de8942e080d45dd3480a7b" title="Completes a digest or signature computation. Also deallocates temporary storage allocated by soap_smd...">soap_smd_end</a>(soap, NULL, NULL); <span class="comment">// clean up</span>
      soap_print_fault(soap, stderr);
    }
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="smdevp_8h.html#a8f18dbae37de8942e080d45dd3480a7b" title="Completes a digest or signature computation. Also deallocates temporary storage allocated by soap_smd...">soap_smd_end</a>(soap, sig, &amp;siglen))
      soap_print_fault(soap, stderr);
    <span class="keywordflow">else</span>
      ... <span class="comment">// sig contains RSA-SHA1 signature of length siglen </span>
    EVP_PKEY_free(key);
</pre></div><p>Compile the gSOAP sources and your code with -DWITH_OPENSSL and link with OpenSSL libraries.</p>
<p>There is no XML output generated by this example, as the object is simply serialized to the smdevp engine. To actually pass the XML object through the smdevp engine and output it to a stream or file simultaneously, use the SOAP_SMD_PASSTHRU flag with the algorithm selection as follows:</p>
<div class="fragment"><pre class="fragment">    ns__Object object;
    <span class="keywordtype">int</span> alg = <a class="code" href="smdevp_8h.html#acbb90951064d98a13af03724dbed2aa8">SOAP_SMD_SIGN_RSA_SHA1</a>;
    FILE *fd = fopen(<span class="stringliteral">&quot;key.pem&quot;</span>, <span class="stringliteral">&quot;r&quot;</span>);
    EVP_PKEY *key = PEM_read_PrivateKey(fd, NULL, NULL, <span class="stringliteral">&quot;password&quot;</span>);
    <span class="keywordtype">char</span> *sig = (<span class="keywordtype">char</span>*)soap_malloc(soap, <a class="code" href="smdevp_8h.html#a358684027d81577215163533f34b971f" title="Returns the number of octets needed to store the digest or signature returned by soap_smd_end.">soap_smd_size</a>(alg, key));
    <span class="keywordtype">int</span> siglen;
    fclose(fd);
    soap-&gt;sendfd = open(<span class="stringliteral">&quot;object.xml&quot;</span>, O_CREAT | O_WRONLY, 0600); <span class="comment">// a file to save object to</span>
    <span class="keywordflow">if</span> (<a class="code" href="smdevp_8h.html#ad8b665c8e8844eca8916f4b16b0ce9c5" title="Initiates a digest or signature computation.">soap_smd_begin</a>(soap, alg | <a class="code" href="smdevp_8h.html#a72aec9a04db9a1e00d26b1ccb5e5da03">SOAP_SMD_PASSTHRU</a>, key, 0)
     || soap_begin_send(soap)
     || soap_out_ns__Object(soap, <span class="stringliteral">&quot;ns:Object&quot;</span>, 0, &amp;<span class="keywordtype">object</span>, NULL) <span class="comment">// save to &quot;object.xml&quot;</span>
     || soap_end_send(soap))
    { <a class="code" href="smdevp_8h.html#a8f18dbae37de8942e080d45dd3480a7b" title="Completes a digest or signature computation. Also deallocates temporary storage allocated by soap_smd...">soap_smd_end</a>(soap, NULL, NULL); <span class="comment">// clean up</span>
      soap_print_fault(soap, stderr);
    }
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="smdevp_8h.html#a8f18dbae37de8942e080d45dd3480a7b" title="Completes a digest or signature computation. Also deallocates temporary storage allocated by soap_smd...">soap_smd_end</a>(soap, sig, &amp;siglen))
      soap_print_fault(soap, stderr);
    <span class="keywordflow">else</span>
      ... <span class="comment">// sig contains RSA-SHA1 signature of length siglen </span>
    close(soap-&gt;sendfd);
    EVP_PKEY_free(key);
</pre></div><p>Note that we used soap_begin_send and soap_end_send to emit the XML to a stream. Each type also has a reader (e.g. soap_read_ns__Object) and writer (e.g. soap_write_ns__Object) that can be used instead as these include soap_begin_recv/soap_end_recv and soap_begin_send/soap_end_send call sequences.</p>
<p>To verify the signature of an object read from a stream or file, we pass it through the smdevp engine as follows:</p>
<div class="fragment"><pre class="fragment">    <span class="keywordtype">char</span> *sig = ...;
    <span class="keywordtype">int</span> siglen = ...;
    ns__Object object;
    <span class="keywordtype">int</span> alg = <a class="code" href="smdevp_8h.html#aa395a40932c9c057cd264c03716c9d6e">SOAP_SMD_VRFY_RSA_SHA1</a>;
    FILE *fd = fopen(<span class="stringliteral">&quot;key.pem&quot;</span>, <span class="stringliteral">&quot;r&quot;</span>);
    EVP_PKEY *key;
    <span class="keywordflow">if</span> (...) <span class="comment">// key file contains public key?</span>
      key = PEM_read_PUBKEY(fd, NULL, NULL, NULL);
    <span class="keywordflow">else</span> <span class="comment">// key file contains certificate</span>
    { X509 *cert = PEM_read_X509(fd, NULL, NULL, NULL);
      key = X509_get_pubkey(cert);
      X509_free(cert);
    }
    fclose(fd);
    soap-&gt;recvfd = open(<span class="stringliteral">&quot;object.xml&quot;</span>, O_RDONLY);
    <span class="keywordflow">if</span> (<a class="code" href="smdevp_8h.html#ad8b665c8e8844eca8916f4b16b0ce9c5" title="Initiates a digest or signature computation.">soap_smd_begin</a>(soap, alg, key, 0)
     || soap_begin_recv(soap)
     || soap_in_ns__Object(soap, <span class="stringliteral">&quot;ns:Object&quot;</span>, &amp;<span class="keywordtype">object</span>, NULL) == NULL
     || soap_end_recv(soap))
    { <a class="code" href="smdevp_8h.html#a8f18dbae37de8942e080d45dd3480a7b" title="Completes a digest or signature computation. Also deallocates temporary storage allocated by soap_smd...">soap_smd_end</a>(soap, NULL, NULL); <span class="comment">// clean up</span>
      soap_print_fault(soap, stderr);
    }
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="smdevp_8h.html#a8f18dbae37de8942e080d45dd3480a7b" title="Completes a digest or signature computation. Also deallocates temporary storage allocated by soap_smd...">soap_smd_end</a>(soap, sig, &amp;siglen))
      soap_print_fault(soap, stderr);
    <span class="keywordflow">else</span>
      ... <span class="comment">// sig verified, i.e. signed object was not changed</span>
    close(soap-&gt;recvfd);
    EVP_PKEY_free(key);
</pre></div><p>To verify the signature of an object stored in memory, we use the RSA public key and re-run the octet stream (by re-serialization in this example) through the smdevp engine using the SOAP_SMD_VRFY_RSA_SHA1 algorithm. Note that a PEM file may contain both the (encrypted) private and public keys.</p>
<div class="fragment"><pre class="fragment">    <span class="keywordtype">char</span> *sig = ...;
    <span class="keywordtype">int</span> siglen = ...;
    ns__Object object;
    <span class="keywordtype">int</span> alg = <a class="code" href="smdevp_8h.html#aa395a40932c9c057cd264c03716c9d6e">SOAP_SMD_VRFY_RSA_SHA1</a>;
    FILE *fd = fopen(<span class="stringliteral">&quot;key.pem&quot;</span>, <span class="stringliteral">&quot;r&quot;</span>);
    EVP_PKEY *key;
    <span class="keywordflow">if</span> (...) <span class="comment">// key file contains public key?</span>
      key = PEM_read_PUBKEY(fd, NULL, NULL, NULL);
    <span class="keywordflow">else</span> <span class="comment">// key file contains certificate</span>
    { X509 *cert = PEM_read_X509(fd, NULL, NULL, NULL);
      key = X509_get_pubkey(cert);
      X509_free(cert);
    }
    fclose(fd);
    <span class="keywordflow">if</span> (<a class="code" href="smdevp_8h.html#ad8b665c8e8844eca8916f4b16b0ce9c5" title="Initiates a digest or signature computation.">soap_smd_begin</a>(soap, alg, key, 0)
     || soap_out_ns__Object(soap, <span class="stringliteral">&quot;ns:Object&quot;</span>, 0, &amp;<span class="keywordtype">object</span>, NULL))
    { <a class="code" href="smdevp_8h.html#a8f18dbae37de8942e080d45dd3480a7b" title="Completes a digest or signature computation. Also deallocates temporary storage allocated by soap_smd...">soap_smd_end</a>(soap, NULL, NULL); <span class="comment">// clean up</span>
      soap_print_fault(soap, stderr);
    }
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="smdevp_8h.html#a8f18dbae37de8942e080d45dd3480a7b" title="Completes a digest or signature computation. Also deallocates temporary storage allocated by soap_smd...">soap_smd_end</a>(soap, sig, &amp;siglen))
      soap_print_fault(soap, stderr);
    <span class="keywordflow">else</span>
      ... <span class="comment">// sig verified, i.e. signed object was not changed</span>
    EVP_PKEY_free(key);
</pre></div><p>The HMAC algorithm uses a shared secret key (hence both the sender and receiver must keep it secret) to sign and verify a message:</p>
<div class="fragment"><pre class="fragment">    ns__Object object;
    <span class="keywordtype">int</span> alg = <a class="code" href="smdevp_8h.html#a7d00704c43ee044926905cd327a712ef">SOAP_SMD_HMAC_SHA1</a>;
    <span class="keyword">static</span> <span class="keywordtype">char</span> key[16] =
    { 0xff, 0xee, 0xdd, 0xcc, 0xbb, 0xaa, 0x99, 0x88,
      0x77, 0x66, 0x55, 0x44, 0x33, 0x22, 0x11, 0x00 };
    <span class="keywordtype">char</span> *sig = (<span class="keywordtype">char</span>*)soap_malloc(soap, <a class="code" href="smdevp_8h.html#a358684027d81577215163533f34b971f" title="Returns the number of octets needed to store the digest or signature returned by soap_smd_end.">soap_smd_size</a>(alg, NULL));
    <span class="keywordtype">int</span> siglen;
    <span class="keywordflow">if</span> (<a class="code" href="smdevp_8h.html#ad8b665c8e8844eca8916f4b16b0ce9c5" title="Initiates a digest or signature computation.">soap_smd_begin</a>(soap, alg, key, <span class="keyword">sizeof</span>(key))
     || soap_out_ns__Object(soap, <span class="stringliteral">&quot;ns:Object&quot;</span>, 0, &amp;<span class="keywordtype">object</span>, NULL))
    { <a class="code" href="smdevp_8h.html#a8f18dbae37de8942e080d45dd3480a7b" title="Completes a digest or signature computation. Also deallocates temporary storage allocated by soap_smd...">soap_smd_end</a>(soap, NULL, NULL); <span class="comment">// clean up</span>
      soap_print_fault(soap, stderr);
    }
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> {<a class="code" href="smdevp_8h.html#a8f18dbae37de8942e080d45dd3480a7b" title="Completes a digest or signature computation. Also deallocates temporary storage allocated by soap_smd...">soap_smd_end</a>(soap, sig, &amp;siglen))
      soap_print_fault(soap, stderr);
    <span class="keywordflow">else</span>
      ... <span class="comment">// sig holds the signature</span>
</pre></div><p>Note: HMAC signature verification proceeds by recomputing the signature value for comparison.</p>
<p>A digest is a hash value of an octet stream computed using the MD5 or SHA1 algorithms:</p>
<div class="fragment"><pre class="fragment">    ns__Object object;
    <span class="keywordtype">int</span> alg = <a class="code" href="smdevp_8h.html#ad8bbfdd0e7b1656123d888bf86a516e9">SOAP_SMD_DGST_SHA1</a>;
    <span class="keywordtype">char</span> *digest = (<span class="keywordtype">char</span>*)soap_malloc(soap, <a class="code" href="smdevp_8h.html#a358684027d81577215163533f34b971f" title="Returns the number of octets needed to store the digest or signature returned by soap_smd_end.">soap_smd_size</a>(alg, NULL));
    <span class="keywordtype">int</span> digestlen;
    <span class="keywordflow">if</span> (<a class="code" href="smdevp_8h.html#ad8b665c8e8844eca8916f4b16b0ce9c5" title="Initiates a digest or signature computation.">soap_smd_begin</a>(soap, alg, NULL, 0)
     || soap_out_ns__Object(soap, <span class="stringliteral">&quot;ns:Object&quot;</span>, 0, &amp;<span class="keywordtype">object</span>, NULL))
    { <a class="code" href="smdevp_8h.html#a8f18dbae37de8942e080d45dd3480a7b" title="Completes a digest or signature computation. Also deallocates temporary storage allocated by soap_smd...">soap_smd_end</a>(soap, NULL, NULL); <span class="comment">// clean up</span>
      soap_print_fault(soap, stderr);
    }
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="smdevp_8h.html#a8f18dbae37de8942e080d45dd3480a7b" title="Completes a digest or signature computation. Also deallocates temporary storage allocated by soap_smd...">soap_smd_end</a>(soap, digest, &amp;digestlen))
      soap_print_fault(soap, stderr);
    <span class="keywordflow">else</span>
      ... <span class="comment">// digest holds hash value of serialized object</span>
</pre></div><p>Note that indentation (SOAP_XML_INDENT) and exc-c14n canonicalization (SOAP_XML_CANONICAL) affects the XML serialization format and, therefore, the digest or signature produced. </p>
</div></div>
<hr class="footer"/><address class="footer"><small>Generated on Sat Oct 22 2011 15:06:38 for gSOAP WS-Security by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
