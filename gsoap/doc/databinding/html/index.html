<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Genivia - XML Data Bindings</title>
<link href="genivia_tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<div id="top">
<div id="titlearea">
<table height="72px" width="100%" cellspacing="0" cellpadding="0">
 <tbody>
  <tr>
   <td width="10%">&nbsp;</td>
   <td width="175px"><a href="http://www.genivia.com"><img alt="Genivia" src="GeniviaLogo2_trans_noslogan.png"/></a></td>
   <td class="tab_home"><a href="http://www.genivia.com">Home</a></td>
   <td class="tab_home"><a href="http://www.genivia.com/dev.html">Developer Center</a></td>
   <td>
    <div style="float: right;"><h1>Data Bindings</h1></div>
   </td>
   <td width="10%">&nbsp;</td>
  </tr>
 </tbody>
</table>
</div>
<!-- Generated by Doxygen 1.8.3 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">XML Data Bindings </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#tocpp">Mapping WSDL and XML schemas to C/C++                                   </a></li>
<li class="level1"><a href="#typemap">Using typemap.dat to customize generated bindings                     </a><ul><li class="level2"><a href="#typemap1">XML namespace bindings                                               </a></li>
<li class="level2"><a href="#typemap2">XSD type bindings                                                    </a></li>
<li class="level2"><a href="#typemap3">Class/struct member additions                                        </a></li>
<li class="level2"><a href="#typemap4">Replacing XSD types by equivalent alternatives                       </a></li>
<li class="level2"><a href="#typemap5">The built-in typemap.dat variables $CONTAINER and $POINTER           </a></li>
<li class="level2"><a href="#typemap6">User-defined content                                                 </a></li>
</ul>
</li>
<li class="level1"><a href="#toxsd">Mapping C/C++ to XML schema                                             </a><ul><li class="level2"><a href="#toxsd1">Overview of serializable C/C++ types                                   </a></li>
<li class="level2"><a href="#toxsd2">Colon notation versus name prefixing                                   </a></li>
<li class="level2"><a href="#toxsd3">C++ Bool and C alternative                                             </a></li>
<li class="level2"><a href="#toxsd4">Enumerations and bitmasks                                              </a></li>
<li class="level2"><a href="#toxsd5">Numerical types                                                        </a></li>
<li class="level2"><a href="#toxsd6">String types                                                           </a></li>
<li class="level2"><a href="#toxsd7">Date and time types                                                    </a></li>
<li class="level2"><a href="#toxsd8">Time duration types                                                    </a></li>
<li class="level2"><a href="#toxsd9">Classes and structs                                                    </a></li>
<li class="level2"><a href="#toxsd10">Special classes and structs                                           </a></li>
</ul>
</li>
<li class="level1"><a href="#memory">Memory management                                                      </a><ul><li class="level2"><a href="#memory1">Memory management in C                                                </a></li>
<li class="level2"><a href="#memory2">Memory management in C++                                              </a></li>
</ul>
</li>
<li class="level1"><a href="#features">Features and limitations                                             </a></li>
<li class="level1"><a href="#nsmap">Removing SOAP namespaces from XML payloads                              </a></li>
<li class="level1"><a href="#examples">Examples                                                             </a></li>
</ul>
</div>
<div class="textblock"><p>This is a detailed overview of the gSOAP XML data bindings concepts and implementation. At the end of this document two examples are given to illustrate the application of data bindings.</p>
<p>The first example <code><a class="el" href="address_8cpp.html">address.cpp</a></code> shows how to use wsdl2h to bind an XML schema to C++. The C++ application reads and writes an XML file into and from a C++ "address book" data structure. The C++ data structure is an STL vector of address objects.</p>
<p>The second example <code><a class="el" href="graph_8cpp.html">graph.cpp</a></code> shows how XML is serialized as a tree, digraph, and cyclic graph. The digraph and cyclic graph serialization rules are similar to SOAP 1.1/1.2 encoded multi-ref elements with id-ref attributes to link elements through IDREF XML "pointers".</p>
<p>These examples demonstrate XML data bindings only for relatively simple data structures and types. The gSOAP tools support more than just these type of structures, which we will explain in the next sections. Support for XML schema components is practically unlimited. The wsdl2h tool maps schemas to C and C++ using built-in intuitive mapping rules, while allowing the mappings to be customized using a <code>typemap.dat</code> file with mapping instructions for wsdl2h.</p>
<p>The information in this document is applicable to gSOAP 2.8.24 and higher, which supports C++11 features. However, C++11 is not required to use this material and follow the example, unless we need smart pointers and scoped enumerations. While most of the examples in this document are given in C++, the concepts also apply to C with the exception of containers, smart pointers, classes and their methods. None of these exceptions limit the use of the gSOAP tools for C in any way.</p>
<p>The data binding concepts described in this document have somewhat changed and improved over the years since the first version of gSOAP was developed in 1999 (the project was called a "XML/SOAP stub/skeleton compiler" back then). However, the principle of mapping XSD components to C/C++ types and vice versa was envisioned, designed, and implemented early on in research conducted by Dr. van Engelen at the Florida State University and subsequently adopted by other tools, including Java web services and in C# WCF.</p>
<h1><a class="anchor" id="tocpp"></a>
Mapping WSDL and XML schemas to C/C++                                   </h1>
<p>To convert WSDL and XML schemas (XSD files), we use the wsdl2h command to generate the data binding interface code in a special gSOAP header file: </p>
<pre class="fragment">wsdl2h [options] -o file.h ... XSD and WSDL files ...
</pre><p>This converts WSDL and XSD files to C++ (or pure C with wsdl2h option <code>-c</code>) and saves a special <code>file.h</code> data binding interface file.</p>
<p>The WSDL 1.1/2.0, SOAP 1.1/1.2, and XSD 1.0/1.1 standards are supported by the gSOAP tools. In addition, the most popular WS specifications are also supported, including WS-Addressing, WS-ReliableMessaging, WS-Discovery, WS-Security, WS-Policy, WS-SecurityPolicy, and WS-SecureConversation.</p>
<p>This document focusses on XML data bindings and mapping C/C++ to XML 1.0/1.1 and XSD 1.0/1.1. This covers all of the following standard XSD components with their optional <code>[ attributes ]</code> properties: </p>
<pre class="fragment">any [minOccurs, maxOccurs]
anyAttribute
all
choice [minOccurs, maxOccurs]
sequence [minOccurs, maxOccurs]
group [name, ref]
attributeGroup [name, ref]
attribute [name, ref, type, use, default, fixed, form, wsdl:arrayType]
element [name, ref, type, default, fixed, form, nillable, abstract, substitutionGroup, minOccurs, maxOccurs]
simpleType [name]
complexType [name, abstract, mixed]
</pre><p>And also the following standard XSD components: </p>
<pre class="fragment">import              imports a schema into the importing schema for referencing
include             include schema component definitions into a schema
override            override by replacing schema component definitions
redefine            extend or restrict schema component definitions
annotation          annotates a component
</pre><p>The XSD facets and their mappings to C/C++ are: </p>
<pre class="fragment">enumeration         maps to enum
simpleContent       maps to class/struct wrapper with __item member
complexContent      maps to class/struct
list                maps to enum* bitmask (enum* enumerates up to 64 bit masks)
extension           through inheritance
restriction         partly through inheritance and redeclaration
length              restricts content length
minLength           restricst content length
maxLength           restricst content length
minInclusive        restricts numerical value range
maxInclusive        restricts numerical value range
minExclusive        restricts numerical value range
maxExclusive        restricts numerical value range
precision           maps to float/double but constraint is not validated
scale               maps to float/double but constraint is not validated
totalDigits         maps to float/double but constraint is not validated
fractionDigits      maps to float/double but constraint is not validated
pattern             must define `soap::fsvalidate` callback to validate patterns
union               maps to string of values
</pre><p>All primitive XSD types are supported, including but not limited to the following XSD types: </p>
<pre class="fragment">anyType             maps to _XML string with literal XML content (or DOM with wsdl2h option -d)
anyURI              maps to string
string              maps to string (char*/wchar_t*/std::string/std::wstring)
boolean             maps to bool (C++) or enum xsd__boolean (C)
byte                maps to char (int8_t)
short               maps to short (int16_t)
int                 maps to int (int32_t)
long                maps to LONG64 (long long and int64_t)
unsignedByte        maps to unsigned char (uint8_t)
unsignedShort       maps to unsigned short (uint16_t)
unsignedInt         maps to unsigned int (uint32_t)
unsignedLong        maps to ULONG64 (unsigned long long and uint64_t)
float               maps to float
double              maps to double
integer             maps to string
decimal             maps to string, or use "#import "custom/long_double.h"
precisionDecimal    maps to string
duration            maps to string, or use "#import "custom/duration.h"
dateTime            maps to time_t, or use "#import "custom/struct_tm.h"
time                maps to string, or use "#import "custom/long_time.h"
date                maps to string, or use "#import "custom/struct_tm_date.h"
hexBinary           maps to class/struct xsd__hexBinary
base64Bianry        maps to class/struct xsd__base64Binary
QName               maps to _QName (URI normalization rules are applied)
</pre><p>All other primitive XSD types not listed above are mapped to strings, by generating a typedef. For example, xsd:token is bound to a C++ or C string, which associates a value space to the type with the appropriate XSD type name used by the soapcpp2-generated serializers: </p>
<pre class="fragment">typedef std::string  xsd__token;  // C++
typedef char        *xsd__token;  // C (wsdl2h option -c)
</pre><p>It is possible to remap types by adding the appropriate mapping rules to <code>typemap.dat</code> as explained in the next section.</p>
<h1><a class="anchor" id="typemap"></a>
Using typemap.dat to customize generated bindings                     </h1>
<p>We use a <code>typemap.dat</code> file to redefine namespace prefixes and to customize type bindings for the the generated header files produced by the wsdl2h tool. The <code>typemap.dat</code> is the default file processed by wsdl2h. Use wsdl2h option <code>-t</code> to specify an alternate file.</p>
<p>Declarations in <code>typemap.dat</code> can be broken up over multiple lines by continuing on the next line by ending each line to be continued with a backslash <code>\</code>.</p>
<h2><a class="anchor" id="typemap1"></a>
XML namespace bindings                                               </h2>
<p>The wsdl2h tool generates C/C++ type declarations that use <code>ns1</code>, <code>ns2</code>, etc. as URI schema-binding prefixes. These default prefixes are generated somewhat arbitrarily for each schema URI, meaning that their ordering may change depending on the WSDL and XSD order of processing with wsdl2h.</p>
<p>It is <b>strongly recommended</b> to declare your own prefix for each schema URI to enhance maintaince of your code. This is to anticipate possible changes of the schema(s) and/or the binding URI(s) and/or the tooling procedures.</p>
<p>Therefore, the first and foremost important thing to do is to define prefix-URI bindings for our C/C++ code by adding the following line(s) to our <code>typemap.dat</code> or make a copy of this file and add the line(s) that bind our choice of prefix name to each URI: </p>
<pre class="fragment">prefix = "URI"
</pre><p>For example: </p>
<pre class="fragment">g = "urn:graph"
</pre><p>This produces <code>g__name</code> C/C++ type names that are bound to the "urn:graph" schema by association of <code>g</code> to the C/C++ types.</p>
<p>This means that <code>&lt;g:name xmlns:g="urn:graph"&gt;</code> is parsed as an instance of a <code>g__name</code> C/C++ type. Also <code>&lt;x:name xmlns:x="urn:graph"&gt;</code> parses as an instance of <code>g__name</code>, because the prefix <code>x</code> has the same URI value <code>urn:graph</code>. Prefixes in XML have local scopes (like variables in a block).</p>
<p>The first run of wsdl2h will reveal the URIs, so we do not need to search WSDLs and XSD files for all of the target namespaces.</p>
<h2><a class="anchor" id="typemap2"></a>
XSD type bindings                                                    </h2>
<p>Custom C/C++ type bindings can be declared in <code>typemap.dat</code> to associate C/C++ types with specific schema types. These type bindings have four parts: </p>
<pre class="fragment">prefix__type = declaration | use | ptruse
</pre><p>where</p>
<ul>
<li><code>prefix__type</code> is the schema type to be customized (the <code>prefix__type</code> name uses the common double underscore naming convention);</li>
<li><code>declaration</code> declares the C/C++ type in the wsdl2h-generated header file. This part can be empty if no explicit declaration is needed;</li>
<li><code>use</code> is an optional part that specifies how the C/C++ type is used in the code. When omitted, it is the same as <code>prefix__type</code>;</li>
<li><code>ptruse</code> is an optional part that specifies how the type is used as a pointer type. By default it is the <code>use</code> type name with a <code>*</code> or C++11 <code>std::shared_ptr&lt;&gt;</code> (see further below).</li>
</ul>
<p>For example, to map xsd:duration to a <code>long long</code> (<code>LONG64</code>) milliseconds value, we can use the custom serializer declared in <code>custom/duration.h</code> by adding the following line to <code>typemap.dat</code>: </p>
<pre class="fragment">xsd__duration = #import "custom/duration.h" | xsd__duration
</pre><p>Here, we could have omitted the second field, because <code>xsd__duration</code> is the name that wsdl2h uses to identify this type.</p>
<p>To map xsd:string to <code>wchar_t*</code> wide strings: </p>
<pre class="fragment">xsd__string = | wchar_t* | wchar_t*
</pre><p>Note that the first field is empty, because <code>wchar_t</code> is a C type and does not need to be declared. A <code>ptruse</code> field is given so that we do not end up generating the wrong pointer types, such as <code>wchar_t**</code> and <code>std::shared_ptr&lt;wchar_t&gt;</code>.</p>
<p>When the auto-generated declaration should be preserved but the <code>use</code> or <code>ptruse</code> fields replaced, then we use an ellipsis for the declaration part: </p>
<pre class="fragment">prefix__type = ... | use | ptruse
</pre><p>This is useful to map schema polymorphic types to C types for example, where we need to be able to both handle a base type and its extensions as per schema extensibility. Say we have a base type called ns:base that is extended, then we can remap this to a C type that permits referening the extended types via a <code>void*</code> as follows: </p>
<pre class="fragment">ns__base = ... | int __type_base; void*
</pre><p>such that <code>__type_base</code> and <code>void*</code> are used to (de)serialize any data type, including base and its derived types.</p>
<h2><a class="anchor" id="typemap3"></a>
Class/struct member additions                                        </h2>
<p>All generated classes and structs can be augmented with additional members such as methods, constructors and destructors, and private members: </p>
<pre class="fragment">prefix__type = $ member-declaration
</pre><p>For example, we can add method declarations and private members to a class, say <code>ns__record</code> as follows: </p>
<pre class="fragment">ns__record = $ ns__record(const ns__record &amp;);  // copy constructor
ns__record = $ void print();                    // a print method
ns__record = $ private: int status;             // a private member
</pre><p>Note that method declarations cannot include any code, because soapcpp2's input permits only type declarations, not code.</p>
<h2><a class="anchor" id="typemap4"></a>
Replacing XSD types by equivalent alternatives                       </h2>
<p>Type replacements can be given to replace one type entirely with another given type: </p>
<pre class="fragment">prefix__type1 == prefix__type2
</pre><p>This replaces all <code>prefix__type1</code> by <code>prefix__type2</code> in the wsdl2h output. However, care muse be taken not to agressively replace types, because this can cause XML validation to fail when a value-type mismatch is encountered in the XML input. Therefore, only replace similar types with other similar types that are wider (e.g. <code>short</code> by <code>int</code> and <code>float</code> by <code>double</code>).</p>
<h2><a class="anchor" id="typemap5"></a>
The built-in typemap.dat variables $CONTAINER and $POINTER           </h2>
<p>The <code>typemap.dat</code> <code>$CONTAINER</code> variable defines the container to emit in the generated declarations, which is <code>std::vector</code> by default. For example, to emit <code>std::list</code> as the container in the wsdl2h-generated declarations: </p>
<pre class="fragment">$CONTAINER = std::list
</pre><p>The <code>typemap.dat</code> <code>$POINTER</code> variable defines the smart pointer to emit in the generated declarations, which replaces the use of <code>*</code> pointers. For example: </p>
<pre class="fragment">$POINTER = std::shared_ptr
</pre><p>Not all pointers in the generated output can be replaced by smart pointers. Standard pointers are itill sed as union members and for pointers to arrays of objects.</p>
<h2><a class="anchor" id="typemap6"></a>
User-defined content                                                 </h2>
<p>Any other content to be generated by wsdl2h can be included in <code>typemap.dat</code> by enclosing it within brackets <code>[</code> and <code>]</code> anywhere in the <code>typemap.dat</code> file. Each of the two brackets MUST appear at the start of a new line.</p>
<p>For example, we can add an <code>#import "wsa5.h"</code> directive to the wsdl2h-generated output as follows: </p>
<pre class="fragment">[
#import "wsa5.h"
]
</pre><p>which emits the <code>#import "wsa5.h"</code> literally at the start of the wsdl2h-generated header file.</p>
<h1><a class="anchor" id="toxsd"></a>
Mapping C/C++ to XML schema                                             </h1>
<p>The soapcpp2 command generates the data binding implementation code from a data binding interface <code>file.h</code>: </p>
<pre class="fragment">soapcpp2 [options] file.h
</pre><p>where <code>file.h</code> is a gSOAP header file that declares the XML data binding interface. The <code>file.h</code> is typically generated by wsdl2h, but we can also declare one ourself. If so, we add gSOAP directives and declare in this file all our C/C++ types we want to serialize in XML. We can also declare functions that will be converted to service operations by soapcpp2.</p>
<p>Global function declarations define service operations, which are of the form: </p>
<pre class="fragment">int ns__name(arg1, arg2, ..., argn, result);
</pre><p>where <code>arg1</code>, <code>arg2</code>, ..., <code>argn</code> are formal argument declarations of the input and <code>result</code> is a formal argument for the output, which must be a pointer or reference to the result object to be populated. More information can be found in the gSOAP user guide.</p>
<h2><a class="anchor" id="toxsd1"></a>
Overview of serializable C/C++ types                                   </h2>
<p>The following C/C++ types are supported by soapcpp2 and mapped to XSD types and constructs. See the subsections below for more details or follow the links.</p>
<p>List of <a href="#toxsd3">C++ bool and C alternative</a> </p>
<pre class="fragment">bool                      C++ bool
enum xsd__boolean         C alternative bool
</pre><p>List of <a href="#toxsd4">enumerations and bitmasks</a> </p>
<pre class="fragment">enum                      enumeration
enum class                C++11 scoped enumeration (soapcpp2 -c++11)
enum*                     a bitmask that enumerates values 1, 2, 4, 8, ...
enum* class               C++11 scoped enumeration (soapcpp2 -c++11)
</pre><p>List of <a href="#toxsd5">numerical types</a> </p>
<pre class="fragment">char                      byte
short                     16 bit integer
int                       32 bit integer
long                      32 bit integer
LONG64                    64 bit integer
long long                 same as LONG64
unsigned char             unsigned byte
unsigned short            unsigned 16 bit integer
unsigned int              unsigned 32 bit integer
unsigned long             unsigned 32 bit integer
ULONG64                   unsigned 64 bit integer
unsigned long long        same as ULONG64
int8_t                    same as char
int16_t                   same as short
int32_t                   same as int
int64_t                   same as LONG64
uint8_t                   same as unsigned char
uint16_t                  same as unsigned short
uint32_t                  same as unsigned int
uint64_t                  same as ULONG64
size_t                    transient type (not serializable)
float                     32 bit float
double                    64 bit float
long double               128 bit float, use #import "custom/long_double.h"
typedef                   declares a type name, may restrict numeric range
</pre><p>List of <a href="#toxsd6">string types</a> </p>
<pre class="fragment">char*                     string
wchar_t*                  wide string
std::string               C++ string
std::wstring              C++ wide string
char[N]                   fixed-size string, requires soapcpp2 option -b
_QName                    normalized QName content
_XML                      literal XML string content
typedef                   declares a type name, may restrict string length
</pre><p>List of <a href="#toxsd7">date and time types</a> </p>
<pre class="fragment">time_t                    date and time point since epoch
struct tm                 date and time point, use #import "custom/struct_tm.h"
struct tm                 date point, use #import "custom/struct_tm_date.h"
struct timeval            date and time point, use #import "custom/struct_timeval.h"
unsigned long long        time point in microseconds, use #import "custom/long_time.h"
std::chrono::system_clock::time_point
                          date and time point, use #import "custom/chrono_time_point.h"
</pre><p>List of <a href="#toxsd8">time duration types</a> </p>
<pre class="fragment">long long                 duration in milliseconds, use #import "custom/duration.h"
std::chrono::nanoseconds  duration in nanoseconds, use #import "custom/chrono_duration.h"
</pre><p>List of <a href="#toxsd9">classes and structs</a> </p>
<pre class="fragment">class                     C++ class with single inheritance only
struct                    C struct or C++ struct without inheritance
T*                        pointer to type T
T[N]                      fixed-size array of type T
std::shared_ptr&lt;T&gt;        C++11 smart shared pointer
std::unique_ptr&lt;T&gt;        C++11 smart pointer
std::auto_ptr&lt;T&gt;          C++ smart pointer
std::deque&lt;T&gt;             use #import "stldeque.h"
std::list&lt;T&gt;              use #import "stllist.h"
std::vector&lt;T&gt;            use #import "stlvector.h"
std::set&lt;T&gt;               use #import "stlset.h"
template&lt;T&gt; class         a container with begin(), end(), size(), clear(), and insert() methods
union                     requires a discriminant member
void*                     requires a __type member to indicate the type of object pointed to
</pre><p>List of <a href="#toxsd10">special classes and structs</a> </p>
<pre class="fragment">Array                     single and multidimensional SOAP Arrays
xsd__hexBinary            binary content
xsd__base64Binary         binary content and optional MIME/MTOM attachments
Wrapper                   complexTypes with simpleContent
</pre><h2><a class="anchor" id="toxsd2"></a>
Colon notation versus name prefixing                                   </h2>
<p>To bind C/C++ type names to XSD types, a simple form of name prefixing is used by the gSOAP tools by prepending the XML namespace prefix to the C/C++ type name with a pair of undescrores. This also ensures that name clashes cannot occur when multiple WSDL and XSD files are converted to C/C++. Also, C++ namespaces are not sufficiently rich to capture XML schema namespaces accurately, for example when class members are associated with schema elements defined in another XML namespace and thus the XML namespace scope of the member's name is relevant, not just its type.</p>
<p>However, from a C/C++ centric point of view this can be cumbersome. Therefore, colon notation is an alternative to physically augmenting C/C++ names with prefixes.</p>
<p>For example, the following class uses colon notation to bind the <code>record</code> class to the <code>urn:types</code> schema: </p>
<pre class="fragment">//gsoap ns schema namespace: urn:types
class ns:record        // binding 'ns:' to a type name
{
 public:
  std::string name;
  uint64_t    SSN;
  ns:record   *spouse;  // using 'ns:' with the type name
  ns:record();          // using 'ns:' here too
  ~ns:record();         // and here
};
</pre><p>The colon notation is stripped away by soapcpp2 when generating the data binding implementation code for our project. So the final code just uses <code>record</code> to identify this class and its constructor/destructor.</p>
<p>When using colon notation we have to be consistent as we cannot use both forms together. That is, <code>ns:record</code> differs from <code>ns__record</code> as a name.</p>
<h2><a class="anchor" id="toxsd3"></a>
C++ Bool and C alternative                                             </h2>
<p>The C++ <code>bool</code> type is bound to built-in XSD type xsd:boolean.</p>
<p>The C alternative is to define an enumeration: </p>
<pre class="fragment">enum xsd__boolean { false_, true_ };
</pre><p>or by defining an enumeration in C with pseudo-scoped enumeration values: </p>
<pre class="fragment">enum xsd__boolean { xsd__boolean__false, xsd__boolean__true };
</pre><p>The XML value space of these types is <code>false</code> and <code>true</code>, but also accepts <code>0</code> and <code>1</code> as values.</p>
<p>To prevent name clashes, <code>false_</code> and <code>true_</code> have an underscore which are removed in the XML value space.</p>
<h2><a class="anchor" id="toxsd4"></a>
Enumerations and bitmasks                                              </h2>
<p>Enumerations are mapped to XSD simpleType enumeration restrictions of xsd:string, xsd:QName, and xsd:long.</p>
<p>Consider for example: </p>
<pre class="fragment">enum ns__Color { RED, WHITE, BLUE };
</pre><p>which maps to a simpleType restriction of xsd:string in the soapcpp2-generated schema: </p>
<pre class="fragment">&lt;simpleType name="Color"&gt;
  &lt;restriction base="xsd:string"&gt;
    &lt;enumeration value="RED"/&gt;
    &lt;enumeration value="WHITE"/&gt;
    &lt;enumeration value="BLUE"/&gt;
  &lt;/restriction&gt;
&lt;/simpleType&gt;
</pre><p>Enumeration name constants can be pseudo-scoped to prevent name clashes, because enumeration name constants have a global scope in C and C++: </p>
<pre class="fragment">enum ns__Color { ns__Color__RED, ns__Color__WHITE, ns__Color__BLUE };
</pre><p>We can also use C++11 scoped enumerations to prevent name clashes: </p>
<pre class="fragment">enum class ns__Color : int { RED, WHITE, BLUE };
</pre><p>Here, the type part <code>: int</code> is optional. In place of <code>int</code> in the example above, we can also use <code>int8_t</code>, <code>int16_t</code>, <code>int32_t</code>, or <code>int64_t</code>.</p>
<p>The XML value space of the enumertions defined above is <code>RED</code>, <code>WHITE</code>, and <code>BLUE</code>.</p>
<p>Prefix-qualified enumeration name constants are mapped to simpleType restrictions of xsd:QName, for example: </p>
<pre class="fragment">enum ns__types { xsd__int, xsd__float };
</pre><p>which maps to a simpleType restriction of xsd:QName in the soapcpp2-generated schema: </p>
<pre class="fragment">&lt;simpleType name="types"&gt;
  &lt;restriction base="xsd:QName"&gt;
    &lt;enumeration value="xsd:int"/&gt;
    &lt;enumeration value="xsd:float"/&gt;
  &lt;/restriction&gt;
&lt;/simpleType&gt;
</pre><p>Enumeration name constants can be pseudo-numeric as follows: </p>
<pre class="fragment">enum ns__Primes { _3 = 3, _5 = 5, _7 = 7, _11 = 11 };
</pre><p>which maps to a simpleType restriction of <code>xsd:long</code>: </p>
<pre class="fragment">&lt;simpleType name="Color"&gt;
  &lt;restriction base="xsd:long"&gt;
    &lt;enumeration value="3"/&gt;
    &lt;enumeration value="5"/&gt;
    &lt;enumeration value="7"/&gt;
    &lt;enumeration value="11"/&gt;
  &lt;/restriction&gt;
&lt;/simpleType&gt;
</pre><p>The XML value space of this type is <code>3</code>, <code>5</code>, <code>7</code>, and <code>11</code>.</p>
<p>Besides (pseudo-) scoped enumerations, another way to prevent name clashes accross enumerations is to start an enumeration name constant with one underscore or followed it by any number of underscores, which makes it unique. The leading and trailing underscores are removed in the XML value space. </p>
<pre class="fragment">enum ns__ABC { A, B, C };
enum ns__BA  { B, A };      // BAD: B = 1 but B is already defined as 2
enum ns__BA_ { B_, A_ };    // OK
</pre><p>The gSOAP soapcpp2 tool permits reusing enumeration name constants in other (non-scoped) enumerations as long as these values are assigned the same constant. Therefore, the following is permitted: </p>
<pre class="fragment">enum ns__Primes { _3 = 3, _5 = 5, _7 = 7, _11 = 11 };
enum ns__Throws { _1 = 1, _2 = 2, _3 = 3, _4 = 4, _5 = 5, _6 = 6 };
</pre><p>A bitmask type is an <code>enum*</code> "product" enumeration with a geometric, power-of-two sequence of values assigned to the name constants: </p>
<pre class="fragment">enum* ns__Options { SSL3, TLS10, TLS11, TLS12 };
</pre><p>where the product enum assigns 1 to <code>SSL3</code>, 2 to <code>TLS10</code>, 4 to <code>TLS11</code>, and 8 to <code>TLS12</code>, which allows the enumeration values to be used in composing bitmasks with <code>|</code> (bitwise or) <code>&amp;</code> (bitwise and), and <code>~</code> (bitwise not): </p>
<pre class="fragment">enum ns__Options options = (enum ns__Options)(SSL3 | TLS10 | TLS11 | TLS12);
if (options &amp; SSL3)  // if SSL3 is an option, warn and remove from options
{
  warning();
  options &amp;= ~SSL3;
}
</pre><p>The bitmask type maps to a simpleType list restriction of xsd:string in the soapcpp2-generated schema: </p>
<pre class="fragment">&lt;simpleType name="Options"&gt;
  &lt;list&gt;
    &lt;restriction base="xsd:string"&gt;
      &lt;enumeration value="SSL3"/&gt;
      &lt;enumeration value="TLS10"/&gt;
      &lt;enumeration value="TLS11"/&gt;
      &lt;enumeration value="TLS12"/&gt;
    &lt;/restriction&gt;
  &lt;/list&gt;
&lt;/simpleType&gt;
</pre><p>The XML value space of this type consists of all 16 possible subsets of the four values, represented by an XML string with space-separated values. For example, the bitmask <code>TLS10 | TLS11 | TLS12</code> equals 14 and is represented in by the XML string <code>TLS10 TLS11 TLS12</code>.</p>
<p>To convert <code>enum</code> name constants to string, we use the soapcpp2 auto-generated <code>const char *soap_T2s(soap, enum T)</code> function.</p>
<p>To convert a string to an <code>enum</code> name constant, we use the soapcpp2 auto-generated <code>int soap_s2T(soap, const char *str, enum T*)</code> function.</p>
<h2><a class="anchor" id="toxsd5"></a>
Numerical types                                                        </h2>
<p>Integer and floating point types are mapped to the equivalent built-in XSD types with the same sign and bit width.</p>
<p>The <code>size_t</code> type is transient (not serializable) because its width is platform dependent. We recommend to use <code>uint64_t</code> instead.</p>
<p>The XML value space of integer types are their decimal representations without loss of precision.</p>
<p>The XML value space of floating point types are their decimal representations. The decimal representations are formatted with the printf format string "%.9G" for floats and the printf format string "%.17lG" for double. The value space includes the values <code>INF</code>, <code>-INF</code>, and <code>NAN</code>. To change the format string, we can change one of these <code>struct soap</code> context data members: </p>
<pre class="fragment">const char * soap::float_format
const char * soap::double_format
</pre><p>Note that decimal conversions may result in a loss of precision of the least significant decimal.</p>
<p>A <code>long double</code> 128 bit floating point value requires a custom serializer: </p>
<pre class="fragment">#import "custom/long_double.h"
typedef long double xsd__decimal;
</pre><p>Compile and link your code with <code>custom/long_double.c</code>.</p>
<p>The range of a numerical type can be restricted with a typedef: </p>
<pre class="fragment">typedef int ns__narrow -10:10;
</pre><p>which maps to a simpleType restriction of xsd:int in the soapcpp2-generated schema: </p>
<pre class="fragment">&lt;simpleType name="narrow"&gt;
  &lt;restriction base="xsd:int"&gt;
    &lt;minInclusive value="-10"/&gt;
    &lt;maxInclusive value="10"/&gt;
  &lt;/restriction&gt;
&lt;/simpleType&gt;
</pre><p>The range of a float type can only be restricted within integral bounds. This restriction may be dropped in future releases.</p>
<h2><a class="anchor" id="toxsd6"></a>
String types                                                           </h2>
<p>String types are mapped to the built-in xsd:string and xsd:QName XSD types.</p>
<p>The wide strings <code>wchar_t*</code> and <code>std::wstring</code> may contain Unicode that is preserved in the XML value space.</p>
<p>Strings <code>char*</code> and <code>std::string</code> can only contain extended Latin, but we can store UTF-8 content that is preserved in the XML value space when the <code>struct soap</code> context is initialized with the flag <code>XML_C_UTFSTRING</code>.</p>
<p>Beware that many XML 1.0 parsers reject all control characters (those between <code>#x1</code> and <code>#x1F</code>) except <code>#x9</code>, <code>#xA</code>, and <code>#xD</code>. With the newer XML 1.1 parsers (including gSOAP) you should be fine.</p>
<p>The length of a string type can be restricted with a typedef: </p>
<pre class="fragment">typedef std::string ns__password 6:16;
</pre><p>which maps to a simpleType restriction of xsd:string in the soapcpp2-generated schema: </p>
<pre class="fragment">&lt;simpleType name="password"&gt;
  &lt;restriction base="xsd:string"&gt;
    &lt;minLength value="6"/&gt;
    &lt;maxLength value="16"/&gt;
  &lt;/restriction&gt;
&lt;/simpleType&gt;
</pre><p>In addition, an XSD regex pattern restriction can be associated with a string typedef: </p>
<pre class="fragment">typedef std::string ns__password "([a-zA-Z]|[0-9]|-)+" 6:16;
</pre><p>which maps to a simpleType restriction of xsd:string in the soapcpp2-generated schema: </p>
<pre class="fragment">&lt;simpleType name="password"&gt;
  &lt;restriction base="xsd:string"&gt;
    &lt;pattern value="([a-zA-Z0-9]|-)+"/&gt;
    &lt;minLength value="6"/&gt;
    &lt;maxLength value="16"/&gt;
  &lt;/restriction&gt;
&lt;/simpleType&gt;
</pre><p>Fixed-size strings (<code>char[N]</code>) are rare occurrences in the wild, but apparently still used in some projects to store strings. To facilitate fixed-size string serialization, use soapcpp2 option <code>-b</code>: </p>
<pre class="fragment">typedef char ns__buffer[10];  // requires soapcpp2 option -b
</pre><p>which maps to a simpleType restriction of xsd:string in the soapcpp2-generated schema: </p>
<pre class="fragment">&lt;simpleType name="buffer"&gt;
  &lt;restriction base="xsd:string"&gt;
    &lt;maxLength value="9"/&gt;
  &lt;/restriction&gt;
&lt;/simpleType&gt;
</pre><p>Note that fixed-size strings MUST contain NUL-terminated text and SHOULD NOT contain raw binary data. Also, the length limitation is more restrictive for UTF-8 content (enabled with the <code>SOAP_C_UTFSTRING</code>) that requires multibyte character encodings. As a consequence, UTF-8 content may be truncated to fit.</p>
<p>Note that raw binary data can be stored in a <code>xsd__base64Binary</code> or <code>xsd__hexBinary</code> structure, or transmitted as a MIME attachment.</p>
<p>The built-in <code>_QName</code> type is a regular C string type (<code>char*</code>) that maps to xsd:QName but has the added advantage that it holds normalized qualified names. There are actually two forms of normalized QName content, to ensure any QName is represented accurately and uniquely: </p>
<pre class="fragment">prefix:name
"URI":name
</pre><p>where the first form is used when the prefix (and the binding URI) is defined in the namespace table and is bound to a URI (see the .nsmap file). The second form is used when the URI is not defined in the namespace table and therefore no prefix is available to bind and normalize the URI to.</p>
<p>A <code>_QName</code> string may contain a sequence of space-separated QName values, not just one, and all QName values are normalized to the format shown above.</p>
<p>To define a <code>std::string</code> base type for xsd:QName, we use a typedef: </p>
<pre class="fragment">typedef std::string xsd__QName;
</pre><p>The <code>xsd__QName</code> string content is normalized, just as with the <code>_QName</code> normalization.</p>
<p>To serialize strings that contain literal XML content to be reproduced in the XML value space, use the built-in <code>_XML</code> string type, which is a regular C string type (<code>char*</code>) that maps to plain XML CDATA.</p>
<p>To define a <code>std::string</code> base type for literal XML content, use a typedef: </p>
<pre class="fragment">typedef std::string XML;
</pre><p>Strings can hold any of the values of the XSD built-in primitive types. We can use a string typedef to declare the use of the string type as a XSD built-in type: </p>
<pre class="fragment">typedef std::string xsd__token;
</pre><p>We MUST ensure that the string values we populate in this type conform to the XML standard, which in case of xsd:token is: the lexical and value spaces of xsd:token are the sets of all strings after whitespace replacement of any occurrence of <code>#x9</code>, <code>#xA</code> , and <code>#xD</code> by <code>#x20</code> and collapsing.</p>
<h2><a class="anchor" id="toxsd7"></a>
Date and time types                                                    </h2>
<p>The C/C++ <code>time_t</code> type is mapped to the built-in xsd:dateTime XSD type that represents a date and time within a time zone (typically UTC).</p>
<p>The XML value space contains ISO 8601 Gregorian time instances of the form <code>[-]CCYY-MM-DDThh:mm:ss.sss[Z|(+|-)hh:mm]</code>, where <code>Z</code> is the UTC time zone or a time zone offset <code>(+|-)hh:mm]</code> from UTC is used.</p>
<p>A <code>time_t</code> value is considered and represented in UTC by the serializer.</p>
<p>Because the <code>time_t</code> value range is restricted to dates after 01/01/1970, care must be taken to ensure the range of xsd:dateTime values in XML exchanges do not exceed the <code>time_t</code> range.</p>
<p>This restriction does not hold for <code>struct tm</code> (<code>&lt;time.h&gt;</code>), which we can use to store and communicate a date and time in UTC without date range restrictions. The serializer uses the <code>tm</code> data members directly for conversion to/from the XML value space of xsd:dateTime: </p>
<pre class="fragment">struct tm
{
  int    tm_sec;    // seconds (0 - 60)
  int    tm_min;    // minutes (0 - 59)
  int    tm_hour;   // hours (0 - 23)
  int    tm_mday;   // day of month (1 - 31)
  int    tm_mon;    // month of year (0 - 11)
  int    tm_year;   // year - 1900
  int    tm_wday;   // day of week (Sunday = 0) (NOT USED)
  int    tm_yday;   // day of year (0 - 365) (NOT USED)
  int    tm_isdst;  // is summer time in effect?
  char*  tm_zone;   // abbreviation of timezone (NOT USED)
};
</pre><p>The <code>struct tm</code> type is mapped to the built-in xsd:dateTime XSD type and serialized with the custom serializer <code>custom/struct_tm.h</code> that declares a <code>xsd__dateTime</code> type: </p>
<pre class="fragment">#import "custom/struct_tm.h"  // import typedef struct tm xsd__dateTime;
... use xsd__dateTime ...
</pre><p>Compile and link your code with <code>custom/struct_tm.c</code>.</p>
<p>The <code>struct tm</code> type is mapped to the built-in xsd:date XSD type and serialized with the custom serializer <code>custom/struct_tm_date.h</code> that declares a <code>xsd__date</code> type: </p>
<pre class="fragment">#import "custom/struct_tm_date.h"  // import typedef struct tm xsd__date;
... use xsd__date ...
</pre><p>Compile and link your code with <code>custom/struct_tm_date.c</code>.</p>
<p>The XML value space of xsd:date are Gregorian calendar dates of the form <code>[-]CCYY-MM-DD[Z|(+|-)hh:mm]</code>.</p>
<p>The <code>struct timeval</code> (<code>&lt;sys/time.h&gt;</code>) type is mapped to the built-in xsd:dateTime XSD type and serialized with the custom serializer <code>custom/struct_timeval.h</code> that declares a <code>xsd__dateTime</code> type: </p>
<pre class="fragment">#import "custom/struct_timeval.h"  // import typedef struct timeval xsd__dateTime;
... use xsd__dateTime ...
</pre><p>Compile and link your code with <code>custom/struct_timeval.c</code>.</p>
<p>Note that the same value range restrictions apply to <code>struct timeval</code> as they apply to <code>time_t</code>. The added benefit of <code>struct timeval</code> is the addition of a microsecond-precise clock: </p>
<pre class="fragment">struct timeval
{
 time_t       tv_sec;   // seconds since Jan. 1, 1970
 suseconds_t  tv_usec;  // and microseconds
};
</pre><p>An <code>unsigned long long</code> (<code>ULONG64</code> or <code>uint64_t</code>) type that contains a 24 hour time in microseconds UTC is mapped to the built-in xsd:time XSD type and serialized with the custom serializer <code>custom/long_time.h</code> that declares a <code>xsd__time</code> type: </p>
<pre class="fragment">#import "custom/long_time.h"  // import typedef unsigned long long xsd__time;
... use xsd__time ...
</pre><p>Compile and link your code with <code>custom/long_time.c</code>.</p>
<p>The XML value space of xsd:time are points in time recurring each day of the form <code>hh:mm:ss.sss[Z|(+|-)hh:mm]</code>, where <code>Z</code> is the UTC time zone or a time zone offset from UTC is used. The <code>xsd__time</code> value is always considered and represented in UTC by the serializer.</p>
<p>A C++11 <code>std::chrono::system_clock::time_point</code> type is mapped to the built-in xsd:dateTime XSD type and serialized with the custom serializer <code>custom/chrono_time_point.h</code> that declares a <code>xsd__dateTime</code> type: </p>
<pre class="fragment">#import "custom/chrono_time_point.h"  // import typedef std::chrono::system_clock::time_point xsd__dateTime;
... use xsd__dateTime ...
</pre><p>Compile and link your code with <code>custom/chrono_time_point.cpp</code>.</p>
<h2><a class="anchor" id="toxsd8"></a>
Time duration types                                                    </h2>
<p>The XML value space of xsd:duration are values of the form <code>PnYnMnDTnHnMnS</code> where the capital letters are delimiters. Delimiters may be omitted when the corresponding member is not used.</p>
<p>A <code>long long</code> (<code>LONG64</code> or <code>int64_t</code>) type that contains a duration (time lapse) in milliseconds is mapped to the built-in xsd:duration XSD type and serialized with the custom serializer <code>custom/duration.h</code> that declares a <code>xsd__duration</code> type: </p>
<pre class="fragment">#import "custom/duration.h"  // import typedef long long xsd__duration;
... use xsd__duration ...
</pre><p>Compile and link your code with <code>custom/duration.c</code>.</p>
<p>The duration type <code>xsd__duration</code> can represent 106,751,991,167 days forward and backward with millisecond precision.</p>
<p>A C++11 <code>std::chrono::nanoseconds</code> type is mapped to the built-in xsd:duration XSD type and serialized with the custom serializer <code>custom/chrono_duration.h</code> that declares a <code>xsd__duration</code> type: </p>
<pre class="fragment">#import "custom/chrono_duration.h"  // import typedef std::chrono::duration xsd__duration;
... use xsd__duration ...
</pre><p>Compile and link your code with <code>custom/chrono_duration.cpp</code>.</p>
<h2><a class="anchor" id="toxsd9"></a>
Classes and structs                                                    </h2>
<p>Classes and structs are mapped to XSD complexTypes. The XML value space consists of XML elements with attributes and subelements, possibly constrained by validation rules that enforce element and attribute occurrence contraints, numerical value range constraints, and string length and pattern constraints.</p>
<p>Classes that are declared with the gSOAP tools are limited to single inheritence only. Structs cannot be inherited.</p>
<p>The class and struct name is bound to an XML namespace by means of the prefix naming convention or by using <a href="#toxsd1">colon notation</a>: </p>
<pre class="fragment">//gsoap ns schema namespace: urn:types
class ns__record
{
 public:
  std::string  name;
  uint64_t     SSN;
  ns__record  *spouse;
  ns__record();
  ~ns__record();
 protected:
  struct soap  *soap;
};
</pre><p>In the example above, we also added a context pointer to the <code>struct soap</code> that manages this instance. It is set when the instance is created in the engine's context, for example when deserialized and populated by the engine.</p>
<p>The class maps to a complexType in the soapcpp2-generated schema: </p>
<pre class="fragment">&lt;complexType name="record"&gt;
  &lt;sequence&gt;
    &lt;element name="name" type="xsd:string" minOccurs="1" maxOccurs="1"/&gt;
    &lt;element name="SSN" type="xsd:unsignedLong" minOccurs="1" maxOccurs="1"/&gt;
    &lt;element name="spouse" type="ns:record" minOccurs="0" maxOccurs="1" nillable="true"/&gt;
  &lt;/sequence&gt;
&lt;/complexType&gt;
</pre><h3>Serializable versus transient types and members</h3>
<p>Public data members of a class or struct are serialized. Private and protected members are transient and not serializable.</p>
<p>Also <code>const</code> and <code>static</code> members are not serializable, with the exception of <code>const char*</code> and <code>const wchar_t*</code>.</p>
<p>Types and specific class/struct members can be made transient by using the <code>extern</code> qualifier: </p>
<pre class="fragment">extern class std::ostream;  // declare 'std::ostream' transient
class ns__record
{
 public:
  extern int       num;         // not serialized
  std::ostream     out;         // not serialized
  static const int MAX = 1024;  // not serialized
};
</pre><p>By declaring <code>std::ostream</code> transient we can use this type where we need it and without soapcpp2 complaining that this class is not defined.</p>
<h3>Volatile classes and structs</h3>
<p>Classes and structs can be declared <code>volatile</code> with the gSOAP tools. This means that they are already declared elsewhere in our project's source code. We do not want soapcpp2 to generate a second definition for these types.</p>
<p>For example, <code>struct tm</code> is declared in <code>&lt;time.h&gt;</code>. We want it serializable and serialize only a selection of its data members: </p>
<pre class="fragment">volatile struct tm
{
  int    tm_sec;    // seconds (0 - 60)
  int    tm_min;    // minutes (0 - 59)
  int    tm_hour;   // hours (0 - 23)
  int    tm_mday;   // day of month (1 - 31)
  int    tm_mon;    // month of year (0 - 11)
  int    tm_year;   // year - 1900
};
</pre><p>We can declare classes and structs <code>volatile</code> for any such types we want to serialize by only providing the public data members we want to serialize.</p>
<p>Colon notation comes in handy to bind an existing class or struct to a schema. For example, we can change the <code>tm</code> name as follows without affecting the code that uses <code>struct tm</code> generated by soapcpp2: </p>
<pre class="fragment">volatile struct ns:tm { ... }
</pre><p>This struct maps to a complexType in the soapcpp2-generated schema: </p>
<pre class="fragment">&lt;complexType name="tm"&gt;
  &lt;sequence&gt;
    &lt;element name="tm-sec" type="xsd:int" minOccurs="1" maxOccurs="1"/&gt;
    &lt;element name="tm-min" type="xsd:int" minOccurs="1" maxOccurs="1"/&gt;
    &lt;element name="tm-hour" type="xsd:int" minOccurs="1" maxOccurs="1"/&gt;
    &lt;element name="tm-mday" type="xsd:int" minOccurs="1" maxOccurs="1"/&gt;
    &lt;element name="tm-mon" type="xsd:int" minOccurs="1" maxOccurs="1"/&gt;
    &lt;element name="tm-year" type="xsd:int" minOccurs="1" maxOccurs="1"/&gt;
  &lt;/sequence&gt;
&lt;/complexType&gt;
</pre><h3>Mutable classes and structs</h3>
<p>Classes and structs can be declared <code>mutable</code> with the gSOAP tools. This means that their definition can be spread out over the source code. This promotes the concept of a class or struct as a <em>row of named values</em>, also known as a <em>named tuple</em>, that can be extended as needed with additional entries. Because these types differ from the traditional object-oriented principles of classes and objects, constructors and destructors cannot be defined (also because we cannot guarantee merging these into one such that all members will be initialized). A default constructor, copy constructor, assignment operation, and destructor will be assigned. </p>
<pre class="fragment">mutable struct ns__tuple
{
  @std::string  id;
};

mutable struct ns__tuple
{
  std::string  name;
  std::string  value;
};
</pre><p>The members are collected into one definition generated by soapcpp2. Members may be repeated from one definition to another, but only if their associated types are identical. So a third extension with a <code>value</code> member with a different type fails: </p>
<pre class="fragment">mutable struct ns__tuple
{
  duuble       value;  // BAD: value is already declared std::string
};
</pre><p>The <code>mutable</code> concept has proven to be very useful when declaring and collecting SOAP Headers for multiple services, which are collected into one <code>struct <a class="el" href="struct_s_o_a_p___e_n_v_____header.html">SOAP_ENV__Header</a></code> by the soapcpp2 tool.</p>
<h3>Default member values</h3>
<p>Class and struct data members may be declared with a default initialization value that is provided "inline" with the declaration of the member: </p>
<pre class="fragment">class ns__record
{
 public:
  std::string name = "Joe";
</pre><p>These initializations are made by the default constructor that is added by soapcpp2 to each class and struct. A constructor is only added when a default constructor is not already defined with the class declaration.</p>
<p>Initializations can only be provided for members that have primitive types (<code>bool</code>, <code>enum</code>, <code>time_t</code>, numeric and string types).</p>
<h3>Attribute members</h3>
<p>Class and struct data members can be declared as XML attributes by annotating their type with a <code>@</code> with the declaration of the member: </p>
<pre class="fragment">class ns__record
{
 public:
  @std::string name;
  @uint64_t    SSN;
  ns__record  *spouse;
};
</pre><p>This class maps to a complexType in the soapcpp2-generated schema: </p>
<pre class="fragment">&lt;complexType name="record"&gt;
  &lt;sequence&gt;
    &lt;element name="spouse" type="ns:record" minOccurs="0" maxOccurs="1" nillable="true"/&gt;
  &lt;/sequence&gt;
  &lt;attribute name="name" type="xsd:string" use="required"/&gt;
  &lt;attribute name="SSN" type="xsd:unsignedLong" use="required"/&gt;
&lt;/complexType&gt;
</pre><p>An example XML instance of <code>ns__record</code> is: </p>
<pre class="fragment">&lt;ns:record xmlns:ns="urn:types" name="Joe" SSN="1234567890"&gt;
  &lt;spouse&gt;
    &lt;name&gt;Jane&lt;/name&gt;
    &lt;SSN&gt;1987654320&lt;/SSN&gt;
  &lt;/spouse&gt;
&lt;/ns:record&gt;
</pre><p>Attribute data members are restricted to primitive types (<code>bool</code>, <code>enum</code>, <code>time_t</code>, numeric and string types), <code>xsd__hexBinary</code>, <code>xsd__base64Binary</code>, and custom serializers, such as <code>xsd__dateTime</code>. Custom serializers for types that may be used as attributes MUST define <code>soap_s2T</code> and <code>soap_T2s</code> functions that convert values of type <code>T</code> to strings and back.</p>
<p>Attribute data members can be pointers and smart pointers to these types, which permits attributes to be optional.</p>
<h3>(Smart) pointer members and their occurrence constraints</h3>
<p>A public pointer-typed data member is serialized by following its (smart) pointer(s) to the value pointed to.</p>
<p>Pointers that are NULL and smart pointers that are empty are serialized to produce omitted element and attribute values, unless an element is required and is nillable.</p>
<p>To control the occurrence requirements of pointer-based data members, occurrence constraints are associated with data members in the form of a range <code>minOccurs : maxOccurs</code>. For non-repeatable (meaning, not a container or array) data members, there are only three reasonable occurrence constraints:</p>
<ul>
<li><code>0:0</code> means that this element or attribute is prohibited.</li>
<li><code>0:1</code> means that this element or attribute is optional.</li>
<li><code>1:1</code> means that this element or attribute is required.</li>
</ul>
<p>Pointer-based data members have a default <code>0:1</code> occurrence constraint, making them optional, and their XSD schema local element/attribute definition is marked as nillable. Non-pointer data members have a default <code>1:1</code> occurence constraint, making them required.</p>
<p>A pointer data member that is explicitly marked as required with <code>1:1</code> will be serialized as an element with an xsi:nil attribute, thus effectively revealing the NULL property of its value.</p>
<p>A non-pointer data member that is explicitly marked as optional with <code>0:1</code> will be set to its default value when no XML value is presented to the deserializer. A default value can be assigned to data members that have primitive types.</p>
<p>Consider for example: </p>
<pre class="fragment">class ns__record
{
 public:
  std::shared_ptr&lt;std::string&gt;  name;              // optional (0:1)
  uint64_t                      SSN    0:1 = 999;  // forced this to be optional with default 999
  ns__record                   *spouse 1:1;        // forced this to be required (only married people)
};
</pre><p>This class maps to a complexType in the soapcpp2-generated schema: </p>
<pre class="fragment">&lt;complexType name="record"&gt;
  &lt;sequence&gt;
    &lt;element name="name" type="xsd:string" minOccurs="0" maxOccurs="1" nillable="true"/&gt;
    &lt;element name="SSN" type="xsd:unsignedLong" minOccurs="0" maxOccurs="1" default="999"/&gt;
    &lt;element name="spouse" type="ns:record" minOccurs="1" maxOccurs="1" nillable="true"/&gt;
  &lt;/sequence&gt;
&lt;/complexType&gt;
</pre><p>An example XML instance of <code>ns__record</code> with its <code>name</code> string value set to <code>Joe</code>, <code>SSN</code> set to its default, and <code>spouse</code> set to NULL: </p>
<pre class="fragment">&lt;ns:record xmlns:ns="urn:types"&gt;
  &lt;name&gt;Joe&lt;/name&gt;
  &lt;SSN&gt;999&lt;/SSN&gt;
  &lt;spouse xsi:nil="true"/&gt;
&lt;/ns:record&gt;
</pre><h3>Container members and their occurrence constraints</h3>
<p>Class and struct data members declared as a container <code>std::deque</code>, <code>std::list</code>, <code>std::set</code>, and <code>std::vector</code> are serialized as a collection of values: </p>
<pre class="fragment">class ns__record
{
 public:
  std::vector&lt;std::string&gt;  names;
  uint64_t                  SSN;
};
</pre><p>To practically limit the number of names within reasonable bounds, occurrence constraints are associated with the container. Occurrence constraints are of the form <code>minOccurs : maxOccurs</code>: </p>
<pre class="fragment">class ns__record
{
 public:
  std::vector&lt;std::string&gt;  names 1:10;
  uint64_t                  SSN;
};
</pre><p>This class maps to a complexType in the soapcpp2-generated schema: </p>
<pre class="fragment">&lt;complexType name="record"&gt;
  &lt;sequence&gt;
    &lt;element name="name" type="xsd:string" minOccurs="1" maxOccurs="10"/&gt;
    &lt;element name="SSN" type="xsd:unsignedLong" minOccurs="1" maxOccurs="1""/&gt;
  &lt;/sequence&gt;
&lt;/complexType&gt;
</pre><p>Because C does not support a container template library, we can use a dynamically-sized array of values. This array is declared as a size-pointer member pair: </p>
<pre class="fragment">struct ns__record
{
  $int      sizeofnames;  // array size
  char*    *names;        // array of char* names
  uint64_t  SSN;
};
</pre><p>where the marker <code>$</code> with <code>int</code> denotes a special type that is used to store the array size and to indicate that this is a size-pointer member pair that declares a dynamically-sized array.</p>
<p>This class maps to a complexType in the soapcpp2-generated schema: </p>
<pre class="fragment">&lt;complexType name="record"&gt;
  &lt;sequence&gt;
    &lt;element name="name" type="xsd:string" minOccurs="0" maxOccurs="unbounded" nillable="true"/&gt;
    &lt;element name="SSN" type="xsd:unsignedLong" minOccurs="1" maxOccurs="1""/&gt;
  &lt;/sequence&gt;
&lt;/complexType&gt;
</pre><p>To limit the number of names in the array within reasonable bounds, occurrence constraints are associated with the array size member. Occurrence constraints are of the form <code>minOccurs : maxOccurs</code>: </p>
<pre class="fragment">struct ns__record
{
  $int      sizeofnames 1:10;  // array size 1..10
  char*    *names;             // array of one to ten char* names
  uint64_t  SSN;
};
</pre><p>This class maps to a complexType in the soapcpp2-generated schema: </p>
<pre class="fragment">&lt;complexType name="record"&gt;
  &lt;sequence&gt;
    &lt;element name="name" type="xsd:string" minOccurs="1" maxOccurs="10" nillable="true"/&gt;
    &lt;element name="SSN" type="xsd:unsignedLong" minOccurs="1" maxOccurs="1""/&gt;
  &lt;/sequence&gt;
&lt;/complexType&gt;
</pre><h3>Union members</h3>
<p>A union member in a class or in a struct cannot be serialized unless a discriminating variant selector is provided that tells the serializer which union field to serialize.</p>
<p>The variant selector is associated with the union as a selector-union member pair, where the variant selector is a special <code>$int</code> member: </p>
<pre class="fragment">class ns__record
{
 public:
  $int  xORnORs;  // variant selector
  union choice
  {
    float x;
    int   n;
    char *s;
  } u;
  std::string name;
};
</pre><p>The variant selector values are auto-generated based on the union name <code>choice</code> and the names of its members <code>x</code>, <code>n</code>, and <code>s</code>:</p>
<ul>
<li><code>xORnORs = SOAP_UNION_choice_x</code> when <code>u.x</code> is valid.</li>
<li><code>xORnORs = SOAP_UNION_choice_n</code> when <code>u.n</code> is valid.</li>
<li><code>xORnORs = SOAP_UNION_choice_s</code> when <code>u.s</code> is valid.</li>
<li><code>xORnORs = 0</code> when none are valid (should only be used with great care, because XML content validation may fail when content is required but absent).</li>
</ul>
<p>This class maps to a complexType with a sequence and choice in the soapcpp2-generated schema: </p>
<pre class="fragment">&lt;complexType name="record"&gt;
  &lt;sequence&gt;
    &lt;choice&gt;
      &lt;element name="x" type="xsd:float" minOccurs="1" maxOccurs="1"/&gt;
      &lt;element name="n" type="xsd:int" minOccurs="1" maxOccurs="1"/&gt;
      &lt;element name="s" type="xsd:string" minOccurs="0" maxOccurs="1" nillable="true"/&gt;
    &lt;/choice&gt;
    &lt;element name="names" type="xsd:string" minOccurs="1" maxOccurs="10" nillable="true"/&gt;
  &lt;/sequence&gt;
&lt;/complexType&gt;
</pre><h3>Adding get and set methods</h3>
<p>A public <code>get</code> method may be added to a class or struct, which will be triggered by the deserializer. This method will be invoked right after the instance is populated by the deserializer. The <code>get</code> method can be used to update or verify deserialized content. It should return <code>SOAP_OK</code> or set <code>soap::error</code> to a nonzero error code and return it.</p>
<p>A public <code>set</code> method may be added to a class or struct, which will be triggered by the serializer. The method will be invoked just before the instance is serialized. Likewise, the <code>set</code> method should return <code>SOAP_OK</code> or set set <code>soap::error</code> to a nonzero error code and return it.</p>
<p>For example, adding a <code>set</code> and <code>get</code> method to a class declaration: </p>
<pre class="fragment">class ns__record
{
 public:
  int set(struct soap*);  // triggered before serialization
  int get(struct soap*);  // triggered after deserialization
</pre><p>To add these and othe rmethods to classes and structs with wsdl2h and <code>typemap.dat</code>, please see section <a href="#typemap3">class and struct addition</a>.</p>
<h3>Defining document root elements</h3>
<p>To define and reference XML document root elements we use type names that start with an underscore: </p>
<pre class="fragment">class _ns__record
</pre><p>Alternatively, we can use a typedef to define a document root element with a given type: </p>
<pre class="fragment">typedef ns__record _ns__record;
</pre><p>This typedef maps to a global root element that is added to the soapcpp2-generated schema: </p>
<pre class="fragment">&lt;element name="record" type="ns:record"/&gt;
</pre><p>An example XML instance of <code>_ns__record</code> is: </p>
<pre class="fragment">&lt;ns:record xmlns:ns="urn:types"&gt;
  &lt;name&gt;Joe&lt;/name&gt;
  &lt;SSN&gt;1234567890&lt;/SSN&gt;
  &lt;spouse&gt;
    &lt;name&gt;Jane&lt;/name&gt;
    &lt;SSN&gt;1987654320&lt;/SSN&gt;
  &lt;/spouse&gt;
&lt;/ns:record&gt;
</pre><p>Global-level element/attribute definitions are also referenced and/or added to the generated schema when serializable data members reference these by their qualified name: </p>
<pre class="fragment">typedef std::string _ns__name 1:100;
class _ns__record
{
 public:
  @_QName      xsi__type;  // built-in XSD attribute xsi:type
  _ns__name    ns__name;   // ref to global ns:name element
  uint64_t     SSN;
  _ns__record *spouse;
};
</pre><p>These types map to the following comonents in the soapcpp2-generated schema: </p>
<pre class="fragment">&lt;simpleType name="name"&gt;
  &lt;restriction base="xsd:string"&gt;
    &lt;minLength value="1"/&gt;
    &lt;maxLength value="100"/&gt;
  &lt;/restriction&gt;
&lt;/simpleType&gt;
&lt;element name="name" type="ns:name"/&gt;
&lt;complexType name="record"&gt;
  &lt;sequence&gt;
    &lt;element ref="ns:name" minOccurs="1" maxOccurs="1"/&gt;
    &lt;element name="SSN" type="xsd:unsignedLong" minOccurs="1" maxOccurs="1"/&gt;
    &lt;element name="spouse" type="ns:record" minOccurs="0" maxOccurs="1" nillable="true"/&gt;
  &lt;/sequence&gt;
  &lt;attribute ref="xsi:type" use="optional"/&gt;
&lt;/complexType&gt;
&lt;element name="record" type="ns:record"/&gt;
</pre><p>However, we must warn against using qualified member names when their types do not match their definitions: </p>
<pre class="fragment">class _ns__record
{
 public:
  int  ns__name;  // BAD: element ns:name is NOT of an int type
</pre><p>Therefore, we recommend to avoid qualified member names and only use them when referring to standard XSD elements and attributes, such as <code>xsi__type</code>, and <code>xsd__lang</code>. The soapcpp2 tool does not prevent abuse of this mechanism.</p>
<h3>Operations on classes and structs</h3>
<p>The following functions/macros are generated by soapcpp2 for each type <code>T</code>, which should make it easier to send, receive, and copy XML data in C and in C++:</p>
<ul>
<li><code>int soap_write_T(struct soap*, T*)</code> writes an instance of <code>T</code> to a FILE (via <code>FILE *soap::sendfd)</code>) or to a stream (via <code>std::ostream *soap::os</code>). Returns <code>SOAP_OK</code> on success or an error code, also stored in <code>soap-&gt;error</code>.</li>
</ul>
<ul>
<li><code>int soap_read_T(struct soap*, T*)</code> reads an instance of <code>T</code> from a FILE (via <code>FILE *soap::recvfd)</code>) or from a stream (via <code>std::istream *soap::is</code>). Returns <code>SOAP_OK</code> on success or an error code, also stored in <code>soap-&gt;error</code>.</li>
</ul>
<ul>
<li><code>void soap_default_T(struct soap*, T*)</code> sets an instance <code>T</code> to its default value, resetting members of a struct to their initial values (for classes we use method <code>T::soap_default</code>, see below).</li>
</ul>
<ul>
<li><code>T * soap_dup_T(struct soap*, T *dst, const T *src)</code> (soapcpp2 option <code>-Ec</code>) deep copy <code>src</code> into <code>dst</code>, replicating all deep cycles and shared pointers when a managing soap context is provided as argument. When <code>dst</code> is NULL, allocates space for <code>dst</code>. Deep copy is a tree when argument is NULL, but the presence of deep cycles will lead to non-termination. Use flag <code>SOAP_XML_TREE</code> with managing context to copy into a tree without cycles and pointers to shared objects. Returns <code>dst</code> (or allocated space when <code>dst</code> is NULL).</li>
</ul>
<ul>
<li><code>void soap_del_T(const T*)</code> (soapcpp2 option <code>-Ed</code>) deletes all heap-allocated members of this object by deep deletion ONLY IF this object and all of its (deep) members are not managed by a soap context AND the deep structure is a tree (no cycles and co-referenced objects by way of multiple (non-smart) pointers pointing to the same data). Can be safely used after <code>soap_dup(NULL)</code> to delete the deep copy. Does not delete the object itself.</li>
</ul>
<p>When in C++ mode, soapcpp2 tool adds several methods to classes and structs, in addition to adding a default constructor and destructor (when these were not explicitly declared).</p>
<p>The public methods added to a class/struct <code>T</code>:</p>
<ul>
<li><code>virtual int T::soap_type(void)</code> returns a unique type ID (<code>SOAP_TYPE_T</code>). This numeric ID can be used to distinguish base from derived instances.</li>
</ul>
<ul>
<li><code>virtual void T::soap_default(struct soap*)</code> sets all data members to default values.</li>
</ul>
<ul>
<li><code>virtual void T::soap_serialize(struct soap*) const</code> serializes object to prepare for SOAP 1.1/1.2 encoded output (or with <code>SOAP_XML_GRAPH</code>) by analyzing its (cyclic) structures.</li>
</ul>
<ul>
<li><code>virtual int T::soap_put(struct soap*, const char *tag, const char *type) const</code> emits object in XML, compliant with SOAP 1.1 encoding style, return error code or <code>SOAP_OK</code>. Requires <code>soap_begin_send(soap)</code> and <code>soap_end_send(soap)</code>.</li>
</ul>
<ul>
<li><code>virtual int T::soap_out(struct soap*, const char *tag, int id, const char *type) const</code> emits object in XML, with tag and optional id attribute and xsi:type, return error code or <code>SOAP_OK</code>. Requires <code>soap_begin_send(soap)</code> and <code>soap_end_send(soap)</code>.</li>
</ul>
<ul>
<li><code>virtual void * T::soap_get(struct soap*, const char *tag, const char *type)</code> Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error. Requires <code>soap_begin_recv(soap)</code> and <code>soap_end_recv(soap)</code>.</li>
</ul>
<ul>
<li><code>virtual void *soap_in(struct soap*, const char *tag, const char *type)</code> Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error. Requires <code>soap_begin_recv(soap)</code> and <code>soap_end_recv(soap)</code></li>
</ul>
<ul>
<li><code>virtual T * T::soap_alloc(void) const</code> returns a new object of type <code>T</code>, default initialized and not managed by a soap context.</li>
</ul>
<ul>
<li><code>virtual T * T::soap_dup(struct soap*) const</code> (soapcpp2 option <code>-Ec</code>) returns a duplicate of this object by deep copying, replicating all deep cycles and shared pointers when a managing soap context is provided as argument. Deep copy is a tree when argument is NULL, but the presence of deep cycles will lead to non-termination. Use flag <code>SOAP_XML_TREE</code> with managing context to copy into a tree without cycles and pointers to shared objects.</li>
</ul>
<ul>
<li><code>virtual void T::soap_del() const</code> (soapcpp2 option <code>-Ed</code>) deletes all heap-allocated members of this object by deep deletion ONLY IF this object and all of its (deep) members are not managed by a soap context AND the deep structure is a tree (no cycles and co-referenced objects by way of multiple (non-smart) pointers pointing to the same data).Can be safely used after <code>soap_dup(NULL)</code> to delete the deep copy. Does not delete the object itself.</li>
</ul>
<h2><a class="anchor" id="toxsd10"></a>
Special classes and structs                                           </h2>
<p>A class or struct with the following layout is a one-dimensional SOAP Array type: </p>
<pre class="fragment">class Array
{
 public:
  T   *__ptr;   // array pointer
  int  __size;  // array size
};
</pre><p>where <code>T</code> is the array element type. A multidimensional SOAP Array is: </p>
<pre class="fragment">class Array
{
 public:
  T   *__ptr;      // array pointer
  int  __size[N];  // array size of each dimension
};
</pre><p>where <code>N</code> is the constant number of dimensions. The pointer points to an array of <code>__size[0]*__size[1]* ... * __size[N-1]</code> elements.</p>
<p>A special case of a one-dimensional array is used to define xsd:hexBinary and xsd:base64Binary types when the pointer type is <code>unsigned char</code>: </p>
<pre class="fragment">class xsd__hexBinary
{
 public:
  unsigned char *__ptr;   // points to raw binary data
  int            __size;  // size of data
};
</pre><p>and </p>
<pre class="fragment">class xsd__base64Binary
{
 public:
  unsigned char *__ptr;   // points to raw binary data
  int            __size;  // size of data
};
</pre><p>A class or struct with a binary content layout can be extended to support MIME/MTOM (and older DIME) attachments, such as in xop:Include elements: </p>
<pre class="fragment">//gsoap xop schema import: http://www.w3.org/2004/08/xop/include
class _xop__Include
{
 public:
  unsigned char *__ptr;   // points to raw binary data
  int            __size;  // size of data
  char          *id;      // NULL to generate an id, or set to a unique UUID
  char          *type;    // MIME type of the data
  char          *options; // optional description of MIME attachment
};
</pre><p>Attachments are beyond the scope of this document and we refer to the gSOAP user guide for more details.</p>
<p>A class or struct with the following layout is a complexType with simpleContent wrapper: </p>
<pre class="fragment">class ns__simple
{
 public:
  T   __item;
};
</pre><p>A wrapper class/struct may have any number of attributes declared with <code>@</code>.</p>
<h1><a class="anchor" id="memory"></a>
Memory management                                                      </h1>
<p>Memory management with the <code>soap</code> context enables us to allocate data in context-managed heap space that can be collectively deleted. All deserialized data is placed on the context-managed heap by the gSOAP engine.</p>
<h2><a class="anchor" id="memory1"></a>
Memory management in C                                                </h2>
<p>In C (wsdl2h option <code>-c</code> and soapcpp2 option <code>-c</code>), the gSOAP engine allocates data on a context-managed heap with:</p>
<ul>
<li><code>void *soap_malloc(struct soap*, size_t len)</code>.</li>
</ul>
<p>The <code>soap_malloc</code> function is a wrapper around <code>malloc</code>, but which also allows the <code>struct soap</code> context to track all heap allocations for collective deletion with <code>soap_end(soap)</code>: </p>
<pre class="fragment">#include "soapH.h"
#include "ns.nsmap"
...
struct soap *soap = soap_new();  // new context
...
struct ns__record *record = soap_malloc(soap, sizeof(struct ns__record));
soap_default_ns__record(soap, record);
...
soap_destroy(soap);  // only for C++, see section on C++ below
soap_end(soap);      // delete record and all other heap allocations
soap_free(soap);     // delete context
</pre><p>The soapcpp2 auto-generated deserializers in C use <code>soap_malloc</code> to allocate and populate deserialized structures, which are managed by the context for collective deletion.</p>
<p>To make <code>char*</code> and <code>wchar_t*</code> string copies to the context-managed heap, we can use the functions:</p>
<ul>
<li><code>char *soap_strdup(struct soap*, const char*)</code> and</li>
</ul>
<ul>
<li><code>wchar_t *soap_wstrdup(struct soap*, const wchar_t*)</code>.</li>
</ul>
<p>We use the soapcpp2 auto-generated <code>soap_dup_T</code> functions to duplicate data into another context (this requires soapcpp2 option <code>-Ec</code> to generate), here shown for C with the second argument <code>dst</code> NULL because we want to allocate a new managed structure: </p>
<pre class="fragment">struct soap *other_soap = soap_new();  // another context
struct ns__record *other_record = soap_dup_ns__record(other_soap, NULL, record);
...
soap_destroy(other_soap);  // only for C++, see section on C++ below
soap_end(other_soap);      // delete other_record and all of its deep data
soap_free(other_soap);     // delete context
</pre><p>Note that the only reason to use another context and not to use the primary context is when the primary context must be destroyed together with all of the objects it manages while some of the objects must be kept alive. If the objects that are kept alive contain deep cycles then this is the only option we have, because deep copy with a managing context detects and preserves these cycles unless the <code>SOAP_XML_TREE</code> flag is used with the context: </p>
<pre class="fragment">struct soap *other_soap = soap_new1(SOAP_XML_TREE);  // another context
struct ns__record *other_record = soap_dup_ns__record(other_soap, NULL, record);
</pre><p>The resulting deep copy will be a full copy of the source data structure as a tree without co-referenced data (i.e. no digraph) and without cycles. Cycles are pruned and (one of the) pointers that forms a cycle is repaced by NULL.</p>
<p>We can also deep copy into unmanaged space and use the auto-generated <code>soap_del_T()</code> function (requires soapcpp2 option <code>-Ed</code> to generate) to delete it later, but we MUST NOT do this for any data that we suspect has deep cycles: </p>
<pre class="fragment">struct ns__record *other_record = soap_dup_ns__record(NULL, NULL, record);
...
soap_del_ns__record(other_record);  // deep delete record data members
free(other_record);                 // delete the record
</pre><p>Cycles in the data structure will lead to non-termination when making unmanaged deep copies. Consider for example: </p>
<pre class="fragment">struct ns__record
{
  const char  *name;
  uint64_t     SSN;
  ns__record  *spouse;
};
</pre><p>Our code to populate a structure with a mutual spouse relationship: </p>
<pre class="fragment">struct soap *soap = soap_new();
...
struct ns__record pers1, pers2;
soap_default_ns__record(soap, &amp;pers1);
soap_default_ns__record(soap, &amp;pers2);
pers1.name = "Joe";                     // OK to serialize static data
pers1.SSN = 1234567890;
pers1.spouse = &amp;pers2;
pers2.name = soap_strdup(soap, "Jane"); // allocates and copies a string
pers2.SSN = 1987654320;
pers2.spouse = &amp;pers1;
...
struct ns__record *pers3 = soap_dup_ns__record(NULL, NULL, &amp;pers1);  // BAD
struct ns__record *pers4 = soap_dup_ns__record(soap, NULL, &amp;pers1);  // OK
soap_set_mode(soap, SOAP_XML_TREE);
struct ns__record *pers5 = soap_dup_ns__record(soap, NULL, &amp;pers1);  // OK
</pre><p>As we can see, the gSOAP serializer can serialize any heap, stack, or static allocated data, such as in our code above. So we can serialize the stack-allocated <code>pers1</code> record as follows: </p>
<pre class="fragment">soap-&gt;sendfd = fopen("record.xml", "w");
soap_set_mode(soap, SOAP_XML_GRAPH);  // support id-ref w/o requiring SOAP
soap_clr_mode(soap, SOAP_XML_TREE);   // if set, clear
soap_write_ns__record(soap, &amp;pers1);
fclose(soap-&gt;sendfd);
soap-&gt;sendfd = NULL;
</pre><p>which produces an XML document record.xml that is similar to: </p>
<pre class="fragment">&lt;ns:record xmlns:ns="urn:types" id="Joe"&gt;
  &lt;name&gt;Joe&lt;/name&gt;
  &lt;SSN&gt;1234567890&lt;/SSN&gt;
  &lt;spouse id="Jane"&gt;
    &lt;name&gt;Jane&lt;/name&gt;
    &lt;SSN&gt;1987654320&lt;/SSN&gt;
    &lt;spouse ref="#Joe"/&gt;
  &lt;/spouse&gt;
&lt;/ns:record&gt;
</pre><p>Deserialization of an XML document with a SOAP 1.1/1.2 encoded id-ref graph leads to the same non-termination problem when we later try to copy the data into unmanaged space: </p>
<pre class="fragment">struct soap *soap = soap_new1(SOAP_XML_GRAPH);  // support id-ref w/o SOAP
...
struct ns__record pers1;
soap-&gt;recvfd = fopen("record.xml", "r");
soap_read_ns__record(soap, &amp;pers1);
fclose(soap-&gt;recvfd);
soap-&gt;recvfd = NULL;
...
struct ns__record *pers3 = soap_dup_ns__record(NULL, NULL, &amp;pers1);  // BAD
struct ns__record *pers4 = soap_dup_ns__record(soap, NULL, &amp;pers1);  // OK
soap_set_mode(soap, SOAP_XML_TREE);
struct ns__record *pers5 = soap_dup_ns__record(soap, NULL, &amp;pers1);  // OK
</pre><p>Copying data with <code>soap_dup_T(soap)</code> into managed space is always safe. Copying into unmanaged space requires diligence. But deleting unmanaged data is easy with <code>soap_del_T()</code>.</p>
<p>We can also use <code>soap_del_T()</code> to delete structures that we created in C, but only if these structures are created with <code>malloc</code> and do NOT contain pointers to stack and static data.</p>
<h2><a class="anchor" id="memory2"></a>
Memory management in C++                                              </h2>
<p>In C++, the gSOAP engine allocates data on a managed heap using a combination of <code>void *soap_malloc(struct soap*, size_t len)</code> and <code>soap_new_T()</code>, where <code>T</code> is the name of a class, struct, or class template (container or smart pointer). Heap allocation is tracked by the <code>struct soap</code> context for collective deletion with <code>soap_destroy(soap)</code> and <code>soap_end(soap)</code>.</p>
<p>Only structs, classes, and class templates are allocated with <code>new</code> via <code>soap_new_T(struct soap*)</code> and mass-deleted with <code>soap_destroy(soap)</code>.</p>
<p>There are four variations of <code>soap_new_T</code> for class/struct/template type <code>T</code> that soapcpp2 auto-generates to create instances on a context-managed heap:</p>
<ul>
<li><code>T * soap_new_T(struct soap*)</code> returns a new instance of <code>T</code> with default data member initializations that are set with the soapcpp2 auto-generated <code>void T::soap_default(struct soap*)</code> method), but ONLY IF the soapcpp2 auto-generated default constructor is used that invokes <code>soap_default()</code> and was not replaced by a user-defined default constructor.</li>
</ul>
<ul>
<li><code>T * soap_new_T(struct soap*, int n)</code> returns an array of <code>n</code> new instances of <code>T</code>. Similar to the above, instances are initialized.</li>
</ul>
<ul>
<li><code>T * soap_new_req_T(struct soap*, ...)</code> returns a new instance of <code>T</code> and sets the required data members to the values specified in <code>...</code>. The required data members are those with minOccurs &gt; 0, see the subsection on occurrence constraints in <a href="#toxsd9">Classes and structs</a>.</li>
</ul>
<ul>
<li><code>T * soap_new_set_T(struct soap*, ...)</code> returns a new instance of <code>T</code> and sets the public/serializable data members to the values specified in <code>...</code>.</li>
</ul>
<p>The above functions can be invoked with a NULL <code>soap</code> context, but we will be responsible to use <code>delete T</code> to remove this instance from the unmanaged heap.</p>
<p>Primitive types and arrays of these are allocated with <code>soap_malloc</code> by the gSOAP engine. As we stated above, all types except for classes, structs, class templates (containers and smart pointers) are allocated with <code>soap_malloc</code> for reasons of efficiency.</p>
<p>We can use a C++ template to simplify the managed allocation and initialization of primitive values as follows (this is for primitive types only, because we should allocate structs and classes with <code>soap_new_T</code>): </p>
<pre class="fragment">template&lt;class T&gt;
T * soap_make(struct soap *soap, T val)
{
  T *p = (T*)soap_malloc(soap, sizeof(T));
  if (p)
    *p = val;
  return p;
}
</pre><p>For example, assuming we have the following class: </p>
<pre class="fragment">class ns__record
{
 public:
  std::string  name;    // required name
  uint64_t    *SSN;     // optional SSN
  ns__record  *spouse;  // optional spouse
};
</pre><p>We can instantiate a record by using the auto-generated <code>soap_new_set_ns__record</code> and our <code>soap_make</code> to create a SSN value on the managed heap: </p>
<pre class="fragment">soap *soap = soap_new();  // new context
...
ns__record *record = soap_new_set_ns__record(
    soap,
    "Joe",
    soap_make&lt;uint64_t&gt;(soap, 1234567890),
    NULL);
...
soap_destroy(soap);  // delete record and all other managed instances
soap_end(soap);      // delete managed soap_malloc'ed heap data
soap_free(soap);     // delete context
</pre><p>Note however that the gSOAP serializer can serialize any heap, stack, or static allocated data. So we can also create a new record as follows: </p>
<pre class="fragment">uint64_t SSN = 1234567890;
ns__record *record = soap_new_set_ns__record(soap, "Joe", &amp;SSN, NULL);
</pre><p>which will be fine to serialize this record as long as the local <code>SSN</code> stack-allocated value remains in scope when invoking the serializer and/or using <code>record</code>. It does not matter if <code>soap_destroy</code> and <code>soap_end</code> are called beyond the scope of <code>SSN</code>.</p>
<p>To facilitate our class methods to access the managing context, we can add a soap context pointer to a class/struct: </p>
<pre class="fragment">class ns__record
{
  ...
  void create_more();  // needs a context to create more internal data
 protected:
  struct soap *soap;   // the context that manages this instance, or NULL
};
</pre><p>The context is set when invoking <code>soap_new_T</code> (and similar) with a non-NULL context argument.</p>
<p>We use the soapcpp2 auto-generated <code>soap_dup_T</code> functions to duplicate data into another context (this requires soapcpp2 option <code>-Ec</code> to generate), here shown for C++ with the second argument <code>dst</code> NULL because we want to allocate a new managed object: </p>
<pre class="fragment">soap *other_soap = soap_new();  // another context
ns__record *other_record = soap_dup_ns__record(other_soap, NULL, record);
...
soap_destroy(other_soap);  // delete record and other managed instances
soap_end(other_soap);      // delete other data (the SSNs on the heap)
soap_free(other_soap);     // delete context
</pre><p>To duplicate base and derived instances when a base class pointer or reference is provided, use the auto-generated method <code>T * T::soap_dup(struct soap*)</code>: </p>
<pre class="fragment">soap *other_soap = soap_new();  // another context
ns__record *other_record = record-&gt;soap_dup(other_soap);
...
soap_destroy(other_soap);  // delete record and other managed instances
soap_end(other_soap);      // delete other data (the SSNs on the heap)
soap_free(other_soap);     // delete context
</pre><p>Note that the only reason to use another context and not to use the primary context is when the primary context must be destroyed together with all of the objects it manages while some of the objects must be kept alive. If the objects that are kept alive contain deep cycles then this is the only option we have, because deep copy with a managing context detects and preserves these cycles unless the <code>SOAP_XML_TREE</code> flag is used with the context: </p>
<pre class="fragment">soap *other_soap = soap_new1(SOAP_XML_TREE);  // another context
ns__record *other_record = record-&gt;soap_dup(other_soap);  // deep tree copy
</pre><p>The resulting deep copy will be a full copy of the source data structure as a tree without co-referenced data (i.e. no digraph) and without cycles. Cycles are pruned and (one of the) pointers that forms a cycle is repaced by NULL.</p>
<p>We can also deep copy into unmanaged space and use the auto-generated <code>soap_del_T()</code> function or the <code>T::soap_del()</code> method (requires soapcpp2 option <code>-Ed</code> to generate) to delete it later, but we MUST NOT do this for any data that we suspect has deep cycles: </p>
<pre class="fragment">ns__record *other_record = record-&gt;soap_dup(NULL);
...
other_record-&gt;soap_del();  // deep delete record data members
delete other_record;       // delete the record
</pre><p>Cycles in the data structure will lead to non-termination when making unmanaged deep copies. Consider for example: </p>
<pre class="fragment">class ns__record
{
  const char  *name;
  uint64_t     SSN;
  ns__record  *spouse;
};
</pre><p>Our code to populate a structure with a mutual spouse relationship: </p>
<pre class="fragment">soap *soap = soap_new();
...
ns__record pers1, pers2;
pers1.name = "Joe";
pers1.SSN = 1234567890;
pers1.spouse = &amp;pers2;
pers2.name = "Jane";
pers2.SSN = 1987654320;
pers2.spouse = &amp;pers1;
...
ns__record *pers3 = soap_dup_ns__record(NULL, NULL, &amp;pers1);  // BAD
ns__record *pers4 = soap_dup_ns__record(soap, NULL, &amp;pers1);  // OK
soap_set_mode(soap, SOAP_XML_TREE);
ns__record *pers5 = soap_dup_ns__record(soap, NULL, &amp;pers1);  // OK
</pre><p>Note that the gSOAP serializer can serialize any heap, stack, or static allocated data, such as in our code above. So we can serialize the stack-allocated <code>pers1</code> record as follows: </p>
<pre class="fragment">soap-&gt;sendfd = fopen("record.xml", "w");
soap_set_mode(soap, SOAP_XML_GRAPH);  // support id-ref w/o requiring SOAP
soap_clr_mode(soap, SOAP_XML_TREE);   // if set, clear
soap_write_ns__record(soap, &amp;pers1);
fclose(soap-&gt;sendfd);
soap-&gt;sendfd = NULL;
</pre><p>which produces an XML document record.xml that is similar to: </p>
<pre class="fragment">&lt;ns:record xmlns:ns="urn:types" id="Joe"&gt;
  &lt;name&gt;Joe&lt;/name&gt;
  &lt;SSN&gt;1234567890&lt;/SSN&gt;
  &lt;spouse id="Jane"&gt;
    &lt;name&gt;Jane&lt;/name&gt;
    &lt;SSN&gt;1987654320&lt;/SSN&gt;
    &lt;spouse ref="#Joe"/&gt;
  &lt;/spouse&gt;
&lt;/ns:record&gt;
</pre><p>Deserialization of an XML document with a SOAP 1.1/1.2 encoded id-ref graph leads to the same non-termination problem when we later try to copy the data into unmanaged space: </p>
<pre class="fragment">soap *soap = soap_new1(SOAP_XML_GRAPH);  // support id-ref w/o SOAP
...
ns__record pers1;
soap-&gt;recvfd = fopen("record.xml", "r");
soap_read_ns__record(soap, &amp;pers1);
fclose(soap-&gt;recvfd);
soap-&gt;recvfd = NULL;
...
ns__record *pers3 = soap_dup_ns__record(NULL, NULL, &amp;pers1);  // BAD
ns__record *pers4 = soap_dup_ns__record(soap, NULL, &amp;pers1);  // OK
soap_set_mode(soap, SOAP_XML_TREE);
ns__record *pers5 = soap_dup_ns__record(soap, NULL, &amp;pers1);  // OK
</pre><p>Copying data with <code>soap_dup_T(soap)</code> into managed space is always safe. Copying into unmanaged space requires diligence. But deleting unmanaged data is easy with <code>soap_del_T()</code>.</p>
<p>We can also use <code>soap_del_T()</code> to delete structures in C++, but only if these structures are created with <code>new</code> (and <code>new []</code> for arrays when applicable) for classes, structs, and class templates and with <code>malloc</code> for anything else, and the structures do NOT contain pointers to stack and static data.</p>
<h1><a class="anchor" id="features"></a>
Features and limitations                                             </h1>
<p>There are several context initialization flags and mode flags to control XML serialization at runtime:</p>
<ul>
<li><code>SOAP_XML_STRICT</code>: strictly validates XML while deserializing. Should not be used together with SOAP 1.1/1.2 encoding style of messaging.</li>
</ul>
<ul>
<li><code>SOAP_XML_INDENT</code>: produces indented XML.</li>
</ul>
<ul>
<li><code>SOAP_XML_CANONICAL</code>: c14n canonocalization, removes unnecessary <code>xmlns</code> bindings and adds them to appropriate places by applying c14n normalization rules. Should not be used together with SOAP 1.1/1.2 encoding style of messaging.</li>
</ul>
<ul>
<li><code>SOAP_XML_TREE</code>: write tree XML without id-ref, pruning data structure cycles to prevent nontermination.</li>
</ul>
<ul>
<li><code>SOAP_XML_GRAPH</code>: write graph (digraph and cyclic graphs with shared pointers to objects) using id-ref attributes. That is, XML with SOAP multi-ref encoded id-ref elements. This is a structure-preserving serialization format, because co-referenced data and also cyclic relations are accurately represented.</li>
</ul>
<ul>
<li><code>SOAP_XML_DEFAULTNS</code>: uses xmlns default bindings, assuming that the schema element form is "qualified" by default (be warned if it is not!).</li>
</ul>
<ul>
<li><code>SOAP_XML_NOTYPE</code>: removes all xsi:type attribuation. This may affect the quality of the deserializer, which relies on xsi:type attributes to distinguish base class instances from derived class instanced.</li>
</ul>
<ul>
<li><code>SOAP_C_UTFSTRING</code>: enables all <code>std::string</code> and <code>char*</code> strings to contain UTF-8 content.</li>
</ul>
<p>Additional notes with respect to the wsdl2h and soapcpp2 tools:</p>
<ul>
<li>Nested classes, structs, and typedefs in a gSOAP header file are unnested by soapcpp2.</li>
</ul>
<ul>
<li>Use <code>#import "file.h"</code> instead of <code>#include</code> to import other header files in a gSOAP header file for soapcpp2. The <code>#include</code> and <code>#define</code> directives are accepted, but deferred to the generated code.</li>
</ul>
<ul>
<li>To remove any SOAP-specific bindings, use soapcpp2 option <code>-0</code>.</li>
</ul>
<ul>
<li>A gSOAP header file for soapcpp2 should not include any code statements, only data type declarations.</li>
</ul>
<ul>
<li>C++ namespaces are supported, use wsdl2h option <code>-qname</code>. Or add a <code>namespace name { ... }</code> to the header file, but the <code>{ ... }</code> MUST cover the entire header file content from begin to end.</li>
</ul>
<ul>
<li>Optional DOM support can be used to store mixed content or literal XML content. Otherwise, mixed content may be lost. Use wsdl2h option <code>-d</code> for DOM support and compile and link with <code>dom.c</code> or <code>dom.cpp</code>.</li>
</ul>
<h1><a class="anchor" id="nsmap"></a>
Removing SOAP namespaces from XML payloads                              </h1>
<p>The soapcpp2 tool generates a <code>.nsmap</code> file that includes two bindings for SOAP namespaces. We can remove all SOAP namespaces (and SOAP processing logic) with soapcpp2 option <code>-0</code> or by simply setting the two entries to NULL: </p>
<pre class="fragment">SOAP_NMAC struct Namespace namespaces[] =
{
  {"SOAP-ENV", NULL, NULL, NULL},
  {"SOAP-ENC", NULL, NULL, NULL},
  ...
</pre><p>Note that once the <code>.nsmap</code> is generated, we can copy-paste the content into our project code. However, if we rerun wsdl2h on updated WSDL/XSD files or <code>typemap.dat</code> declarations then we need to use the updated table.</p>
<h1><a class="anchor" id="examples"></a>
Examples                                                             </h1>
<p>Select the project files below to peruse the source code examples.</p>
<h2>Source files</h2>
<ul>
<li><code>address.xsd</code> Address book schema</li>
<li><code><a class="el" href="address_8cpp.html">address.cpp</a></code> Address book app (reads/writes address.xml file)</li>
<li><code>addresstypemap.dat</code> Schema namespace prefix name preference for wsdl2h</li>
<li><code><a class="el" href="graph_8h.html">graph.h</a></code> <a class="el" href="class_graph.html">Graph</a> data binding (tree, digraph, cyclic graph)</li>
<li><code><a class="el" href="graph_8cpp.html">graph.cpp</a></code> Test graph serialization as tree, digraph, and cyclic</li>
</ul>
<h2>Generated files</h2>
<ul>
<li><code><a class="el" href="address_8h.html">address.h</a></code> gSOAP-specific data binding definitions from address.xsd</li>
<li><code><a class="el" href="address_stub_8h.html">addressStub.h</a></code> C++ data binding definitions</li>
<li><code><a class="el" href="address_h_8h.html">addressH.h</a></code> Serializers</li>
<li><code>addressC.cpp</code> Serializers</li>
<li><code>address.xml</code> Address book data generated by address app</li>
<li><code><a class="el" href="graph_stub_8h.html">graphStub.h</a></code> C++ data binding definitions</li>
<li><code><a class="el" href="graph_h_8h.html">graphH.h</a></code> Serializers</li>
<li><code>graphC.cpp</code> Serializers</li>
<li><code>g.xsd</code> XSD schema with <code>g:<a class="el" href="class_graph.html">Graph</a></code> complexType</li>
<li><code>g.nsmap</code> xmlns bindings namespace mapping table</li>
</ul>
<h2>Build steps</h2>
<p>Building the AddressBook example: </p>
<pre class="fragment">wsdl2h -g -t addresstypemap.dat address.xsd
soapcpp2 -0 -CS -I../../import -p address address.h
c++ -I../.. address.cpp addressC.cpp -o address -lgsoap++
</pre><p>Building the graph serialization example: </p>
<pre class="fragment">soapcpp2 -CS -I../../import -p graph graph.h
c++ -I../.. graph.cpp graphC.cpp -o graph -lgsoap++
</pre><p>To compile without using the <code>libgsoap++</code> library: simply compile <code>stdsoap2.cpp</code> together with the above.</p>
<h2>Usage</h2>
<p>To execute the AddressBook example: </p>
<pre class="fragment">./address
</pre><p>To execute the <a class="el" href="class_graph.html">Graph</a> serialization example: </p>
<pre class="fragment">./graph</pre> </div></div><!-- contents -->
</div><!-- doc-content -->
<hr class="footer"><address class="footer"><small>
Generated on Sun Oct 25 2015 21:44:35 for <a href="http://www.genivia.com">Genivia</a> documentation of Data Bindings by <a target="_blank" href="http://www.doxygen.org/index.html">Doxygen</a> 1.8.3</small></address>
</body>
</html>
