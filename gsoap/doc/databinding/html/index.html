<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8">
<meta http-equiv="cache-control" content="no-cache">
<title>Genivia - C and C++ XML Data Bindings</title>
<link href="genivia_tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="genivia_content.css" rel="stylesheet" type="text/css">
</head>
<body>
<div id="top">
 <div id="titlearea">
  <table height="72px" width="100%" cellspacing="0" cellpadding="0">
   <tbody>
    <tr>
     <td width="10%">&nbsp;</td>
     <td width="175px"><a href="https://www.genivia.com"><img alt="Genivia" src="GeniviaLogo2_trans_noslogan.png"/></a></td>
     <td class="tab_home"><a href="https://www.genivia.com">Home</a></td>
     <td class="tab_home"><a href="https://www.genivia.com/docs.html">Documentation</a></td>
     <td>
      <div style="float: right; font-size: 18px; font-weight: bold;">C and C++ XML Data Bindings</div>
      <br>
      <div style="float: right; font-size: 10px;">updated Tue Aug 22 2017 by Robert van Engelen</div>
     </td>
     <td width="10%">&nbsp;</td>
    </tr>
   </tbody>
  </table>
 </div>
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">C and C++ XML Data Bindings </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#intro">Introduction                                                            </a></li>
<li class="level1"><a href="#tocpp">Mapping WSDL and XML schemas to C/C++                                   </a></li>
<li class="level1"><a href="#typemap">Using typemap.dat to customize data bindings                          </a><ul><li class="level2"><a href="#typemap1">XML namespace bindings                                               </a></li>
<li class="level2"><a href="#typemap2">XSD type bindings                                                    </a></li>
<li class="level2"><a href="#custom">Custom serializers for XSD types                                       </a><ul><li class="level3"><a href="#custom-1">xsd:integer</a></li>
<li class="level3"><a href="#custom-2">xsd:decimal</a></li>
<li class="level3"><a href="#custom-3">xsd:dateTime</a></li>
<li class="level3"><a href="#custom-4">xsd:date</a></li>
<li class="level3"><a href="#custom-5">xsd:time</a></li>
<li class="level3"><a href="#custom-6">xsd:duration</a></li>
</ul>
</li>
<li class="level2"><a href="#qt">Custom Qt serializers for XSD types                                        </a><ul><li class="level3"><a href="#qt-1">xsd:string</a></li>
<li class="level3"><a href="#qt-2">xsd:base64Binary</a></li>
<li class="level3"><a href="#qt-3">xsd:hexBinary</a></li>
<li class="level3"><a href="#qt-4">xsd:dateTime</a></li>
<li class="level3"><a href="#qt-5">xsd:date</a></li>
<li class="level3"><a href="#qt-6">xsd:time</a></li>
</ul>
</li>
<li class="level2"><a href="#typemap3">Class/struct member additions                                        </a></li>
<li class="level2"><a href="#typemap4">Replacing XSD types by equivalent alternatives                       </a></li>
<li class="level2"><a href="#typemap5">The built-in typemap.dat variables $CONTAINER and $POINTER           </a></li>
<li class="level2"><a href="#typemap6">User-defined content                                                 </a></li>
</ul>
</li>
<li class="level1"><a href="#toxsd">Mapping C/C++ to XML schema                                             </a><ul><li class="level2"><a href="#toxsd1">Overview of serializable C/C++ types                                   </a></li>
<li class="level2"><a href="#toxsd2">Colon notation versus name prefixing with XML tag name translation     </a></li>
<li class="level2"><a href="#toxsd3">C++ Bool and C alternatives                                            </a></li>
<li class="level2"><a href="#toxsd4">Enumerations and bitmasks                                              </a></li>
<li class="level2"><a href="#toxsd5">Numerical types                                                        </a></li>
<li class="level2"><a href="#toxsd6">String types                                                           </a></li>
<li class="level2"><a href="#toxsd7">Date and time types                                                    </a></li>
<li class="level2"><a href="#toxsd8">Time duration types                                                    </a></li>
<li class="level2"><a href="#toxsd9">Classes and structs                                                    </a><ul><li class="level3"><a href="#toxsd9-1">Serializable versus transient types and data members</a></li>
<li class="level3"><a href="#toxsd9-2">Volatile classes and structs</a></li>
<li class="level3"><a href="#toxsd9-3">Mutable classes and structs</a></li>
<li class="level3"><a href="#toxsd9-4">Default and fixed member values</a></li>
<li class="level3"><a href="#toxsd9-5">Attribute members and backtick XML tags</a></li>
<li class="level3"><a href="#toxsd9-6">Qualified and unqualified members</a></li>
<li class="level3"><a href="#toxsd9-7">Defining document root elements</a></li>
<li class="level3"><a href="#toxsd9-8">(Smart) pointer members and their occurrence constraints</a></li>
<li class="level3"><a href="#toxsd9-9">Container and array members and their occurrence constraints</a></li>
<li class="level3"><a href="#toxsd9-10">Sequencing with hidden members</a></li>
<li class="level3"><a href="#toxsd9-11">Tagged union members</a></li>
<li class="level3"><a href="#toxsd9-12">Tagged void pointer members</a></li>
<li class="level3"><a href="#toxsd9-13">Adding get and set methods</a></li>
<li class="level3"><a href="#toxsd9-14">Operations on classes and structs</a></li>
</ul>
</li>
<li class="level2"><a href="#toxsd10">Special classes and structs                                           </a><ul><li class="level3"><a href="#toxsd10-1">SOAP encoded arrays</a></li>
<li class="level3"><a href="#toxsd10-2">XSD hexBinary and base64Binary types</a></li>
<li class="level3"><a href="#toxsd10-3">MIME/MTOM attachment binary types</a></li>
<li class="level3"><a href="#toxsd10-4">Wrapper class/struct with simpleContent</a></li>
<li class="level3"><a href="#toxsd10-5">DOM anyType and anyAttribute</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#directives">Directives                                                         </a><ul><li class="level2"><a href="#directives-1">Service directives                                               </a></li>
<li class="level2"><a href="#directives-2">Service method directives                                        </a></li>
<li class="level2"><a href="#directives-3">Schema directives                                                </a></li>
<li class="level2"><a href="#directives-4">Schema type directives                                           </a></li>
</ul>
</li>
<li class="level1"><a href="#rules">Serialization rules                                                     </a><ul><li class="level2"><a href="#doc-rpc">SOAP document versus rpc style                                        </a></li>
<li class="level2"><a href="#lit-enc">SOAP literal versus encoding                                          </a></li>
<li class="level2"><a href="#soap">SOAP 1.1 versus SOAP 1.2                                                 </a></li>
<li class="level2"><a href="#non-soap">Non-SOAP XML serialization                                           </a></li>
</ul>
</li>
<li class="level1"><a href="#io">Input and output                                                           </a><ul><li class="level2"><a href="#io1">Reading and writing from/to files and streams                             </a></li>
<li class="level2"><a href="#io2">Reading and writing from/to string buffers                                </a></li>
</ul>
</li>
<li class="level1"><a href="#memory">Memory management                                                      </a><ul><li class="level2"><a href="#memory1">Memory management in C                                                </a></li>
<li class="level2"><a href="#memory2">Memory management in C++                                              </a></li>
</ul>
</li>
<li class="level1"><a href="#flags">Context flags to initialize the soap struct                             </a></li>
<li class="level1"><a href="#params">Context parameter settings                                             </a></li>
<li class="level1"><a href="#errors">Error handling and reporting                                           </a></li>
<li class="level1"><a href="#features">Features and limitations                                             </a></li>
<li class="level1"><a href="#nsmap">Removing SOAP namespaces from XML payloads                              </a></li>
<li class="level1"><a href="#examples">Examples                                                             </a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="intro"></a>
Introduction                                                            </h1>
<p>This article presents a detailed overview of the gSOAP XML data bindings for C and C++. The XML data bindings for C and C++ are extensively used with gSOAP Web services to serialize C and C++ data in XML as part of the SOAP/XML Web services payloads. Also REST XML with gSOAP relies on XML serialization of C and C++ data via XML data bindings.</p>
<p>The major advantage of XML data bindings is that your application data is always <b>type safe</b> in C and C++ by binding XML schema types to C/C++ types. So integers in XML are bound to C integers, strings in XML are bound to C or C++ strings, complex types in XML are bound to C structs or C++ classes, and so on. The structured data you create and accept will fit the data model and is <b>static type safe</b>. In other words, by leveraging strong typing in C/C++, your XML data meets <b>XML schema validation requirements</b> and satisfies <b>XML interoperability requirements</b>.</p>
<p>In fact, gSOAP data bindings are more powerful than simply representing C/C++ data in XML. The gSOAP tools implement true and tested <b>structure-preserving serialization</b> of C/C++ data in XML, including the serialization of cyclic graph structures with id-ref XML attributes. The gSOAP tools also generate routines for deep copying and deep deletion of C/C++ data structures to simplify memory management. In addition, C/C++ structures are deserialized into managed memory, managed by the gSOAP <code>soap</code> context.</p>
<p>At the end of this article two examples are given to illustrate the application of XML data bindings. The first simple example <code><a class="el" href="address_8cpp.html">address.cpp</a></code> shows how to use wsdl2h to bind an XML schema to C++. The C++ application reads and writes an XML file into and from a C++ "address book" data structure as a simple example. The C++ data structure is an STL vector of address objects. The second example <code><a class="el" href="graph_8cpp.html">graph.cpp</a></code> shows how C++ data can be accurately serialized as a tree, digraph, and cyclic graph in XML. The digraph and cyclic graph serialization rules implement SOAP 1.1/1.2 multi-ref encoding with id-ref attributes to link elements through IDREF XML references, creating a an XML graph with pointers to XML nodes that preserves the structural integrity of the serialized C++ data.</p>
<p>These examples demonstrate XML data bindings only for relatively simple data structures and types. The gSOAP tools support more than just these type of structures to serialize in XML. There are practically no limits to the serialization of C and C++ data types in XML.</p>
<p>Also the support for XML schema (XSD) components is unlimited. The wsdl2h tool maps schemas to C and C++ using built-in intuitive mapping rules, while allowing the mappings to be customized using a <code>typemap.dat</code> file with mapping instructions for wsdl2h.</p>
<p>The information in this article is applicable to gSOAP 2.8.26 and later versions that support C++11 features. However, C++11 is not required. The material and the examples in this article use plain C and C++, until the point where we introduce C++11 smart pointers and scoped enumerations. While most of the examples in this article are given in C++, the concepts also apply to C with the exception of containers, smart pointers, classes and their methods. None of these exceptions limit the use of the gSOAP tools for C in any way.</p>
<p>The data binding concepts described in this article were first envisioned in 1999 by Prof. Robert van Engelen at the Florida State University. An implementation was created in 2000, named "stub/skeleton compiler". The first articles on its successor version "gSOAP" appeared in 2002. The principle of mapping XSD components to C/C++ types and vice versa is now widely adopted in systems and programming languages, including Java web services and by C# WCF.</p>
<p>We continue to be committed to our goal to empower C/C++ developers with powerful autocoding tools for XML. Our commitment started in the very early days of SOAP by actively participating in <a href="http://www.whitemesa.com/interop.htm">SOAP interoperability testing</a>, participating in the development and testing of the <a href="http://www.w3.org/2002/ws/databinding">W3C XML Schema Patterns for Databinding Interoperability</a>, and continues by contributing to the development of <a href="https://www.oasis-open.org">OASIS open standards</a> in partnership with leading IT companies in the world.</p>
<p>üîù <a href="#">Back to table of contents</a></p>
<h1><a class="anchor" id="tocpp"></a>
Mapping WSDL and XML schemas to C/C++                                   </h1>
<p>To convert WSDL and XML schemas (XSD files) to code, we use the wsdl2h command on the command line (or command prompt), after opening a terminal. The wsdl2h command generates the data binding interface code that is saved to a special gSOAP header file with extension <code>.h</code> that contains the WSDL service declarations and the data binding interface declarations in a familiar C/C++ format: </p><pre class="fragment">wsdl2h [options] -o file.h ... XSD and WSDL files ...
</pre><p>This command converts WSDL and XSD files to C++ (or pure C with wsdl2h option <code>-c</code>) and saves the data binding interface to a gSOAP header file <code>file.h</code> that uses familiar C/C++ syntax extended with <code>//gsoap</code> <a href="#directives">directives</a> and annotations. Notational conventions are used in the data binding interface to declare serializable C/C++ types and functions for Web service operations.</p>
<p>The WSDL 1.1/2.0, SOAP 1.1/1.2, and XSD 1.0/1.1 standards are supported by the gSOAP tools. In addition, the most popular WS specifications are also supported, including WS-Addressing, WS-ReliableMessaging, WS-Discovery, WS-Security, WS-Policy, WS-SecurityPolicy, and WS-SecureConversation.</p>
<p>This article focusses mainly on XML data bindings. XML data bindings for C/C++ bind XML schema types to C/C++ types. So integers in XML are bound to C integers, strings in XML are bound to C or C++ strings, complex types in XML are bound to C structs or C++ classes, and so on.</p>
<p>A data binding is dual, meaning supporting a two way direction for development. Either you start with WSDLs and/or XML schemas that are mapped to equivalent C/C++ types, or you start with C/C++ types that are mapped to XSD types. Either way, the end result is that you can serialize C/C++ types in XML such that your XML is an instance of XML schema(s) and is validated against these schema(s).</p>
<p>This covers all of the following standard XSD components with their optional attributes and properties:</p>
<table class="doxtable">
<tr>
<th>XSD component </th><th>attributes and properties  </th></tr>
<tr>
<td>schema </td><td>targetNamespace, version, elementFormDefault, attributeFormDefault, defaultAttributes </td></tr>
<tr>
<td>attribute </td><td>name, ref, type, use, default, fixed, form, targetNamespace, wsdl:arrayType </td></tr>
<tr>
<td>element </td><td>name, ref, type, default, fixed, form, nillable, abstract, substitutionGroup, minOccurs, maxOccurs, targetNamespace </td></tr>
<tr>
<td>simpleType </td><td>name </td></tr>
<tr>
<td>complexType </td><td>name, abstract, mixed, defaultAttributesApply </td></tr>
<tr>
<td>all </td><td><em>n/a</em> </td></tr>
<tr>
<td>choice </td><td>minOccurs, maxOccurs </td></tr>
<tr>
<td>sequence </td><td>minOccurs, maxOccurs </td></tr>
<tr>
<td>group </td><td>name, ref, minOccurs, maxOccurs </td></tr>
<tr>
<td>attributeGroup </td><td>name, ref </td></tr>
<tr>
<td>any </td><td>minOccurs, maxOccurs </td></tr>
<tr>
<td>anyAttribute </td><td><em>n/a</em> </td></tr>
</table>
<p>And also the following standard XSD directives are covered:</p>
<table class="doxtable">
<tr>
<th>directive </th><th>description  </th></tr>
<tr>
<td>import </td><td>Imports a schema into the importing schema for referencing </td></tr>
<tr>
<td>include </td><td>Include schema component definitions into a schema </td></tr>
<tr>
<td>override </td><td>Override by replacing schema component definitions </td></tr>
<tr>
<td>redefine </td><td>Extend or restrict schema component definitions </td></tr>
<tr>
<td>annotation </td><td>Annotates a component </td></tr>
</table>
<p>The XSD facets and their mappings to C/C++ are:</p>
<table class="doxtable">
<tr>
<th>XSD facet </th><th>maps to  </th></tr>
<tr>
<td>enumeration </td><td><code>enum</code> </td></tr>
<tr>
<td>simpleContent </td><td>class/struct wrapper with <code>__item</code> member </td></tr>
<tr>
<td>complexContent </td><td>class/struct </td></tr>
<tr>
<td>list </td><td><code>enum*</code> bitmask (<code>enum*</code> enumerates a bitmask up to 64 bits) </td></tr>
<tr>
<td>extension </td><td>class/struct inheritance/extension </td></tr>
<tr>
<td>restriction </td><td><code>typedef</code> and class/struct inheritance/redeclaration </td></tr>
<tr>
<td>length </td><td><code>typedef</code> with restricted content length annotation </td></tr>
<tr>
<td>minLength </td><td><code>typedef</code> with restricted content length annotation </td></tr>
<tr>
<td>maxLength </td><td><code>typedef</code> with restricted content length annotation </td></tr>
<tr>
<td>minInclusive </td><td><code>typedef</code> with numerical value range restriction annotation </td></tr>
<tr>
<td>maxInclusive </td><td><code>typedef</code> with numerical value range restriction annotation </td></tr>
<tr>
<td>minExclusive </td><td><code>typedef</code> with numerical value range restriction annotation </td></tr>
<tr>
<td>maxExclusive </td><td><code>typedef</code> with numerical value range restriction annotation </td></tr>
<tr>
<td>precision </td><td><code>typedef</code> with pattern annotation (pattern used for output, but input is not validated) </td></tr>
<tr>
<td>scale </td><td><code>typedef</code> with pattern annotation (pattern used for output, but input is not validated) </td></tr>
<tr>
<td>totalDigits </td><td><code>typedef</code> with pattern annotation (pattern used for output, but input is not validated) </td></tr>
<tr>
<td>fractionDigits </td><td><code>typedef</code> with pattern annotation (pattern used for output, but input is not validated) </td></tr>
<tr>
<td>pattern </td><td><code>typedef</code> with pattern annotation (define <code>soap::fsvalidate</code> callback to validate patterns) </td></tr>
<tr>
<td>union </td><td>string with union of value </td></tr>
</table>
<p>All primitive XSD types are supported, including but not limited to the following XSD types:</p>
<table class="doxtable">
<tr>
<th>XSD type </th><th>maps to  </th></tr>
<tr>
<td>any/anyType </td><td><code>_XML</code> string with literal XML content (or enable DOM with wsdl2h option <code>-d</code>) </td></tr>
<tr>
<td>anyURI </td><td>string (i.e. <code>char*</code>, <code>wchar_t*</code>, <code>std::string</code>, <code>std::wstring</code>) </td></tr>
<tr>
<td>string </td><td>string (i.e. <code>char*</code>, <code>wchar_t*</code>, <code>std::string</code>, <code>std::wstring</code>) </td></tr>
<tr>
<td>boolean </td><td><code>bool</code> (C++) or <code>enum xsd__boolean</code> (C) </td></tr>
<tr>
<td>byte </td><td><code>char</code> (i.e. <code>int8_t</code>) </td></tr>
<tr>
<td>short </td><td><code>short</code> (i.e. <code>int16_t</code>) </td></tr>
<tr>
<td>int </td><td><code>int</code> (i.e. <code>int32_t</code>) </td></tr>
<tr>
<td>long </td><td><code>LONG64</code> (i.e. <code>long long</code> and <code>int64_t</code>) </td></tr>
<tr>
<td>unsignedByte </td><td><code>unsigned char</code> (i.e. <code>uint8_t</code>) </td></tr>
<tr>
<td>unsignedShort </td><td><code>unsigned short</code> (i.e. <code>uint16_t</code>) </td></tr>
<tr>
<td>unsignedInt </td><td><code>unsigned int</code> (i.e. <code>uint32_t</code>) </td></tr>
<tr>
<td>unsignedLong </td><td><code>ULONG64</code> (i.e. <code>unsigned long long</code> and <code>uint64_t</code>) </td></tr>
<tr>
<td>float </td><td><code>float</code> </td></tr>
<tr>
<td>double </td><td><code>double</code> </td></tr>
<tr>
<td>integer </td><td>string or <code>#import "custom/int128.h"</code> to use 128 bit <code>xsd__integer</code> </td></tr>
<tr>
<td>decimal </td><td>string or <code>#import "custom/long_double.h"</code> to use <code>long double</code> </td></tr>
<tr>
<td>precisionDecimal </td><td>string </td></tr>
<tr>
<td>duration </td><td>string or <code>#import "custom/duration.h"</code> to use 64 bit <code>xsd__duration</code> </td></tr>
<tr>
<td>dateTime </td><td><code>time_t</code> or <code>#import "custom/struct_tm.h"</code> to use <code>struct tm</code> for <code>xsd__dateTime</code> </td></tr>
<tr>
<td>time </td><td>string or <code>#import "custom/long_time.h"</code> to use 64 bit <code>xsd__time</code> </td></tr>
<tr>
<td>date </td><td>string or <code>#import "custom/struct_tm_date.h"</code> to use <code>struct tm</code> for <code>xsd__date</code> </td></tr>
<tr>
<td>hexBinary </td><td>special class/struct <code>xsd__hexBinary</code> </td></tr>
<tr>
<td>base64Bianry </td><td>special class/struct <code>xsd__base64Binary</code> </td></tr>
<tr>
<td>QName </td><td><code>_QName</code> string (URI normalization rules are applied) </td></tr>
</table>
<p>All other primitive XSD types not listed above are mapped to strings, by wsdl2h generating a typedef to string for these types. For example, <code>xsd:token</code> is bound to a C++ or C string:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> std::string  xsd__token; <span class="comment">// C++</span></div><div class="line"><span class="keyword">typedef</span> <span class="keywordtype">char</span>        *xsd__token; <span class="comment">// C (wsdl2h option -c)</span></div></div><!-- fragment --><p>This associates a compatible value space to the type with the appropriate XSD type name used by the soapcpp2-generated serializers.</p>
<p>It is possible to remap types by adding the appropriate mapping rules to <code>typemap.dat</code> as we will explain in more detail in the next section.</p>
<p>Imported custom serializers are intended to extend the C/C++ type bindings when the default binding to string is not satisfactory to your taste and if the target platform supports these C/C++ types. To add custom serializers to <code>typemap.dat</code> for wsdl2h, see <a href="#custom">adding custom serializers</a> below.</p>
<p>üîù <a href="#">Back to table of contents</a></p>
<h1><a class="anchor" id="typemap"></a>
Using typemap.dat to customize data bindings                          </h1>
<p>Use a <code>typemap.dat</code> file to redefine namespace prefixes and to customize type bindings for the the generated header files produced by the wsdl2h tool. The <code>typemap.dat</code> is the default file processed by wsdl2h. Use wsdl2h option <code>-t</code> to specify a different file.</p>
<p>Declarations in <code>typemap.dat</code> can be broken up over multiple lines by continuing on the next line by ending each line to be continued with a backslash <code>\</code>. The limit is 4095 characters per line, whether the line is broken up or not.</p>
<p>üîù <a href="#">Back to table of contents</a></p>
<h2><a class="anchor" id="typemap1"></a>
XML namespace bindings                                               </h2>
<p>The wsdl2h tool generates C/C++ type declarations that use <code>ns1</code>, <code>ns2</code>, etc. as schema-binding URI prefixes. These default prefixes are generated somewhat arbitrarily for each schema targetNamespace URI, meaning that their ordering may change depending on the WSDL and XSD order of processing with wsdl2h.</p>
<p>Therefore, it is <b>strongly recommended</b> to declare your own prefix for each schema URI in <code>typemap.dat</code> to reduce maintaince effort of your code. This is more robust when anticipating possible changes of the schema(s) and/or the binding URI(s) and/or the tooling algorithms.</p>
<p>The first and foremost important thing to do is to define prefix-URI bindings for our C/C++ code by adding the following line(s) to our <code>typemap.dat</code> or make a copy of this file and add the line(s) that bind our choice of prefix name to each URI: </p><pre class="fragment">prefix = "URI"
</pre><p>For example, to use <code>g</code> as a prefix for the "urn:graph" XML namespace: </p><pre class="fragment">g = "urn:graph"
</pre><p>This produces <code>g__name</code> C/C++ type names that are bound to the "urn:graph" schema by association of <code>g</code> to the generated C/C++ types.</p>
<p>This means that <code>&lt;g:name xmlns:g="urn:graph"&gt;</code> is parsed as an instance of a <code>g__name</code> C/C++ type. Also <code>&lt;x:name xmlns:x="urn:graph"&gt;</code> parses as an instance of <code>g__name</code>, because the prefix <code>x</code> has the same URI value <code>urn:graph</code>. Prefixes in XML have local scopes (like variables in a block).</p>
<p>The first run of wsdl2h will reveal the XML namespace URIs, so you do not need to search WSDLs and XSD files for all of the target namespaces. Just copy them from the generated header file after the first run into <code>typemap.dat</code> for editing.</p>
<dl class="section note"><dt>Note</dt><dd>Only define a namespace prefix once in <code>typemap.dat</code>. That is, do not use the same prefix for multiple XML namespace URIs. This is to avoid namespace conflicts that may cause failed builds and failures in XML parsing and XML schema validation.</dd></dl>
<p>üîù <a href="#">Back to table of contents</a></p>
<h2><a class="anchor" id="typemap2"></a>
XSD type bindings                                                    </h2>
<p>Custom C/C++ type bindings can be declared in <code>typemap.dat</code> to associate C/C++ types with specific schema types. These type bindings have four parts: </p><pre class="fragment">prefix__type = declaration | use | ptruse
</pre><p>where</p>
<ul>
<li><code>prefix__type</code> is the schema type to be customized (the <code>prefix__type</code> name uses the common double underscore naming convention);</li>
<li><code>declaration</code> declares the C/C++ type in the wsdl2h-generated header file. This part can be empty if no explicit declaration is needed;</li>
<li><code>use</code> is an optional part that specifies how the C/C++ type is used in the code. When omitted, it is the same as <code>prefix__type</code>;</li>
<li><code>ptruse</code> is an optional part that specifies how the type is used as a pointer type. By default it is the <code>use</code> type name with a <code>*</code> or C++11 <code>std::shared_ptr&lt;&gt;</code> when enabled (see further below). If <code>use</code> is already a pointer type by the presence of a <code>*</code> in the <code>use</code> part, then the default <code>ptruse</code> type is the same as the <code>use</code> type (that is, no double pointer <code>**</code> will be created in this case).</li>
</ul>
<p>For example, to map <code>xsd:duration</code> to a <code>long long</code> (<code>LONG64</code>) type that holds millisecond duration values, we can use the custom serializer declared in <code>custom/duration.h</code> by adding the following line to <code>typemap.dat</code>: </p><pre class="fragment">xsd__duration = #import "custom/duration.h"
</pre><p>Here, we omitted the second and third parts, because <code>xsd__duration</code> is the name that wsdl2h uses for this type in our generated code so we should leave the <code>use</code> part unspecified. The third part is omitted to let wsdl2h use <code>xsd__duration *</code> for pointers or <code>std::shared_ptr&lt;xsd__duration&gt;</code> if smart pointers are enabled.</p>
<p>To map <code>xsd:string</code> to <code>wchar_t*</code> wide strings: </p><pre class="fragment">xsd__string = | wchar_t* | wchar_t*
</pre><p>Note that the first part is empty, because <code>wchar_t</code> is a C type and does not need to be declared. A <code>ptruse</code> part is also defined in this example, but does not need to be because the <code>use</code> part <code>wchar_t*</code> is already a pointer.</p>
<p>When the auto-generated declaration should be preserved but the <code>use</code> or <code>ptruse</code> parts replaced, then we use an ellipsis for the declaration part: </p><pre class="fragment">prefix__type = ... | use | ptruse
</pre><p>This is useful to map schema polymorphic types to C types for example, where we need to be able to both handle a base type and its extensions as per schema extensibility. Say we have a base type called <code>ns:base</code> that is extended, then we can remap this to a C type that permits referening the extended types via a <code>void*</code> as follows: </p><pre class="fragment">ns__base = ... | int __type_base; void*
</pre><p>such that <code>__type_base</code> and <code>void*</code> will be used to (de)serialize any data type, including base and its derived types. The <code>__type_base</code> integer is set to a <code>SOAP_TYPE_T</code> value to indicate what type of data the <code>void*</code> pointer points to.</p>
<p>üîù <a href="#">Back to table of contents</a></p>
<h2><a class="anchor" id="custom"></a>
Custom serializers for XSD types                                       </h2>
<p>In the previous part we saw how a custom serializer is used to bind <code>xsd:duration</code> to a <code>long long</code> (<code>LONG64</code> or <code>int64_t</code>) type to store millisecond duration values: </p><pre class="fragment">xsd__duration = #import "custom/duration.h"
</pre><p>The <code>xsd__duration</code> type is an alias of <code>long long</code> (<code>LONG64</code> or <code>int64_t</code>).</p>
<p>While wsdl2h will use this binding declared in <code>typemap.dat</code> automatically, you will also need to compile <code>custom/duration.c</code>. Each custom serializer has a header file and an implementation file written in C. You can compile these in C++ (rename files to <code>.cpp</code> if needed).</p>
<p>We will discuss the custom serializers that are available to you.</p>
<p>üîù <a href="#">Back to table of contents</a></p>
<h3><a class="anchor" id="custom-1"></a>
xsd:integer</h3>
<p>The wsdl2h tool maps <code>xsd:integer</code> to a string by default. To map <code>xsd:integer</code> to the 128 bit big int type <code>__int128_t</code>: </p><pre class="fragment">xsd__integer = #import "custom/int128.h"
</pre><p>The <code>xsd__integer</code> type is an alias of <code>__int128_t</code>.</p>
<dl class="section warning"><dt>Warning</dt><dd>Beware that the <code>xsd:integer</code> value space of integers is in principle unbounded and values can be of arbitrary length. A value range fault <code>SOAP_TYPE</code> (value exceeds native representation) or <code>SOAP_LENGTH</code> (value exceeds range bounds) will be thrown by the deserializer if the value is out of range.</dd></dl>
<p>Other XSD integer types that are restrictions of <code>xsd:integer</code>, are <code>xsd:nonNegativeInteger</code> and <code>xsd:nonPositiveInteger</code>, which are further restricted by <code>xsd:positiveInteger</code> and <code>xsd:negativeInteger</code>. To bind these types to <code>__int128_t</code> add the following definitions to <code>typemap.dat</code>: </p><pre class="fragment">xsd__nonNegativeInteger = typedef xsd__integer xsd__nonNegativeInteger 0 :    ;
xsd__nonPositiveInteger = typedef xsd__integer xsd__nonPositiveInteger   : 0  ;
xsd__positiveInteger    = typedef xsd__integer xsd__positiveInteger    1 :    ;
xsd__negativeInteger    = typedef xsd__integer xsd__negativeInteger      : -1 ;
</pre><p>Or simply uncomment these definitions in <code>typemap.dat</code> when you are using the latest gSOAP releases.</p>
<dl class="section note"><dt>Note</dt><dd>If <code>__int128_t</code> 128 bit integers are not supported on your platform and if it is certain that <code>xsd:integer</code> values are within 64 bit value bounds for your application's use, then you can map this type to <code>LONG64</code>: <pre class="fragment">xsd__integer = typedef LONG64 xsd__integer;
</pre></dd>
<dd>
Again, a value range fault <code>SOAP_TYPE</code> or <code>SOAP_LENGTH</code> will be thrown by the deserializer if the value is out of range.</dd></dl>
<p>After running wsdl2h and soapcpp2, compile <code>custom/int128.c</code> with your project.</p>
<dl class="section see"><dt>See also</dt><dd>Section <a href="#toxsd5">numerical types</a>.</dd></dl>
<p>üîù <a href="#">Back to table of contents</a></p>
<h3><a class="anchor" id="custom-2"></a>
xsd:decimal</h3>
<p>The wsdl2h tool maps <code>xsd:decimal</code> to a string by default. To map <code>xsd:decimal</code> to extended precision floating point: </p><pre class="fragment">xsd__decimal = #import "custom/long_double.h" | long double
</pre><p>By contrast to all other custom serializers, this serializer enables <code>long double</code> natively without requiring a new binding name (<code>xsd__decimal</code> is NOT defined).</p>
<p>If your system supports <code>&lt;quadmath.h&gt;</code> quadruple precision floating point <code>__float128</code>, you can map <code>xsd:decimal</code> to <code>xsd__decimal</code> that is an alias of <code>__float128</code>: </p><pre class="fragment">xsd__decimal = #import "custom/float128.h"
</pre><dl class="section warning"><dt>Warning</dt><dd>Beware that <code>xsd:decimal</code> is in principle a decimal value with arbitraty lengths. A value range fault <code>SOAP_TYPE</code> will be thrown by the deserializer if the value is out of range.</dd></dl>
<p>In the XML payload the special values <code>INF</code>, <code>-INF</code>, <code>NaN</code> represent plus or minus infinity and not-a-number, respectively.</p>
<p>After running wsdl2h and soapcpp2, compile <code>custom/long_double.c</code> with your project.</p>
<dl class="section see"><dt>See also</dt><dd>Section <a href="#toxsd5">numerical types</a>.</dd></dl>
<p>üîù <a href="#">Back to table of contents</a></p>
<h3><a class="anchor" id="custom-3"></a>
xsd:dateTime</h3>
<p>The wsdl2h tool maps <code>xsd:dateTime</code> to <code>time_t</code> by default.</p>
<p>The trouble with <code>time_t</code> when represented as 32 bit <code>long</code> integers is that it is limited to dates between 1970 and 2038. A 64 bit <code>time_t</code> is safe to use if the target platform supports it, but lack of 64 bit <code>time_t</code> portability may still cause date range issues.</p>
<p>For this reason <code>struct tm</code> should be used to represent wider date ranges. This custom serializer avoids using date and time information in <code>time_t</code>. You get the raw date and time information. You only lose the day of the week information. It is always Sunday (<code>tm_wday=0</code>).</p>
<p>To map <code>xsd:dateTime</code> to <code>xsd__dateTime</code> which is an alias of <code>struct tm</code>: </p><pre class="fragment">xsd__dateTime = #import "custom/struct_tm.h"
</pre><p>If the limited date range of <code>time_t</code> is not a problem but you want to increase the time precision with fractional seconds, then we suggest to map <code>xsd:dateTime</code> to <code>struct timeval</code>: </p><pre class="fragment">xsd__dateTime = #import "custom/struct_timeval.h"
</pre><p>If the limited date range of <code>time_t</code> is not a problem but you want to use the C++11 time point type <code>std::chrono::system_clock::time_point</code> (which internally uses <code>time_t</code>): </p><pre class="fragment">xsd__dateTime = #import "custom/chrono_time_point.h"
</pre><p>Again, we should make sure that the dates will not exceed the date range when using the default <code>time_t</code> binding for <code>xsd:dateTime</code> or when binding <code>xsd:dateTime</code> to <code>struct timeval</code> or to <code>std::chrono::system_clock::time_point</code>. These are safe to use in applications that use <code>xsd:dateTime</code> to record date stamps within a given window. Otherwise, we recommend the <code>struct tm</code> custom serializer.</p>
<p>After running wsdl2h and soapcpp2, compile <code>custom/struct_tm.c</code> with your project.</p>
<p>You could even map <code>xsd:dateTime</code> to a plain string (use <code>char*</code> with C and <code>std::string</code> with C++). For example: </p><pre class="fragment">xsd__dateTime = | char*
</pre><dl class="section see"><dt>See also</dt><dd>Section <a href="#toxsd7">date and time types</a>.</dd></dl>
<p>üîù <a href="#">Back to table of contents</a></p>
<h3><a class="anchor" id="custom-4"></a>
xsd:date</h3>
<p>The wsdl2h tool maps <code>xsd:date</code> to a string by default. We can map <code>xsd:date</code> to <code>struct tm</code>: </p><pre class="fragment">xsd__date = #import "custom/struct_tm_date.h"
</pre><p>The <code>xsd__date</code> type is an alias of <code>struct tm</code>. The serializer ignores the time part and the deserializer only populates the date part of the struct, setting the time to 00:00:00. There is no unreasonable limit on the date range because the year field is stored as an integer (<code>int</code>).</p>
<p>After running wsdl2h and soapcpp2, compile <code>custom/struct_tm_date.c</code> with your project.</p>
<dl class="section see"><dt>See also</dt><dd>Section <a href="#toxsd7">date and time types</a>.</dd></dl>
<p>üîù <a href="#">Back to table of contents</a></p>
<h3><a class="anchor" id="custom-5"></a>
xsd:time</h3>
<p>The wsdl2h tool maps <code>xsd:time</code> to a string by default. We can map <code>xsd:time</code> to an <code>unsigned long long</code> (<code>ULONG64</code> or <code>uint64_t</code>) integer with microsecond time precision: </p><pre class="fragment">xsd__time = #import "custom/long_time.h"
</pre><p>This type represents 00:00:00.000000 to 23:59:59.999999, from <code>0</code> to an upper bound of <code>86399999999</code>. A microsecond resolution means that a 1 second increment requires an increment of 1000000 in the integer value. The serializer adds a UTC time zone.</p>
<p>After running wsdl2h and soapcpp2, compile <code>custom/long_time.c</code> with your project.</p>
<dl class="section see"><dt>See also</dt><dd>Section <a href="#toxsd7">date and time types</a>.</dd></dl>
<p>üîù <a href="#">Back to table of contents</a></p>
<h3><a class="anchor" id="custom-6"></a>
xsd:duration</h3>
<p>The wsdl2h tool maps <code>xsd:duration</code> to a string by default, unless <code>xsd:duration</code> is mapped to a <code>long long</code> (<code>LONG64</code> or <code>int64_t</code>) type with with millisecond (ms) time duration precision: </p><pre class="fragment">xsd__duration = #import "custom/duration.h"
</pre><p>The <code>xsd__duration</code> type is a 64 bit signed integer that can represent 106,751,991,167 days forwards (positive) and backwards (negative) in time in increments of 1 ms (1/1000 of a second).</p>
<p>Rescaling of the duration value by may be needed when adding the duration value to a <code>time_t</code> value, because <code>time_t</code> may or may not have a seconds resolution, depending on the platform and possible changes to <code>time_t</code>.</p>
<p>Rescaling is done automatically when you add a C++11 <code>std::chrono::nanoseconds</code> value to a <code>std::chrono::system_clock::time_point</code> value. To use <code>std::chrono::nanoseconds</code> as <code>xsd:duration</code>: </p><pre class="fragment">xsd__duration = #import "custom/chrono_duration.h"
</pre><p>This type can represent 384,307,168 days (2^63 nanoseconds) forwards and backwards in time in increments of 1 ns (1/1,000,000,000 of a second).</p>
<p>Certain observations with respect to receiving durations in years and months apply to both of these serializer decoders for <code>xsd:duration</code>.</p>
<p>After running wsdl2h and soapcpp2, compile <code>custom/duration.c</code> with your project.</p>
<dl class="section see"><dt>See also</dt><dd>Section <a href="#toxsd8">time duration types</a>.</dd></dl>
<p>üîù <a href="#">Back to table of contents</a></p>
<h2><a class="anchor" id="qt"></a>
Custom Qt serializers for XSD types                                        </h2>
<p>The gSOAP distribution includes several custom serializers for Qt types. Also Qt container classes are supported, see <a href="#typemap5">the built-in typemap.dat variables $CONTAINER and $POINTER</a>.</p>
<p>This feature requires gSOAP 2.8.34 or higher and Qt 4.8 or higher.</p>
<p>Each Qt custom serializer has an interface header file for soapcpp2 and a C++ implementation file to be compiled with your project.</p>
<p>Other Qt primitive types that are Qt typedefs of C/C++ types do not require a custom serializer.</p>
<p>üîù <a href="#">Back to table of contents</a></p>
<h3><a class="anchor" id="qt-1"></a>
xsd:string</h3>
<p>To use Qt strings instead of C++ strings, add the following definition to <code>typemap.dat</code>: </p><pre class="fragment">xsd__string = #import "custom/qstring.h"
</pre><p>After running wsdl2h and soapcpp2, compile <code>custom/qstring.cpp</code> with your project.</p>
<p>üîù <a href="#">Back to table of contents</a></p>
<h3><a class="anchor" id="qt-2"></a>
xsd:base64Binary</h3>
<p>To use Qt byte arrays for <code>xsd:base64Binary</code> instead of the <code>xsd__base64Binary</code> class, add the following definition to <code>typemap.dat</code>: </p><pre class="fragment">xsd__base64Binary = #import "custom/qbytearray_base64.h"
</pre><p>After running wsdl2h and soapcpp2, compile <code>custom/qbytearray_base64.cpp</code> with your project.</p>
<p>üîù <a href="#">Back to table of contents</a></p>
<h3><a class="anchor" id="qt-3"></a>
xsd:hexBinary</h3>
<p>To use Qt byte arrays for <code>xsd:hexBinary</code> instead of the <code>xsd__base64Binary</code> class, add the following definition to <code>typemap.dat</code>: </p><pre class="fragment">xsd__hexBinary = #import "custom/qbytearray_hex.h"
</pre><p>After running wsdl2h and soapcpp2, compile <code>custom/qbytearray_hex.cpp</code> with your project.</p>
<p>üîù <a href="#">Back to table of contents</a></p>
<h3><a class="anchor" id="qt-4"></a>
xsd:dateTime</h3>
<p>To use Qt QDateTime for <code>xsd:dateTime</code>, add the following definition to <code>typemap.dat</code>: </p><pre class="fragment">xsd__dateTime = #import "custom/datetime.h"
</pre><p>After running wsdl2h and soapcpp2, compile <code>custom/qdatetime.cpp</code> with your project.</p>
<p>üîù <a href="#">Back to table of contents</a></p>
<h3><a class="anchor" id="qt-5"></a>
xsd:date</h3>
<p>To use Qt QDate for <code>xsd:date</code>, add the following definition to <code>typemap.dat</code>: </p><pre class="fragment">xsd__date = #import "custom/qdate.h"
</pre><p>After running wsdl2h and soapcpp2, compile <code>custom/qdate.cpp</code> with your project.</p>
<p>üîù <a href="#">Back to table of contents</a></p>
<h3><a class="anchor" id="qt-6"></a>
xsd:time</h3>
<p>To use Qt QDate for <code>xsd:time</code>, add the following definition to <code>typemap.dat</code>: </p><pre class="fragment">xsd__time = #import "custom/qtime.h"
</pre><p>After running wsdl2h and soapcpp2, compile <code>custom/qtime.cpp</code> with your project.</p>
<p>üîù <a href="#">Back to table of contents</a></p>
<h2><a class="anchor" id="typemap3"></a>
Class/struct member additions                                        </h2>
<p>All generated classes and structs can be augmented with additional members such as methods, constructors and destructors, and private members: </p><pre class="fragment">prefix__type = $ member-declaration
</pre><p>For example, we can add method declarations and private members to a class, say <code>ns__record</code> as follows: </p><pre class="fragment">ns__record = $ ns__record(const ns__record &amp;); // copy constructor
ns__record = $ void print();                   // a print method
ns__record = $ private: int status;            // a private member
</pre><p>Note that method declarations cannot include any code, because soapcpp2's input permits only type declarations, not code.</p>
<p>üîù <a href="#">Back to table of contents</a></p>
<h2><a class="anchor" id="typemap4"></a>
Replacing XSD types by equivalent alternatives                       </h2>
<p>Type replacements can be given to replace one type entirely with another given type: </p><pre class="fragment">prefix__type1 == prefix__type2
</pre><p>This replaces all <code>prefix__type1</code> by <code>prefix__type2</code> in the wsdl2h output.</p>
<dl class="section warning"><dt>Warning</dt><dd>Do not agressively replace types, because this can cause XML schema validation to fail when a value-type mismatch is encountered in the XML input. Therefore, only replace similar types with other similar types that are wider (e.g. <code>short</code> by <code>int</code> and <code>float</code> by <code>double</code>).</dd></dl>
<p>üîù <a href="#">Back to table of contents</a></p>
<h2><a class="anchor" id="typemap5"></a>
The built-in typemap.dat variables $CONTAINER and $POINTER           </h2>
<p>The <code>typemap.dat</code> <code>$CONTAINER</code> variable defines the container to emit in the generated declarations, which is <code>std::vector</code> by default. For example, to emit <code>std::list</code> as the container in the wsdl2h-generated declarations: </p><pre class="fragment">$CONTAINER = std::list
</pre><p>The <code>typemap.dat</code> <code>$POINTER</code> variable defines the smart pointer to emit in the generated declarations, which replaces the use of <code>*</code> pointers. For example: </p><pre class="fragment">$POINTER = std::shared_ptr
</pre><p>Not all pointers in the generated output can be replaced by smart pointers. Regular pointers are still used as union members and for pointers to arrays of objects.</p>
<dl class="section note"><dt>Note</dt><dd>The standard smart pointer <code>std::shared_ptr</code> is generally safe to use. Other smart pointers such as <code>std::unique_ptr</code> and <code>std::auto_ptr</code> may cause compile-time errors when classes have smart pointer members but no copy constructor (a default copy constructor). A copy constructor is required for non-shared smart pointer copying or swapping.</dd></dl>
<p>Alternatives to <code>std::shared_ptr</code> of the form <code>NAMESPACE::shared_ptr</code> can be assigned to <code>$POINTER</code> when the namespace <code>NAMESPACE</code> also implements <code>NAMESPACE::make_shared</code> and when the shared pointer class provides <code>reset()</code> and<code>get()</code> methods and the dereference operator. For example Boost <code>boost::shared_ptr</code>: </p><pre class="fragment">[
#include &lt;boost/shared_ptr.hpp&gt;
]
$POINTER = boost::shared_ptr
</pre><p>The user-defined content between <code>[</code> and <code>]</code> ensures that we include the Boost header files that are needed to support <code>boost::shared_ptr</code> and <code>boost::make_shared</code>.</p>
<p>A Qt container can be used instead of the default <code>std::vector</code>, for example <code>QVector</code>: </p><pre class="fragment">[
#include &lt;QVector&gt;
]
$CONTAINER = QVector
</pre><p>üîù <a href="#">Back to table of contents</a></p>
<h2><a class="anchor" id="typemap6"></a>
User-defined content                                                 </h2>
<p>Any other content to be generated by wsdl2h can be included in <code>typemap.dat</code> by enclosing it within brackets <code>[</code> and <code>]</code> anywhere in the <code>typemap.dat</code> file. Each of the two brackets MUST appear at the start of a new line.</p>
<p>For example, we can add an <code>#import "wsa5.h"</code> to the wsdl2h-generated output as follows: </p><pre class="fragment">[
#import "import/wsa5.h"
]
</pre><p>which emits the <code>#import "import/wsa5.h"</code> literally at the start of the wsdl2h-generated header file.</p>
<p>üîù <a href="#">Back to table of contents</a></p>
<h1><a class="anchor" id="toxsd"></a>
Mapping C/C++ to XML schema                                             </h1>
<p>The soapcpp2 command generates the data binding implementation code from a data binding interface <code>file.h</code>: </p><pre class="fragment">soapcpp2 [options] file.h
</pre><p>where <code>file.h</code> is a gSOAP header file that declares the XML data binding interface. The <code>file.h</code> is typically generated by wsdl2h, but you can also declare one yourself. If so, add <code>//gsaop</code> <a href="#directives">directives</a> and declare in this file all our C/C++ types you want to serialize in XML.</p>
<p>You can also declare functions that will be converted to Web service operations by soapcpp2. Global function declarations define service operations, which are of the form:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> prefix__func(arg1, arg2, ..., argn, result);</div></div><!-- fragment --><p>where <code>arg1</code>, <code>arg2</code>, ..., <code>argn</code> are formal argument declarations of the input and <code>result</code> is a formal argument for the output, which must be a pointer or reference to the result object to be populated. More information can be found in the <a href="http://www.genivia.com/doc/soapdoc2.html">gSOAP user guide.</a></p>
<p>üîù <a href="#">Back to table of contents</a></p>
<h2><a class="anchor" id="toxsd1"></a>
Overview of serializable C/C++ types                                   </h2>
<p>The following C/C++ types are supported by soapcpp2 and mapped to XSD types and constructs. See the subsections below for more details or follow the links.</p>
<p>üîù <a href="#">Back to table of contents</a></p>
<h3>List of Boolean types</h3>
<table class="doxtable">
<tr>
<th>Boolean Type </th><th>Notes  </th></tr>
<tr>
<td><code>bool</code> </td><td>C++ bool </td></tr>
<tr>
<td><code>enum xsd__boolean</code> </td><td>C alternative to C++ <code>bool</code> with <code>false_</code> and <code>true_</code> </td></tr>
</table>
<dl class="section see"><dt>See also</dt><dd>Section <a href="#toxsd3">C++ bool and C alternative</a>.</dd></dl>
<p>üîù <a href="#">Back to table of contents</a></p>
<h3>List of enumeration and bitmask types</h3>
<table class="doxtable">
<tr>
<th>Enumeration Type </th><th>Notes  </th></tr>
<tr>
<td><code>enum</code> </td><td>enumeration </td></tr>
<tr>
<td><code>enum class</code> </td><td>C++11 scoped enumeration (soapcpp2 <code>-c++11</code>) </td></tr>
<tr>
<td><code>enum*</code> </td><td>a bitmask that enumerates values 1, 2, 4, 8, ... </td></tr>
<tr>
<td><code>enum* class</code> </td><td>C++11 scoped enumeration bitmask (soapcpp2 <code>-c++11</code>) </td></tr>
</table>
<dl class="section see"><dt>See also</dt><dd>Section <a href="#toxsd4">enumerations and bitmasks</a>.</dd></dl>
<p>üîù <a href="#">Back to table of contents</a></p>
<h3>List of numerical types</h3>
<table class="doxtable">
<tr>
<th>Numerical Type </th><th>Notes  </th></tr>
<tr>
<td><code>char</code> </td><td>byte </td></tr>
<tr>
<td><code>short</code> </td><td>16 bit integer </td></tr>
<tr>
<td><code>int</code> </td><td>32 bit integer </td></tr>
<tr>
<td><code>long</code> </td><td>32 bit integer </td></tr>
<tr>
<td><code>LONG64</code> </td><td>64 bit integer </td></tr>
<tr>
<td><code>xsd__integer</code> </td><td>128 bit integer, use <code>#import "custom/int128.h"</code> </td></tr>
<tr>
<td><code>long long</code> </td><td>same as <code>LONG64</code> </td></tr>
<tr>
<td><code>unsigned char</code> </td><td>unsigned byte </td></tr>
<tr>
<td><code>unsigned short</code> </td><td>unsigned 16 bit integer </td></tr>
<tr>
<td><code>unsigned int</code> </td><td>unsigned 32 bit integer </td></tr>
<tr>
<td><code>unsigned long</code> </td><td>unsigned 32 bit integer </td></tr>
<tr>
<td><code>ULONG64</code> </td><td>unsigned 64 bit integer </td></tr>
<tr>
<td><code>unsigned long long</code> </td><td>same as <code>ULONG64</code> </td></tr>
<tr>
<td><code>int8_t</code> </td><td>same as <code>char</code> </td></tr>
<tr>
<td><code>int16_t</code> </td><td>same as <code>short</code> </td></tr>
<tr>
<td><code>int32_t</code> </td><td>same as <code>int</code> </td></tr>
<tr>
<td><code>int64_t</code> </td><td>same as <code>LONG64</code> </td></tr>
<tr>
<td><code>uint8_t</code> </td><td>same as <code>unsigned char</code> </td></tr>
<tr>
<td><code>uint16_t</code> </td><td>same as <code>unsigned short</code> </td></tr>
<tr>
<td><code>uint32_t</code> </td><td>same as <code>unsigned int</code> </td></tr>
<tr>
<td><code>uint64_t</code> </td><td>same as <code>ULONG64</code> </td></tr>
<tr>
<td><code>size_t</code> </td><td>transient type (not serializable) </td></tr>
<tr>
<td><code>float</code> </td><td>32 bit float </td></tr>
<tr>
<td><code>double</code> </td><td>64 bit float </td></tr>
<tr>
<td><code>long double</code> </td><td>extended precision float, use <code>#import "custom/long_double.h"</code> </td></tr>
<tr>
<td><code>xsd__decimal</code> </td><td><code>&lt;quadmath.h&gt;</code> 128 bit quadruple precision float, use <code>#import "custom/float128.h"</code> </td></tr>
<tr>
<td><code>typedef</code> </td><td>declares a type name, with optional value range and string length bounds </td></tr>
</table>
<dl class="section see"><dt>See also</dt><dd>Section <a href="#toxsd5">numerical types</a>.</dd></dl>
<p>üîù <a href="#">Back to table of contents</a></p>
<h3>List of string types</h3>
<table class="doxtable">
<tr>
<th>String Type </th><th>Notes  </th></tr>
<tr>
<td><code>char*</code> </td><td>string (may contain UTF-8 with flag <code>SOAP_C_UTFSTRING</code>) </td></tr>
<tr>
<td><code>wchar_t*</code> </td><td>wide string </td></tr>
<tr>
<td><code>std::string</code> </td><td>C++ string (may contain UTF-8 with flag <code>SOAP_C_UTFSTRING</code>) </td></tr>
<tr>
<td><code>std::wstring</code> </td><td>C++ wide string </td></tr>
<tr>
<td><code>char[N]</code> </td><td>fixed-size string, requires soapcpp2 option <code>-b</code> </td></tr>
<tr>
<td><code>_QName</code> </td><td>normalized QName content </td></tr>
<tr>
<td><code>_XML</code> </td><td>literal XML string content with wide characters in UTF-8 </td></tr>
<tr>
<td><code>typedef</code> </td><td>declares a new string type name, may restrict string length </td></tr>
</table>
<dl class="section see"><dt>See also</dt><dd>Section <a href="#toxsd6">string types</a>.</dd></dl>
<p>üîù <a href="#">Back to table of contents</a></p>
<h3>List of date and time types</h3>
<table class="doxtable">
<tr>
<th>Date and Time Type </th><th>Notes  </th></tr>
<tr>
<td><code>time_t</code> </td><td>date and time point since epoch </td></tr>
<tr>
<td><code>struct tm</code> </td><td>date and time point, use <code>#import "custom/struct_tm.h"</code> </td></tr>
<tr>
<td><code>struct tm</code> </td><td>date point, use <code>#import "custom/struct_tm_date.h"</code> </td></tr>
<tr>
<td><code>struct timeval</code> </td><td>date and time point, use <code>#import "custom/struct_timeval.h"</code> </td></tr>
<tr>
<td><code>unsigned long long</code> </td><td>time point in microseconds, use <code>#import "custom/long_time.h"</code> </td></tr>
<tr>
<td><code>std::chrono::system_clock::time_point</code> </td><td>date and time point, use <code>#import "custom/chrono_time_point.h"</code> </td></tr>
</table>
<dl class="section see"><dt>See also</dt><dd>Section <a href="#toxsd7">date and time types</a>.</dd></dl>
<p>üîù <a href="#">Back to table of contents</a></p>
<h3>List of time duration types</h3>
<table class="doxtable">
<tr>
<th>Time Duration Type </th><th>Notes  </th></tr>
<tr>
<td><code>long long</code> </td><td>duration in milliseconds, use <code>#import "custom/duration.h"</code> </td></tr>
<tr>
<td><code>std::chrono::nanoseconds</code> </td><td>duration in nanoseconds, use <code>#import "custom/chrono_duration.h"</code> </td></tr>
</table>
<dl class="section see"><dt>See also</dt><dd>Section <a href="#toxsd8">time duration types</a>.</dd></dl>
<p>üîù <a href="#">Back to table of contents</a></p>
<h3>List of classes and structs</h3>
<table class="doxtable">
<tr>
<th>Classes, Structs, and Members </th><th>Notes  </th></tr>
<tr>
<td><code>class</code> </td><td>C++ class with single inheritance only </td></tr>
<tr>
<td><code>struct</code> </td><td>C struct or C++ struct without inheritance </td></tr>
<tr>
<td><code>std::shared_ptr&lt;T&gt;</code> </td><td>C++11 smart shared pointer </td></tr>
<tr>
<td><code>std::unique_ptr&lt;T&gt;</code> </td><td>C++11 smart pointer </td></tr>
<tr>
<td><code>std::auto_ptr&lt;T&gt;</code> </td><td>C++ smart pointer </td></tr>
<tr>
<td><code>std::deque&lt;T&gt;</code> </td><td>use <code>#import "import/stldeque.h"</code> </td></tr>
<tr>
<td><code>std::list&lt;T&gt;</code> </td><td>use <code>#import "import/stllist.h"</code> </td></tr>
<tr>
<td><code>std::vector&lt;T&gt;</code> </td><td>use <code>#import "import/stlvector.h"</code> </td></tr>
<tr>
<td><code>std::set&lt;T&gt;</code> </td><td>use <code>#import "import/stlset.h"</code> </td></tr>
<tr>
<td><code>template&lt;T&gt; class</code> </td><td>a container with <code>begin()</code>, <code>end()</code>, <code>size()</code>, <code>clear()</code>, and <code>insert()</code> methods </td></tr>
<tr>
<td><code>T*</code> </td><td>data member: pointer to data of type <code>T</code> or points to array of <code>T</code> of size <code>__size</code> </td></tr>
<tr>
<td><code>T[N]</code> </td><td>data member: fixed-size array of type <code>T</code> </td></tr>
<tr>
<td><code>union</code> </td><td>data member: requires a variant selector member <code>__union</code> </td></tr>
<tr>
<td><code>void*</code> </td><td>data member: requires a <code>__type</code> member to indicate the type of object pointed to </td></tr>
</table>
<dl class="section see"><dt>See also</dt><dd>Section <a href="#toxsd9">classes and structs</a>.</dd></dl>
<p>üîù <a href="#">Back to table of contents</a></p>
<h3>List of special classes and structs</h3>
<table class="doxtable">
<tr>
<th>Special Classes and Structs </th><th>Notes  </th></tr>
<tr>
<td>Special Array class/struct </td><td>single and multidimensional SOAP Arrays </td></tr>
<tr>
<td>Special Wrapper class/struct </td><td>complexTypes with simpleContent, wraps <code>__item</code> member </td></tr>
<tr>
<td><code>xsd__hexBinary</code> </td><td>binary content </td></tr>
<tr>
<td><code>xsd__base64Binary</code> </td><td>binary content and optional MIME/MTOM attachments </td></tr>
<tr>
<td><code>xsd__anyType</code> </td><td>DOM elements, use <code>#import "dom.h"</code> </td></tr>
<tr>
<td><code>@xsd__anyAttribute</code> </td><td>DOM attributes, use <code>#import "dom.h"</code> </td></tr>
</table>
<dl class="section see"><dt>See also</dt><dd>Section <a href="#toxsd10">special classes and structs</a>.</dd></dl>
<p>üîù <a href="#">Back to table of contents</a></p>
<h2><a class="anchor" id="toxsd2"></a>
Colon notation versus name prefixing with XML tag name translation     </h2>
<p>To bind C/C++ type names to XSD types, a simple form of name prefixing is used by the gSOAP tools by prepending the XML namespace prefix to the C/C++ type name with a pair of undescrores. This also ensures that name clashes cannot occur when multiple WSDL and XSD files are converted to C/C++. Also, C++ namespaces are not sufficiently rich to capture XML schema namespaces accurately, for example when class members are associated with schema elements defined in another XML namespace and thus the XML namespace scope of the member's name is relevant, not just its type.</p>
<p>However, from a C/C++ centric point of view this can be cumbersome. Therefore, colon notation is an alternative to physically augmenting C/C++ names with prefixes.</p>
<p>For example, the following class uses colon notation to bind the <code>record</code> class to the <code>urn:types</code> schema:</p>
<div class="fragment"><div class="line"><span class="comment">//gsoap ns schema namespace: urn:types</span></div><div class="line"><span class="keyword">class </span>ns:record        <span class="comment">// binding &#39;ns:&#39; to a type name</span></div><div class="line">{</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  std::string name;</div><div class="line">  uint64_t    SSN;</div><div class="line">  ns:record   *spouse; <span class="comment">// using &#39;ns:&#39; with the type name</span></div><div class="line">  ns:record();         <span class="comment">// using &#39;ns:&#39; here too</span></div><div class="line">  ~ns:record();        <span class="comment">// and here</span></div><div class="line">};</div></div><!-- fragment --><p>The colon notation is stripped away by soapcpp2 when generating the data binding implementation code for our project. So the final code just uses <code>record</code> to identify this class and its constructor/destructor.</p>
<p>When using colon notation make sure to be consistent and not use colon notation mixed with prefixed forms. The name <code>ns:record</code> differs from <code>ns__record</code>, because <code>ns:record</code> is compiled to an unqualified <code>record</code> name.</p>
<p>Colon notation also facilitates overruling the elementFormDefault and attributeFormDefault declaration that is applied to local elements and attributes, when declared as members of classes, structs, and unions. For more details, see <a href="#toxsd9-6">qualified and unqualified members</a>.</p>
<p>A C/C++ identifier name (a type name, member name, function name, or parameter name) is translated to an XML tag name by the following rules:</p>
<ul>
<li>Two leading underscores indicates that the identifier name has no XML tag name, i.e. this name is not visible in XML and is not translated.</li>
<li>A leading underscore is removed, but the underscore indicates that: <b>a</b>) a struct/class member name or parameter name has a wildcard XML tag name (i.e. matches any XML tag), or <b>b</b>) a type name that has a <a href="#toxsd9-7">document root element definition</a>.</li>
<li>Trailing underscores are removed (i.e. trailing underscores can be used to avoid name clashes with keywords).</li>
<li>Underscores within names are translated to hyphens (hyphens are more common in XML tags).</li>
<li><code>_USCORE</code> is translated to an underscore in the translated XML tag name.</li>
<li><code>_DOT</code> is translated to a dot (<code>.</code>) in the translated XML tag name.</li>
<li><code>_xHHHH</code> is translated to the Unicode character with code point HHHH (hex).</li>
<li>C++11 Unicode identifier name characters in UTF-8 are translated as-is.</li>
</ul>
<p>For example, the C/C++ namespace qualified identifier name <code>s_a__my_way</code> is translated to the XML tag name <code>s-a:my-way</code> by translating the prefix <code>s_a</code> and the local name <code>my_way</code>.</p>
<p>Struct/class member and parameter name translation can be overruled by using <a href="#toxsd9-5">backtick XML tags</a> (with gSOAP 2.8.30 and later versions).</p>
<p>üîù <a href="#">Back to table of contents</a></p>
<h2><a class="anchor" id="toxsd3"></a>
C++ Bool and C alternatives                                            </h2>
<p>The C++ <code>bool</code> type is bound to built-in XSD type <code>xsd:boolean</code>.</p>
<p>The C alternative is to define an enumeration:</p>
<div class="fragment"><div class="line"><span class="keyword">enum</span> xsd__boolean { false_, true_ };</div></div><!-- fragment --><p>or by defining an enumeration in C with pseudo-scoped enumeration constants:</p>
<div class="fragment"><div class="line"><span class="keyword">enum</span> xsd__boolean { xsd__boolean__false, xsd__boolean__true };</div></div><!-- fragment --><p>The XML value space of these types is <code>false</code> and <code>true</code>, but also accepted are <code>0</code> and <code>1</code> values for false and true, respectively.</p>
<p>To prevent name clashes, <code>false_</code> and <code>true_</code> have an underscore. Trailing underscores are removed from the XML value space.</p>
<p>üîù <a href="#">Back to table of contents</a></p>
<h2><a class="anchor" id="toxsd4"></a>
Enumerations and bitmasks                                              </h2>
<p>Enumerations are mapped to XSD simpleType enumeration restrictions of <code>xsd:string</code>, <code>xsd:QName</code>, and <code>xsd:long</code>.</p>
<p>Consider for example:</p>
<div class="fragment"><div class="line"><span class="keyword">enum</span> ns__Color { RED, WHITE, BLUE };</div></div><!-- fragment --><p>which maps to a simpleType restriction of <code>xsd:string</code> in the soapcpp2-generated schema:</p>
<div class="alt"> <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;&lt;<span class="keywordtype">simpleType</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;Color&quot;</span>&gt;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  &lt;<span class="keywordtype">restriction</span> <span class="keyword">base</span>=<span class="stringliteral">&quot;xsd:string&quot;</span>&gt;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    &lt;<span class="keywordtype">enumeration</span> <span class="keyword">value</span>=<span class="stringliteral">&quot;RED&quot;</span>/&gt;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    &lt;<span class="keywordtype">enumeration</span> <span class="keyword">value</span>=<span class="stringliteral">&quot;WHITE&quot;</span>/&gt;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    &lt;<span class="keywordtype">enumeration</span> <span class="keyword">value</span>=<span class="stringliteral">&quot;BLUE&quot;</span>/&gt;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;  &lt;/<span class="keywordtype">restriction</span>&gt;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;&lt;/<span class="keywordtype">simpleType</span>&gt;</div></div><!-- fragment --> </div><p>Enumeration name constants can be pseudo-scoped to prevent name clashes, because enumeration name constants have a global scope in C and C++:</p>
<div class="fragment"><div class="line"><span class="keyword">enum</span> ns__Color { ns__Color__RED, ns__Color__WHITE, ns__Color__BLUE };</div></div><!-- fragment --><p>You can also use C++11 scoped enumerations to prevent name clashes:</p>
<div class="fragment"><div class="line"><span class="keyword">enum class</span> ns__Color : int { RED, WHITE, BLUE };</div></div><!-- fragment --><p>Here, the enumeration class base type <code>: int</code> is optional. In place of <code>int</code> in the example above, we can also use <code>int8_t</code>, <code>int16_t</code>, <code>int32_t</code>, or <code>int64_t</code>.</p>
<p>The XML value space of the enumertions defined above is <code>RED</code>, <code>WHITE</code>, and <code>BLUE</code>.</p>
<p>Prefix-qualified enumeration name constants are mapped to simpleType restrictions of <code>xsd:QName</code>, for example:</p>
<div class="fragment"><div class="line"><span class="keyword">enum</span> ns__types { xsd__int, xsd__float };</div></div><!-- fragment --><p>which maps to a simpleType restriction of <code>xsd:QName</code> in the soapcpp2-generated schema:</p>
<div class="alt"> <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;&lt;<span class="keywordtype">simpleType</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;types&quot;</span>&gt;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  &lt;<span class="keywordtype">restriction</span> <span class="keyword">base</span>=<span class="stringliteral">&quot;xsd:QName&quot;</span>&gt;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    &lt;<span class="keywordtype">enumeration</span> <span class="keyword">value</span>=<span class="stringliteral">&quot;xsd:int&quot;</span>/&gt;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    &lt;<span class="keywordtype">enumeration</span> <span class="keyword">value</span>=<span class="stringliteral">&quot;xsd:float&quot;</span>/&gt;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;  &lt;/<span class="keywordtype">restriction</span>&gt;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;&lt;/<span class="keywordtype">simpleType</span>&gt;</div></div><!-- fragment --> </div><p>Enumeration name constants can be pseudo-numeric as follows:</p>
<div class="fragment"><div class="line"><span class="keyword">enum</span> ns__Primes { _3 = 3, _5 = 5, _7 = 7, _11 = 11 };</div></div><!-- fragment --><p>which maps to a simpleType restriction of <code>xsd:long</code>:</p>
<div class="alt"> <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;&lt;<span class="keywordtype">simpleType</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;Color&quot;</span>&gt;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  &lt;<span class="keywordtype">restriction</span> <span class="keyword">base</span>=<span class="stringliteral">&quot;xsd:long&quot;</span>&gt;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    &lt;<span class="keywordtype">enumeration</span> <span class="keyword">value</span>=<span class="stringliteral">&quot;3&quot;</span>/&gt;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    &lt;<span class="keywordtype">enumeration</span> <span class="keyword">value</span>=<span class="stringliteral">&quot;5&quot;</span>/&gt;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    &lt;<span class="keywordtype">enumeration</span> <span class="keyword">value</span>=<span class="stringliteral">&quot;7&quot;</span>/&gt;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    &lt;<span class="keywordtype">enumeration</span> <span class="keyword">value</span>=<span class="stringliteral">&quot;11&quot;</span>/&gt;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;  &lt;/<span class="keywordtype">restriction</span>&gt;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;&lt;/<span class="keywordtype">simpleType</span>&gt;</div></div><!-- fragment --> </div><p>The XML value space of this type is <code>3</code>, <code>5</code>, <code>7</code>, and <code>11</code>.</p>
<p>Besides (pseudo-) scoped enumerations, another way to prevent name clashes accross enumerations is to start an enumeration name constant with one underscore or followed it by any number of underscores, which makes it unique. The leading and trailing underscores are removed from the XML value space.</p>
<div class="fragment"><div class="line"><span class="keyword">enum</span> ns__ABC { A, B, C };</div><div class="line"><span class="keyword">enum</span> ns__BA  { B, A };    <span class="comment">// BAD: B = 1 but B is already defined as 2</span></div><div class="line"><span class="keyword">enum</span> ns__BA_ { B_, A_ };  <span class="comment">// OK</span></div></div><!-- fragment --><p>The gSOAP soapcpp2 tool permits reusing enumeration name constants across (non-scoped) enumerations as long as these values are assigned the same constant. Therefore, the following is permitted:</p>
<div class="fragment"><div class="line"><span class="keyword">enum</span> ns__Primes { _3 = 3, _5 = 5, _7 = 7, _11 = 11 };</div><div class="line"><span class="keyword">enum</span> ns__Throws { _1 = 1, _2 = 2, _3 = 3, _4 = 4, _5 = 5, _6 = 6 };</div></div><!-- fragment --><p>A bitmask type is an <code>enum*</code> "product" enumeration with a geometric, power-of-two sequence of values assigned to the enumeration constants:</p>
<div class="fragment"><div class="line"><span class="keyword">enum</span>* ns__Options { SSL3, TLS10, TLS11, TLS12 };</div></div><!-- fragment --><p>where the product enum assigns 1 to <code>SSL3</code>, 2 to <code>TLS10</code>, 4 to <code>TLS11</code>, and 8 to <code>TLS12</code>, which allows these enumeration constants to be used in composing bitmasks with <code>|</code> (bitwise or) <code>&amp;</code> (bitwise and), and <code>~</code> (bitwise not):</p>
<div class="fragment"><div class="line"><span class="keyword">enum</span> ns__Options options = (<span class="keyword">enum</span> ns__Options)(SSL3 | TLS10 | TLS11 | TLS12);</div><div class="line"><span class="keywordflow">if</span> (options &amp; SSL3) <span class="comment">// if SSL3 is an option, warn and remove from options</span></div><div class="line">{</div><div class="line">  warning();</div><div class="line">  options &amp;= ~SSL3;</div><div class="line">}</div></div><!-- fragment --><p>The bitmask type maps to a simpleType list restriction of <code>xsd:string</code> in the soapcpp2-generated schema:</p>
<div class="alt"> <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;&lt;<span class="keywordtype">simpleType</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;Options&quot;</span>&gt;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  &lt;<span class="keywordtype">list</span>&gt;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    &lt;<span class="keywordtype">restriction</span> <span class="keyword">base</span>=<span class="stringliteral">&quot;xsd:string&quot;</span>&gt;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;      &lt;<span class="keywordtype">enumeration</span> <span class="keyword">value</span>=<span class="stringliteral">&quot;SSL3&quot;</span>/&gt;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;      &lt;<span class="keywordtype">enumeration</span> <span class="keyword">value</span>=<span class="stringliteral">&quot;TLS10&quot;</span>/&gt;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;      &lt;<span class="keywordtype">enumeration</span> <span class="keyword">value</span>=<span class="stringliteral">&quot;TLS11&quot;</span>/&gt;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;      &lt;<span class="keywordtype">enumeration</span> <span class="keyword">value</span>=<span class="stringliteral">&quot;TLS12&quot;</span>/&gt;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    &lt;/<span class="keywordtype">restriction</span>&gt;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;  &lt;/<span class="keywordtype">list</span>&gt;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;&lt;/<span class="keywordtype">simpleType</span>&gt;</div></div><!-- fragment --> </div><p>The XML value space of this type consists of all 16 possible subsets of the four values, represented by an XML string with space-separated values. For example, the bitmask <code>TLS10 | TLS11 | TLS12</code> equals 14 and is represented by the XML string <code>TLS10 TLS11 TLS12</code>.</p>
<p>You can also use C++11 scoped enumerations with bitmasks:</p>
<div class="fragment"><div class="line"><span class="keyword">enum</span>* <span class="keyword">class </span>ns__Options { SSL3, TLS10, TLS11, TLS12 };</div></div><!-- fragment --><p>The base type of a scoped enumeration bitmask, when explicitly given, is ignored. The base type is either <code>int</code> or <code>int64_t</code>, depending on the number of constants enumerated in the bitmask.</p>
<p>To convert <code>enum</code> name constants and bitmasks to a string, we use the auto-generated function for enum <code>T</code>:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> *soap_T2s(<span class="keyword">struct</span> soap*, <span class="keyword">enum</span> T val)</div></div><!-- fragment --><p>The string returned is stored in an internal buffer of the current <code>soap</code> context, so you MUST copy it to keep it from being overwritten. For example, use <code>char *soap_strdup(struct soap*, const char*)</code>.</p>
<p>To convert a string to an <code>enum</code> constant or bitmask, we use the auto-generated function</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> soap_s2T(<span class="keyword">struct</span> soap*, <span class="keyword">const</span> <span class="keywordtype">char</span> *str, <span class="keyword">enum</span> T *val)</div></div><!-- fragment --><p>This function takes the name (or names, space-separated for bitmasks) of the enumeration constant in a string <code>str</code>. Names should be given without the pseudo-scope prefix and without trailing underscores. The function sets <code>val</code> to the corresponding integer enum constant or to a bitmask. The function returns <code>SOAP_OK</code> (zero) on success or an error if the string is not a valid enumeration name.</p>
<p>üîù <a href="#">Back to table of contents</a></p>
<h2><a class="anchor" id="toxsd5"></a>
Numerical types                                                        </h2>
<p>Integer and floating point types are mapped to the equivalent built-in XSD types with the same sign and bit width.</p>
<p>The <code>size_t</code> type is transient (not serializable) because its width is platform dependent. We recommend to use <code>uint64_t</code> instead.</p>
<p>The XML value space of integer types are their decimal representations without loss of precision.</p>
<p>The XML value space of floating point types are their decimal representations. The decimal representations are formatted with the printf format string "%.9G" for floats and the printf format string "%.17lG" for double. To change the format strings, we can assign new strings to the following <code>struct soap</code> context members:</p>
<div class="fragment"><div class="line">soap.float_format       = <span class="stringliteral">&quot;%g&quot;</span>;</div><div class="line">soap.double_format      = <span class="stringliteral">&quot;%lg&quot;</span>;</div><div class="line">soap.long_double_format = <span class="stringliteral">&quot;%Lg&quot;</span>;</div></div><!-- fragment --><p>Note that decimal representations may result in a loss of precision of the least significant decimal. Therefore, the format strings that are used by default are sufficiently precise to avoid loss, but this may result in long decimal fractions in the XML value space.</p>
<p>The <code>long double</code> extended floating point type requires a custom serializer:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#import &quot;custom/long_double.h&quot;</span></div><div class="line">... use <span class="keywordtype">long</span> <span class="keywordtype">double</span> ...</div></div><!-- fragment --><p>You can now use <code>long double</code>, which has a serializer that serializes this type as <code>xsd:decimal</code>. Compile and link your code with <code>custom/long_double.c</code>.</p>
<p>The value space of floating point values includes the special values <code>INF</code>, <code>-INF</code>, and <code>NaN</code>. You can check a value for plus or minus infinity and not-a-number as follows:</p>
<div class="fragment"><div class="line">soap_isinf(x) &amp;&amp; x &gt; 0 <span class="comment">// is x INF?</span></div><div class="line">soap_isinf(x) &amp;&amp; x &lt; 0 <span class="comment">// is x -INF?</span></div><div class="line">soap_isnan(x)          <span class="comment">// is x NaN?</span></div></div><!-- fragment --><p>To assign these values, use:</p>
<div class="fragment"><div class="line"><span class="comment">// x is float       // x is double, long double, or __float128</span></div><div class="line">x = FLT_PINFY;      x = DBL_PINFTY;</div><div class="line">x = FLT_NINFY;      x = DBL_NINFTY;</div><div class="line">x = FLT_NAN;        x = DBL_NAN;</div></div><!-- fragment --><p>If your system supports <code>__float128</code> then you can also use this 128 bit floating point type with a custom serializer:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#import &quot;custom/float128.h&quot;</span></div><div class="line">... use xsd__decimal ...</div></div><!-- fragment --><p>Then use the <code>xsd__decimal</code> alias of <code>__float128</code>, which has a serializer. Do not use <code>__float128</code> directly, which is transient (not serializable).</p>
<p>To check for <code>INF</code>, <code>-INF</code>, and <code>NaN</code> of a <code>__float128</code> value use:</p>
<div class="fragment"><div class="line">isinfq(x) &amp;&amp; x &gt; 0 <span class="comment">// is x INF?</span></div><div class="line">isinfq(x) &amp;&amp; x &lt; 0 <span class="comment">// is x -INF?</span></div><div class="line">isnanq(x)          <span class="comment">// is x NaN?</span></div></div><!-- fragment --><p>The range of a typedef-defined numerical type can be restricted using the range <code>:</code> operator with inclusive lower and upper bounds. For example:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keywordtype">int</span> ns__narrow -10 : 10;</div></div><!-- fragment --><p>This maps to a simpleType restriction of <code>xsd:int</code> in the soapcpp2-generated schema:</p>
<div class="alt"> <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;&lt;<span class="keywordtype">simpleType</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;narrow&quot;</span>&gt;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  &lt;<span class="keywordtype">restriction</span> <span class="keyword">base</span>=<span class="stringliteral">&quot;xsd:int&quot;</span>&gt;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    &lt;<span class="keywordtype">minInclusive</span> <span class="keyword">value</span>=<span class="stringliteral">&quot;-10&quot;</span>/&gt;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    &lt;<span class="keywordtype">maxInclusive</span> <span class="keyword">value</span>=<span class="stringliteral">&quot;10&quot;</span>/&gt;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;  &lt;/<span class="keywordtype">restriction</span>&gt;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;&lt;/<span class="keywordtype">simpleType</span>&gt;</div></div><!-- fragment --> </div><p>The lower and upper bound of a range are optional. When omitted, values are not bound from below or from above, respectively.</p>
<p>The range of a floating point typedef-defined type can be restricted within floating point constant bounds.</p>
<p>Also with a floating point typedef a printf format pattern can be given of the form <code>"%[width][.precision]f"</code> to format decimal values using the given width and precision fields:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keywordtype">float</span> ns__PH <span class="stringliteral">&quot;%5.2f&quot;</span> 0.0 : 14.0;</div></div><!-- fragment --><p>This maps to a simpleType restriction of <code>xsd:float</code> in the soapcpp2-generated schema:</p>
<div class="alt"> <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;&lt;<span class="keywordtype">simpleType</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;PH&quot;</span>&gt;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  &lt;<span class="keywordtype">restriction</span> <span class="keyword">base</span>=<span class="stringliteral">&quot;xsd:float&quot;</span>&gt;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    &lt;<span class="keywordtype">totalDigits</span> <span class="keyword">value</span>=<span class="stringliteral">&quot;5&quot;</span>/&gt;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    &lt;<span class="keywordtype">fractionDigits</span> <span class="keyword">value</span>=<span class="stringliteral">&quot;2&quot;</span>/&gt;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    &lt;<span class="keywordtype">minInclusive</span> <span class="keyword">value</span>=<span class="stringliteral">&quot;0&quot;</span>/&gt;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    &lt;<span class="keywordtype">maxInclusive</span> <span class="keyword">value</span>=<span class="stringliteral">&quot;14&quot;</span>/&gt;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;  &lt;/<span class="keywordtype">restriction</span>&gt;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;&lt;/<span class="keywordtype">simpleType</span>&gt;</div></div><!-- fragment --> </div><p>For exclusive bounds, we use the <code>&lt;</code> operator instead of the <code>:</code> range operator:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keywordtype">float</span> ns__epsilon 0.0 &lt; 1.0;</div></div><!-- fragment --><p>Values <code>eps</code> of <code>ns__epsilon</code> are restricted between <code>0.0 &lt; eps &lt; 1.0</code>.</p>
<p>This maps to a simpleType restriction of <code>xsd:float</code> in the soapcpp2-generated schema:</p>
<div class="alt"> <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;&lt;<span class="keywordtype">simpleType</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;epsilon&quot;</span>&gt;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  &lt;<span class="keywordtype">restriction</span> <span class="keyword">base</span>=<span class="stringliteral">&quot;xsd:float&quot;</span>&gt;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    &lt;<span class="keywordtype">minExclusive</span> <span class="keyword">value</span>=<span class="stringliteral">&quot;0&quot;</span>/&gt;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    &lt;<span class="keywordtype">maxExclusive</span> <span class="keyword">value</span>=<span class="stringliteral">&quot;1&quot;</span>/&gt;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;  &lt;/<span class="keywordtype">restriction</span>&gt;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;&lt;/<span class="keywordtype">simpleType</span>&gt;</div></div><!-- fragment --> </div><p>To make just one of the bounds exclusive, while keeping the other bound inclusive, we add a <code>&lt;</code> on the left or on the right side of the range ':' operator. For example:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keywordtype">float</span> ns__pos 0.0 &lt; : ; <span class="comment">// 0.0 &lt; pos</span></div><div class="line"><span class="keyword">typedef</span> <span class="keywordtype">float</span> ns__neg : &lt; 0.0 ; <span class="comment">// neg &lt; 0.0</span></div></div><!-- fragment --><p>It is valid to make both left and right side exclusive with <code>&lt; : &lt;</code> which is in fact identical to the exlusive range <code>&lt;</code> operator:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keywordtype">float</span> ns__epsilon 0.0 &lt; : &lt; 1.0; <span class="comment">// 0.0 &lt; eps &lt; 1.0</span></div></div><!-- fragment --><p>It helps to think of the <code>:</code> as a placeholder of the value between the two bounds, which is easier to memorize than the shorthand forms of bounds from which the <code>:</code> is removed:</p>
<table class="doxtable">
<tr>
<th>Bounds </th><th>Validation Check </th><th>Shorthand  </th></tr>
<tr>
<td>1 : </td><td>1 &lt;= x </td><td>1 </td></tr>
<tr>
<td>1 : 10 </td><td>1 &lt;= x &lt;= 10 </td><td></td></tr>
<tr>
<td>: 10 </td><td>x &lt;= 10 </td><td></td></tr>
<tr>
<td>1 &lt; : &lt; 10 </td><td>1 &lt; x &lt; 10 </td><td>1 &lt; 10 </td></tr>
<tr>
<td>1 : &lt; 10 </td><td>1 &lt;= x &lt; 10 </td><td></td></tr>
<tr>
<td>: &lt; 10 </td><td>x &lt; 10 </td><td>&lt; 10 </td></tr>
<tr>
<td>1 &lt; : </td><td>1 &lt; x </td><td>1 &lt; </td></tr>
<tr>
<td>1 &lt; : 10 </td><td>1 &lt; x &lt;= 10 </td><td></td></tr>
</table>
<p>Besides <code>float</code>, also <code>double</code> and <code>long double</code> values can be restricted. For example, consider a nonzero probability extended floating point precision type:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#import &quot;custom/long_double.h&quot;</span></div><div class="line"><span class="keyword">typedef</span> <span class="keywordtype">long</span> <span class="keywordtype">double</span> ns__probability <span class="stringliteral">&quot;%16Lg&quot;</span> 0.0 &lt; : 1.0;</div></div><!-- fragment --><p>Value range restrictions are validated by the parser for all inbound XML data. A type fault <code>SOAP_TYPE</code> will be thrown by the deserializer if the value is out of range.</p>
<p>Finally, if your system supports <code>__int128_t</code> then you can also use this 128 bit integer type with a custom serializer:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#import &quot;custom/int128.h&quot;</span></div><div class="line">... use xsd__integer ...</div></div><!-- fragment --><p>Use the <code>xsd__integer</code> alias of <code>__int128_t</code>, which has a serializer. Do not use <code>__int128_t</code> directly, which is transient (not serializable).</p>
<p>To convert numeric values to a string, we use the auto-generated function for numeric type <code>T</code>:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> *soap_T2s(<span class="keyword">struct</span> soap*, T val)</div></div><!-- fragment --><p>For numeric types <code>T</code>, the string returned is stored in an internal buffer of the current <code>soap</code> context, so you MUST copy it to keep it from being overwritten. For example, use <code>char *soap_strdup(struct soap*, const char*)</code>.</p>
<p>To convert a string to a numeric value, we use the auto-generated function</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> soap_s2T(<span class="keyword">struct</span> soap*, <span class="keyword">const</span> <span class="keywordtype">char</span> *str, T *val)</div></div><!-- fragment --><p>where <code>T</code> is for example <code>int</code>, <code>LONG64</code>, <code>float</code>, <code>decimal</code> (the custom serializer name of <code>long double</code>) or <code>xsd__integer</code> (the custom serializer name of <code>__int128_t</code>). The function <code>soap_s2T</code> returns <code>SOAP_OK</code> on success or an error when the value is not numeric. For floating point types, "INF", "-INF" and "NaN" are valid strings to convert to numbers.</p>
<p>üîù <a href="#">Back to table of contents</a></p>
<h2><a class="anchor" id="toxsd6"></a>
String types                                                           </h2>
<p>String types are mapped to the built-in <code>xsd:string</code> and <code>xsd:QName</code> XSD types.</p>
<p>The wide strings <code>wchar_t*</code> and <code>std::wstring</code> may contain Unicode that is preserved in the XML value space.</p>
<p>Strings <code>char*</code> and <code>std::string</code> can only contain extended Latin, but we can store UTF-8 content that is preserved in the XML value space when the <code>struct soap</code> context is initialized with the flag <code>SOAP_C_UTFSTRING</code>.</p>
<dl class="section warning"><dt>Warning</dt><dd>Beware that many XML 1.0 parsers reject all control characters (those between <code>#x1</code> and <code>#x1F</code>) except for <code>#x9</code>, <code>#xA</code>, and <code>#xD</code>. With the newer XML 1.1 version parsers (including gSOAP) you should be fine.</dd></dl>
<p>The length of a string of a typedef-defined string type can be restricted:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> std::string ns__password 6 : 16;</div></div><!-- fragment --><p>which maps to a simpleType restriction of <code>xsd:string</code> in the soapcpp2-generated schema:</p>
<div class="alt"> <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;&lt;<span class="keywordtype">simpleType</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;password&quot;</span>&gt;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  &lt;<span class="keywordtype">restriction</span> <span class="keyword">base</span>=<span class="stringliteral">&quot;xsd:string&quot;</span>&gt;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    &lt;<span class="keywordtype">minLength</span> <span class="keyword">value</span>=<span class="stringliteral">&quot;6&quot;</span>/&gt;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    &lt;<span class="keywordtype">maxLength</span> <span class="keyword">value</span>=<span class="stringliteral">&quot;16&quot;</span>/&gt;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;  &lt;/<span class="keywordtype">restriction</span>&gt;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;&lt;/<span class="keywordtype">simpleType</span>&gt;</div></div><!-- fragment --> </div><p>String length restrictions are validated by the parser for inbound XML data. A value length fault <code>SOAP_LENGTH</code> will be thrown by the deserializer if the string is too long or too short.</p>
<p>In addition, an XSD regex pattern restriction can be associated with a string typedef:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> std::string ns__password <span class="stringliteral">&quot;([a-zA-Z]|[0-9]|-)+&quot;</span> 6 : 16;</div></div><!-- fragment --><p>which maps to a simpleType restriction of <code>xsd:string</code> in the soapcpp2-generated schema:</p>
<div class="alt"> <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;&lt;<span class="keywordtype">simpleType</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;password&quot;</span>&gt;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  &lt;<span class="keywordtype">restriction</span> <span class="keyword">base</span>=<span class="stringliteral">&quot;xsd:string&quot;</span>&gt;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    &lt;<span class="keywordtype">pattern</span> <span class="keyword">value</span>=<span class="stringliteral">&quot;([a-zA-Z0-9]|-)+&quot;</span>/&gt;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    &lt;<span class="keywordtype">minLength</span> <span class="keyword">value</span>=<span class="stringliteral">&quot;6&quot;</span>/&gt;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    &lt;<span class="keywordtype">maxLength</span> <span class="keyword">value</span>=<span class="stringliteral">&quot;16&quot;</span>/&gt;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;  &lt;/<span class="keywordtype">restriction</span>&gt;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;&lt;/<span class="keywordtype">simpleType</span>&gt;</div></div><!-- fragment --> </div><p>Pattern restrictions are validated by the parser for inbound XML data only if the <code>soap::fsvalidate</code> and <code>soap::fwvalidate</code> callbacks are defined, see the <a href="http://www.genivia.com/doc/soapdoc2.html">gSOAP user guide.</a></p>
<p>Exclusive length bounds can be used with strings:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> std::string ns__string255 : &lt; 256; <span class="comment">// same as 0 : 255</span></div></div><!-- fragment --><p>Fixed-size strings (<code>char[N]</code>) are rare occurrences in the wild, but apparently still used in some projects to store strings. To facilitate fixed-size string serialization, use soapcpp2 option <code>-b</code>. For example:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keywordtype">char</span> ns__buffer[10]; <span class="comment">// requires soapcpp2 option -b</span></div></div><!-- fragment --><p>which maps to a simpleType restriction of <code>xsd:string</code> in the soapcpp2-generated schema:</p>
<div class="alt"> <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;&lt;<span class="keywordtype">simpleType</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;buffer&quot;</span>&gt;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  &lt;<span class="keywordtype">restriction</span> <span class="keyword">base</span>=<span class="stringliteral">&quot;xsd:string&quot;</span>&gt;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    &lt;<span class="keywordtype">maxLength</span> <span class="keyword">value</span>=<span class="stringliteral">&quot;9&quot;</span>/&gt;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;  &lt;/<span class="keywordtype">restriction</span>&gt;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;&lt;/<span class="keywordtype">simpleType</span>&gt;</div></div><!-- fragment --> </div><p>Note that fixed-size strings MUST contain NUL-terminated text and SHOULD NOT contain raw binary data. Also, the length limitation is more restrictive for UTF-8 content (enabled with the <code>SOAP_C_UTFSTRING</code>) that requires multibyte character encodings. As a consequence, UTF-8 content may be truncated to fit.</p>
<p>Note that raw binary data can be stored in a <code>xsd__base64Binary</code> or <code>xsd__hexBinary</code> structure, or transmitted as a MIME attachment.</p>
<p>The built-in <code>_QName</code> type is a regular C string type (<code>char*</code>) that maps to <code>xsd:QName</code> but has the added advantage that it holds normalized qualified names. There are actually two forms of normalized QName content, to ensure any QName is represented accurately and uniquely:</p>
<div class="fragment"><div class="line"><span class="stringliteral">&quot;prefix:name&quot;</span></div><div class="line"><span class="stringliteral">&quot;\&quot;URI\&quot;:name&quot;</span></div></div><!-- fragment --><p>The first form of string is used when the prefix (and the binding URI) is defined in the namespace table and is bound to a URI (see the .nsmap file). The second form is used when the URI is not defined in the namespace table and therefore no prefix is available to bind and normalize the URI to.</p>
<p>A <code>_QName</code> string may contain a sequence of space-separated QName values, not just one, and all QName values are normalized to the format shown above.</p>
<p>To define a <code>std::string</code> base type for <code>xsd:QName</code>, we use a typedef:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> std::string xsd__QName;</div></div><!-- fragment --><p>The <code>xsd__QName</code> string content is normalized, just as with the <code>_QName</code> normalization.</p>
<p>To serialize strings that contain literal XML content to be reproduced in the XML value space, use the built-in <code>_XML</code> string type, which is a regular C string type (<code>char*</code>) that maps to plain XML CDATA.</p>
<p>To define a <code>std::string</code> base type for literal XML content, use a typedef:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> std::string XML;</div></div><!-- fragment --><p>Strings can hold any of the values of the XSD built-in primitive types. We can use a string typedef to declare the use of the string type as a XSD built-in type:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> std::string xsd__token;</div></div><!-- fragment --><p>You MUST ensure that the string values we populate in this type conform to the XML standard, which in case of <code>xsd:token</code> is the lexical and value spaces of <code>xsd:token</code> are the sets of all strings after whitespace replacement of any occurrence of <code>#x9</code>, <code>#xA</code> , and <code>#xD</code> by <code>#x20</code> and collapsing.</p>
<p>As of version 2.8.49, the gSOAP parser will automatically collapse or replace the white space content when receiving data for XSD types that require white space collapsed or replaced. This normalization is applied to strings directly. The decision to collapse or replace is based on the <code>typedef</code> name corresponding to the built-in string-based XSD type.</p>
<p>To copy <code>char*</code> or <code>wchar_t*</code> strings with a context that manages the allocated memory, use functions</p>
<div class="fragment"><div class="line"><span class="keywordtype">char</span> *soap_strdup(<span class="keyword">struct</span> soap*, <span class="keyword">const</span> <span class="keywordtype">char</span>*)</div><div class="line">wchar_t *soap_wstrdup(struct soap*, const <span class="keywordtype">wchar_t</span>*)</div></div><!-- fragment --><p>To convert a wide string to a UTF-8 encoded string, use function</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>* SOAP_FMAC2 soap_wchar2s(<span class="keyword">struct</span> soap*, <span class="keyword">const</span> <span class="keywordtype">wchar_t</span> *s)</div></div><!-- fragment --><p>The function allocates and returns a string, with its memory being managed by the context.</p>
<p>To convert a UTF-8 encoded string to a wide string, use function</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> soap_s2wchar(<span class="keyword">struct</span> soap*, <span class="keyword">const</span> <span class="keywordtype">char</span> *from, <span class="keywordtype">wchar_t</span> **to, <span class="keywordtype">long</span> minlen, <span class="keywordtype">long</span> maxlen)</div></div><!-- fragment --><p>where <code>to</code> is set to point to an allocated <code>wchar_t*</code> string. Pass <code>-1</code> for <code>minlen</code> and <code>maxlen</code> to ignore length constraints on the target string. The function returns <code>SOAP_OK</code> or an error when the length constraints are not met.</p>
<p>üîù <a href="#">Back to table of contents</a></p>
<h2><a class="anchor" id="toxsd7"></a>
Date and time types                                                    </h2>
<p>The C/C++ <code>time_t</code> type is mapped to the built-in <code>xsd:dateTime</code> XSD type that represents a date and time within a time zone (typically UTC).</p>
<p>The XML value space contains ISO 8601 Gregorian time instances of the form <code>[-]CCYY-MM-DDThh:mm:ss.sss[Z|(+|-)hh:mm]</code>, where <code>Z</code> is the UTC time zone or a time zone offset <code>(+|-)hh:mm]</code> from UTC is used.</p>
<p>A <code>time_t</code> value is considered and represented in UTC by the serializer.</p>
<p>Because the <code>time_t</code> value range is restricted to dates after 01/01/1970 and before 2038 assuming <code>time_t</code> is a <code>long</code> 32 bit, care must be taken to ensure the range of <code>xsd:dateTime</code> values in XML exchanges do not exceed the <code>time_t</code> range.</p>
<p>This restriction does not hold for <code>struct tm</code> (<code>&lt;time.h&gt;</code>), which we can use to store and exchange a date and time in UTC without date range restrictions. The serializer uses the <code>struct tm</code> members directly for the XML value space of <code>xsd:dateTime</code>:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>tm</div><div class="line">{</div><div class="line">  <span class="keywordtype">int</span>    tm_sec;   <span class="comment">// seconds (0 - 60)</span></div><div class="line">  <span class="keywordtype">int</span>    tm_min;   <span class="comment">// minutes (0 - 59)</span></div><div class="line">  <span class="keywordtype">int</span>    tm_hour;  <span class="comment">// hours (0 - 23)</span></div><div class="line">  <span class="keywordtype">int</span>    tm_mday;  <span class="comment">// day of month (1 - 31)</span></div><div class="line">  <span class="keywordtype">int</span>    tm_mon;   <span class="comment">// month of year (0 - 11)</span></div><div class="line">  <span class="keywordtype">int</span>    tm_year;  <span class="comment">// year - 1900</span></div><div class="line">  <span class="keywordtype">int</span>    tm_wday;  <span class="comment">// day of week (Sunday = 0) (NOT USED)</span></div><div class="line">  <span class="keywordtype">int</span>    tm_yday;  <span class="comment">// day of year (0 - 365) (NOT USED)</span></div><div class="line">  <span class="keywordtype">int</span>    tm_isdst; <span class="comment">// is summer time in effect?</span></div><div class="line">  <span class="keywordtype">char</span>*  tm_zone;  <span class="comment">// abbreviation of timezone (NOT USED)</span></div><div class="line">};</div></div><!-- fragment --><p>You will lose the day of the week information. It is always Sunday (<code>tm_wday=0</code>) and the day of the year is not set either. The time zone is UTC.</p>
<p>This <code>struct tm</code> type is mapped to the built-in <code>xsd:dateTime</code> XSD type and serialized with the custom serializer <code>custom/struct_tm.h</code> that declares a <code>xsd__dateTime</code> type:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#import &quot;custom/struct_tm.h&quot;</span> <span class="comment">// import typedef struct tm xsd__dateTime;</span></div><div class="line">... use xsd__dateTime ...</div></div><!-- fragment --><p>Compile and link your code with <code>custom/struct_tm.c</code>.</p>
<p>The <code>struct timeval</code> (<code>&lt;sys/time.h&gt;</code>) type is mapped to the built-in <code>xsd:dateTime</code> XSD type and serialized with the custom serializer <code>custom/struct_timeval.h</code> that declares a <code>xsd__dateTime</code> type:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#import &quot;custom/struct_timeval.h&quot;</span> <span class="comment">// import typedef struct timeval xsd__dateTime;</span></div><div class="line">... use xsd__dateTime ...</div></div><!-- fragment --><p>Compile and link your code with <code>custom/struct_timeval.c</code>.</p>
<p>Note that the same value range restrictions apply to <code>struct timeval</code> as they apply to <code>time_t</code>. The added benefit of <code>struct timeval</code> is the addition of a microsecond-precise clock:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>timeval</div><div class="line">{</div><div class="line">  time_t       tv_sec;  <span class="comment">// seconds since Jan. 1, 1970</span></div><div class="line">  suseconds_t  tv_usec; <span class="comment">// and microseconds</span></div><div class="line">};</div></div><!-- fragment --><p>A C++11 <code>std::chrono::system_clock::time_point</code> type is mapped to the built-in <code>xsd:dateTime</code> XSD type and serialized with the custom serializer <code>custom/chrono_time_point.h</code> that declares a <code>xsd__dateTime</code> type:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#import &quot;custom/chrono_time_point.h&quot;</span> <span class="comment">// import typedef std::chrono::system_clock::time_point xsd__dateTime;</span></div><div class="line">... use xsd__dateTime ...</div></div><!-- fragment --><p>Compile and link your code with <code>custom/chrono_time_point.cpp</code>.</p>
<p>The <code>struct tm</code> type is mapped to the built-in <code>xsd:date</code> XSD type and serialized with the custom serializer <code>custom/struct_tm_date.h</code> that declares a <code>xsd__date</code> type:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#import &quot;custom/struct_tm_date.h&quot;</span> <span class="comment">// import typedef struct tm xsd__date;</span></div><div class="line">... use xsd__date ...</div></div><!-- fragment --><p>Compile and link your code with <code>custom/struct_tm_date.c</code>.</p>
<p>The XML value space of <code>xsd:date</code> are Gregorian calendar dates of the form <code>[-]CCYY-MM-DD[Z|(+|-)hh:mm]</code> with a time zone.</p>
<p>The serializer ignores the time part and the deserializer only populates the date part of the struct, setting the time to 00:00:00. There is no unreasonable limit on the date range because the year field is stored as an integer (<code>int</code>).</p>
<p>An <code>unsigned long long</code> (<code>ULONG64</code> or <code>uint64_t</code>) type that contains a 24 hour time in microseconds UTC is mapped to the built-in <code>xsd:time</code> XSD type and serialized with the custom serializer <code>custom/long_time.h</code> that declares a <code>xsd__time</code> type:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#import &quot;custom/long_time.h&quot;</span> <span class="comment">// import typedef unsigned long long xsd__time;</span></div><div class="line">... use xsd__time ...</div></div><!-- fragment --><p>Compile and link your code with <code>custom/long_time.c</code>.</p>
<p>This type represents <code>00:00:00.000000</code> to <code>23:59:59.999999</code>, from 0 to an upper bound of 86,399,999,999. A microsecond resolution means that a 1 second increment requires an increment of 1,000,000 in the integer value.</p>
<p>The XML value space of <code>xsd:time</code> are points in time recurring each day of the form <code>hh:mm:ss.sss[Z|(+|-)hh:mm]</code>, where <code>Z</code> is the UTC time zone or a time zone offset from UTC is used. The <code>xsd__time</code> value is always considered and represented in UTC by the serializer.</p>
<p>To convert date and/or time values to a string, we use the auto-generated function for type <code>T</code>:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> *soap_T2s(<span class="keyword">struct</span> soap*, T val)</div></div><!-- fragment --><p>For date and time types <code>T</code>, the string returned is stored in an internal buffer of the current <code>soap</code> context, so you MUST copy it to keep it from being overwritten. For example, use <code>char *soap_strdup(struct soap*, const char*)</code>.</p>
<p>To convert a string to a date/time value, we use the auto-generated function</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> soap_s2T(<span class="keyword">struct</span> soap*, <span class="keyword">const</span> <span class="keywordtype">char</span> *str, T *val)</div></div><!-- fragment --><p>where <code>T</code> is for example <code>dateTime</code> (for <code>time_t</code>), <code>xsd__dateTime</code> (for <code>struct tm</code>, <code>struct timeval</code>, or <code>std::chrono::system_clock::time_point</code>). The function <code>soap_s2T</code> returns <code>SOAP_OK</code> on success or an error when the value is not a date/time.</p>
<p>üîù <a href="#">Back to table of contents</a></p>
<h2><a class="anchor" id="toxsd8"></a>
Time duration types                                                    </h2>
<p>The XML value space of <code>xsd:duration</code> are values of the form <code>PnYnMnDTnHnMnS</code> where the capital letters are delimiters. Delimiters may be omitted when the corresponding member is not used.</p>
<p>A <code>long long</code> (<code>LONG64</code> or <code>int64_t</code>) type that contains a duration (time lapse) in milliseconds is mapped to the built-in <code>xsd:duration</code> XSD type and serialized with the custom serializer <code>custom/duration.h</code> that declares a <code>xsd__duration</code> type:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#import &quot;custom/duration.h&quot;</span> <span class="comment">// import typedef long long xsd__duration;</span></div><div class="line">... use xsd__duration ...</div></div><!-- fragment --><p>Compile and link your code with <code>custom/duration.c</code>.</p>
<p>The duration type <code>xsd__duration</code> can represent 106,751,991,167 days forward and backward with millisecond precision.</p>
<p>Durations that exceed a month are always output in days, rather than months to avoid days-per-month conversion inacurracies.</p>
<p>Durations that are received in years and months instead of total number of days from a reference point are not well defined, since there is no accepted reference time point (it may or may not be the current time). The decoder simple assumes that there are 30 days per month. For example, conversion of "P4M" gives 120 days. Therefore, the durations "P4M" and "P120D" are assumed to be identical, which is not necessarily true depending on the reference point in time.</p>
<p>Rescaling of the duration value by may be needed when adding the duration value to a <code>time_t</code> value, because <code>time_t</code> may or may not have a seconds resolution, depending on the platform and possible changes to <code>time_t</code>.</p>
<p>Rescaling is done automatically when you add a C++11 <code>std::chrono::nanoseconds</code> value to a <code>std::chrono::system_clock::time_point</code> value. To use <code>std::chrono::nanoseconds</code> as <code>xsd:duration</code>:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#import &quot;custom/chrono_duration.h&quot;</span> <span class="comment">// import typedef std::chrono::duration xsd__duration;</span></div><div class="line">... use xsd__duration ...</div></div><!-- fragment --><p>Compile and link your code with <code>custom/chrono_duration.cpp</code>.</p>
<p>This type can represent 384,307,168 days (2^63 nanoseconds) forwards and backwards in time in increments of 1 ns (1/1000000000 second).</p>
<p>The same observations with respect to receiving durations in years and months apply to this serializer's decoder.</p>
<p>To convert duration values to a string, we use the auto-generated function</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> *soap_xsd__duration2s(<span class="keyword">struct</span> soap*, xsd__duration val)</div></div><!-- fragment --><p>The string returned is stored in an internal buffer, so you MUST copy it to keep it from being overwritten, Use <code>soap_strdup(struct soap*, const char*)</code> for example to copy this string.</p>
<p>To convert a string to a duration value, we use the auto-generated function</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> soap_s2xsd__dateTime(<span class="keyword">struct</span> soap*, <span class="keyword">const</span> <span class="keywordtype">char</span> *str, xsd__dateTime *val)</div></div><!-- fragment --><p>The function returns <code>SOAP_OK</code> on success or an error when the value is not a duration.</p>
<p>üîù <a href="#">Back to table of contents</a></p>
<h2><a class="anchor" id="toxsd9"></a>
Classes and structs                                                    </h2>
<p>Classes and structs are mapped to XSD complexTypes. The XML value space consists of XML elements with attributes and subelements, possibly constrained by XML schema validation rules that enforce element and attribute occurrence contraints, numerical value range constraints, and string length and pattern constraints.</p>
<p>Classes that are declared with the gSOAP tools are limited to single inheritence only. Structs cannot be inherited.</p>
<p>The class and struct name is bound to an XML namespace by means of the prefix naming convention or by using <a href="#toxsd1">colon notation</a>:</p>
<div class="fragment"><div class="line"><span class="comment">//gsoap ns schema namespace: urn:types</span></div><div class="line"><span class="keyword">class </span>ns__record</div><div class="line">{</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  std::string  name;</div><div class="line">  uint64_t     SSN;</div><div class="line">  ns__record  *spouse;</div><div class="line">  ns__record();</div><div class="line">  ~ns__record();</div><div class="line"> <span class="keyword">protected</span>:</div><div class="line">  <span class="keyword">struct </span>soap  *soap;</div><div class="line">};</div></div><!-- fragment --><p>In the example above, we also added a context pointer to the <code>struct soap</code> that manages this instance. It is set when the instance is created in the engine's context, for example when deserialized and populated by the engine.</p>
<p>The class maps to a complexType in the soapcpp2-generated schema:</p>
<div class="alt"> <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;&lt;<span class="keywordtype">complexType</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;record&quot;</span>&gt;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  &lt;<span class="keywordtype">sequence</span>&gt;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    &lt;<span class="keywordtype">element</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;name&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;xsd:string&quot;</span> <span class="keyword">minOccurs</span>=<span class="stringliteral">&quot;1&quot;</span> <span class="keyword">maxOccurs</span>=<span class="stringliteral">&quot;1&quot;</span>/&gt;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    &lt;<span class="keywordtype">element</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;SSN&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;xsd:unsignedLong&quot;</span> <span class="keyword">minOccurs</span>=<span class="stringliteral">&quot;1&quot;</span> <span class="keyword">maxOccurs</span>=<span class="stringliteral">&quot;1&quot;</span>/&gt;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    &lt;<span class="keywordtype">element</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;spouse&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;ns:record&quot;</span> <span class="keyword">minOccurs</span>=<span class="stringliteral">&quot;0&quot;</span> <span class="keyword">maxOccurs</span>=<span class="stringliteral">&quot;1&quot;</span> <span class="keyword">nillable</span>=<span class="stringliteral">&quot;true&quot;</span>/&gt;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;  &lt;/<span class="keywordtype">sequence</span>&gt;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;&lt;/<span class="keywordtype">complexType</span>&gt;</div></div><!-- fragment --> </div><p>üîù <a href="#">Back to table of contents</a></p>
<h3><a class="anchor" id="toxsd9-1"></a>
Serializable versus transient types and data members</h3>
<p>Public data members of a class or struct are serialized. Private and protected members are transient and not serializable.</p>
<p>Also <code>const</code> and <code>static</code> members are not serializable, with the exception of <code>const char*</code> and <code>const wchar_t*</code>. Types and specific class/struct members can also be made transient with the <code>extern</code> qualifier:</p>
<div class="fragment"><div class="line"><span class="keyword">extern</span> <span class="keyword">class </span>std::ostream;     <span class="comment">// declare &#39;std::ostream&#39; transient</span></div><div class="line"><span class="keyword">class </span>ns__record</div><div class="line">{</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="keyword">extern</span> <span class="keywordtype">int</span>       num;        <span class="comment">// not serialized</span></div><div class="line">  std::ostream     out;        <span class="comment">// not serialized</span></div><div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> MAX = 1024; <span class="comment">// not serialized</span></div><div class="line">};</div></div><!-- fragment --><p>By declaring <code>std::ostream</code> transient with <code>extern</code> you can use this type wherever you need it without soapcpp2 complaining that this class is not defined.</p>
<p>üîù <a href="#">Back to table of contents</a></p>
<h3><a class="anchor" id="toxsd9-2"></a>
Volatile classes and structs</h3>
<p>Classes and structs can be declared <code>volatile</code> with the gSOAP tools. This means that they are already declared elsewhere in your project's source code and you do not want soapcpp2 to generate code with a second declaration of these types.</p>
<p>For example, <code>struct tm</code> is declared in <code>&lt;time.h&gt;</code>. You can make it serializable and include a partial list of data members that you want to serialize:</p>
<div class="fragment"><div class="line"><span class="keyword">volatile</span> <span class="keyword">struct </span>tm</div><div class="line">{</div><div class="line">  <span class="keywordtype">int</span>    tm_sec;    <span class="comment">// seconds (0 - 60)</span></div><div class="line">  <span class="keywordtype">int</span>    tm_min;    <span class="comment">// minutes (0 - 59)</span></div><div class="line">  <span class="keywordtype">int</span>    tm_hour;   <span class="comment">// hours (0 - 23)</span></div><div class="line">  <span class="keywordtype">int</span>    tm_mday;   <span class="comment">// day of month (1 - 31)</span></div><div class="line">  <span class="keywordtype">int</span>    tm_mon;    <span class="comment">// month of year (0 - 11)</span></div><div class="line">  <span class="keywordtype">int</span>    tm_year;   <span class="comment">// year - 1900</span></div><div class="line">};</div></div><!-- fragment --><p>You can declare classes and structs <code>volatile</code> for any such types you want to serialize by only providing the public data members you want to serialize.</p>
<p>In addition, <a href="#toxsd2">colon notation</a> is a simple and effective way to bind an existing class or struct to a schema. For example, you can change the <code>tm</code> name as follows without affecting the code that uses <code>struct tm</code> generated by soapcpp2:</p>
<div class="fragment"><div class="line"><span class="keyword">volatile</span> <span class="keyword">struct </span>ns:tm { ... }</div></div><!-- fragment --><p>This struct maps to a complexType in the soapcpp2-generated schema:</p>
<div class="alt"> <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;&lt;<span class="keywordtype">complexType</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;tm&quot;</span>&gt;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  &lt;<span class="keywordtype">sequence</span>&gt;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    &lt;<span class="keywordtype">element</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;tm-sec&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;xsd:int&quot;</span> <span class="keyword">minOccurs</span>=<span class="stringliteral">&quot;1&quot;</span> <span class="keyword">maxOccurs</span>=<span class="stringliteral">&quot;1&quot;</span>/&gt;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    &lt;<span class="keywordtype">element</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;tm-min&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;xsd:int&quot;</span> <span class="keyword">minOccurs</span>=<span class="stringliteral">&quot;1&quot;</span> <span class="keyword">maxOccurs</span>=<span class="stringliteral">&quot;1&quot;</span>/&gt;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    &lt;<span class="keywordtype">element</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;tm-hour&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;xsd:int&quot;</span> <span class="keyword">minOccurs</span>=<span class="stringliteral">&quot;1&quot;</span> <span class="keyword">maxOccurs</span>=<span class="stringliteral">&quot;1&quot;</span>/&gt;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    &lt;<span class="keywordtype">element</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;tm-mday&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;xsd:int&quot;</span> <span class="keyword">minOccurs</span>=<span class="stringliteral">&quot;1&quot;</span> <span class="keyword">maxOccurs</span>=<span class="stringliteral">&quot;1&quot;</span>/&gt;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    &lt;<span class="keywordtype">element</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;tm-mon&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;xsd:int&quot;</span> <span class="keyword">minOccurs</span>=<span class="stringliteral">&quot;1&quot;</span> <span class="keyword">maxOccurs</span>=<span class="stringliteral">&quot;1&quot;</span>/&gt;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    &lt;<span class="keywordtype">element</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;tm-year&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;xsd:int&quot;</span> <span class="keyword">minOccurs</span>=<span class="stringliteral">&quot;1&quot;</span> <span class="keyword">maxOccurs</span>=<span class="stringliteral">&quot;1&quot;</span>/&gt;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;  &lt;/<span class="keywordtype">sequence</span>&gt;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;&lt;/<span class="keywordtype">complexType</span>&gt;</div></div><!-- fragment --> </div><p>üîù <a href="#">Back to table of contents</a></p>
<h3><a class="anchor" id="toxsd9-3"></a>
Mutable classes and structs</h3>
<p>Classes and structs can be declared <code>mutable</code> with the gSOAP tools. This means that their definition can be spread out over the source code. This promotes the concept of a class or struct as a <em>row of named values</em>, also known as a <em>named tuple</em>, that can be extended at compile time in your source code with additional members. Because these types differ from the traditional object-oriented principles and design concepts of classes and objects, constructors and destructors cannot be defined (also because we cannot guarantee merging these into one such that all members will be initialized). A default constructor, copy constructor, assignment operation, and destructor will be assigned automatically by soapcpp2.</p>
<div class="fragment"><div class="line"><span class="keyword">mutable</span> <span class="keyword">struct </span>ns__tuple</div><div class="line">{</div><div class="line">  @std::string  id;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">mutable</span> <span class="keyword">struct </span>ns__tuple</div><div class="line">{</div><div class="line">  std::string  name;</div><div class="line">  std::string  value;</div><div class="line">};</div></div><!-- fragment --><p>The members are collected into one definition generated by soapcpp2. Members may be repeated from one definition to another, but only if their associated types are identical. So, for example, a third extension with a <code>value</code> member with a different type fails:</p>
<div class="fragment"><div class="line"><span class="keyword">mutable</span> <span class="keyword">struct </span>ns__tuple</div><div class="line">{</div><div class="line">  <span class="keywordtype">float</span>        value; <span class="comment">// BAD: value is already declared std::string</span></div><div class="line">};</div></div><!-- fragment --><p>The <code>mutable</code> concept has proven to be very useful when declaring and collecting SOAP Headers for multiple services, which are collected into one <code>struct <a class="el" href="struct_s_o_a_p___e_n_v_____header.html">SOAP_ENV__Header</a></code> by the soapcpp2 tool.</p>
<p>üîù <a href="#">Back to table of contents</a></p>
<h3><a class="anchor" id="toxsd9-4"></a>
Default and fixed member values</h3>
<p>Class and struct data members in C and C++ may be declared with an optional default initialization value that is provided "inline" with the declaration of the member:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>ns__record</div><div class="line">{</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  std::string name = <span class="stringliteral">&quot;Joe&quot;</span>;</div><div class="line">  ...</div><div class="line">};</div></div><!-- fragment --><p>Alternatively, use C++11 default initialization syntax:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>ns__record</div><div class="line">{</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  std::string name { <span class="stringliteral">&quot;Joe&quot;</span> };</div><div class="line">  ...</div><div class="line">};</div></div><!-- fragment --><p>These initializations are made by the default constructor that is added by soapcpp2 to each class and struct (in C++ only). A constructor is only added when a default constructor is not already defined with the class declaration.</p>
<p>You can explicitly (re)initialize an object with these initial values by using the soapcpp2 auto-generated functions:</p>
<ul>
<li><code>void T::soap_default(struct soap*)</code> for <code>class T</code> (C++ only)</li>
<li><code>void soap_default_T(struct soap*, T*)</code> for <code>struct T</code> (C and C++).</li>
</ul>
<p>Default value initializations can be provided for members that have primitive types (<code>bool</code>, <code>enum</code>, <code>time_t</code>, numeric and string types).</p>
<p>Default value initializations of pointer members is permitted, but the effect is different. To conform to XML schema validation, an attribute member that is a pointer to a primitive type will be assigned the default value when parsed from XML. An element member that is a pointer to a primitive type will be assigned when the element is empty when parsed from XML.</p>
<p>As of gSOAP 2.8.48 and greater, a fixed value can be assigned with a <code>==</code>. A fixed value is also verified by the parser's validator.</p>
<p>Default and fixed values for members with or without pointers are best explained with the following two example fragments.</p>
<p>A record class (can be a struct in C) with default values for attributes and elements is declared as follows:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>ns__record_with_default</div><div class="line">{</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  @std::string  a   = <span class="stringliteral">&quot;A&quot;</span>; <span class="comment">// optional XML attribute with default value &quot;A&quot;</span></div><div class="line">  @std::string  b 1 = <span class="stringliteral">&quot;B&quot;</span>; <span class="comment">// required XML attribute with default value &quot;B&quot;</span></div><div class="line">  @std::string *c   = <span class="stringliteral">&quot;C&quot;</span>; <span class="comment">// optional XML attribute with default value &quot;C&quot;</span></div><div class="line">   std::string  d 0 = <span class="stringliteral">&quot;D&quot;</span>; <span class="comment">// optional XML element with default value &quot;D&quot;</span></div><div class="line">   std::string  e   = <span class="stringliteral">&quot;E&quot;</span>; <span class="comment">// required XML element with default value &quot;E&quot;</span></div><div class="line">   std::string *f   = <span class="stringliteral">&quot;F&quot;</span>; <span class="comment">// optional XML element with default value &quot;F&quot;</span></div><div class="line">  ...</div><div class="line">};</div></div><!-- fragment --><p>Note that attributes are optional unless marked as required with the occurrence constraint <code>1</code>. Elements are required unless the member type is a pointer or if the member is marked optional with occurrence constraint <code>0</code>.</p>
<p>Instead of default values, fixed values indicate that the attribute or element must contain that value, and only that value, when provided in XML. A fixed value is specified with a <code>==</code>.</p>
<p>A record class (can be a struct in C) with fixed values for attributes and elements is declared as follows:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>ns__record_with_fixed</div><div class="line">{</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  @std::string  <a class="code" href="classg.html">g</a>   == <span class="stringliteral">&quot;G&quot;</span>; <span class="comment">// optional XML attribute with fixed value &quot;G&quot;</span></div><div class="line">  @std::string  h 1 == <span class="stringliteral">&quot;H&quot;</span>; <span class="comment">// required XML attribute with fixed value &quot;H&quot;</span></div><div class="line">  @std::string *i   == <span class="stringliteral">&quot;I&quot;</span>; <span class="comment">// optional XML attribute with fixed value &quot;I&quot;</span></div><div class="line">   std::string  j 0 == <span class="stringliteral">&quot;J&quot;</span>; <span class="comment">// optional XML element with fixed value &quot;J&quot;</span></div><div class="line">   std::string  k   == <span class="stringliteral">&quot;K&quot;</span>; <span class="comment">// required XML element with fixed value &quot;K&quot;</span></div><div class="line">   std::string *l   == <span class="stringliteral">&quot;L&quot;</span>; <span class="comment">// optional XML element with fixed value &quot;L&quot;</span></div><div class="line">  ...</div><div class="line">};</div></div><!-- fragment --><p>The XML schema validation rules for the two example classes above are as follows:</p>
<table class="doxtable">
<tr>
<th>Member </th><th>Notes  </th></tr>
<tr>
<td><code>a</code> </td><td>attribute may appear once; if it does not appear its value is "A", otherwise its value is that given (also note: instantiating <code>ns__record_with_default</code> assigns the default value "A") </td></tr>
<tr>
<td><code>b</code> </td><td>has no effect when parsing XML (but note: instantiating <code>ns__record_with_default</code> assigns the default value "B") </td></tr>
<tr>
<td><code>c</code> </td><td>attribute may appear once; if it does not appear its value is "C", otherwise its value is that given (also note: instantiating <code>ns__record_with_default</code> assigns NULL) </td></tr>
<tr>
<td><code>d</code> </td><td>element may appear once; if it does not appear or if it is empty, its value is "D"; otherwise its value is that given (also note: instantiating <code>ns__record_with_default</code> assigns the default value "D") </td></tr>
<tr>
<td><code>e</code> </td><td>has no effect when parsing XML (but note: instantiating <code>ns__record_with_default</code> assigns the default value "E") </td></tr>
<tr>
<td><code>f</code> </td><td>element may appear once; if it does not appear it is not provided; if it does appear and it is empty, its value is "F"; otherwise its value is that given (also note: instantiating <code>ns__record_with_default</code> assigns NULL) </td></tr>
<tr>
<td><code>g</code> </td><td>attribute may appear once; if it does not appear its value is "G", if it does not appear its value is "G" (also note: instantiating <code>ns__record_with_fixed</code> assigns the fixed value "G") </td></tr>
<tr>
<td><code>h</code> </td><td>attribute must appear once, its value must be "H" (also note: instantiating <code>ns__record_with_fixed</code> assigns the fixed value "H") </td></tr>
<tr>
<td><code>i</code> </td><td>attribute may appear once; if it does not appear its value is "I", if it does not appear its value is "I" (also note: instantiating <code>ns__record_with_fixed</code> assigns NULL) </td></tr>
<tr>
<td><code>j</code> </td><td>element may appear once, if it does not appear it is not provided; if it does appear and it is empty, its value is "J"; if it does appear and it is not empty, its value must be "J" (also note: instantiating <code>ns__record_with_fixed</code> assigns the fixed value "J") </td></tr>
<tr>
<td><code>k</code> </td><td>element must appear once, its value must be "K" (also note: instantiating <code>ns__record_with_fixed</code> assigns the fixed value "K") </td></tr>
<tr>
<td><code>l</code> </td><td>element may appear once, if it does not appear it is not provided; if it does appear and it is empty, its value is "J"; if it does appear and it is not empty, its value must be "J" (also note: instantiating <code>ns__record_with_fixed</code> assigns NULL) </td></tr>
</table>
<dl class="section see"><dt>See also</dt><dd>Section <a href="#toxsd9-14">operations on classes and structs</a>.</dd></dl>
<p>üîù <a href="#">Back to table of contents</a></p>
<h3><a class="anchor" id="toxsd9-5"></a>
Attribute members and backtick XML tags</h3>
<p>Class and struct data members are declared as XML attributes by annotating their type with a <code>@</code> qualifier:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>ns__record</div><div class="line">{</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  @std::string name;   <span class="comment">// required (non-pointer means required)</span></div><div class="line">  @uint64_t    SSN;    <span class="comment">// required (non-pointer means required)</span></div><div class="line">  ns__record  *spouse; <span class="comment">// optional (pointer means minOccurs=0)</span></div><div class="line">};</div></div><!-- fragment --><p>This class maps to a complexType in the soapcpp2-generated schema:</p>
<div class="alt"> <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;&lt;<span class="keywordtype">complexType</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;record&quot;</span>&gt;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  &lt;<span class="keywordtype">sequence</span>&gt;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    &lt;<span class="keywordtype">element</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;spouse&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;ns:record&quot;</span> <span class="keyword">minOccurs</span>=<span class="stringliteral">&quot;0&quot;</span> <span class="keyword">maxOccurs</span>=<span class="stringliteral">&quot;1&quot;</span> <span class="keyword">nillable</span>=<span class="stringliteral">&quot;true&quot;</span>/&gt;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;  &lt;/<span class="keywordtype">sequence</span>&gt;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;  &lt;<span class="keywordtype">attribute</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;name&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;xsd:string&quot;</span> <span class="keyword">use</span>=<span class="stringliteral">&quot;required&quot;</span>/&gt;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;  &lt;<span class="keywordtype">attribute</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;SSN&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;xsd:unsignedLong&quot;</span> <span class="keyword">use</span>=<span class="stringliteral">&quot;required&quot;</span>/&gt;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;&lt;/<span class="keywordtype">complexType</span>&gt;</div></div><!-- fragment --> </div><p>An example XML instance of <code>ns__record</code> is:</p>
<div class="alt"> <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;&lt;<span class="keywordtype">ns:record</span> <span class="keyword">xmlns:ns</span>=<span class="stringliteral">&quot;urn:types&quot;</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;Joe&quot;</span> <span class="keyword">SSN</span>=<span class="stringliteral">&quot;1234567890&quot;</span>&gt;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  &lt;<span class="keywordtype">spouse</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;Jane&quot;</span> <span class="keyword">SSN</span>=<span class="stringliteral">&quot;1987654320&quot;</span>&gt;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  &lt;/<span class="keywordtype">spouse</span>&gt;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;&lt;/<span class="keywordtype">ns:record</span>&gt;</div></div><!-- fragment --> </div><p>Attribute data members are restricted to primitive types (<code>bool</code>, <code>enum</code>, <code>time_t</code>, numeric and string types), <code>xsd__hexBinary</code>, <code>xsd__base64Binary</code>, and custom serializers, such as <code>xsd__dateTime</code>. Custom serializers for types that may be used as attributes MUST define <code>soap_s2T</code> and <code>soap_T2s</code> functions that convert values of type <code>T</code> to strings and back.</p>
<p>Attribute data members can be pointers and smart pointers to these types, which permits attributes to be optional.</p>
<p>The XML tag name of a class/struct member is the name of the member with the usual XML tag translation, see <a href="#toxsd2">colon notation</a>.</p>
<p>To override the standard translation of identifier names to XML tag names of attributes and elements, add the XML tag name in backticks (requires gSOAP 2.8.30 and later versions):</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>ns__record</div><div class="line">{</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  @std::string name    `full-name`;</div><div class="line">  @uint64_t    SSN     `tax-<span class="keywordtype">id</span>`;</div><div class="line">  ns__record  *spouse  `married-to`;</div><div class="line">};</div></div><!-- fragment --><p>This class maps to a complexType in the soapcpp2-generated schema:</p>
<div class="alt"> <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;&lt;<span class="keywordtype">complexType</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;record&quot;</span>&gt;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  &lt;<span class="keywordtype">sequence</span>&gt;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    &lt;<span class="keywordtype">element</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;married-to&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;ns:record&quot;</span> <span class="keyword">minOccurs</span>=<span class="stringliteral">&quot;0&quot;</span> <span class="keyword">maxOccurs</span>=<span class="stringliteral">&quot;1&quot;</span>/&gt;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;  &lt;/<span class="keywordtype">sequence</span>&gt;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;  &lt;<span class="keywordtype">attribute</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;full-name&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;xsd:string&quot;</span> <span class="keyword">use</span>=<span class="stringliteral">&quot;required&quot;</span>/&gt;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;  &lt;<span class="keywordtype">attribute</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;tax-id&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;xsd:unsignedLong&quot;</span> <span class="keyword">use</span>=<span class="stringliteral">&quot;required&quot;</span>/&gt;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;&lt;/<span class="keywordtype">complexType</span>&gt;</div></div><!-- fragment --> </div><p>An example XML instance of <code>ns__record</code> is:</p>
<div class="alt"> <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;&lt;<span class="keywordtype">ns:record</span> <span class="keyword">xmlns:ns</span>=<span class="stringliteral">&quot;urn:types&quot;</span> <span class="keyword">full-name</span>=<span class="stringliteral">&quot;Joe&quot;</span> <span class="keyword">tax-id</span>=<span class="stringliteral">&quot;1234567890&quot;</span>&gt;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  &lt;<span class="keywordtype">married-to</span> <span class="keyword">full-name</span>=<span class="stringliteral">&quot;Jane&quot;</span> <span class="keyword">tax-id</span>=<span class="stringliteral">&quot;1987654320&quot;</span>&gt;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  &lt;/<span class="keywordtype">married-to</span>&gt;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;&lt;/<span class="keywordtype">ns:record</span>&gt;</div></div><!-- fragment --> </div><p>A backtick XML tag name may contain any non-empty sequence of ASCII and UTF-8 characters except white space and the backtick character. A backtick tag can be combined with member constraints and default member initializers: </p><pre class="fragment">@uint64_t SSN `tax-id` 0:1 = 999;
</pre><p>üîù <a href="#">Back to table of contents</a></p>
<h3><a class="anchor" id="toxsd9-6"></a>
Qualified and unqualified members</h3>
<p>Class, struct, and union data members are mapped to namespace qualified or unqualified tag names of local elements and attributes. If a data member has no prefix then the default form of qualification is applied based on the element/attribute form that is declared with the schema of the class, struct, or union type. If the member name has a namespace prefix by colon notation, then the prefix overrules the default (un)qualified form. Therefore, <a href="#toxsd2">colon notation</a> is an effective mechanism to control qualification of tag names of individual members of classes, structs, and unions.</p>
<p>The XML schema elementFormDefault and attributeFormDefault declarations control the tag name qualification of local elements and attributes, respectively.</p>
<ul>
<li>"unqualified" indicates that local elements/attributes are not qualified with the namespace prefix.</li>
<li>"qualified" indicates that local elements/attributes must be qualified with the namespace prefix.</li>
</ul>
<p>Individual schema declarations of local elements and attributes may overrule this by using the form declaration in a schema and by using colon notation to add namespace prefixes to class, struct, and union members in the header file for soapcpp2.</p>
<p>Consider for example an <code>ns__record</code> class in the <code>ns</code> namespace in which local elements are qualified and local attributes are unqualified by default:</p>
<div class="fragment"><div class="line"><span class="comment">//gsoap ns schema namespace:     urn:types</span></div><div class="line"><span class="comment">//gsoap ns schema elementForm:   qualified</span></div><div class="line"><span class="comment">//gsoap ns schema attributeForm: unqualified</span></div><div class="line"><span class="keyword">class </span>ns__record</div><div class="line">{</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  @std::string name;</div><div class="line">  @uint64_t    SSN;</div><div class="line">  ns__record  *spouse;</div><div class="line">};</div></div><!-- fragment --><p>This class maps to a complexType in the soapcpp2-generated schema with targetNamespace "urn:types", elementFormDefault qualified and attributeFormDefault unqualified:</p>
<div class="alt"> <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;&lt;<span class="keywordtype">schema</span> <span class="keyword">targetNamespace</span>=<span class="stringliteral">&quot;urn:types&quot;</span></div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  ...</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  <span class="keyword">elementFormDefault</span>=<span class="stringliteral">&quot;qualified&quot;</span></div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;  <span class="keyword">attributeFormDefault</span>=<span class="stringliteral">&quot;unqualified&quot;</span></div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;  ...  &gt;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;  &lt;<span class="keywordtype">complexType</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;record&quot;</span>&gt;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    &lt;<span class="keywordtype">sequence</span>&gt;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;      &lt;<span class="keywordtype">element</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;spouse&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;ns:record&quot;</span> <span class="keyword">minOccurs</span>=<span class="stringliteral">&quot;0&quot;</span> <span class="keyword">maxOccurs</span>=<span class="stringliteral">&quot;1&quot;</span>/&gt;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;    &lt;/<span class="keywordtype">sequence</span>&gt;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    &lt;<span class="keywordtype">attribute</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;name&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;xsd:string&quot;</span> <span class="keyword">use</span>=<span class="stringliteral">&quot;required&quot;</span>/&gt;</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;    &lt;<span class="keywordtype">attribute</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;SSN&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;xsd:unsignedLong&quot;</span> <span class="keyword">use</span>=<span class="stringliteral">&quot;required&quot;</span>/&gt;</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;  &lt;/<span class="keywordtype">complexType</span>&gt;</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;&lt;/<span class="keywordtype">schema</span>&gt;</div></div><!-- fragment --> </div><p>An example XML instance of <code>ns__record</code> is:</p>
<div class="alt"> <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;&lt;<span class="keywordtype">ns:record</span> <span class="keyword">xmlns:ns</span>=<span class="stringliteral">&quot;urn:types&quot;</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;Joe&quot;</span> <span class="keyword">SSN</span>=<span class="stringliteral">&quot;1234567890&quot;</span>&gt;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  &lt;<span class="keywordtype">ns:spouse</span>&gt; <span class="keyword">name</span>=<span class="stringliteral">&quot;Jane&quot;</span> <span class="keyword">SSN</span>=<span class="stringliteral">&quot;1987654320&quot;</span>&gt;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  &lt;/<span class="keywordtype">ns:spouse</span>&gt;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;&lt;/<span class="keywordtype">ns:record</span>&gt;</div></div><!-- fragment --> </div><p>Note that the root element <code>&lt;ns:record&gt;</code> is qualified because it is a root element of the schema with target namespace "urn:types". Its local element <code>&lt;ns:spouse&gt;</code> is namespace qualified because the elementFormDefault of local elements is qualified. Attributes are unqualified.</p>
<p>The default namespace (un)qualification of local elements and attributes can be overruled by adding a prefix to the member name by using colon notation:</p>
<div class="fragment"><div class="line"><span class="comment">//gsoap ns schema namespace:     urn:types</span></div><div class="line"><span class="comment">//gsoap ns schema elementForm:   qualified</span></div><div class="line"><span class="comment">//gsoap ns schema attributeForm: unqualified</span></div><div class="line"><span class="keyword">class </span>ns__record</div><div class="line">{</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  @std::string ns:name; <span class="comment">// &#39;ns:&#39; qualified</span></div><div class="line">  @uint64_t    SSN;</div><div class="line">  ns__record  *:spouse; <span class="comment">// &#39;:&#39; unqualified (empty prefix)</span></div><div class="line">};</div></div><!-- fragment --><p>The colon notation for member <code>ns:name</code> forces qualification of its attribute tag in XML. The colon notation for member <code>:spouse</code> removes qualification from its local element tag:</p>
<div class="alt"> <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;&lt;<span class="keywordtype">schema</span> <span class="keyword">targetNamespace</span>=<span class="stringliteral">&quot;urn:types&quot;</span></div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  ...</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  <span class="keyword">elementFormDefault</span>=<span class="stringliteral">&quot;unqualified&quot;</span></div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;  <span class="keyword">attributeFormDefault</span>=<span class="stringliteral">&quot;unqualified&quot;</span></div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;  ... &gt;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;  &lt;<span class="keywordtype">complexType</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;record&quot;</span>&gt;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    &lt;<span class="keywordtype">sequence</span>&gt;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;      &lt;<span class="keywordtype">element</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;spouse&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;ns:record&quot;</span> <span class="keyword">minOccurs</span>=<span class="stringliteral">&quot;0&quot;</span> <span class="keyword">maxOccurs</span>=<span class="stringliteral">&quot;1&quot;</span> <span class="keyword">form</span>=<span class="stringliteral">&quot;unqualified&quot;</span>/&gt;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;    &lt;/<span class="keywordtype">sequence</span>&gt;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    &lt;<span class="keywordtype">attribute</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;name&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;xsd:string&quot;</span> <span class="keyword">use</span>=<span class="stringliteral">&quot;required&quot;</span> <span class="keyword">form</span>=<span class="stringliteral">&quot;qualified&quot;</span>/&gt;</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;    &lt;<span class="keywordtype">attribute</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;SSN&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;xsd:unsignedLong&quot;</span> <span class="keyword">use</span>=<span class="stringliteral">&quot;required&quot;</span>/&gt;</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;  &lt;/<span class="keywordtype">complexType</span>&gt;</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;&lt;/<span class="keywordtype">schema</span>&gt;</div></div><!-- fragment --> </div><p>XML instances of <code>ns__record</code> have unqualified spouse elements and qualified ns:name attributes:</p>
<div class="alt"> <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;&lt;<span class="keywordtype">ns:record</span> <span class="keyword">xmlns:ns</span>=<span class="stringliteral">&quot;urn:types&quot;</span> <span class="keyword">ns:name</span>=<span class="stringliteral">&quot;Joe&quot;</span> <span class="keyword">SSN</span>=<span class="stringliteral">&quot;1234567890&quot;</span>&gt;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  &lt;<span class="keywordtype">spouse</span>&gt; <span class="keyword">ns:name</span>=<span class="stringliteral">&quot;Jane&quot;</span> <span class="keyword">SSN</span>=<span class="stringliteral">&quot;1987654320&quot;</span>&gt;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  &lt;/<span class="keywordtype">spouse</span>&gt;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;&lt;/<span class="keywordtype">ns:record</span>&gt;</div></div><!-- fragment --> </div><p>Note that data members can also be prefixed using the <code>prefix__name</code> convention. However, this has a different effect by referring to global (root) elements and attributes, see <a href="#toxsd9-7">document root element definitions</a>.</p>
<p><a href="#toxsd9-5">Backtick tag names</a> can be used in place of the member name annotations and will achieve the same effect as described when these tag names are (un)qualified (requires gSOAP 2.8.30 and later versions).</p>
<dl class="section note"><dt>Note</dt><dd>You must declare a target namespace with a <code>//gsoap ns schema namespace:</code> directive to enable the <code>elementForm</code> and <code>attributeForm</code> directives in order to generate valid schemas with soapcpp2. See <a href="#directives">directives</a> for more details.</dd></dl>
<p>üîù <a href="#">Back to table of contents</a></p>
<h3><a class="anchor" id="toxsd9-7"></a>
Defining document root elements</h3>
<p>To define and reference XML document root elements we use type names that start with an underscore:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>_ns__record</div></div><!-- fragment --><p>Alternatively, we can use a typedef to define a document root element with a given type:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> ns__record _ns__record;</div></div><!-- fragment --><p>This typedef maps to a global root element that is added to the soapcpp2-generated schema:</p>
<div class="alt"> <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;&lt;<span class="keywordtype">element</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;record&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;ns:record&quot;</span>/&gt;</div></div><!-- fragment --> </div><p>An example XML instance of <code>_ns__record</code> is:</p>
<div class="alt"> <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;&lt;<span class="keywordtype">ns:record</span> <span class="keyword">xmlns:ns</span>=<span class="stringliteral">&quot;urn:types&quot;</span>&gt;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  &lt;<span class="keywordtype">name</span>&gt;<span class="keyword">Joe</span>&lt;/<span class="keywordtype">name</span>&gt;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  &lt;<span class="keywordtype">SSN</span>&gt;1234567890&lt;/<span class="keywordtype">SSN</span>&gt;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;  &lt;<span class="keywordtype">spouse</span>&gt;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    &lt;<span class="keywordtype">name</span>&gt;<span class="keyword">Jane</span>&lt;/<span class="keywordtype">name</span>&gt;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    &lt;<span class="keywordtype">SSN</span>&gt;1987654320&lt;/<span class="keywordtype">SSN</span>&gt;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;  &lt;/<span class="keywordtype">spouse</span>&gt;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;&lt;/<span class="keywordtype">ns:record</span>&gt;</div></div><!-- fragment --> </div><p>Global-level element/attribute definitions are also referenced and/or added to the generated schema when serializable data members reference these by their qualified name:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> std::string _ns__name 1 : 100;</div><div class="line"><span class="keyword">class </span>_ns__record</div><div class="line">{</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  @<a class="code" href="address_stub_8h.html#aa178a46d0cf703ff226a5c148483286d">_QName</a>      xsi__type; <span class="comment">// built-in XSD attribute xsi:type</span></div><div class="line">  _ns__name    ns__name;  <span class="comment">// ref to global ns:name element</span></div><div class="line">  uint64_t     SSN;</div><div class="line">  _ns__record *spouse;</div><div class="line">};</div></div><!-- fragment --><p>These types map to the following comonents in the soapcpp2-generated schema:</p>
<div class="alt"> <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;&lt;<span class="keywordtype">simpleType</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;name&quot;</span>&gt;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  &lt;<span class="keywordtype">restriction</span> <span class="keyword">base</span>=<span class="stringliteral">&quot;xsd:string&quot;</span>&gt;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    &lt;<span class="keywordtype">minLength</span> <span class="keyword">value</span>=<span class="stringliteral">&quot;1&quot;</span>/&gt;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    &lt;<span class="keywordtype">maxLength</span> <span class="keyword">value</span>=<span class="stringliteral">&quot;100&quot;</span>/&gt;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;  &lt;/<span class="keywordtype">restriction</span>&gt;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;&lt;/<span class="keywordtype">simpleType</span>&gt;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;&lt;<span class="keywordtype">element</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;name&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;ns:name&quot;</span>/&gt;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;&lt;<span class="keywordtype">complexType</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;record&quot;</span>&gt;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;  &lt;<span class="keywordtype">sequence</span>&gt;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    &lt;<span class="keywordtype">element</span> <span class="keyword">ref</span>=<span class="stringliteral">&quot;ns:name&quot;</span> <span class="keyword">minOccurs</span>=<span class="stringliteral">&quot;1&quot;</span> <span class="keyword">maxOccurs</span>=<span class="stringliteral">&quot;1&quot;</span>/&gt;</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;    &lt;<span class="keywordtype">element</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;SSN&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;xsd:unsignedLong&quot;</span> <span class="keyword">minOccurs</span>=<span class="stringliteral">&quot;1&quot;</span> <span class="keyword">maxOccurs</span>=<span class="stringliteral">&quot;1&quot;</span>/&gt;</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;    &lt;<span class="keywordtype">element</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;spouse&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;ns:record&quot;</span> <span class="keyword">minOccurs</span>=<span class="stringliteral">&quot;0&quot;</span> <span class="keyword">maxOccurs</span>=<span class="stringliteral">&quot;1&quot;</span>/&gt;</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;  &lt;/<span class="keywordtype">sequence</span>&gt;</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;  &lt;<span class="keywordtype">attribute</span> <span class="keyword">ref</span>=<span class="stringliteral">&quot;xsi:type&quot;</span> <span class="keyword">use</span>=<span class="stringliteral">&quot;optional&quot;</span>/&gt;</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;&lt;/<span class="keywordtype">complexType</span>&gt;</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;&lt;<span class="keywordtype">element</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;record&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;ns:record&quot;</span>/&gt;</div></div><!-- fragment --> </div><p>Use only use qualified member names when their types match the global-level element types that they refer to. For example:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> std::string _ns__name; <span class="comment">// global element ns:name of type xsd:string</span></div><div class="line"><span class="keyword">class </span>_ns__record</div><div class="line">{</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="keywordtype">int</span>          ns__name;       <span class="comment">// BAD: global element ns:name is NOT type int</span></div><div class="line">  _ns__record  ns__record;     <span class="comment">// OK: ns:record is a global-level root element</span></div><div class="line">  ...</div><div class="line">};</div></div><!-- fragment --><p>Therefore, we recommend to use qualified member names only when necessary to refer to standard XSD elements and attributes, such as <code>xsi__type</code>, and <code>xsd__lang</code>.</p>
<p>By contrast, colon notation has the desired effect to (un)qualify local tag names by overruling the default element/attribute namespace qualification, see <a href="#toxsd9-6">qualified and unqualified members</a>.</p>
<p>As an alternative to prefixing member names, use the backtick tag (requires gSOAP 2.8.30 and later versions):</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> std::string _ns__name 1 : 100;</div><div class="line"><span class="keyword">class </span>_ns__record</div><div class="line">{</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  @<a class="code" href="address_stub_8h.html#aa178a46d0cf703ff226a5c148483286d">_QName</a>      t    `xsi:type`; <span class="comment">// built-in XSD attribute xsi:type</span></div><div class="line">  _ns__name    s    `ns:name`;  <span class="comment">// ref to global ns:name element</span></div><div class="line">  uint64_t     SSN;</div><div class="line">  _ns__record *spouse;</div><div class="line">};</div></div><!-- fragment --><p>üîù <a href="#">Back to table of contents</a></p>
<h3><a class="anchor" id="toxsd9-8"></a>
(Smart) pointer members and their occurrence constraints</h3>
<p>A public pointer-typed data member is serialized by following its (smart) pointer(s) to the value pointed to. To serialize pointers to dynamic arrays of data, please see the next section on <a href="#toxsd9-9">container and array members and their occurrence constraints</a>.</p>
<p>Pointers that are NULL and smart pointers that are empty are serialized to produce omitted element and attribute values, unless an element is required and is nillable (struct/class members marked with <code>nullptr</code>) in which case the element is rendered as an empty element with <code>xsi:nil="true"</code>.</p>
<p>To control the occurrence requirements of pointer-based data members, occurrence constraints are associated with data members in the form of a range <code>minOccurs : maxOccurs</code>. For non-repeatable (meaning, not a container or array) data members, there are only three reasonable occurrence constraints:</p>
<ul>
<li><code>0:0</code> means that this element or attribute is prohibited.</li>
<li><code>0:1</code> means that this element or attribute is optional.</li>
<li><code>1:1</code> means that this element or attribute is required.</li>
</ul>
<p>Pointer-based data members have a default <code>0:1</code> occurrence constraint, making them optional, and their XML schema local element/attribute definition is marked as nillable. Non-pointer data members have a default <code>1:1</code> occurence constraint, making them required.</p>
<p>A <code>nullptr</code> occurrence constraint may be applicable to required elements that are nillable pointer types, thus <code>nullptr 1:1</code>. This indicates that the element is nillable (can be <code>NULL</code> or <code>nullptr</code>). A pointer data member that is explicitly marked as required and nillable with <code>nullptr 1:1</code> will be serialized as an element with an <code>xsi:nil</code> attribute, thus effectively revealing the NULL property of its value.</p>
<p>A non-pointer data member that is explicitly marked as optional with <code>0:1</code> will be set to its default value when no XML value is presented to the deserializer. A default value can be assigned to a data member that has a primitive type or is a (smart) pointer to primitive type.</p>
<p>Consider for example:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>ns__record</div><div class="line">{</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  std::shared_ptr&lt;std::string&gt;  name;               <span class="comment">// optional (pointer means minOccurs=0)</span></div><div class="line">  uint64_t                      SSN    0:1 = 999;   <span class="comment">// force optional with default 999</span></div><div class="line">  ns__record                   *spouse <span class="keyword">nullptr</span> 1:1; <span class="comment">// force required and nillabe when absent</span></div><div class="line">};</div></div><!-- fragment --><p>This class maps to a complexType in the soapcpp2-generated schema:</p>
<div class="alt"> <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;&lt;<span class="keywordtype">complexType</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;record&quot;</span>&gt;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  &lt;<span class="keywordtype">sequence</span>&gt;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    &lt;<span class="keywordtype">element</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;name&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;xsd:string&quot;</span> <span class="keyword">minOccurs</span>=<span class="stringliteral">&quot;0&quot;</span> <span class="keyword">maxOccurs</span>=<span class="stringliteral">&quot;1&quot;</span> <span class="keyword">nillable</span>=<span class="stringliteral">&quot;true&quot;</span>/&gt;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    &lt;<span class="keywordtype">element</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;SSN&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;xsd:unsignedLong&quot;</span> <span class="keyword">minOccurs</span>=<span class="stringliteral">&quot;0&quot;</span> <span class="keyword">maxOccurs</span>=<span class="stringliteral">&quot;1&quot;</span> <span class="keyword">default</span>=<span class="stringliteral">&quot;999&quot;</span>/&gt;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    &lt;<span class="keywordtype">element</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;spouse&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;ns:record&quot;</span> <span class="keyword">minOccurs</span>=<span class="stringliteral">&quot;1&quot;</span> <span class="keyword">maxOccurs</span>=<span class="stringliteral">&quot;1&quot;</span> <span class="keyword">nillable</span>=<span class="stringliteral">&quot;true&quot;</span>/&gt;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;  &lt;/<span class="keywordtype">sequence</span>&gt;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;&lt;/<span class="keywordtype">complexType</span>&gt;</div></div><!-- fragment --> </div><p>An example XML instance of <code>ns__record</code> with its <code>name</code> string value set to <code>Joe</code>, <code>SSN</code> set to its default, and <code>spouse</code> set to NULL:</p>
<div class="alt"> <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;&lt;<span class="keywordtype">ns:record</span> <span class="keyword">xmlns:ns</span>=<span class="stringliteral">&quot;urn:types&quot;</span> ...&gt;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  &lt;<span class="keywordtype">name</span>&gt;<span class="keyword">Joe</span>&lt;/<span class="keywordtype">name</span>&gt;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  &lt;<span class="keywordtype">SSN</span>&gt;999&lt;/<span class="keywordtype">SSN</span>&gt;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;  &lt;<span class="keywordtype">spouse</span> <span class="keyword">xsi:nil</span>=<span class="stringliteral">&quot;true&quot;</span>/&gt;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;&lt;/<span class="keywordtype">ns:record</span>&gt;</div></div><!-- fragment --> </div><dl class="section note"><dt>Note</dt><dd>In general, a smart pointer is simply declared as a <code>volatile</code> template in a gSOAP header file for soapcpp2:</dd></dl>
<div class="fragment"><div class="line"><span class="keyword">volatile</span> <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; <span class="keyword">class </span>NAMESPACE::shared_ptr;</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The soapcpp2 tool generates code that uses <code>NAMESPACE::shared_ptr</code> and <code>NAMESPACE::make_shared</code> to create shared pointers to objects, where <code>NAMESPACE</code> is any valid C++ namespace such as <code>std</code> and <code>boost</code> if you have Boost installed.</dd></dl>
<p>üîù <a href="#">Back to table of contents</a></p>
<h3><a class="anchor" id="toxsd9-9"></a>
Container and array members and their occurrence constraints</h3>
<p>Class and struct data member types that are containers <code>std::deque</code>, <code>std::list</code>, <code>std::vector</code> and <code>std::set</code> are serialized as a collection of the values they contain. You can also serialize dynamic arrays, which is the alternative for C to store collections of data. Let's start with STL containers.</p>
<p>You can use <code>std::deque</code>, <code>std::list</code>, <code>std::vector</code>, and <code>std::set</code> containers by importing:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#import &quot;import/stl.h&quot;</span>       <span class="comment">// import all containers</span></div><div class="line"><span class="preprocessor">#import &quot;import/stldeque.h&quot;</span>  <span class="comment">// import deque</span></div><div class="line"><span class="preprocessor">#import &quot;import/stllist.h&quot;</span>   <span class="comment">// import list</span></div><div class="line"><span class="preprocessor">#import &quot;import/stlvector.h&quot;</span> <span class="comment">// import vector</span></div><div class="line"><span class="preprocessor">#import &quot;import/stlset.h&quot;</span>    <span class="comment">// import set</span></div></div><!-- fragment --><p>For example, to use a vector data mamber to store names in a record:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#import &quot;import/stlvector.h&quot;</span></div><div class="line"><span class="keyword">class </span>ns__record</div><div class="line">{</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  std::vector&lt;std::string&gt;  names;</div><div class="line">  uint64_t                  SSN;</div><div class="line">};</div></div><!-- fragment --><p>To limit the number of names in the vector within reasonable bounds, occurrence constraints are associated with the container. Occurrence constraints are of the form <code>minOccurs : maxOccurs</code>:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#import &quot;import/stlvector.h&quot;</span></div><div class="line"><span class="keyword">class </span>ns__record</div><div class="line">{</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  std::vector&lt;std::string&gt;  names 1:10;</div><div class="line">  uint64_t                  SSN;</div><div class="line">};</div></div><!-- fragment --><p>This class maps to a complexType in the soapcpp2-generated schema:</p>
<div class="alt"> <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;&lt;<span class="keywordtype">complexType</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;record&quot;</span>&gt;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  &lt;<span class="keywordtype">sequence</span>&gt;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    &lt;<span class="keywordtype">element</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;name&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;xsd:string&quot;</span> <span class="keyword">minOccurs</span>=<span class="stringliteral">&quot;1&quot;</span> <span class="keyword">maxOccurs</span>=<span class="stringliteral">&quot;10&quot;</span>/&gt;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    &lt;<span class="keywordtype">element</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;SSN&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;xsd:unsignedLong&quot;</span> <span class="keyword">minOccurs</span>=<span class="stringliteral">&quot;1&quot;</span> <span class="keyword">maxOccurs</span>=<span class="stringliteral">&quot;1&quot;</span>&quot;/&gt;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;  &lt;/<span class="keywordtype">sequence</span>&gt;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;&lt;/<span class="keywordtype">complexType</span>&gt;</div></div><!-- fragment --> </div><dl class="section note"><dt>Note</dt><dd>In general, a container is simply declared as a template in a gSOAP header file for soapcpp2. All class templates are considered containers (except when declared <code>volatile</code>, see smart pointers). For example, <code>std::vector</code> is declared in <code>gsoap/import/stlvector.h</code> as:</dd></dl>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; <span class="keyword">class </span>std::vector;</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>You can define and use your own containers. The soapcpp2 tool generates code that uses the following members of the <code>template &lt;typename T&gt; class C</code> container:</dd></dl>
<div class="fragment"><div class="line"><span class="keywordtype">void</span>              C::clear()</div><div class="line">C::iterator       C::begin()</div><div class="line">C::const_iterator C::begin() const</div><div class="line">C::iterator       C::end()</div><div class="line">C::const_iterator C::end() const</div><div class="line"><span class="keywordtype">size_t</span>            C::size() const</div><div class="line">C::iterator       C::insert(C::iterator pos, const T&amp; val)</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>For more details see the example <code>simple_vector</code> container with documentation in the package under <code>gsoap/samples/template</code>.</dd></dl>
<p>Because C does not support a container template library, we can use a dynamically-sized array of values. This array is declared as a size-pointer pair of members within a struct or class. The array size information is stored in a special size tag member with the name <code>__size</code> or <code>__sizeX</code>, where <code>X</code> can be any name, or by an <code>$int</code> member to identify the member as a special size tag:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>ns__record</div><div class="line">{</div><div class="line">  $int      sizeofnames; <span class="comment">// array size</span></div><div class="line">  <span class="keywordtype">char</span>*    *names;       <span class="comment">// array of char* names</span></div><div class="line">  uint64_t  SSN;</div><div class="line">};</div></div><!-- fragment --><p>This struct maps to a complexType in the soapcpp2-generated schema:</p>
<div class="alt"> <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;&lt;<span class="keywordtype">complexType</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;record&quot;</span>&gt;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  &lt;<span class="keywordtype">sequence</span>&gt;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    &lt;<span class="keywordtype">element</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;name&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;xsd:string&quot;</span> <span class="keyword">minOccurs</span>=<span class="stringliteral">&quot;0&quot;</span> <span class="keyword">maxOccurs</span>=<span class="stringliteral">&quot;unbounded&quot;</span> <span class="keyword">nillable</span>=<span class="stringliteral">&quot;true&quot;</span>/&gt;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    &lt;<span class="keywordtype">element</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;SSN&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;xsd:unsignedLong&quot;</span> <span class="keyword">minOccurs</span>=<span class="stringliteral">&quot;1&quot;</span> <span class="keyword">maxOccurs</span>=<span class="stringliteral">&quot;1&quot;</span>&quot;/&gt;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;  &lt;/<span class="keywordtype">sequence</span>&gt;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;&lt;/<span class="keywordtype">complexType</span>&gt;</div></div><!-- fragment --> </div><p>To limit the number of names in the array within reasonable bounds, occurrence constraints are associated with the array size member. Occurrence constraints are of the form <code>minOccurs : maxOccurs</code>:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>ns__record</div><div class="line">{</div><div class="line">  $int      sizeofnames 1:10; <span class="comment">// array size 1..10</span></div><div class="line">  <span class="keywordtype">char</span>*    *names;            <span class="comment">// array of one to ten char* names</span></div><div class="line">  uint64_t  SSN;</div><div class="line">};</div></div><!-- fragment --><p>This struct maps to a complexType in the soapcpp2-generated schema:</p>
<div class="alt"> <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;&lt;<span class="keywordtype">complexType</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;record&quot;</span>&gt;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  &lt;<span class="keywordtype">sequence</span>&gt;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    &lt;<span class="keywordtype">element</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;name&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;xsd:string&quot;</span> <span class="keyword">minOccurs</span>=<span class="stringliteral">&quot;1&quot;</span> <span class="keyword">maxOccurs</span>=<span class="stringliteral">&quot;10&quot;</span> <span class="keyword">nillable</span>=<span class="stringliteral">&quot;true&quot;</span>/&gt;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    &lt;<span class="keywordtype">element</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;SSN&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;xsd:unsignedLong&quot;</span> <span class="keyword">minOccurs</span>=<span class="stringliteral">&quot;1&quot;</span> <span class="keyword">maxOccurs</span>=<span class="stringliteral">&quot;1&quot;</span>&quot;/&gt;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;  &lt;/<span class="keywordtype">sequence</span>&gt;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;&lt;/<span class="keywordtype">complexType</span>&gt;</div></div><!-- fragment --> </div><p>üîù <a href="#">Back to table of contents</a></p>
<h3><a class="anchor" id="toxsd9-10"></a>
Sequencing with hidden members</h3>
<p>A member becomes a hidden XML element, i.e. not visibly rendered in XML, when its name starts with a double underscore. This makes it possible to sequence a collection of data members, basically by forming a sequence of elements that can be optional or repeated together.</p>
<p>To create a sequence of members that are optional, use a pointer-based hidden member that is a struct with the collection of members to sequence:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>ns__record</div><div class="line">{</div><div class="line">  std::string   name;       <span class="comment">// required name</span></div><div class="line">  <span class="keyword">struct </span>__ns__optional</div><div class="line">  {</div><div class="line">    uint64_t    SSN;        <span class="comment">// SSN in optional group</span></div><div class="line">    std::string phone;      <span class="comment">// phone number in optional group</span></div><div class="line">  }            *__optional; <span class="comment">// optional group</span></div><div class="line">};</div></div><!-- fragment --><p>Note that we used a hidden struct type <code>__ns__optional</code> which starts with a double underscore, because we do not want to define a new global type for the schema we generate. We just need a unique name for a structure that sequences the two members.</p>
<p>This struct maps to a complexType in the soapcpp2-generated schema:</p>
<div class="alt"> <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;&lt;<span class="keywordtype">complexType</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;record&quot;</span>&gt;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  &lt;<span class="keywordtype">sequence</span>&gt;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    &lt;<span class="keywordtype">element</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;name&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;xsd:string&quot;</span> <span class="keyword">minOccurs</span>=<span class="stringliteral">&quot;1&quot;</span> <span class="keyword">maxOccurs</span>=<span class="stringliteral">&quot;1&quot;</span>/&gt;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    &lt;<span class="keywordtype">sequence</span> <span class="keyword">minOccurs</span>=<span class="stringliteral">&quot;0&quot;</span> <span class="keyword">maxOccurs</span>=<span class="stringliteral">&quot;1&quot;</span>&gt;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;      &lt;<span class="keywordtype">element</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;SSN&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;xsd:unsignedLong&quot;</span> <span class="keyword">minOccurs</span>=<span class="stringliteral">&quot;1&quot;</span> <span class="keyword">maxOccurs</span>=<span class="stringliteral">&quot;1&quot;</span>/&gt;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;      &lt;<span class="keywordtype">element</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;phone&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;xsd:string&quot;</span> <span class="keyword">minOccurs</span>=<span class="stringliteral">&quot;1&quot;</span> <span class="keyword">maxOccurs</span>=<span class="stringliteral">&quot;1&quot;</span>/&gt;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    &lt;/<span class="keywordtype">sequence</span>&gt;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;  &lt;/<span class="keywordtype">sequence</span>&gt;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;&lt;/<span class="keywordtype">complexType</span>&gt;</div></div><!-- fragment --> </div><p>Note that the <code>name</code> is a required element of the <code>record</code> complexType. The <code>record</code> complexType has an optional sequence of <code>SSN</code> and <code>phone</code> elements.</p>
<p>To create repetitions of a sequence of members, use an array as follows:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>ns__record</div><div class="line">{</div><div class="line">  std::string   name;        <span class="comment">// required name</span></div><div class="line">  $int          sizeofarray; <span class="comment">// size of group array</span></div><div class="line">  <span class="keyword">struct </span>__ns__array</div><div class="line">  {</div><div class="line">    uint64_t    SSN;         <span class="comment">// SSN in group</span></div><div class="line">    std::string phone;       <span class="comment">// phone number in group</span></div><div class="line">  }            *__array;     <span class="comment">// group array</span></div><div class="line">};</div></div><!-- fragment --><p>This struct maps to a complexType in the soapcpp2-generated schema:</p>
<div class="alt"> <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;&lt;<span class="keywordtype">complexType</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;record&quot;</span>&gt;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  &lt;<span class="keywordtype">sequence</span>&gt;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    &lt;<span class="keywordtype">element</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;name&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;xsd:string&quot;</span> <span class="keyword">minOccurs</span>=<span class="stringliteral">&quot;1&quot;</span> <span class="keyword">maxOccurs</span>=<span class="stringliteral">&quot;1&quot;</span>/&gt;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    &lt;<span class="keywordtype">sequence</span> <span class="keyword">minOccurs</span>=<span class="stringliteral">&quot;0&quot;</span> <span class="keyword">maxOccurs</span>=<span class="stringliteral">&quot;unbounded&quot;</span>&gt;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;      &lt;<span class="keywordtype">element</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;SSN&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;xsd:unsignedLong&quot;</span> <span class="keyword">minOccurs</span>=<span class="stringliteral">&quot;1&quot;</span> <span class="keyword">maxOccurs</span>=<span class="stringliteral">&quot;1&quot;</span>/&gt;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;      &lt;<span class="keywordtype">element</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;phone&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;xsd:string&quot;</span> <span class="keyword">minOccurs</span>=<span class="stringliteral">&quot;1&quot;</span> <span class="keyword">maxOccurs</span>=<span class="stringliteral">&quot;1&quot;</span>/&gt;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    &lt;/<span class="keywordtype">sequence</span>&gt;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;  &lt;/<span class="keywordtype">sequence</span>&gt;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;&lt;/<span class="keywordtype">complexType</span>&gt;</div></div><!-- fragment --> </div><p>Note that the <code>name</code> is a required element of the <code>record</code> complexType. The <code>record</code> complexType has a potentially unbounded sequence of <code>SSN</code> and <code>phone</code> elements. You can specify array bounds instead of zero to unbounded, see <a href="#toxsd9-9">Container and array members and their occurrence constraints</a>.</p>
<p>The XML value space consists of a sequence of SSN and phone elements:</p>
<div class="alt"> <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;&lt;<span class="keywordtype">ns:record</span>&gt;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  &lt;<span class="keywordtype">name</span>&gt;<span class="keyword">numbers</span>&lt;/<span class="keywordtype">name</span>&gt;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  &lt;<span class="keywordtype">SSN</span>&gt;1234567890&lt;/<span class="keywordtype">SSN</span>&gt;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;  &lt;<span class="keywordtype">phone</span>&gt;555-123-4567&lt;/<span class="keywordtype">phone</span>&gt;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;  &lt;<span class="keywordtype">SSN</span>&gt;1987654320&lt;/<span class="keywordtype">SSN</span>&gt;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;  &lt;<span class="keywordtype">phone</span>&gt;555-789-1234&lt;/<span class="keywordtype">phone</span>&gt;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;  &lt;<span class="keywordtype">SSN</span>&gt;2345678901&lt;/<span class="keywordtype">SSN</span>&gt;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;  &lt;<span class="keywordtype">phone</span>&gt;555-987-6543&lt;/<span class="keywordtype">phone</span>&gt;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;&lt;/<span class="keywordtype">ns:record</span>&gt;</div></div><!-- fragment --> </div><p>üîù <a href="#">Back to table of contents</a></p>
<h3><a class="anchor" id="toxsd9-11"></a>
Tagged union members</h3>
<p>A union member in a class or in a struct cannot be serialized unless a discriminating <em>variant selector</em> member is provided that tells the serializer which union field to serialize. This effectively creates a <em>tagged union</em>.</p>
<p>The variant selector is associated with the union as a selector-union pair of members. The variant selector is a member with the name <code>__union</code> or <code>__unionX</code>, where <code>X</code> can be any name, or by an <code>$int</code> member to identify the member as a variant selector tag:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>ns__record</div><div class="line">{</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  $int  xORnORs;    <span class="comment">// variant selector with values SOAP_UNION_fieldname</span></div><div class="line">  <span class="keyword">union </span>ns__choice</div><div class="line">  {</div><div class="line">    <span class="keywordtype">float</span> x;</div><div class="line">    <span class="keywordtype">int</span>   n;</div><div class="line">    <span class="keywordtype">char</span> *s;</div><div class="line">  } u;</div><div class="line">  std::string name;</div><div class="line">};</div></div><!-- fragment --><p>The variant selector values are auto-generated based on the union name <code>choice</code> and the names of its members <code>x</code>, <code>n</code>, and <code>s</code>:</p>
<ul>
<li><code>xORnORs = SOAP_UNION_ns__choice_x</code> when <code>u.x</code> is valid.</li>
<li><code>xORnORs = SOAP_UNION_ns__choice_n</code> when <code>u.n</code> is valid.</li>
<li><code>xORnORs = SOAP_UNION_ns__choice_s</code> when <code>u.s</code> is valid.</li>
<li><code>xORnORs = 0</code> when none are valid (should only be used with great care, because XSD validation may fail when content is required but absent).</li>
</ul>
<p>This class maps to a complexType with a sequence and choice in the soapcpp2-generated schema:</p>
<div class="alt"> <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;&lt;<span class="keywordtype">complexType</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;record&quot;</span>&gt;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  &lt;<span class="keywordtype">sequence</span>&gt;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    &lt;<span class="keywordtype">choice</span>&gt;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;      &lt;<span class="keywordtype">element</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;x&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;xsd:float&quot;</span> <span class="keyword">minOccurs</span>=<span class="stringliteral">&quot;1&quot;</span> <span class="keyword">maxOccurs</span>=<span class="stringliteral">&quot;1&quot;</span>/&gt;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;      &lt;<span class="keywordtype">element</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;n&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;xsd:int&quot;</span> <span class="keyword">minOccurs</span>=<span class="stringliteral">&quot;1&quot;</span> <span class="keyword">maxOccurs</span>=<span class="stringliteral">&quot;1&quot;</span>/&gt;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;      &lt;<span class="keywordtype">element</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;s&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;xsd:string&quot;</span> <span class="keyword">minOccurs</span>=<span class="stringliteral">&quot;0&quot;</span> <span class="keyword">maxOccurs</span>=<span class="stringliteral">&quot;1&quot;</span> <span class="keyword">nillable</span>=<span class="stringliteral">&quot;true&quot;</span>/&gt;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    &lt;/<span class="keywordtype">choice</span>&gt;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    &lt;<span class="keywordtype">element</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;names&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;xsd:string&quot;</span> <span class="keyword">minOccurs</span>=<span class="stringliteral">&quot;1&quot;</span> <span class="keyword">maxOccurs</span>=<span class="stringliteral">&quot;1&quot;</span> <span class="keyword">nillable</span>=<span class="stringliteral">&quot;true&quot;</span>/&gt;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;  &lt;/<span class="keywordtype">sequence</span>&gt;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;&lt;/<span class="keywordtype">complexType</span>&gt;</div></div><!-- fragment --> </div><p>An STL container or dynamic array of a union requires wrapping the variant selector and union member in a struct:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>ns__record</div><div class="line">{</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  std::vector&lt;</div><div class="line">  <span class="keyword">struct </span>ns__data  <span class="comment">// data with a choice of x, n, or s</span></div><div class="line">  {</div><div class="line">    $int  xORnORs; <span class="comment">// variant selector with values SOAP_UNION_fieldname</span></div><div class="line">    <span class="keyword">union </span>ns__choice</div><div class="line">    {</div><div class="line">      <span class="keywordtype">float</span> x;</div><div class="line">      <span class="keywordtype">int</span>   n;</div><div class="line">      <span class="keywordtype">char</span> *s;</div><div class="line">    } u;</div><div class="line">  }&gt; data;         <span class="comment">// vector with data</span></div><div class="line">};</div></div><!-- fragment --><p>and an equivalent definition with a dynamic array instead of a <code>std::vector</code> (you can use this in C with structs):</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>ns__record</div><div class="line">{</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  $int  sizeOfdata; <span class="comment">// size of dynamic array</span></div><div class="line">  <span class="keyword">struct </span>ns__data   <span class="comment">// data with a choice of x, n, or s</span></div><div class="line">  {</div><div class="line">    $int  xORnORs;  <span class="comment">// variant selector with values SOAP_UNION_fieldname</span></div><div class="line">    <span class="keyword">union </span>ns__choice</div><div class="line">    {</div><div class="line">      <span class="keywordtype">float</span> x;</div><div class="line">      <span class="keywordtype">int</span>   n;</div><div class="line">      <span class="keywordtype">char</span> *s;</div><div class="line">    } u;</div><div class="line">  } *data;          <span class="comment">// points to the data array of length sizeOfdata</span></div><div class="line">};</div></div><!-- fragment --><p>This maps to two complexTypes in the soapcpp2-generated schema:</p>
<div class="alt"> <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;&lt;<span class="keywordtype">complexType</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;data&quot;</span>&gt;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  &lt;<span class="keywordtype">choice</span>&gt;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    &lt;<span class="keywordtype">element</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;x&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;xsd:float&quot;</span> <span class="keyword">minOccurs</span>=<span class="stringliteral">&quot;1&quot;</span> <span class="keyword">maxOccurs</span>=<span class="stringliteral">&quot;1&quot;</span>/&gt;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    &lt;<span class="keywordtype">element</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;n&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;xsd:int&quot;</span> <span class="keyword">minOccurs</span>=<span class="stringliteral">&quot;1&quot;</span> <span class="keyword">maxOccurs</span>=<span class="stringliteral">&quot;1&quot;</span>/&gt;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    &lt;<span class="keywordtype">element</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;s&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;xsd:string&quot;</span> <span class="keyword">minOccurs</span>=<span class="stringliteral">&quot;0&quot;</span> <span class="keyword">maxOccurs</span>=<span class="stringliteral">&quot;1&quot;</span> <span class="keyword">nillable</span>=<span class="stringliteral">&quot;true&quot;</span>/&gt;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;  &lt;/<span class="keywordtype">choice</span>&gt;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;&lt;/<span class="keywordtype">complexType</span>&gt;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;&lt;<span class="keywordtype">complexType</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;record&quot;</span>&gt;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;  &lt;<span class="keywordtype">sequence</span>&gt;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    &lt;<span class="keywordtype">element</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;data&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;ns:data&quot;</span> <span class="keyword">minOccurs</span>=<span class="stringliteral">&quot;0&quot;</span> <span class="keyword">maxOccurs</span>=<span class="stringliteral">&quot;unbounded&quot;</span>/&gt;</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;  &lt;/<span class="keywordtype">sequence</span>&gt;</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;&lt;/<span class="keywordtype">complexType</span>&gt;</div></div><!-- fragment --> </div><p>The XML value space consists of a sequence of item elements each wrapped in an data element:</p>
<div class="alt"> <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;&lt;<span class="keywordtype">ns:record</span> <span class="keyword">xmlns:ns</span>=<span class="stringliteral">&quot;urn:types&quot;</span> ...&gt;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  &lt;<span class="keywordtype">data</span>&gt;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    &lt;<span class="keywordtype">n</span>&gt;123&lt;/<span class="keywordtype">n</span>&gt;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;  &lt;/<span class="keywordtype">data</span>&gt;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;  &lt;<span class="keywordtype">data</span>&gt;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    &lt;<span class="keywordtype">x</span>&gt;3.1&lt;/<span class="keywordtype">x</span>&gt;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;  &lt;/<span class="keywordtype">data</span>&gt;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;  &lt;<span class="keywordtype">data</span>&gt;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;    &lt;<span class="keywordtype">s</span>&gt;<span class="keyword">hello</span>&lt;/<span class="keywordtype">s</span>&gt;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;  &lt;/<span class="keywordtype">data</span>&gt;</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;  &lt;<span class="keywordtype">data</span>&gt;</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;    &lt;<span class="keywordtype">s</span>&gt;<span class="keyword">world</span>&lt;/<span class="keywordtype">s</span>&gt;</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;  &lt;/<span class="keywordtype">data</span>&gt;</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;&lt;/<span class="keywordtype">ns:record</span>&gt;</div></div><!-- fragment --> </div><p>To remove the wrapping data element, simply rename the wrapping struct to <code>__ns__data</code> and the member to <code>__data</code> to make this member invisible to the serializer. The double underscore prefix naming convention is used for the struct name and member name. Also use a dynamic array instead of a STL container (so you can also use this approach in C with structs):</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>ns__record</div><div class="line">{</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  $int  sizeOfdata; <span class="comment">// size of dynamic array</span></div><div class="line">  <span class="keyword">struct </span>__ns__data <span class="comment">// contains choice of x, n, or s</span></div><div class="line">  {</div><div class="line">    $int  xORnORs;  <span class="comment">// variant selector with values SOAP_UNION_fieldname</span></div><div class="line">    <span class="keyword">union </span>ns__choice</div><div class="line">    {</div><div class="line">      <span class="keywordtype">float</span> x;</div><div class="line">      <span class="keywordtype">int</span>   n;</div><div class="line">      <span class="keywordtype">char</span> *s;</div><div class="line">    } u;</div><div class="line">  } *__data;        <span class="comment">// points to the data array of length sizeOfdata</span></div><div class="line">};</div></div><!-- fragment --><p>This maps to a complexType in the soapcpp2-generated schema:</p>
<div class="alt"> <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;&lt;<span class="keywordtype">complexType</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;record&quot;</span>&gt;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  &lt;<span class="keywordtype">sequence</span> <span class="keyword">minOccurs</span>=<span class="stringliteral">&quot;0&quot;</span> <span class="keyword">maxOccurs</span>=<span class="stringliteral">&quot;unbounded&quot;</span>&gt;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    &lt;<span class="keywordtype">choice</span>&gt;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;      &lt;<span class="keywordtype">element</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;x&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;xsd:float&quot;</span> <span class="keyword">minOccurs</span>=<span class="stringliteral">&quot;1&quot;</span> <span class="keyword">maxOccurs</span>=<span class="stringliteral">&quot;1&quot;</span>/&gt;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;      &lt;<span class="keywordtype">element</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;n&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;xsd:int&quot;</span> <span class="keyword">minOccurs</span>=<span class="stringliteral">&quot;1&quot;</span> <span class="keyword">maxOccurs</span>=<span class="stringliteral">&quot;1&quot;</span>/&gt;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;      &lt;<span class="keywordtype">element</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;s&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;xsd:string&quot;</span> <span class="keyword">minOccurs</span>=<span class="stringliteral">&quot;0&quot;</span> <span class="keyword">maxOccurs</span>=<span class="stringliteral">&quot;1&quot;</span> <span class="keyword">nillable</span>=<span class="stringliteral">&quot;true&quot;</span>/&gt;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    &lt;/<span class="keywordtype">choice</span>&gt;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;  &lt;/<span class="keywordtype">sequence</span>&gt;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;&lt;/<span class="keywordtype">complexType</span>&gt;</div></div><!-- fragment --> </div><p>The XML value space consists of a sequence of <code>&lt;x&gt;</code>, <code>&lt;n&gt;</code>, and/or <code>&lt;s&gt;</code> elements:</p>
<div class="alt"> <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;&lt;<span class="keywordtype">ns:record</span> <span class="keyword">xmlns:ns</span>=<span class="stringliteral">&quot;urn:types&quot;</span> ...&gt;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  &lt;<span class="keywordtype">n</span>&gt;123&lt;/<span class="keywordtype">n</span>&gt;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  &lt;<span class="keywordtype">x</span>&gt;3.1&lt;/<span class="keywordtype">x</span>&gt;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;  &lt;<span class="keywordtype">s</span>&gt;<span class="keyword">hello</span>&lt;/<span class="keywordtype">s</span>&gt;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;  &lt;<span class="keywordtype">s</span>&gt;<span class="keyword">world</span>&lt;/<span class="keywordtype">s</span>&gt;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;&lt;/<span class="keywordtype">ns:record</span>&gt;</div></div><!-- fragment --> </div><p>Please note that structs, classes, and unions are unnested by soapcpp2 (as in the C standard of nested structs and unions). Therefore, the <code>ns__choice</code> union in the <code>ns__record</code> class is redeclared at the top level despite its nesting within the <code>ns__record</code> class. This means that you will have to choose a unique name for each nested struct, class, and union.</p>
<p>üîù <a href="#">Back to table of contents</a></p>
<h3><a class="anchor" id="toxsd9-12"></a>
Tagged void pointer members</h3>
<p>To serialize data pointed to by <code>void*</code> requires run-time type information that tells the serializer what type of data to serialize by means of a <em>tagged void pointer</em>. This type information is stored in a special type tag member of a struct/class with the name <code>__type</code> or <code>__typeX</code>, where <code>X</code> can be any name, or alternatively by an <code>$int</code> special member of any name as a type tag:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>ns__record</div><div class="line">{</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  $int  typeOfdata; <span class="comment">// type tag with values SOAP_TYPE_T</span></div><div class="line">  <span class="keywordtype">void</span> *data;       <span class="comment">// points to some data of type T</span></div><div class="line">};</div></div><!-- fragment --><p>A type tag member has nonzero values <code>SOAP_TYPE_T</code> where <code>T</code> is the name of a struct/class or the name of a primitive type, such as <code>int</code>, <code>std__string</code> (for <code>std::string</code>), <code>string</code> (for <code>char*</code>).</p>
<p>This class maps to a complexType with a sequence in the soapcpp2-generated schema:</p>
<div class="alt"> <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;&lt;<span class="keywordtype">complexType</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;record&quot;</span>&gt;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  &lt;<span class="keywordtype">sequence</span>&gt;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    &lt;<span class="keywordtype">element</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;data&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;xsd:anyType&quot;</span> <span class="keyword">minOccurs</span>=<span class="stringliteral">&quot;0&quot;</span> <span class="keyword">maxOccurs</span>=<span class="stringliteral">&quot;1&quot;</span>/&gt;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;  &lt;/<span class="keywordtype">sequence</span>&gt;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;&lt;/<span class="keywordtype">complexType</span>&gt;</div></div><!-- fragment --> </div><p>The XML value space consists of the XML value space of the type with the addition of an <code>xsi:type</code> attribute to the enveloping element:</p>
<div class="alt"> <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;&lt;<span class="keywordtype">ns:record</span> <span class="keyword">xmlns:ns</span>=<span class="stringliteral">&quot;urn:types&quot;</span> ...&gt;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  &lt;<span class="keywordtype">data</span> <span class="keyword">xsi:type</span>=<span class="stringliteral">&quot;xsd:int&quot;</span>&gt;123&lt;/<span class="keywordtype">data</span>&gt;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;&lt;/<span class="keywordtype">ns:record</span>&gt;</div></div><!-- fragment --> </div><p>This <code>xsi:type</code> attribute is important for the receiving end to distinguish the type of data to instantiate. The receiver cannot deserialize the data without an <code>xsd:type</code> attribute.</p>
<p>You can find the <code>SOAP_TYPE_T</code> name of each serializable type in the auto-generated soapStub.h file.</p>
<p>Also all serializable C++ classes have a virtual <code>int T::soap_type()</code> member that returns their <code>SOAP_TYPE_T</code> value that you can use.</p>
<p>When the <code>void*</code> pointer is NULL or when <code>typeOfdata</code> is zero, the data is not serialized.</p>
<p>An STL container or dynamic array of <code>void*</code> pointers to <code>xsd:anyType</code> data requires wrapping the type tag and <code>void*</code> members in a struct:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>ns__record</div><div class="line">{</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  std::vector&lt;</div><div class="line">  <span class="keyword">struct </span>ns__data     <span class="comment">// data with an xsd:anyType item</span></div><div class="line">  {</div><div class="line">    $int  typeOfitem; <span class="comment">// type tag with values SOAP_TYPE_T</span></div><div class="line">    <span class="keywordtype">void</span> *item;       <span class="comment">// points to some item of type T</span></div><div class="line">  }&gt; data;            <span class="comment">// vector with data</span></div><div class="line">};</div></div><!-- fragment --><p>and an equivalent definition with a dynamic array instead of a <code>std::vector</code> (you can use this in C with structs):</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>ns__record</div><div class="line">{</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  $int  sizeOfdata;   <span class="comment">// size of dynamic array</span></div><div class="line">  <span class="keyword">struct </span>ns__data     <span class="comment">// data with an xsd:anyType item</span></div><div class="line">  {</div><div class="line">    $int  typeOfitem; <span class="comment">// type tag with values SOAP_TYPE_T</span></div><div class="line">    <span class="keywordtype">void</span> *item;       <span class="comment">// points to some item of type T</span></div><div class="line">  } *data;            <span class="comment">// points to the data array of length sizeOfdata</span></div><div class="line">};</div></div><!-- fragment --><p>This maps to two complexTypes in the soapcpp2-generated schema:</p>
<div class="alt"> <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;&lt;<span class="keywordtype">complexType</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;data&quot;</span>&gt;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  &lt;<span class="keywordtype">sequence</span>&gt;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    &lt;<span class="keywordtype">element</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;item&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;xsd:anyType&quot;</span> <span class="keyword">minOccurs</span>=<span class="stringliteral">&quot;1&quot;</span> <span class="keyword">maxOccurs</span>=<span class="stringliteral">&quot;1&quot;</span> <span class="keyword">nillable</span>=<span class="stringliteral">&quot;true&quot;</span>/&gt;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;  &lt;/<span class="keywordtype">sequence</span>&gt;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;&lt;/<span class="keywordtype">complexType</span>&gt;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;&lt;<span class="keywordtype">complexType</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;record&quot;</span>&gt;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;  &lt;<span class="keywordtype">sequence</span>&gt;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    &lt;<span class="keywordtype">element</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;data&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;ns:data&quot;</span> <span class="keyword">minOccurs</span>=<span class="stringliteral">&quot;0&quot;</span> <span class="keyword">maxOccurs</span>=<span class="stringliteral">&quot;unbounded&quot;</span>/&gt;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;  &lt;/<span class="keywordtype">sequence</span>&gt;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;&lt;/<span class="keywordtype">complexType</span>&gt;</div></div><!-- fragment --> </div><p>The XML value space consists of a sequence of item elements each wrapped in a data element:</p>
<div class="alt"> <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;&lt;<span class="keywordtype">ns:record</span> <span class="keyword">xmlns:ns</span>=<span class="stringliteral">&quot;urn:types&quot;</span> ...&gt;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  &lt;<span class="keywordtype">data</span>&gt;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    &lt;<span class="keywordtype">item</span> <span class="keyword">xsi:type</span>=<span class="stringliteral">&quot;xsd:int&quot;</span>&gt;123&lt;/<span class="keywordtype">item</span>&gt;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;  &lt;/<span class="keywordtype">data</span>&gt;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;  &lt;<span class="keywordtype">data</span>&gt;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    &lt;<span class="keywordtype">item</span> <span class="keyword">xsi:type</span>=<span class="stringliteral">&quot;xsd:double&quot;</span>&gt;3.1&lt;/<span class="keywordtype">item</span>&gt;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;  &lt;/<span class="keywordtype">data</span>&gt;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;  &lt;<span class="keywordtype">data</span>&gt;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;    &lt;<span class="keywordtype">item</span> <span class="keyword">xsi:type</span>=<span class="stringliteral">&quot;xsd:string&quot;</span>&gt;<span class="keyword">abc</span>&lt;/<span class="keywordtype">item</span>&gt;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;  &lt;/<span class="keywordtype">data</span>&gt;</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;&lt;/<span class="keywordtype">ns:record</span>&gt;</div></div><!-- fragment --> </div><p>To remove the wrapping data elements, simply rename the wrapping struct and member to <code>__data</code> to make this member invisible to the serializer with the double underscore prefix naming convention. Also use a dynamic array instead of a STL container (you can use this in C with structs):</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>ns__record</div><div class="line">{</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  $int  sizeOfdata;   <span class="comment">// size of dynamic array</span></div><div class="line">  <span class="keyword">struct </span>__data       <span class="comment">// contains xsd:anyType item</span></div><div class="line">  {</div><div class="line">    $int  typeOfitem; <span class="comment">// type tag with values SOAP_TYPE_T</span></div><div class="line">    <span class="keywordtype">void</span> *item;       <span class="comment">// points to some item of type T</span></div><div class="line">  } *__data;          <span class="comment">// points to the data array of length sizeOfdata</span></div><div class="line">};</div></div><!-- fragment --><p>This maps to a complexType in the soapcpp2-generated schema:</p>
<div class="alt"> <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;&lt;<span class="keywordtype">complexType</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;record&quot;</span>&gt;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  &lt;<span class="keywordtype">sequence</span> <span class="keyword">minOccurs</span>=<span class="stringliteral">&quot;0&quot;</span> <span class="keyword">maxOccurs</span>=<span class="stringliteral">&quot;unbounded&quot;</span>&gt;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    &lt;<span class="keywordtype">element</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;item&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;xsd:anyType&quot;</span> <span class="keyword">minOccurs</span>=<span class="stringliteral">&quot;1&quot;</span> <span class="keyword">maxOccurs</span>=<span class="stringliteral">&quot;1&quot;</span>/&gt;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;  &lt;/<span class="keywordtype">sequence</span>&gt;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;&lt;/<span class="keywordtype">complexType</span>&gt;</div></div><!-- fragment --> </div><p>The XML value space consists of a sequence of data elements:</p>
<div class="alt"> <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;&lt;<span class="keywordtype">ns:record</span> <span class="keyword">xmlns:ns</span>=<span class="stringliteral">&quot;urn:types&quot;</span> ...&gt;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  &lt;<span class="keywordtype">item</span> <span class="keyword">xsi:type</span>=<span class="stringliteral">&quot;xsd:int&quot;</span>&gt;123&lt;/<span class="keywordtype">item</span>&gt;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  &lt;<span class="keywordtype">item</span> <span class="keyword">xsi:type</span>=<span class="stringliteral">&quot;xsd:double&quot;</span>&gt;3.1&lt;/<span class="keywordtype">item</span>&gt;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;  &lt;<span class="keywordtype">item</span> <span class="keyword">xsi:type</span>=<span class="stringliteral">&quot;xsd:string&quot;</span>&gt;<span class="keyword">abc</span>&lt;/<span class="keywordtype">item</span>&gt;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;&lt;/<span class="keywordtype">ns:record</span>&gt;</div></div><!-- fragment --> </div><p>Again, please note that structs, classes, and unions are unnested by soapcpp2 (as in the C standard of nested structs and unions). Therefore, the <code>__data</code> struct in the <code>ns__record</code> class is redeclared at the top level despite its nesting within the <code>ns__record</code> class. This means that you will have to choose a unique name for each nested struct, class, and union.</p>
<dl class="section see"><dt>See also</dt><dd>Section <a href="#typemap2">XSD type bindings</a>.</dd></dl>
<p>üîù <a href="#">Back to table of contents</a></p>
<h3><a class="anchor" id="toxsd9-13"></a>
Adding get and set methods</h3>
<p>A public <code>get</code> method may be added to a class or struct, which will be triggered by the deserializer. This method will be invoked right after the instance is populated by the deserializer. The <code>get</code> method can be used to update or verify deserialized content. It should return <code>SOAP_OK</code> or set <code>soap::error</code> to a nonzero error code and return it.</p>
<p>A public <code>set</code> method may be added to a class or struct, which will be triggered by the serializer. The method will be invoked just before the instance is serialized. Likewise, the <code>set</code> method should return <code>SOAP_OK</code> or set set <code>soap::error</code> to a nonzero error code and return it.</p>
<p>For example, adding a <code>set</code> and <code>get</code> method to a class declaration:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>ns__record</div><div class="line">{</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="keywordtype">int</span> <span class="keyword">set</span>(<span class="keyword">struct </span>soap*); <span class="comment">// triggered before serialization</span></div><div class="line">  <span class="keywordtype">int</span> <span class="keyword">get</span>(<span class="keyword">struct </span>soap*); <span class="comment">// triggered after deserialization</span></div><div class="line">  ...</div><div class="line">};</div></div><!-- fragment --><p>To add these and othe rmethods to classes and structs with wsdl2h and <code>typemap.dat</code>, please see <a href="#typemap3">class/struct member additions</a>.</p>
<p>üîù <a href="#">Back to table of contents</a></p>
<h3><a class="anchor" id="toxsd9-14"></a>
Operations on classes and structs</h3>
<p>The following functions/macros are generated by soapcpp2 for each type <code>T</code>, which should make it easier to send, receive, and copy XML data in C and in C++:</p>
<ul>
<li><code>int soap_write_T(struct soap*, T*)</code> writes an instance of <code>T</code> to a file via file descriptor <code>int soap::sendfd)</code> or to a stream via <code>std::ostream *soap::os</code> (C++ only) or saves into a NUL-terminated string by setting <code>const char **soap::os</code> to a string pointer to be set (C only). Returns <code>SOAP_OK</code> on success or an error code, also stored in <code>soap-&gt;error</code>.</li>
<li><code>int soap_read_T(struct soap*, T*)</code> reads an instance of <code>T</code> from a file via file descriptor <code>int soap::recvfd)</code> or from a stream via <code>std::istream *soap::is</code> (C++ only) or reads from a NUL-termianted string <code>const char *soap::is</code> (C only). Returns <code>SOAP_OK</code> on success or an error code, also stored in <code>soap-&gt;error</code>.</li>
<li><code>void soap_default_T(struct soap*, T*)</code> sets an instance <code>T</code> to its default value, resetting members of a struct to their initial values (for classes we use method <code>T::soap_default</code>, see below).</li>
<li><code>T * soap_dup_T(struct soap*, T *dst, const T *src)</code> (soapcpp2 option <code>-Ec</code>) deep copy <code>src</code> into <code>dst</code>, replicating all deep cycles and shared pointers when a managing soap context is provided as argument. When <code>dst</code> is NULL, allocates space for <code>dst</code>. Deep copy is a tree when argument is NULL, but the presence of deep cycles will lead to non-termination. Use flag <code>SOAP_XML_TREE</code> with managing context to copy into a tree without cycles and pointers to shared objects. Returns <code>dst</code> (or allocated space when <code>dst</code> is NULL).</li>
<li><code>void soap_del_T(const T*)</code> (soapcpp2 option <code>-Ed</code>) deletes all heap-allocated members of this object by deep deletion ONLY IF this object and all of its (deep) members are not managed by a soap context AND the deep structure is a tree (no cycles and co-referenced objects by way of multiple (non-smart) pointers pointing to the same data). Can be safely used after <code>soap_dup(NULL)</code> to delete the deep copy. Does not delete the object itself.</li>
</ul>
<p>When in C++ mode, soapcpp2 tool adds several methods to classes in addition to adding a default constructor and destructor (when these were not explicitly declared).</p>
<p>The public methods added to a class <code>T</code>:</p>
<ul>
<li><code>virtual int T::soap_type(void)</code> returns a unique type ID (<code>SOAP_TYPE_T</code>). This numeric ID can be used to distinguish base from derived instances.</li>
<li><code>virtual void T::soap_default(struct soap*)</code> sets all data members to default values.</li>
<li><code>virtual void T::soap_serialize(struct soap*) const</code> serializes object to prepare for SOAP 1.1/1.2 encoded output (or with <code>SOAP_XML_GRAPH</code>) by analyzing its (cyclic) structures.</li>
<li><code>virtual int T::soap_put(struct soap*, const char *tag, const char *type) const</code> emits object in XML, compliant with SOAP 1.1 encoding style, return error code or <code>SOAP_OK</code>. Requires <code>soap_begin_send(soap)</code> and <code>soap_end_send(soap)</code>.</li>
<li><code>virtual int T::soap_out(struct soap*, const char *tag, int id, const char *type) const</code> emits object in XML, with tag and optional id attribute and <code>xsi:type</code>, return error code or <code>SOAP_OK</code>. Requires <code>soap_begin_send(soap)</code> and <code>soap_end_send(soap)</code>.</li>
<li><code>virtual void * T::soap_get(struct soap*, const char *tag, const char *type)</code> Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error. Requires <code>soap_begin_recv(soap)</code> and <code>soap_end_recv(soap)</code>.</li>
<li><code>virtual void *soap_in(struct soap*, const char *tag, const char *type)</code> Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error. Requires <code>soap_begin_recv(soap)</code> and <code>soap_end_recv(soap)</code></li>
<li><code>virtual T * T::soap_alloc(void) const</code> returns a new object of type <code>T</code>, default initialized and not managed by a soap context.</li>
<li><code>virtual T * T::soap_dup(struct soap*) const</code> (soapcpp2 option <code>-Ec</code>) returns a duplicate of this object by deep copying, replicating all deep cycles and shared pointers when a managing soap context is provided as argument. Deep copy is a tree when argument is NULL, but the presence of deep cycles will lead to non-termination. Use flag <code>SOAP_XML_TREE</code> with the managing context to copy into a tree without cycles and pointers to shared objects.</li>
<li><code>virtual void T::soap_del() const</code> (soapcpp2 option <code>-Ed</code>) deletes all heap-allocated members of this object by deep deletion ONLY IF this object and all of its (deep) members are not managed by a soap context AND the deep structure is a tree (no cycles and co-referenced objects by way of multiple (non-smart) pointers pointing to the same data). Can be safely used after <code>soap_dup(NULL)</code> to delete the deep copy. Does not delete the object itself.</li>
</ul>
<p>Also for C++, there are four variations of <code>soap_new_T</code> for class/struct/template type <code>T</code> that soapcpp2 auto-generates to create instances on a context-managed heap:</p>
<ul>
<li><code>T * soap_new_T(struct soap*)</code> returns a new instance of <code>T</code> with default data member initializations that are set with the soapcpp2 auto-generated <code>void T::soap_default(struct soap*)</code> method), but ONLY IF the soapcpp2 auto-generated default constructor is used that invokes <code>soap_default()</code> and was not replaced by a user-defined default constructor.</li>
<li><code>T * soap_new_T(struct soap*, int n)</code> returns an array of <code>n</code> new instances of <code>T</code>. Similar to the above, instances are initialized.</li>
<li><code>T * soap_new_req_T(struct soap*, ...)</code> returns a new instance of <code>T</code> and sets the required data members to the values specified in <code>...</code>. The required data members are those with nonzero minOccurs, see the subsections on <a href="#toxsd9-8">(smart) pointer members and their occurrence constraints</a> and <a href="#toxsd9-9">container and array members and their occurrence constraints</a>.</li>
<li><code>T * soap_new_set_T(struct soap*, ...)</code> returns a new instance of <code>T</code> and sets the public/serializable data members to the values specified in <code>...</code>.</li>
</ul>
<p>The above functions can be invoked with a NULL <code>soap</code> context, but we will be responsible to use <code>delete T</code> to remove this instance from the unmanaged heap.</p>
<p>üîù <a href="#">Back to table of contents</a></p>
<h2><a class="anchor" id="toxsd10"></a>
Special classes and structs                                           </h2>
<h3><a class="anchor" id="toxsd10-1"></a>
SOAP encoded arrays</h3>
<p>A class or struct with the following layout is a one-dimensional SOAP encoded Array type:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>ArrayOfT</div><div class="line">{</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  T   *__ptr;  <span class="comment">// array pointer</span></div><div class="line">  <span class="keywordtype">int</span>  __size; <span class="comment">// array size</span></div><div class="line">};</div></div><!-- fragment --><p>where <code>T</code> is the array element type. A multidimensional SOAP Array is:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>ArrayOfT</div><div class="line">{</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  T   *__ptr;     <span class="comment">// array pointer</span></div><div class="line">  <span class="keywordtype">int</span>  __size[N]; <span class="comment">// array size of each dimension</span></div><div class="line">};</div></div><!-- fragment --><p>where <code>N</code> is the constant number of dimensions. The pointer points to an array of <code>__size[0]*__size[1]* ... * __size[N-1]</code> elements.</p>
<p>This maps to a complexType restriction of SOAP-ENC:Array in the soapcpp2-generated schema:</p>
<div class="alt"> <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;&lt;<span class="keywordtype">complexType</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;ArrayOfT&quot;</span>&gt;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  &lt;<span class="keywordtype">complexContent</span>&gt;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    &lt;<span class="keywordtype">restriction</span> <span class="keyword">base</span>=<span class="stringliteral">&quot;SOAP-ENC:Array&quot;</span>&gt;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;      &lt;<span class="keywordtype">sequence</span>&gt;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;        &lt;<span class="keywordtype">element</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;item&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;T&quot;</span> <span class="keyword">minOccurs</span>=<span class="stringliteral">&quot;0&quot;</span> <span class="keyword">maxOccurs</span>=<span class="stringliteral">&quot;unbounded&quot;</span> <span class="keyword">nillable</span>=<span class="stringliteral">&quot;true&quot;</span>/&gt;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;      &lt;/<span class="keywordtype">sequence</span>&gt;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;      &lt;<span class="keywordtype">attribute</span> <span class="keyword">ref</span>=<span class="stringliteral">&quot;SOAP-ENC:arrayType&quot;</span> <span class="keyword">WSDL:arrayType</span>=<span class="stringliteral">&quot;ArrayOfT[]&quot;</span>/&gt;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    &lt;/<span class="keywordtype">restriction</span>&gt;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;  &lt;/<span class="keywordtype">complexContent</span>&gt;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;&lt;/<span class="keywordtype">complexType</span>&gt;</div></div><!-- fragment --> </div><p>The name of the class can be arbitrary. We often use <code>ArrayOfT</code> without a prefix to distinguish arrays from other classes and structs.</p>
<p>With SOAP 1.1 encoding, an optional offset member can be added that controls the start of the index range for each dimension:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>ArrayOfT</div><div class="line">{</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  T   *__ptr;       <span class="comment">// array pointer</span></div><div class="line">  <span class="keywordtype">int</span>  __size[N];   <span class="comment">// array size of each dimension</span></div><div class="line">  <span class="keywordtype">int</span>  __offset[N]; <span class="comment">// array offsets to start each dimension</span></div><div class="line">};</div></div><!-- fragment --><p>For example, we can define a matrix of floats as follows:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Matrix</div><div class="line">{</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="keywordtype">double</span> *__ptr;</div><div class="line">  <span class="keywordtype">int</span>     __size[2];</div><div class="line">};</div></div><!-- fragment --><p>The following code populates the matrix and serializes it in XML:</p>
<div class="fragment"><div class="line">soap *soap = soap_new1(SOAP_XML_INDENT);</div><div class="line">Matrix A;</div><div class="line"><span class="keywordtype">double</span> a[6] = { 1, 2, 3, 4, 5, 6 };</div><div class="line">A.__ptr = a;</div><div class="line">A.__size[0] = 2;</div><div class="line">A.__size[1] = 3;</div><div class="line">soap_write_Matrix(soap, &amp;A);</div></div><!-- fragment --><p>Matrix A is serialized as an array with 2x3 values:</p>
<div class="alt"> <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;&lt;<span class="keywordtype">SOAP-ENC:Array</span> <span class="keyword">SOAP-ENC:arrayType</span>=<span class="stringliteral">&quot;xsd:double[2,3]&quot;</span> ...&gt;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  &lt;<span class="keywordtype">item</span>&gt;1&lt;/<span class="keywordtype">item</span>&gt;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  &lt;<span class="keywordtype">item</span>&gt;2&lt;/<span class="keywordtype">item</span>&gt;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;  &lt;<span class="keywordtype">item</span>&gt;3&lt;/<span class="keywordtype">item</span>&gt;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;  &lt;<span class="keywordtype">item</span>&gt;4&lt;/<span class="keywordtype">item</span>&gt;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;  &lt;<span class="keywordtype">item</span>&gt;5&lt;/<span class="keywordtype">item</span>&gt;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;  &lt;<span class="keywordtype">item</span>&gt;6&lt;/<span class="keywordtype">item</span>&gt;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;&lt;/<span class="keywordtype">SOAP-ENC:Array</span>&gt;</div></div><!-- fragment --> </div><p>üîù <a href="#">Back to table of contents</a></p>
<h3><a class="anchor" id="toxsd10-2"></a>
XSD hexBinary and base64Binary types</h3>
<p>A special case of a one-dimensional array is used to define <code>xsd:hexBinary</code> and <code>xsd:base64Binary</code> types when the pointer type is <code>unsigned char</code>:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>xsd__hexBinary</div><div class="line">{</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *__ptr;  <span class="comment">// points to raw binary data</span></div><div class="line">  <span class="keywordtype">int</span>            __size; <span class="comment">// size of data</span></div><div class="line">};</div></div><!-- fragment --><p>and</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>xsd__base64Binary</div><div class="line">{</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *__ptr;  <span class="comment">// points to raw binary data</span></div><div class="line">  <span class="keywordtype">int</span>            __size; <span class="comment">// size of data</span></div><div class="line">};</div></div><!-- fragment --><p>üîù <a href="#">Back to table of contents</a></p>
<h3><a class="anchor" id="toxsd10-3"></a>
MIME/MTOM attachment binary types</h3>
<p>A class or struct with a binary content layout can be extended to support MIME/MTOM (and older DIME) attachments, such as in <code>&lt;xop:Include&gt;</code> elements:</p>
<div class="fragment"><div class="line"><span class="comment">//gsoap xop schema import: http://www.w3.org/2004/08/xop/include</span></div><div class="line"><span class="keyword">class </span>_xop__Include</div><div class="line">{</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *__ptr;   <span class="comment">// points to raw binary data</span></div><div class="line">  <span class="keywordtype">int</span>            __size;  <span class="comment">// size of data</span></div><div class="line">  <span class="keywordtype">char</span>          *id;      <span class="comment">// NULL to generate an id, or set to a unique UUID</span></div><div class="line">  <span class="keywordtype">char</span>          *type;    <span class="comment">// MIME type of the data</span></div><div class="line">  <span class="keywordtype">char</span>          *options; <span class="comment">// optional description of MIME attachment</span></div><div class="line">};</div></div><!-- fragment --><p>Attachments are beyond the scope of this article. The <code>SOAP_ENC_MIME</code> and <code>SOAP_ENC_MTOM</code> context flag must be set to enable attachments. See the <a href="http://www.genivia.com/doc/soapdoc2.html">gSOAP user guide</a> for more details.</p>
<p>üîù <a href="#">Back to table of contents</a></p>
<h3><a class="anchor" id="toxsd10-4"></a>
Wrapper class/struct with simpleContent</h3>
<p>A class or struct with the following layout is a complexType that wraps simpleContent:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>ns__simple</div><div class="line">{</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  T   __item;</div><div class="line">};</div></div><!-- fragment --><p>The type <code>T</code> is a primitive type (<code>bool</code>, <code>enum</code>, <code>time_t</code>, numeric and string types), <code>xsd__hexBinary</code>, <code>xsd__base64Binary</code>, and custom serializers, such as <code>xsd__dateTime</code>.</p>
<p>This maps to a complexType with simpleContent in the soapcpp2-generated schema:</p>
<div class="alt"> <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;&lt;<span class="keywordtype">complexType</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;simple&quot;</span>&gt;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  &lt;<span class="keywordtype">simpleContent</span>&gt;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    &lt;<span class="keywordtype">extension</span> <span class="keyword">base</span>=<span class="stringliteral">&quot;T&quot;</span>/&gt;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;  &lt;/<span class="keywordtype">simpleContent</span>&gt;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;&lt;/<span class="keywordtype">complexType</span>&gt; </div></div><!-- fragment --> </div><p>A wrapper class/struct may include any number of attributes declared with <code>@</code>.</p>
<p>üîù <a href="#">Back to table of contents</a></p>
<h3><a class="anchor" id="toxsd10-5"></a>
DOM anyType and anyAttribute</h3>
<p>Use of a DOM is optional and enabled by <code>#import "dom.h"</code> to use the DOM <code>xsd__anyType</code> element node and <code>xsd__anyAttribute</code> attribute node:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#import &quot;dom.h&quot;</span></div><div class="line"></div><div class="line"><span class="keyword">class </span>ns__record</div><div class="line">{</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  @xsd__anyAttribute attributes; <span class="comment">// optional DOM attributes</span></div><div class="line">  ...</div><div class="line">  xsd__anyType      *name;       <span class="comment">// optional DOM element (pointer means minOccurs=0)</span></div><div class="line">  xsd__anyType       address;    <span class="comment">// required DOM element (minOccurs=1)</span></div><div class="line">  xsd__anyType       email   0;  <span class="comment">// optional DOM element (minOccurs=0)</span></div><div class="line">};</div></div><!-- fragment --><p>where <code>name</code> contains XML stored in a DOM node set and <code>attributes</code> is a list of all visibly rendered attributes. The name <code>attributes</code> is arbitrary and any name will suffice.</p>
<p>You should place the <code>xsd__anyType</code> members at the end of the struct or class. This ensures that the DOM members are populated last as a "catch all". A member name starting with double underscore is a wildcard member. These members are placed at the end of a struct or class automatically by soapcpp2.</p>
<p>An <code>#import "dom.h"</code> import is automatically added by wsdl2h with option <code>-d</code> to bind <code>xsd:anyType</code> to DOM nodes, and also to populate <code>xsd:any</code>, <code>xsd:anyAttribute</code> and <code>xsd:mixed</code> XML content:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#import &quot;dom.h&quot;</span></div><div class="line"></div><div class="line"><span class="keyword">class </span>ns__record</div><div class="line">{</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  ...</div><div class="line">  @xsd__anyAttribute        __anyAttribute; <span class="comment">// optional DOM attributes</span></div><div class="line">  std::vector&lt;xsd__anyType&gt; __any   0;      <span class="comment">// optional DOM elements (minOccurs=0)</span></div><div class="line">  xsd__anyType              __mixed 0;      <span class="comment">// optional mixed content (minOccurs=0)</span></div><div class="line">};</div></div><!-- fragment --><p>where the members prefixed with <code>__</code> are "invisible" to the XML parser, meaning that these members are not bound to XML tag names.</p>
<p>In C you can use a dynamic arrary instead of <code>std::vector</code>:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#import &quot;dom.h&quot;</span></div><div class="line"></div><div class="line"><span class="keyword">struct </span>ns__record</div><div class="line">{</div><div class="line">  ...</div><div class="line">  @xsd__anyAttribute        __anyAttribute; <span class="comment">// optional DOM attributes</span></div><div class="line">  $int                      __sizeOfany;    <span class="comment">// size of the array</span></div><div class="line">  xsd__anyType             *__any;          <span class="comment">// optional DOM elements (pointer means minOccurs=0)</span></div><div class="line">  xsd__anyType              __mixed 0;      <span class="comment">// optional mixed content (minOccurs=0)</span></div><div class="line">};</div></div><!-- fragment --><p>Classes can inherit DOM, which enables full use of polymorphism with one base DOM class:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#import &quot;dom.h&quot;</span></div><div class="line"></div><div class="line"><span class="keyword">class </span>ns__record : <span class="keyword">public</span> xsd__anyType</div><div class="line">{</div><div class="line">  ...</div><div class="line">  std::vector&lt;xsd__anyType*&gt; array; <span class="comment">// array of objects of any class</span></div><div class="line">};</div></div><!-- fragment --><p>This permits an <code>xsd__anyType</code> pointer to refer to a derived class such as <code>ns__record</code>, which will be serialized with an <code>xsi:type</code> attribute that is set to "ns:record". The <code>xsi:type</code> attributes add the necessary type information to distinguish the XML content from the DOM base type. This is important for the receiving end: without <code>xsd:type</code> attributes with type names, only base DOM objects are recognized and instantiated.</p>
<p>Because C lacks OOP principles such as class inheritance and polymorphism, you will need to use the special <a href="#toxsd9-12"><code>void*</code> members</a> to serialize data pointed to by a <code>void*</code> member.</p>
<p>To ensure that wsdl2h generates pointer-based <code>xsd__anyType</code> DOM nodes with option <code>-d</code> for <code>xsd:any</code>, add the following line to <code>typemap.dat</code>: </p><pre class="fragment">xsd__any = | xsd__anyType*
</pre><p>This lets wsdl2h produce class/struct members and containers with <code>xsd__anyType*</code> for <code>xsd:any</code> instead of <code>xsd__anyType</code>. To just force all <code>xsd:anyType</code> uses to be pointer-based, declare in <code>typemap.dat</code>: </p><pre class="fragment">xsd__anyType = | xsd__anyType*
</pre><p>If you use wsdl2h with option <code>-p</code> with option <code>-d</code> then every class will inherit DOM as shown above. Without option <code>-d</code>, an <code>xsd__anyType</code> type is generated to serve as the root type in the type hierarchy:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>xsd__anyType { <a class="code" href="address_stub_8h.html#a5c62d26b4823b76c5b4ef29e7865d3f0">_XML</a> __item; <span class="keyword">struct </span>soap *soap; };</div><div class="line"></div><div class="line"><span class="keyword">class </span>ns__record : <span class="keyword">public</span> xsd__anyType</div><div class="line">{</div><div class="line">  ...</div><div class="line">};</div></div><!-- fragment --><p>where the <code>_XML __item</code> member holds any XML content as a literal XML string.</p>
<p>To use the DOM API, compile <code>dom.c</code> (or <code>dom.cpp</code> for C++), or link with <code>-lgsoapssl</code> (or <code>-lgsoapssl++</code> for C++).</p>
<dl class="section see"><dt>See also</dt><dd>Documentation of <a href="http://www.genivia.com/doc/dom/html">XML DOM and XPath</a> for more details.</dd></dl>
<p>üîù <a href="#">Back to table of contents</a></p>
<h1><a class="anchor" id="directives"></a>
Directives                                                         </h1>
<p>You can use <code>//gsoap</code> directives in the gSOAP header file with the data binding interface for soapcpp2. These directives are used to configure the code generated by soapcpp2 by declaring various. properties of Web services and XML schemas. When using the wsdl2h tool, you will notice that wsdl2h generates directives automatically based on the WSDL and XSD input.</p>
<p>Service directives are applicable to service and operations described by WSDL. Schema directives are applicable to types, elements, and attributes defined by XML schemas.</p>
<p>üîù <a href="#">Back to table of contents</a></p>
<h2><a class="anchor" id="directives-1"></a>
Service directives                                               </h2>
<p>A service directive must start at a new line and is of the form:</p>
<div class="fragment"><div class="line"><span class="comment">//gsoap &lt;prefix&gt; service &lt;property&gt;: &lt;value&gt;</span></div></div><!-- fragment --><p>where <code>&lt;prefix&gt;</code> is the XML namespace prefix of a service binding. The <code>&lt;property&gt;</code> and <code>&lt;value&gt;</code> fields are one of the following:</p>
<table class="doxtable">
<tr>
<th>property </th><th>value  </th></tr>
<tr>
<td><code>name</code> </td><td>name of the service, optionally followed by text describing the service </td></tr>
<tr>
<td><code>namespace</code> </td><td>URI of the WSDL targetNamespace </td></tr>
<tr>
<td><code>documentation</code> </td><td>text describing the service (see also the <code>name</code> property), multiple permitted </td></tr>
<tr>
<td><code>doc</code> </td><td>same as above, shorthand form </td></tr>
<tr>
<td><code>style</code> </td><td><code>document</code> (default) SOAP messaging style or <code>rpc</code> for SOAP RPC </td></tr>
<tr>
<td><code>encoding</code> </td><td><code>literal</code> (default), <code>encoded</code> for SOAP encoding, or a custom URI </td></tr>
<tr>
<td><code>protocol</code> </td><td>specifies SOAP or REST, see below </td></tr>
<tr>
<td><code>port</code> </td><td>URL of the service endpoint, usually an http or https address </td></tr>
<tr>
<td><code>transport</code> </td><td>URI declaration of the transport, usually <code><a href="http://schemas.xmlsoap.org/soap/http">http://schemas.xmlsoap.org/soap/http</a></code> </td></tr>
<tr>
<td><code>definitions</code> </td><td>name of the WSDL definitions/@name </td></tr>
<tr>
<td><code>type</code> </td><td>name of the WSDL definitions/portType/@name (WSDL2.0 interface/@name) </td></tr>
<tr>
<td><code>binding</code> </td><td>name of the WSDL definitions/binding/@name </td></tr>
<tr>
<td><code>portName</code> </td><td>name of the WSDL definitions/service/port/@name </td></tr>
<tr>
<td><code>portType</code> </td><td>an alias for the <code>type</code> property </td></tr>
<tr>
<td><code>interface</code> </td><td>an alias for the <code>type</code> property </td></tr>
<tr>
<td><code>location</code> </td><td>an alias for the <code>port</code> property </td></tr>
<tr>
<td><code>endpoint</code> </td><td>an alias for the <code>port</code> property </td></tr>
</table>
<p>The service <code>name</code> and <code>namespace</code> properties are required in order to generate a valid WSDL with soapcpp2. The other properties are optional.</p>
<p>The <code>style</code> and <code>encoding</code> property defaults are changed with soapcpp2 option <code>-e</code> to <code>rpc</code> and <code>encoded</code>, respectively.</p>
<p>The <code>protocol</code> property is <code>SOAP</code> by default (SOAP 1.1). Protocol property values are:</p>
<table class="doxtable">
<tr>
<th>protocol value </th><th>description  </th></tr>
<tr>
<td><code>SOAP</code> </td><td>SOAP transport, supporting both SOAP 1.1 and 1.2 </td></tr>
<tr>
<td><code>SOAP1.1</code> </td><td>SOAP 1.1 transport (same as soapcpp2 option <code>-1</code>) </td></tr>
<tr>
<td><code>SOAP1.2</code> </td><td>SOAP 1.2 transport (same as soapcpp2 option <code>-2</code>) </td></tr>
<tr>
<td><code>SOAP-GET</code> </td><td>one-way SOAP 1.1 or 1.2 with HTTP GET </td></tr>
<tr>
<td><code>SOAP1.1-GET</code> </td><td>one-way SOAP 1.1 with HTTP GET </td></tr>
<tr>
<td><code>SOAP1.2-GET</code> </td><td>one-way SOAP 1.2 with HTTP GET </td></tr>
<tr>
<td><code>HTTP</code> </td><td>non-SOAP REST protocol with HTTP POST </td></tr>
<tr>
<td><code>POST</code> </td><td>non-SOAP REST protocol with HTTP POST </td></tr>
<tr>
<td><code>GET</code> </td><td>non-SOAP REST protocol with HTTP GET </td></tr>
<tr>
<td><code>PUT</code> </td><td>non-SOAP REST protocol with HTTP PUT </td></tr>
<tr>
<td><code>DELETE</code> </td><td>non-SOAP REST protocol with HTTP DELETE </td></tr>
</table>
<p>You can bind service operations to the WSDL namespace of a service by using the namespace prefix as part of the identifier name of the function that defines the service operation:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> prefix__func(arg1, arg2, ..., argn, result);</div></div><!-- fragment --><p>You can override the <code>port</code> endpoint URL at runtime in the auto-generated <code>soap_call_prefix__func</code> service call (C/C++ client side) and in the C++ proxy class service call.</p>
<p>üîù <a href="#">Back to table of contents</a></p>
<h2><a class="anchor" id="directives-2"></a>
Service method directives                                        </h2>
<p>Service properties are applicable to a service and to all of its operations. Service method directives are specifically applicable to a service operation.</p>
<p>A service method directive is of the form:</p>
<div class="fragment"><div class="line"><span class="comment">//gsoap &lt;prefix&gt; service method-&lt;property&gt;: &lt;method&gt; &lt;value&gt;</span></div></div><!-- fragment --><p>where <code>&lt;prefix&gt;</code> is the XML namespace prefix of a service binding and <code>&lt;method&gt;</code> is the unqualified name of a service operation. The <code>&lt;property&gt;</code> and <code>&lt;value&gt;</code> fields are one of the following:</p>
<table class="doxtable">
<tr>
<th>method property </th><th>value  </th></tr>
<tr>
<td><code>method-documentation</code> </td><td>text describing the service operation </td></tr>
<tr>
<td><code>method</code> </td><td>same as above, shorthand form </td></tr>
<tr>
<td><code>method-action</code> </td><td><code>""</code> or URI SOAPAction HTTP header, or URL query string for REST protocols </td></tr>
<tr>
<td><code>method-input-action</code> </td><td><code>""</code> or URI SOAPAction HTTP header of service request messages </td></tr>
<tr>
<td><code>method-output-action</code> </td><td><code>""</code> or URI SOAPAction HTTP header of service response messages </td></tr>
<tr>
<td><code>method-fault-action</code> </td><td><code>""</code> or URI SOAPAction HTTP header of service fault messages </td></tr>
<tr>
<td><code>method-header-part</code> </td><td>member name of the <code><a class="el" href="struct_s_o_a_p___e_n_v_____header.html">SOAP_ENV__Header</a></code> struct used in SOAP Header </td></tr>
<tr>
<td><code>method-input-header-part</code> </td><td>member name of the <code><a class="el" href="struct_s_o_a_p___e_n_v_____header.html">SOAP_ENV__Header</a></code> struct used in SOAP Headers of requests </td></tr>
<tr>
<td><code>method-output-header-part</code> </td><td>member name of the <code><a class="el" href="struct_s_o_a_p___e_n_v_____header.html">SOAP_ENV__Header</a></code> struct used in SOAP Headers of responses </td></tr>
<tr>
<td><code>method-fault</code> </td><td>type name of a struct or class member used in <code>SOAP_ENV__Details</code> struct </td></tr>
<tr>
<td><code>method-mime-type</code> </td><td>REST content type or SOAP MIME attachment content type(s) </td></tr>
<tr>
<td><code>method-input-mime-type</code> </td><td>REST content type or SOAP MIME attachment content type(s) of request message </td></tr>
<tr>
<td><code>method-output-mime-type</code> </td><td>REST content type or SOAP MIME attachment content type(s) of response message </td></tr>
<tr>
<td><code>method-style</code> </td><td><code>document</code> or <code>rpc</code> </td></tr>
<tr>
<td><code>method-encoding</code> </td><td><code>literal</code>, <code>encoded</code>, or a custom URI for encodingStyle of messages </td></tr>
<tr>
<td><code>method-response-encoding</code> </td><td><code>literal</code>, <code>encoded</code>, or a custom URI for encodingStyle of response messages </td></tr>
<tr>
<td><code>method-protocol</code> </td><td>SOAP or REST, see <a href="#directives-1">service directives</a> </td></tr>
</table>
<p>The <code>method-header-part</code> properties can be repeated for a service operation to declare multiple SOAP Header parts that the service operation requires. You can use <code>method-input-header-part</code> and <code>method-output-header-part</code> to differentiate between request and response messages.</p>
<p>The <code>method-fault</code> property can be repeated for a service operation to declare multiple faults that the service operation may return.</p>
<p>The <code>method-action</code> property serves two purposes:</p>
<ol type="1">
<li>To set the SOAPAction header for SOAP protocols, i.e. sets the definitions/binding/operation/SOAP:operation/@soapAction.</li>
<li>To set the URL query string for endpoints with REST protocols, i.e. sets the definitions/binding/operation/HTTP:operation/@location, which specifies a URL query string (starts with a <code>?</code>) to complete the service endpoint URL or extends the endpoint URL with a local path (starts with a <code>/</code>).</li>
</ol>
<p>Use <code>method-input-action</code> and <code>method-output-action</code> to differentiate the SOAPAction between SOAP request and response messages.</p>
<p>You can always override the port endpoint URL and action values at runtime in the auto-generated <code>soap_call_prefix__func</code> service call (C/C++ client side) and in the auto-generated C++ proxy class service calls. A runtime NULL endpoint URL and/or action uses the defaults set by these directives.</p>
<p>The <code>method-mime-type</code> property serves two purposes:</p>
<ol type="1">
<li>To set the type of MIME/MTOM attachments used with SOAP protocols. Multiple attachment types can be declared for a SOAP service operation, i.e. adds definitions/binding/operation/input/MIME:multipartRelated/MIME:part/MIME:content/@type for each type specified.</li>
<li>To set the MIME type of a REST operation. This replaces XML declared in WSDL by definitions/binding/operation/(input|output)/MIME:mimeXml with MIME:content/@type. Use <code>application/x-www-form-urlencoded</code> with REST POST and PUT protocols to send encoded form data automatically instead of XML. Only primitive type values can be transmitted with form data, such as numbers and strings, i.e. only types that are legal to use as <a href="#toxsd9-5">attributes members</a>.</li>
</ol>
<p>Use <code>method-input-mime-type</code> and <code>method-output-mime-type</code> to differentiate the attachment types between SOAP request and response messages.</p>
<p>üîù <a href="#">Back to table of contents</a></p>
<h2><a class="anchor" id="directives-3"></a>
Schema directives                                                </h2>
<p>A schema directive is of the form:</p>
<div class="fragment"><div class="line"><span class="comment">//gsoap &lt;prefix&gt; schema &lt;property&gt;: &lt;value&gt;</span></div></div><!-- fragment --><p>where <code>&lt;prefix&gt;</code> is the XML namespace prefix of a schema. The <code>&lt;property&gt;</code> and <code>&lt;value&gt;</code> fields are one of the following:</p>
<table class="doxtable">
<tr>
<th>property </th><th>value  </th></tr>
<tr>
<td><code>namespace</code> </td><td>URI of the XSD targetNamespace </td></tr>
<tr>
<td><code>namespace2</code> </td><td>alternate URI for the XSD namespace (i.e. URI is also accepted by the XML parser) </td></tr>
<tr>
<td><code>import</code> </td><td>URI of imported namespace </td></tr>
<tr>
<td><code>form</code> </td><td><code>unqualified</code> (default) or <code>qualified</code> local element and attribute form defaults </td></tr>
<tr>
<td><code>elementForm</code> </td><td><code>unqualified</code> (default) or <code>qualified</code> local element form default </td></tr>
<tr>
<td><code>attributeForm</code> </td><td><code>unqualified</code> (default) or <code>qualified</code> local attribute form default </td></tr>
<tr>
<td><code>typed</code> </td><td><code>no</code> (default) or <code>yes</code> for serializers to add <code>xsi:type</code> attributes to XML </td></tr>
</table>
<p>To learn more about the local form defaults, see <a href="#toxsd9-6">qualified and unqualified members.</a></p>
<p>The <code>typed</code> property is implicitly <code>yes</code> when soapcpp2 option <code>-t</code> is used.</p>
<p>üîù <a href="#">Back to table of contents</a></p>
<h2><a class="anchor" id="directives-4"></a>
Schema type directives                                           </h2>
<p>A schema type directive is of the form:</p>
<div class="fragment"><div class="line"><span class="comment">//gsoap &lt;prefix&gt; schema type-&lt;property&gt;: &lt;name&gt; &lt;value&gt;</span></div><div class="line"><span class="comment">//gsoap &lt;prefix&gt; schema type-&lt;property&gt;: &lt;name&gt;::&lt;member&gt; &lt;value&gt;</span></div></div><!-- fragment --><p>where <code>&lt;prefix&gt;</code> is the XML namespace prefix of a schema and <code>&lt;name&gt;</code> is an unqualified name of a C/C++ type, and the optional <code>&lt;member&gt;</code> is a class/struct members or enum constant.</p>
<p>You can describe a type:</p>
<table class="doxtable">
<tr>
<th>type property </th><th>value  </th></tr>
<tr>
<td><code>type-documentation</code> </td><td>text describing the schema type </td></tr>
<tr>
<td><code>type</code> </td><td>same as above, shorthand form </td></tr>
</table>
<p>For example, you can add a description to an enumeration:</p>
<div class="fragment"><div class="line"><span class="comment">//gsoap ns schema type: Vowels The letters A, E, I, O, U, and sometimes Y</span></div><div class="line"><span class="comment">//gsoap ns schema type: Vowels::Y A vowel, sometimes</span></div><div class="line"><span class="keyword">enum class</span> ns__Vowels : char { A = <span class="charliteral">&#39;A&#39;</span>, E = <span class="charliteral">&#39;E&#39;</span>, I = <span class="charliteral">&#39;I&#39;</span>, O = <span class="charliteral">&#39;O&#39;</span>, U = <span class="charliteral">&#39;U&#39;</span>, Y = <span class="charliteral">&#39;Y&#39;</span> };</div></div><!-- fragment --><p>This documented enumeration maps to a simpleType restriction of <code>xsd:string</code> in the soapcpp2-generated schema:</p>
<div class="alt"> <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;&lt;<span class="keywordtype">simpleType</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;Vowels&quot;</span>&gt;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  &lt;<span class="keywordtype">annotation</span>&gt;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    &lt;<span class="keywordtype">documentation</span>&gt;<span class="keyword">The</span> <span class="keyword">letters</span> <span class="keyword">A</span>, <span class="keyword">E</span>, <span class="keyword">I</span>, <span class="keyword">O</span>, <span class="keyword">U</span>, <span class="keyword">and</span> <span class="keyword">sometimes</span> <span class="keyword">Y</span>&lt;/<span class="keywordtype">documentation</span>&gt;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;  &lt;/<span class="keywordtype">annotation</span>&gt;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;  &lt;<span class="keywordtype">restriction</span> <span class="keyword">base</span>=<span class="stringliteral">&quot;xsd:string&quot;</span>&gt;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    &lt;<span class="keywordtype">enumeration</span> <span class="keyword">value</span>=<span class="stringliteral">&quot;A&quot;</span>/&gt;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    &lt;<span class="keywordtype">enumeration</span> <span class="keyword">value</span>=<span class="stringliteral">&quot;E&quot;</span>/&gt;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    &lt;<span class="keywordtype">enumeration</span> <span class="keyword">value</span>=<span class="stringliteral">&quot;I&quot;</span>/&gt;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;    &lt;<span class="keywordtype">enumeration</span> <span class="keyword">value</span>=<span class="stringliteral">&quot;O&quot;</span>/&gt;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    &lt;<span class="keywordtype">enumeration</span> <span class="keyword">value</span>=<span class="stringliteral">&quot;U&quot;</span>/&gt;</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;    &lt;<span class="keywordtype">enumeration</span> <span class="keyword">value</span>=<span class="stringliteral">&quot;Y&quot;</span>&gt;</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;      &lt;<span class="keywordtype">annotation</span>&gt;</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;        &lt;<span class="keywordtype">documentation</span>&gt;<span class="keyword">A</span> <span class="keyword">vowel</span>, <span class="keyword">sometimes</span>&lt;/<span class="keywordtype">documentation</span>&gt;</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;      &lt;/<span class="keywordtype">annotation</span>&gt;</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;    &lt;<span class="keywordtype">enumeration</span>/&gt;</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;  &lt;/<span class="keywordtype">restriction</span>&gt;</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;&lt;/<span class="keywordtype">simpleType</span>&gt;</div></div><!-- fragment --> </div><p>üîù <a href="#">Back to table of contents</a></p>
<h1><a class="anchor" id="rules"></a>
Serialization rules                                                     </h1>
<p>A presentation on XML data bindings is not complete without discussing the serialization rules and options that put your data in XML on the wire or store it a file or buffer.</p>
<p>There are several options to choose from to serialize data in XML. The choice depends on the use of the SOAP protocol or if SOAP is not required. The wsdl2h tool automates this for you by taking the WSDL transport bindings into account when generating the service functions in C and C++ that use SOAP or REST.</p>
<p>The gSOAP tools are not limited to SOAP. The tools implement generic XML data bindings for SOAP, REST, and other uses of XML. So you can read and write XML using the serializing <a href="#toxsd9-14">operations on classes and structs</a>.</p>
<p>The following sections briefly explain the serialization rules with respect to the SOAP protocol for XML Web services. A basic understanding of the SOAP protocol is useful when developing client and server applications that must interoperate with other SOAP applications.</p>
<p>SOAP/REST Web service client and service operations are represented as functions in your gSOAP header file with the data binding interface for soapcpp2. The soapcpp2 tool will translate these function to client-side service invocation calls and server-side service operation dispatchers.</p>
<p>A discussion of SOAP clients and servers is beyond the scope of this article. However, the SOAP options discussed here also apply to SOAP client and server development.</p>
<p>üîù <a href="#">Back to table of contents</a></p>
<h2><a class="anchor" id="doc-rpc"></a>
SOAP document versus rpc style                                        </h2>
<p>The <code>wsdl:binding/soap:binding/@style</code> attribute in the <code>&lt;wsdl:binding&gt;</code> section of a WSDL is either "document" or "rpc". The "rpc" style refers to SOAP RPC (Remote Procedure Call), which is more restrictive than the "document" style by requiring one XML element in the SOAP Body to act as the procedure name with XML subelements as its parameters.</p>
<p>For example, the following directives in the gSOAP header file for soapcpp2 declare that <code>DBupdate</code> is a SOAP RPC encoding service method:</p>
<div class="fragment"><div class="line"><span class="comment">//gsoap ns service namespace:       urn:DB</span></div><div class="line"><span class="comment">//gsoap ns service method-protocol: DBupdate SOAP</span></div><div class="line"><span class="comment">//gsoap ns service method-style:    DBupdate rpc</span></div><div class="line"><span class="keywordtype">int</span> ns__DBupdate(...);</div></div><!-- fragment --><p>The XML payload has a SOAP envelope, optional SOAP header, and a SOAP body with one element representing the operation with the parameters as subelements:</p>
<div class="alt"> <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;&lt;<span class="keywordtype">SOAP-ENV:Envelope</span></div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  <span class="keyword">xmlns:SOAP-ENV</span>=<span class="stringliteral">&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;</span></div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  <span class="keyword">xmlns:SOAP-ENC</span>=<span class="stringliteral">&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;</span></div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;  <span class="keyword">xmlns:xsi</span>=<span class="stringliteral">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;  <span class="keyword">xmlns:xsd</span>=<span class="stringliteral">&quot;http://www.w3.org/2001/XMLSchema&quot;</span></div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;  <span class="keyword">xmlsn:ns</span>=<span class="stringliteral">&quot;urn:DB&quot;</span>&gt;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;  &lt;<span class="keywordtype">SOAP-ENV:Body</span>&gt;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    &lt;<span class="keywordtype">ns:DBupdate</span>&gt;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;      ...</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    &lt;/<span class="keywordtype">ns:DBupdate</span>&gt;</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;  &lt;/<span class="keywordtype">SOAP-ENV:Body</span>&gt;</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;&lt;/<span class="keywordtype">SOAP-ENV:Envelope</span>&gt;</div></div><!-- fragment --> </div><p>The "document" style puts no restrictions on the SOAP Body content. However, we recommend that the first element's tag name in the SOAP Body should be unique to each type of operation, so that the receiver can dispatch the operation based on this element's tag name. Alternatively, the HTTP URL path can be used to specify the operation, or the HTTP action header can be used to dispatch operations automatically on the server side (soapcpp2 options -a and -A).</p>
<p>üîù <a href="#">Back to table of contents</a></p>
<h2><a class="anchor" id="lit-enc"></a>
SOAP literal versus encoding                                          </h2>
<p>The <code>wsdl:operation/soap:body/@use</code> attribute in the <code>&lt;wsdl:binding&gt;</code> section of a WSDL is either "literal" or "encoded". The "encoded" use refers to the SOAP encoding rules that support id-ref multi-referenced elements to serialize data as graphs.</p>
<p>SOAP encoding is very useful if the data internally forms a graph (including cycles) and we want the graph to be serialized in XML in a format that ensures that its structure is preserved. In that case, SOAP 1.2 encoding is the best option.</p>
<p>SOAP encoding also adds encoding rules for <a href="#toxsd10">SOAP arrays</a> to serialize multi-dimensional arrays. The use of XML attributes to exchange XML data in SOAP encoding is not permitted. The only attributes permitted are the standard XSD attributes, SOAP encoding attributes (such as for arrays), and id-ref.</p>
<p>For example, the following directives in the gSOAP header file for soapcpp2 declare that <code>DBupdate</code> is a SOAP RPC encoding service method:</p>
<div class="fragment"><div class="line"><span class="comment">//gsoap ns service namespace:       urn:DB</span></div><div class="line"><span class="comment">//gsoap ns service method-protocol: DBupdate SOAP</span></div><div class="line"><span class="comment">//gsoap ns service method-style:    DBupdate rpc</span></div><div class="line"><span class="comment">//gsoap ns service method-encoding: DBupdate encoded</span></div><div class="line"><span class="keywordtype">int</span> ns__DBupdate(...);</div></div><!-- fragment --><p>The XML payload has a SOAP envelope, optional SOAP header, and a SOAP body with an encodingStyle attribute for SOAP 1.1 encoding and an element representing the operation with parameters that are SOAP 1.1 encoded:</p>
<div class="alt"> <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;&lt;<span class="keywordtype">SOAP-ENV:Envelope</span></div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  <span class="keyword">xmlns:SOAP-ENV</span>=<span class="stringliteral">&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;</span></div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  <span class="keyword">xmlns:SOAP-ENC</span>=<span class="stringliteral">&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;</span></div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;  <span class="keyword">xmlns:xsi</span>=<span class="stringliteral">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;  <span class="keyword">xmlns:xsd</span>=<span class="stringliteral">&quot;http://www.w3.org/2001/XMLSchema&quot;</span></div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;  <span class="keyword">xmlsn:ns</span>=<span class="stringliteral">&quot;urn:DB&quot;</span>&gt;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;  &lt;<span class="keywordtype">SOAP-ENV:Body</span> <span class="keyword">SOAP-ENV:encodingStyle</span>=<span class="stringliteral">&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;</span>&gt;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    &lt;<span class="keywordtype">ns:DBupdate</span>&gt;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;      &lt;<span class="keywordtype">records</span> <span class="keyword">SOAP-ENC:arrayType</span>=<span class="stringliteral">&quot;ns:record[3]&quot;</span>&gt;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;        &lt;<span class="keywordtype">item</span>&gt;</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;          &lt;<span class="keywordtype">name</span> <span class="keyword">href</span>=<span class="stringliteral">&quot;#_1&quot;</span>/&gt;</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;          &lt;<span class="keywordtype">SSN</span>&gt;1234567890&lt;/<span class="keywordtype">SSN</span>&gt;</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;        &lt;/<span class="keywordtype">item</span>&gt;</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;        &lt;<span class="keywordtype">item</span>&gt;</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;          &lt;<span class="keywordtype">name</span>&gt;<span class="keyword">Jane</span>&lt;/<span class="keywordtype">name</span>&gt;</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;          &lt;<span class="keywordtype">SSN</span>&gt;1987654320&lt;/<span class="keywordtype">SSN</span>&gt;</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;        &lt;/<span class="keywordtype">item</span>&gt;</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;        &lt;<span class="keywordtype">item</span>&gt;</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;          &lt;<span class="keywordtype">name</span> <span class="keyword">href</span>=<span class="stringliteral">&quot;#_1&quot;</span>/&gt;</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;          &lt;<span class="keywordtype">SSN</span>&gt;2345678901&lt;/<span class="keywordtype">SSN</span>&gt;</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;        &lt;/<span class="keywordtype">item</span>&gt;</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;      &lt;/<span class="keywordtype">records</span>&gt;</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;    &lt;/<span class="keywordtype">ns:DBupdate</span>&gt;</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;    &lt;<span class="keywordtype">id</span> <span class="keyword">id</span>=<span class="stringliteral">&quot;_1&quot;</span> <span class="keyword">xsi:type</span>=<span class="stringliteral">&quot;xsd:string&quot;</span>&gt;<span class="keyword">Joe</span>&lt;/<span class="keywordtype">id</span>&gt;</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;  &lt;/<span class="keywordtype">SOAP-ENV:Body</span>&gt;</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;&lt;/<span class="keywordtype">SOAP-ENV:Envelope</span>&gt;</div></div><!-- fragment --> </div><p>Note that the name "Joe" is shared by two records and the string is referenced by SOAP 1.1 href and id attributes.</p>
<p>While gSOAP only introduces multi-referenced elements in the payload when they are actually multi-referenced in the data graph, other SOAP applications may render multi-referenced elements more aggressively. The example could also be rendered as:</p>
<div class="alt"> <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;&lt;<span class="keywordtype">SOAP-ENV:Envelope</span></div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  <span class="keyword">xmlns:SOAP-ENV</span>=<span class="stringliteral">&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;</span></div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  <span class="keyword">xmlns:SOAP-ENC</span>=<span class="stringliteral">&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;</span></div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;  <span class="keyword">xmlns:xsi</span>=<span class="stringliteral">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;  <span class="keyword">xmlns:xsd</span>=<span class="stringliteral">&quot;http://www.w3.org/2001/XMLSchema&quot;</span></div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;  <span class="keyword">xmlsn:ns</span>=<span class="stringliteral">&quot;urn:DB&quot;</span>&gt;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;  &lt;<span class="keywordtype">SOAP-ENV:Body</span> <span class="keyword">SOAP-ENV:encodingStyle</span>=<span class="stringliteral">&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;</span>&gt;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    &lt;<span class="keywordtype">ns:DBupdate</span>&gt;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;      &lt;<span class="keywordtype">records</span> <span class="keyword">SOAP-ENC:arrayType</span>=<span class="stringliteral">&quot;ns:record[3]&quot;</span>&gt;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;        &lt;<span class="keywordtype">item</span> <span class="keyword">href</span>=<span class="stringliteral">&quot;#id1&quot;</span>/&gt;</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;        &lt;<span class="keywordtype">item</span> <span class="keyword">href</span>=<span class="stringliteral">&quot;#id2&quot;</span>/&gt;</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;        &lt;<span class="keywordtype">item</span> <span class="keyword">href</span>=<span class="stringliteral">&quot;#id3&quot;</span>/&gt;</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;      &lt;/<span class="keywordtype">records</span>&gt;</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;    &lt;/<span class="keywordtype">ns:DBupdate</span>&gt;</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;    &lt;<span class="keywordtype">id</span> <span class="keyword">id</span>=<span class="stringliteral">&quot;id1&quot;</span> <span class="keyword">xsi:type</span>=<span class="stringliteral">&quot;ns:record&quot;</span>&gt;</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;      &lt;<span class="keywordtype">name</span> <span class="keyword">href</span>=<span class="stringliteral">&quot;#id4&quot;</span>/&gt;</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;      &lt;<span class="keywordtype">SSN</span>&gt;1234567890&lt;/<span class="keywordtype">SSN</span>&gt;</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;    &lt;/<span class="keywordtype">id</span>&gt;</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;    &lt;<span class="keywordtype">id</span> <span class="keyword">id</span>=<span class="stringliteral">&quot;id2&quot;</span> <span class="keyword">xsi:type</span>=<span class="stringliteral">&quot;ns:record&quot;</span>&gt;</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;      &lt;<span class="keywordtype">name</span> <span class="keyword">href</span>=<span class="stringliteral">&quot;#id5&quot;</span>/&gt;</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;      &lt;<span class="keywordtype">SSN</span>&gt;1987654320&lt;/<span class="keywordtype">SSN</span>&gt;</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;    &lt;/<span class="keywordtype">id</span>&gt;</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;    &lt;<span class="keywordtype">id</span> <span class="keyword">id</span>=<span class="stringliteral">&quot;id3&quot;</span> <span class="keyword">xsi:type</span>=<span class="stringliteral">&quot;ns:record&quot;</span>&gt;</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;      &lt;<span class="keywordtype">name</span> <span class="keyword">href</span>=<span class="stringliteral">&quot;#id4&quot;</span>/&gt;</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;      &lt;<span class="keywordtype">SSN</span>&gt;2345678901&lt;/<span class="keywordtype">SSN</span>&gt;</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;    &lt;/<span class="keywordtype">id</span>&gt;</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;    &lt;<span class="keywordtype">id</span> <span class="keyword">id</span>=<span class="stringliteral">&quot;id4&quot;</span> <span class="keyword">xsi:type</span>=<span class="stringliteral">&quot;xsd:string&quot;</span>&gt;<span class="keyword">Joe</span>&lt;/<span class="keywordtype">id</span>&gt;</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;    &lt;<span class="keywordtype">id</span> <span class="keyword">id</span>=<span class="stringliteral">&quot;id5&quot;</span> <span class="keyword">xsi:type</span>=<span class="stringliteral">&quot;xsd:string&quot;</span>&gt;<span class="keyword">Jane</span>&lt;/<span class="keywordtype">id</span>&gt;</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;  &lt;/<span class="keywordtype">SOAP-ENV:Body</span>&gt;</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;&lt;/<span class="keywordtype">SOAP-ENV:Envelope</span>&gt;</div></div><!-- fragment --> </div><p>SOAP 1.2 encoding is cleaner and produces more accurate XML encodings of data graphs by setting the id attribute on the element that is referenced:</p>
<div class="alt"> <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;&lt;<span class="keywordtype">SOAP-ENV:Envelope</span></div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  <span class="keyword">xmlns:SOAP-ENV</span>=<span class="stringliteral">&quot;http://www.w3.org/2003/05/soap-envelope&quot;</span></div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  <span class="keyword">xmlns:SOAP-ENC</span>=<span class="stringliteral">&quot;http://www.w3.org/2003/05/soap-encoding&quot;</span></div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;  <span class="keyword">xmlns:xsi</span>=<span class="stringliteral">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;  <span class="keyword">xmlns:xsd</span>=<span class="stringliteral">&quot;http://www.w3.org/2001/XMLSchema&quot;</span></div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;  <span class="keyword">xmlsn:ns</span>=<span class="stringliteral">&quot;urn:DB&quot;</span>&gt;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;  &lt;<span class="keywordtype">SOAP-ENV:Body</span>&gt;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    &lt;<span class="keywordtype">ns:DBupdate</span> <span class="keyword">SOAP-ENV:encodingStyle</span>=<span class="stringliteral">&quot;http://www.w3.org/2003/05/soap-encoding&quot;</span>&gt;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;      &lt;<span class="keywordtype">records</span> <span class="keyword">SOAP-ENC:itemType</span>=<span class="stringliteral">&quot;ns:record&quot;</span> <span class="keyword">SOAP-ENC:arraySize</span>=<span class="stringliteral">&quot;3&quot;</span>&gt;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;        &lt;<span class="keywordtype">item</span>&gt;</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;          &lt;<span class="keywordtype">name</span> <span class="keyword">SOAP-ENC:id</span>=<span class="stringliteral">&quot;_1&quot;</span>&gt;<span class="keyword">Joe</span>&lt;/<span class="keywordtype">name</span>&gt;</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;          &lt;<span class="keywordtype">SSN</span>&gt;1234567890&lt;/<span class="keywordtype">SSN</span>&gt;</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;        &lt;/<span class="keywordtype">item</span>&gt;</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;        &lt;<span class="keywordtype">item</span>&gt;</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;          &lt;<span class="keywordtype">name</span>&gt;<span class="keyword">Jane</span>&lt;/<span class="keywordtype">name</span>&gt;</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;          &lt;<span class="keywordtype">SSN</span>&gt;1987654320&lt;/<span class="keywordtype">SSN</span>&gt;</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;        &lt;/<span class="keywordtype">item</span>&gt;</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;        &lt;<span class="keywordtype">item</span>&gt;</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;          &lt;<span class="keywordtype">name</span> <span class="keyword">SOAP-ENC:ref</span>=<span class="stringliteral">&quot;_1&quot;</span>/&gt;</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;          &lt;<span class="keywordtype">SSN</span>&gt;2345678901&lt;/<span class="keywordtype">SSN</span>&gt;</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;        &lt;/<span class="keywordtype">item</span>&gt;</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;      &lt;/<span class="keywordtype">records</span>&gt;</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;    &lt;/<span class="keywordtype">ns:DBupdate</span>&gt;</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;  &lt;/<span class="keywordtype">SOAP-ENV:Body</span>&gt;</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;&lt;/<span class="keywordtype">SOAP-ENV:Envelope</span>&gt;</div></div><!-- fragment --> </div><dl class="section note"><dt>Note</dt><dd>Some SOAP 1.2 applications consider the namespace <code>SOAP-ENC</code> of <code>SOAP-ENC:id</code> and <code>SOAP-ENC:ref</code> optional. The gSOAP SOAP 1.2 encoding serialization follows the 2007 standard, while accepting unqualified id and ref attributes.</dd></dl>
<p>To remove all rendered id-ref multi-referenced elements in gSOAP, use the <code>SOAP_XML_TREE</code> flag to initialize the gSOAP engine context.</p>
<p>Some XSD validation rules are turned off with SOAP encoding, because of the presence of additional attributes, such as id and ref/href, SOAP arrays with arbitrary element tags for array elements, and the occurrence of additional multi-ref elements in the SOAP 1.1 Body.</p>
<p>The use of "literal" puts no restrictions on the XML in the SOAP Body. Full XSD validation is possible, which can be enabled with the <code>SOAP_XML_STRICT</code> flag to initialize the gSOAP engine context. However, data graphs will be serialized as trees and cycles in the data will be cut from the XML rendition.</p>
<p>üîù <a href="#">Back to table of contents</a></p>
<h2><a class="anchor" id="soap"></a>
SOAP 1.1 versus SOAP 1.2                                                 </h2>
<p>There are two SOAP protocol versions: 1.1 and 1.2. The gSOAP tools can switch between the two versions seamlessly. You can declare the default SOAP version for a service operation as follows:</p>
<div class="fragment"><div class="line"><span class="comment">//gsoap ns service method-protocol: DBupdate SOAP1.2</span></div></div><!-- fragment --><p>The gSOAP soapcpp2 auto-generates client and server code. At the client side, this operation sends data with SOAP 1.2 but accepts responses also in SOAP 1.1. At the server side, this operation accepts requests in SOAP 1.1 and 1.2 and will return responses in the same SOAP version.</p>
<p>As we discussed in the previous section, the SOAP 1.2 protocol has a cleaner multi-referenced element serialization format that greatly enhances the accuracy of data graph serialization with SOAP RPC encoding and is therefore recommended.</p>
<p>The SOAP 1.2 protocol default can also be set by importing and loading <code>gsoap/import/soap12.h</code>:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#import &quot;soap12.h&quot;</span></div></div><!-- fragment --><p>üîù <a href="#">Back to table of contents</a></p>
<h2><a class="anchor" id="non-soap"></a>
Non-SOAP XML serialization                                           </h2>
<p>You can serialize data that is stored on the heap, on the stack (locals), and static data as long as the serializable (i.e. non-transient) members are properly initialized and pointers in the structures are either NULL or point to valid structures. Deserialized data is put on the heap and managed by the gSOAP engine context <code>struct soap</code>, see also <a href="#memory">memory management</a>.</p>
<p>You can read and write XML directly to a file or stream with the serializing <a href="#toxsd9-14">operations on classes and structs</a>.</p>
<p>To define and use XML Web service client and service operations, we can declare these operations in your gSOAP header file with the data binding interface for soapcpp2 as functions. The function are translated by soapcpp2 to client-side service invocation calls and server-side service operation dispatchers.</p>
<p>The REST operations POST, GET, and PUT are declared with <code>//gsoap</code> directives in the gSOAP header file for soapcpp2. For example, a REST POST operation is declared as follows:</p>
<div class="fragment"><div class="line"><span class="comment">//gsoap ns service namespace:       urn:DB</span></div><div class="line"><span class="comment">//gsoap ns service method-protocol: DBupdate POST</span></div><div class="line"><span class="keywordtype">int</span> ns__DBupdate(...);</div></div><!-- fragment --><p>There is no SOAP Envelope and no SOAP Body in the payload for <code>DBupdate</code>. Also the XML serialization rules are identical to SOAP document/literal. The XML payload only has the operation name as an element with its parameters serialized as subelements:</p>
<div class="alt"> <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;&lt;<span class="keywordtype">ns:DBupdate</span> <span class="keyword">xmln:ns</span>=<span class="stringliteral">&quot;urn:DB&quot;</span> ...&gt;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160; ...</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;&lt;/<span class="keywordtype">ns:DBupdate</span>&gt;</div></div><!-- fragment --> </div><p>To force id-ref serialization with REST similar to SOAP 1.2 multi-reference encoding, use the <code>SOAP_XML_GRAPH</code> flag to initialize the gSOAP engine context. The XML serialization includes id and ref attributes for multi-referenced elements as follows:</p>
<div class="alt"> <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;&lt;<span class="keywordtype">ns:DBupdate</span> <span class="keyword">xmln:ns</span>=<span class="stringliteral">&quot;urn:DB&quot;</span> ...&gt;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  &lt;<span class="keywordtype">records</span>&gt;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    &lt;<span class="keywordtype">item</span>&gt;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;      &lt;<span class="keywordtype">name</span> <span class="keyword">id</span>=<span class="stringliteral">&quot;_1&quot;</span>&gt;<span class="keyword">Joe</span>&lt;/<span class="keywordtype">name</span>&gt;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;      &lt;<span class="keywordtype">SSN</span>&gt;1234567890&lt;/<span class="keywordtype">SSN</span>&gt;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    &lt;/<span class="keywordtype">item</span>&gt;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    &lt;<span class="keywordtype">item</span>&gt;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;      &lt;<span class="keywordtype">name</span>&gt;<span class="keyword">Jane</span>&lt;/<span class="keywordtype">name</span>&gt;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;      &lt;<span class="keywordtype">SSN</span>&gt;1987654320&lt;/<span class="keywordtype">SSN</span>&gt;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    &lt;/<span class="keywordtype">item</span>&gt;</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;    &lt;<span class="keywordtype">item</span>&gt;</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;      &lt;<span class="keywordtype">name</span> <span class="keyword">ref</span>=<span class="stringliteral">&quot;_1&quot;</span>/&gt;</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;      &lt;<span class="keywordtype">SSN</span>&gt;2345678901&lt;/<span class="keywordtype">SSN</span>&gt;</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;    &lt;/<span class="keywordtype">item</span>&gt;</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;  &lt;/<span class="keywordtype">records</span>&gt;</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;&lt;/<span class="keywordtype">ns:DBupdate</span>&gt;</div></div><!-- fragment --> </div><p>üîù <a href="#">Back to table of contents</a></p>
<h1><a class="anchor" id="io"></a>
Input and output                                                           </h1>
<p>Reading and writing XML from/to files, streams and string buffers is done via the managing context by setting one of the following context members that control IO sources and sinks:</p>
<div class="fragment"><div class="line">soap-&gt;recvfd = fd; <span class="comment">// an int file descriptor to read from (0 by default)</span></div><div class="line">soap-&gt;sendfd = fd; <span class="comment">// an int file descriptor to write to (1 by default)</span></div><div class="line">soap-&gt;is = &amp;is;    <span class="comment">// C++ only: a std::istream is object to read from</span></div><div class="line">soap-&gt;os = &amp;os;    <span class="comment">// C++ only: a std::ostream os object to write to</span></div><div class="line">soap-&gt;is = cs;     <span class="comment">// C only: a const char* string to read from (soap-&gt;is will advance)</span></div><div class="line">soap-&gt;os = &amp;cs;    <span class="comment">// C only: pointer to a const char*, will be set to point to the string output</span></div></div><!-- fragment --><p>Normally, all of these context members are NULL, which is required to send and receive data over sockets by gSOAP clients and servers. Therefore, if you set any of these context members in a client or server application then you MUST reset them to NULL to ensure that socket communications are not blocked.</p>
<p>Note: the use of <code>soap-&gt;is</code> and <code>soap-&gt;os</code> in C requires gSOAP 2.8.28 or later.</p>
<p>In the following sections, we present more details on how to read and write to files and streams, and use string buffers as sources and sinks for XML data.</p>
<p>In addition, you can set IO callback functions to handle IO at a lower level.</p>
<p>For more details, see the <a href="http://www.genivia.com/doc/soapdoc2.html">gSOAP user guide.</a></p>
<p>üîù <a href="#">Back to table of contents</a></p>
<h2><a class="anchor" id="io1"></a>
Reading and writing from/to files and streams                             </h2>
<p>The default IO is standard input and output. Other sources and sinks (those listed above) will be used until you (re)set them. For example with file-based input and output:</p>
<div class="fragment"><div class="line">FILE *fp = fopen(<span class="stringliteral">&quot;record.xml&quot;</span>, <span class="stringliteral">&quot;r&quot;</span>);</div><div class="line"><span class="keywordflow">if</span> (fp != NULL)</div><div class="line">{</div><div class="line">  soap-&gt;recvfd = fileno(fp);    <span class="comment">// get file descriptor of file to read from</span></div><div class="line">  <span class="keywordflow">if</span> (soap_read_ns__record(soap, &amp;pers1))</div><div class="line">    ... <span class="comment">// handle IO error</span></div><div class="line">  fclose(fp);</div><div class="line">  soap-&gt;recvfd = 0;             <span class="comment">// read from stdin, or -1 to block reading</span></div><div class="line">}</div><div class="line"></div><div class="line">FILE *fp = fopen(<span class="stringliteral">&quot;record.xml&quot;</span>, <span class="stringliteral">&quot;w&quot;</span>);</div><div class="line"><span class="keywordflow">if</span> (fp != NULL)</div><div class="line">{</div><div class="line">  soap-&gt;sendfd = fileno(fp);    <span class="comment">// get file descriptor of file to write to</span></div><div class="line">  <span class="keywordflow">if</span> (soap_write_ns__record(soap, &amp;pers1))</div><div class="line">    ... <span class="comment">// handle IO error</span></div><div class="line">  fclose(fp);</div><div class="line">  soap-&gt;sendfd = 1;             <span class="comment">// write to stdout, or -1 to block writing</span></div><div class="line">}</div></div><!-- fragment --><p>Similar code with streams in C++:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line">std::fstream fs;</div><div class="line">fs.open(<span class="stringliteral">&quot;record.xml&quot;</span>, std::ios::in);</div><div class="line"><span class="keywordflow">if</span> (fs)</div><div class="line">{</div><div class="line">  soap-&gt;is = &amp;fs;</div><div class="line">  <span class="keywordflow">if</span> (soap_read__ns__record(soap, &amp;pers1))</div><div class="line">    ... <span class="comment">// handle IO error</span></div><div class="line">  fs.close();</div><div class="line">  soap-&gt;is = NULL;</div><div class="line">}</div><div class="line"></div><div class="line">fs.open(<span class="stringliteral">&quot;record.xml&quot;</span>, std::ios::out);</div><div class="line"><span class="keywordflow">if</span> (fs)</div><div class="line">{</div><div class="line">  soap-&gt;os = &amp;fs;</div><div class="line">  <span class="keywordflow">if</span> (soap_write__ns__record(soap, &amp;pers1))</div><div class="line">    ... <span class="comment">// handle IO error</span></div><div class="line">  fs.close();</div><div class="line">  soap-&gt;os = NULL;</div><div class="line">}</div></div><!-- fragment --><p>üîù <a href="#">Back to table of contents</a></p>
<h2><a class="anchor" id="io2"></a>
Reading and writing from/to string buffers                                </h2>
<p>For C++ we recommend to use <code>std::stringstream</code> objects from <code>&lt;sstream&gt;</code> as illustrated in the following example:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;sstream&gt;</span></div><div class="line"></div><div class="line">std::stringstream ss;</div><div class="line">ss.str(<span class="stringliteral">&quot;...&quot;</span>); <span class="comment">// XML to parse</span></div><div class="line">soap-&gt;is = &amp;ss;</div><div class="line"><span class="keywordflow">if</span> (soap_read__ns__record(soap, &amp;pers1))</div><div class="line">  ... <span class="comment">// handle IO error</span></div><div class="line">soap-&gt;is = NULL;</div><div class="line"></div><div class="line">soap-&gt;os = &amp;ss;</div><div class="line"><span class="keywordflow">if</span> (soap_write__ns__record(soap, &amp;pers1))</div><div class="line">  ... <span class="comment">// handle IO error</span></div><div class="line">soap-&gt;os = NULL;</div><div class="line">std::string s = ss.str(); <span class="comment">// string with XML</span></div></div><!-- fragment --><p>For C we can use <code>soap-&gt;is</code> and <code>soap-&gt;os</code> to point to strings of XML content as follows (this requires gSOAP 2.8.28 or later):</p>
<div class="fragment"><div class="line">soap-&gt;is = <span class="stringliteral">&quot;...&quot;</span>; <span class="comment">// XML to parse</span></div><div class="line"><span class="keywordflow">if</span> (soap_read__ns__record(soap, &amp;pers1))</div><div class="line">  ... <span class="comment">// handle IO error</span></div><div class="line">soap-&gt;is = NULL;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> *cs = NULL;</div><div class="line">soap-&gt;os = &amp;cs;</div><div class="line"><span class="keywordflow">if</span> (soap_write__ns__record(soap, &amp;pers1))</div><div class="line">  ... <span class="comment">// handle IO error</span></div><div class="line">soap-&gt;os = NULL;</div><div class="line">... = cs; <span class="comment">// string with XML (do not free(cs): managed by the context and freed with soap_end())</span></div></div><!-- fragment --><p>Note that <code>soap-&gt;os</code> is a pointer to a <code>const char*</code> string. The pointer is set by the managing context to point to the XML data that is stored on the context-managed heap.</p>
<p>For earlier gSOAP versions we recommend to use IO callbacks <code>soap-&gt;frecv</code> and <code>soap-&gt;fsend</code>, see the <a href="http://www.genivia.com/doc/soapdoc2.html">gSOAP user guide.</a></p>
<p>üîù <a href="#">Back to table of contents</a></p>
<h1><a class="anchor" id="memory"></a>
Memory management                                                      </h1>
<p>Memory management with the <code>soap</code> context enables us to allocate data in context-managed heap space that can be collectively deleted. All deserialized data is placed on the context-managed heap by the gSOAP engine.</p>
<p>üîù <a href="#">Back to table of contents</a></p>
<h2><a class="anchor" id="memory1"></a>
Memory management in C                                                </h2>
<p>When working with gSOAP in C (i.e. using wsdl2h option <code>-c</code> and soapcpp2 option <code>-c</code>), data is allocated on the managed heap with:</p>
<ul>
<li><code>void *soap_malloc(struct soap*, size_t len)</code>.</li>
</ul>
<p>You can also make shallow copies of data with <code>soap_memdup</code> that uses <code>soap_malloc</code> and a safe version of <code>memcpy</code> to copy a chunk of data <code>src</code> with length <code>len</code> to the context-managed heap:</p>
<ul>
<li><code>void * soap_memdup(struct soap*, const void *src, size_t len)</code></li>
</ul>
<p>This function returns a pointer to the copy. This function requires gSOAP 2.8.27 or later.</p>
<p>In gSOAP 2.8.35 and later, you can use an auto-generated function to allocate and initialize data of type <code>T</code> on the managed heap:</p>
<ul>
<li><code>T * soap_new_T(struct soap*, int n)</code></li>
</ul>
<p>This function returns an array of length <code>n</code> of type <code>T</code> data that is default initialized (by internally calling <code>soap_malloc(soap, n * sizeof(T))</code> and then <code>soap_default_T(soap, T*)</code> on each array value). Use <code>n=1</code> to allocate and initialize a single value.</p>
<p>The <code>soap_malloc</code> function is a wrapper around <code>malloc</code>, but which also permits the <code>struct soap</code> context to track all heap allocations for collective deletion with <code>soap_end(soap)</code>:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;soapH.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;ns.nsmap&quot;</span></div><div class="line">...</div><div class="line">struct soap *soap = soap_new(); <span class="comment">// new context</span></div><div class="line">...</div><div class="line">struct ns__record *record = (<span class="keyword">struct </span>ns__record*)soap_malloc(soap, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> ns__record));</div><div class="line">soap_default_ns__record(soap, record); <span class="comment">// auto-generated struct initializer</span></div><div class="line">...</div><div class="line">soap_destroy(soap); <span class="comment">// only for C++, see section on C++ below</span></div><div class="line">soap_end(soap);     <span class="comment">// delete record and all other heap allocations</span></div><div class="line">soap_free(soap);    <span class="comment">// delete context</span></div></div><!-- fragment --><p>All data on the managed heap is mass-deleted with <code>soap_end(soap)</code> which must be called before <code>soap_done(soap)</code> or <code>soap_free(soap)</code>, which end the use of the <code>soap</code> engine context and free the context, respectively. Use <code>soap_free(soap)</code> only when the context is allocated with <code>soap_new()</code>. Use <code>soap_done(soap)</code> only when the context is stack allocated (so cannot be deleted from the heap).</p>
<p>The managed heap is checked for memory leaks when the gSOAP code is compiled with <code>-DDEBUG</code>.</p>
<p>The soapcpp2 auto-generated deserializers in C use <code>soap_malloc</code> to allocate and populate deserialized structures, which are managed by the context for collective deletion.</p>
<p>To make <code>char*</code> and <code>wchar_t*</code> string copies to the context-managed heap, we can use the functions:</p>
<ul>
<li><code>char *soap_strdup(struct soap*, const char *str)</code> and</li>
<li><code>wchar_t *soap_wstrdup(struct soap*, const wchar_t *wstr)</code>.</li>
</ul>
<p>If your C compiler supports <code>typeof</code> then you can use the following macro to simplify the managed heap allocation and initialization of primitive values:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define soap_assign(soap, lhs, rhs) (*(lhs = (typeof(lhs))soap_malloc(soap, sizeof(*lhs))) = rhs)</span></div></div><!-- fragment --><p>Pointers to primitive values are often used for optional members. For example, assume we have the following struct:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>ns__record</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span>        *name 1; <span class="comment">// required (minOccurs=1)</span></div><div class="line">  uint64_t          *SSN;    <span class="comment">// optional (pointer means minOccurs=0)</span></div><div class="line">  <span class="keyword">struct </span>ns__record *spouse; <span class="comment">// optional (pointer means minOccurs=0)</span></div><div class="line">};</div></div><!-- fragment --><p>Use <code>soap_assign</code> to create a SSN value on the managed heap:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>soap *soap = soap_new(); <span class="comment">// new context</span></div><div class="line">...</div><div class="line">struct ns__record *record = (<span class="keyword">struct </span>ns__record*)soap_malloc(soap, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> ns__record));</div><div class="line">soap_default_ns__record(soap, record);</div><div class="line">record-&gt;name = soap_strdup(soap, <span class="stringliteral">&quot;Joe&quot;</span>);</div><div class="line">soap_assign(soap, record-&gt;SSN, 1234567890UL);</div><div class="line">...</div><div class="line">soap_end(soap);     <span class="comment">// delete managed soap_malloc&#39;ed heap data</span></div><div class="line">soap_free(soap);    <span class="comment">// delete context</span></div></div><!-- fragment --><p>Without the <code>soap_assign</code> macro, you will need two lines of code, one to allocate and one to assign (you should also use this if your system can run out of memory):</p>
<div class="fragment"><div class="line">assert((record-&gt;SSN = (uint64_t*)soap_malloc(soap, <span class="keyword">sizeof</span>(utint64_t))) != NULL);</div><div class="line">*record-&gt;SSN = 1234567890UL;</div></div><!-- fragment --><p>The gSOAP serializer can serialize any heap, stack, or static allocated data. So we can also create a new record as follows:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>soap *soap = soap_new(); <span class="comment">// new context</span></div><div class="line">...</div><div class="line">struct ns__record *record = (<span class="keyword">struct </span>ns__record*)soap_malloc(soap, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> ns__record));</div><div class="line"><span class="keyword">static</span> uint64_t SSN = 1234567890UL;</div><div class="line">soap_default_ns__record(soap, record);</div><div class="line">record-&gt;name = <span class="stringliteral">&quot;Joe&quot;</span>;</div><div class="line">record-&gt;SSN = &amp;SSN; <span class="comment">// safe to use static values: the value of record-&gt;SSN is never changed by gSOAP</span></div><div class="line">...</div><div class="line">soap_end(soap);     <span class="comment">// delete managed soap_malloc&#39;ed heap data</span></div><div class="line">soap_free(soap);    <span class="comment">// delete context</span></div></div><!-- fragment --><p>Use the soapcpp2 auto-generated <code>soap_dup_T</code> functions to duplicate data into another context (this requires soapcpp2 option <code>-Ec</code> to generate), here shown for C with the second argument <code>dst</code> NULL because we want to allocate a new managed structure:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>soap *other_soap = soap_new(); <span class="comment">// another context</span></div><div class="line"><span class="keyword">struct </span>ns__record *other_record = soap_dup_ns__record(other_soap, NULL, record);</div><div class="line">...</div><div class="line">soap_destroy(other_soap); <span class="comment">// only for C++, see section on C++ below</span></div><div class="line">soap_end(other_soap);     <span class="comment">// delete other_record and all of its deep data</span></div><div class="line">soap_free(other_soap);    <span class="comment">// delete context</span></div></div><!-- fragment --><p>Note that the only reason to use another context and not to use the primary context is when the primary context must be destroyed together with all of the objects it manages while some of the objects must be kept alive. If the objects that are kept alive contain deep cycles then this is the only option we have, because deep copy with a managing context detects and preserves these cycles unless the <code>SOAP_XML_TREE</code> flag is used with the context:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>soap *other_soap = soap_new1(SOAP_XML_TREE); <span class="comment">// another context</span></div><div class="line"><span class="keyword">struct </span>ns__record *other_record = soap_dup_ns__record(other_soap, NULL, record);</div></div><!-- fragment --><p>The resulting deep copy will be a full copy of the source data structure as a tree without co-referenced data (i.e. no digraph) and without cycles. Cycles are pruned and (one of the) pointers that forms a cycle is repaced by NULL.</p>
<p>You can also deep copy into unmanaged space and use the auto-generated <code>soap_del_T()</code> function (requires soapcpp2 option <code>-Ed</code> to generate) to delete it later, but you MUST NOT do this for any data that has deep cycles in its runtime data structure:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>ns__record *other_record = soap_dup_ns__record(NULL, NULL, record);</div><div class="line">...</div><div class="line">soap_del_ns__record(other_record); <span class="comment">// deep delete record data members</span></div><div class="line">free(other_record);                <span class="comment">// delete the record</span></div></div><!-- fragment --><p>Cycles in the data structure will lead to non-termination when making unmanaged deep copies. Consider for example:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>ns__record</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span>         *name 1; <span class="comment">// required (minOccurs=1)</span></div><div class="line">  uint64_t            SSN;    <span class="comment">// required (non-pointer means minOccurs=1)</span></div><div class="line">  <span class="keyword">struct </span>ns__record  *spouse; <span class="comment">// optional (pointer means minOccurs=0)</span></div><div class="line">};</div></div><!-- fragment --><p>The code to populate a structure with a mutual spouse relationship:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>soap *soap = soap_new();</div><div class="line">...</div><div class="line">struct ns__record pers1, pers2;</div><div class="line">soap_default_ns__record(soap, &amp;pers1);</div><div class="line">soap_default_ns__record(soap, &amp;pers2);</div><div class="line">pers1.name = <span class="stringliteral">&quot;Joe&quot;</span>;                     <span class="comment">// OK to serialize static data</span></div><div class="line">pers1.SSN = 1234567890;</div><div class="line">pers1.spouse = &amp;pers2;</div><div class="line">pers2.name = soap_strdup(soap, <span class="stringliteral">&quot;Jane&quot;</span>); <span class="comment">// allocates and copies a string</span></div><div class="line">pers2.SSN = 1987654320;</div><div class="line">pers2.spouse = &amp;pers1;</div><div class="line">...</div><div class="line">struct ns__record *pers3 = soap_dup_ns__record(NULL, NULL, &amp;pers1); <span class="comment">// BAD</span></div><div class="line"><span class="keyword">struct </span>ns__record *pers4 = soap_dup_ns__record(soap, NULL, &amp;pers1); <span class="comment">// OK</span></div><div class="line">soap_set_mode(soap, SOAP_XML_TREE);</div><div class="line"><span class="keyword">struct </span>ns__record *pers5 = soap_dup_ns__record(soap, NULL, &amp;pers1); <span class="comment">// OK</span></div></div><!-- fragment --><p>As we can see, the gSOAP serializer can serialize any heap, stack, or static allocated data, such as in the code above. So we can serialize the stack-allocated <code>pers1</code> record as follows:</p>
<div class="fragment"><div class="line">FILE *fp = fopen(<span class="stringliteral">&quot;record.xml&quot;</span>, <span class="stringliteral">&quot;w&quot;</span>);</div><div class="line"><span class="keywordflow">if</span> (fp != NULL)</div><div class="line">{</div><div class="line">  soap-&gt;sendfd = fileno(fp);           <span class="comment">// file descriptor to write to</span></div><div class="line">  soap_set_mode(soap, SOAP_XML_GRAPH); <span class="comment">// support id-ref w/o requiring SOAP</span></div><div class="line">  soap_clr_mode(soap, SOAP_XML_TREE);  <span class="comment">// if set, clear</span></div><div class="line">  soap_write_ns__record(soap, &amp;pers1);</div><div class="line">  fclose(fp);</div><div class="line">  soap-&gt;sendfd = -1;                   <span class="comment">// block further writing</span></div><div class="line">}</div></div><!-- fragment --><p>which produces an XML document record.xml that is similar to:</p>
<div class="alt"> <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;&lt;<span class="keywordtype">ns:record</span> <span class="keyword">xmlns:ns</span>=<span class="stringliteral">&quot;urn:types&quot;</span> <span class="keyword">id</span>=<span class="stringliteral">&quot;Joe&quot;</span>&gt;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  &lt;<span class="keywordtype">name</span>&gt;<span class="keyword">Joe</span>&lt;/<span class="keywordtype">name</span>&gt;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  &lt;<span class="keywordtype">SSN</span>&gt;1234567890&lt;/<span class="keywordtype">SSN</span>&gt;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;  &lt;<span class="keywordtype">spouse</span> <span class="keyword">id</span>=<span class="stringliteral">&quot;Jane&quot;</span>&gt;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    &lt;<span class="keywordtype">name</span>&gt;<span class="keyword">Jane</span>&lt;/<span class="keywordtype">name</span>&gt;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    &lt;<span class="keywordtype">SSN</span>&gt;1987654320&lt;/<span class="keywordtype">SSN</span>&gt;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    &lt;<span class="keywordtype">spouse</span> <span class="keyword">ref</span>=<span class="stringliteral">&quot;#Joe&quot;</span>/&gt;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;  &lt;/<span class="keywordtype">spouse</span>&gt;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;&lt;/<span class="keywordtype">ns:record</span>&gt;</div></div><!-- fragment --> </div><p>Deserialization of an XML document with a SOAP 1.1/1.2 encoded id-ref graph leads to the same non-termination problem when we later try to copy the data into unmanaged memory heap space:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>soap *soap = soap_new1(SOAP_XML_GRAPH); <span class="comment">// support id-ref w/o SOAP</span></div><div class="line">...</div><div class="line">struct ns__record pers1;</div><div class="line">FILE *fp = fopen(<span class="stringliteral">&quot;record.xml&quot;</span>, <span class="stringliteral">&quot;r&quot;</span>);</div><div class="line"><span class="keywordflow">if</span> (fp != NULL)</div><div class="line">{</div><div class="line">  soap-&gt;recvfd = fileno(fp);</div><div class="line">  <span class="keywordflow">if</span> (soap_read_ns__record(soap, &amp;pers1))</div><div class="line">    ... <span class="comment">// handle IO error</span></div><div class="line">  fclose(fp);</div><div class="line">  soap-&gt;recvfd = -1;                    <span class="comment">// blocks further reading</span></div><div class="line">}</div><div class="line">...</div><div class="line">struct ns__record *pers3 = soap_dup_ns__record(NULL, NULL, &amp;pers1); <span class="comment">// BAD</span></div><div class="line"><span class="keyword">struct </span>ns__record *pers4 = soap_dup_ns__record(soap, NULL, &amp;pers1); <span class="comment">// OK</span></div><div class="line">soap_set_mode(soap, SOAP_XML_TREE);</div><div class="line"><span class="keyword">struct </span>ns__record *pers5 = soap_dup_ns__record(soap, NULL, &amp;pers1); <span class="comment">// OK</span></div></div><!-- fragment --><p>Copying data with <code>soap_dup_T(soap)</code> into managed heap memory space is always safe. Copying into unmanaged heap memory space requires diligence. But deleting unmanaged data is easy with <code>soap_del_T()</code>.</p>
<p>You can also use <code>soap_del_T()</code> to delete structures that you created in C, but only if these structures are created with <code>malloc</code> and do NOT contain pointers to stack and static data.</p>
<p>You can unlink one or more allocated objects from the managed heap to allow the object to live after <code>soap_end(soap)</code> by using:</p>
<ul>
<li><code>void soap_unlink(struct soap *soap, void *ptr)</code></li>
</ul>
<p>The unlinked heap-allocated data pointed to by <code>ptr</code> can be accessed after <code>soap_end(soap)</code>. Do not forget to free the data with <code>free(ptr)</code>. Be aware that <code>soap_unlink(soap, ptr)</code> does not perform a deep unlinkage. If <code>ptr</code> is a struct, pointer members will become invalid when pointing to objects on the managed heap. Use <code>soap_unlink(soap, ptr-&gt;member)</code> to unlink <code>member</code> as well.</p>
<p>Finally, when data is allocated in managed memory heap space, either explicitly with the allocation functions shown above or by the gSOAP deserializers, you can delegate the management and deletion of this data to another <code>struct soap</code> context. That context will be responsible to delete the data with <code>soap_end(soap)</code> later:</p>
<ul>
<li><code>void delegate_deletion(struct soap *soap_from, struct soap *soap_to)</code></li>
</ul>
<p>This allows the <code>soap_from</code> context to be deleted with <code>soap_free(soap_from)</code> (assuming it is allocated with <code>soap_new()</code>, use <code>soap_done(soap_from)</code> when <code>soap_from</code> is stack-allocated) while the managed data remains intact. You can use this function any time, to delegate management and deletion to another context <code>soap_to</code> and then continue with the current context. You can also use different source <code>soap_from</code> contexts to delegate management and deletion to the other <code>soap_to</code> context. To mass delete all managed data, use <code>soap_end(soap_to)</code>.</p>
<p>üîù <a href="#">Back to table of contents</a></p>
<h2><a class="anchor" id="memory2"></a>
Memory management in C++                                              </h2>
<p>When working with gSOAP in C++, the gSOAP engine allocates data on a managed heap using <code>soap_new_T(soap)</code> to allocate a type with type name <code>T</code>. Managed heap allocation is tracked by the <code>struct soap</code> context for collective deletion with <code>soap_destroy(soap)</code> for structs, classes, and templates and with <code>soap_end(soap)</code> for everything else.</p>
<p>You should only use <code>soap_malloc(struct soap*, size_t len)</code> to allocate primitive types, but <code>soap_new_T()</code> is preferred. The auto-generated <code>T * soap_new_T(struct soap*)</code> returns data allocated on the managed heap for type <code>T</code>. The data is mass-deleted with <code>soap_destroy(soap)</code> followed by <code>soap_end(soap)</code>.</p>
<p>The <code>soap_new_T</code> functions return NULL when allocation fails. C++ exceptions are never raised by gSOAP code when data is allocated, unless <code>SOAP_NOTHROW</code> (set to <code>(std::nothrow)</code>) is redefined to permit <code>new</code> to throw exceptions.</p>
<p>There are four variations of <code>soap_new_T()</code> to allocate data of type <code>T</code> that soapcpp2 auto-generates:</p>
<ul>
<li><code>T * soap_new_T(struct soap*)</code> returns a new instance of <code>T</code> that is default initialized. For classes, initialization is internally performed using the soapcpp2 auto-generated <code>void T::soap_default(struct soap*)</code> method of the class, but ONLY IF the soapcpp2 auto-generated default constructor is used that invokes <code>soap_default()</code> and was not replaced by a user-defined default constructor.</li>
<li><code>T * soap_new_T(struct soap*, int n)</code> returns an array of <code>n</code> new instances of <code>T</code>. The instances in the array are default initialized as described above.</li>
<li><code>T * soap_new_req_T(struct soap*, ...)</code> (structs and classes only) returns a new instance of <code>T</code> and sets the required data members to the values specified in <code>...</code>. The required data members are those with nonzero minOccurs, see the subsections on <a href="#toxsd9-8">(smart) pointer members and their occurrence constraints</a> and <a href="#toxsd9-9">container and array members and their occurrence constraints</a>.</li>
<li><code>T * soap_new_set_T(struct soap*, ...)</code> (structs and classes only) returns a new instance of <code>T</code> and sets the public/serializable data members to the values specified in <code>...</code>.</li>
</ul>
<p>The above functions can be invoked with a NULL <code>soap</code> context, but you are then responsible to use <code>delete T</code> to remove this instance from the unmanaged heap.</p>
<p>For example, to allocate a managed <code>std::string</code> you can use:</p>
<div class="fragment"><div class="line">std::string *s = <a class="code" href="address_h_8h.html#a6898f547fe3a350ad81cb25e9e16afe5">soap_new_std__string</a>(soap);</div></div><!-- fragment --><p>Primitive types and arrays of these are allocated with <code>soap_malloc</code> (<code>soap_new_T</code> calls <code>soap_malloc</code> for primitive type <code>T</code>). All primitive types (i.e. no classes, structs, class templates, containers, and smart pointers) are allocated with <code>soap_malloc</code> for reasons of efficiency.</p>
<p>You can use a C++ template to simplify the managed allocation and initialization of primitive values as follows (this is for primitive types only):</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</div><div class="line">T * soap_make(<span class="keyword">struct</span> soap *soap, T val) <span class="keywordflow">throw</span> (std::bad_alloc)</div><div class="line">{</div><div class="line">  T *p = (T*)soap_malloc(soap, <span class="keyword">sizeof</span>(T));</div><div class="line">  <span class="keywordflow">if</span> (p == NULL)</div><div class="line">    <span class="keywordflow">throw</span> std::bad_alloc();</div><div class="line">  *p = val;</div><div class="line">  <span class="keywordflow">return</span> p;</div><div class="line">}</div></div><!-- fragment --><p>For example, assuming we have the following class:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>ns__record</div><div class="line">{</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  std::string  name;   <span class="comment">// required (non-pointer means minOccurs=1)</span></div><div class="line">  uint64_t    *SSN;    <span class="comment">// optional (pointer means minOccurs=0)</span></div><div class="line">  ns__record  *spouse; <span class="comment">// optional (pointer means minOccurs=0)</span></div><div class="line">};</div></div><!-- fragment --><p>You can instantiate a record by using the auto-generated <code>soap_new_set_ns__record</code> and use <code>soap_make</code> to create a SSN value on the managed heap as follows:</p>
<div class="fragment"><div class="line">soap *soap = soap_new(); <span class="comment">// new context</span></div><div class="line">...</div><div class="line">ns__record *record = soap_new_set_ns__record(</div><div class="line">    soap,</div><div class="line">    <span class="stringliteral">&quot;Joe&quot;</span>,</div><div class="line">    soap_make&lt;uint64_t&gt;(soap, 1234567890UL),</div><div class="line">    NULL);</div><div class="line">...</div><div class="line">soap_destroy(soap); <span class="comment">// delete record and all other managed instances</span></div><div class="line">soap_end(soap);     <span class="comment">// delete managed soap_malloc&#39;ed heap data</span></div><div class="line">soap_free(soap);    <span class="comment">// delete context</span></div></div><!-- fragment --><p>All data on the managed heap is mass-deleted with <code>soap_end(soap)</code> which must be called before <code>soap_done(soap)</code> or <code>soap_free(soap)</code>, which end the use of the <code>soap</code> engine context and free the context, respectively. Use <code>soap_free(soap)</code> only when the context is allocated with <code>soap_new()</code>. Use <code>soap_done(soap)</code> only when the context is stack allocated (so cannot be deleted from the heap).</p>
<p>The managed heap is checked for memory leaks when the gSOAP code is compiled with <code>-DDEBUG</code>.</p>
<p>Note however that the gSOAP serializer can serialize any heap, stack, or static allocated data. So we can also create a new record as follows:</p>
<div class="fragment"><div class="line">uint64_t SSN = 1234567890UL;</div><div class="line">ns__record *record = soap_new_set_ns__record(soap, <span class="stringliteral">&quot;Joe&quot;</span>, &amp;SSN, NULL);</div></div><!-- fragment --><p>which will be fine to serialize this record as long as the local <code>SSN</code> stack-allocated value remains in scope when invoking the serializer and/or using <code>record</code>. It does not matter if <code>soap_destroy</code> and <code>soap_end</code> are called beyond the scope of <code>SSN</code>.</p>
<p>To facilitate class methods to access the managing context, we can add a soap context pointer to a class/struct:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>ns__record</div><div class="line">{</div><div class="line">  ...</div><div class="line">  <span class="keywordtype">void</span> create_more(); <span class="comment">// needs a context to create more internal data</span></div><div class="line"> <span class="keyword">protected</span>:</div><div class="line">  <span class="keyword">struct </span>soap *soap;  <span class="comment">// the context that manages this instance, or NULL</span></div><div class="line">};</div></div><!-- fragment --><p>The context is set when invoking <code>soap_new_T</code> (and similar) with a non-NULL context argument.</p>
<p>You can also use a template when an array of pointers to values is required. To create an array of pointers to values, define the following template:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</div><div class="line">T **soap_make_array(<span class="keyword">struct</span> soap *soap, T* array, <span class="keywordtype">int</span> n) <span class="keywordflow">throw</span> (std::bad_alloc)</div><div class="line">{ </div><div class="line">  T **p = (T**)soap_malloc(soap, n * <span class="keyword">sizeof</span>(T*));</div><div class="line">  <span class="keywordflow">if</span> (p == NULL)</div><div class="line">    <span class="keywordflow">throw</span> std::bad_alloc();</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; n; ++i)</div><div class="line">    p[i] = &amp;array[i];</div><div class="line">  <span class="keywordflow">return</span> p;</div><div class="line">}</div></div><!-- fragment --><p>The <code>array</code> parameter is a pointer to an array of <code>n</code> values. The template returns an array of <code>n</code> pointers that point to the values in that array:</p>
<div class="fragment"><div class="line"><span class="comment">// create an array of 100 pointers to 100 records</span></div><div class="line"><span class="keywordtype">int</span> n = 100;</div><div class="line">ns__record **precords = soap_make_array(soap, soap_new_ns__record(soap, n), n);</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; n; ++i)</div><div class="line">{</div><div class="line">  precords[i]-&gt;name = <span class="stringliteral">&quot;...&quot;</span>;</div><div class="line">  precords[i]-&gt;SSN = soap_make&lt;uint64_t&gt;(1234567890UL + i);</div><div class="line">}</div></div><!-- fragment --><p>Note that <code>soap_new_ns__record(soap, n)</code> returns a pointer to an array of <code>n</code> records, which is then used to create an array of <code>n</code> pointers to these records.</p>
<p>Use the soapcpp2 auto-generated <code>soap_dup_T</code> functions to duplicate data into another context (this requires soapcpp2 option <code>-Ec</code> to generate), here shown for C++ with the second argument <code>dst</code> NULL to allocate a new managed object:</p>
<div class="fragment"><div class="line">soap *other_soap = soap_new(); <span class="comment">// another context</span></div><div class="line">ns__record *other_record = soap_dup_ns__record(other_soap, NULL, record);</div><div class="line">...</div><div class="line">soap_destroy(other_soap); <span class="comment">// delete record and other managed instances</span></div><div class="line">soap_end(other_soap);     <span class="comment">// delete other data (the SSNs on the heap)</span></div><div class="line">soap_free(other_soap);    <span class="comment">// delete context</span></div></div><!-- fragment --><p>To duplicate base and derived instances when a base class pointer or reference is provided, use the auto-generated method <code>T * T::soap_dup(struct soap*)</code>:</p>
<div class="fragment"><div class="line">soap *other_soap = soap_new(); <span class="comment">// another context</span></div><div class="line">ns__record *other_record = record-&gt;soap_dup(other_soap);</div><div class="line">...</div><div class="line">soap_destroy(other_soap); <span class="comment">// delete record and other managed instances</span></div><div class="line">soap_end(other_soap);     <span class="comment">// delete other data (the SSNs on the heap)</span></div><div class="line">soap_free(other_soap);    <span class="comment">// delete context</span></div></div><!-- fragment --><p>Note that the only reason to use another context and not to use the primary context is when the primary context must be destroyed together with all of the objects it manages while some of the objects must be kept alive. If the objects that are kept alive contain deep cycles then this is the only option we have, because deep copy with a managing context detects and preserves these cycles unless the <code>SOAP_XML_TREE</code> flag is used with the context:</p>
<div class="fragment"><div class="line">soap *other_soap = soap_new1(SOAP_XML_TREE);             <span class="comment">// another context</span></div><div class="line">ns__record *other_record = record-&gt;soap_dup(other_soap); <span class="comment">// deep tree copy</span></div></div><!-- fragment --><p>The resulting deep copy will be a full copy of the source data structure as a tree without co-referenced data (i.e. no digraph) and without cycles. Cycles are pruned and (one of the) pointers that forms a cycle is repaced by NULL.</p>
<p>You can also deep copy into unmanaged space and use the auto-generated <code>soap_del_T()</code> function or the <code>T::soap_del()</code> method (requires soapcpp2 option <code>-Ed</code> to generate) to delete it later, but we MUST NOT do this for any data that has deep cycles in its runtime data structure graph:</p>
<div class="fragment"><div class="line">ns__record *other_record = record-&gt;soap_dup(NULL);</div><div class="line">...</div><div class="line">other_record-&gt;soap_del(); <span class="comment">// deep delete record data members</span></div><div class="line"><span class="keyword">delete</span> other_record;      <span class="comment">// delete the record</span></div></div><!-- fragment --><p>Cycles in the data structure will lead to non-termination when making unmanaged deep copies. Consider for example:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>ns__record</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span>  *name 1; <span class="comment">// required (minOccurs=1)</span></div><div class="line">  uint64_t     SSN;    <span class="comment">// required (non-pointer means minOccurs=1)</span></div><div class="line">  ns__record  *spouse; <span class="comment">// optional (pointer means minOccurs=1)</span></div><div class="line">};</div></div><!-- fragment --><p>The code to populate a structure with a mutual spouse relationship:</p>
<div class="fragment"><div class="line">soap *soap = soap_new();</div><div class="line">...</div><div class="line">ns__record pers1, pers2;</div><div class="line">pers1.name = <span class="stringliteral">&quot;Joe&quot;</span>;</div><div class="line">pers1.SSN = 1234567890;</div><div class="line">pers1.spouse = &amp;pers2;</div><div class="line">pers2.name = <span class="stringliteral">&quot;Jane&quot;</span>;</div><div class="line">pers2.SSN = 1987654320;</div><div class="line">pers2.spouse = &amp;pers1;</div><div class="line">...</div><div class="line">ns__record *pers3 = soap_dup_ns__record(NULL, NULL, &amp;pers1); <span class="comment">// BAD</span></div><div class="line">ns__record *pers4 = soap_dup_ns__record(soap, NULL, &amp;pers1); <span class="comment">// OK</span></div><div class="line">soap_set_mode(soap, SOAP_XML_TREE);</div><div class="line">ns__record *pers5 = soap_dup_ns__record(soap, NULL, &amp;pers1); <span class="comment">// OK</span></div></div><!-- fragment --><p>Note that the gSOAP serializer can serialize any heap, stack, or static allocated data, such as in the code above. So we can serialize the stack-allocated <code>pers1</code> record as follows:</p>
<div class="fragment"><div class="line">FILE *fp = fopen(<span class="stringliteral">&quot;record.xml&quot;</span>, <span class="stringliteral">&quot;w&quot;</span>);</div><div class="line"><span class="keywordflow">if</span> (fp != NULL)</div><div class="line">{</div><div class="line">  soap-&gt;sendfd = fileno(fp);           <span class="comment">// file descriptor to write to</span></div><div class="line">  soap_set_mode(soap, SOAP_XML_GRAPH); <span class="comment">// support id-ref w/o requiring SOAP</span></div><div class="line">  soap_clr_mode(soap, SOAP_XML_TREE);  <span class="comment">// if set, clear</span></div><div class="line">  <span class="keywordflow">if</span> (soap_write_ns__record(soap, &amp;pers1))</div><div class="line">    ... <span class="comment">// handle IO error</span></div><div class="line">      fclose(fp);</div><div class="line">  soap-&gt;sendfd = -1;                   <span class="comment">// block further writing</span></div><div class="line">}</div></div><!-- fragment --><p>which produces an XML document record.xml that is similar to:</p>
<div class="alt"> <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;&lt;<span class="keywordtype">ns:record</span> <span class="keyword">xmlns:ns</span>=<span class="stringliteral">&quot;urn:types&quot;</span> <span class="keyword">id</span>=<span class="stringliteral">&quot;Joe&quot;</span>&gt;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  &lt;<span class="keywordtype">name</span>&gt;<span class="keyword">Joe</span>&lt;/<span class="keywordtype">name</span>&gt;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  &lt;<span class="keywordtype">SSN</span>&gt;1234567890&lt;/<span class="keywordtype">SSN</span>&gt;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;  &lt;<span class="keywordtype">spouse</span> <span class="keyword">id</span>=<span class="stringliteral">&quot;Jane&quot;</span>&gt;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    &lt;<span class="keywordtype">name</span>&gt;<span class="keyword">Jane</span>&lt;/<span class="keywordtype">name</span>&gt;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    &lt;<span class="keywordtype">SSN</span>&gt;1987654320&lt;/<span class="keywordtype">SSN</span>&gt;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    &lt;<span class="keywordtype">spouse</span> <span class="keyword">ref</span>=<span class="stringliteral">&quot;#Joe&quot;</span>/&gt;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;  &lt;/<span class="keywordtype">spouse</span>&gt;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;&lt;/<span class="keywordtype">ns:record</span>&gt;</div></div><!-- fragment --> </div><p>Deserialization of an XML document with a SOAP 1.1/1.2 encoded id-ref graph leads to the same non-termination problem when we later try to copy the data into unmanaged space:</p>
<div class="fragment"><div class="line">soap *soap = soap_new1(SOAP_XML_GRAPH); <span class="comment">// support id-ref w/o SOAP</span></div><div class="line">...</div><div class="line">ns__record pers1;</div><div class="line">FILE *fp = fopen(<span class="stringliteral">&quot;record.xml&quot;</span>, <span class="stringliteral">&quot;r&quot;</span>);</div><div class="line"><span class="keywordflow">if</span> (fp != NULL)</div><div class="line">{</div><div class="line">  soap-&gt;recvfd = fileno(fp);            <span class="comment">// file descriptor to read from</span></div><div class="line">  <span class="keywordflow">if</span> (soap_read_ns__record(soap, &amp;pers1))</div><div class="line">    ... <span class="comment">// handle IO error</span></div><div class="line">  fclose(fp);</div><div class="line">  soap-&gt;recvfd = -1;                    <span class="comment">// block further reading</span></div><div class="line">}</div><div class="line">...</div><div class="line">ns__record *pers3 = soap_dup_ns__record(NULL, NULL, &amp;pers1); <span class="comment">// BAD</span></div><div class="line">ns__record *pers4 = soap_dup_ns__record(soap, NULL, &amp;pers1); <span class="comment">// OK</span></div><div class="line">soap_set_mode(soap, SOAP_XML_TREE);</div><div class="line">ns__record *pers5 = soap_dup_ns__record(soap, NULL, &amp;pers1); <span class="comment">// OK</span></div></div><!-- fragment --><p>Copying data with <code>soap_dup_T(soap)</code> into managed space is always safe. Copying into unmanaged space requires diligence. But deleting unmanaged data is easy with <code>soap_del_T()</code>.</p>
<p>You can also use <code>soap_del_T()</code> to delete structures in C++, but only if these structures are created with <code>new</code> (and <code>new []</code> for arrays when applicable) for classes, structs, and class templates and with <code>malloc</code> for anything else, and the structures do NOT contain pointers to stack and static data.</p>
<p>You can unlink one or more allocated objects from the managed heap to allow the object to live after <code>soap_destroy(soap)</code> and <code>soap_end(soap)</code> by using:</p>
<ul>
<li><code>void soap_unlink(struct soap *soap, void *ptr)</code></li>
</ul>
<p>The unlinked heap-allocated data pointed to by <code>ptr</code> can be accessed after <code>soap_destroy(soap)</code> and <code>soap_end(soap)</code>. Do not forget to free the data with <code>delete ptr</code> (C++ class instance only) or with <code>free(ptr)</code> (non-class data). Be aware that <code>soap_unlink(soap, ptr)</code> does not perform a deep unlinkage. If <code>ptr</code> is a struct or class, pointer members will become invalid when pointing to objects on the managed heap. Use <code>soap_unlink(soap, ptr-&gt;member)</code> to unlink <code>member</code> as well.</p>
<p>Finally, when data is allocated in managed memory heap space, either explicitly with the allocation functions shown above or by the gSOAP deserializers, you can delegate the management and deletion of this data to another <code>struct soap</code> context. That context will be responsible to delete the data with <code>soap_destroy(soap)</code> and <code>soap_end(soap)</code> later:</p>
<ul>
<li><code>void delegate_deletion(struct soap *soap_from, struct soap *soap_to)</code></li>
</ul>
<p>This allows the <code>soap_from</code> context to be deleted with <code>soap_free(soap_from)</code> (assuming it is allocated with <code>soap_new()</code>, use <code>soap_done(soap_from)</code> when <code>soap_from</code> is stack-allocated) while the managed data remains intact. You can use this function any time, to delegate management and deletion to another context <code>soap_to</code> and then continue with the current context. You can also use different source <code>soap_from</code> contexts to delegate management and deletion to the other <code>soap_to</code> context. To mass delete all managed data, use <code>soap_destroy(soap_to)</code> followed by <code>soap_end(soap_to)</code>.</p>
<p>üîù <a href="#">Back to table of contents</a></p>
<h1><a class="anchor" id="flags"></a>
Context flags to initialize the soap struct                             </h1>
<p>There are several context initialization flags and context mode flags to control XML serialization at runtime. The flags are set with <code>soap_new1()</code> to allocate and initialize a new context:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>soap *soap = soap_new1(&lt;flag&gt; | &lt;flag&gt; ... | &lt;flag&gt;);</div><div class="line">...</div><div class="line">soap_destroy(soap); <span class="comment">// delete objects</span></div><div class="line">soap_end(soap);     <span class="comment">// delete other data and temp data</span></div><div class="line">soap_free(soap);    <span class="comment">// free context</span></div></div><!-- fragment --><p>and with <code>soap_init1()</code> for stack-allocated contexts:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>soap soap;</div><div class="line">soap_init1(&amp;soap, &lt;flag&gt; | &lt;flag&gt; ... | &lt;flag&gt;);</div><div class="line">...</div><div class="line">soap_destroy(&amp;soap); <span class="comment">// delete objects</span></div><div class="line">soap_end(&amp;soap);     <span class="comment">// delete other data and temp data</span></div><div class="line">soap_done(&amp;soap);    <span class="comment">// clear context</span></div></div><!-- fragment --><p>where <code>&lt;flag&gt;</code> is one of:</p>
<ul>
<li><code>SOAP_C_UTFSTRING</code>: enables all <code>std::string</code> and <code>char*</code> strings to contain UTF-8 content. This option is recommended.</li>
<li><code>SOAP_C_NILSTRING</code>: treat empty strings as if they were NULL pointers, i.e. omits elements and attributes when empty.</li>
<li><code>SOAP_XML_STRICT</code>: strictly validates XML while deserializing. Should not be used together with SOAP 1.1/1.2 encoding style of messaging. Use soapcpp2 option <code>-s</code> to hard code <code>SOAP_XML_STRICT</code> in the generated serializers. Not recommended with SOAP 1.1/1.2 encoding style messaging.</li>
<li><code>SOAP_XML_INDENT</code>: produces indented XML.</li>
<li><code>SOAP_XML_CANONICAL</code>: c14n canonocalization, removes unused <code>xmlns</code> bindings and adds them to appropriate places by applying c14n normalization rules. Should not be used together with SOAP 1.1/1.2 encoding style messaging.</li>
<li><code>SOAP_XML_TREE</code>: write tree XML without id-ref, while pruning data structure cycles to prevent nontermination of the serializer for cyclic structures.</li>
<li><code>SOAP_XML_GRAPH</code>: write graph (digraph and cyclic graphs with shared pointers to objects) using id-ref attributes. That is, XML with SOAP multi-ref encoded id-ref elements. This is a structure-preserving serialization format, because co-referenced data and also cyclic relations are accurately represented.</li>
<li><code>SOAP_XML_DEFAULTNS</code>: uses xmlns default namespace declarations, assuming that the schema attribute form is "qualified" by default (be warned if it is not, since attributes in the null namespace will get bound to namespaces!).</li>
<li><code>SOAP_XML_NIL</code>: emit empty element with <code>xsi:nil</code> for all NULL pointers serialized.</li>
<li><code>SOAP_XML_IGNORENS</code>: the XML parser ignores XML namespaces, i.e. element and attribute tag names match independent of their namespace.</li>
<li><code>SOAP_XML_NOTYPE</code>: removes all <code>xsi:type</code> attribuation. This option is usually not needed unless the receiver rejects all <code>xsi:type</code> attributes. This option may affect the quality of the deserializer, which relies on <code>xsi:type</code> attributes to distinguish base class instances from derived class instances transported in the XML payloads.</li>
<li><code>SOAP_IO_CHUNK</code>: to enable HTTP chunked transfers.</li>
<li><code>SOAP_IO_STORE</code>: full buffering of outbound messages.</li>
<li><code>SOAP_ENC_ZLIB</code>: compress messages, requires compiling with <code>-DWITH_GZIP</code> and linking with zlib (<code>-lz</code>).</li>
<li><code>SOAP_ENC_MIME</code>: enable MIME attachments, see <a href="#toxsd10-3">MIME/MTOM attachment binary types</a>.</li>
<li><code>SOAP_ENC_MTOM</code>: enable MTOM attachments, see <a href="#toxsd10-3">MIME/MTOM attachment binary types</a>.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>C++ Web service proxy and service classes have their own context, either as a base class (soapcpp2 option -i) or as a data member <code>soap</code> that points to a context (soapcpp2 option -j). These contexts are allocated when the proxy or service is instantiated with context flags that are passed to the constructor.</dd></dl>
<p>üîù <a href="#">Back to table of contents</a></p>
<h1><a class="anchor" id="params"></a>
Context parameter settings                                             </h1>
<p>After allocation and initializtion of a <code>struct soap</code> context, several context parameters can be set (some parameters may require 2.8.31 and later versions):</p>
<ul>
<li><code>unsigned int soap::maxlevel</code> is the maximum XML nesting depth levels that the parser permits. Default initialized to <code>SOAP_MAXLEVEL</code> (10000), which is a redefinable macro in stdsoap2.h. Set <code>soap::maxlevel</code> to a lower value to restrict XML parsing nesting depth.</li>
<li><code>long soap::maxlength</code> is the maximum string content length if not already constrained by an XML schema validation <code>maxLength</code> constraint. Zero means unlimited string lengths are permitted (unless restricted by XML schema <code>maxLength</code>). Default initialized to <code>SOAP_MAXLENGTH</code> (0), which is a redefinable macro in stdsoap2.h. Set <code>soap::maxlength</code> to a positive value to restrict the number of (wide) characters in strings parsed, restrict hexBinary byte length, and restrict base64Binary byte length.</li>
<li><code>size_t soap::maxoccurs</code> is the maximum number of array or container elements permitted by the parser. Must be greater than zero (0). Default initialized to <code>SOAP_MAXOCCURS</code> (100000), which is a redefinable macro in stdsoap2.h. Set <code>soap::maxoccurs</code> to a positive value to restrict the number of array and container elements that can be parsed.</li>
<li><code>soap::version</code> is the SOAP version used, with 0 for non-SOAP, 1 for SOAP1.1, and 2 for SOAP1.2. This value is normally set by web service operations, and is otherwise 0 (non-SOAP). Use <code>soap_set_version(struct soap*, short)</code> to set the value. This controls XML namespaces and SOAP id-ref serialization when applicable with an encodingStyle (see below).</li>
<li><code>const char *soap::encodingStyle</code> is a string that is used with SOAP encoding, normally NULL for non-SOAP XML. Set this string to "" (empty string) to enable SOAP encoding style, which supports id-ref graph serialization (see also the <code>SOAP_XML_GRAPH</code> <a href="#flags">context flag</a>).</li>
<li><code>int soap::recvfd</code> is the file descriptor to read and parse source data from. Default initialized to 0 (stdin). See also <a href="#io">input and output</a>.</li>
<li><code>int soap::sendfd</code> is the file descriptor to write data to. Default initialized to 1 (stdout). See also <a href="#io">input and output</a>.</li>
<li><code>const char *is</code> for C: string to read and parse source data from, overriding the <code>recvfd</code> source. Normally NULL. This value must be reset to NULL or the parser will continue to read from this string content until the NUL character. See also <a href="#io">input and output</a>.</li>
<li><code>std::istream *is</code> for C++: an input stream to read and parse source data from, overriding the <code>recvfd</code> source. Normally NULL. This value must be reset to NULL or the parser will continue to read from this stream until EOF. See also <a href="#io">input and output</a>.</li>
<li><code>const char **os</code> for C: points to a string (a <code>const char *</code>) that will be set to point to the string output. Normally NULL. This value must be reset to NULL or the next output will result in reassigning the pointer to point to the next string that is output. The strings are automatically deallocated by <code>soap_end(soap)</code>. See also <a href="#io">input and output</a>.</li>
<li><code>std::ostream *os</code> for C++: an output stream to write output to. Normally NULL. This value must be reste to NULL or the next output will be send to this stream. See also <a href="#io">input and output</a>.</li>
</ul>
<p>üîù <a href="#">Back to table of contents</a></p>
<h1><a class="anchor" id="errors"></a>
Error handling and reporting                                           </h1>
<p>The gSOAP API functions return <code>SOAP_OK</code> (zero) or a non-zero error code. The error code is stored in <code>int soap::error</code> of the current <code>struct soap</code> context. Error messages can be displayed with:</p>
<ul>
<li><code>void soap_stream_fault(struct soap*, std::ostream &amp;os)</code> for C++ only, prints the error message to an output stream.</li>
<li><code>void soap_print_fault(struct soap*, FILE *fd)</code> prints the error message to a FILE descriptor.</li>
<li><code>void soap_sprint_fault(struct soap*, char *buf, size_t len)</code> saves the error message to a fixed-size buffer allocated with a maximum length.</li>
<li><code>void soap_print_fault_location(struct soap*, FILE *fd)</code> prints the location and part of the XML where the parser encountered an error.</li>
</ul>
<p>C++ exceptions are never raised by gSOAP code, even when data is allocated. (That is unless the <code>SOAP_NOTHROW</code> macro (set to <code>(std::nothrow)</code> by default) is redefined to permit <code>new</code> to throw exceptions.)</p>
<p>A <code>SOAP_EOM</code> error code is returned when memory was exhausted during processing of input and/or output of data.</p>
<p>An EOF (<code>SOAP_EOF</code> or -1) error code is returned when the parser has hit EOF but expected more input, or when socket communications timed out. In addition to the <code>SOAP_EOF</code> error, the <code>int soap::errnum</code> of the <code>struct soap</code> context is set to the <code>errno</code> value of the operation that failed. For timeouts, the <code>soap::ernum</code> value is always 0 instead of an <code>errno</code> error code.</p>
<p>Use <code>soap_xml_error_check(soap-&gt;error)</code> to check for XML errors. This returns true (non-zero) when a parsing and validation error has occurred.</p>
<p>For example:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;sstream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">struct </span>soap *soap = soap_new1(SOAP_XML_INDENT | SOAP_XML_STRICT | SOAP_XML_TREE);</div><div class="line"><span class="keyword">struct </span>ns__record person;</div><div class="line">std::stringstream ss;</div><div class="line">ss.str(<span class="stringliteral">&quot;...&quot;</span>);      <span class="comment">// XML to parse</span></div><div class="line">soap-&gt;is = &amp;ss;</div><div class="line"><span class="keywordflow">if</span> (soap_read__ns__record(soap, &amp;person))</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> (soap_xml_error_check(soap-&gt;error))</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;XML parsing error!&quot;</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    soap_stream_fault(soap, std::cerr);</div><div class="line">}</div><div class="line"><span class="keywordflow">else</span></div><div class="line">{</div><div class="line">  ...               <span class="comment">// all OK, use person record</span></div><div class="line">}</div><div class="line">soap_destroy(soap); <span class="comment">// delete objects</span></div><div class="line">soap_end(soap);     <span class="comment">// delete other data and temp data</span></div><div class="line">soap_free(soap);    <span class="comment">// free context</span></div></div><!-- fragment --><p>When deploying your application on UNIX and Linux systems, UNIX signal handlers should be added to your code handle signals, in particular <code>SIGPIPE</code>:</p>
<div class="fragment"><div class="line">signal(SIGPIPE, sigpipe_handler);</div></div><!-- fragment --><p>where the <code>sigpipe_handler</code> is a function:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> sigpipe_handler(<span class="keywordtype">int</span> x) { }</div></div><!-- fragment --><p>Other UNIX signals may have to be handled as well.</p>
<p>The gSOAP engine is designed for easy memory cleanup after being interrupted. Use <code>soap_destroy(soap)</code> and <code>soap_end(soap)</code>, after which the <code>soap</code> context can be reused.</p>
<p>üîù <a href="#">Back to table of contents</a></p>
<h1><a class="anchor" id="features"></a>
Features and limitations                                             </h1>
<p>In general, to use the generated code:</p>
<ul>
<li>Make sure to <code>#include "soapH.h"</code> in your code and also define a namespace table or <code>#include "ns.nsmap"</code> with the generated table, where <code>ns</code> is the namespace prefix for services.</li>
<li>Use soapcpp2 option -j (C++ only) to generate C++ proxy and service objects. The auto-generated files include documented inferfaces. Compile with soapC.cpp and link with -lgsoap++, or alternatively compile stdsoap2.cpp.</li>
<li>Without soapcpp2 option -j: client-side uses the auto-generated soapClient.cpp and soapC.cpp (or C versions of those). Compile and link with -lgsoap++ (-lgsoap for C), or alternatively compile stdsoap2.cpp (stdsoap2.c for C).</li>
<li>Without soapcpp2 option -j: server-side uses the auto-generated soapServer.cpp and soapC.cpp (or C versions of those). Compile and link with -lgsoap++ (-lgsoap for C), or alternatively compile stdsoap2.cpp (stdsoap2.c for C).</li>
<li>Use <code>soap_new()</code> or <code>soap_new1(int flags)</code> to allocate and initialize a heap-allocated context with or without flags. Delete this context with <code>soap_free(struct soap*)</code>, but only after <code>soap_destroy(struct soap*)</code> and <code>soap_end(struct soap*)</code>.</li>
<li>Use <code>soap_init(struct *soap)</code> or <code>soap_init1(struct soap*, int flags)</code> to initialize a stack-allocated context with or without flags. End the use of this context with <code>soap_done(struct soap*)</code>, but only after <code>soap_destroy(struct soap*)</code> and <code>soap_end(struct soap*)</code>.</li>
</ul>
<p>Additional notes with respect to the wsdl2h and soapcpp2 tools:</p>
<ul>
<li>Nested classes, structs, and unions in a gSOAP header file are unnested by soapcpp2.</li>
<li>Use <code>#import "file.h"</code> instead of <code>#include</code> to import other header files in a gSOAP header file for soapcpp2. The <code>#include</code>, <code>#define</code>, and <code>#pragma</code> are accepted by soapcpp2, but are moved to the very start of the generated code for the C/C++ compiler to include before all generated definitions. Often it is useful to add an <code>#include</code> with a <a href="#toxsd9-2">volatile type</a> that includes the actual type declaration, and to ensure transient types are declared when these are used in a data binding interface declared in a gSOAP header file for soapcpp2.</li>
<li>To remove any SOAP-specific bindings, use soapcpp2 option <code>-0</code>.</li>
<li>A gSOAP header file for soapcpp2 should not include any code statements, only data type declarations. This includes constructor initialization lists that are not permitted. Use member initializations instead.</li>
<li>C++ namespaces are supported. Use wsdl2h option <code>-qname</code>. Or add a <code>namespace name { ... }</code> to the header file, but the <code>{ ... }</code> MUST cover the entire header file content from begin to end.</li>
<li>Optional XML DOM support can be used to store mixed content or literal XML content. Otherwise, mixed content may be lost. Use wsdl2h option <code>-d</code> for XML DOM support and compile and link with <code>dom.c</code> or <code>dom.cpp</code>. For details, see <a href="http://www.genivia.com/doc/dom/html">XML DOM and XPath</a>.</li>
</ul>
<p>üîù <a href="#">Back to table of contents</a></p>
<h1><a class="anchor" id="nsmap"></a>
Removing SOAP namespaces from XML payloads                              </h1>
<p>The soapcpp2 tool generates a <code>.nsmap</code> file that includes two bindings for SOAP namespaces. We can remove all SOAP namespaces (and SOAP processing logic) with soapcpp2 option <code>-0</code> or by simply setting the two entries to NULL:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Namespace namespaces[] =</div><div class="line">{</div><div class="line">  {<span class="stringliteral">&quot;SOAP-ENV&quot;</span>, NULL, NULL, NULL},</div><div class="line">  {<span class="stringliteral">&quot;SOAP-ENC&quot;</span>, NULL, NULL, NULL},</div><div class="line">  ...</div><div class="line">};</div></div><!-- fragment --><p>Note that once the <code>.nsmap</code> is generated, you can copy-paste the content into your project code. However, if we rerun wsdl2h on updated WSDL/XSD files or <code>typemap.dat</code> declarations then we need to use the updated table.</p>
<p>In cases that no XML namespaces are used at all, for example with <a href="http://www.genivia.com/doc/xml-rpc-json/html">XML-RPC</a>, you may use an empty namespace table:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Namespace namespaces[] = {{NULL,NULL,NULL,NULL}};</div></div><!-- fragment --><p>However, beware that any built-in xsi attributes that are rendered will lack the proper namespace binding. At least we suggest to use <code>SOAP_XML_NOTYPE</code> for this reason.</p>
<p>üîù <a href="#">Back to table of contents</a></p>
<h1><a class="anchor" id="examples"></a>
Examples                                                             </h1>
<p>Select the project files below to peruse the source code examples.</p>
<p>üîù <a href="#">Back to table of contents</a></p>
<h2>Source files </h2>
<ul>
<li><code>address.xsd</code> Address book schema</li>
<li><code><a class="el" href="address_8cpp.html">address.cpp</a></code> Address book app (reads/writes address.xml file)</li>
<li><code>addresstypemap.dat</code> Schema namespace prefix name preference for wsdl2h</li>
<li><code><a class="el" href="graph_8h.html">graph.h</a></code> <a class="el" href="class_graph.html">Graph</a> data binding (tree, digraph, cyclic graph)</li>
<li><code><a class="el" href="graph_8cpp.html">graph.cpp</a></code> Test graph serialization as tree, digraph, and cyclic</li>
</ul>
<p>üîù <a href="#">Back to table of contents</a></p>
<h2>Generated files </h2>
<ul>
<li><code><a class="el" href="address_8h.html">address.h</a></code> gSOAP-specific data binding definitions from address.xsd</li>
<li><code><a class="el" href="address_stub_8h.html">addressStub.h</a></code> C++ data binding definitions</li>
<li><code><a class="el" href="address_h_8h.html">addressH.h</a></code> Serializers</li>
<li><code>addressC.cpp</code> Serializers</li>
<li><code>address.xml</code> Address book data generated by address app</li>
<li><code><a class="el" href="graph_stub_8h.html">graphStub.h</a></code> C++ data binding definitions</li>
<li><code><a class="el" href="graph_h_8h.html">graphH.h</a></code> Serializers</li>
<li><code>graphC.cpp</code> Serializers</li>
<li><code>g.xsd</code> XSD schema with <code>g:<a class="el" href="class_graph.html">Graph</a></code> complexType</li>
<li><code>g.nsmap</code> xmlns bindings namespace mapping table</li>
</ul>
<p>üîù <a href="#">Back to table of contents</a></p>
<h2>Build steps </h2>
<p>Building the AddressBook example: </p><pre class="fragment">wsdl2h -g -t addresstypemap.dat address.xsd
soapcpp2 -0 -CS -I../../import -p address address.h
c++ -I../.. address.cpp addressC.cpp -o address -lgsoap++
</pre><p>Option <code>-g</code> produces bindings for global (root) elements in addition to types. In this case the root element <code>a:address-book</code> is bound to <code><a class="el" href="class__a____address__book.html" title="The root element of the address book schema. ">_a__address_book</a></code>. The complexType <code>a:address</code> is bound to class <code><a class="el" href="classa____address.html" title="An address information item. ">a__address</a></code>, which is also the type of <code><a class="el" href="class__a____address__book.html" title="The root element of the address book schema. ">_a__address_book</a></code>. This option is not required, but allows you to use global element tag names when referring to their serializers, instead of their type name. Option <code>-0</code> removes the SOAP protocol. Options <code>-C</code> and <code>-S</code> removes client and server code generation. Option <code>-p</code> renames the output <code>soap</code> files to <code>address</code> files.</p>
<p>See the <code><a class="el" href="address_8cpp.html">address.cpp</a></code> implementation and <a href="pages.html">related pages</a>.</p>
<p>The <code>addresstypemap.dat</code> file specifies the XML namespace prefix for the bindings: </p><pre class="fragment">#       Bind the address book schema namespace to prefix 'a'

a = "urn:address-book-example"

#       By default the xsd:dateTime schema type is translated to time_t
#       To map xsd:dateTime to struct tm, enable the following line:

# xsd__dateTime = #import "../../custom/struct_tm.h"

#       ... and compile/link with custom/struct_tm.c
</pre><p>The DOB field is a <code>xsd:dateTime</code>, which is bound to <code>time_t</code> by default. To change this to <code>struct tm</code>, enable the import of the <code>xsd__dateTime</code> custom serializer by uncommenting the definition of <code>xsd__dateTime</code> in <code>addresstypemap.dat</code>. Then change <code>soap_dateTime2s</code> to <code>soap_xsd__dateTime2s</code> in the code.</p>
<p>Building the graph serialization example: </p><pre class="fragment">soapcpp2 -CS -I../../import -p graph graph.h
c++ -I../.. graph.cpp graphC.cpp -o graph -lgsoap++
</pre><p>To compile without using the <code>libgsoap++</code> library: simply compile <code>stdsoap2.cpp</code> together with the above.</p>
<p>üîù <a href="#">Back to table of contents</a></p>
<h2>Usage </h2>
<p>To execute the AddressBook example: </p><pre class="fragment">./address
</pre><p>To execute the <a class="el" href="class_graph.html">Graph</a> serialization example: </p><pre class="fragment">./graph</pre> </div></div><!-- contents -->
</div><!-- doc-content -->
<hr class="footer">
<address class="footer">
Copyright (C) 2017, Robert van Engelen, Genivia Inc., All Rights Reserved.
</address>
<address class="footer"><small>
Converted on Tue Aug 22 2017 18:15:32 by <a target="_blank" href="http://www.doxygen.org/index.html">Doxygen</a> 1.8.11</small></address>
<br>
<div style="height: 246px; background: #DBDBDB;">
</body>
</html>
