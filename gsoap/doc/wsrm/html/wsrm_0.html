<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>gSOAP WS-ReliableMessaging: The wsrm plugin for client applications and stand-alone services</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.8 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1><a class="anchor" name="wsrm_0">The wsrm plugin for client applications and stand-alone services</a></h1><h2><a class="anchor" name="wsrm_1">
WS-ReliableMessaging Setup</a></h2>
The material in this section relates to the WS-ReliableMessaging and WS-Addressing (2005) specifications.<p>
To use the wsrm plugin:<ol>
<li>Run wsdl2h -t typemap.dat on a WSDL of a service that requires WS-ReliableMessaging and WS-Addressing headers. The typemap.dat file included in the gSOAP package is used to recognize and translate header blocks.</li><li>Run soapcpp2 -a on the header file produced by wsdl2h. To enable reliable-messaging and addressing-based service operation selection, you MUST use soapcpp2 option -a. This allows the service to dispatch methods based on the WS-Addressing action information header value (when the wsa plugin is registered).</li><li>(Re-)compile and link stdsoap2.c/pp or libgsoap, (dom.c/pp when needed), plugin/wsrmapi.c, plugin/wsaapi.c, custom/duration.c, and the soapcpp2- generated source files.</li><li>Use the wsrm plugin API functions described below. The wsrm plugin uses the wsa plugin to implement the WS-Addressing 2005 operations. Both must be registered. The wsrm plugin API is self-contained. There is no need to use the wsa plugin API, unless WS-Addressing-specific headers must be added to messages.</li></ol>
<p>
An example wsrm client/server application can be found in samples/wsrm.<p>
A gSOAP service definitions header file with a "wsrm import" to support WS-ReliableMessaging is automatically generated by wsdl2h for a set of WSDLs that use WS-ReliableMessaging. The wsdl2h-generated header file should be further processed by soapcpp2 to generate the binding code. The <a class="el" href="wsrmapi_8h.html">wsrmapi.h</a> and <a class="el" href="wsrmapi_8c.html">wsrmapi.c</a> implement the WS-ReliableMessaging API described in this document.<p>
A wsdl2h-generated service definitions header file might include the following imports, where the <a class="el" href="wsrm_8h.html">wsrm.h</a> is mandatory to support WS-ReliableMessaging:<p>
<div class="fragment"><pre><span class="preprocessor">#import "soap12.h"</span>
<span class="preprocessor">#import "<a class="code" href="wsrm_8h.html">wsrm.h</a>"</span>
</pre></div><p>
The <a class="el" href="wsrm_8h.html">wsrm.h</a> header file is imported from import/wsrm.h by soapcpp2. The <a class="el" href="wsrm_8h.html">wsrm.h</a> import can be manually added to enable WS-ReliableMessaging when needed. The gSOAP service definitions header file is processed with soapcpp2 to generate the client-side and/or server-side binding code.<p>
Note that the <a class="el" href="wsrm_8h.html">wsrm.h</a> and the WS-ReliableMessaging-dependent <a class="el" href="wsrx_8h.html">wsrx.h</a> and <a class="el" href="wsa5_8h.html">wsa5.h</a> header files are located in the import directory of the gSOAP package. These files define the WS-ReliableMessaging and WS-Addressing information header elements and types. The <a class="el" href="wsrx_8h.html">wsrx.h</a> header file defines the WS-ReliableMessaging CreateSequence, CloseSequence, and TerminateSequence operations, as well as an one-way SequenceAcknowledgement operation to accept acknowledgements. The soap12.h header file enables SOAP 1.2 messaging.<p>
For developers working on protocols: the WS-ReliableMessaging header blocks in <a class="el" href="wsrm_8h.html">wsrm.h</a> were generated from the WS-ReliableMessaging schema with the wsdl2h tool and WS/WS-typemap.dat as follows:<p>
<div class="fragment"><pre>    &gt; wsdl2h -cgyex -o wsrm.h -t WS/WS-typemap.dat WS/WS-ReliableMessaging.xsd
</pre></div><p>
This step is not needed to use the wsrm plugin.<h2><a class="anchor" name="wsrm_2">
WS-ReliableMessaging Information Header Bindings</a></h2>
To associate WS-ReliableMessaging and WS-Addressing information headers with service operations, the SOAP Header struct <a class="el" href="struct_s_o_a_p___e_n_v_____header.html">SOAP_ENV__Header</a> must have been declared and contain the necessary header blocks to be transported with SOAP messages. The <a class="el" href="struct_s_o_a_p___e_n_v_____header.html">SOAP_ENV__Header</a> for WS-ReliableMessaging and WS-Addressing is predefined in <a class="el" href="wsrm_8h.html">wsrm.h</a> and imported into the gSOAP service definitions header file (this is automatically generated by wsdl2h). For each service operation in the gSOAP service definitions header file that uses WS-ReliableMessaging and/or WS-Addressing method-header-part directives are used.<p>
For example, the following gSOAP service definitions header file illustrates a typical import and service operation definition of operation 'example' in service namespace 'ns':<p>
<div class="fragment"><pre><span class="preprocessor">#import "<a class="code" href="wsrm_8h.html">wsrm.h</a>"</span>

<span class="comment">//gsoap ns service method-header-part: example wsa5__MessageID</span>
<span class="comment">//gsoap ns service method-header-part: example wsa5__RelatesTo</span>
<span class="comment">//gsoap ns service method-header-part: example wsa5__From</span>
<span class="comment">//gsoap ns service method-header-part: example wsa5__ReplyTo</span>
<span class="comment">//gsoap ns service method-header-part: example wsa5__FaultTo</span>
<span class="comment">//gsoap ns service method-header-part: example wsa5__To</span>
<span class="comment">//gsoap ns service method-header-part: example wsa5__Action</span>

<span class="comment">//gsoap ns service method-header-part: example wsrm__Sequence</span>
<span class="comment">//gsoap ns service method-header-part: example wsrm__AckRequested</span>
<span class="comment">//gsoap ns service method-header-part: example wsrm__SequenceAcknowledgement</span>

<span class="comment">//gsoap ns service method-action:          example urn:example/examplePort/example</span>
<span class="comment">//gsoap ns service method-response-action: example urn:example/examplePort/exampleResponse</span>

<span class="keywordtype">int</span> ns__example(<span class="keywordtype">char</span> *in, <span class="keyword">struct</span> ns__exampleResponse { <span class="keywordtype">char</span> *out; } *);
</pre></div><p>
The wsa5 information headers are defined in <a class="el" href="wsa5_8h.html">wsa5.h</a> and imported by <a class="el" href="wsrm_8h.html">wsrm.h</a> (both are located in the 'import' directory). Here, all of the WS-Addressing and WS-ReliableMessaging information headers are bound to the ns__example operation request and response messages.<p>
The method action directive is important for WS-Addressing, because WS-Addressing Action information headers must be included that are unique for each operation. The soapcpp2 option -a ensures that WS-Addressing Action header blocks (and HTTP Action headers) are processed at the receiving side, which means that the service dispatcher uses the Action together with the operation name to invoke the service operation at the destination. This also means that Action headers must be properly set by the client.<p>
Note: the <a class="el" href="struct_s_o_a_p___e_n_v_____header.html">SOAP_ENV__Header</a> struct can be declared in multiple files. The soapcpp2 tool gathers all members of the structs into the "final" <a class="el" href="struct_s_o_a_p___e_n_v_____header.html">SOAP_ENV__Header</a> struct used by the gSOAP engine and your application. This is convenient when service-specific header blocks are combined with WS-ReliableMessaging and WS-Addressing header blocks or when WS-Security header blocks are added by the WSSE plugin.<h2><a class="anchor" name="wsrm_3">
WS-ReliableMessaging Overview</a></h2>
In this section a brief overview of WS-ReliableMessaging is given. For more details please refer to the WS-ReliableMessaging protocol or tutorials on the subject. The following introduces the basic concepts of WS-ReliableMessaging from a practical point of view.<p>
WS-ReliableMessaging is useful to improve the reliability of one-way asynchronous messaging, for unreliable data gram messaging (SOAP-over-UDP), or to improve reliable delivery of responses relayed to other destinations, such as response messages that are relayed to destinations indicated by the WS-Addressing ReplyTo header. The protocol is also useful when multiple sources are sending messages that arrive in different order or must be flagged as an incomplete message collection when messages are missing as defined by the notion of a collection of related messages.<p>
WS-ReliableMessaging is not essential to improve the reliability of request-response message exchanges between two parties over HTTP, since a successful delivery of a request message can be inferred from the fact that a response was received for the request sent.<p>
WS-ReliableMessaging "protects" message sequences, i.e. a collection of related messages. A WS-ReliableMessaging message sequence is created after which the sequence of messages is sent. The sequence is closed and terminated by the client after the last message. Either the message sequence is complete or not, and the resulting action to discard the incomplete message sequence or not depends on the chosen behavior. Duplicate messages (e.g. resulting from resends) are always discarded.<p>
To create a new sequence, a client (WS-RM source) requests from the server (WS-RM destination) a unique (new) message sequence identification. The server responds with the identification to be used as well as other details, such as the expiration time of the sequence and the behavior implemented when a sequence was received incomplete:<p>
<ul>
<li>NoDiscard means that the sequence of messages is not discarded by the destination server when one or more messages are missing;</li><li>DiscardFollowingFirstGap means that the initial messages of the sequence are retained by the destination up to the first gap (a missing message) in the sequence;</li><li>DiscardEntireSequence means that the entire sequence of messages will be discarded when a single message is missing.</li></ul>
<p>
When the client terminates the sequence, it first sends a sequence close request and then a sequence termination request to the destination server. The sequence close informs the server how many messages should have been received. The client can still resend messages after the close, but no new messages are supposed to be send. After the optional resends, the client requests termination of the sequence. The termination will be successful depending on the behavior when messages went missing, as was listed above.<p>
The ensure reliable delivery, the WS-ReliableMessaging protocol allows the client to resend messages. Message resends are desirable when messages are lost in transit. Since the client has limited information on delivery success (message delivery acknowledgments can get lost as well), the client may resend more messages than necessary. This could lead to message duplication. However, messages that were already received by the server are discarded.<p>
The client may request message delivery acknowledgements from the server. The server sends message receipt acknowledgements for all the messages it has received in the sequence back to the client, usually by piggy-backing them with the response of a subsequent message exchange. When the client is informed about successful delivery it reduces the number of resends the client will attempt.<p>
Messages in a sequence are uniquely identified by their enumeration number in the sequence. Messages may be transmitted out of order. A missing message number indicates a gap in the message sequence. Message receipt acknowledgements consist of ranges of message numbers. Acknowledgements are normally sent to the source to help identify which messages should be resend.<p>
With the WS-Addressing protocol, message responses and fault messages can be relayed to other destinations. The ReplyTo and FaultTo WS-Addressing header blocks are used for this purpose. The WS-ReliableMessaging protocol allows message acknowledgements to be relayed. The WS-ReliableMessaging AcksTo header block is used for this purpose.<p>
In all, there are four types of communicating peers that are visible to the source (the client):<p>
<ul>
<li>The destination service. The WS-ReliableMessaging sequence is essentially controlled by this service. When a message is sent by the source to the destination service (over HTTP, TCP, or UDP), the WS-Addressing To information header may contain the endpoint address. The destination service normally returns message responses back to the client (HTTP request-response).</li><li>One of more ReplyTo destination services that accept response messages from the destination service. Rather than sending responses back to the client, the destination service relays them to another service. The WS-Addressing ReplyTo information header is used by the client to indicate the response relay target.</li><li>One or more FaultTo destination services that accept SOAP fault messages from the destination service. Rather than sending SOAP Faults back to the client, the destination service relays them to another service. The WS-Addressing FaultTo information header is used by the client to indicate the fault relay target.</li><li>One AcksTo destination service that accept WS-ReliableMessaging acknowledgements. Rather than sending acknowledgements piggy-backed with response messages back to the client, the destination service relays them to another service. The WS-ReliableMessaging AcksTo information header is used by the client when the sequence is created to indicate the acknowledgements relay target. The AcksTo cannot be changed after sequence creation to termination.</li></ul>
<p>
Any or all of the above destination services except the first can be the source (client) itself, so message responses, faults, and acknowledgements can be relayed back to the client. To this end, it is important that the client sets the WS-Addressing From information header for each message to match the ReplyTo, FaultTo, and AcksTo address.<p>
The practical aspects of message sequence creation, the message exchanges, the message relays, and sequence close/termination are presented for the client side first and then for each of the four types of destination servers.<h2><a class="anchor" name="wsrm_4">
Client-side Usage</a></h2>
<h3><a class="anchor" name="wsrm_4_1">
Creating, Closing, and Terminating Message Sequences</a></h3>
A sequence is created, closed, terminated, and cleaned-up on the client side as follows:<p>
<div class="fragment"><pre><span class="keyword">struct </span>soap *soap = soap_new(); <span class="comment">// Note: can use C++ proxy instead of 'soap'</span>
soap_register_plugin(soap, soap_wsa);
soap_register_plugin(soap, soap_wsrm);

<span class="keyword">const</span> <span class="keywordtype">char</span> *destination = <span class="stringliteral">"..."</span>; <span class="comment">// WS-RM destination server address</span>
<span class="keyword">const</span> <span class="keywordtype">char</span> *acksto = <span class="stringliteral">"..."</span>;      <span class="comment">// WS-RM AcksTo server, or NULL if none</span>
ULONG64 expires = 10000;         <span class="comment">// 10000 ms to expire (10 seconds)</span>
<span class="keyword">const</span> <span class="keywordtype">char</span> *<span class="keywordtype">id</span> = NULL;           <span class="comment">// id = NULL: generate a temp sequence ID</span>
<span class="keyword">const</span> <span class="keywordtype">char</span> *opt_msg_id = NULL;   <span class="comment">// WS-Addressing message ID, or NULL</span>

<a class="code" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence_handle</a> seq;   <span class="comment">// a local handle to the sequence state</span>

<span class="comment">// Step 1: create a sequence</span>
<span class="keywordflow">if</span> (<a class="code" href="wsrmapi_8h.html#a18">soap_wsrm_create_offer</a>(soap, destination, acksto, <span class="keywordtype">id</span>, expires, NoDiscard, opt_msg_id, &amp;seq))
{ <span class="keywordflow">if</span> (seq)
    <a class="code" href="wsrmapi_8h.html#a26">soap_wsrm_seq_free</a>(soap, seq);
  ... <span class="comment">// error creating sequence</span>
} 

<span class="comment">// Step 2: exchange messages with WS-RM destination, request acks, receive acks, issue resends (see later) </span>
...

<span class="comment">// Step 3: optionally close first before terminating</span>
if (<a class="code" href="wsrmapi_8h.html#a24">soap_wsrm_close</a>(soap, seq, NULL))
{ <a class="code" href="wsrmapi_8h.html#a26">soap_wsrm_seq_free</a>(soap, seq);
  ... <span class="comment">// error closing sequence</span>
} 

<span class="comment">// Step 4: terminate</span>
<span class="keywordflow">if</span> (<a class="code" href="wsrmapi_8h.html#a25">soap_wsrm_terminate</a>(soap, seq, NULL))
{ <a class="code" href="wsrmapi_8h.html#a26">soap_wsrm_seq_free</a>(soap, seq);
  ... <span class="comment">// error terminating sequence</span>
} 

<span class="comment">// Step 5: cleanup</span>
<a class="code" href="wsrmapi_8h.html#a26">soap_wsrm_seq_free</a>(soap, seq);
</pre></div><p>
As usual, the context can release all its temporary and deserialized data with the following pair of calls:<p>
<div class="fragment"><pre>soap_destroy(soap);
soap_end(soap);
</pre></div><p>
This cleanup of memory resources may be performed at any time in the sequence of message exchange or afterwards when desired. The sequence state is maintained independent of these cleanup operations.<p>
The sequence termination may fail when the delivery of a sequence of messages is incomplete or when the lifetime of the sequence expired (see <a class="el" href="wsrmapi_8h.html#a2">SOAP_WSRM_MAX_SEC_TO_EXPIRE</a>). The WS-RM destination determines the failure based on the final sequence state and the sequence behavior. The behavior is set to NoDiscard by default, which means that the sequence is not discared when transmission gaps appeared in the messages and the sequence is incomplete. The desired behavior can be specified with a sequence creation offer as explained in the next section.<h3><a class="anchor" name="wsrm_4_2">
Creating a Sequence with an Offer</a></h3>
To enable a destination server to produce a reliable message response sequence, you need to create a sequence with an offer. Otherwise, response messages are not tracked and delivery not verified. Two-way messaging should use the offer mechanism, but if all messages are one-way then this is not needed. A sequence is created with an offer of sequence lifetime and behavior parameters as follows:<p>
<div class="fragment"><pre>ULONG64 expires = 60000;       <span class="comment">// 1 minute = 60,000 milliseconds</span>
<span class="keyword">const</span> <span class="keywordtype">char</span> *<span class="keywordtype">id</span> = NULL;         <span class="comment">// id = NULL: generate a temp sequence ID</span>
<span class="keyword">const</span> <span class="keywordtype">char</span> *opt_msg_id = NULL; <span class="comment">// WS-Addressing message ID</span>

<span class="keywordflow">if</span> (<a class="code" href="wsrmapi_8h.html#a18">soap_wsrm_create_offer</a>(soap, destination, acksto, <span class="keywordtype">id</span>, expires, DiscardEntireSequence, opt_msg_id, &amp;seq))
{ <span class="keywordflow">if</span> (seq)
    <a class="code" href="wsrmapi_8h.html#a26">soap_wsrm_seq_free</a>(soap, seq);
  ... <span class="comment">// error creating sequence</span>
}
</pre></div><p>
This offers sequence parameters to the WS-RM destination, which may accept the offer and apply the requested lifetime (expiration time in ms) and sequence behavior.<p>
The sequence behavior is either<p>
<ul>
<li>NoDiscard (default) means that the sequence of messages is not discarded by the destination server when one or more messages are missing;</li><li>DiscardFollowingFirstGap means that the initial messages of the sequence are retained by the destination up to the first gap (a missing message) in the sequence;</li><li>DiscardEntireSequence means that the entire sequence of messages will be discarded when a single message is missing.</li></ul>
<h3><a class="anchor" name="wsrm_4_3">
Exchanging Messages in a Sequence</a></h3>
Each message exchange with the WS-RM destination should be preceded with a <a class="el" href="wsrmapi_8h.html#a20">soap_wsrm_request()</a> or <a class="el" href="wsrmapi_8h.html#a21">soap_wsrm_request_acks()</a> call to set the required WS-RM information headers for the message send operation or request-response exchange.<p>
For example, consider the 'example' operation defined previously and suppose we invoke the 'example' operation in a sequence (after creation and before closing):<p>
<div class="fragment"><pre><span class="keyword">const</span> <span class="keywordtype">char</span> *exampleRequestAction = <span class="stringliteral">"urn:example/examplePort/example"</span>;
<span class="keyword">const</span> <span class="keywordtype">char</span> *exampleRequestMessageID = NULL; <span class="comment">// optional WS-Addressing ID</span>

<span class="keyword">struct </span>ns__exampleResponse response;

<span class="keywordflow">if</span> (<a class="code" href="wsrmapi_8h.html#a20">soap_wsrm_request</a>(soap, seq, exampleRequestMessageID, exampleRequestAction))
  ... <span class="comment">// error: out of memory</span>

<span class="keywordflow">if</span> (soap_call_ns__example(soap, <a class="code" href="wsrmapi_8h.html#a28">soap_wsrm_to</a>(seq), exampleRequestAction, &amp;response))
  soap_print_fault(soap, stderr); <span class="comment">// an error occurred</span>
<span class="keywordflow">else</span>
  ... <span class="comment">// process the response</span>
</pre></div><p>
The <a class="el" href="wsrmapi_8h.html#a20">soap_wsrm_request()</a> takes the sequence handle and optional WS-Addressing message ID and mandatory WS-Addressing action string (this string must match the method-action defined in the gSOAP service definition header file). It produces a WS-RM header block with the message number incremented by one for the invocation. Messages are enumerated from one and included in the WS-RM header to allow the destination to determine which messages were received in the sequence (for acknowledgements) and to ignore duplicate messages.<p>
The remote invocation soap_call_ns__example() uses soap_wsrm_to(seq) for the WS-RM destination address, which was set by <a class="el" href="wsrmapi_8h.html#a17">soap_wsrm_create()</a> or <a class="el" href="wsrmapi_8h.html#a18">soap_wsrm_create_offer()</a>. Because the address may change due to a redirect, we encourage the use of <a class="el" href="wsrmapi_8h.html#a28">soap_wsrm_to()</a> for the WS-RM destination address.<p>
A C++ proxy object (generated by soapcpp2 option -i) that invokes a service operation should reset the destination address explicitly by setting the 'soap_endpoint' member string before each operation invocation.<h3><a class="anchor" name="wsrm_4_4">
Exchanging Messages with Acknowledgements in a Sequence</a></h3>
Message acknowledgements are requested as follows:<p>
<div class="fragment"><pre><span class="keywordflow">if</span> (<a class="code" href="wsrmapi_8h.html#a21">soap_wsrm_request_acks</a>(soap, seq, exampleRequestMessageID, exampleRequestAction))
  ... <span class="comment">// error: out of memory</span>
</pre></div><p>
This informs the WS-RM destination to return message delivery acknowledgements back to the sender (piggy-backed in the header of the response message), unless the AcksTo is set to target an acknowledgement service endpoint.<p>
The <a class="el" href="wsrmapi_8h.html#a24">soap_wsrm_close()</a> returns acknowledgements automatically, so requesting intermediate acknowledgements is not required to issue a final <a class="el" href="wsrmapi_8h.html#a23">soap_wsrm_resend()</a> to resend all non-acknowledged messages, e.g. after <a class="el" href="wsrmapi_8h.html#a24">soap_wsrm_close()</a>. See also below.<h3><a class="anchor" name="wsrm_4_5">
Resending Non-Acknowledged Messages</a></h3>
All non-acknowledged messages in a sequence that were previously sent can be resend (from the internal sender-side cache of sent messages in a sequence) as follows:<p>
<div class="fragment"><pre><a class="code" href="wsrmapi_8h.html#a23">soap_wsrm_resend</a>(soap, seq, 0, 0);
</pre></div><p>
To resend a range of non-acknowledged messages, say between 3 and 7, use:<p>
<div class="fragment"><pre><a class="code" href="wsrmapi_8h.html#a23">soap_wsrm_resend</a>(soap, seq, 3, 7);
</pre></div><p>
Or all messages after message number 3:<p>
<div class="fragment"><pre><a class="code" href="wsrmapi_8h.html#a23">soap_wsrm_resend</a>(soap, seq, 3, 0);
</pre></div><p>
Resends should be used with care, since in the worst case when no acknowledgements have been received all messages up to the last will be resend (and ignored by the WS-RM destination when a message is received more than once).<p>
Note that when an AcksTo destination service address was set with <a class="el" href="wsrmapi_8h.html#a17">soap_wsrm_create()</a> or <a class="el" href="wsrmapi_8h.html#a18">soap_wsrm_create_offer()</a>, then the acknowledgements will not be returned to the sender (client). In this case message resends are performed for all messages sent, since these have not been acknowledged.<p>
It is permitted to issue resends between creation and termination of a sequence, including after a sequence close (as long as no new messages are sent after close). The sequence close provides acknowledgement information to limit the number of messages that need to be resend.<p>
To find out if none, some, or all messages have been acknowledged, use:<p>
<div class="fragment"><pre>ULONG64 nack = <a class="code" href="wsrmapi_8h.html#a31">soap_wsrm_nack</a>(seq);
<span class="keywordflow">if</span> (nack == 0)
  ... <span class="comment">// all sent messages have been acknowledged</span>
<span class="keywordflow">else</span> <span class="keywordflow">if</span> (nack == <a class="code" href="wsrmapi_8h.html#a30">soap_wsrm_num</a>(seq))
  ... <span class="comment">// none of the sent messages have been acknowledged</span>
<span class="keywordflow">else</span>
  ... <span class="comment">// some sent messages have been acknowledged</span>
</pre></div><h3><a class="anchor" name="wsrm_4_6">
Relaying Response and Fault Messages with WS-Addressing</a></h3>
WS-ReliableMessaging is important when messages are relayed, and especially when relayed over UDP.<p>
The ReplyTo and FaultTo destination service endpoints can be specified for each message as follows:<p>
<div class="fragment"><pre><span class="keyword">const</span> <span class="keywordtype">char</span> *replyto = <span class="stringliteral">"..."</span>; <span class="comment">// endpoint of response processing service</span>
<span class="keyword">const</span> <span class="keywordtype">char</span> *faultto = <span class="stringliteral">"..."</span>; <span class="comment">// endpoint of fault processing service</span>

<span class="keywordflow">if</span> (<a class="code" href="wsrmapi_8h.html#a21">soap_wsrm_request_acks</a>(soap, seq, NULL, exampleRequestAction)
 || <a class="code" href="wsaapi_8h.html#a12">soap_wsa_add_ReplyTo</a>(soap, replyto)
 || <a class="code" href="wsaapi_8h.html#a13">soap_wsa_add_FaultTo</a>(soap, faultto))
  ... <span class="comment">// error: out of memory</span>
<span class="keywordflow">if</span> (soap_call_ns__example(soap, <a class="code" href="wsrmapi_8h.html#a28">soap_wsrm_to</a>(seq), exampleRequestAction, &amp;response))
{ <span class="keywordflow">if</span> (soap-&gt;error == 202)
    ... <span class="comment">// request was accepted by destination (HTTP 202 Accept)</span>
  <span class="keywordflow">else</span>
    ... <span class="comment">// other error, see below on how to detect acks</span>
}
</pre></div><p>
To sent acknowledgements back to the client, set AcksTo to NULL:<p>
<div class="fragment"><pre>ULONG64 expires = 60000;         <span class="comment">// 1 minute = 60,000 milliseconds</span>
<span class="keyword">const</span> <span class="keywordtype">char</span> *<span class="keywordtype">id</span> = NULL;           <span class="comment">// id = NULL: generate a temp sequence ID</span>
<span class="keyword">const</span> <span class="keywordtype">char</span> *opt_msg_id = NULL;   <span class="comment">// WS-Addressing message ID</span>
<span class="keyword">const</span> <span class="keywordtype">char</span> *destination = <span class="stringliteral">"..."</span>; <span class="comment">// WS-RM destination server address</span>
<span class="keyword">const</span> <span class="keywordtype">char</span> *acksto = NULL;       <span class="comment">// sent acks to client</span>

<a class="code" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence_handle</a> seq;   <span class="comment">// a local handle to the sequence state</span>

<span class="keywordflow">if</span> (<a class="code" href="wsrmapi_8h.html#a18">soap_wsrm_create_offer</a>(soap, destination, acksto, <span class="keywordtype">id</span>, expires, NoDiscard, opt_msg_id, &amp;seq))
{ <span class="keywordflow">if</span> (seq)
    <a class="code" href="wsrmapi_8h.html#a26">soap_wsrm_seq_free</a>(soap, seq);
  ... <span class="comment">// error creating sequence</span>
} 

<span class="keywordflow">if</span> (<a class="code" href="wsrmapi_8h.html#a21">soap_wsrm_request_acks</a>(soap, seq, NULL, exampleRequestAction))
  ... <span class="comment">// error: out of memory</span>
<span class="keywordflow">if</span> (soap_call_ns__example(soap, <a class="code" href="wsrmapi_8h.html#a28">soap_wsrm_to</a>(seq), exampleRequestAction, &amp;response))
{ <span class="keywordflow">if</span> (soap-&gt;error == 202)
    ... <span class="comment">// request was accepted by destination (HTTP 202 Accept)</span>
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (soap-&gt;error == SOAP_NO_TAG) <span class="comment">// empty &lt;Body&gt;</span>
    ... <span class="comment">// request was accepted by destination, acks are returned in empty Body</span>
  <span class="keywordflow">else</span>
    ... <span class="comment">// other error</span>
}
</pre></div><p>
Otherwise, setting the AcksTo will relay acknowledgements to the address specified.<p>
An optional source address information header can be added with <a class="el" href="wsaapi_8h.html#a10">soap_wsa_add_From()</a>:<p>
<div class="fragment"><pre><span class="keyword">const</span> <span class="keywordtype">char</span> *from = <span class="stringliteral">"..."</span>; <span class="comment">// endpoint of the client (could be any URI)</span>

<span class="keywordflow">if</span> (<a class="code" href="wsrmapi_8h.html#a21">soap_wsrm_request_acks</a>(soap, seq, NULL, exampleRequestAction)
 || <a class="code" href="wsaapi_8h.html#a10">soap_wsa_add_From</a>(soap, from))
  ... <span class="comment">// error: out of memory</span>
</pre></div><p>
Adding a From address is optional and usually not required with WS-ReliableMessaging.<h3><a class="anchor" name="wsrm_4_7">
Using Retry Loops to Improve Robustness of Message Sends</a></h3>
A potential problem with reliable message delivery with resends can fail when the initial send was not successful, for example due to a connection failure. The wsrm plugin records all sent messages when the send operation was not interrupted. A problem occurs when the message cache contains incomplete messages and these messages cannot be resend. This section presents an additional mechanism to ensure messages are cached properly for automatic retransmission.<p>
Besides network failues, a request-response message exchange can also appear to fail due to a non SOAP_OK returned, such as a benign HTTP 202 Accept To distinguish fatal send errors from errors returned by the peer, the soap_wsrm_retry() function can be used as follows to only retry the message exchange (or send) when needed:<p>
<div class="fragment"><pre><span class="keywordflow">if</span> (<a class="code" href="wsrmapi_8h.html#a21">soap_wsrm_request_acks</a>(soap, seq, NULL, exampleRequestAction))
  ... <span class="comment">// error: out of memory</span>
<span class="keywordflow">while</span> (soap_call_ns__example(soap, <a class="code" href="wsrmapi_8h.html#a28">soap_wsrm_to</a>(seq), exampleRequestAction, &amp;response))
{ <span class="keywordflow">if</span> (soap-&gt;error == 202)
  { <span class="comment">// request was accepted by destination (HTTP 202 Accept)</span>
    <span class="keywordflow">break</span>;
  }
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (soap-&gt;error == SOAP_NO_TAG) <span class="comment">// empty &lt;Body&gt;</span>
  { <span class="comment">// request was accepted by destination, acks are returned</span>
    <span class="keywordflow">break</span>;
  }
  soap_print_fault(soap, stderr);
  <span class="keywordflow">if</span> (<a class="code" href="wsrmapi_8h.html#a22">soap_wsrm_check_retry</a>(soap, seq))
    <span class="keywordflow">break</span>; <span class="comment">// do not continue</span>
  sleep(1); <span class="comment">// wait a second to give network a chance to recover</span>
}

<span class="keywordflow">if</span> (soap-&gt;error == SOAP_OK)
  ... <span class="comment">// response can be processed</span>
</pre></div><p>
Note that the <a class="el" href="wsrmapi_8h.html#a20">soap_wsrm_request()</a> is only invoked once in the above to increment the message enumeration.<p>
The loop retries transmissions a maximum of <a class="el" href="wsrmapi_8h.html#a1">SOAP_WSRM_MAX_RETRIES</a> iterations before giving up.<h3><a class="anchor" name="wsrm_4_8">
Example Client</a></h3>
The following code shows an example WS-RM client fragment that combines the concepts introduced in the previous sections:<p>
<div class="fragment"><pre><span class="keyword">struct </span>soap *soap = soap_new(); <span class="comment">// Note: can use C++ proxy instead of 'soap'</span>
soap_register_plugin(soap, soap_wsa);
soap_register_plugin(soap, soap_wsrm);

<span class="keyword">struct </span>ns__exampleResponse response;
<span class="keyword">const</span> <span class="keywordtype">char</span> *exampleRequestAction = <span class="stringliteral">"urn:example/examplePort/example"</span>;

<span class="keyword">const</span> <span class="keywordtype">char</span> *destination = <span class="stringliteral">"..."</span>; <span class="comment">// WS-RM destination server address</span>
<span class="keyword">const</span> <span class="keywordtype">char</span> *acksto = <span class="stringliteral">"..."</span>;      <span class="comment">// WS-RM AcksTo server, or NULL if none</span>
<span class="keyword">const</span> <span class="keywordtype">char</span> *replyto = <span class="stringliteral">"..."</span>;     <span class="comment">// WS-A ReplyTo server to relay response</span>
<span class="keyword">const</span> <span class="keywordtype">char</span> *faultto = <span class="stringliteral">"..."</span>;     <span class="comment">// WS-A FaultTo server to relay fauls</span>
ULONG64 expires = 60000;         <span class="comment">// 1 minute sequence lifetime</span>

<a class="code" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence_handle</a> seq;

<span class="keywordflow">if</span> (<a class="code" href="wsrmapi_8h.html#a18">soap_wsrm_create_offer</a>(soap, destination, acksto, NULL, expires, DiscardEntireSequence, NULL, &amp;seq))
{ <span class="keywordflow">if</span> (seq)
    <a class="code" href="wsrmapi_8h.html#a26">soap_wsrm_seq_free</a>(soap, seq);
  ... <span class="comment">// error creating sequence</span>
} 

<span class="keywordflow">if</span> (<a class="code" href="wsrmapi_8h.html#a21">soap_wsrm_request_acks</a>(soap, seq, NULL, exampleRequestAction)
 || <a class="code" href="wsaapi_8h.html#a12">soap_wsa_add_ReplyTo</a>(soap, replyto)
 || <a class="code" href="wsaapi_8h.html#a13">soap_wsa_add_FaultTo</a>(soap, faultto))
  ... <span class="comment">// error: out of memory</span>

<span class="keywordflow">while</span> (soap_call_ns__example(soap, <a class="code" href="wsrmapi_8h.html#a28">soap_wsrm_to</a>(seq), exampleRequestAction, &amp;response))
{ <span class="keywordflow">if</span> (soap-&gt;error == 202)
  { <span class="comment">// request was accepted by destination (HTTP 202 Accept)</span>
    <span class="keywordflow">break</span>;
  }
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (soap-&gt;error == SOAP_NO_TAG) <span class="comment">// empty &lt;Body&gt;</span>
  { <span class="comment">// request was accepted by destination, acks are returned</span>
    <span class="keywordflow">break</span>;
  }
  soap_print_fault(soap, stderr);
  <span class="keywordflow">if</span> (<a class="code" href="wsrmapi_8h.html#a22">soap_wsrm_check_retry</a>(soap, seq))
    <span class="keywordflow">break</span>; <span class="comment">// do not continue</span>
  sleep(1); <span class="comment">// wait a second to give network a chance to recover</span>
}

<span class="keywordflow">if</span> (soap-&gt;error == SOAP_OK)
  ... <span class="comment">// response can be processed</span>

<span class="keywordflow">if</span> (<a class="code" href="wsrmapi_8h.html#a24">soap_wsrm_close</a>(soap, seq, NULL))
{ <a class="code" href="wsrmapi_8h.html#a26">soap_wsrm_seq_free</a>(soap, seq);
  ... <span class="comment">// error closing sequence</span>
} 

<a class="code" href="wsrmapi_8h.html#a23">soap_wsrm_resend</a>(soap, seq, 0, 0); <span class="comment">// resend non-acked messages</span>

<span class="keywordflow">if</span> (<a class="code" href="wsrmapi_8h.html#a25">soap_wsrm_terminate</a>(soap, seq, NULL))
{ <a class="code" href="wsrmapi_8h.html#a26">soap_wsrm_seq_free</a>(soap, seq);
  ... <span class="comment">// error terminating sequence</span>
} 

<a class="code" href="wsrmapi_8h.html#a26">soap_wsrm_seq_free</a>(soap, seq);

soap_destroy(soap);
soap_end(soap);
soap_free(soap);
</pre></div><p>
Responses can be discarded by the WS-RM destination service as requested with the <a class="el" href="wsaapi_8h.html#a11">soap_wsa_add_NoReply()</a> call, which adds a ReplyTo 'noreply' WS-Addressing header block URI.<h2><a class="anchor" name="wsrm_5">
Server-side Usage</a></h2>
To set up a WS-ReliableMessaging compliant server, register the wsa and wsrm plugins with the soap context (or with the C++ proxy object generated by soapcpp2 option -i):<p>
<div class="fragment"><pre><span class="keyword">struct </span>soap *soap = soap_new(); <span class="comment">// Note: can use C++ proxy instead of 'soap'</span>
soap_register_plugin(soap, soap_wsa);
soap_register_plugin(soap, soap_wsrm);
</pre></div><p>
The following subsections detail the differences between the types of WS-RM destination services.<h3><a class="anchor" name="wsrm_5_1">
Setting up a WS-RM Destination Service</a></h3>
Each service operation that supports WS-ReliableMessaging and WS-Addressing should use the <a class="el" href="wsrmapi_8h.html#a32">soap_wsrm_check()</a>, <a class="el" href="wsrmapi_8h.html#a39">soap_wsrm_sender_fault()</a>, <a class="el" href="wsrmapi_8h.html#a40">soap_wsrm_receiver_fault()</a>, and <a class="el" href="wsrmapi_8h.html#a34">soap_wsrm_reply()</a> functions as follows:<p>
<div class="fragment"><pre><span class="keywordtype">int</span> ns__example(<span class="keyword">struct</span> soap *soap, <span class="keywordtype">char</span> *in, <span class="keyword">struct</span> ns__exampleResponse *response)
{ <span class="keyword">const</span> <span class="keywordtype">char</span> *ResponseAction = <span class="stringliteral">"urn:example/examplePort/exampleResponse"</span>;

  <span class="comment">// fatal service operation-specific errors (before soap_wsrm_check)</span>
  <span class="keywordflow">if</span> (!database) <span class="comment">// suppose we need a database, if there is none terminate</span>
    <span class="keywordflow">return</span> <a class="code" href="wsrmapi_8h.html#a40">soap_wsrm_receiver_fault</a>(soap, <span class="stringliteral">"No database!"</span>, NULL);

  <span class="comment">// check for WS-RM/WSA and set WS-RM/WSA return headers</span>
  <span class="keywordflow">if</span> (<a class="code" href="wsrmapi_8h.html#a32">soap_wsrm_check</a>(soap))
    <span class="keywordflow">return</span> soap-&gt;error;

  <span class="comment">// check for non-fatal service operation-specific errors</span>
  <span class="keywordflow">if</span> (!in || !*in) <span class="comment">// sender did not put anything in the 'in' string: fault</span>
    <span class="keywordflow">return</span> <a class="code" href="wsrmapi_8h.html#a39">soap_wsrm_sender_fault</a>(soap, <span class="stringliteral">"No string content!"</span>, NULL);

  response-&gt;out = ...

  <span class="comment">// return normally, relaying the response to the ReplyTo service when needed</span>
  <span class="keywordflow">return</span> <a class="code" href="wsrmapi_8h.html#a34">soap_wsrm_reply</a>(soap, NULL, ResponseAction);
}
</pre></div><p>
An error produced by <a class="el" href="wsrmapi_8h.html#a39">soap_wsrm_sender_fault()</a> or soap_wsrm_receiever_fault() before <a class="el" href="wsrmapi_8h.html#a32">soap_wsrm_check()</a> is considered fatal, it will terminate the sequence and the sender (client) will not be able to continue the sequence transmissions. While the faults preduced after <a class="el" href="wsrmapi_8h.html#a32">soap_wsrm_check()</a> allow the sequence to continue.<h3><a class="anchor" name="wsrm_5_2">
Setting up a ReplyTo Service Endpoint</a></h3>
A response-processing destination service may or may not support WS-RM. This allows response messages to be relayed to simple services.<p>
To set up a response-processing destination (accepting ReplyTo-relayed response messages), set up the server in the same way as the destination server. Service opertions should not use <a class="el" href="wsrmapi_8h.html#a32">soap_wsrm_check()</a> and <a class="el" href="wsrmapi_8h.html#a34">soap_wsrm_reply()</a>. Because response messages are sent (as if these were request messages), the service must define the appropriate one-way operations and gSOAP service definitions bindings.<p>
For example, the one-way response message of the ns__example operation is defined as follows in the gSOAP service definitions header file:<p>
<div class="fragment"><pre><span class="comment">//gsoap ns service method-header-part: exampleResponse wsa5__MessageID</span>
<span class="comment">//gsoap ns service method-header-part: exampleResponse wsa5__RelatesTo</span>
<span class="comment">//gsoap ns service method-header-part: exampleResponse wsa5__From</span>
<span class="comment">//gsoap ns service method-header-part: exampleResponse wsa5__ReplyTo</span>
<span class="comment">//gsoap ns service method-header-part: exampleResponse wsa5__FaultTo</span>
<span class="comment">//gsoap ns service method-header-part: exampleResponse wsa5__To</span>
<span class="comment">//gsoap ns service method-header-part: exampleResponse wsa5__Action</span>

<span class="comment">//gsoap ns service method-header-part: exampleResponse wsrm__SequenceAcknowledgement</span>

<span class="comment">//gsoap ns service method-action: exampleResponse urn:example/examplePort/exampleResponse</span>

<span class="keywordtype">int</span> ns__exampleResponse(<span class="keywordtype">char</span> *out, <span class="keywordtype">void</span>);
</pre></div><p>
Note that when these definitions are combined with the previous definition for ns__example, there is no need to define the ns__ExampleResponse struct any longer as this is implied by the ns__exampleResponse function content.<p>
The server operation implementation is for example:<p>
<div class="fragment"><pre><span class="keywordtype">int</span> ns__exampleResponse(<span class="keyword">struct</span> soap *soap, <span class="keywordtype">char</span> *out)
{
  ... <span class="comment">// process</span>
  <span class="keywordflow">return</span> SOAP_OK;
}
</pre></div><p>
Note that message acknowledgements can be piggy-backed with these response messages from the destination service when AcksTo is not set (at the destintation service). These acknowledgements are processed automatically to update the local sequence states when the wsrm plugin is registered.<h3><a class="anchor" name="wsrm_5_3">
Setting up a FaultTo Service Endpoint</a></h3>
The SOAP Fault is accepted as a message by a service when defined as follows in the gSOAP service definition header file:<p>
<div class="fragment"><pre><span class="comment">//gsoap SOAP_ENV service method-action: Fault http://schemas.xmlsoap.org/ws/2004/08/addressing/fault</span>
<span class="keywordtype">int</span> SOAP_ENV__Fault
(       _QName                   faultcode,             <span class="comment">// SOAP 1.1</span>
        <span class="keywordtype">char</span>                    *faultstring,           <span class="comment">// SOAP 1.1</span>
        <span class="keywordtype">char</span>                    *faultactor,            <span class="comment">// SOAP 1.1</span>
        <span class="keyword">struct </span>SOAP_ENV__Detail *detail,                <span class="comment">// SOAP 1.1</span>
        <span class="keyword">struct </span>SOAP_ENV__Code   *SOAP_ENV__Code,        <span class="comment">// SOAP 1.2</span>
        <span class="keyword">struct </span>SOAP_ENV__Reason *SOAP_ENV__Reason,      <span class="comment">// SOAP 1.2</span>
        <span class="keywordtype">char</span>                    *SOAP_ENV__Node,        <span class="comment">// SOAP 1.2</span>
        <span class="keywordtype">char</span>                    *SOAP_ENV__Role,        <span class="comment">// SOAP 1.2</span>
        <span class="keyword">struct </span>SOAP_ENV__Detail *SOAP_ENV__Detail,      <span class="comment">// SOAP 1.2</span>
        <span class="keywordtype">void</span>
);
</pre></div><p>
Given the above service definitions, the soapcpp2 tool generates a SOAP_ENV__Fault service dispatcher that will invoke the SOAP_ENV__Fault() function that should be implemented at the server side:<p>
<div class="fragment"><pre><span class="keywordtype">int</span> SOAP_ENV__Fault(
  <span class="keyword">struct</span> soap *soap,
  <span class="keywordtype">char</span> *faultcode,
  <span class="keywordtype">char</span> *faultstring,
  <span class="keywordtype">char</span> *faultactor,
  <span class="keyword">struct</span> SOAP_ENV__Detail *detail,
  <span class="keyword">struct</span> SOAP_ENV__Code *SOAP_ENV__Code,
  <span class="keyword">struct</span> SOAP_ENV__Reason *SOAP_ENV__Reason,
  <span class="keywordtype">char</span> *SOAP_ENV__Node,
  <span class="keywordtype">char</span> *SOAP_ENV__Role,
  <span class="keyword">struct</span> SOAP_ENV__Detail *SOAP_ENV__Detail
  )
{ 
  <span class="comment">// SOAP 1.1</span>
  ... = faultcode;
  ... = faultstring;
  ... = faultactor;
  ... = detail;
  <span class="comment">// SOAP 1.2</span>
  ... = SOAP_ENV__Code;
  ... = SOAP_ENV__Reason;
  ... = SOAP_ENV__Node;
  ... = SOAP_ENV__Role;
  ... = SOAP_ENV__Detail;
  <span class="keywordflow">return</span> soap_send_empty_response(soap, SOAP_OK); <span class="comment">// HTTP 202 Accepted</span>
}
</pre></div><p>
Because the FaultTo service only uses WS-Addressing, there is no need to register or use the wsrm plugin.<h3><a class="anchor" name="wsrm_5_4">
Setting up an AcksTo Service Endpoint</a></h3>
To set up an AcksTo acknowledgement-processing destination, the service definition header file should at least import <a class="el" href="wsrm_8h.html">wsrm.h</a>:<p>
<div class="fragment"><pre><span class="preprocessor">#import "<a class="code" href="wsrm_8h.html">wsrm.h</a>"</span>
</pre></div><p>
This is sufficient, since the wsrm plugin implements an acknowledgement processing capability with the built-in <a class="el" href="wsrx_8h.html#a3">__wsrm__SequenceAcknowledgement()</a> server operation, that updates the local sequence state when acknowledgements are received.<p>
How to use the sequence state of the AcksTo server and use the state updates is up to the application developer.<h2><a class="anchor" name="wsrm_6">
WS-ReliableMessaging over HTTPS with Basic Authentication</a></h2>
The HTTPS client and server are set up as shown in the gSOAP documentation and examples. There are no additional API calls needed to support WS-RM with HTTPS.<p>
Note that the WS-RM destination service may also relay messages to other HTTPS services, thus the WS-RM destination acts as a receiver (server) and sender (client). Therefore, the WS-RM destination server's SSL context should be set to authenticate the other servers:<p>
<div class="fragment"><pre><span class="keywordflow">if</span> (soap_ssl_server_context(soap,
  SOAP_SSL_DEFAULT,
  <span class="stringliteral">"server.pem"</span>, <span class="comment">// keyfile (server)</span>
  <span class="stringliteral">"password"</span>,   <span class="comment">// password to read the key file (server)</span>
  <span class="stringliteral">"cacert.pem"</span>, <span class="comment">// cacert file to store trusted certificates (client)</span>
  NULL,         <span class="comment">// optional capath</span>
  NULL,         <span class="comment">// DH file name or DH param key len bits, NULL: RSA</span>
  NULL,         <span class="comment">// file with random data to seed randomness</span>
  argv[1]       <span class="comment">// unique server identification for SSL session cache</span>
))
{ soap_print_fault(soap, stderr);
  ... <span class="comment">// handle error</span>
}
</pre></div><p>
Here, the cacert.pem file contains certificates to authenticate the ReplyTo, FaultTo, and AcksTo services when HTTPS is used.<p>
The client side sets up the SSL context with the soap_ssl_client_context() as instructed in the documentation and by the examples. Multi-threaded HTTPS clients and servers must register mutex locks with OpenSSL<p>
To use Basic Authentication at the client side, set the userid and passwd values:<p>
<div class="fragment"><pre>soap-&gt;userid = <span class="stringliteral">"..."</span>; <span class="comment">// Basic Auth user id</span>
soap-&gt;passwd = <span class="stringliteral">"..."</span>; <span class="comment">// Basic Auth password</span>
<span class="keywordflow">if</span> (<a class="code" href="wsrmapi_8h.html#a21">soap_wsrm_request_acks</a>(soap, seq, NULL, exampleRequestAction)
  ... <span class="comment">// error: out of memory</span>
<span class="keywordflow">if</span> (soap_call_ns__example(soap, <a class="code" href="wsrmapi_8h.html#a28">soap_wsrm_to</a>(seq), exampleRequestAction, &amp;response))
{ <span class="keywordflow">if</span> (soap-&gt;error == 401)
    ... <span class="comment">// authentication failed for the userid/passwd pair</span>
  <span class="keywordflow">else</span>
    ... <span class="comment">// other error</span>
}
</pre></div><p>
At the server side add the authentication check to the service operation before <a class="el" href="wsrmapi_8h.html#a32">soap_wsrm_check()</a> to terminate the sequence when an authentication failure occurs. For example:<p>
<div class="fragment"><pre><span class="keywordtype">int</span> ns__example(<span class="keyword">struct</span> soap *soap, <span class="keywordtype">char</span> *in, <span class="keyword">struct</span> ns__exampleResponse *response)
{ <span class="keywordflow">if</span> (!soap-&gt;userid || !soap-&gt;passwd || strcmp(soap-&gt;userid, <span class="stringliteral">"..."</span>) || strcmp(soap-&gt;passwd, <span class="stringliteral">"..."</span>))
  { soap-&gt;authrealm = <span class="stringliteral">"..."</span>; <span class="comment">// optional to set HTTP WWW-Authenticate: Basic realm="..."</span>
    <span class="keywordflow">return</span> 401; <span class="comment">// HTTP 401 Unauthorized</span>
  }
  <span class="keywordflow">if</span> (<a class="code" href="wsrmapi_8h.html#a32">soap_wsrm_check</a>(soap))
    <span class="keywordflow">return</span> soap-&gt;error;
</pre></div><p>
Here, we check only one userid-passwd pair though normally we could search for valid credentials in an authentication store.<p>
Note: never use Basic Authentication over HTTP because the password is sent in the clear. You must use HTTPS to encrypt the HTTP authentication information and message content. HTTP Digest Auth is preferred for this reason, because Digest Auth verifies the digest of a userid-passwd rather than require the password to be exchanged or stored in cleartext.<h2><a class="anchor" name="wsrm_7">
WS-ReliableMessaging over UDP with Timeouts</a></h2>
The use of UDP is automatic at the client side using the "soap.udp://" protocol. Therefore, endpoints should use a "soap.udp://" URL to connect. (when using an already opened socket, the SOAP_IO_UDP flag must be used, see the documentation.)<p>
Note that UDP datagram messages should not exceed 8K, which is usually a size that UDP datagrams can support. To reduce the message size, we recommend compression (-DWITH_GZIP compile flag to enable ZLIB and use libgsoapssl.a/libgsoapssl++.a for OpenSSL and ZLIB compression combined).<p>
The code of an UDP-enabled server is identical to an HTTP/TCP server except that the soap_accept() call is disabled and unnecessary.<p>
When message responses are not returned to the client, the client may block indefinitely when it expects a response. Therefore we recommend the use of send and receive timeouts:<p>
<div class="fragment"><pre><span class="keyword">struct </span>soap *soap = soap_new();

<span class="keyword">const</span> <span class="keywordtype">char</span> *destination = <span class="stringliteral">"soap.udp://..."</span>;
<span class="keyword">const</span> <span class="keywordtype">char</span> *acksto = NULL;

soap-&gt;send_timeout = soap-&gt;recv_timeout = 1; <span class="comment">// 1 second to timeout</span>

<span class="keywordflow">if</span> (<a class="code" href="wsrmapi_8h.html#a18">soap_wsrm_create_offer</a>(soap, destination, acksto, NULL, expires, NoDiscard, NULL, &amp;seq))
 ... <span class="comment">// an error occured</span>

<span class="keywordflow">if</span> (<a class="code" href="wsrmapi_8h.html#a20">soap_wsrm_request</a>(soap, seq, NULL, exampleRequestAction))
  ... <span class="comment">// an error occured</span>
<span class="keywordflow">if</span> (soap_call_ns__example(soap, ...))
{ <span class="keywordflow">if</span> (soap-&gt;error == SOAP_EOF &amp;&amp; soap-&gt;errnum == 0)
    ... <span class="comment">// a timeout occured</span>
  <span class="keywordflow">else</span>
    ... <span class="comment">// an error occured</span>
}
</pre></div><p>
Note that the WS-Addressing ReplyTo and the use of NoReply do not return response message from the server. However, acknowledgements will be returned when acknowledgements were requested (unless acknowledgements are relayed with AcksTo).<p>
<div class="fragment"><pre><span class="keyword">struct </span>soap *soap = soap_new();

soap-&gt;send_timeout = soap-&gt;recv_timeout = 1; <span class="comment">// 1 second to timeout</span>

<span class="keyword">const</span> <span class="keywordtype">char</span> *destination = <span class="stringliteral">"soap.udp://..."</span>;
<span class="keyword">const</span> <span class="keywordtype">char</span> *from = <span class="stringliteral">"..."</span>; <span class="comment">// some identifying URI</span>
<span class="keyword">const</span> <span class="keywordtype">char</span> *acksto = from;

soap-&gt;send_timeout = soap-&gt;recv_timeout = 1; <span class="comment">// 1 second to timeout</span>

<span class="keywordflow">if</span> (<a class="code" href="wsrmapi_8h.html#a18">soap_wsrm_create_offer</a>(soap, destination, acksto, NULL, expires, NoDiscard, NULL, &amp;seq))
 ... <span class="comment">// an error occured</span>

<span class="keywordflow">if</span> (<a class="code" href="wsrmapi_8h.html#a21">soap_wsrm_request_acks</a>(soap, seq, NULL, exampleRequestAction)
 || <a class="code" href="wsaapi_8h.html#a11">soap_wsa_add_NoReply</a>(soap)
  ... <span class="comment">// an error occured</span>
<span class="keywordflow">if</span> (soap_call_ns__example(soap, ...))
{ <span class="keywordflow">if</span> (soap-&gt;error == SOAP_EOF &amp;&amp; soap-&gt;errnum == 0)
    ... <span class="comment">// a timeout occured</span>
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (soap-&gt;error == SOAP_NO_TAG)
    ... <span class="comment">// ack was received and recorded</span>
  <span class="keywordflow">else</span>
    ... <span class="comment">// an error occured</span>
}
</pre></div><p>
In this case an acknowledgement will be returned and the timeout reflects a possible network packet loss.<h2><a class="anchor" name="wsrm_8">
WS-ReliableMessaging and WS-Security</a></h2>
WS-Security can be combined with WS-ReliableMessaging using the <a href="../../wsse/html/index.html">WSSE plugin</a>.<p>
Both plugins must be registered at the client and server side. These APIs are independent.<h2><a class="anchor" name="wsrm_9">
The wsrm Plugin and Generated C++ Server Objects</a></h2>
Plugins are developed in C to support C and C++. There is no disadvantage to the use of C for this purpose. The only exception is the server-side use of the wsrm plugin with a server object generated by soapcpp2 option -i. With this option the following methods must be implemented as wrappers for the wsrm plugin service operations:<p>
<div class="fragment"><pre><span class="keywordtype">int</span> wsrmService::CreateSequence(
  <span class="keyword">struct</span> <a class="code" href="structwsrm_____create_sequence_type.html">wsrm__CreateSequenceType</a> *wsrm__CreateSequence,
  <span class="keyword">struct</span> <a class="code" href="structwsrm_____create_sequence_response_type.html">wsrm__CreateSequenceResponseType</a> *wsrm__CreateSequenceResponse)
{ <span class="keywordflow">return</span> <a class="code" href="wsrx_8h.html#a0">__wsrm__CreateSequence</a>(<span class="keyword">this</span>, wsrm__CreateSequence, wsrm__CreateSequenceResponse);
}
<span class="keywordtype">int</span> wsrmService::CloseSequence(
  <span class="keyword">struct</span> <a class="code" href="structwsrm_____close_sequence_type.html">wsrm__CloseSequenceType</a> *wsrm__CloseSequence,
  <span class="keyword">struct</span> <a class="code" href="structwsrm_____close_sequence_response_type.html">wsrm__CloseSequenceResponseType</a> *wsrm__CloseSequenceResponse)
{ <span class="keywordflow">return</span> <a class="code" href="wsrx_8h.html#a1">__wsrm__CloseSequence</a>(<span class="keyword">this</span>, wsrm__CloseSequence, wsrm__CloseSequenceResponse);
}
<span class="keywordtype">int</span> wsrmService::TerminateSequence(
  <span class="keyword">struct</span> <a class="code" href="structwsrm_____terminate_sequence_type.html">wsrm__TerminateSequenceType</a> *wsrm__TerminateSequence,
  <span class="keyword">struct</span> <a class="code" href="structwsrm_____terminate_sequence_response_type.html">wsrm__TerminateSequenceResponseType</a> *wsrm__TerminateSequenceResponse)
{ <span class="keywordflow">return</span> <a class="code" href="wsrx_8h.html#a2">__wsrm__TerminateSequence</a>(<span class="keyword">this</span>, wsrm__TerminateSequence, wsrm__TerminateSequenceResponse);
}
<span class="keywordtype">int</span> wsrmService::SequenceAcknowledgement()
{ <span class="keywordflow">return</span> <a class="code" href="wsrx_8h.html#a3">__wsrm__SequenceAcknowledgement</a>(<span class="keyword">this</span>);
}
</pre></div><p>
In addition, we need to dispatch the wsrm service operations when received. Suppose we have a myService server class generated by soapcpp2 -i, which is used to process requests with the serve() member function (also generated):<p>
<div class="fragment"><pre>myService service;
<span class="keywordflow">if</span> (soap_invalid_socket(service.bind(NULL, port, 100)))
  ... <span class="comment">// error</span>
<span class="keywordflow">if</span> (soap_invalid_socket(service.accept()))
  ... <span class="comment">// error</span>
<span class="keywordflow">if</span> (service.serve() == SOAP_NO_METHOD) <span class="comment">// no matching operation</span>
{ wsrmService wsrm(service);           <span class="comment">// wsrm server</span>
  soap_copy_stream(&amp;wsrm, &amp;service);   <span class="comment">// copy open connection</span>
  wsrm.dispatch();                     <span class="comment">// process WS-RM request</span>
}
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Sun May 9 10:52:07 2010 for gSOAP WS-ReliableMessaging by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.8 </small></address>
</body>
</html>
