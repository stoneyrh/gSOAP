<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>gSOAP WS-ReliableMessaging: /Users/engelen/Projects/gsoap/plugin/wsrmapi.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">gSOAP WS-ReliableMessaging&#160;<span id="projectnumber">2.8 Stable</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">/Users/engelen/Projects/gsoap/plugin/wsrmapi.c File Reference</div>  </div>
</div>
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="wsrmapi_8h.html">wsrmapi.h</a>&quot;</code><br/>
</div><div class="textblock"><div class="dynheader">
Include dependency graph for wsrmapi.c:</div>
<div class="dyncontent">
<div class="center"><img src="wsrmapi_8c__incl.png" border="0" usemap="#_2_users_2engelen_2_projects_2gsoap_2plugin_2wsrmapi_8c" alt=""/></div>
</div>
</div><table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#ae217764567f04ef0b1e2a208f8e62d66">soap_wsrm_init</a> (struct soap *soap, struct <a class="el" href="structsoap__wsrm__data.html">soap_wsrm_data</a> *data, void *arg)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes plugin data.  <a href="#ae217764567f04ef0b1e2a208f8e62d66"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#a4f296f96d8787a1f864a5d3562250f0a">soap_wsrm_copy</a> (struct soap *soap, struct soap_plugin *p, struct soap_plugin *q)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy plugin data.  <a href="#a4f296f96d8787a1f864a5d3562250f0a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#adfeafbbe659550e4055c3f49aa564f5c">soap_wsrm_delete</a> (struct soap *soap, struct soap_plugin *p)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes plugin data.  <a href="#adfeafbbe659550e4055c3f49aa564f5c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#ac7ff6d902d415e409bd46096022e1eac">soap_wsrm_send</a> (struct soap *soap, const char *buf, size_t len)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal callback function to override fsend(). When the wsrm plugin is enabled, saves the message to the current sequence that is created at the client side. Allows unacknowledged messages to be resend with <a class="el" href="wsrmapi_8h.html#af0644e93628d1c450cb3c73fed5afd4f" title="Client-side call to resend all non-acknowledged messages that were automatically cached for this sequ...">soap_wsrm_resend()</a>.  <a href="#ac7ff6d902d415e409bd46096022e1eac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#aaff41127e3a1960010dd0eed252a1779">soap_wsrm_preparefinalrecv</a> (struct soap *soap)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal callback function to override fpreparefinalrecv(). Takes acks returned by response to update the states of the sequences with acknowledgements. Acknowledged messages do not have to be resend and are purged from the sequence states. Also checks if at client-side response message was already received and otherwise records it in the state.  <a href="#aaff41127e3a1960010dd0eed252a1779"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#a37b48a2e189b15b873083802cafa745a">soap_wsrm_disconnect</a> (struct soap *soap)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal callback function to override fdisconnect(). Turns caching off, sets the cached message to NACK, and resets the server-side handle, so sequence can be deallocated later.  <a href="#a37b48a2e189b15b873083802cafa745a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#a3a1093d90de46a3170cfc9d980c728a1">soap_wsrm_process_ack</a> (struct soap *soap, struct <a class="el" href="struct__wsrm_____sequence_acknowledgement.html">_wsrm__SequenceAcknowledgement</a> *ack)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal function to purge acknowledged messages as given by wsrm:SequenceAcknowledgement header.  <a href="#a3a1093d90de46a3170cfc9d980c728a1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#acfeb9cf37279d4bf6f436a2d0a591e6f">soap_wsrm_add_acks</a> (struct soap *soap)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal function to add SequenceAcknowledgement headers for AckRequested. Sends acknowledgements to the AcksTo destination service or back to the source. These sends can take SOAP_WSRM_TIMEOUT seconds time, with at most 10 retries performed.  <a href="#acfeb9cf37279d4bf6f436a2d0a591e6f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#a101b336e539b0527bcf5bc1b2091d94f">soap_wsrm_set_ack</a> (struct soap *soap, struct <a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence</a> *seq, struct <a class="el" href="struct__wsrm_____sequence_acknowledgement.html">_wsrm__SequenceAcknowledgement</a> *ack)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal function called by <a class="el" href="wsrmapi_8c.html#acfeb9cf37279d4bf6f436a2d0a591e6f" title="Internal function to add SequenceAcknowledgement headers for AckRequested. Sends acknowledgements to ...">soap_wsrm_add_acks()</a> to populate the SequenceAcknowledgement header block.  <a href="#a101b336e539b0527bcf5bc1b2091d94f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#ad95f4acccaf87b7f2c9f460a5a2d992b">soap_wsrm_resend_seq</a> (struct soap *soap, struct <a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence</a> *seq, ULONG64 lower, ULONG64 upper)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal function to resend unacknowledged messages of a sequence given a range of message numbers. Used by <a class="el" href="wsrmapi_8h.html#af0644e93628d1c450cb3c73fed5afd4f" title="Client-side call to resend all non-acknowledged messages that were automatically cached for this sequ...">soap_wsrm_resend()</a>.  <a href="#ad95f4acccaf87b7f2c9f460a5a2d992b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#a52fd48a4b0e18498c7a7b64fd9f97c91">soap_wsrm_seq_newid</a> (struct soap *soap, struct <a class="el" href="structsoap__wsrm__data.html">soap_wsrm_data</a> *data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal function to generate a new sequence identifier.  <a href="#a52fd48a4b0e18498c7a7b64fd9f97c91"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#a41af4d5508da70c827b04c8e58907365">soap_wsrm_seq_lookup</a> (const struct <a class="el" href="structsoap__wsrm__data.html">soap_wsrm_data</a> *data, const char *id)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal function to look up sequence given its id.  <a href="#a41af4d5508da70c827b04c8e58907365"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#ae8fd48312ea83f82957725d6080a17ac">soap_wsrm_seq_lookup_ack</a> (const struct <a class="el" href="structsoap__wsrm__data.html">soap_wsrm_data</a> *data, const char *id)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal function to look up sequence given its acksid.  <a href="#ae8fd48312ea83f82957725d6080a17ac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#a50f1196273d87a048697ae98a6e34f73">soap_wsrm_seq_insert</a> (struct soap *soap, struct <a class="el" href="structsoap__wsrm__data.html">soap_wsrm_data</a> *data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal function to create a new local sequence state.  <a href="#a50f1196273d87a048697ae98a6e34f73"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#ab9a66b74f5a83ccd622d21761eee2cd8">soap_wsrm_msg_append</a> (struct soap *soap, struct <a class="el" href="structsoap__wsrm__data.html">soap_wsrm_data</a> *data, const char *buf, size_t len)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal function used by <a class="el" href="wsrmapi_8c.html#ac7ff6d902d415e409bd46096022e1eac" title="Internal callback function to override fsend(). When the wsrm plugin is enabled, saves the message to...">soap_wsrm_send()</a> to append message data to the current message being transmitted for the current sequence.  <a href="#ab9a66b74f5a83ccd622d21761eee2cd8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#a78a2fa23790452bac71a5f072f8b724f">soap_wsrm_seq_terminated</a> (struct soap *soap, struct <a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence</a> *seq)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal function to check if a sequence is terminated or needs to be terminated when expired.  <a href="#a78a2fa23790452bac71a5f072f8b724f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#a65f6112c6e361533f7b6443baae09578">soap_wsrm_num_lookup</a> (struct soap *soap, const struct <a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence</a> *seq, ULONG64 num)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal function to look up a message number in the sequence state.  <a href="#a65f6112c6e361533f7b6443baae09578"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#a0438af9292fd010392709375126346ca">soap_wsrm_num_insert</a> (struct soap *soap, struct <a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence</a> *seq, ULONG64 num)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal function to insert a message number in the sequence state. Updates the sequence ranges.  <a href="#a0438af9292fd010392709375126346ca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#ae505bc4b6468b034dddc6d5562d5d564">soap_wsrm_num_size</a> (const struct <a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence</a> *seq)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal function returns the number of message ranges in a sequence state.  <a href="#ae505bc4b6468b034dddc6d5562d5d564"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#ab21e11870cb50f0a06b8f3b4bc4cf2ef">soap_wsrm_num_free</a> (struct soap *soap, struct <a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence</a> *seq)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal function to deallocate all message number ranges from a sequence state.  <a href="#ab21e11870cb50f0a06b8f3b4bc4cf2ef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structsoap__wsrm__message.html">soap_wsrm_message</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#a259f8b53be93534e90ccc56a46d76c02">soap_wsrm_msg_new</a> (struct soap *soap, struct <a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence</a> *seq, ULONG64 num)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal function to allocate a new message for a sequence sequence state.  <a href="#a259f8b53be93534e90ccc56a46d76c02"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#a0e3f1f0d75b70c9ba5df7ec5935037c7">soap_wsrm_msg_free</a> (struct soap *soap, struct <a class="el" href="structsoap__wsrm__message.html">soap_wsrm_message</a> *p)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal function to deallocate all cached message content from a sequence state.  <a href="#a0e3f1f0d75b70c9ba5df7ec5935037c7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#a070f3ffaacb8c9b160a7d8a1246a6c9a">soap_wsrm_create</a> (struct soap *soap, const char *to, const char *acksto, LONG64 expires, const char *wsa_id, <a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence_handle</a> *seq)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new sequence. Sequences are usually created by the sender (client) and confirmed by the receiver (server). The 'to' server address must be used for all messages of the sequence to be sent to the server. Optionally the 'acksto' address can be given for acknowledgement messages to be sent to. A sequence ID is generated by the server upon success.  <a href="#a070f3ffaacb8c9b160a7d8a1246a6c9a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#a426dbfc35357b39b0d84bd21fdbafa12">soap_wsrm_create_offer</a> (struct soap *soap, const char *to, const char *acksto, const char *id, LONG64 expires, enum <a class="el" href="wsrm_8h.html#aff9cd7eafbe766f7c92b26f868cb0418">wsrm__IncompleteSequenceBehaviorType</a> behavior, const char *wsa_id, <a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence_handle</a> *seq)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new sequence by offering suggested WS-RM parameters to the destination. Sequences are usually created by the sender (client) and confirmed by the receiver (server). The 'to' server address must be used for all messages of the sequence to be sent to the server. Optionally the 'acksto' address can be given for acknowledgement messages to be sent to. server upon success.  <a href="#a426dbfc35357b39b0d84bd21fdbafa12"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#ae5fdeabdc2ec09fb63b27839275598d3">soap_wsrm_request_num</a> (struct soap *soap, <a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence_handle</a> seq, const char *wsa_id, const char *wsa_action, ULONG64 num)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a WS-RM sequence message number to the next message transmitted. No acks are requested.  <a href="#ae5fdeabdc2ec09fb63b27839275598d3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#a05857d4bed3b3052e6878f490330277f">soap_wsrm_request</a> (struct soap *soap, <a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence_handle</a> seq, const char *wsa_id, const char *wsa_action)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a WS-RM sequence message number to the next message transmitted to the WS-RM destination and increments the message counter by one. No acks are requested.  <a href="#a05857d4bed3b3052e6878f490330277f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#a7292b4a8e24e767b538e0fb2993a6864">soap_wsrm_request_acks</a> (struct soap *soap, <a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence_handle</a> seq, const char *wsa_id, const char *wsa_action)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a WS-RM sequence message number to the next message transmitted to the WS-RM destination and increments the message counter by one. Message acks for the current sequence are requested.  <a href="#a7292b4a8e24e767b538e0fb2993a6864"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#a091a66f982799656bf39cf713ff29eff">soap_wsrm_check_retry</a> (struct soap *soap, <a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence_handle</a> seq)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Client-side check to verify if the remote call can be retried when a failure occured. Increases the robustness of messages sends, by ensuring that the message was at least transmitted (but not necessarily received). Also implements HTTP 307 Temporary Redirect. Retries are limited to SOAP_WSRM_MAX_RETRIES iterations.  <a href="#a091a66f982799656bf39cf713ff29eff"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#af0644e93628d1c450cb3c73fed5afd4f">soap_wsrm_resend</a> (struct soap *soap, <a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence_handle</a> seq, ULONG64 lower, ULONG64 upper)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Client-side call to resend all non-acknowledged messages that were automatically cached for this sequence. Messages stored in the sequence for retransmission (those that were previously sent but not acknowledged) are resent to the <a class="el" href="wsrmapi_8h.html#a6b6ce73440955d04712c6acb429f536b" title="Returns the endpoint address of the destination service that serves the sequence. Initially set with ...">soap_wsrm_to()</a> address, which was set by <a class="el" href="wsrmapi_8h.html#a070f3ffaacb8c9b160a7d8a1246a6c9a" title="Creates a new sequence. Sequences are usually created by the sender (client) and confirmed by the rec...">soap_wsrm_create()</a> or <a class="el" href="wsrmapi_8h.html#a426dbfc35357b39b0d84bd21fdbafa12" title="Creates a new sequence by offering suggested WS-RM parameters to the destination. Sequences are usual...">soap_wsrm_create_offer()</a>. It is recommended to resend messages after the last message in the sequence was transmitted before closing the sequence. To reduce unnecessary resend attempts, it is recommended to use soap_wsrm_request_ack() with the last message to request acks for messages already delivered.  <a href="#af0644e93628d1c450cb3c73fed5afd4f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#a663e39e46e4fb291ee0f9af8a0badac5">soap_wsrm_close</a> (struct soap *soap, <a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence_handle</a> seq, const char *wsa_id)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the sequence, but does not yet terminate it. No new messages should be send, but messages can be resend with <a class="el" href="wsrmapi_8h.html#af0644e93628d1c450cb3c73fed5afd4f" title="Client-side call to resend all non-acknowledged messages that were automatically cached for this sequ...">soap_wsrm_resend()</a> if desired.  <a href="#a663e39e46e4fb291ee0f9af8a0badac5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#aed55a951561e63b74699003f423e6e4d">soap_wsrm_terminate</a> (struct soap *soap, <a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence_handle</a> seq, const char *wsa_id)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Terminates the sequence. No new messages should be send and no resends should be tried. Usually done after <a class="el" href="wsrmapi_8h.html#a663e39e46e4fb291ee0f9af8a0badac5" title="Closes the sequence, but does not yet terminate it. No new messages should be send, but messages can be resend with soap_wsrm_resend() if desired.">soap_wsrm_close()</a> or any time to terminate the sequence prematurely.  <a href="#aed55a951561e63b74699003f423e6e4d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#a21c32d0aaadf26d86170098a890c0e54">soap_wsrm_seq_free</a> (struct soap *soap, <a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence_handle</a> seq)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Must be called to free the sequence allocated by <a class="el" href="wsrmapi_8h.html#a070f3ffaacb8c9b160a7d8a1246a6c9a" title="Creates a new sequence. Sequences are usually created by the sender (client) and confirmed by the rec...">soap_wsrm_create()</a> or by <a class="el" href="wsrmapi_8h.html#a426dbfc35357b39b0d84bd21fdbafa12" title="Creates a new sequence by offering suggested WS-RM parameters to the destination. Sequences are usual...">soap_wsrm_create_offer()</a>. Sequence handles are not automatically reclaimed by the engine.  <a href="#a21c32d0aaadf26d86170098a890c0e54"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#a3ba123420e7bb4528588fbbc4a3795f8">soap_wsrm_to</a> (<a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence_handle</a> seq)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the endpoint address of the destination service that serves the sequence. Initially set with soap_wsrm_create or soap_wsrm_create_offer. HTTP 307 Temporary Redirect can change the endpoint during the lifetime of a message sequence. Thus, this function returns the most recent endpoint binding that can be used to send message to the server endpoint.  <a href="#a3ba123420e7bb4528588fbbc4a3795f8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#aa9ecf7b23be8eb3c89a34a52ae8f3236">soap_wsrm_acksto</a> (<a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence_handle</a> seq)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the endpoint address of the AcksTo acknowledgement service that serves the sequence, when set with <a class="el" href="wsrmapi_8h.html#a070f3ffaacb8c9b160a7d8a1246a6c9a" title="Creates a new sequence. Sequences are usually created by the sender (client) and confirmed by the rec...">soap_wsrm_create()</a> or <a class="el" href="wsrmapi_8h.html#a426dbfc35357b39b0d84bd21fdbafa12" title="Creates a new sequence by offering suggested WS-RM parameters to the destination. Sequences are usual...">soap_wsrm_create_offer()</a> or NULL otherwise. HTTP 307 Temporary Redirect can change the endpoint during the lifetime of a message sequence. Thus, this function returns the most recent endpoint binding.  <a href="#aa9ecf7b23be8eb3c89a34a52ae8f3236"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ULONG64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#aece714bf9f13141b0cce8a914ce9709c">soap_wsrm_num</a> (<a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence_handle</a> seq)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current message number of the sequence.  <a href="#aece714bf9f13141b0cce8a914ce9709c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ULONG64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#a2ceeeb0b560422f249524024ec37160b">soap_wsrm_nack</a> (<a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence_handle</a> seq)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of non-acknowledged messages sent.  <a href="#a2ceeeb0b560422f249524024ec37160b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#a0304e1219b99929fa576cf12114206eb">soap_wsrm_check</a> (struct soap *soap)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Server-side check for the presence of WS-Addressing and WS-RM header blocks in the SOAP header. Also prepares the return WS-RM header. This function should be called in the each service operation that supports WS-RM. Do not use this function in a ReplyTo response-accepting destination service operation.  <a href="#a0304e1219b99929fa576cf12114206eb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#ad7d6e11c10a16bf032a7af10a8470cd0">soap_wsrm_reply_num</a> (struct soap *soap)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a WS-RM sequence message number to the next message transmitted. No acks are requested. No WS-Addressing relay.  <a href="#ad7d6e11c10a16bf032a7af10a8470cd0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#af7ab54d15beca0118bdffc64520b6589">soap_wsrm_reply</a> (struct soap *soap, const char *wsa_id, const char *wsa_action)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Server-side server operation reply to be performed when the service operation returns. Server operations that support WS-Addressing and WS-RM must call this function to return normally (and allow the response to be relayed).  <a href="#af7ab54d15beca0118bdffc64520b6589"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#ad88bd9d375279ec59cbb82ba0e76caf2">soap_wsrm_reply_request_acks</a> (struct soap *soap, const char *wsa_id, const char *wsa_action)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Server-side server operation reply to be performed when the service operation returns. Message acks for the current sequence are requested, but only when client made a create sequence offer. Server operations that support WS-Addressing and WS-RM must call this function or <a class="el" href="wsrmapi_8h.html#af7ab54d15beca0118bdffc64520b6589" title="Server-side server operation reply to be performed when the service operation returns. Server operations that support WS-Addressing and WS-RM must call this function to return normally (and allow the response to be relayed).">soap_wsrm_reply()</a> to return normally (and allow the response to be relayed).  <a href="#ad88bd9d375279ec59cbb82ba0e76caf2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#a1b16c06bd2a4cb938c1c66868b34d4b5">soap_wsrm_cleanup</a> (struct soap *soap)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Cleans up all expired sequences and releases resources. To be used at the server side to periodically clean up WS-RM sequences. Server-side cleanup is automatic, as long as WS-RM is in use. Does not release client-side sequences allocated by <a class="el" href="wsrmapi_8h.html#a070f3ffaacb8c9b160a7d8a1246a6c9a" title="Creates a new sequence. Sequences are usually created by the sender (client) and confirmed by the rec...">soap_wsrm_create()</a> or <a class="el" href="wsrmapi_8h.html#a426dbfc35357b39b0d84bd21fdbafa12" title="Creates a new sequence by offering suggested WS-RM parameters to the destination. Sequences are usual...">soap_wsrm_create_offer()</a>.  <a href="#a1b16c06bd2a4cb938c1c66868b34d4b5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#afc3adfdfdc6c60dd2085f3adb541f7c3">__wsrm__CreateSequence</a> (struct soap *soap, struct <a class="el" href="structwsrm_____create_sequence_type.html">wsrm__CreateSequenceType</a> *req, struct <a class="el" href="structwsrm_____create_sequence_response_type.html">wsrm__CreateSequenceResponseType</a> *res)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">WS-RM CreateSequence service operation. Automatically invoked by the server to process a create sequence request (with or without offer). Creates a new local sequence state to keep track of messages.  <a href="#afc3adfdfdc6c60dd2085f3adb541f7c3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#a45392a369c8c0c545a8356958ffe8638">__wsrm__CloseSequence</a> (struct soap *soap, struct <a class="el" href="structwsrm_____close_sequence_type.html">wsrm__CloseSequenceType</a> *req, struct <a class="el" href="structwsrm_____close_sequence_response_type.html">wsrm__CloseSequenceResponseType</a> *res)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">WS-RM CloseSequence service operation. Automatically invoked by the server to process the close sequence request. Updates the server's local sequence state to closed.  <a href="#a45392a369c8c0c545a8356958ffe8638"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#ad937d441ba6e8fe06b7c4b2d958512bb">__wsrm__TerminateSequence</a> (struct soap *soap, struct <a class="el" href="structwsrm_____terminate_sequence_type.html">wsrm__TerminateSequenceType</a> *req, struct <a class="el" href="structwsrm_____terminate_sequence_response_type.html">wsrm__TerminateSequenceResponseType</a> *res)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">WS-RM TerminateSequence service operation. Automatically invoked by the server to process the close sequence request. Updates the server's local sequence state to terminated.  <a href="#ad937d441ba6e8fe06b7c4b2d958512bb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#a946176cad5228da0fdbc3b672535e054">__wsrm__SequenceAcknowledgement</a> (struct soap *soap)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">WS-RM SequenceAcknowledgement service operation of the AcksTo destination service for relayed acknowledgements. Invoked by the server. The AcksTo server maintains the messages that are acknowledged by updating its local sequence state information by registering message acknowledgement receipts.  <a href="#a946176cad5228da0fdbc3b672535e054"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#addf7a38c3091d9e2f0151009d4bad14b">soap_wsrm_fault_subcode</a> (struct soap *soap, int flag, const char *faultsubcode, const char *faultstring, const char *faultdetail)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets sender/receiver SOAP Fault (sub)code for server faults (can be user defined faults). When called before <a class="el" href="wsrmapi_8h.html#a0304e1219b99929fa576cf12114206eb" title="Server-side check for the presence of WS-Addressing and WS-RM header blocks in the SOAP header...">soap_wsrm_check()</a> in the server operation, terminates the current sequence. Otherwise, the sequence is not terminated. In either case the fault is returned to sender (client) or to the FaultTo server when the WS-Addressing FaultTo header was set by the sender.  <a href="#addf7a38c3091d9e2f0151009d4bad14b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#a94a53920fbe164b32905a34a73317ac6">soap_wsrm_sender_fault_subcode</a> (struct soap *soap, const char *faultsubcode, const char *faultstring, const char *faultdetail)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets sender SOAP Fault (sub)code for server faults (can be user defined faults). When called before <a class="el" href="wsrmapi_8h.html#a0304e1219b99929fa576cf12114206eb" title="Server-side check for the presence of WS-Addressing and WS-RM header blocks in the SOAP header...">soap_wsrm_check()</a> in the server operation, terminates the current sequence. Otherwise, the sequence is not terminated. In either case the fault is returned to sender (client) or to the FaultTo server when the WS-Addressing FaultTo header was set by the sender.  <a href="#a94a53920fbe164b32905a34a73317ac6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#a6cb3621b4a3ab658059000974d7ee96c">soap_wsrm_receiver_fault_subcode</a> (struct soap *soap, const char *faultsubcode, const char *faultstring, const char *faultdetail)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets receiver SOAP Fault (sub)code for server faults (can be user defined faults). When called before <a class="el" href="wsrmapi_8h.html#a0304e1219b99929fa576cf12114206eb" title="Server-side check for the presence of WS-Addressing and WS-RM header blocks in the SOAP header...">soap_wsrm_check()</a> in the server operation, terminates the current sequence. Otherwise, the sequence is not terminated. In either case the fault is returned to sender (client) or to the FaultTo server when the WS-Addressing FaultTo header was set by the sender.  <a href="#a6cb3621b4a3ab658059000974d7ee96c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#af2bcd68f3810d632bef61ecfe86e1e5f">soap_wsrm_sender_fault</a> (struct soap *soap, const char *faultstring, const char *faultdetail)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets sender SOAP Fault for server faults (can be user defined faults). When called before <a class="el" href="wsrmapi_8h.html#a0304e1219b99929fa576cf12114206eb" title="Server-side check for the presence of WS-Addressing and WS-RM header blocks in the SOAP header...">soap_wsrm_check()</a> in the server operation, terminates the current sequence. Otherwise, the sequence is not terminated. In either case the fault is returned to sender (client) or to the FaultTo server when the WS-Addressing FaultTo header was set by the sender.  <a href="#af2bcd68f3810d632bef61ecfe86e1e5f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#a65c7a86eaf7366b9cb9c4759c1f7c061">soap_wsrm_receiver_fault</a> (struct soap *soap, const char *faultstring, const char *faultdetail)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets receiver SOAP Fault for server faults (can be user defined faults). When called before <a class="el" href="wsrmapi_8h.html#a0304e1219b99929fa576cf12114206eb" title="Server-side check for the presence of WS-Addressing and WS-RM header blocks in the SOAP header...">soap_wsrm_check()</a> in the server operation, terminates the current sequence. Otherwise, the sequence is not terminated. In either case the fault is returned to sender (client) or to the FaultTo server when the WS-Addressing FaultTo header was set by the sender.  <a href="#a65c7a86eaf7366b9cb9c4759c1f7c061"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#a27bfb3df2145cb5a7302129dfedd2645">soap_wsrm_check_fault</a> (struct soap *soap, enum <a class="el" href="wsrm_8h.html#a74a1b26ed97040d29fb3ad5b1e88a3c8">wsrm__FaultCodes</a> *fault, const char **info)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the presence of a WS-RM fault at the client side (or in the FaultTo destination service) when a response is received.  <a href="#a27bfb3df2145cb5a7302129dfedd2645"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#a8c2c3d3298b9695483f5562d9765e8cc">soap_wsrm_error</a> (struct soap *soap, struct <a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence</a> *seq, enum <a class="el" href="wsrm_8h.html#a74a1b26ed97040d29fb3ad5b1e88a3c8">wsrm__FaultCodes</a> fault)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets SOAP Fault (sub)code for server WS-RM fault response. Terminates the sequence.  <a href="#a8c2c3d3298b9695483f5562d9765e8cc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#a283b52421482f2afaf2bd44cf1372c91">soap_wsrm_dump</a> (struct soap *soap, FILE *fd)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Dumps the current sequences and details of the wsrm plugin for diagnotics purposes.  <a href="#a283b52421482f2afaf2bd44cf1372c91"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#aaf792b8e8eff0209f4d84e156d726231">soap_wsrm</a> (struct soap *soap, struct soap_plugin *p, void *arg)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Plugin registry function, used with soap_register_plugin.  <a href="#aaf792b8e8eff0209f4d84e156d726231"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#a2f5b88f6da2708c658e230610ca380ab">soap_wsrm_id</a> [] = SOAP_WSRM_ID</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#a1b87a809162eab1f088457a69765dfa6">soap_wsrm_session</a> = NULL</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#a3bbcb03227062fef356ef38dd45f0924">soap_wsrm_idname</a> = NULL</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#ac68843c070e732b20450b4e9bdfb91fe">soap_wsrm_idnum</a> = 0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static MUTEX_TYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#a1f675d133185cc7a40b0af8e0d5ffdcb">soap_wsrm_session_lock</a> = MUTEX_INITIALIZER</td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a45392a369c8c0c545a8356958ffe8638"></a><!-- doxytag: member="wsrmapi.c::__wsrm__CloseSequence" ref="a45392a369c8c0c545a8356958ffe8638" args="(struct soap *soap, struct wsrm__CloseSequenceType *req, struct wsrm__CloseSequenceResponseType *res)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int __wsrm__CloseSequence </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structwsrm_____close_sequence_type.html">wsrm__CloseSequenceType</a> *&#160;</td>
          <td class="paramname"><em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structwsrm_____close_sequence_response_type.html">wsrm__CloseSequenceResponseType</a> *&#160;</td>
          <td class="paramname"><em>res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>WS-RM CloseSequence service operation. Automatically invoked by the server to process the close sequence request. Updates the server's local sequence state to closed. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">soap</td><td>context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">req</td><td>wsrm__CloseSequence request message </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">res</td><td>wsrm__CloseSequenceResponse response message </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SOAP_OK or error code </dd></dl>

</div>
</div>
<a class="anchor" id="afc3adfdfdc6c60dd2085f3adb541f7c3"></a><!-- doxytag: member="wsrmapi.c::__wsrm__CreateSequence" ref="afc3adfdfdc6c60dd2085f3adb541f7c3" args="(struct soap *soap, struct wsrm__CreateSequenceType *req, struct wsrm__CreateSequenceResponseType *res)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int __wsrm__CreateSequence </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structwsrm_____create_sequence_type.html">wsrm__CreateSequenceType</a> *&#160;</td>
          <td class="paramname"><em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structwsrm_____create_sequence_response_type.html">wsrm__CreateSequenceResponseType</a> *&#160;</td>
          <td class="paramname"><em>res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>WS-RM CreateSequence service operation. Automatically invoked by the server to process a create sequence request (with or without offer). Creates a new local sequence state to keep track of messages. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">soap</td><td>context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">req</td><td>wsrm__CreateSequence request message </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">res</td><td>wsrm__CreateSequenceResponse response message </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SOAP_OK or error code </dd></dl>

</div>
</div>
<a class="anchor" id="a946176cad5228da0fdbc3b672535e054"></a><!-- doxytag: member="wsrmapi.c::__wsrm__SequenceAcknowledgement" ref="a946176cad5228da0fdbc3b672535e054" args="(struct soap *soap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int __wsrm__SequenceAcknowledgement </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>WS-RM SequenceAcknowledgement service operation of the AcksTo destination service for relayed acknowledgements. Invoked by the server. The AcksTo server maintains the messages that are acknowledged by updating its local sequence state information by registering message acknowledgement receipts. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td>context </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SOAP_OK or error code </dd></dl>

</div>
</div>
<a class="anchor" id="ad937d441ba6e8fe06b7c4b2d958512bb"></a><!-- doxytag: member="wsrmapi.c::__wsrm__TerminateSequence" ref="ad937d441ba6e8fe06b7c4b2d958512bb" args="(struct soap *soap, struct wsrm__TerminateSequenceType *req, struct wsrm__TerminateSequenceResponseType *res)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int __wsrm__TerminateSequence </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structwsrm_____terminate_sequence_type.html">wsrm__TerminateSequenceType</a> *&#160;</td>
          <td class="paramname"><em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structwsrm_____terminate_sequence_response_type.html">wsrm__TerminateSequenceResponseType</a> *&#160;</td>
          <td class="paramname"><em>res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>WS-RM TerminateSequence service operation. Automatically invoked by the server to process the close sequence request. Updates the server's local sequence state to terminated. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">soap</td><td>context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">req</td><td>wsrm__TerminateSequence request message </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">res</td><td>wsrm__TerminateSequenceResponse response message </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SOAP_OK or error code </dd></dl>

</div>
</div>
<a class="anchor" id="aaf792b8e8eff0209f4d84e156d726231"></a><!-- doxytag: member="wsrmapi.c::soap_wsrm" ref="aaf792b8e8eff0209f4d84e156d726231" args="(struct soap *soap, struct soap_plugin *p, void *arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soap_wsrm </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct soap_plugin *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Plugin registry function, used with soap_register_plugin. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">soap</td><td>context </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">p</td><td>plugin created in registry </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>optional argument passed from soap_register_plugin_arg </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SOAP_OK </dd></dl>

</div>
</div>
<a class="anchor" id="aa9ecf7b23be8eb3c89a34a52ae8f3236"></a><!-- doxytag: member="wsrmapi.c::soap_wsrm_acksto" ref="aa9ecf7b23be8eb3c89a34a52ae8f3236" args="(soap_wsrm_sequence_handle seq)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* soap_wsrm_acksto </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence_handle</a>&#160;</td>
          <td class="paramname"><em>seq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the endpoint address of the AcksTo acknowledgement service that serves the sequence, when set with <a class="el" href="wsrmapi_8h.html#a070f3ffaacb8c9b160a7d8a1246a6c9a" title="Creates a new sequence. Sequences are usually created by the sender (client) and confirmed by the rec...">soap_wsrm_create()</a> or <a class="el" href="wsrmapi_8h.html#a426dbfc35357b39b0d84bd21fdbafa12" title="Creates a new sequence by offering suggested WS-RM parameters to the destination. Sequences are usual...">soap_wsrm_create_offer()</a> or NULL otherwise. HTTP 307 Temporary Redirect can change the endpoint during the lifetime of a message sequence. Thus, this function returns the most recent endpoint binding. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">seq</td><td>sequence handle set by <a class="el" href="wsrmapi_8h.html#a070f3ffaacb8c9b160a7d8a1246a6c9a" title="Creates a new sequence. Sequences are usually created by the sender (client) and confirmed by the rec...">soap_wsrm_create()</a> or <a class="el" href="wsrmapi_8h.html#a426dbfc35357b39b0d84bd21fdbafa12" title="Creates a new sequence by offering suggested WS-RM parameters to the destination. Sequences are usual...">soap_wsrm_create_offer()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the sequence endpoint address </dd></dl>

</div>
</div>
<a class="anchor" id="acfeb9cf37279d4bf6f436a2d0a591e6f"></a><!-- doxytag: member="wsrmapi.c::soap_wsrm_add_acks" ref="acfeb9cf37279d4bf6f436a2d0a591e6f" args="(struct soap *soap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int soap_wsrm_add_acks </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Internal function to add SequenceAcknowledgement headers for AckRequested. Sends acknowledgements to the AcksTo destination service or back to the source. These sends can take SOAP_WSRM_TIMEOUT seconds time, with at most 10 retries performed. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td>context </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SOAP_OK or error code </dd></dl>

</div>
</div>
<a class="anchor" id="a0304e1219b99929fa576cf12114206eb"></a><!-- doxytag: member="wsrmapi.c::soap_wsrm_check" ref="a0304e1219b99929fa576cf12114206eb" args="(struct soap *soap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soap_wsrm_check </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Server-side check for the presence of WS-Addressing and WS-RM header blocks in the SOAP header. Also prepares the return WS-RM header. This function should be called in the each service operation that supports WS-RM. Do not use this function in a ReplyTo response-accepting destination service operation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td>context </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SOAP_OK or error code (and server operation must return this value) </dd></dl>

</div>
</div>
<a class="anchor" id="a27bfb3df2145cb5a7302129dfedd2645"></a><!-- doxytag: member="wsrmapi.c::soap_wsrm_check_fault" ref="a27bfb3df2145cb5a7302129dfedd2645" args="(struct soap *soap, enum wsrm__FaultCodes *fault, const char **info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soap_wsrm_check_fault </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="wsrm_8h.html#a74a1b26ed97040d29fb3ad5b1e88a3c8">wsrm__FaultCodes</a> *&#160;</td>
          <td class="paramname"><em>fault</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks the presence of a WS-RM fault at the client side (or in the FaultTo destination service) when a response is received. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">soap</td><td>context </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">fault</td><td>code </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>string pointer related to the fault (or NULL) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SOAP_OK (no fault or not a WS-RM fault) or error when not WS-RM fault </dd></dl>

</div>
</div>
<a class="anchor" id="a091a66f982799656bf39cf713ff29eff"></a><!-- doxytag: member="wsrmapi.c::soap_wsrm_check_retry" ref="a091a66f982799656bf39cf713ff29eff" args="(struct soap *soap, soap_wsrm_sequence_handle seq)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soap_wsrm_check_retry </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence_handle</a>&#160;</td>
          <td class="paramname"><em>seq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Client-side check to verify if the remote call can be retried when a failure occured. Increases the robustness of messages sends, by ensuring that the message was at least transmitted (but not necessarily received). Also implements HTTP 307 Temporary Redirect. Retries are limited to SOAP_WSRM_MAX_RETRIES iterations. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td>context </td></tr>
    <tr><td class="paramname">seq</td><td>sequence handle set by soap_wsrm_create or soap_wsrm_create_offer </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SOAP_OK when retry is safe, error code otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a1b16c06bd2a4cb938c1c66868b34d4b5"></a><!-- doxytag: member="wsrmapi.c::soap_wsrm_cleanup" ref="a1b16c06bd2a4cb938c1c66868b34d4b5" args="(struct soap *soap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void soap_wsrm_cleanup </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Cleans up all expired sequences and releases resources. To be used at the server side to periodically clean up WS-RM sequences. Server-side cleanup is automatic, as long as WS-RM is in use. Does not release client-side sequences allocated by <a class="el" href="wsrmapi_8h.html#a070f3ffaacb8c9b160a7d8a1246a6c9a" title="Creates a new sequence. Sequences are usually created by the sender (client) and confirmed by the rec...">soap_wsrm_create()</a> or <a class="el" href="wsrmapi_8h.html#a426dbfc35357b39b0d84bd21fdbafa12" title="Creates a new sequence by offering suggested WS-RM parameters to the destination. Sequences are usual...">soap_wsrm_create_offer()</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td>context </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a663e39e46e4fb291ee0f9af8a0badac5"></a><!-- doxytag: member="wsrmapi.c::soap_wsrm_close" ref="a663e39e46e4fb291ee0f9af8a0badac5" args="(struct soap *soap, soap_wsrm_sequence_handle seq, const char *wsa_id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soap_wsrm_close </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence_handle</a>&#160;</td>
          <td class="paramname"><em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>wsa_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Closes the sequence, but does not yet terminate it. No new messages should be send, but messages can be resend with <a class="el" href="wsrmapi_8h.html#af0644e93628d1c450cb3c73fed5afd4f" title="Client-side call to resend all non-acknowledged messages that were automatically cached for this sequ...">soap_wsrm_resend()</a> if desired. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">soap</td><td>context </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">seq</td><td>sequence handle set by soap_wsrm_create or soap_wsrm_create_offer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wsa_id</td><td>WS-Addressing message ID (optional) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SOAP_OK or error code </dd></dl>

</div>
</div>
<a class="anchor" id="a4f296f96d8787a1f864a5d3562250f0a"></a><!-- doxytag: member="wsrmapi.c::soap_wsrm_copy" ref="a4f296f96d8787a1f864a5d3562250f0a" args="(struct soap *soap, struct soap_plugin *p, struct soap_plugin *q)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int soap_wsrm_copy </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct soap_plugin *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct soap_plugin *&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy plugin data. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">soap</td><td>context </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p</td><td>plugin </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td>plugin </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SOAP_OK </dd></dl>

</div>
</div>
<a class="anchor" id="a070f3ffaacb8c9b160a7d8a1246a6c9a"></a><!-- doxytag: member="wsrmapi.c::soap_wsrm_create" ref="a070f3ffaacb8c9b160a7d8a1246a6c9a" args="(struct soap *soap, const char *to, const char *acksto, LONG64 expires, const char *wsa_id, soap_wsrm_sequence_handle *seq)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soap_wsrm_create </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>acksto</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LONG64&#160;</td>
          <td class="paramname"><em>expires</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>wsa_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence_handle</a> *&#160;</td>
          <td class="paramname"><em>seq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new sequence. Sequences are usually created by the sender (client) and confirmed by the receiver (server). The 'to' server address must be used for all messages of the sequence to be sent to the server. Optionally the 'acksto' address can be given for acknowledgement messages to be sent to. A sequence ID is generated by the server upon success. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">soap</td><td>context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">to</td><td>endpoint address of the WS-RM destination server (required) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">acksto</td><td>endpoint address of the WS-RM acknowledgement server (optional, use NULL when acks are piggy-backed on response messages to the source) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">expires</td><td>max sequence duration (its lifetime) in ms (use 0 for inifinite) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wsa_id</td><td>WS-Addressing message ID (optional, use NULL when omitted) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">seq</td><td>sequence handle is set </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SOAP_OK or error code </dd></dl>

</div>
</div>
<a class="anchor" id="a426dbfc35357b39b0d84bd21fdbafa12"></a><!-- doxytag: member="wsrmapi.c::soap_wsrm_create_offer" ref="a426dbfc35357b39b0d84bd21fdbafa12" args="(struct soap *soap, const char *to, const char *acksto, const char *id, LONG64 expires, enum wsrm__IncompleteSequenceBehaviorType behavior, const char *wsa_id, soap_wsrm_sequence_handle *seq)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soap_wsrm_create_offer </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>acksto</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LONG64&#160;</td>
          <td class="paramname"><em>expires</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="wsrm_8h.html#aff9cd7eafbe766f7c92b26f868cb0418">wsrm__IncompleteSequenceBehaviorType</a>&#160;</td>
          <td class="paramname"><em>behavior</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>wsa_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence_handle</a> *&#160;</td>
          <td class="paramname"><em>seq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new sequence by offering suggested WS-RM parameters to the destination. Sequences are usually created by the sender (client) and confirmed by the receiver (server). The 'to' server address must be used for all messages of the sequence to be sent to the server. Optionally the 'acksto' address can be given for acknowledgement messages to be sent to. server upon success. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">soap</td><td>context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">to</td><td>endpoint address of the WS-RM destination server (required) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">acksto</td><td>endpoint address of the WS-RM acknowledgement server (optional, use NULL when acks are piggy-backed on response messages to the source) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>offered WS-RM sequence identifier (optional, generate when NULL) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">expires</td><td>max sequence duration (its lifetime) in ms (use 0 for inifinite) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">behavior</td><td>offered DiscardEntireSequence, DiscardFollowingFirstGap, or NoDiscard, which specifies the WS-RM destination's action when a sequence is closed/terminated when it is incomplete, and notifies the source when failed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wsa_id</td><td>WS-Addressing message ID (optional, use NULL when omitted) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">seq</td><td>sequence handle is set </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SOAP_OK or error code </dd></dl>

</div>
</div>
<a class="anchor" id="adfeafbbe659550e4055c3f49aa564f5c"></a><!-- doxytag: member="wsrmapi.c::soap_wsrm_delete" ref="adfeafbbe659550e4055c3f49aa564f5c" args="(struct soap *soap, struct soap_plugin *p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void soap_wsrm_delete </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct soap_plugin *&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deletes plugin data. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">soap</td><td>context </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">p</td><td>plugin </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SOAP_OK </dd></dl>

</div>
</div>
<a class="anchor" id="a37b48a2e189b15b873083802cafa745a"></a><!-- doxytag: member="wsrmapi.c::soap_wsrm_disconnect" ref="a37b48a2e189b15b873083802cafa745a" args="(struct soap *soap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int soap_wsrm_disconnect </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Internal callback function to override fdisconnect(). Turns caching off, sets the cached message to NACK, and resets the server-side handle, so sequence can be deallocated later. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td>context </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SOAP_OK or error code </dd></dl>

</div>
</div>
<a class="anchor" id="a283b52421482f2afaf2bd44cf1372c91"></a><!-- doxytag: member="wsrmapi.c::soap_wsrm_dump" ref="a283b52421482f2afaf2bd44cf1372c91" args="(struct soap *soap, FILE *fd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void soap_wsrm_dump </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Dumps the current sequences and details of the wsrm plugin for diagnotics purposes. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">soap</td><td>context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fd</td><td>file descriptor to send text to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8c2c3d3298b9695483f5562d9765e8cc"></a><!-- doxytag: member="wsrmapi.c::soap_wsrm_error" ref="a8c2c3d3298b9695483f5562d9765e8cc" args="(struct soap *soap, struct soap_wsrm_sequence *seq, enum wsrm__FaultCodes fault)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soap_wsrm_error </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence</a> *&#160;</td>
          <td class="paramname"><em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="wsrm_8h.html#a74a1b26ed97040d29fb3ad5b1e88a3c8">wsrm__FaultCodes</a>&#160;</td>
          <td class="paramname"><em>fault</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets SOAP Fault (sub)code for server WS-RM fault response. Terminates the sequence. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">soap</td><td>context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">seq</td><td>pointer to sequence to terminate or NULL </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fault</td><td>is one of enum wsrm__FaultCodes enumeration values </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SOAP_FAULT </dd></dl>

</div>
</div>
<a class="anchor" id="addf7a38c3091d9e2f0151009d4bad14b"></a><!-- doxytag: member="wsrmapi.c::soap_wsrm_fault_subcode" ref="addf7a38c3091d9e2f0151009d4bad14b" args="(struct soap *soap, int flag, const char *faultsubcode, const char *faultstring, const char *faultdetail)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soap_wsrm_fault_subcode </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>faultsubcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>faultstring</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>faultdetail</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets sender/receiver SOAP Fault (sub)code for server faults (can be user defined faults). When called before <a class="el" href="wsrmapi_8h.html#a0304e1219b99929fa576cf12114206eb" title="Server-side check for the presence of WS-Addressing and WS-RM header blocks in the SOAP header...">soap_wsrm_check()</a> in the server operation, terminates the current sequence. Otherwise, the sequence is not terminated. In either case the fault is returned to sender (client) or to the FaultTo server when the WS-Addressing FaultTo header was set by the sender. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">soap</td><td>context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flag</td><td>0=receiver, 1=sender </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">faultsubcode</td><td>sub code string </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">faultstring</td><td>fault string </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">faultdetail</td><td>detail string </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SOAP_FAULT </dd></dl>

</div>
</div>
<a class="anchor" id="ae217764567f04ef0b1e2a208f8e62d66"></a><!-- doxytag: member="wsrmapi.c::soap_wsrm_init" ref="ae217764567f04ef0b1e2a208f8e62d66" args="(struct soap *soap, struct soap_wsrm_data *data, void *arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int soap_wsrm_init </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structsoap__wsrm__data.html">soap_wsrm_data</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initializes plugin data. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">soap</td><td>context </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>plugin data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>optional argument passed from soap_register_plugin_arg </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SOAP_OK </dd></dl>

</div>
</div>
<a class="anchor" id="ab9a66b74f5a83ccd622d21761eee2cd8"></a><!-- doxytag: member="wsrmapi.c::soap_wsrm_msg_append" ref="ab9a66b74f5a83ccd622d21761eee2cd8" args="(struct soap *soap, struct soap_wsrm_data *data, const char *buf, size_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int soap_wsrm_msg_append </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structsoap__wsrm__data.html">soap_wsrm_data</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Internal function used by <a class="el" href="wsrmapi_8c.html#ac7ff6d902d415e409bd46096022e1eac" title="Internal callback function to override fsend(). When the wsrm plugin is enabled, saves the message to...">soap_wsrm_send()</a> to append message data to the current message being transmitted for the current sequence. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">soap</td><td>context </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">data</td><td>plugin </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>message data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>message data length </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SOAP_OK or error code </dd></dl>

</div>
</div>
<a class="anchor" id="a0e3f1f0d75b70c9ba5df7ec5935037c7"></a><!-- doxytag: member="wsrmapi.c::soap_wsrm_msg_free" ref="a0e3f1f0d75b70c9ba5df7ec5935037c7" args="(struct soap *soap, struct soap_wsrm_message *p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void soap_wsrm_msg_free </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structsoap__wsrm__message.html">soap_wsrm_message</a> *&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Internal function to deallocate all cached message content from a sequence state. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td>context </td></tr>
    <tr><td class="paramname">p</td><td>pointer to message (in a sequence state) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a259f8b53be93534e90ccc56a46d76c02"></a><!-- doxytag: member="wsrmapi.c::soap_wsrm_msg_new" ref="a259f8b53be93534e90ccc56a46d76c02" args="(struct soap *soap, struct soap_wsrm_sequence *seq, ULONG64 num)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static struct <a class="el" href="structsoap__wsrm__message.html">soap_wsrm_message</a> * soap_wsrm_msg_new </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence</a> *&#160;</td>
          <td class="paramname"><em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ULONG64&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static, read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Internal function to allocate a new message for a sequence sequence state. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td>context </td></tr>
    <tr><td class="paramname">seq</td><td>sequence pointer </td></tr>
    <tr><td class="paramname">num</td><td>message num </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to msg </dd></dl>

</div>
</div>
<a class="anchor" id="a2ceeeb0b560422f249524024ec37160b"></a><!-- doxytag: member="wsrmapi.c::soap_wsrm_nack" ref="a2ceeeb0b560422f249524024ec37160b" args="(soap_wsrm_sequence_handle seq)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ULONG64 soap_wsrm_nack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence_handle</a>&#160;</td>
          <td class="paramname"><em>seq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the number of non-acknowledged messages sent. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">seq</td><td>sequence handle set by <a class="el" href="wsrmapi_8h.html#a070f3ffaacb8c9b160a7d8a1246a6c9a" title="Creates a new sequence. Sequences are usually created by the sender (client) and confirmed by the rec...">soap_wsrm_create()</a> or <a class="el" href="wsrmapi_8h.html#a426dbfc35357b39b0d84bd21fdbafa12" title="Creates a new sequence by offering suggested WS-RM parameters to the destination. Sequences are usual...">soap_wsrm_create_offer()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the sequence endpoint address </dd></dl>

</div>
</div>
<a class="anchor" id="aece714bf9f13141b0cce8a914ce9709c"></a><!-- doxytag: member="wsrmapi.c::soap_wsrm_num" ref="aece714bf9f13141b0cce8a914ce9709c" args="(soap_wsrm_sequence_handle seq)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ULONG64 soap_wsrm_num </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence_handle</a>&#160;</td>
          <td class="paramname"><em>seq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the current message number of the sequence. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">seq</td><td>sequence handle set by <a class="el" href="wsrmapi_8h.html#a070f3ffaacb8c9b160a7d8a1246a6c9a" title="Creates a new sequence. Sequences are usually created by the sender (client) and confirmed by the rec...">soap_wsrm_create()</a> or <a class="el" href="wsrmapi_8h.html#a426dbfc35357b39b0d84bd21fdbafa12" title="Creates a new sequence by offering suggested WS-RM parameters to the destination. Sequences are usual...">soap_wsrm_create_offer()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the sequence endpoint address </dd></dl>

</div>
</div>
<a class="anchor" id="ab21e11870cb50f0a06b8f3b4bc4cf2ef"></a><!-- doxytag: member="wsrmapi.c::soap_wsrm_num_free" ref="ab21e11870cb50f0a06b8f3b4bc4cf2ef" args="(struct soap *soap, struct soap_wsrm_sequence *seq)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void soap_wsrm_num_free </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence</a> *&#160;</td>
          <td class="paramname"><em>seq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Internal function to deallocate all message number ranges from a sequence state. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td>context </td></tr>
    <tr><td class="paramname">seq</td><td>pointer to sequence </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0438af9292fd010392709375126346ca"></a><!-- doxytag: member="wsrmapi.c::soap_wsrm_num_insert" ref="a0438af9292fd010392709375126346ca" args="(struct soap *soap, struct soap_wsrm_sequence *seq, ULONG64 num)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int soap_wsrm_num_insert </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence</a> *&#160;</td>
          <td class="paramname"><em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ULONG64&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Internal function to insert a message number in the sequence state. Updates the sequence ranges. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">soap</td><td>context </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">seq</td><td>pointer to sequence </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SOAP_OK or error code (out of memory) </dd></dl>

</div>
</div>
<a class="anchor" id="a65f6112c6e361533f7b6443baae09578"></a><!-- doxytag: member="wsrmapi.c::soap_wsrm_num_lookup" ref="a65f6112c6e361533f7b6443baae09578" args="(struct soap *soap, const struct soap_wsrm_sequence *seq, ULONG64 num)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int soap_wsrm_num_lookup </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence</a> *&#160;</td>
          <td class="paramname"><em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ULONG64&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Internal function to look up a message number in the sequence state. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">soap</td><td>context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">seq</td><td>pointer to sequence </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num</td><td>message num to search </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 (not found) 1 (found) </dd></dl>

</div>
</div>
<a class="anchor" id="ae505bc4b6468b034dddc6d5562d5d564"></a><!-- doxytag: member="wsrmapi.c::soap_wsrm_num_size" ref="ae505bc4b6468b034dddc6d5562d5d564" args="(const struct soap_wsrm_sequence *seq)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int soap_wsrm_num_size </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence</a> *&#160;</td>
          <td class="paramname"><em>seq</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Internal function returns the number of message ranges in a sequence state. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">seq</td><td>pointer to sequence </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>number of message ranges </dd></dl>

</div>
</div>
<a class="anchor" id="aaff41127e3a1960010dd0eed252a1779"></a><!-- doxytag: member="wsrmapi.c::soap_wsrm_preparefinalrecv" ref="aaff41127e3a1960010dd0eed252a1779" args="(struct soap *soap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int soap_wsrm_preparefinalrecv </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Internal callback function to override fpreparefinalrecv(). Takes acks returned by response to update the states of the sequences with acknowledgements. Acknowledged messages do not have to be resend and are purged from the sequence states. Also checks if at client-side response message was already received and otherwise records it in the state. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td>context </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SOAP_OK or error code </dd></dl>

</div>
</div>
<a class="anchor" id="a3a1093d90de46a3170cfc9d980c728a1"></a><!-- doxytag: member="wsrmapi.c::soap_wsrm_process_ack" ref="a3a1093d90de46a3170cfc9d980c728a1" args="(struct soap *soap, struct _wsrm__SequenceAcknowledgement *ack)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int soap_wsrm_process_ack </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="struct__wsrm_____sequence_acknowledgement.html">_wsrm__SequenceAcknowledgement</a> *&#160;</td>
          <td class="paramname"><em>ack</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Internal function to purge acknowledged messages as given by wsrm:SequenceAcknowledgement header. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">soap</td><td>context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ack</td><td>from the WS-RM SequenceAcknowledgement header. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SOAP_OK or error code </dd></dl>

</div>
</div>
<a class="anchor" id="a65c7a86eaf7366b9cb9c4759c1f7c061"></a><!-- doxytag: member="wsrmapi.c::soap_wsrm_receiver_fault" ref="a65c7a86eaf7366b9cb9c4759c1f7c061" args="(struct soap *soap, const char *faultstring, const char *faultdetail)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soap_wsrm_receiver_fault </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>faultstring</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>faultdetail</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets receiver SOAP Fault for server faults (can be user defined faults). When called before <a class="el" href="wsrmapi_8h.html#a0304e1219b99929fa576cf12114206eb" title="Server-side check for the presence of WS-Addressing and WS-RM header blocks in the SOAP header...">soap_wsrm_check()</a> in the server operation, terminates the current sequence. Otherwise, the sequence is not terminated. In either case the fault is returned to sender (client) or to the FaultTo server when the WS-Addressing FaultTo header was set by the sender. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">soap</td><td>context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">faultstring</td><td>fault string </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">faultdetail</td><td>detail string </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SOAP_FAULT </dd></dl>

</div>
</div>
<a class="anchor" id="a6cb3621b4a3ab658059000974d7ee96c"></a><!-- doxytag: member="wsrmapi.c::soap_wsrm_receiver_fault_subcode" ref="a6cb3621b4a3ab658059000974d7ee96c" args="(struct soap *soap, const char *faultsubcode, const char *faultstring, const char *faultdetail)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soap_wsrm_receiver_fault_subcode </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>faultsubcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>faultstring</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>faultdetail</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets receiver SOAP Fault (sub)code for server faults (can be user defined faults). When called before <a class="el" href="wsrmapi_8h.html#a0304e1219b99929fa576cf12114206eb" title="Server-side check for the presence of WS-Addressing and WS-RM header blocks in the SOAP header...">soap_wsrm_check()</a> in the server operation, terminates the current sequence. Otherwise, the sequence is not terminated. In either case the fault is returned to sender (client) or to the FaultTo server when the WS-Addressing FaultTo header was set by the sender. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">soap</td><td>context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">faultsubcode</td><td>sub code string </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">faultstring</td><td>fault string </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">faultdetail</td><td>detail string </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SOAP_FAULT </dd></dl>

</div>
</div>
<a class="anchor" id="af7ab54d15beca0118bdffc64520b6589"></a><!-- doxytag: member="wsrmapi.c::soap_wsrm_reply" ref="af7ab54d15beca0118bdffc64520b6589" args="(struct soap *soap, const char *wsa_id, const char *wsa_action)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soap_wsrm_reply </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>wsa_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>wsa_action</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Server-side server operation reply to be performed when the service operation returns. Server operations that support WS-Addressing and WS-RM must call this function to return normally (and allow the response to be relayed). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">soap</td><td>context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wsa_id</td><td>WS-Addressing message ID (optional) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wsa_action</td><td>mandatory WS-Addressing action of the response </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SOAP_OK or error code (and server operation must return this value) </dd></dl>

</div>
</div>
<a class="anchor" id="ad7d6e11c10a16bf032a7af10a8470cd0"></a><!-- doxytag: member="wsrmapi.c::soap_wsrm_reply_num" ref="ad7d6e11c10a16bf032a7af10a8470cd0" args="(struct soap *soap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soap_wsrm_reply_num </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds a WS-RM sequence message number to the next message transmitted. No acks are requested. No WS-Addressing relay. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td>context </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SOAP_OK or error code (and server operation must return this value) </dd></dl>

</div>
</div>
<a class="anchor" id="ad88bd9d375279ec59cbb82ba0e76caf2"></a><!-- doxytag: member="wsrmapi.c::soap_wsrm_reply_request_acks" ref="ad88bd9d375279ec59cbb82ba0e76caf2" args="(struct soap *soap, const char *wsa_id, const char *wsa_action)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soap_wsrm_reply_request_acks </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>wsa_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>wsa_action</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Server-side server operation reply to be performed when the service operation returns. Message acks for the current sequence are requested, but only when client made a create sequence offer. Server operations that support WS-Addressing and WS-RM must call this function or <a class="el" href="wsrmapi_8h.html#af7ab54d15beca0118bdffc64520b6589" title="Server-side server operation reply to be performed when the service operation returns. Server operations that support WS-Addressing and WS-RM must call this function to return normally (and allow the response to be relayed).">soap_wsrm_reply()</a> to return normally (and allow the response to be relayed). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">soap</td><td>context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wsa_id</td><td>WS-Addressing message ID (optional) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wsa_action</td><td>mandatory WS-Addressing action of the response </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SOAP_OK or error code (and server operation must return this value) </dd></dl>

</div>
</div>
<a class="anchor" id="a05857d4bed3b3052e6878f490330277f"></a><!-- doxytag: member="wsrmapi.c::soap_wsrm_request" ref="a05857d4bed3b3052e6878f490330277f" args="(struct soap *soap, soap_wsrm_sequence_handle seq, const char *wsa_id, const char *wsa_action)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soap_wsrm_request </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence_handle</a>&#160;</td>
          <td class="paramname"><em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>wsa_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>wsa_action</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds a WS-RM sequence message number to the next message transmitted to the WS-RM destination and increments the message counter by one. No acks are requested. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">soap</td><td>context </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">seq</td><td>sequence handle set by <a class="el" href="wsrmapi_8h.html#a070f3ffaacb8c9b160a7d8a1246a6c9a" title="Creates a new sequence. Sequences are usually created by the sender (client) and confirmed by the rec...">soap_wsrm_create()</a> or <a class="el" href="wsrmapi_8h.html#a426dbfc35357b39b0d84bd21fdbafa12" title="Creates a new sequence by offering suggested WS-RM parameters to the destination. Sequences are usual...">soap_wsrm_create_offer()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wsa_id</td><td>WS-Addressing message ID (optional, use NULL when omitted) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wsa_action</td><td>mandatory WS-Addressing action of the next message sent </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SOAP_OK or error code </dd></dl>

</div>
</div>
<a class="anchor" id="a7292b4a8e24e767b538e0fb2993a6864"></a><!-- doxytag: member="wsrmapi.c::soap_wsrm_request_acks" ref="a7292b4a8e24e767b538e0fb2993a6864" args="(struct soap *soap, soap_wsrm_sequence_handle seq, const char *wsa_id, const char *wsa_action)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soap_wsrm_request_acks </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence_handle</a>&#160;</td>
          <td class="paramname"><em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>wsa_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>wsa_action</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds a WS-RM sequence message number to the next message transmitted to the WS-RM destination and increments the message counter by one. Message acks for the current sequence are requested. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">soap</td><td>context </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">seq</td><td>sequence handle set by <a class="el" href="wsrmapi_8h.html#a070f3ffaacb8c9b160a7d8a1246a6c9a" title="Creates a new sequence. Sequences are usually created by the sender (client) and confirmed by the rec...">soap_wsrm_create()</a> or <a class="el" href="wsrmapi_8h.html#a426dbfc35357b39b0d84bd21fdbafa12" title="Creates a new sequence by offering suggested WS-RM parameters to the destination. Sequences are usual...">soap_wsrm_create_offer()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wsa_id</td><td>WS-Addressing message ID (optional, use NULL when omitted) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wsa_action</td><td>mandatory WS-Addressing action of the next message sent </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SOAP_OK or error code </dd></dl>

</div>
</div>
<a class="anchor" id="ae5fdeabdc2ec09fb63b27839275598d3"></a><!-- doxytag: member="wsrmapi.c::soap_wsrm_request_num" ref="ae5fdeabdc2ec09fb63b27839275598d3" args="(struct soap *soap, soap_wsrm_sequence_handle seq, const char *wsa_id, const char *wsa_action, ULONG64 num)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soap_wsrm_request_num </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence_handle</a>&#160;</td>
          <td class="paramname"><em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>wsa_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>wsa_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ULONG64&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds a WS-RM sequence message number to the next message transmitted. No acks are requested. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">soap</td><td>context </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">seq</td><td>sequence handle set by <a class="el" href="wsrmapi_8h.html#a070f3ffaacb8c9b160a7d8a1246a6c9a" title="Creates a new sequence. Sequences are usually created by the sender (client) and confirmed by the rec...">soap_wsrm_create()</a> or <a class="el" href="wsrmapi_8h.html#a426dbfc35357b39b0d84bd21fdbafa12" title="Creates a new sequence by offering suggested WS-RM parameters to the destination. Sequences are usual...">soap_wsrm_create_offer()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wsa_id</td><td>WS-Addressing message ID (optional, use NULL when omitted) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wsa_action</td><td>mandatory WS-Addressing action of the next message sent </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num</td><td>WS-RM sequence message number </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SOAP_OK or error code </dd></dl>

</div>
</div>
<a class="anchor" id="af0644e93628d1c450cb3c73fed5afd4f"></a><!-- doxytag: member="wsrmapi.c::soap_wsrm_resend" ref="af0644e93628d1c450cb3c73fed5afd4f" args="(struct soap *soap, soap_wsrm_sequence_handle seq, ULONG64 lower, ULONG64 upper)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soap_wsrm_resend </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence_handle</a>&#160;</td>
          <td class="paramname"><em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ULONG64&#160;</td>
          <td class="paramname"><em>lower</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ULONG64&#160;</td>
          <td class="paramname"><em>upper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Client-side call to resend all non-acknowledged messages that were automatically cached for this sequence. Messages stored in the sequence for retransmission (those that were previously sent but not acknowledged) are resent to the <a class="el" href="wsrmapi_8h.html#a6b6ce73440955d04712c6acb429f536b" title="Returns the endpoint address of the destination service that serves the sequence. Initially set with ...">soap_wsrm_to()</a> address, which was set by <a class="el" href="wsrmapi_8h.html#a070f3ffaacb8c9b160a7d8a1246a6c9a" title="Creates a new sequence. Sequences are usually created by the sender (client) and confirmed by the rec...">soap_wsrm_create()</a> or <a class="el" href="wsrmapi_8h.html#a426dbfc35357b39b0d84bd21fdbafa12" title="Creates a new sequence by offering suggested WS-RM parameters to the destination. Sequences are usual...">soap_wsrm_create_offer()</a>. It is recommended to resend messages after the last message in the sequence was transmitted before closing the sequence. To reduce unnecessary resend attempts, it is recommended to use soap_wsrm_request_ack() with the last message to request acks for messages already delivered. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">soap</td><td>context </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">seq</td><td>sequence handle set by soap_wsrm_create or soap_wsrm_create_offer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lower</td><td>resend message range lower bound (0 for lowest) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">upper</td><td>resend message range upper bound (or 0 for infinite) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SOAP_OK or error code (can be ignored when resends are retried later) </dd></dl>

</div>
</div>
<a class="anchor" id="ad95f4acccaf87b7f2c9f460a5a2d992b"></a><!-- doxytag: member="wsrmapi.c::soap_wsrm_resend_seq" ref="ad95f4acccaf87b7f2c9f460a5a2d992b" args="(struct soap *soap, struct soap_wsrm_sequence *seq, ULONG64 lower, ULONG64 upper)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int soap_wsrm_resend_seq </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence</a> *&#160;</td>
          <td class="paramname"><em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ULONG64&#160;</td>
          <td class="paramname"><em>lower</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ULONG64&#160;</td>
          <td class="paramname"><em>upper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Internal function to resend unacknowledged messages of a sequence given a range of message numbers. Used by <a class="el" href="wsrmapi_8h.html#af0644e93628d1c450cb3c73fed5afd4f" title="Client-side call to resend all non-acknowledged messages that were automatically cached for this sequ...">soap_wsrm_resend()</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">soap</td><td>context </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">seq</td><td>sequence handle set by <a class="el" href="wsrmapi_8h.html#a070f3ffaacb8c9b160a7d8a1246a6c9a" title="Creates a new sequence. Sequences are usually created by the sender (client) and confirmed by the rec...">soap_wsrm_create()</a> or <a class="el" href="wsrmapi_8h.html#a426dbfc35357b39b0d84bd21fdbafa12" title="Creates a new sequence by offering suggested WS-RM parameters to the destination. Sequences are usual...">soap_wsrm_create_offer()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lower</td><td>resend message range lower bound (0 for lowest) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">upper</td><td>resend message range upper bound (or 0 for infinite) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SOAP_OK or error code (can be ignored to continue sequence) </dd></dl>

</div>
</div>
<a class="anchor" id="ac7ff6d902d415e409bd46096022e1eac"></a><!-- doxytag: member="wsrmapi.c::soap_wsrm_send" ref="ac7ff6d902d415e409bd46096022e1eac" args="(struct soap *soap, const char *buf, size_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int soap_wsrm_send </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Internal callback function to override fsend(). When the wsrm plugin is enabled, saves the message to the current sequence that is created at the client side. Allows unacknowledged messages to be resend with <a class="el" href="wsrmapi_8h.html#af0644e93628d1c450cb3c73fed5afd4f" title="Client-side call to resend all non-acknowledged messages that were automatically cached for this sequ...">soap_wsrm_resend()</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">soap</td><td>context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>message data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>message data length </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SOAP_OK or error code </dd></dl>

</div>
</div>
<a class="anchor" id="af2bcd68f3810d632bef61ecfe86e1e5f"></a><!-- doxytag: member="wsrmapi.c::soap_wsrm_sender_fault" ref="af2bcd68f3810d632bef61ecfe86e1e5f" args="(struct soap *soap, const char *faultstring, const char *faultdetail)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soap_wsrm_sender_fault </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>faultstring</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>faultdetail</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets sender SOAP Fault for server faults (can be user defined faults). When called before <a class="el" href="wsrmapi_8h.html#a0304e1219b99929fa576cf12114206eb" title="Server-side check for the presence of WS-Addressing and WS-RM header blocks in the SOAP header...">soap_wsrm_check()</a> in the server operation, terminates the current sequence. Otherwise, the sequence is not terminated. In either case the fault is returned to sender (client) or to the FaultTo server when the WS-Addressing FaultTo header was set by the sender. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">soap</td><td>context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">faultstring</td><td>fault string </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">faultdetail</td><td>detail string </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SOAP_FAULT </dd></dl>

</div>
</div>
<a class="anchor" id="a94a53920fbe164b32905a34a73317ac6"></a><!-- doxytag: member="wsrmapi.c::soap_wsrm_sender_fault_subcode" ref="a94a53920fbe164b32905a34a73317ac6" args="(struct soap *soap, const char *faultsubcode, const char *faultstring, const char *faultdetail)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soap_wsrm_sender_fault_subcode </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>faultsubcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>faultstring</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>faultdetail</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets sender SOAP Fault (sub)code for server faults (can be user defined faults). When called before <a class="el" href="wsrmapi_8h.html#a0304e1219b99929fa576cf12114206eb" title="Server-side check for the presence of WS-Addressing and WS-RM header blocks in the SOAP header...">soap_wsrm_check()</a> in the server operation, terminates the current sequence. Otherwise, the sequence is not terminated. In either case the fault is returned to sender (client) or to the FaultTo server when the WS-Addressing FaultTo header was set by the sender. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">soap</td><td>context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">faultsubcode</td><td>sub code string </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">faultstring</td><td>fault string </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">faultdetail</td><td>detail string </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SOAP_FAULT </dd></dl>

</div>
</div>
<a class="anchor" id="a21c32d0aaadf26d86170098a890c0e54"></a><!-- doxytag: member="wsrmapi.c::soap_wsrm_seq_free" ref="a21c32d0aaadf26d86170098a890c0e54" args="(struct soap *soap, soap_wsrm_sequence_handle seq)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void soap_wsrm_seq_free </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence_handle</a>&#160;</td>
          <td class="paramname"><em>seq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Must be called to free the sequence allocated by <a class="el" href="wsrmapi_8h.html#a070f3ffaacb8c9b160a7d8a1246a6c9a" title="Creates a new sequence. Sequences are usually created by the sender (client) and confirmed by the rec...">soap_wsrm_create()</a> or by <a class="el" href="wsrmapi_8h.html#a426dbfc35357b39b0d84bd21fdbafa12" title="Creates a new sequence by offering suggested WS-RM parameters to the destination. Sequences are usual...">soap_wsrm_create_offer()</a>. Sequence handles are not automatically reclaimed by the engine. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td>context </td></tr>
    <tr><td class="paramname">seq</td><td>sequence handle set by <a class="el" href="wsrmapi_8h.html#a070f3ffaacb8c9b160a7d8a1246a6c9a" title="Creates a new sequence. Sequences are usually created by the sender (client) and confirmed by the rec...">soap_wsrm_create()</a> or <a class="el" href="wsrmapi_8h.html#a426dbfc35357b39b0d84bd21fdbafa12" title="Creates a new sequence by offering suggested WS-RM parameters to the destination. Sequences are usual...">soap_wsrm_create_offer()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a50f1196273d87a048697ae98a6e34f73"></a><!-- doxytag: member="wsrmapi.c::soap_wsrm_seq_insert" ref="a50f1196273d87a048697ae98a6e34f73" args="(struct soap *soap, struct soap_wsrm_data *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static struct <a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence</a> * soap_wsrm_seq_insert </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structsoap__wsrm__data.html">soap_wsrm_data</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static, read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Internal function to create a new local sequence state. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td>context </td></tr>
    <tr><td class="paramname">data</td><td>plugin </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>sequence or NULL </dd></dl>

</div>
</div>
<a class="anchor" id="a41af4d5508da70c827b04c8e58907365"></a><!-- doxytag: member="wsrmapi.c::soap_wsrm_seq_lookup" ref="a41af4d5508da70c827b04c8e58907365" args="(const struct soap_wsrm_data *data, const char *id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static struct <a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence</a> * soap_wsrm_seq_lookup </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structsoap__wsrm__data.html">soap_wsrm_data</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static, read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Internal function to look up sequence given its id. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">data</td><td>plugin </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>identifier string </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>sequence or NULL </dd></dl>

</div>
</div>
<a class="anchor" id="ae8fd48312ea83f82957725d6080a17ac"></a><!-- doxytag: member="wsrmapi.c::soap_wsrm_seq_lookup_ack" ref="ae8fd48312ea83f82957725d6080a17ac" args="(const struct soap_wsrm_data *data, const char *id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static struct <a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence</a> * soap_wsrm_seq_lookup_ack </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structsoap__wsrm__data.html">soap_wsrm_data</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static, read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Internal function to look up sequence given its acksid. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">data</td><td>plugin </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>identifier string </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>sequence or NULL </dd></dl>

</div>
</div>
<a class="anchor" id="a52fd48a4b0e18498c7a7b64fd9f97c91"></a><!-- doxytag: member="wsrmapi.c::soap_wsrm_seq_newid" ref="a52fd48a4b0e18498c7a7b64fd9f97c91" args="(struct soap *soap, struct soap_wsrm_data *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static const char * soap_wsrm_seq_newid </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structsoap__wsrm__data.html">soap_wsrm_data</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Internal function to generate a new sequence identifier. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td>context </td></tr>
    <tr><td class="paramname">data</td><td>plugin </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>sequence identifier string </dd></dl>

</div>
</div>
<a class="anchor" id="a78a2fa23790452bac71a5f072f8b724f"></a><!-- doxytag: member="wsrmapi.c::soap_wsrm_seq_terminated" ref="a78a2fa23790452bac71a5f072f8b724f" args="(struct soap *soap, struct soap_wsrm_sequence *seq)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int soap_wsrm_seq_terminated </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence</a> *&#160;</td>
          <td class="paramname"><em>seq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Internal function to check if a sequence is terminated or needs to be terminated when expired. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td>context </td></tr>
    <tr><td class="paramname">seq</td><td>pointer to sequence </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 (not terminated) or 1 (terminated) </dd></dl>

</div>
</div>
<a class="anchor" id="a101b336e539b0527bcf5bc1b2091d94f"></a><!-- doxytag: member="wsrmapi.c::soap_wsrm_set_ack" ref="a101b336e539b0527bcf5bc1b2091d94f" args="(struct soap *soap, struct soap_wsrm_sequence *seq, struct _wsrm__SequenceAcknowledgement *ack)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int soap_wsrm_set_ack </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence</a> *&#160;</td>
          <td class="paramname"><em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="struct__wsrm_____sequence_acknowledgement.html">_wsrm__SequenceAcknowledgement</a> *&#160;</td>
          <td class="paramname"><em>ack</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Internal function called by <a class="el" href="wsrmapi_8c.html#acfeb9cf37279d4bf6f436a2d0a591e6f" title="Internal function to add SequenceAcknowledgement headers for AckRequested. Sends acknowledgements to ...">soap_wsrm_add_acks()</a> to populate the SequenceAcknowledgement header block. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">soap</td><td>context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">seq</td><td>pointer to sequence </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ack</td><td>pointer to SequenceAcknowledgement to populate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aed55a951561e63b74699003f423e6e4d"></a><!-- doxytag: member="wsrmapi.c::soap_wsrm_terminate" ref="aed55a951561e63b74699003f423e6e4d" args="(struct soap *soap, soap_wsrm_sequence_handle seq, const char *wsa_id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soap_wsrm_terminate </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence_handle</a>&#160;</td>
          <td class="paramname"><em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>wsa_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Terminates the sequence. No new messages should be send and no resends should be tried. Usually done after <a class="el" href="wsrmapi_8h.html#a663e39e46e4fb291ee0f9af8a0badac5" title="Closes the sequence, but does not yet terminate it. No new messages should be send, but messages can be resend with soap_wsrm_resend() if desired.">soap_wsrm_close()</a> or any time to terminate the sequence prematurely. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">soap</td><td>context </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">seq</td><td>sequence handle set by soap_wsrm_create or soap_wsrm_create_offer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wsa_id</td><td>WS-Addressing message ID (optional) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SOAP_OK or error code </dd></dl>

</div>
</div>
<a class="anchor" id="a3ba123420e7bb4528588fbbc4a3795f8"></a><!-- doxytag: member="wsrmapi.c::soap_wsrm_to" ref="a3ba123420e7bb4528588fbbc4a3795f8" args="(soap_wsrm_sequence_handle seq)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* soap_wsrm_to </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence_handle</a>&#160;</td>
          <td class="paramname"><em>seq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the endpoint address of the destination service that serves the sequence. Initially set with soap_wsrm_create or soap_wsrm_create_offer. HTTP 307 Temporary Redirect can change the endpoint during the lifetime of a message sequence. Thus, this function returns the most recent endpoint binding that can be used to send message to the server endpoint. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">seq</td><td>sequence handle set by <a class="el" href="wsrmapi_8h.html#a070f3ffaacb8c9b160a7d8a1246a6c9a" title="Creates a new sequence. Sequences are usually created by the sender (client) and confirmed by the rec...">soap_wsrm_create()</a> or <a class="el" href="wsrmapi_8h.html#a426dbfc35357b39b0d84bd21fdbafa12" title="Creates a new sequence by offering suggested WS-RM parameters to the destination. Sequences are usual...">soap_wsrm_create_offer()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the sequence endpoint address </dd></dl>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="a2f5b88f6da2708c658e230610ca380ab"></a><!-- doxytag: member="wsrmapi.c::soap_wsrm_id" ref="a2f5b88f6da2708c658e230610ca380ab" args="[]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char <a class="el" href="wsrmapi_8c.html#a2f5b88f6da2708c658e230610ca380ab">soap_wsrm_id</a>[] = SOAP_WSRM_ID</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Plugin identification for plugin registry </p>

</div>
</div>
<a class="anchor" id="a3bbcb03227062fef356ef38dd45f0924"></a><!-- doxytag: member="wsrmapi.c::soap_wsrm_idname" ref="a3bbcb03227062fef356ef38dd45f0924" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* <a class="el" href="wsrmapi_8c.html#a3bbcb03227062fef356ef38dd45f0924">soap_wsrm_idname</a> = NULL</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac68843c070e732b20450b4e9bdfb91fe"></a><!-- doxytag: member="wsrmapi.c::soap_wsrm_idnum" ref="ac68843c070e732b20450b4e9bdfb91fe" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long <a class="el" href="wsrmapi_8c.html#ac68843c070e732b20450b4e9bdfb91fe">soap_wsrm_idnum</a> = 0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a1b87a809162eab1f088457a69765dfa6"></a><!-- doxytag: member="wsrmapi.c::soap_wsrm_session" ref="a1b87a809162eab1f088457a69765dfa6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence</a>* <a class="el" href="wsrmapi_8c.html#a1b87a809162eab1f088457a69765dfa6">soap_wsrm_session</a> = NULL<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sequence session database </p>

</div>
</div>
<a class="anchor" id="a1f675d133185cc7a40b0af8e0d5ffdcb"></a><!-- doxytag: member="wsrmapi.c::soap_wsrm_session_lock" ref="a1f675d133185cc7a40b0af8e0d5ffdcb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MUTEX_TYPE <a class="el" href="wsrmapi_8c.html#a1f675d133185cc7a40b0af8e0d5ffdcb">soap_wsrm_session_lock</a> = MUTEX_INITIALIZER<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sequence session database lock </p>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Sat Oct 22 2011 15:04:50 for gSOAP WS-ReliableMessaging by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
